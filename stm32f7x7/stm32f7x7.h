#pragma once

// Generated enums and structures for device STM32F7x7 version 1.9
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ           

	//  Cortex-CM7 Processor Exceptions Numbers 
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt                           
	Reserved_3_IRQn       = -13,
	MemoryManagement_IRQn = -12, // 4 Memory Management Interrupt            
	BusFault_IRQn         = -11, // 5 Bus Fault Interrupt                    
	UsageFault_IRQn       = -10, // 6 Usage Fault Interrupt                  
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 SV Call Interrupt                     
	DebugMonitor_IRQn     = -4, // 12 Debug Monitor Interrupt               
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Pend SV Interrupt                     
	SysTick_IRQn          = -1, // 15 System Tick Interrupt                 

	//  Device specific Interrupt Numbers
	WWDG_IRQn = 0, // Window Watchdog interrupt
	PVD_IRQn = 1, // PVD through EXTI line detection
	TAMP_STAMP_IRQn = 2, // Tamper and TimeStamp interrupts through the EXTI line
	RTC_WKUP_IRQn = 3, // RTC Tamper or TimeStamp /CSS on LSE through EXTI line 19 interrupts
	FLASH_IRQn = 4, // Flash global interrupt
	RCC_IRQn = 5, // RCC global interrupt
	EXTI0_IRQn = 6, // EXTI Line0 interrupt
	EXTI1_IRQn = 7, // EXTI Line1 interrupt
	EXTI2_IRQn = 8, // EXTI Line2 interrupt
	EXTI3_IRQn = 9, // EXTI Line3 interrupt
	EXTI4_IRQn = 10, // EXTI Line4 interrupt
	DMA1_Stream0_IRQn = 11, // DMA1 Stream0 global interrupt
	DMA1_Stream1_IRQn = 12, // DMA1 Stream1 global interrupt
	DMA1_Stream2_IRQn = 13, // DMA1 Stream2 global interrupt
	DMA1_Stream3_IRQn = 14, // DMA1 Stream3 global interrupt
	DMA1_Stream4_IRQn = 15, // DMA1 Stream4 global interrupt
	DMA1_Stream5_IRQn = 16, // DMA1 Stream5 global interrupt
	DMA1_Stream6_IRQn = 17, // DMA1 Stream6 global interrupt
	ADC_IRQn = 18, // ADC1 global interrupt
	CAN1_TX_IRQn = 19, // CAN1 TX interrupts
	CAN1_RX0_IRQn = 20, // CAN1 RX0 interrupts
	CAN1_RX1_IRQn = 21, // CAN1 RX1 interrupts
	CAN1_SCE_IRQn = 22, // CAN1 SCE interrupt
	EXTI9_5_IRQn = 23, // EXTI Line[9:5] interrupts
	TIM1_BRK_TIM9_IRQn = 24, // TIM1 Break interrupt and TIM9 global interrupt
	TIM1_UP_TIM10_IRQn = 25, // TIM1 Update interrupt and TIM10
	TIM1_TRG_COM_TIM11_IRQn = 26, // TIM1 Trigger and Commutation interrupts and TIM11 global interrupt
	TIM1_CC_IRQn = 27, // TIM1 Capture Compare interrupt
	TIM2_IRQn = 28, // TIM2 global interrupt
	TIM3_IRQn = 29, // TIM3 global interrupt
	TIM4_IRQn = 30, // TIM4 global interrupt
	I2C1_EV_IRQn = 31, // I2C1 event interrupt
	I2C1_ER_IRQn = 32, // I2C1 error interrupt
	I2C2_EV_IRQn = 33, // I2C2 event interrupt
	I2C2_ER_IRQn = 34, // I2C2 error interrupt
	SPI1_IRQn = 35, // SPI1 global interrupt
	SPI2_IRQn = 36, // SPI2 global interrupt
	USART1_IRQn = 37, // USART1 global interrupt
	USART2_IRQn = 38, // USART2 global interrupt
	USART3_IRQn = 39, // USART3 global interrupt
	EXTI15_10_IRQn = 40, // EXTI Line[15:10] interrupts
	RTC_ALARM_IRQn = 41, // RTC alarms through EXTI line 18 interrupts
	OTG_FS_WKUP_IRQn = 42, // USB On-The-Go FS Wakeup through EXTI line interrupt
	TIM8_BRK_TIM12_IRQn = 43, // TIM8 Break interrupt and TIM12 global interrupt
	TIM8_UP_TIM13_IRQn = 44, // TIM8 Update interrupt and TIM13 global interrupt
	TIM8_TRG_COM_TIM14_IRQn = 45, // TIM8 Trigger and Commutation interrupts and TIM14 global interrupt
	TIM8_CC_IRQn = 46, // TIM8 Capture Compare interrupt
	DMA1_Stream7_IRQn = 47, // DMA1 Stream7 global interrupt
	FMC_IRQn = 48, // FMC global interrupt
	SDMMC1_IRQn = 49, // SDMMC1 global interrupt
	TIM5_IRQn = 50, // TIM5 global interrupt
	SPI3_IRQn = 51, // SPI3 global interrupt
	UART4_IRQn = 52, // UART4 global interrupt
	UART5_IRQn = 53, // UART5 global interrupt
	TIM6_DAC_IRQn = 54, // TIM6 global interrupt, DAC1 and DAC2 underrun error interrupt
	TIM7_IRQn = 55, // TIM7 global interrupt
	DMA2_Stream0_IRQn = 56, // DMA2 Stream0 global interrupt
	DMA2_Stream1_IRQn = 57, // DMA2 Stream1 global interrupt
	DMA2_Stream2_IRQn = 58, // DMA2 Stream2 global interrupt
	DMA2_Stream3_IRQn = 59, // DMA2 Stream3 global interrupt
	DMA2_Stream4_IRQn = 60, // DMA2 Stream4 global interrupt
	ETH_IRQn = 61, // Ethernet global interrupt
	ETH_WKUP_IRQn = 62, // Ethernet Wakeup through EXTI line
	CAN2_TX_IRQn = 63, // CAN2 TX interrupts
	CAN2_RX0_IRQn = 64, // CAN2 RX0 interrupts
	CAN2_RX1_IRQn = 65, // CAN2 RX1 interrupts
	CAN2_SCE_IRQn = 66, // CAN2 SCE interrupt
	OTG_FS_IRQn = 67, // USB On The Go FS global interrupt
	DMA2_Stream5_IRQn = 68, // DMA2 Stream5 global interrupt
	DMA2_Stream6_IRQn = 69, // DMA2 Stream6 global interrupt
	DMA2_Stream7_IRQn = 70, // DMA2 Stream7 global interrupt
	USART6_IRQn = 71, // USART6 global interrupt
	I2C3_EV_IRQn = 72, // I2C3 event interrupt
	I2C3_ER_IRQn = 73, // I2C3 error interrupt
	OTG_HS_EP1_OUT_IRQn = 74, // USB On The Go HS End Point 1 Out global interrupt
	OTG_HS_EP1_IN_IRQn = 75, // USB On The Go HS End Point 1 In global interrupt
	OTG_HS_WKUP_IRQn = 76, // USB On The Go HS Wakeup through EXTI interrupt
	OTG_HS_IRQn = 77, // USB On The Go HS global interrupt
	DCMI_IRQn = 78, // DCMI global interrupt
	CRYP_IRQn = 79, // CRYP crypto global interrupt
	HASH_RNG_IRQn = 80, // Hash and Rng global interrupt
	FPU_IRQn = 81, // Floating point unit interrupt
	UART7_IRQn = 82, // UART7 global interrupt
	UART8_IRQn = 83, // UART 8 global interrupt
	SPI4_IRQn = 84, // SPI 4 global interrupt
	SPI5_IRQn = 85, // SPI 5 global interrupt
	SPI6_IRQn = 86, // SPI 6 global interrupt
	SAI1_IRQn = 87, // SAI1 global interrupt
	LCD_TFT_IRQn = 88, // LTDC global interrupt
	LCD_TFT_ER_IRQn = 89, // LCD-TFT global Error interrupt
	DMA2D_IRQn = 90, // DMA2D global interrupt
	SAI2_IRQn = 91, // SAI2 global interrupt
	QuadSPI_IRQn = 92, // QuadSPI global interrupt
	LP_Timer1_IRQn = 93, // LP Timer1 global interrupt
	I2C4_EV_IRQn = 95, // I2C4 event interrupt
	I2C4_ER_IRQn = 96, // I2C4 Error interrupt
	SPDIFRX_IRQn = 97, // SPDIFRX global interrupt
	DSIHOST_IRQn = 98, // DSI host global interrupt
	DFSDM1_FLT0_IRQn = 99, // DFSDM1 Filter 0 global interrupt
	DFSDM1_FLT1_IRQn = 100, // DFSDM1 Filter 1 global interrupt
	DFSDM1_FLT2_IRQn = 101, // DFSDM1 Filter 2 global interrupt
	DFSDM1_FLT3_IRQn = 102, // DFSDM1 Filter 3 global interrupt
	SDMMC2_IRQn = 103, // SDMMC2 global interrupt
	CAN3_TX_IRQn = 104, // CAN3 TX interrupt
	CAN3_RX0_IRQn = 105, // CAN3 RX0 interrupt
	CAN3_RX1_IRQn = 106, // CAN3 RX1 interrupt
	CAN3_SCE_IRQn = 107, // CAN3 SCE interrupt
	JPEG_IRQn = 108, // JPEG global interrupt
	MDIOS_IRQn = 109, // MDIO slave global interrupt
};


#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions


/* Access control */
struct AC_Type {
	__IO uint8_t ITCMCR; // @0 Instruction and Data Tightly-Coupled Memory Control Registers
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t DTCMCR; // @4 Instruction and Data Tightly-Coupled Memory Control Registers
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t AHBPCR; // @8 AHBP Control register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint8_t CACR; // @12 Auxiliary Cache Control register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t AHBSCR; // @16 AHB Slave Control register
	 uint8_t RESERVED4[6]; // @18 
	__IO uint16_t ABFSR; // @24 Auxiliary Bus Fault Status register
};

// AC->ITCMCR Instruction and Data Tightly-Coupled Memory Control Registers
enum {
	AC_ITCMCR_SZ = ((1UL<<4)-1) << 3, // SZ
	AC_ITCMCR_RETEN = 1UL<<2, // RETEN
	AC_ITCMCR_RMW = 1UL<<1, // RMW
	AC_ITCMCR_EN = 1UL<<0, // EN		
};
inline void ac_itcmcr_set_sz(struct AC_Type* p, uint32_t val) { p->ITCMCR = (p->ITCMCR & ~AC_ITCMCR_SZ) | ((val<<3) & AC_ITCMCR_SZ); }
inline uint32_t ac_itcmcr_get_sz(struct AC_Type* p) { return (p->ITCMCR & AC_ITCMCR_SZ) >> 3 ; }

// AC->DTCMCR Instruction and Data Tightly-Coupled Memory Control Registers
enum {
	AC_DTCMCR_SZ = ((1UL<<4)-1) << 3, // SZ
	AC_DTCMCR_RETEN = 1UL<<2, // RETEN
	AC_DTCMCR_RMW = 1UL<<1, // RMW
	AC_DTCMCR_EN = 1UL<<0, // EN		
};
inline void ac_dtcmcr_set_sz(struct AC_Type* p, uint32_t val) { p->DTCMCR = (p->DTCMCR & ~AC_DTCMCR_SZ) | ((val<<3) & AC_DTCMCR_SZ); }
inline uint32_t ac_dtcmcr_get_sz(struct AC_Type* p) { return (p->DTCMCR & AC_DTCMCR_SZ) >> 3 ; }

// AC->AHBPCR AHBP Control register
enum {
	AC_AHBPCR_SZ = ((1UL<<3)-1) << 1, // SZ
	AC_AHBPCR_EN = 1UL<<0, // EN		
};
inline void ac_ahbpcr_set_sz(struct AC_Type* p, uint32_t val) { p->AHBPCR = (p->AHBPCR & ~AC_AHBPCR_SZ) | ((val<<1) & AC_AHBPCR_SZ); }
inline uint32_t ac_ahbpcr_get_sz(struct AC_Type* p) { return (p->AHBPCR & AC_AHBPCR_SZ) >> 1 ; }

// AC->CACR Auxiliary Cache Control register
enum {
	AC_CACR_FORCEWT = 1UL<<2, // FORCEWT
	AC_CACR_ECCEN = 1UL<<1, // ECCEN
	AC_CACR_SIWT = 1UL<<0, // SIWT		
};

// AC->AHBSCR AHB Slave Control register
enum {
	AC_AHBSCR_INITCOUNT = ((1UL<<5)-1) << 11, // INITCOUNT
	AC_AHBSCR_TPRI = ((1UL<<9)-1) << 2, // TPRI
	AC_AHBSCR_CTL = ((1UL<<2)-1) << 0, // CTL		
};
inline void ac_ahbscr_set_initcount(struct AC_Type* p, uint32_t val) { p->AHBSCR = (p->AHBSCR & ~AC_AHBSCR_INITCOUNT) | ((val<<11) & AC_AHBSCR_INITCOUNT); }
inline void ac_ahbscr_set_tpri(struct AC_Type* p, uint32_t val) { p->AHBSCR = (p->AHBSCR & ~AC_AHBSCR_TPRI) | ((val<<2) & AC_AHBSCR_TPRI); }
inline void ac_ahbscr_set_ctl(struct AC_Type* p, uint32_t val) { p->AHBSCR = (p->AHBSCR & ~AC_AHBSCR_CTL) | ((val<<0) & AC_AHBSCR_CTL); }
inline uint32_t ac_ahbscr_get_initcount(struct AC_Type* p) { return (p->AHBSCR & AC_AHBSCR_INITCOUNT) >> 11 ; }
inline uint32_t ac_ahbscr_get_tpri(struct AC_Type* p) { return (p->AHBSCR & AC_AHBSCR_TPRI) >> 2 ; }
inline uint32_t ac_ahbscr_get_ctl(struct AC_Type* p) { return (p->AHBSCR & AC_AHBSCR_CTL) >> 0 ; }

// AC->ABFSR Auxiliary Bus Fault Status register
enum {
	AC_ABFSR_AXIMTYPE = ((1UL<<2)-1) << 8, // AXIMTYPE
	AC_ABFSR_EPPB = 1UL<<4, // EPPB
	AC_ABFSR_AXIM = 1UL<<3, // AXIM
	AC_ABFSR_AHBP = 1UL<<2, // AHBP
	AC_ABFSR_DTCM = 1UL<<1, // DTCM
	AC_ABFSR_ITCM = 1UL<<0, // ITCM		
};
inline void ac_abfsr_set_aximtype(struct AC_Type* p, uint32_t val) { p->ABFSR = (p->ABFSR & ~AC_ABFSR_AXIMTYPE) | ((val<<8) & AC_ABFSR_AXIMTYPE); }
inline uint32_t ac_abfsr_get_aximtype(struct AC_Type* p) { return (p->ABFSR & AC_ABFSR_AXIMTYPE) >> 8 ; }

/* Analog-to-digital converter */
struct ADC1_Type {
	__IO uint8_t SR; // @0 status register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CR1; // @4 control register 1
	__IO uint32_t CR2; // @8 control register 2
	__IO uint32_t SMPR1; // @12 sample time register 1
	__IO uint32_t SMPR2; // @16 sample time register 2
	__IO uint16_t JOFR1; // @20 injected channel data offset register x
	 uint8_t RESERVED1[2]; // @22 
	__IO uint16_t JOFR2; // @24 injected channel data offset register x
	 uint8_t RESERVED2[2]; // @26 
	__IO uint16_t JOFR3; // @28 injected channel data offset register x
	 uint8_t RESERVED3[2]; // @30 
	__IO uint16_t JOFR4; // @32 injected channel data offset register x
	 uint8_t RESERVED4[2]; // @34 
	__IO uint16_t HTR; // @36 watchdog higher threshold register
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t LTR; // @40 watchdog lower threshold register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint32_t SQR1; // @44 regular sequence register 1
	__IO uint32_t SQR2; // @48 regular sequence register 2
	__IO uint32_t SQR3; // @52 regular sequence register 3
	__IO uint32_t JSQR; // @56 injected sequence register
	__I uint16_t JDR1; // @60 injected data register x
	 uint8_t RESERVED7[2]; // @62 
	__I uint16_t JDR2; // @64 injected data register x
	 uint8_t RESERVED8[2]; // @66 
	__I uint16_t JDR3; // @68 injected data register x
	 uint8_t RESERVED9[2]; // @70 
	__I uint16_t JDR4; // @72 injected data register x
	 uint8_t RESERVED10[2]; // @74 
	__I uint16_t DR; // @76 regular data register
};

// ADC1->SR status register
enum {
	ADC1_SR_OVR = 1UL<<5, // Overrun
	ADC1_SR_STRT = 1UL<<4, // Regular channel start flag
	ADC1_SR_JSTRT = 1UL<<3, // Injected channel start flag
	ADC1_SR_JEOC = 1UL<<2, // Injected channel end of conversion
	ADC1_SR_EOC = 1UL<<1, // Regular channel end of conversion
	ADC1_SR_AWD = 1UL<<0, // Analog watchdog flag		
};

// ADC1->CR1 control register 1
enum {
	ADC1_CR1_OVRIE = 1UL<<26, // Overrun interrupt enable
	ADC1_CR1_RES = ((1UL<<2)-1) << 24, // Resolution
	ADC1_CR1_AWDEN = 1UL<<23, // Analog watchdog enable on regular channels
	ADC1_CR1_JAWDEN = 1UL<<22, // Analog watchdog enable on injected channels
	ADC1_CR1_DISCNUM = ((1UL<<3)-1) << 13, // Discontinuous mode channel count
	ADC1_CR1_JDISCEN = 1UL<<12, // Discontinuous mode on injected channels
	ADC1_CR1_DISCEN = 1UL<<11, // Discontinuous mode on regular channels
	ADC1_CR1_JAUTO = 1UL<<10, // Automatic injected group conversion
	ADC1_CR1_AWDSGL = 1UL<<9, // Enable the watchdog on a single channel in scan mode
	ADC1_CR1_SCAN = 1UL<<8, // Scan mode
	ADC1_CR1_JEOCIE = 1UL<<7, // Interrupt enable for injected channels
	ADC1_CR1_AWDIE = 1UL<<6, // Analog watchdog interrupt enable
	ADC1_CR1_EOCIE = 1UL<<5, // Interrupt enable for EOC
	ADC1_CR1_AWDCH = ((1UL<<5)-1) << 0, // Analog watchdog channel select bits		
};
inline void adc1_cr1_set_res(struct ADC1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~ADC1_CR1_RES) | ((val<<24) & ADC1_CR1_RES); }
inline void adc1_cr1_set_discnum(struct ADC1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~ADC1_CR1_DISCNUM) | ((val<<13) & ADC1_CR1_DISCNUM); }
inline void adc1_cr1_set_awdch(struct ADC1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~ADC1_CR1_AWDCH) | ((val<<0) & ADC1_CR1_AWDCH); }
inline uint32_t adc1_cr1_get_res(struct ADC1_Type* p) { return (p->CR1 & ADC1_CR1_RES) >> 24 ; }
inline uint32_t adc1_cr1_get_discnum(struct ADC1_Type* p) { return (p->CR1 & ADC1_CR1_DISCNUM) >> 13 ; }
inline uint32_t adc1_cr1_get_awdch(struct ADC1_Type* p) { return (p->CR1 & ADC1_CR1_AWDCH) >> 0 ; }

// ADC1->CR2 control register 2
enum {
	ADC1_CR2_SWSTART = 1UL<<30, // Start conversion of regular channels
	ADC1_CR2_EXTEN = ((1UL<<2)-1) << 28, // External trigger enable for regular channels
	ADC1_CR2_EXTSEL = ((1UL<<4)-1) << 24, // External event select for regular group
	ADC1_CR2_JSWSTART = 1UL<<22, // Start conversion of injected channels
	ADC1_CR2_JEXTEN = ((1UL<<2)-1) << 20, // External trigger enable for injected channels
	ADC1_CR2_JEXTSEL = ((1UL<<4)-1) << 16, // External event select for injected group
	ADC1_CR2_ALIGN = 1UL<<11, // Data alignment
	ADC1_CR2_EOCS = 1UL<<10, // End of conversion selection
	ADC1_CR2_DDS = 1UL<<9, // DMA disable selection (for single ADC mode)
	ADC1_CR2_DMA = 1UL<<8, // Direct memory access mode (for single ADC mode)
	ADC1_CR2_CONT = 1UL<<1, // Continuous conversion
	ADC1_CR2_ADON = 1UL<<0, // A/D Converter ON / OFF		
};
inline void adc1_cr2_set_exten(struct ADC1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~ADC1_CR2_EXTEN) | ((val<<28) & ADC1_CR2_EXTEN); }
inline void adc1_cr2_set_extsel(struct ADC1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~ADC1_CR2_EXTSEL) | ((val<<24) & ADC1_CR2_EXTSEL); }
inline void adc1_cr2_set_jexten(struct ADC1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~ADC1_CR2_JEXTEN) | ((val<<20) & ADC1_CR2_JEXTEN); }
inline void adc1_cr2_set_jextsel(struct ADC1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~ADC1_CR2_JEXTSEL) | ((val<<16) & ADC1_CR2_JEXTSEL); }
inline uint32_t adc1_cr2_get_exten(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_EXTEN) >> 28 ; }
inline uint32_t adc1_cr2_get_extsel(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_EXTSEL) >> 24 ; }
inline uint32_t adc1_cr2_get_jexten(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_JEXTEN) >> 20 ; }
inline uint32_t adc1_cr2_get_jextsel(struct ADC1_Type* p) { return (p->CR2 & ADC1_CR2_JEXTSEL) >> 16 ; }

// ADC1->JOFR1 injected channel data offset register x
enum {
	ADC1_JOFR1_JOFFSET1 = ((1UL<<12)-1) << 0, // Data offset for injected channel x		
};
inline void adc1_jofr1_set_joffset1(struct ADC1_Type* p, uint32_t val) { p->JOFR1 = (p->JOFR1 & ~ADC1_JOFR1_JOFFSET1) | ((val<<0) & ADC1_JOFR1_JOFFSET1); }
inline uint32_t adc1_jofr1_get_joffset1(struct ADC1_Type* p) { return (p->JOFR1 & ADC1_JOFR1_JOFFSET1) >> 0 ; }

// ADC1->JOFR2 injected channel data offset register x
enum {
	ADC1_JOFR2_JOFFSET2 = ((1UL<<12)-1) << 0, // Data offset for injected channel x		
};
inline void adc1_jofr2_set_joffset2(struct ADC1_Type* p, uint32_t val) { p->JOFR2 = (p->JOFR2 & ~ADC1_JOFR2_JOFFSET2) | ((val<<0) & ADC1_JOFR2_JOFFSET2); }
inline uint32_t adc1_jofr2_get_joffset2(struct ADC1_Type* p) { return (p->JOFR2 & ADC1_JOFR2_JOFFSET2) >> 0 ; }

// ADC1->JOFR3 injected channel data offset register x
enum {
	ADC1_JOFR3_JOFFSET3 = ((1UL<<12)-1) << 0, // Data offset for injected channel x		
};
inline void adc1_jofr3_set_joffset3(struct ADC1_Type* p, uint32_t val) { p->JOFR3 = (p->JOFR3 & ~ADC1_JOFR3_JOFFSET3) | ((val<<0) & ADC1_JOFR3_JOFFSET3); }
inline uint32_t adc1_jofr3_get_joffset3(struct ADC1_Type* p) { return (p->JOFR3 & ADC1_JOFR3_JOFFSET3) >> 0 ; }

// ADC1->JOFR4 injected channel data offset register x
enum {
	ADC1_JOFR4_JOFFSET4 = ((1UL<<12)-1) << 0, // Data offset for injected channel x		
};
inline void adc1_jofr4_set_joffset4(struct ADC1_Type* p, uint32_t val) { p->JOFR4 = (p->JOFR4 & ~ADC1_JOFR4_JOFFSET4) | ((val<<0) & ADC1_JOFR4_JOFFSET4); }
inline uint32_t adc1_jofr4_get_joffset4(struct ADC1_Type* p) { return (p->JOFR4 & ADC1_JOFR4_JOFFSET4) >> 0 ; }

// ADC1->HTR watchdog higher threshold register
enum {
	ADC1_HTR_HT = ((1UL<<12)-1) << 0, // Analog watchdog higher threshold		
};
inline void adc1_htr_set_ht(struct ADC1_Type* p, uint32_t val) { p->HTR = (p->HTR & ~ADC1_HTR_HT) | ((val<<0) & ADC1_HTR_HT); }
inline uint32_t adc1_htr_get_ht(struct ADC1_Type* p) { return (p->HTR & ADC1_HTR_HT) >> 0 ; }

// ADC1->LTR watchdog lower threshold register
enum {
	ADC1_LTR_LT = ((1UL<<12)-1) << 0, // Analog watchdog lower threshold		
};
inline void adc1_ltr_set_lt(struct ADC1_Type* p, uint32_t val) { p->LTR = (p->LTR & ~ADC1_LTR_LT) | ((val<<0) & ADC1_LTR_LT); }
inline uint32_t adc1_ltr_get_lt(struct ADC1_Type* p) { return (p->LTR & ADC1_LTR_LT) >> 0 ; }

// ADC1->SQR1 regular sequence register 1
enum {
	ADC1_SQR1_L = ((1UL<<4)-1) << 20, // Regular channel sequence length
	ADC1_SQR1_SQ16 = ((1UL<<5)-1) << 15, // 16th conversion in regular sequence
	ADC1_SQR1_SQ15 = ((1UL<<5)-1) << 10, // 15th conversion in regular sequence
	ADC1_SQR1_SQ14 = ((1UL<<5)-1) << 5, // 14th conversion in regular sequence
	ADC1_SQR1_SQ13 = ((1UL<<5)-1) << 0, // 13th conversion in regular sequence		
};
inline void adc1_sqr1_set_l(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_L) | ((val<<20) & ADC1_SQR1_L); }
inline void adc1_sqr1_set_sq16(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ16) | ((val<<15) & ADC1_SQR1_SQ16); }
inline void adc1_sqr1_set_sq15(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ15) | ((val<<10) & ADC1_SQR1_SQ15); }
inline void adc1_sqr1_set_sq14(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ14) | ((val<<5) & ADC1_SQR1_SQ14); }
inline void adc1_sqr1_set_sq13(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ13) | ((val<<0) & ADC1_SQR1_SQ13); }
inline uint32_t adc1_sqr1_get_l(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_L) >> 20 ; }
inline uint32_t adc1_sqr1_get_sq16(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ16) >> 15 ; }
inline uint32_t adc1_sqr1_get_sq15(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ15) >> 10 ; }
inline uint32_t adc1_sqr1_get_sq14(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ14) >> 5 ; }
inline uint32_t adc1_sqr1_get_sq13(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ13) >> 0 ; }

// ADC1->SQR2 regular sequence register 2
enum {
	ADC1_SQR2_SQ12 = ((1UL<<5)-1) << 25, // 12th conversion in regular sequence
	ADC1_SQR2_SQ11 = ((1UL<<5)-1) << 20, // 11th conversion in regular sequence
	ADC1_SQR2_SQ10 = ((1UL<<5)-1) << 15, // 10th conversion in regular sequence
	ADC1_SQR2_SQ9 = ((1UL<<5)-1) << 10, // 9th conversion in regular sequence
	ADC1_SQR2_SQ8 = ((1UL<<5)-1) << 5, // 8th conversion in regular sequence
	ADC1_SQR2_SQ7 = ((1UL<<5)-1) << 0, // 7th conversion in regular sequence		
};
inline void adc1_sqr2_set_sq12(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ12) | ((val<<25) & ADC1_SQR2_SQ12); }
inline void adc1_sqr2_set_sq11(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ11) | ((val<<20) & ADC1_SQR2_SQ11); }
inline void adc1_sqr2_set_sq10(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ10) | ((val<<15) & ADC1_SQR2_SQ10); }
inline void adc1_sqr2_set_sq9(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ9) | ((val<<10) & ADC1_SQR2_SQ9); }
inline void adc1_sqr2_set_sq8(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ8) | ((val<<5) & ADC1_SQR2_SQ8); }
inline void adc1_sqr2_set_sq7(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ7) | ((val<<0) & ADC1_SQR2_SQ7); }
inline uint32_t adc1_sqr2_get_sq12(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ12) >> 25 ; }
inline uint32_t adc1_sqr2_get_sq11(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ11) >> 20 ; }
inline uint32_t adc1_sqr2_get_sq10(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ10) >> 15 ; }
inline uint32_t adc1_sqr2_get_sq9(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ9) >> 10 ; }
inline uint32_t adc1_sqr2_get_sq8(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ8) >> 5 ; }
inline uint32_t adc1_sqr2_get_sq7(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ7) >> 0 ; }

// ADC1->SQR3 regular sequence register 3
enum {
	ADC1_SQR3_SQ6 = ((1UL<<5)-1) << 25, // 6th conversion in regular sequence
	ADC1_SQR3_SQ5 = ((1UL<<5)-1) << 20, // 5th conversion in regular sequence
	ADC1_SQR3_SQ4 = ((1UL<<5)-1) << 15, // 4th conversion in regular sequence
	ADC1_SQR3_SQ3 = ((1UL<<5)-1) << 10, // 3rd conversion in regular sequence
	ADC1_SQR3_SQ2 = ((1UL<<5)-1) << 5, // 2nd conversion in regular sequence
	ADC1_SQR3_SQ1 = ((1UL<<5)-1) << 0, // 1st conversion in regular sequence		
};
inline void adc1_sqr3_set_sq6(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ6) | ((val<<25) & ADC1_SQR3_SQ6); }
inline void adc1_sqr3_set_sq5(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ5) | ((val<<20) & ADC1_SQR3_SQ5); }
inline void adc1_sqr3_set_sq4(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ4) | ((val<<15) & ADC1_SQR3_SQ4); }
inline void adc1_sqr3_set_sq3(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ3) | ((val<<10) & ADC1_SQR3_SQ3); }
inline void adc1_sqr3_set_sq2(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ2) | ((val<<5) & ADC1_SQR3_SQ2); }
inline void adc1_sqr3_set_sq1(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ1) | ((val<<0) & ADC1_SQR3_SQ1); }
inline uint32_t adc1_sqr3_get_sq6(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ6) >> 25 ; }
inline uint32_t adc1_sqr3_get_sq5(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ5) >> 20 ; }
inline uint32_t adc1_sqr3_get_sq4(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ4) >> 15 ; }
inline uint32_t adc1_sqr3_get_sq3(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ3) >> 10 ; }
inline uint32_t adc1_sqr3_get_sq2(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ2) >> 5 ; }
inline uint32_t adc1_sqr3_get_sq1(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ1) >> 0 ; }

// ADC1->JSQR injected sequence register
enum {
	ADC1_JSQR_JL = ((1UL<<2)-1) << 20, // Injected sequence length
	ADC1_JSQR_JSQ4 = ((1UL<<5)-1) << 15, // 4th conversion in injected sequence
	ADC1_JSQR_JSQ3 = ((1UL<<5)-1) << 10, // 3rd conversion in injected sequence
	ADC1_JSQR_JSQ2 = ((1UL<<5)-1) << 5, // 2nd conversion in injected sequence
	ADC1_JSQR_JSQ1 = ((1UL<<5)-1) << 0, // 1st conversion in injected sequence		
};
inline void adc1_jsqr_set_jl(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JL) | ((val<<20) & ADC1_JSQR_JL); }
inline void adc1_jsqr_set_jsq4(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ4) | ((val<<15) & ADC1_JSQR_JSQ4); }
inline void adc1_jsqr_set_jsq3(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ3) | ((val<<10) & ADC1_JSQR_JSQ3); }
inline void adc1_jsqr_set_jsq2(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ2) | ((val<<5) & ADC1_JSQR_JSQ2); }
inline void adc1_jsqr_set_jsq1(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ1) | ((val<<0) & ADC1_JSQR_JSQ1); }
inline uint32_t adc1_jsqr_get_jl(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JL) >> 20 ; }
inline uint32_t adc1_jsqr_get_jsq4(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ4) >> 15 ; }
inline uint32_t adc1_jsqr_get_jsq3(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ3) >> 10 ; }
inline uint32_t adc1_jsqr_get_jsq2(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ2) >> 5 ; }
inline uint32_t adc1_jsqr_get_jsq1(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ1) >> 0 ; }



/* Controller area network */
struct CAN_Type {
	__IO uint32_t MCR; // @0 master control register
	__IO uint16_t MSR; // @4 master status register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t TSR; // @8 transmit status register
	__IO uint8_t RF0R; // @12 receive FIFO 0 register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint8_t RF1R; // @16 receive FIFO 1 register
	 uint8_t RESERVED2[3]; // @17 
	__IO uint32_t IER; // @20 interrupt enable register
	__IO uint32_t ESR; // @24 interrupt enable register
	__IO uint32_t BTR; // @28 bit timing register
	 uint8_t RESERVED3[352]; // @32 
	__IO uint32_t TI0R; // @384 TX mailbox identifier register
	__IO uint32_t TDT0R; // @388 mailbox data length control and time stamp register
	__IO uint32_t TDL0R; // @392 mailbox data low register
	__IO uint32_t TDH0R; // @396 mailbox data high register
	__IO uint32_t TI1R; // @400 mailbox identifier register
	__IO uint32_t TDT1R; // @404 mailbox data length control and time stamp register
	__IO uint32_t TDL1R; // @408 mailbox data low register
	__IO uint32_t TDH1R; // @412 mailbox data high register
	__IO uint32_t TI2R; // @416 mailbox identifier register
	__IO uint32_t TDT2R; // @420 mailbox data length control and time stamp register
	__IO uint32_t TDL2R; // @424 mailbox data low register
	__IO uint32_t TDH2R; // @428 mailbox data high register
	__I uint32_t RI0R; // @432 receive FIFO mailbox identifier register
	__I uint32_t RDT0R; // @436 mailbox data high register
	__I uint32_t RDL0R; // @440 mailbox data high register
	__I uint32_t RDH0R; // @444 receive FIFO mailbox data high register
	__I uint32_t RI1R; // @448 mailbox data high register
	__I uint32_t RDT1R; // @452 mailbox data high register
	__I uint32_t RDL1R; // @456 mailbox data high register
	__I uint32_t RDH1R; // @460 mailbox data high register
	 uint8_t RESERVED4[48]; // @464 
	__IO uint16_t FMR; // @512 filter master register
	 uint8_t RESERVED5[2]; // @514 
	__IO uint32_t FM1R; // @516 filter mode register
	 uint8_t RESERVED6[4]; // @520 
	__IO uint32_t FS1R; // @524 filter scale register
	 uint8_t RESERVED7[4]; // @528 
	__IO uint32_t FFA1R; // @532 filter FIFO assignment register
	 uint8_t RESERVED8[4]; // @536 
	__IO uint32_t FA1R; // @540 filter activation register
	 uint8_t RESERVED9[32]; // @544 
	__IO uint32_t F0R1; // @576 Filter bank 0 register 1
	__IO uint32_t F0R2; // @580 Filter bank 0 register 2
	__IO uint32_t F1R1; // @584 Filter bank 1 register 1
	__IO uint32_t F1R2; // @588 Filter bank 1 register 2
	__IO uint32_t F2R1; // @592 Filter bank 2 register 1
	__IO uint32_t F2R2; // @596 Filter bank 2 register 2
	__IO uint32_t F3R1; // @600 Filter bank 3 register 1
	__IO uint32_t F3R2; // @604 Filter bank 3 register 2
	__IO uint32_t F4R1; // @608 Filter bank 4 register 1
	__IO uint32_t F4R2; // @612 Filter bank 4 register 2
	__IO uint32_t F5R1; // @616 Filter bank 5 register 1
	__IO uint32_t F5R2; // @620 Filter bank 5 register 2
	__IO uint32_t F6R1; // @624 Filter bank 6 register 1
	__IO uint32_t F6R2; // @628 Filter bank 6 register 2
	__IO uint32_t F7R1; // @632 Filter bank 7 register 1
	__IO uint32_t F7R2; // @636 Filter bank 7 register 2
	__IO uint32_t F8R1; // @640 Filter bank 8 register 1
	__IO uint32_t F8R2; // @644 Filter bank 8 register 2
	__IO uint32_t F9R1; // @648 Filter bank 9 register 1
	__IO uint32_t F9R2; // @652 Filter bank 9 register 2
	__IO uint32_t F10R1; // @656 Filter bank 10 register 1
	__IO uint32_t F10R2; // @660 Filter bank 10 register 2
	__IO uint32_t F11R1; // @664 Filter bank 11 register 1
	__IO uint32_t F11R2; // @668 Filter bank 11 register 2
	__IO uint32_t F12R1; // @672 Filter bank 4 register 1
	__IO uint32_t F12R2; // @676 Filter bank 12 register 2
	__IO uint32_t F13R1; // @680 Filter bank 13 register 1
	__IO uint32_t F13R2; // @684 Filter bank 13 register 2
	__IO uint32_t F14R1; // @688 Filter bank 14 register 1
	__IO uint32_t F14R2; // @692 Filter bank 14 register 2
	__IO uint32_t F15R1; // @696 Filter bank 15 register 1
	__IO uint32_t F15R2; // @700 Filter bank 15 register 2
	__IO uint32_t F16R1; // @704 Filter bank 16 register 1
	__IO uint32_t F16R2; // @708 Filter bank 16 register 2
	__IO uint32_t F17R1; // @712 Filter bank 17 register 1
	__IO uint32_t F17R2; // @716 Filter bank 17 register 2
	__IO uint32_t F18R1; // @720 Filter bank 18 register 1
	__IO uint32_t F18R2; // @724 Filter bank 18 register 2
	__IO uint32_t F19R1; // @728 Filter bank 19 register 1
	__IO uint32_t F19R2; // @732 Filter bank 19 register 2
	__IO uint32_t F20R1; // @736 Filter bank 20 register 1
	__IO uint32_t F20R2; // @740 Filter bank 20 register 2
	__IO uint32_t F21R1; // @744 Filter bank 21 register 1
	__IO uint32_t F21R2; // @748 Filter bank 21 register 2
	__IO uint32_t F22R1; // @752 Filter bank 22 register 1
	__IO uint32_t F22R2; // @756 Filter bank 22 register 2
	__IO uint32_t F23R1; // @760 Filter bank 23 register 1
	__IO uint32_t F23R2; // @764 Filter bank 23 register 2
	__IO uint32_t F24R1; // @768 Filter bank 24 register 1
	__IO uint32_t F24R2; // @772 Filter bank 24 register 2
	__IO uint32_t F25R1; // @776 Filter bank 25 register 1
	__IO uint32_t F25R2; // @780 Filter bank 25 register 2
	__IO uint32_t F26R1; // @784 Filter bank 26 register 1
	__IO uint32_t F26R2; // @788 Filter bank 26 register 2
	__IO uint32_t F27R1; // @792 Filter bank 27 register 1
	__IO uint32_t F27R2; // @796 Filter bank 27 register 2
};

// CAN->MCR master control register
enum {
	CAN_MCR_DBF = 1UL<<16, // DBF
	CAN_MCR_RESET = 1UL<<15, // RESET
	CAN_MCR_TTCM = 1UL<<7, // TTCM
	CAN_MCR_ABOM = 1UL<<6, // ABOM
	CAN_MCR_AWUM = 1UL<<5, // AWUM
	CAN_MCR_NART = 1UL<<4, // NART
	CAN_MCR_RFLM = 1UL<<3, // RFLM
	CAN_MCR_TXFP = 1UL<<2, // TXFP
	CAN_MCR_SLEEP = 1UL<<1, // SLEEP
	CAN_MCR_INRQ = 1UL<<0, // INRQ		
};

// CAN->MSR master status register
enum {
	CAN_MSR_RX = 1UL<<11, // RX
	CAN_MSR_SAMP = 1UL<<10, // SAMP
	CAN_MSR_RXM = 1UL<<9, // RXM
	CAN_MSR_TXM = 1UL<<8, // TXM
	CAN_MSR_SLAKI = 1UL<<4, // SLAKI
	CAN_MSR_WKUI = 1UL<<3, // WKUI
	CAN_MSR_ERRI = 1UL<<2, // ERRI
	CAN_MSR_SLAK = 1UL<<1, // SLAK
	CAN_MSR_INAK = 1UL<<0, // INAK		
};

// CAN->TSR transmit status register
enum {
	CAN_TSR_LOW2 = 1UL<<31, // Lowest priority flag for mailbox 2
	CAN_TSR_LOW1 = 1UL<<30, // Lowest priority flag for mailbox 1
	CAN_TSR_LOW0 = 1UL<<29, // Lowest priority flag for mailbox 0
	CAN_TSR_TME2 = 1UL<<28, // Lowest priority flag for mailbox 2
	CAN_TSR_TME1 = 1UL<<27, // Lowest priority flag for mailbox 1
	CAN_TSR_TME0 = 1UL<<26, // Lowest priority flag for mailbox 0
	CAN_TSR_CODE = ((1UL<<2)-1) << 24, // CODE
	CAN_TSR_ABRQ2 = 1UL<<23, // ABRQ2
	CAN_TSR_TERR2 = 1UL<<19, // TERR2
	CAN_TSR_ALST2 = 1UL<<18, // ALST2
	CAN_TSR_TXOK2 = 1UL<<17, // TXOK2
	CAN_TSR_RQCP2 = 1UL<<16, // RQCP2
	CAN_TSR_ABRQ1 = 1UL<<15, // ABRQ1
	CAN_TSR_TERR1 = 1UL<<11, // TERR1
	CAN_TSR_ALST1 = 1UL<<10, // ALST1
	CAN_TSR_TXOK1 = 1UL<<9, // TXOK1
	CAN_TSR_RQCP1 = 1UL<<8, // RQCP1
	CAN_TSR_ABRQ0 = 1UL<<7, // ABRQ0
	CAN_TSR_TERR0 = 1UL<<3, // TERR0
	CAN_TSR_ALST0 = 1UL<<2, // ALST0
	CAN_TSR_TXOK0 = 1UL<<1, // TXOK0
	CAN_TSR_RQCP0 = 1UL<<0, // RQCP0		
};
inline void can_tsr_set_code(struct CAN_Type* p, uint32_t val) { p->TSR = (p->TSR & ~CAN_TSR_CODE) | ((val<<24) & CAN_TSR_CODE); }
inline uint32_t can_tsr_get_code(struct CAN_Type* p) { return (p->TSR & CAN_TSR_CODE) >> 24 ; }

// CAN->RF0R receive FIFO 0 register
enum {
	CAN_RF0R_RFOM0 = 1UL<<5, // RFOM0
	CAN_RF0R_FOVR0 = 1UL<<4, // FOVR0
	CAN_RF0R_FULL0 = 1UL<<3, // FULL0
	CAN_RF0R_FMP0 = ((1UL<<2)-1) << 0, // FMP0		
};
inline void can_rf0r_set_fmp0(struct CAN_Type* p, uint32_t val) { p->RF0R = (p->RF0R & ~CAN_RF0R_FMP0) | ((val<<0) & CAN_RF0R_FMP0); }
inline uint32_t can_rf0r_get_fmp0(struct CAN_Type* p) { return (p->RF0R & CAN_RF0R_FMP0) >> 0 ; }

// CAN->RF1R receive FIFO 1 register
enum {
	CAN_RF1R_RFOM1 = 1UL<<5, // RFOM1
	CAN_RF1R_FOVR1 = 1UL<<4, // FOVR1
	CAN_RF1R_FULL1 = 1UL<<3, // FULL1
	CAN_RF1R_FMP1 = ((1UL<<2)-1) << 0, // FMP1		
};
inline void can_rf1r_set_fmp1(struct CAN_Type* p, uint32_t val) { p->RF1R = (p->RF1R & ~CAN_RF1R_FMP1) | ((val<<0) & CAN_RF1R_FMP1); }
inline uint32_t can_rf1r_get_fmp1(struct CAN_Type* p) { return (p->RF1R & CAN_RF1R_FMP1) >> 0 ; }

// CAN->IER interrupt enable register
enum {
	CAN_IER_SLKIE = 1UL<<17, // SLKIE
	CAN_IER_WKUIE = 1UL<<16, // WKUIE
	CAN_IER_ERRIE = 1UL<<15, // ERRIE
	CAN_IER_LECIE = 1UL<<11, // LECIE
	CAN_IER_BOFIE = 1UL<<10, // BOFIE
	CAN_IER_EPVIE = 1UL<<9, // EPVIE
	CAN_IER_EWGIE = 1UL<<8, // EWGIE
	CAN_IER_FOVIE1 = 1UL<<6, // FOVIE1
	CAN_IER_FFIE1 = 1UL<<5, // FFIE1
	CAN_IER_FMPIE1 = 1UL<<4, // FMPIE1
	CAN_IER_FOVIE0 = 1UL<<3, // FOVIE0
	CAN_IER_FFIE0 = 1UL<<2, // FFIE0
	CAN_IER_FMPIE0 = 1UL<<1, // FMPIE0
	CAN_IER_TMEIE = 1UL<<0, // TMEIE		
};

// CAN->ESR interrupt enable register
enum {
	CAN_ESR_REC = ((1UL<<8)-1) << 24, // REC
	CAN_ESR_TEC = ((1UL<<8)-1) << 16, // TEC
	CAN_ESR_LEC = ((1UL<<3)-1) << 4, // LEC
	CAN_ESR_BOFF = 1UL<<2, // BOFF
	CAN_ESR_EPVF = 1UL<<1, // EPVF
	CAN_ESR_EWGF = 1UL<<0, // EWGF		
};
inline void can_esr_set_rec(struct CAN_Type* p, uint32_t val) { p->ESR = (p->ESR & ~CAN_ESR_REC) | ((val<<24) & CAN_ESR_REC); }
inline void can_esr_set_tec(struct CAN_Type* p, uint32_t val) { p->ESR = (p->ESR & ~CAN_ESR_TEC) | ((val<<16) & CAN_ESR_TEC); }
inline void can_esr_set_lec(struct CAN_Type* p, uint32_t val) { p->ESR = (p->ESR & ~CAN_ESR_LEC) | ((val<<4) & CAN_ESR_LEC); }
inline uint32_t can_esr_get_rec(struct CAN_Type* p) { return (p->ESR & CAN_ESR_REC) >> 24 ; }
inline uint32_t can_esr_get_tec(struct CAN_Type* p) { return (p->ESR & CAN_ESR_TEC) >> 16 ; }
inline uint32_t can_esr_get_lec(struct CAN_Type* p) { return (p->ESR & CAN_ESR_LEC) >> 4 ; }

// CAN->BTR bit timing register
enum {
	CAN_BTR_SILM = 1UL<<31, // SILM
	CAN_BTR_LBKM = 1UL<<30, // LBKM
	CAN_BTR_SJW = ((1UL<<2)-1) << 24, // SJW
	CAN_BTR_TS2 = ((1UL<<3)-1) << 20, // TS2
	CAN_BTR_TS1 = ((1UL<<4)-1) << 16, // TS1
	CAN_BTR_BRP = ((1UL<<10)-1) << 0, // BRP		
};
inline void can_btr_set_sjw(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_SJW) | ((val<<24) & CAN_BTR_SJW); }
inline void can_btr_set_ts2(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_TS2) | ((val<<20) & CAN_BTR_TS2); }
inline void can_btr_set_ts1(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_TS1) | ((val<<16) & CAN_BTR_TS1); }
inline void can_btr_set_brp(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_BRP) | ((val<<0) & CAN_BTR_BRP); }
inline uint32_t can_btr_get_sjw(struct CAN_Type* p) { return (p->BTR & CAN_BTR_SJW) >> 24 ; }
inline uint32_t can_btr_get_ts2(struct CAN_Type* p) { return (p->BTR & CAN_BTR_TS2) >> 20 ; }
inline uint32_t can_btr_get_ts1(struct CAN_Type* p) { return (p->BTR & CAN_BTR_TS1) >> 16 ; }
inline uint32_t can_btr_get_brp(struct CAN_Type* p) { return (p->BTR & CAN_BTR_BRP) >> 0 ; }

// CAN->TI0R TX mailbox identifier register
enum {
	CAN_TI0R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI0R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI0R_IDE = 1UL<<2, // IDE
	CAN_TI0R_RTR = 1UL<<1, // RTR
	CAN_TI0R_TXRQ = 1UL<<0, // TXRQ		
};
inline void can_ti0r_set_stid(struct CAN_Type* p, uint32_t val) { p->TI0R = (p->TI0R & ~CAN_TI0R_STID) | ((val<<21) & CAN_TI0R_STID); }
inline void can_ti0r_set_exid(struct CAN_Type* p, uint32_t val) { p->TI0R = (p->TI0R & ~CAN_TI0R_EXID) | ((val<<3) & CAN_TI0R_EXID); }
inline uint32_t can_ti0r_get_stid(struct CAN_Type* p) { return (p->TI0R & CAN_TI0R_STID) >> 21 ; }
inline uint32_t can_ti0r_get_exid(struct CAN_Type* p) { return (p->TI0R & CAN_TI0R_EXID) >> 3 ; }

// CAN->TDT0R mailbox data length control and time stamp register
enum {
	CAN_TDT0R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT0R_TGT = 1UL<<8, // TGT
	CAN_TDT0R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline void can_tdt0r_set_time(struct CAN_Type* p, uint32_t val) { p->TDT0R = (p->TDT0R & ~CAN_TDT0R_TIME) | ((val<<16) & CAN_TDT0R_TIME); }
inline void can_tdt0r_set_dlc(struct CAN_Type* p, uint32_t val) { p->TDT0R = (p->TDT0R & ~CAN_TDT0R_DLC) | ((val<<0) & CAN_TDT0R_DLC); }
inline uint32_t can_tdt0r_get_time(struct CAN_Type* p) { return (p->TDT0R & CAN_TDT0R_TIME) >> 16 ; }
inline uint32_t can_tdt0r_get_dlc(struct CAN_Type* p) { return (p->TDT0R & CAN_TDT0R_DLC) >> 0 ; }

// CAN->TDL0R mailbox data low register
enum {
	CAN_TDL0R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL0R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL0R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL0R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline void can_tdl0r_set_data3(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA3) | ((val<<24) & CAN_TDL0R_DATA3); }
inline void can_tdl0r_set_data2(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA2) | ((val<<16) & CAN_TDL0R_DATA2); }
inline void can_tdl0r_set_data1(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA1) | ((val<<8) & CAN_TDL0R_DATA1); }
inline void can_tdl0r_set_data0(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA0) | ((val<<0) & CAN_TDL0R_DATA0); }
inline uint32_t can_tdl0r_get_data3(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA3) >> 24 ; }
inline uint32_t can_tdl0r_get_data2(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA2) >> 16 ; }
inline uint32_t can_tdl0r_get_data1(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA1) >> 8 ; }
inline uint32_t can_tdl0r_get_data0(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA0) >> 0 ; }

// CAN->TDH0R mailbox data high register
enum {
	CAN_TDH0R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH0R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH0R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH0R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline void can_tdh0r_set_data7(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA7) | ((val<<24) & CAN_TDH0R_DATA7); }
inline void can_tdh0r_set_data6(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA6) | ((val<<16) & CAN_TDH0R_DATA6); }
inline void can_tdh0r_set_data5(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA5) | ((val<<8) & CAN_TDH0R_DATA5); }
inline void can_tdh0r_set_data4(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA4) | ((val<<0) & CAN_TDH0R_DATA4); }
inline uint32_t can_tdh0r_get_data7(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA7) >> 24 ; }
inline uint32_t can_tdh0r_get_data6(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA6) >> 16 ; }
inline uint32_t can_tdh0r_get_data5(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA5) >> 8 ; }
inline uint32_t can_tdh0r_get_data4(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA4) >> 0 ; }

// CAN->TI1R mailbox identifier register
enum {
	CAN_TI1R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI1R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI1R_IDE = 1UL<<2, // IDE
	CAN_TI1R_RTR = 1UL<<1, // RTR
	CAN_TI1R_TXRQ = 1UL<<0, // TXRQ		
};
inline void can_ti1r_set_stid(struct CAN_Type* p, uint32_t val) { p->TI1R = (p->TI1R & ~CAN_TI1R_STID) | ((val<<21) & CAN_TI1R_STID); }
inline void can_ti1r_set_exid(struct CAN_Type* p, uint32_t val) { p->TI1R = (p->TI1R & ~CAN_TI1R_EXID) | ((val<<3) & CAN_TI1R_EXID); }
inline uint32_t can_ti1r_get_stid(struct CAN_Type* p) { return (p->TI1R & CAN_TI1R_STID) >> 21 ; }
inline uint32_t can_ti1r_get_exid(struct CAN_Type* p) { return (p->TI1R & CAN_TI1R_EXID) >> 3 ; }

// CAN->TDT1R mailbox data length control and time stamp register
enum {
	CAN_TDT1R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT1R_TGT = 1UL<<8, // TGT
	CAN_TDT1R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline void can_tdt1r_set_time(struct CAN_Type* p, uint32_t val) { p->TDT1R = (p->TDT1R & ~CAN_TDT1R_TIME) | ((val<<16) & CAN_TDT1R_TIME); }
inline void can_tdt1r_set_dlc(struct CAN_Type* p, uint32_t val) { p->TDT1R = (p->TDT1R & ~CAN_TDT1R_DLC) | ((val<<0) & CAN_TDT1R_DLC); }
inline uint32_t can_tdt1r_get_time(struct CAN_Type* p) { return (p->TDT1R & CAN_TDT1R_TIME) >> 16 ; }
inline uint32_t can_tdt1r_get_dlc(struct CAN_Type* p) { return (p->TDT1R & CAN_TDT1R_DLC) >> 0 ; }

// CAN->TDL1R mailbox data low register
enum {
	CAN_TDL1R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL1R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL1R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL1R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline void can_tdl1r_set_data3(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA3) | ((val<<24) & CAN_TDL1R_DATA3); }
inline void can_tdl1r_set_data2(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA2) | ((val<<16) & CAN_TDL1R_DATA2); }
inline void can_tdl1r_set_data1(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA1) | ((val<<8) & CAN_TDL1R_DATA1); }
inline void can_tdl1r_set_data0(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA0) | ((val<<0) & CAN_TDL1R_DATA0); }
inline uint32_t can_tdl1r_get_data3(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA3) >> 24 ; }
inline uint32_t can_tdl1r_get_data2(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA2) >> 16 ; }
inline uint32_t can_tdl1r_get_data1(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA1) >> 8 ; }
inline uint32_t can_tdl1r_get_data0(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA0) >> 0 ; }

// CAN->TDH1R mailbox data high register
enum {
	CAN_TDH1R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH1R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH1R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH1R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline void can_tdh1r_set_data7(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA7) | ((val<<24) & CAN_TDH1R_DATA7); }
inline void can_tdh1r_set_data6(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA6) | ((val<<16) & CAN_TDH1R_DATA6); }
inline void can_tdh1r_set_data5(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA5) | ((val<<8) & CAN_TDH1R_DATA5); }
inline void can_tdh1r_set_data4(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA4) | ((val<<0) & CAN_TDH1R_DATA4); }
inline uint32_t can_tdh1r_get_data7(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA7) >> 24 ; }
inline uint32_t can_tdh1r_get_data6(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA6) >> 16 ; }
inline uint32_t can_tdh1r_get_data5(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA5) >> 8 ; }
inline uint32_t can_tdh1r_get_data4(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA4) >> 0 ; }

// CAN->TI2R mailbox identifier register
enum {
	CAN_TI2R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI2R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI2R_IDE = 1UL<<2, // IDE
	CAN_TI2R_RTR = 1UL<<1, // RTR
	CAN_TI2R_TXRQ = 1UL<<0, // TXRQ		
};
inline void can_ti2r_set_stid(struct CAN_Type* p, uint32_t val) { p->TI2R = (p->TI2R & ~CAN_TI2R_STID) | ((val<<21) & CAN_TI2R_STID); }
inline void can_ti2r_set_exid(struct CAN_Type* p, uint32_t val) { p->TI2R = (p->TI2R & ~CAN_TI2R_EXID) | ((val<<3) & CAN_TI2R_EXID); }
inline uint32_t can_ti2r_get_stid(struct CAN_Type* p) { return (p->TI2R & CAN_TI2R_STID) >> 21 ; }
inline uint32_t can_ti2r_get_exid(struct CAN_Type* p) { return (p->TI2R & CAN_TI2R_EXID) >> 3 ; }

// CAN->TDT2R mailbox data length control and time stamp register
enum {
	CAN_TDT2R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT2R_TGT = 1UL<<8, // TGT
	CAN_TDT2R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline void can_tdt2r_set_time(struct CAN_Type* p, uint32_t val) { p->TDT2R = (p->TDT2R & ~CAN_TDT2R_TIME) | ((val<<16) & CAN_TDT2R_TIME); }
inline void can_tdt2r_set_dlc(struct CAN_Type* p, uint32_t val) { p->TDT2R = (p->TDT2R & ~CAN_TDT2R_DLC) | ((val<<0) & CAN_TDT2R_DLC); }
inline uint32_t can_tdt2r_get_time(struct CAN_Type* p) { return (p->TDT2R & CAN_TDT2R_TIME) >> 16 ; }
inline uint32_t can_tdt2r_get_dlc(struct CAN_Type* p) { return (p->TDT2R & CAN_TDT2R_DLC) >> 0 ; }

// CAN->TDL2R mailbox data low register
enum {
	CAN_TDL2R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL2R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL2R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL2R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline void can_tdl2r_set_data3(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA3) | ((val<<24) & CAN_TDL2R_DATA3); }
inline void can_tdl2r_set_data2(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA2) | ((val<<16) & CAN_TDL2R_DATA2); }
inline void can_tdl2r_set_data1(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA1) | ((val<<8) & CAN_TDL2R_DATA1); }
inline void can_tdl2r_set_data0(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA0) | ((val<<0) & CAN_TDL2R_DATA0); }
inline uint32_t can_tdl2r_get_data3(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA3) >> 24 ; }
inline uint32_t can_tdl2r_get_data2(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA2) >> 16 ; }
inline uint32_t can_tdl2r_get_data1(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA1) >> 8 ; }
inline uint32_t can_tdl2r_get_data0(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA0) >> 0 ; }

// CAN->TDH2R mailbox data high register
enum {
	CAN_TDH2R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH2R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH2R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH2R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline void can_tdh2r_set_data7(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA7) | ((val<<24) & CAN_TDH2R_DATA7); }
inline void can_tdh2r_set_data6(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA6) | ((val<<16) & CAN_TDH2R_DATA6); }
inline void can_tdh2r_set_data5(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA5) | ((val<<8) & CAN_TDH2R_DATA5); }
inline void can_tdh2r_set_data4(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA4) | ((val<<0) & CAN_TDH2R_DATA4); }
inline uint32_t can_tdh2r_get_data7(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA7) >> 24 ; }
inline uint32_t can_tdh2r_get_data6(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA6) >> 16 ; }
inline uint32_t can_tdh2r_get_data5(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA5) >> 8 ; }
inline uint32_t can_tdh2r_get_data4(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA4) >> 0 ; }

// CAN->RI0R receive FIFO mailbox identifier register
enum {
	CAN_RI0R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_RI0R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_RI0R_IDE = 1UL<<2, // IDE
	CAN_RI0R_RTR = 1UL<<1, // RTR		
};
inline uint32_t can_ri0r_get_stid(struct CAN_Type* p) { return (p->RI0R & CAN_RI0R_STID) >> 21 ; }
inline uint32_t can_ri0r_get_exid(struct CAN_Type* p) { return (p->RI0R & CAN_RI0R_EXID) >> 3 ; }

// CAN->RDT0R mailbox data high register
enum {
	CAN_RDT0R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_RDT0R_FMI = ((1UL<<8)-1) << 8, // FMI
	CAN_RDT0R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline uint32_t can_rdt0r_get_time(struct CAN_Type* p) { return (p->RDT0R & CAN_RDT0R_TIME) >> 16 ; }
inline uint32_t can_rdt0r_get_fmi(struct CAN_Type* p) { return (p->RDT0R & CAN_RDT0R_FMI) >> 8 ; }
inline uint32_t can_rdt0r_get_dlc(struct CAN_Type* p) { return (p->RDT0R & CAN_RDT0R_DLC) >> 0 ; }

// CAN->RDL0R mailbox data high register
enum {
	CAN_RDL0R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_RDL0R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_RDL0R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_RDL0R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline uint32_t can_rdl0r_get_data3(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA3) >> 24 ; }
inline uint32_t can_rdl0r_get_data2(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA2) >> 16 ; }
inline uint32_t can_rdl0r_get_data1(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA1) >> 8 ; }
inline uint32_t can_rdl0r_get_data0(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA0) >> 0 ; }

// CAN->RDH0R receive FIFO mailbox data high register
enum {
	CAN_RDH0R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_RDH0R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_RDH0R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_RDH0R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline uint32_t can_rdh0r_get_data7(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA7) >> 24 ; }
inline uint32_t can_rdh0r_get_data6(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA6) >> 16 ; }
inline uint32_t can_rdh0r_get_data5(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA5) >> 8 ; }
inline uint32_t can_rdh0r_get_data4(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA4) >> 0 ; }

// CAN->RI1R mailbox data high register
enum {
	CAN_RI1R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_RI1R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_RI1R_IDE = 1UL<<2, // IDE
	CAN_RI1R_RTR = 1UL<<1, // RTR		
};
inline uint32_t can_ri1r_get_stid(struct CAN_Type* p) { return (p->RI1R & CAN_RI1R_STID) >> 21 ; }
inline uint32_t can_ri1r_get_exid(struct CAN_Type* p) { return (p->RI1R & CAN_RI1R_EXID) >> 3 ; }

// CAN->RDT1R mailbox data high register
enum {
	CAN_RDT1R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_RDT1R_FMI = ((1UL<<8)-1) << 8, // FMI
	CAN_RDT1R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline uint32_t can_rdt1r_get_time(struct CAN_Type* p) { return (p->RDT1R & CAN_RDT1R_TIME) >> 16 ; }
inline uint32_t can_rdt1r_get_fmi(struct CAN_Type* p) { return (p->RDT1R & CAN_RDT1R_FMI) >> 8 ; }
inline uint32_t can_rdt1r_get_dlc(struct CAN_Type* p) { return (p->RDT1R & CAN_RDT1R_DLC) >> 0 ; }

// CAN->RDL1R mailbox data high register
enum {
	CAN_RDL1R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_RDL1R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_RDL1R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_RDL1R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline uint32_t can_rdl1r_get_data3(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA3) >> 24 ; }
inline uint32_t can_rdl1r_get_data2(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA2) >> 16 ; }
inline uint32_t can_rdl1r_get_data1(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA1) >> 8 ; }
inline uint32_t can_rdl1r_get_data0(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA0) >> 0 ; }

// CAN->RDH1R mailbox data high register
enum {
	CAN_RDH1R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_RDH1R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_RDH1R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_RDH1R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline uint32_t can_rdh1r_get_data7(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA7) >> 24 ; }
inline uint32_t can_rdh1r_get_data6(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA6) >> 16 ; }
inline uint32_t can_rdh1r_get_data5(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA5) >> 8 ; }
inline uint32_t can_rdh1r_get_data4(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA4) >> 0 ; }

// CAN->FMR filter master register
enum {
	CAN_FMR_CAN2SB = ((1UL<<6)-1) << 8, // CAN2SB
	CAN_FMR_FINIT = 1UL<<0, // FINIT		
};
inline void can_fmr_set_can2sb(struct CAN_Type* p, uint32_t val) { p->FMR = (p->FMR & ~CAN_FMR_CAN2SB) | ((val<<8) & CAN_FMR_CAN2SB); }
inline uint32_t can_fmr_get_can2sb(struct CAN_Type* p) { return (p->FMR & CAN_FMR_CAN2SB) >> 8 ; }

// CAN->FM1R filter mode register
enum {
	CAN_FM1R_FBMX  = ((1UL<<28)-1) << 0, // Merged Filter mode		
};
inline void can_fm1r_set_fbmx (struct CAN_Type* p, uint32_t val) { p->FM1R = (p->FM1R & ~CAN_FM1R_FBMX ) | ((val<<0) & CAN_FM1R_FBMX ); }
inline uint32_t can_fm1r_get_fbmx (struct CAN_Type* p) { return (p->FM1R & CAN_FM1R_FBMX ) >> 0 ; }

// CAN->FS1R filter scale register
enum {
	CAN_FS1R_FSCX  = ((1UL<<28)-1) << 0, // Merged Filter scale configuration		
};
inline void can_fs1r_set_fscx (struct CAN_Type* p, uint32_t val) { p->FS1R = (p->FS1R & ~CAN_FS1R_FSCX ) | ((val<<0) & CAN_FS1R_FSCX ); }
inline uint32_t can_fs1r_get_fscx (struct CAN_Type* p) { return (p->FS1R & CAN_FS1R_FSCX ) >> 0 ; }

// CAN->FFA1R filter FIFO assignment register
enum {
	CAN_FFA1R_FFAX  = ((1UL<<28)-1) << 0, // Merged Filter FIFO assignment for filter 27		
};
inline void can_ffa1r_set_ffax (struct CAN_Type* p, uint32_t val) { p->FFA1R = (p->FFA1R & ~CAN_FFA1R_FFAX ) | ((val<<0) & CAN_FFA1R_FFAX ); }
inline uint32_t can_ffa1r_get_ffax (struct CAN_Type* p) { return (p->FFA1R & CAN_FFA1R_FFAX ) >> 0 ; }

// CAN->FA1R filter activation register
enum {
	CAN_FA1R_FACTX  = ((1UL<<28)-1) << 0, // Merged Filter active		
};
inline void can_fa1r_set_factx (struct CAN_Type* p, uint32_t val) { p->FA1R = (p->FA1R & ~CAN_FA1R_FACTX ) | ((val<<0) & CAN_FA1R_FACTX ); }
inline uint32_t can_fa1r_get_factx (struct CAN_Type* p) { return (p->FA1R & CAN_FA1R_FACTX ) >> 0 ; }



/* HDMI-CEC controller */
struct CEC_Type {
	__IO uint8_t CR; // @0 control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CFGR; // @4 configuration register
	__O uint8_t TXDR; // @8 Tx data register
	 uint8_t RESERVED1[3]; // @9 
	__I uint8_t RXDR; // @12 Rx Data Register
	 uint8_t RESERVED2[3]; // @13 
	__IO uint16_t ISR; // @16 Interrupt and Status Register
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t IER; // @20 interrupt enable register
};

// CEC->CR control register
enum {
	CEC_CR_TXEOM = 1UL<<2, // Tx End Of Message
	CEC_CR_TXSOM = 1UL<<1, // Tx start of message
	CEC_CR_CECEN = 1UL<<0, // CEC Enable		
};

// CEC->CFGR configuration register
enum {
	CEC_CFGR_LSTN = 1UL<<31, // Listen mode
	CEC_CFGR_OAR = ((1UL<<15)-1) << 16, // Own addresses configuration
	CEC_CFGR_SFTOP = 1UL<<8, // SFT Option Bit
	CEC_CFGR_BRDNOGEN = 1UL<<7, // Avoid Error-Bit Generation in Broadcast
	CEC_CFGR_LBPEGEN = 1UL<<6, // Generate Error-Bit on Long Bit Period Error
	CEC_CFGR_BREGEN = 1UL<<5, // Generate error-bit on bit rising error
	CEC_CFGR_BRESTP = 1UL<<4, // Rx-stop on bit rising error
	CEC_CFGR_RXTOL = 1UL<<3, // Rx-Tolerance
	CEC_CFGR_SFT = ((1UL<<3)-1) << 0, // Signal Free Time		
};
inline void cec_cfgr_set_oar(struct CEC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CEC_CFGR_OAR) | ((val<<16) & CEC_CFGR_OAR); }
inline void cec_cfgr_set_sft(struct CEC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CEC_CFGR_SFT) | ((val<<0) & CEC_CFGR_SFT); }
inline uint32_t cec_cfgr_get_oar(struct CEC_Type* p) { return (p->CFGR & CEC_CFGR_OAR) >> 16 ; }
inline uint32_t cec_cfgr_get_sft(struct CEC_Type* p) { return (p->CFGR & CEC_CFGR_SFT) >> 0 ; }

// CEC->ISR Interrupt and Status Register
enum {
	CEC_ISR_TXACKE = 1UL<<12, // Tx-Missing acknowledge error
	CEC_ISR_TXERR = 1UL<<11, // Tx-Error
	CEC_ISR_TXUDR = 1UL<<10, // Tx-Buffer Underrun
	CEC_ISR_TXEND = 1UL<<9, // End of Transmission
	CEC_ISR_TXBR = 1UL<<8, // Tx-Byte Request
	CEC_ISR_ARBLST = 1UL<<7, // Arbitration Lost
	CEC_ISR_RXACKE = 1UL<<6, // Rx-Missing Acknowledge
	CEC_ISR_LBPE = 1UL<<5, // Rx-Long Bit Period Error
	CEC_ISR_SBPE = 1UL<<4, // Rx-Short Bit period error
	CEC_ISR_BRE = 1UL<<3, // Rx-Bit rising error
	CEC_ISR_RXOVR = 1UL<<2, // Rx-Overrun
	CEC_ISR_RXEND = 1UL<<1, // End Of Reception
	CEC_ISR_RXBR = 1UL<<0, // Rx-Byte Received		
};

// CEC->IER interrupt enable register
enum {
	CEC_IER_TXACKIE = 1UL<<12, // Tx-Missing Acknowledge Error Interrupt Enable
	CEC_IER_TXERRIE = 1UL<<11, // Tx-Error Interrupt Enable
	CEC_IER_TXUDRIE = 1UL<<10, // Tx-Underrun interrupt enable
	CEC_IER_TXENDIE = 1UL<<9, // Tx-End of message interrupt enable
	CEC_IER_TXBRIE = 1UL<<8, // Tx-Byte Request Interrupt Enable
	CEC_IER_ARBLSTIE = 1UL<<7, // Arbitration Lost Interrupt Enable
	CEC_IER_RXACKIE = 1UL<<6, // Rx-Missing Acknowledge Error Interrupt Enable
	CEC_IER_LBPEIE = 1UL<<5, // Long Bit Period Error Interrupt Enable
	CEC_IER_SBPEIE = 1UL<<4, // Short Bit Period Error Interrupt Enable
	CEC_IER_BREIE = 1UL<<3, // Bit Rising Error Interrupt Enable
	CEC_IER_RXOVRIE = 1UL<<2, // Rx-Buffer Overrun Interrupt Enable
	CEC_IER_RXENDIE = 1UL<<1, // End Of Reception Interrupt Enable
	CEC_IER_RXBRIE = 1UL<<0, // Rx-Byte Received Interrupt Enable		
};

/* Cryptographic processor */
struct CRC_Type {
	__IO uint32_t DR; // @0 Data register
	__IO uint8_t IDR; // @4 Independent Data register
	 uint8_t RESERVED0[3]; // @5 
	__O uint8_t CR; // @8 Control register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t INIT; // @12 Initial CRC value
	__IO uint32_t POL; // @16 CRC polynomial
};

// CRC->CR Control register
enum {
	CRC_CR_CR = 1UL<<0, // Control regidter		
};

/* Cryptographic processor */
struct CRYP_Type {
	__IO uint32_t CR; // @0 control register
	__I uint8_t SR; // @4 status register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint32_t DIN; // @8 data input register
	__I uint32_t DOUT; // @12 data output register
	__IO uint8_t DMACR; // @16 DMA control register
	 uint8_t RESERVED1[3]; // @17 
	__IO uint8_t IMSCR; // @20 interrupt mask set/clear register
	 uint8_t RESERVED2[3]; // @21 
	__I uint8_t RISR; // @24 raw interrupt status register
	 uint8_t RESERVED3[3]; // @25 
	__I uint8_t MISR; // @28 masked interrupt status register
	 uint8_t RESERVED4[3]; // @29 
	__O uint32_t K0LR; // @32 key registers
	__O uint32_t K0RR; // @36 key registers
	__O uint32_t K1LR; // @40 key registers
	__O uint32_t K1RR; // @44 key registers
	__O uint32_t K2LR; // @48 key registers
	__O uint32_t K2RR; // @52 key registers
	__O uint32_t K3LR; // @56 key registers
	__O uint32_t K3RR; // @60 key registers
	__IO uint32_t IV0LR; // @64 initialization vector registers
	__IO uint32_t IV0RR; // @68 initialization vector registers
	__IO uint32_t IV1LR; // @72 initialization vector registers
	__IO uint32_t IV1RR; // @76 initialization vector registers
	__IO uint32_t CSGCMCCM0R; // @80 context swap register
	__IO uint32_t CSGCMCCM1R; // @84 context swap register
	__IO uint32_t CSGCMCCM2R; // @88 context swap register
	__IO uint32_t CSGCMCCM3R; // @92 context swap register
	__IO uint32_t CSGCMCCM4R; // @96 context swap register
	__IO uint32_t CSGCMCCM5R; // @100 context swap register
	__IO uint32_t CSGCMCCM6R; // @104 context swap register
	__IO uint32_t CSGCMCCM7R; // @108 context swap register
	__IO uint32_t CSGCM0R; // @112 context swap register
	__IO uint32_t CSGCM1R; // @116 context swap register
	__IO uint32_t CSGCM2R; // @120 context swap register
	__IO uint32_t CSGCM3R; // @124 context swap register
	__IO uint32_t CSGCM4R; // @128 context swap register
	__IO uint32_t CSGCM5R; // @132 context swap register
	__IO uint32_t CSGCM6R; // @136 context swap register
	__IO uint32_t CSGCM7R; // @140 context swap register
};

// CRYP->CR control register
enum {
	CRYP_CR_ALGOMODE3 = 1UL<<19, // ALGOMODE
	CRYP_CR_GCM_CCMPH = ((1UL<<2)-1) << 16, // GCM_CCMPH
	CRYP_CR_CRYPEN = 1UL<<15, // Cryptographic processor enable
	CRYP_CR_FFLUSH = 1UL<<14, // FIFO flush
	CRYP_CR_KEYSIZE = ((1UL<<2)-1) << 8, // Key size selection (AES mode only)
	CRYP_CR_DATATYPE = ((1UL<<2)-1) << 6, // Data type selection
	CRYP_CR_ALGOMODE0 = ((1UL<<3)-1) << 3, // Algorithm mode
	CRYP_CR_ALGODIR = 1UL<<2, // Algorithm direction		
};
inline void cryp_cr_set_gcm_ccmph(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_GCM_CCMPH) | ((val<<16) & CRYP_CR_GCM_CCMPH); }
inline void cryp_cr_set_keysize(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_KEYSIZE) | ((val<<8) & CRYP_CR_KEYSIZE); }
inline void cryp_cr_set_datatype(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_DATATYPE) | ((val<<6) & CRYP_CR_DATATYPE); }
inline void cryp_cr_set_algomode0(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_ALGOMODE0) | ((val<<3) & CRYP_CR_ALGOMODE0); }
inline uint32_t cryp_cr_get_gcm_ccmph(struct CRYP_Type* p) { return (p->CR & CRYP_CR_GCM_CCMPH) >> 16 ; }
inline uint32_t cryp_cr_get_keysize(struct CRYP_Type* p) { return (p->CR & CRYP_CR_KEYSIZE) >> 8 ; }
inline uint32_t cryp_cr_get_datatype(struct CRYP_Type* p) { return (p->CR & CRYP_CR_DATATYPE) >> 6 ; }
inline uint32_t cryp_cr_get_algomode0(struct CRYP_Type* p) { return (p->CR & CRYP_CR_ALGOMODE0) >> 3 ; }

// CRYP->SR status register
enum {
	CRYP_SR_BUSY = 1UL<<4, // Busy bit
	CRYP_SR_OFFU = 1UL<<3, // Output FIFO full
	CRYP_SR_OFNE = 1UL<<2, // Output FIFO not empty
	CRYP_SR_IFNF = 1UL<<1, // Input FIFO not full
	CRYP_SR_IFEM = 1UL<<0, // Input FIFO empty		
};

// CRYP->DMACR DMA control register
enum {
	CRYP_DMACR_DOEN = 1UL<<1, // DMA output enable
	CRYP_DMACR_DIEN = 1UL<<0, // DMA input enable		
};

// CRYP->IMSCR interrupt mask set/clear register
enum {
	CRYP_IMSCR_OUTIM = 1UL<<1, // Output FIFO service interrupt mask
	CRYP_IMSCR_INIM = 1UL<<0, // Input FIFO service interrupt mask		
};

// CRYP->RISR raw interrupt status register
enum {
	CRYP_RISR_OUTRIS = 1UL<<1, // Output FIFO service raw interrupt status
	CRYP_RISR_INRIS = 1UL<<0, // Input FIFO service raw interrupt status		
};

// CRYP->MISR masked interrupt status register
enum {
	CRYP_MISR_OUTMIS = 1UL<<1, // Output FIFO service masked interrupt status
	CRYP_MISR_INMIS = 1UL<<0, // Input FIFO service masked interrupt status		
};

/* Digital-to-analog converter */
struct DAC_Type {
	__IO uint32_t CR; // @0 control register
	__O uint8_t SWTRIGR; // @4 software trigger register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint16_t DHR12R1; // @8 channel1 12-bit right-aligned data holding register
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t DHR12L1; // @12 channel1 12-bit left aligned data holding register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t DHR8R1; // @16 channel1 8-bit right aligned data holding register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t DHR12R2; // @20 channel2 12-bit right aligned data holding register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t DHR12L2; // @24 channel2 12-bit left aligned data holding register
	 uint8_t RESERVED5[2]; // @26 
	__IO uint8_t DHR8R2; // @28 channel2 8-bit right-aligned data holding register
	 uint8_t RESERVED6[3]; // @29 
	__IO uint32_t DHR12RD; // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DHR12LD; // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint16_t DHR8RD; // @40 DUAL DAC 8-bit right aligned data holding register
	 uint8_t RESERVED7[2]; // @42 
	__I uint16_t DOR1; // @44 channel1 data output register
	 uint8_t RESERVED8[2]; // @46 
	__I uint16_t DOR2; // @48 channel2 data output register
	 uint8_t RESERVED9[2]; // @50 
	__IO uint32_t SR; // @52 status register
};

// DAC->CR control register
enum {
	DAC_CR_DMAUDRIE2 = 1UL<<29, // DAC channel2 DMA underrun interrupt enable
	DAC_CR_DMAEN2 = 1UL<<28, // DAC channel2 DMA enable
	DAC_CR_MAMP2 = ((1UL<<4)-1) << 24, // DAC channel2 mask/amplitude selector
	DAC_CR_WAVE2 = ((1UL<<2)-1) << 22, // DAC channel2 noise/triangle wave generation enable
	DAC_CR_TSEL2 = ((1UL<<3)-1) << 19, // DAC channel2 trigger selection
	DAC_CR_TEN2 = 1UL<<18, // DAC channel2 trigger enable
	DAC_CR_BOFF2 = 1UL<<17, // DAC channel2 output buffer disable
	DAC_CR_EN2 = 1UL<<16, // DAC channel2 enable
	DAC_CR_DMAUDRIE1 = 1UL<<13, // DAC channel1 DMA Underrun Interrupt enable
	DAC_CR_DMAEN1 = 1UL<<12, // DAC channel1 DMA enable
	DAC_CR_MAMP1 = ((1UL<<4)-1) << 8, // DAC channel1 mask/amplitude selector
	DAC_CR_WAVE1 = ((1UL<<2)-1) << 6, // DAC channel1 noise/triangle wave generation enable
	DAC_CR_TSEL1 = ((1UL<<3)-1) << 3, // DAC channel1 trigger selection
	DAC_CR_TEN1 = 1UL<<2, // DAC channel1 trigger enable
	DAC_CR_BOFF1 = 1UL<<1, // DAC channel1 output buffer disable
	DAC_CR_EN1 = 1UL<<0, // DAC channel1 enable		
};
inline void dac_cr_set_mamp2(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_MAMP2) | ((val<<24) & DAC_CR_MAMP2); }
inline void dac_cr_set_wave2(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_WAVE2) | ((val<<22) & DAC_CR_WAVE2); }
inline void dac_cr_set_tsel2(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_TSEL2) | ((val<<19) & DAC_CR_TSEL2); }
inline void dac_cr_set_mamp1(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_MAMP1) | ((val<<8) & DAC_CR_MAMP1); }
inline void dac_cr_set_wave1(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_WAVE1) | ((val<<6) & DAC_CR_WAVE1); }
inline void dac_cr_set_tsel1(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_TSEL1) | ((val<<3) & DAC_CR_TSEL1); }
inline uint32_t dac_cr_get_mamp2(struct DAC_Type* p) { return (p->CR & DAC_CR_MAMP2) >> 24 ; }
inline uint32_t dac_cr_get_wave2(struct DAC_Type* p) { return (p->CR & DAC_CR_WAVE2) >> 22 ; }
inline uint32_t dac_cr_get_tsel2(struct DAC_Type* p) { return (p->CR & DAC_CR_TSEL2) >> 19 ; }
inline uint32_t dac_cr_get_mamp1(struct DAC_Type* p) { return (p->CR & DAC_CR_MAMP1) >> 8 ; }
inline uint32_t dac_cr_get_wave1(struct DAC_Type* p) { return (p->CR & DAC_CR_WAVE1) >> 6 ; }
inline uint32_t dac_cr_get_tsel1(struct DAC_Type* p) { return (p->CR & DAC_CR_TSEL1) >> 3 ; }

// DAC->SWTRIGR software trigger register
enum {
	DAC_SWTRIGR_SWTRIGX  = ((1UL<<2)-1) << 0, // Merged DAC channel2 software trigger		
};
inline void dac_swtrigr_set_swtrigx (struct DAC_Type* p, uint32_t val) { p->SWTRIGR = (p->SWTRIGR & ~DAC_SWTRIGR_SWTRIGX ) | ((val<<0) & DAC_SWTRIGR_SWTRIGX ); }
inline uint32_t dac_swtrigr_get_swtrigx (struct DAC_Type* p) { return (p->SWTRIGR & DAC_SWTRIGR_SWTRIGX ) >> 0 ; }

// DAC->DHR12R1 channel1 12-bit right-aligned data holding register
enum {
	DAC_DHR12R1_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data		
};
inline void dac_dhr12r1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12R1 = (p->DHR12R1 & ~DAC_DHR12R1_DACC1DHR) | ((val<<0) & DAC_DHR12R1_DACC1DHR); }
inline uint32_t dac_dhr12r1_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12R1 & DAC_DHR12R1_DACC1DHR) >> 0 ; }

// DAC->DHR12L1 channel1 12-bit left aligned data holding register
enum {
	DAC_DHR12L1_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data		
};
inline void dac_dhr12l1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12L1 = (p->DHR12L1 & ~DAC_DHR12L1_DACC1DHR) | ((val<<4) & DAC_DHR12L1_DACC1DHR); }
inline uint32_t dac_dhr12l1_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12L1 & DAC_DHR12L1_DACC1DHR) >> 4 ; }

// DAC->DHR12R2 channel2 12-bit right aligned data holding register
enum {
	DAC_DHR12R2_DACC2DHR = ((1UL<<12)-1) << 0, // DAC channel2 12-bit right-aligned data		
};
inline void dac_dhr12r2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12R2 = (p->DHR12R2 & ~DAC_DHR12R2_DACC2DHR) | ((val<<0) & DAC_DHR12R2_DACC2DHR); }
inline uint32_t dac_dhr12r2_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12R2 & DAC_DHR12R2_DACC2DHR) >> 0 ; }

// DAC->DHR12L2 channel2 12-bit left aligned data holding register
enum {
	DAC_DHR12L2_DACC2DHR = ((1UL<<12)-1) << 4, // DAC channel2 12-bit left-aligned data		
};
inline void dac_dhr12l2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12L2 = (p->DHR12L2 & ~DAC_DHR12L2_DACC2DHR) | ((val<<4) & DAC_DHR12L2_DACC2DHR); }
inline uint32_t dac_dhr12l2_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12L2 & DAC_DHR12L2_DACC2DHR) >> 4 ; }

// DAC->DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC_DHR12RD_DACC2DHR = ((1UL<<12)-1) << 16, // DAC channel2 12-bit right-aligned data
	DAC_DHR12RD_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data		
};
inline void dac_dhr12rd_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12RD = (p->DHR12RD & ~DAC_DHR12RD_DACC2DHR) | ((val<<16) & DAC_DHR12RD_DACC2DHR); }
inline void dac_dhr12rd_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12RD = (p->DHR12RD & ~DAC_DHR12RD_DACC1DHR) | ((val<<0) & DAC_DHR12RD_DACC1DHR); }
inline uint32_t dac_dhr12rd_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12RD & DAC_DHR12RD_DACC2DHR) >> 16 ; }
inline uint32_t dac_dhr12rd_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12RD & DAC_DHR12RD_DACC1DHR) >> 0 ; }

// DAC->DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC_DHR12LD_DACC2DHR = ((1UL<<12)-1) << 20, // DAC channel2 12-bit left-aligned data
	DAC_DHR12LD_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data		
};
inline void dac_dhr12ld_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12LD = (p->DHR12LD & ~DAC_DHR12LD_DACC2DHR) | ((val<<20) & DAC_DHR12LD_DACC2DHR); }
inline void dac_dhr12ld_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12LD = (p->DHR12LD & ~DAC_DHR12LD_DACC1DHR) | ((val<<4) & DAC_DHR12LD_DACC1DHR); }
inline uint32_t dac_dhr12ld_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12LD & DAC_DHR12LD_DACC2DHR) >> 20 ; }
inline uint32_t dac_dhr12ld_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12LD & DAC_DHR12LD_DACC1DHR) >> 4 ; }

// DAC->DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC_DHR8RD_DACC2DHR = ((1UL<<8)-1) << 8, // DAC channel2 8-bit right-aligned data
	DAC_DHR8RD_DACC1DHR = ((1UL<<8)-1) << 0, // DAC channel1 8-bit right-aligned data		
};
inline void dac_dhr8rd_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR8RD = (p->DHR8RD & ~DAC_DHR8RD_DACC2DHR) | ((val<<8) & DAC_DHR8RD_DACC2DHR); }
inline void dac_dhr8rd_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR8RD = (p->DHR8RD & ~DAC_DHR8RD_DACC1DHR) | ((val<<0) & DAC_DHR8RD_DACC1DHR); }
inline uint32_t dac_dhr8rd_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR8RD & DAC_DHR8RD_DACC2DHR) >> 8 ; }
inline uint32_t dac_dhr8rd_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR8RD & DAC_DHR8RD_DACC1DHR) >> 0 ; }

// DAC->DOR1 channel1 data output register
enum {
	DAC_DOR1_DACC1DOR = ((1UL<<12)-1) << 0, // DAC channel1 data output		
};
inline uint32_t dac_dor1_get_dacc1dor(struct DAC_Type* p) { return (p->DOR1 & DAC_DOR1_DACC1DOR) >> 0 ; }

// DAC->DOR2 channel2 data output register
enum {
	DAC_DOR2_DACC2DOR = ((1UL<<12)-1) << 0, // DAC channel2 data output		
};
inline uint32_t dac_dor2_get_dacc2dor(struct DAC_Type* p) { return (p->DOR2 & DAC_DOR2_DACC2DOR) >> 0 ; }

// DAC->SR status register
enum {
	DAC_SR_DMAUDR2 = 1UL<<29, // DAC channel2 DMA underrun flag
	DAC_SR_DMAUDR1 = 1UL<<13, // DAC channel1 DMA underrun flag		
};

/* Digital camera interface */
struct DCMI_Type {
	__IO uint16_t CR; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__I uint8_t SR; // @4 status register
	 uint8_t RESERVED1[3]; // @5 
	__I uint8_t RIS; // @8 raw interrupt status register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint8_t IER; // @12 interrupt enable register
	 uint8_t RESERVED3[3]; // @13 
	__I uint8_t MIS; // @16 masked interrupt status register
	 uint8_t RESERVED4[3]; // @17 
	__O uint8_t ICR; // @20 interrupt clear register
	 uint8_t RESERVED5[3]; // @21 
	__IO uint32_t ESCR; // @24 embedded synchronization code register
	__IO uint32_t ESUR; // @28 embedded synchronization unmask register
	__IO uint32_t CWSTRT; // @32 crop window start
	__IO uint32_t CWSIZE; // @36 crop window size
	__I uint32_t DR; // @40 data register
};

// DCMI->CR control register 1
enum {
	DCMI_CR_ENABLE = 1UL<<14, // DCMI enable
	DCMI_CR_EDM = ((1UL<<2)-1) << 10, // Extended data mode
	DCMI_CR_FCRC = ((1UL<<2)-1) << 8, // Frame capture rate control
	DCMI_CR_VSPOL = 1UL<<7, // Vertical synchronization polarity
	DCMI_CR_HSPOL = 1UL<<6, // Horizontal synchronization polarity
	DCMI_CR_PCKPOL = 1UL<<5, // Pixel clock polarity
	DCMI_CR_ESS = 1UL<<4, // Embedded synchronization select
	DCMI_CR_JPEG = 1UL<<3, // JPEG format
	DCMI_CR_CROP = 1UL<<2, // Crop feature
	DCMI_CR_CM = 1UL<<1, // Capture mode
	DCMI_CR_CAPTURE = 1UL<<0, // Capture enable		
};
inline void dcmi_cr_set_edm(struct DCMI_Type* p, uint32_t val) { p->CR = (p->CR & ~DCMI_CR_EDM) | ((val<<10) & DCMI_CR_EDM); }
inline void dcmi_cr_set_fcrc(struct DCMI_Type* p, uint32_t val) { p->CR = (p->CR & ~DCMI_CR_FCRC) | ((val<<8) & DCMI_CR_FCRC); }
inline uint32_t dcmi_cr_get_edm(struct DCMI_Type* p) { return (p->CR & DCMI_CR_EDM) >> 10 ; }
inline uint32_t dcmi_cr_get_fcrc(struct DCMI_Type* p) { return (p->CR & DCMI_CR_FCRC) >> 8 ; }

// DCMI->SR status register
enum {
	DCMI_SR_FNE = 1UL<<2, // FIFO not empty
	DCMI_SR_VSYNC = 1UL<<1, // VSYNC
	DCMI_SR_HSYNC = 1UL<<0, // HSYNC		
};

// DCMI->RIS raw interrupt status register
enum {
	DCMI_RIS_LINE_RIS = 1UL<<4, // Line raw interrupt status
	DCMI_RIS_VSYNC_RIS = 1UL<<3, // VSYNC raw interrupt status
	DCMI_RIS_ERR_RIS = 1UL<<2, // Synchronization error raw interrupt status
	DCMI_RIS_OVR_RIS = 1UL<<1, // Overrun raw interrupt status
	DCMI_RIS_FRAME_RIS = 1UL<<0, // Capture complete raw interrupt status		
};

// DCMI->IER interrupt enable register
enum {
	DCMI_IER_LINE_IE = 1UL<<4, // Line interrupt enable
	DCMI_IER_VSYNC_IE = 1UL<<3, // VSYNC interrupt enable
	DCMI_IER_ERR_IE = 1UL<<2, // Synchronization error interrupt enable
	DCMI_IER_OVR_IE = 1UL<<1, // Overrun interrupt enable
	DCMI_IER_FRAME_IE = 1UL<<0, // Capture complete interrupt enable		
};

// DCMI->MIS masked interrupt status register
enum {
	DCMI_MIS_LINE_MIS = 1UL<<4, // Line masked interrupt status
	DCMI_MIS_VSYNC_MIS = 1UL<<3, // VSYNC masked interrupt status
	DCMI_MIS_ERR_MIS = 1UL<<2, // Synchronization error masked interrupt status
	DCMI_MIS_OVR_MIS = 1UL<<1, // Overrun masked interrupt status
	DCMI_MIS_FRAME_MIS = 1UL<<0, // Capture complete masked interrupt status		
};

// DCMI->ICR interrupt clear register
enum {
	DCMI_ICR_LINE_ISC = 1UL<<4, // line interrupt status clear
	DCMI_ICR_VSYNC_ISC = 1UL<<3, // Vertical synch interrupt status clear
	DCMI_ICR_ERR_ISC = 1UL<<2, // Synchronization error interrupt status clear
	DCMI_ICR_OVR_ISC = 1UL<<1, // Overrun interrupt status clear
	DCMI_ICR_FRAME_ISC = 1UL<<0, // Capture complete interrupt status clear		
};

// DCMI->ESCR embedded synchronization code register
enum {
	DCMI_ESCR_FEC = ((1UL<<8)-1) << 24, // Frame end delimiter code
	DCMI_ESCR_LEC = ((1UL<<8)-1) << 16, // Line end delimiter code
	DCMI_ESCR_LSC = ((1UL<<8)-1) << 8, // Line start delimiter code
	DCMI_ESCR_FSC = ((1UL<<8)-1) << 0, // Frame start delimiter code		
};
inline void dcmi_escr_set_fec(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_FEC) | ((val<<24) & DCMI_ESCR_FEC); }
inline void dcmi_escr_set_lec(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_LEC) | ((val<<16) & DCMI_ESCR_LEC); }
inline void dcmi_escr_set_lsc(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_LSC) | ((val<<8) & DCMI_ESCR_LSC); }
inline void dcmi_escr_set_fsc(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_FSC) | ((val<<0) & DCMI_ESCR_FSC); }
inline uint32_t dcmi_escr_get_fec(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_FEC) >> 24 ; }
inline uint32_t dcmi_escr_get_lec(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_LEC) >> 16 ; }
inline uint32_t dcmi_escr_get_lsc(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_LSC) >> 8 ; }
inline uint32_t dcmi_escr_get_fsc(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_FSC) >> 0 ; }

// DCMI->ESUR embedded synchronization unmask register
enum {
	DCMI_ESUR_FEU = ((1UL<<8)-1) << 24, // Frame end delimiter unmask
	DCMI_ESUR_LEU = ((1UL<<8)-1) << 16, // Line end delimiter unmask
	DCMI_ESUR_LSU = ((1UL<<8)-1) << 8, // Line start delimiter unmask
	DCMI_ESUR_FSU = ((1UL<<8)-1) << 0, // Frame start delimiter unmask		
};
inline void dcmi_esur_set_feu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_FEU) | ((val<<24) & DCMI_ESUR_FEU); }
inline void dcmi_esur_set_leu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_LEU) | ((val<<16) & DCMI_ESUR_LEU); }
inline void dcmi_esur_set_lsu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_LSU) | ((val<<8) & DCMI_ESUR_LSU); }
inline void dcmi_esur_set_fsu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_FSU) | ((val<<0) & DCMI_ESUR_FSU); }
inline uint32_t dcmi_esur_get_feu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_FEU) >> 24 ; }
inline uint32_t dcmi_esur_get_leu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_LEU) >> 16 ; }
inline uint32_t dcmi_esur_get_lsu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_LSU) >> 8 ; }
inline uint32_t dcmi_esur_get_fsu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_FSU) >> 0 ; }

// DCMI->CWSTRT crop window start
enum {
	DCMI_CWSTRT_VST = ((1UL<<13)-1) << 16, // Vertical start line count
	DCMI_CWSTRT_HOFFCNT = ((1UL<<14)-1) << 0, // Horizontal offset count		
};
inline void dcmi_cwstrt_set_vst(struct DCMI_Type* p, uint32_t val) { p->CWSTRT = (p->CWSTRT & ~DCMI_CWSTRT_VST) | ((val<<16) & DCMI_CWSTRT_VST); }
inline void dcmi_cwstrt_set_hoffcnt(struct DCMI_Type* p, uint32_t val) { p->CWSTRT = (p->CWSTRT & ~DCMI_CWSTRT_HOFFCNT) | ((val<<0) & DCMI_CWSTRT_HOFFCNT); }
inline uint32_t dcmi_cwstrt_get_vst(struct DCMI_Type* p) { return (p->CWSTRT & DCMI_CWSTRT_VST) >> 16 ; }
inline uint32_t dcmi_cwstrt_get_hoffcnt(struct DCMI_Type* p) { return (p->CWSTRT & DCMI_CWSTRT_HOFFCNT) >> 0 ; }

// DCMI->CWSIZE crop window size
enum {
	DCMI_CWSIZE_VLINE = ((1UL<<14)-1) << 16, // Vertical line count
	DCMI_CWSIZE_CAPCNT = ((1UL<<14)-1) << 0, // Capture count		
};
inline void dcmi_cwsize_set_vline(struct DCMI_Type* p, uint32_t val) { p->CWSIZE = (p->CWSIZE & ~DCMI_CWSIZE_VLINE) | ((val<<16) & DCMI_CWSIZE_VLINE); }
inline void dcmi_cwsize_set_capcnt(struct DCMI_Type* p, uint32_t val) { p->CWSIZE = (p->CWSIZE & ~DCMI_CWSIZE_CAPCNT) | ((val<<0) & DCMI_CWSIZE_CAPCNT); }
inline uint32_t dcmi_cwsize_get_vline(struct DCMI_Type* p) { return (p->CWSIZE & DCMI_CWSIZE_VLINE) >> 16 ; }
inline uint32_t dcmi_cwsize_get_capcnt(struct DCMI_Type* p) { return (p->CWSIZE & DCMI_CWSIZE_CAPCNT) >> 0 ; }

// DCMI->DR data register
enum {
	DCMI_DR_BYTE3 = ((1UL<<8)-1) << 24, // Data byte 3
	DCMI_DR_BYTE2 = ((1UL<<8)-1) << 16, // Data byte 2
	DCMI_DR_BYTE1 = ((1UL<<8)-1) << 8, // Data byte 1
	DCMI_DR_BYTE0 = ((1UL<<8)-1) << 0, // Data byte 0		
};
inline uint32_t dcmi_dr_get_byte3(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE3) >> 24 ; }
inline uint32_t dcmi_dr_get_byte2(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE2) >> 16 ; }
inline uint32_t dcmi_dr_get_byte1(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE1) >> 8 ; }
inline uint32_t dcmi_dr_get_byte0(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE0) >> 0 ; }

/* Digital filter for sigma delta modulators */
struct DFSDM_Type {
	__IO uint32_t CHCFG0R1; // @0 DFSDM channel configuration 0 register 1
	__IO uint32_t CHCFG0R2; // @4 DFSDM channel configuration 0 register 2
	__IO uint32_t AWSCD0R; // @8 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT0R; // @12 DFSDM channel watchdog filter data register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint32_t CHDATIN0R; // @16 DFSDM channel data input register
	 uint8_t RESERVED1[12]; // @20 
	__IO uint32_t CHCFG1R1; // @32 DFSDM channel configuration 1 register 1
	__IO uint32_t CHCFG1R2; // @36 DFSDM channel configuration 1 register 2
	__IO uint32_t AWSCD1R; // @40 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT1R; // @44 DFSDM channel watchdog filter data register
	 uint8_t RESERVED2[2]; // @46 
	__IO uint32_t CHDATIN1R; // @48 DFSDM channel data input register
	 uint8_t RESERVED3[12]; // @52 
	__IO uint32_t CHCFG2R1; // @64 DFSDM channel configuration 2 register 1
	__IO uint32_t CHCFG2R2; // @68 DFSDM channel configuration 2 register 2
	__IO uint32_t AWSCD2R; // @72 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT2R; // @76 DFSDM channel watchdog filter data register
	 uint8_t RESERVED4[2]; // @78 
	__IO uint32_t CHDATIN2R; // @80 DFSDM channel data input register
	 uint8_t RESERVED5[12]; // @84 
	__IO uint32_t CHCFG3R1; // @96 DFSDM channel configuration 3 register 1
	__IO uint32_t CHCFG3R2; // @100 DFSDM channel configuration 3 register 2
	__IO uint32_t AWSCD3R; // @104 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT3R; // @108 DFSDM channel watchdog filter data register
	 uint8_t RESERVED6[2]; // @110 
	__IO uint32_t CHDATIN3R; // @112 DFSDM channel data input register
	 uint8_t RESERVED7[12]; // @116 
	__IO uint32_t CHCFG4R1; // @128 DFSDM channel configuration 4 register 1
	__IO uint32_t CHCFG4R2; // @132 DFSDM channel configuration 4 register 2
	__IO uint32_t AWSCD4R; // @136 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT4R; // @140 DFSDM channel watchdog filter data register
	 uint8_t RESERVED8[2]; // @142 
	__IO uint32_t CHDATIN4R; // @144 DFSDM channel data input register
	 uint8_t RESERVED9[12]; // @148 
	__IO uint32_t CHCFG5R1; // @160 DFSDM channel configuration 5 register 1
	__IO uint32_t CHCFG5R2; // @164 DFSDM channel configuration 5 register 2
	__IO uint32_t AWSCD5R; // @168 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT5R; // @172 DFSDM channel watchdog filter data register
	 uint8_t RESERVED10[2]; // @174 
	__IO uint32_t CHDATIN5R; // @176 DFSDM channel data input register
	 uint8_t RESERVED11[12]; // @180 
	__IO uint32_t CHCFG6R1; // @192 DFSDM channel configuration 6 register 1
	__IO uint32_t CHCFG6R2; // @196 DFSDM channel configuration 6 register 2
	__IO uint32_t AWSCD6R; // @200 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT6R; // @204 DFSDM channel watchdog filter data register
	 uint8_t RESERVED12[2]; // @206 
	__IO uint32_t CHDATIN6R; // @208 DFSDM channel data input register
	 uint8_t RESERVED13[12]; // @212 
	__IO uint32_t CHCFG7R1; // @224 DFSDM channel configuration 7 register 1
	__IO uint32_t CHCFG7R2; // @228 DFSDM channel configuration 7 register 2
	__IO uint32_t AWSCD7R; // @232 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t CHWDAT7R; // @236 DFSDM channel watchdog filter data register
	 uint8_t RESERVED14[2]; // @238 
	__IO uint32_t CHDATIN7R; // @240 DFSDM channel data input register
	 uint8_t RESERVED15[12]; // @244 
	__IO uint32_t DFSDM0_CR1; // @256 DFSDM control register 1
	__IO uint32_t DFSDM0_CR2; // @260 DFSDM control register 2
	__I uint32_t DFSDM0_ISR; // @264 DFSDM interrupt and status register
	__IO uint32_t DFSDM0_ICR; // @268 DFSDM interrupt flag clear register
	__IO uint8_t DFSDM0_JCHGR; // @272 DFSDM injected channel group selection register
	 uint8_t RESERVED16[3]; // @273 
	__IO uint32_t DFSDM0_FCR; // @276 DFSDM filter control register
	__I uint32_t DFSDM0_JDATAR; // @280 DFSDM data register for injected group
	__I uint32_t DFSDM0_RDATAR; // @284 DFSDM data register for the regular channel
	__IO uint32_t DFSDM0_AWHTR; // @288 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM0_AWLTR; // @292 DFSDM analog watchdog low threshold register
	__I uint16_t DFSDM0_AWSR; // @296 DFSDM analog watchdog status register
	 uint8_t RESERVED17[2]; // @298 
	__IO uint16_t DFSDM0_AWCFR; // @300 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED18[2]; // @302 
	__I uint32_t DFSDM0_EXMAX; // @304 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM0_EXMIN; // @308 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM0_CNVTIMR; // @312 DFSDM conversion timer register
	 uint8_t RESERVED19[68]; // @316 
	__IO uint32_t DFSDM1_CR1; // @384 DFSDM control register 1
	__IO uint32_t DFSDM1_CR2; // @388 DFSDM control register 2
	__I uint32_t DFSDM1_ISR; // @392 DFSDM interrupt and status register
	__IO uint32_t DFSDM1_ICR; // @396 DFSDM interrupt flag clear register
	__IO uint8_t DFSDM1_JCHGR; // @400 DFSDM injected channel group selection register
	 uint8_t RESERVED20[3]; // @401 
	__IO uint32_t DFSDM1_FCR; // @404 DFSDM filter control register
	union {  // @408
		__I uint32_t DFSDM1_JDATAR; // DFSDM data register for injected group
		__I uint32_t DFSDM1_RDATAR; // DFSDM data register for the regular channel
	};
	 uint8_t RESERVED21[4]; // @412 
	__IO uint32_t DFSDM1_AWHTR; // @416 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM1_AWLTR; // @420 DFSDM analog watchdog low threshold register
	__I uint16_t DFSDM1_AWSR; // @424 DFSDM analog watchdog status register
	 uint8_t RESERVED22[2]; // @426 
	__IO uint16_t DFSDM1_AWCFR; // @428 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED23[2]; // @430 
	__I uint32_t DFSDM1_EXMAX; // @432 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM1_EXMIN; // @436 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM1_CNVTIMR; // @440 DFSDM conversion timer register
	 uint8_t RESERVED24[68]; // @444 
	__IO uint32_t DFSDM2_CR1; // @512 DFSDM control register 1
	__IO uint32_t DFSDM2_CR2; // @516 DFSDM control register 2
	__I uint32_t DFSDM2_ISR; // @520 DFSDM interrupt and status register
	__IO uint32_t DFSDM2_ICR; // @524 DFSDM interrupt flag clear register
	__IO uint8_t DFSDM2_JCHGR; // @528 DFSDM injected channel group selection register
	 uint8_t RESERVED25[3]; // @529 
	__IO uint32_t DFSDM2_FCR; // @532 DFSDM filter control register
	union {  // @536
		__I uint32_t DFSDM2_RDATAR; // DFSDM data register for the regular channel
		__I uint32_t DFSDM2_JDATAR; // DFSDM data register for injected group
	};
	 uint8_t RESERVED26[4]; // @540 
	__IO uint32_t DFSDM2_AWHTR; // @544 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM2_AWLTR; // @548 DFSDM analog watchdog low threshold register
	__I uint16_t DFSDM2_AWSR; // @552 DFSDM analog watchdog status register
	 uint8_t RESERVED27[2]; // @554 
	__IO uint16_t DFSDM2_AWCFR; // @556 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED28[2]; // @558 
	__I uint32_t DFSDM2_EXMAX; // @560 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM2_EXMIN; // @564 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM2_CNVTIMR; // @568 DFSDM conversion timer register
	 uint8_t RESERVED29[100]; // @572 
	__IO uint32_t DFSDM3_AWHTR; // @672 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM3_AWLTR; // @676 DFSDM analog watchdog low threshold register
	__I uint16_t DFSDM3_AWSR; // @680 DFSDM analog watchdog status register
	 uint8_t RESERVED30[2]; // @682 
	__IO uint16_t DFSDM3_AWCFR; // @684 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED31[2]; // @686 
	__I uint32_t DFSDM3_EXMAX; // @688 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM3_EXMIN; // @692 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM3_CNVTIMR; // @696 DFSDM conversion timer register
	 uint8_t RESERVED32[84]; // @700 
	__IO uint8_t DFSDM3_JCHGR; // @784 DFSDM injected channel group selection register
	 uint8_t RESERVED33[3]; // @785 
	__IO uint32_t DFSDM3_FCR; // @788 DFSDM filter control register
	union {  // @792
		__I uint32_t DFSDM3_RDATAR; // DFSDM data register for the regular channel
		__I uint32_t DFSDM3_JDATAR; // DFSDM data register for injected group
	};
	 uint8_t RESERVED34[100]; // @796 
	__IO uint32_t DFSDM3_CR1; // @896 DFSDM control register 1
	__IO uint32_t DFSDM3_CR2; // @900 DFSDM control register 2
	__I uint32_t DFSDM3_ISR; // @904 DFSDM interrupt and status register
	__IO uint32_t DFSDM3_ICR; // @908 DFSDM interrupt flag clear register
};

// DFSDM->CHCFG0R1 DFSDM channel configuration 0 register 1
enum {
	DFSDM_CHCFG0R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG0R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG0R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG0R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG0R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 0
	DFSDM_CHCFG0R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG0R1_CHEN = 1UL<<7, // Channel 0 enable
	DFSDM_CHCFG0R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 0
	DFSDM_CHCFG0R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 0
	DFSDM_CHCFG0R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 0
	DFSDM_CHCFG0R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 0		
};
inline void dfsdm_chcfg0r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG0R1_CKOUTDIV); }
inline void dfsdm_chcfg0r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_DATPACK) | ((val<<14) & DFSDM_CHCFG0R1_DATPACK); }
inline void dfsdm_chcfg0r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_DATMPX) | ((val<<12) & DFSDM_CHCFG0R1_DATMPX); }
inline void dfsdm_chcfg0r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG0R1_SPICKSEL); }
inline void dfsdm_chcfg0r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_SITP) | ((val<<0) & DFSDM_CHCFG0R1_SITP); }
inline uint32_t dfsdm_chcfg0r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg0r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg0r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg0r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg0r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_SITP) >> 0 ; }

// DFSDM->CHCFG0R2 DFSDM channel configuration 0 register 2
enum {
	DFSDM_CHCFG0R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 0
	DFSDM_CHCFG0R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 0		
};
inline void dfsdm_chcfg0r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R2 = (p->CHCFG0R2 & ~DFSDM_CHCFG0R2_OFFSET) | ((val<<8) & DFSDM_CHCFG0R2_OFFSET); }
inline void dfsdm_chcfg0r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R2 = (p->CHCFG0R2 & ~DFSDM_CHCFG0R2_DTRBS) | ((val<<3) & DFSDM_CHCFG0R2_DTRBS); }
inline uint32_t dfsdm_chcfg0r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG0R2 & DFSDM_CHCFG0R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg0r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG0R2 & DFSDM_CHCFG0R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD0R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD0R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 0
	DFSDM_AWSCD0R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 0
	DFSDM_AWSCD0R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 0
	DFSDM_AWSCD0R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 0		
};
inline void dfsdm_awscd0r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_AWFORD) | ((val<<22) & DFSDM_AWSCD0R_AWFORD); }
inline void dfsdm_awscd0r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_AWFOSR) | ((val<<16) & DFSDM_AWSCD0R_AWFOSR); }
inline void dfsdm_awscd0r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_BKSCD) | ((val<<12) & DFSDM_AWSCD0R_BKSCD); }
inline void dfsdm_awscd0r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_SCDT) | ((val<<0) & DFSDM_AWSCD0R_SCDT); }
inline uint32_t dfsdm_awscd0r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd0r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd0r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd0r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_SCDT) >> 0 ; }

// DFSDM->CHDATIN0R DFSDM channel data input register
enum {
	DFSDM_CHDATIN0R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 1
	DFSDM_CHDATIN0R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 0		
};
inline void dfsdm_chdatin0r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN0R = (p->CHDATIN0R & ~DFSDM_CHDATIN0R_INDAT1) | ((val<<16) & DFSDM_CHDATIN0R_INDAT1); }
inline void dfsdm_chdatin0r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN0R = (p->CHDATIN0R & ~DFSDM_CHDATIN0R_INDAT0) | ((val<<0) & DFSDM_CHDATIN0R_INDAT0); }
inline uint32_t dfsdm_chdatin0r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN0R & DFSDM_CHDATIN0R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin0r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN0R & DFSDM_CHDATIN0R_INDAT0) >> 0 ; }

// DFSDM->CHCFG1R1 DFSDM channel configuration 1 register 1
enum {
	DFSDM_CHCFG1R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG1R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG1R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG1R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG1R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 1
	DFSDM_CHCFG1R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG1R1_CHEN = 1UL<<7, // Channel 1 enable
	DFSDM_CHCFG1R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 1
	DFSDM_CHCFG1R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 1
	DFSDM_CHCFG1R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 1
	DFSDM_CHCFG1R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 1		
};
inline void dfsdm_chcfg1r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG1R1_CKOUTDIV); }
inline void dfsdm_chcfg1r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_DATPACK) | ((val<<14) & DFSDM_CHCFG1R1_DATPACK); }
inline void dfsdm_chcfg1r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_DATMPX) | ((val<<12) & DFSDM_CHCFG1R1_DATMPX); }
inline void dfsdm_chcfg1r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG1R1_SPICKSEL); }
inline void dfsdm_chcfg1r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_SITP) | ((val<<0) & DFSDM_CHCFG1R1_SITP); }
inline uint32_t dfsdm_chcfg1r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg1r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg1r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg1r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg1r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_SITP) >> 0 ; }

// DFSDM->CHCFG1R2 DFSDM channel configuration 1 register 2
enum {
	DFSDM_CHCFG1R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 1
	DFSDM_CHCFG1R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 1		
};
inline void dfsdm_chcfg1r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R2 = (p->CHCFG1R2 & ~DFSDM_CHCFG1R2_OFFSET) | ((val<<8) & DFSDM_CHCFG1R2_OFFSET); }
inline void dfsdm_chcfg1r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R2 = (p->CHCFG1R2 & ~DFSDM_CHCFG1R2_DTRBS) | ((val<<3) & DFSDM_CHCFG1R2_DTRBS); }
inline uint32_t dfsdm_chcfg1r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG1R2 & DFSDM_CHCFG1R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg1r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG1R2 & DFSDM_CHCFG1R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD1R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD1R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 1
	DFSDM_AWSCD1R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 1
	DFSDM_AWSCD1R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 1
	DFSDM_AWSCD1R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 1		
};
inline void dfsdm_awscd1r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_AWFORD) | ((val<<22) & DFSDM_AWSCD1R_AWFORD); }
inline void dfsdm_awscd1r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_AWFOSR) | ((val<<16) & DFSDM_AWSCD1R_AWFOSR); }
inline void dfsdm_awscd1r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_BKSCD) | ((val<<12) & DFSDM_AWSCD1R_BKSCD); }
inline void dfsdm_awscd1r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_SCDT) | ((val<<0) & DFSDM_AWSCD1R_SCDT); }
inline uint32_t dfsdm_awscd1r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd1r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd1r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd1r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_SCDT) >> 0 ; }

// DFSDM->CHDATIN1R DFSDM channel data input register
enum {
	DFSDM_CHDATIN1R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 2
	DFSDM_CHDATIN1R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 1		
};
inline void dfsdm_chdatin1r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN1R = (p->CHDATIN1R & ~DFSDM_CHDATIN1R_INDAT1) | ((val<<16) & DFSDM_CHDATIN1R_INDAT1); }
inline void dfsdm_chdatin1r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN1R = (p->CHDATIN1R & ~DFSDM_CHDATIN1R_INDAT0) | ((val<<0) & DFSDM_CHDATIN1R_INDAT0); }
inline uint32_t dfsdm_chdatin1r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN1R & DFSDM_CHDATIN1R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin1r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN1R & DFSDM_CHDATIN1R_INDAT0) >> 0 ; }

// DFSDM->CHCFG2R1 DFSDM channel configuration 2 register 1
enum {
	DFSDM_CHCFG2R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG2R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG2R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG2R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG2R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 2
	DFSDM_CHCFG2R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG2R1_CHEN = 1UL<<7, // Channel 2 enable
	DFSDM_CHCFG2R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 2
	DFSDM_CHCFG2R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 2
	DFSDM_CHCFG2R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 2
	DFSDM_CHCFG2R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 2		
};
inline void dfsdm_chcfg2r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG2R1_CKOUTDIV); }
inline void dfsdm_chcfg2r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_DATPACK) | ((val<<14) & DFSDM_CHCFG2R1_DATPACK); }
inline void dfsdm_chcfg2r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_DATMPX) | ((val<<12) & DFSDM_CHCFG2R1_DATMPX); }
inline void dfsdm_chcfg2r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG2R1_SPICKSEL); }
inline void dfsdm_chcfg2r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_SITP) | ((val<<0) & DFSDM_CHCFG2R1_SITP); }
inline uint32_t dfsdm_chcfg2r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg2r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg2r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg2r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg2r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_SITP) >> 0 ; }

// DFSDM->CHCFG2R2 DFSDM channel configuration 2 register 2
enum {
	DFSDM_CHCFG2R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 2
	DFSDM_CHCFG2R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 2		
};
inline void dfsdm_chcfg2r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R2 = (p->CHCFG2R2 & ~DFSDM_CHCFG2R2_OFFSET) | ((val<<8) & DFSDM_CHCFG2R2_OFFSET); }
inline void dfsdm_chcfg2r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R2 = (p->CHCFG2R2 & ~DFSDM_CHCFG2R2_DTRBS) | ((val<<3) & DFSDM_CHCFG2R2_DTRBS); }
inline uint32_t dfsdm_chcfg2r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG2R2 & DFSDM_CHCFG2R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg2r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG2R2 & DFSDM_CHCFG2R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD2R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD2R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 2
	DFSDM_AWSCD2R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 2
	DFSDM_AWSCD2R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 2
	DFSDM_AWSCD2R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 2		
};
inline void dfsdm_awscd2r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_AWFORD) | ((val<<22) & DFSDM_AWSCD2R_AWFORD); }
inline void dfsdm_awscd2r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_AWFOSR) | ((val<<16) & DFSDM_AWSCD2R_AWFOSR); }
inline void dfsdm_awscd2r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_BKSCD) | ((val<<12) & DFSDM_AWSCD2R_BKSCD); }
inline void dfsdm_awscd2r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_SCDT) | ((val<<0) & DFSDM_AWSCD2R_SCDT); }
inline uint32_t dfsdm_awscd2r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd2r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd2r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd2r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_SCDT) >> 0 ; }

// DFSDM->CHDATIN2R DFSDM channel data input register
enum {
	DFSDM_CHDATIN2R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 3
	DFSDM_CHDATIN2R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 2		
};
inline void dfsdm_chdatin2r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN2R = (p->CHDATIN2R & ~DFSDM_CHDATIN2R_INDAT1) | ((val<<16) & DFSDM_CHDATIN2R_INDAT1); }
inline void dfsdm_chdatin2r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN2R = (p->CHDATIN2R & ~DFSDM_CHDATIN2R_INDAT0) | ((val<<0) & DFSDM_CHDATIN2R_INDAT0); }
inline uint32_t dfsdm_chdatin2r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN2R & DFSDM_CHDATIN2R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin2r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN2R & DFSDM_CHDATIN2R_INDAT0) >> 0 ; }

// DFSDM->CHCFG3R1 DFSDM channel configuration 3 register 1
enum {
	DFSDM_CHCFG3R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG3R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG3R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG3R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG3R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 3
	DFSDM_CHCFG3R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG3R1_CHEN = 1UL<<7, // Channel 3 enable
	DFSDM_CHCFG3R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 3
	DFSDM_CHCFG3R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 3
	DFSDM_CHCFG3R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 3
	DFSDM_CHCFG3R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 3		
};
inline void dfsdm_chcfg3r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG3R1_CKOUTDIV); }
inline void dfsdm_chcfg3r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_DATPACK) | ((val<<14) & DFSDM_CHCFG3R1_DATPACK); }
inline void dfsdm_chcfg3r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_DATMPX) | ((val<<12) & DFSDM_CHCFG3R1_DATMPX); }
inline void dfsdm_chcfg3r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG3R1_SPICKSEL); }
inline void dfsdm_chcfg3r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_SITP) | ((val<<0) & DFSDM_CHCFG3R1_SITP); }
inline uint32_t dfsdm_chcfg3r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg3r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg3r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg3r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg3r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_SITP) >> 0 ; }

// DFSDM->CHCFG3R2 DFSDM channel configuration 3 register 2
enum {
	DFSDM_CHCFG3R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 3
	DFSDM_CHCFG3R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 3		
};
inline void dfsdm_chcfg3r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R2 = (p->CHCFG3R2 & ~DFSDM_CHCFG3R2_OFFSET) | ((val<<8) & DFSDM_CHCFG3R2_OFFSET); }
inline void dfsdm_chcfg3r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R2 = (p->CHCFG3R2 & ~DFSDM_CHCFG3R2_DTRBS) | ((val<<3) & DFSDM_CHCFG3R2_DTRBS); }
inline uint32_t dfsdm_chcfg3r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG3R2 & DFSDM_CHCFG3R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg3r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG3R2 & DFSDM_CHCFG3R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD3R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD3R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 3
	DFSDM_AWSCD3R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 3
	DFSDM_AWSCD3R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 3
	DFSDM_AWSCD3R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 3		
};
inline void dfsdm_awscd3r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_AWFORD) | ((val<<22) & DFSDM_AWSCD3R_AWFORD); }
inline void dfsdm_awscd3r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_AWFOSR) | ((val<<16) & DFSDM_AWSCD3R_AWFOSR); }
inline void dfsdm_awscd3r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_BKSCD) | ((val<<12) & DFSDM_AWSCD3R_BKSCD); }
inline void dfsdm_awscd3r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_SCDT) | ((val<<0) & DFSDM_AWSCD3R_SCDT); }
inline uint32_t dfsdm_awscd3r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd3r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd3r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd3r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_SCDT) >> 0 ; }

// DFSDM->CHDATIN3R DFSDM channel data input register
enum {
	DFSDM_CHDATIN3R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 4
	DFSDM_CHDATIN3R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 3		
};
inline void dfsdm_chdatin3r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN3R = (p->CHDATIN3R & ~DFSDM_CHDATIN3R_INDAT1) | ((val<<16) & DFSDM_CHDATIN3R_INDAT1); }
inline void dfsdm_chdatin3r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN3R = (p->CHDATIN3R & ~DFSDM_CHDATIN3R_INDAT0) | ((val<<0) & DFSDM_CHDATIN3R_INDAT0); }
inline uint32_t dfsdm_chdatin3r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN3R & DFSDM_CHDATIN3R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin3r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN3R & DFSDM_CHDATIN3R_INDAT0) >> 0 ; }

// DFSDM->CHCFG4R1 DFSDM channel configuration 4 register 1
enum {
	DFSDM_CHCFG4R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG4R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG4R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG4R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG4R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 4
	DFSDM_CHCFG4R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG4R1_CHEN = 1UL<<7, // Channel 4 enable
	DFSDM_CHCFG4R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 4
	DFSDM_CHCFG4R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 4
	DFSDM_CHCFG4R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 4
	DFSDM_CHCFG4R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 4		
};
inline void dfsdm_chcfg4r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG4R1_CKOUTDIV); }
inline void dfsdm_chcfg4r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_DATPACK) | ((val<<14) & DFSDM_CHCFG4R1_DATPACK); }
inline void dfsdm_chcfg4r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_DATMPX) | ((val<<12) & DFSDM_CHCFG4R1_DATMPX); }
inline void dfsdm_chcfg4r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG4R1_SPICKSEL); }
inline void dfsdm_chcfg4r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_SITP) | ((val<<0) & DFSDM_CHCFG4R1_SITP); }
inline uint32_t dfsdm_chcfg4r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg4r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg4r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg4r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg4r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_SITP) >> 0 ; }

// DFSDM->CHCFG4R2 DFSDM channel configuration 4 register 2
enum {
	DFSDM_CHCFG4R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 4
	DFSDM_CHCFG4R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 4		
};
inline void dfsdm_chcfg4r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R2 = (p->CHCFG4R2 & ~DFSDM_CHCFG4R2_OFFSET) | ((val<<8) & DFSDM_CHCFG4R2_OFFSET); }
inline void dfsdm_chcfg4r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R2 = (p->CHCFG4R2 & ~DFSDM_CHCFG4R2_DTRBS) | ((val<<3) & DFSDM_CHCFG4R2_DTRBS); }
inline uint32_t dfsdm_chcfg4r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG4R2 & DFSDM_CHCFG4R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg4r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG4R2 & DFSDM_CHCFG4R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD4R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD4R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 4
	DFSDM_AWSCD4R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 4
	DFSDM_AWSCD4R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 4
	DFSDM_AWSCD4R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 4		
};
inline void dfsdm_awscd4r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_AWFORD) | ((val<<22) & DFSDM_AWSCD4R_AWFORD); }
inline void dfsdm_awscd4r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_AWFOSR) | ((val<<16) & DFSDM_AWSCD4R_AWFOSR); }
inline void dfsdm_awscd4r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_BKSCD) | ((val<<12) & DFSDM_AWSCD4R_BKSCD); }
inline void dfsdm_awscd4r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_SCDT) | ((val<<0) & DFSDM_AWSCD4R_SCDT); }
inline uint32_t dfsdm_awscd4r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd4r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd4r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd4r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_SCDT) >> 0 ; }

// DFSDM->CHDATIN4R DFSDM channel data input register
enum {
	DFSDM_CHDATIN4R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 5
	DFSDM_CHDATIN4R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 4		
};
inline void dfsdm_chdatin4r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN4R = (p->CHDATIN4R & ~DFSDM_CHDATIN4R_INDAT1) | ((val<<16) & DFSDM_CHDATIN4R_INDAT1); }
inline void dfsdm_chdatin4r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN4R = (p->CHDATIN4R & ~DFSDM_CHDATIN4R_INDAT0) | ((val<<0) & DFSDM_CHDATIN4R_INDAT0); }
inline uint32_t dfsdm_chdatin4r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN4R & DFSDM_CHDATIN4R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin4r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN4R & DFSDM_CHDATIN4R_INDAT0) >> 0 ; }

// DFSDM->CHCFG5R1 DFSDM channel configuration 5 register 1
enum {
	DFSDM_CHCFG5R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG5R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG5R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG5R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG5R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 5
	DFSDM_CHCFG5R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG5R1_CHEN = 1UL<<7, // Channel 5 enable
	DFSDM_CHCFG5R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 5
	DFSDM_CHCFG5R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 5
	DFSDM_CHCFG5R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 5
	DFSDM_CHCFG5R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 5		
};
inline void dfsdm_chcfg5r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG5R1_CKOUTDIV); }
inline void dfsdm_chcfg5r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_DATPACK) | ((val<<14) & DFSDM_CHCFG5R1_DATPACK); }
inline void dfsdm_chcfg5r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_DATMPX) | ((val<<12) & DFSDM_CHCFG5R1_DATMPX); }
inline void dfsdm_chcfg5r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG5R1_SPICKSEL); }
inline void dfsdm_chcfg5r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_SITP) | ((val<<0) & DFSDM_CHCFG5R1_SITP); }
inline uint32_t dfsdm_chcfg5r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg5r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg5r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg5r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg5r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_SITP) >> 0 ; }

// DFSDM->CHCFG5R2 DFSDM channel configuration 5 register 2
enum {
	DFSDM_CHCFG5R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 5
	DFSDM_CHCFG5R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 5		
};
inline void dfsdm_chcfg5r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R2 = (p->CHCFG5R2 & ~DFSDM_CHCFG5R2_OFFSET) | ((val<<8) & DFSDM_CHCFG5R2_OFFSET); }
inline void dfsdm_chcfg5r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R2 = (p->CHCFG5R2 & ~DFSDM_CHCFG5R2_DTRBS) | ((val<<3) & DFSDM_CHCFG5R2_DTRBS); }
inline uint32_t dfsdm_chcfg5r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG5R2 & DFSDM_CHCFG5R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg5r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG5R2 & DFSDM_CHCFG5R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD5R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD5R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 5
	DFSDM_AWSCD5R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 5
	DFSDM_AWSCD5R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 5
	DFSDM_AWSCD5R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 5		
};
inline void dfsdm_awscd5r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_AWFORD) | ((val<<22) & DFSDM_AWSCD5R_AWFORD); }
inline void dfsdm_awscd5r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_AWFOSR) | ((val<<16) & DFSDM_AWSCD5R_AWFOSR); }
inline void dfsdm_awscd5r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_BKSCD) | ((val<<12) & DFSDM_AWSCD5R_BKSCD); }
inline void dfsdm_awscd5r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_SCDT) | ((val<<0) & DFSDM_AWSCD5R_SCDT); }
inline uint32_t dfsdm_awscd5r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd5r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd5r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd5r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_SCDT) >> 0 ; }

// DFSDM->CHDATIN5R DFSDM channel data input register
enum {
	DFSDM_CHDATIN5R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 6
	DFSDM_CHDATIN5R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 5		
};
inline void dfsdm_chdatin5r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN5R = (p->CHDATIN5R & ~DFSDM_CHDATIN5R_INDAT1) | ((val<<16) & DFSDM_CHDATIN5R_INDAT1); }
inline void dfsdm_chdatin5r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN5R = (p->CHDATIN5R & ~DFSDM_CHDATIN5R_INDAT0) | ((val<<0) & DFSDM_CHDATIN5R_INDAT0); }
inline uint32_t dfsdm_chdatin5r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN5R & DFSDM_CHDATIN5R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin5r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN5R & DFSDM_CHDATIN5R_INDAT0) >> 0 ; }

// DFSDM->CHCFG6R1 DFSDM channel configuration 6 register 1
enum {
	DFSDM_CHCFG6R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG6R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG6R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG6R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG6R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 6
	DFSDM_CHCFG6R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG6R1_CHEN = 1UL<<7, // Channel 6 enable
	DFSDM_CHCFG6R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 6
	DFSDM_CHCFG6R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 6
	DFSDM_CHCFG6R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 6
	DFSDM_CHCFG6R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 6		
};
inline void dfsdm_chcfg6r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG6R1_CKOUTDIV); }
inline void dfsdm_chcfg6r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_DATPACK) | ((val<<14) & DFSDM_CHCFG6R1_DATPACK); }
inline void dfsdm_chcfg6r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_DATMPX) | ((val<<12) & DFSDM_CHCFG6R1_DATMPX); }
inline void dfsdm_chcfg6r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG6R1_SPICKSEL); }
inline void dfsdm_chcfg6r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_SITP) | ((val<<0) & DFSDM_CHCFG6R1_SITP); }
inline uint32_t dfsdm_chcfg6r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg6r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg6r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg6r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg6r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_SITP) >> 0 ; }

// DFSDM->CHCFG6R2 DFSDM channel configuration 6 register 2
enum {
	DFSDM_CHCFG6R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 6
	DFSDM_CHCFG6R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 6		
};
inline void dfsdm_chcfg6r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R2 = (p->CHCFG6R2 & ~DFSDM_CHCFG6R2_OFFSET) | ((val<<8) & DFSDM_CHCFG6R2_OFFSET); }
inline void dfsdm_chcfg6r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R2 = (p->CHCFG6R2 & ~DFSDM_CHCFG6R2_DTRBS) | ((val<<3) & DFSDM_CHCFG6R2_DTRBS); }
inline uint32_t dfsdm_chcfg6r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG6R2 & DFSDM_CHCFG6R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg6r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG6R2 & DFSDM_CHCFG6R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD6R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD6R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 6
	DFSDM_AWSCD6R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 6
	DFSDM_AWSCD6R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 6
	DFSDM_AWSCD6R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 6		
};
inline void dfsdm_awscd6r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_AWFORD) | ((val<<22) & DFSDM_AWSCD6R_AWFORD); }
inline void dfsdm_awscd6r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_AWFOSR) | ((val<<16) & DFSDM_AWSCD6R_AWFOSR); }
inline void dfsdm_awscd6r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_BKSCD) | ((val<<12) & DFSDM_AWSCD6R_BKSCD); }
inline void dfsdm_awscd6r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_SCDT) | ((val<<0) & DFSDM_AWSCD6R_SCDT); }
inline uint32_t dfsdm_awscd6r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd6r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd6r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd6r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_SCDT) >> 0 ; }

// DFSDM->CHDATIN6R DFSDM channel data input register
enum {
	DFSDM_CHDATIN6R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 7
	DFSDM_CHDATIN6R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 6		
};
inline void dfsdm_chdatin6r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN6R = (p->CHDATIN6R & ~DFSDM_CHDATIN6R_INDAT1) | ((val<<16) & DFSDM_CHDATIN6R_INDAT1); }
inline void dfsdm_chdatin6r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN6R = (p->CHDATIN6R & ~DFSDM_CHDATIN6R_INDAT0) | ((val<<0) & DFSDM_CHDATIN6R_INDAT0); }
inline uint32_t dfsdm_chdatin6r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN6R & DFSDM_CHDATIN6R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin6r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN6R & DFSDM_CHDATIN6R_INDAT0) >> 0 ; }

// DFSDM->CHCFG7R1 DFSDM channel configuration 7 register 1
enum {
	DFSDM_CHCFG7R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_CHCFG7R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_CHCFG7R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_CHCFG7R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_CHCFG7R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 7
	DFSDM_CHCFG7R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_CHCFG7R1_CHEN = 1UL<<7, // Channel 7 enable
	DFSDM_CHCFG7R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 7
	DFSDM_CHCFG7R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 7
	DFSDM_CHCFG7R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 7
	DFSDM_CHCFG7R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 7		
};
inline void dfsdm_chcfg7r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG7R1_CKOUTDIV); }
inline void dfsdm_chcfg7r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_DATPACK) | ((val<<14) & DFSDM_CHCFG7R1_DATPACK); }
inline void dfsdm_chcfg7r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_DATMPX) | ((val<<12) & DFSDM_CHCFG7R1_DATMPX); }
inline void dfsdm_chcfg7r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG7R1_SPICKSEL); }
inline void dfsdm_chcfg7r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_SITP) | ((val<<0) & DFSDM_CHCFG7R1_SITP); }
inline uint32_t dfsdm_chcfg7r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg7r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg7r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg7r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg7r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_SITP) >> 0 ; }

// DFSDM->CHCFG7R2 DFSDM channel configuration 7 register 2
enum {
	DFSDM_CHCFG7R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 7
	DFSDM_CHCFG7R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 7		
};
inline void dfsdm_chcfg7r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R2 = (p->CHCFG7R2 & ~DFSDM_CHCFG7R2_OFFSET) | ((val<<8) & DFSDM_CHCFG7R2_OFFSET); }
inline void dfsdm_chcfg7r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R2 = (p->CHCFG7R2 & ~DFSDM_CHCFG7R2_DTRBS) | ((val<<3) & DFSDM_CHCFG7R2_DTRBS); }
inline uint32_t dfsdm_chcfg7r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG7R2 & DFSDM_CHCFG7R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg7r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG7R2 & DFSDM_CHCFG7R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD7R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD7R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 7
	DFSDM_AWSCD7R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 7
	DFSDM_AWSCD7R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 7
	DFSDM_AWSCD7R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 7		
};
inline void dfsdm_awscd7r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_AWFORD) | ((val<<22) & DFSDM_AWSCD7R_AWFORD); }
inline void dfsdm_awscd7r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_AWFOSR) | ((val<<16) & DFSDM_AWSCD7R_AWFOSR); }
inline void dfsdm_awscd7r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_BKSCD) | ((val<<12) & DFSDM_AWSCD7R_BKSCD); }
inline void dfsdm_awscd7r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_SCDT) | ((val<<0) & DFSDM_AWSCD7R_SCDT); }
inline uint32_t dfsdm_awscd7r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd7r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd7r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd7r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_SCDT) >> 0 ; }

// DFSDM->CHDATIN7R DFSDM channel data input register
enum {
	DFSDM_CHDATIN7R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 8
	DFSDM_CHDATIN7R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 7		
};
inline void dfsdm_chdatin7r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN7R = (p->CHDATIN7R & ~DFSDM_CHDATIN7R_INDAT1) | ((val<<16) & DFSDM_CHDATIN7R_INDAT1); }
inline void dfsdm_chdatin7r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN7R = (p->CHDATIN7R & ~DFSDM_CHDATIN7R_INDAT0) | ((val<<0) & DFSDM_CHDATIN7R_INDAT0); }
inline uint32_t dfsdm_chdatin7r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN7R & DFSDM_CHDATIN7R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin7r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN7R & DFSDM_CHDATIN7R_INDAT0) >> 0 ; }

// DFSDM->DFSDM0_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM0_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM0_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM0_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM0_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM0_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM0_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM0_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM0_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM0_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM0_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM0_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM0_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM0_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM0_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm0_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_RCH) | ((val<<24) & DFSDM_DFSDM0_CR1_RCH); }
inline void dfsdm_dfsdm0_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM0_CR1_JEXTEN); }
inline void dfsdm_dfsdm0_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM0_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm0_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm0_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM0_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM0_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM0_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM0_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM0_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM0_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM0_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM0_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM0_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM0_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm0_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR2 = (p->DFSDM0_CR2 & ~DFSDM_DFSDM0_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM0_CR2_AWDCH); }
inline void dfsdm_dfsdm0_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR2 = (p->DFSDM0_CR2 & ~DFSDM_DFSDM0_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM0_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm0_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM0_CR2 & DFSDM_DFSDM0_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm0_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM0_CR2 & DFSDM_DFSDM0_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM0_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM0_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM0_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM0_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM0_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM0_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM0_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM0_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM0_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM0_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm0_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM0_ISR & DFSDM_DFSDM0_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM0_ISR & DFSDM_DFSDM0_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM0_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM0_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM0_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM0_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM0_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm0_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_ICR = (p->DFSDM0_ICR & ~DFSDM_DFSDM0_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM0_ICR_CLRSCDF); }
inline void dfsdm_dfsdm0_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_ICR = (p->DFSDM0_ICR & ~DFSDM_DFSDM0_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM0_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm0_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM0_ICR & DFSDM_DFSDM0_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM0_ICR & DFSDM_DFSDM0_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM0_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM0_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM0_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM0_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm0_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_FORD) | ((val<<29) & DFSDM_DFSDM0_FCR_FORD); }
inline void dfsdm_dfsdm0_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM0_FCR_FOSR); }
inline void dfsdm_dfsdm0_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM0_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm0_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm0_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm0_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM0_JDATAR DFSDM data register for injected group
enum {
	DFSDM_DFSDM0_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM0_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm0_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM0_JDATAR & DFSDM_DFSDM0_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM0_JDATAR & DFSDM_DFSDM0_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM0_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM0_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM0_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM0_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm0_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM0_RDATAR & DFSDM_DFSDM0_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM0_RDATAR & DFSDM_DFSDM0_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM0_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM0_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM0_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm0_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWHTR = (p->DFSDM0_AWHTR & ~DFSDM_DFSDM0_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM0_AWHTR_AWHT); }
inline void dfsdm_dfsdm0_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWHTR = (p->DFSDM0_AWHTR & ~DFSDM_DFSDM0_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM0_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm0_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM0_AWHTR & DFSDM_DFSDM0_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM0_AWHTR & DFSDM_DFSDM0_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM0_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM0_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM0_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm0_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWLTR = (p->DFSDM0_AWLTR & ~DFSDM_DFSDM0_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM0_AWLTR_AWLT); }
inline void dfsdm_dfsdm0_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWLTR = (p->DFSDM0_AWLTR & ~DFSDM_DFSDM0_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM0_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm0_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM0_AWLTR & DFSDM_DFSDM0_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM0_AWLTR & DFSDM_DFSDM0_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM0_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM0_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM0_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm0_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM0_AWSR & DFSDM_DFSDM0_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM0_AWSR & DFSDM_DFSDM0_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM0_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM0_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM0_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm0_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWCFR = (p->DFSDM0_AWCFR & ~DFSDM_DFSDM0_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM0_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm0_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWCFR = (p->DFSDM0_AWCFR & ~DFSDM_DFSDM0_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM0_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm0_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM0_AWCFR & DFSDM_DFSDM0_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM0_AWCFR & DFSDM_DFSDM0_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM0_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM0_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM0_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm0_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM0_EXMAX & DFSDM_DFSDM0_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM0_EXMAX & DFSDM_DFSDM0_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM0_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM0_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM0_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm0_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM0_EXMIN & DFSDM_DFSDM0_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM0_EXMIN & DFSDM_DFSDM0_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM0_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM0_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm0_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM0_CNVTIMR & DFSDM_DFSDM0_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM1_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM1_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM1_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM1_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM1_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM1_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM1_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM1_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM1_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM1_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM1_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM1_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM1_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM1_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM1_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm1_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_RCH) | ((val<<24) & DFSDM_DFSDM1_CR1_RCH); }
inline void dfsdm_dfsdm1_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM1_CR1_JEXTEN); }
inline void dfsdm_dfsdm1_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM1_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm1_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm1_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM1_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM1_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM1_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM1_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM1_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM1_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM1_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM1_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM1_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM1_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm1_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR2 = (p->DFSDM1_CR2 & ~DFSDM_DFSDM1_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM1_CR2_AWDCH); }
inline void dfsdm_dfsdm1_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR2 = (p->DFSDM1_CR2 & ~DFSDM_DFSDM1_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM1_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm1_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM1_CR2 & DFSDM_DFSDM1_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm1_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM1_CR2 & DFSDM_DFSDM1_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM1_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM1_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM1_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM1_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM1_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM1_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM1_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM1_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM1_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM1_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm1_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM1_ISR & DFSDM_DFSDM1_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM1_ISR & DFSDM_DFSDM1_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM1_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM1_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM1_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM1_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM1_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm1_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_ICR = (p->DFSDM1_ICR & ~DFSDM_DFSDM1_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM1_ICR_CLRSCDF); }
inline void dfsdm_dfsdm1_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_ICR = (p->DFSDM1_ICR & ~DFSDM_DFSDM1_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM1_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm1_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM1_ICR & DFSDM_DFSDM1_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM1_ICR & DFSDM_DFSDM1_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM1_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM1_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM1_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM1_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm1_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_FORD) | ((val<<29) & DFSDM_DFSDM1_FCR_FORD); }
inline void dfsdm_dfsdm1_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM1_FCR_FOSR); }
inline void dfsdm_dfsdm1_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM1_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm1_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm1_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm1_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM1_JDATAR DFSDM data register for injected group
enum {
	DFSDM_DFSDM1_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM1_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm1_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM1_JDATAR & DFSDM_DFSDM1_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM1_JDATAR & DFSDM_DFSDM1_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM1_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM1_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM1_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm1_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWHTR = (p->DFSDM1_AWHTR & ~DFSDM_DFSDM1_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM1_AWHTR_AWHT); }
inline void dfsdm_dfsdm1_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWHTR = (p->DFSDM1_AWHTR & ~DFSDM_DFSDM1_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM1_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm1_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM1_AWHTR & DFSDM_DFSDM1_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM1_AWHTR & DFSDM_DFSDM1_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM1_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM1_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM1_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm1_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWLTR = (p->DFSDM1_AWLTR & ~DFSDM_DFSDM1_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM1_AWLTR_AWLT); }
inline void dfsdm_dfsdm1_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWLTR = (p->DFSDM1_AWLTR & ~DFSDM_DFSDM1_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM1_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm1_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM1_AWLTR & DFSDM_DFSDM1_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM1_AWLTR & DFSDM_DFSDM1_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM1_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM1_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM1_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm1_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM1_AWSR & DFSDM_DFSDM1_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM1_AWSR & DFSDM_DFSDM1_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM1_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM1_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM1_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm1_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWCFR = (p->DFSDM1_AWCFR & ~DFSDM_DFSDM1_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM1_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm1_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWCFR = (p->DFSDM1_AWCFR & ~DFSDM_DFSDM1_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM1_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm1_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM1_AWCFR & DFSDM_DFSDM1_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM1_AWCFR & DFSDM_DFSDM1_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM1_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM1_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM1_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm1_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM1_EXMAX & DFSDM_DFSDM1_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM1_EXMAX & DFSDM_DFSDM1_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM1_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM1_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM1_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm1_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM1_EXMIN & DFSDM_DFSDM1_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM1_EXMIN & DFSDM_DFSDM1_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM1_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM1_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm1_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM1_CNVTIMR & DFSDM_DFSDM1_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM2_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM2_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM2_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM2_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM2_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM2_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM2_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM2_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM2_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM2_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM2_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM2_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM2_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM2_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM2_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm2_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_RCH) | ((val<<24) & DFSDM_DFSDM2_CR1_RCH); }
inline void dfsdm_dfsdm2_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM2_CR1_JEXTEN); }
inline void dfsdm_dfsdm2_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM2_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm2_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm2_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM2_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM2_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM2_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM2_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM2_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM2_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM2_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM2_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM2_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM2_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm2_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR2 = (p->DFSDM2_CR2 & ~DFSDM_DFSDM2_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM2_CR2_AWDCH); }
inline void dfsdm_dfsdm2_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR2 = (p->DFSDM2_CR2 & ~DFSDM_DFSDM2_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM2_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm2_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM2_CR2 & DFSDM_DFSDM2_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm2_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM2_CR2 & DFSDM_DFSDM2_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM2_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM2_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM2_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM2_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM2_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM2_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM2_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM2_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM2_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM2_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm2_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM2_ISR & DFSDM_DFSDM2_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM2_ISR & DFSDM_DFSDM2_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM2_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM2_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM2_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM2_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM2_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm2_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_ICR = (p->DFSDM2_ICR & ~DFSDM_DFSDM2_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM2_ICR_CLRSCDF); }
inline void dfsdm_dfsdm2_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_ICR = (p->DFSDM2_ICR & ~DFSDM_DFSDM2_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM2_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm2_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM2_ICR & DFSDM_DFSDM2_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM2_ICR & DFSDM_DFSDM2_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM2_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM2_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM2_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM2_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm2_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_FORD) | ((val<<29) & DFSDM_DFSDM2_FCR_FORD); }
inline void dfsdm_dfsdm2_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM2_FCR_FOSR); }
inline void dfsdm_dfsdm2_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM2_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm2_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm2_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm2_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM2_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM2_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM2_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM2_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm2_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM2_RDATAR & DFSDM_DFSDM2_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM2_RDATAR & DFSDM_DFSDM2_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM2_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM2_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM2_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm2_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWHTR = (p->DFSDM2_AWHTR & ~DFSDM_DFSDM2_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM2_AWHTR_AWHT); }
inline void dfsdm_dfsdm2_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWHTR = (p->DFSDM2_AWHTR & ~DFSDM_DFSDM2_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM2_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm2_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM2_AWHTR & DFSDM_DFSDM2_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM2_AWHTR & DFSDM_DFSDM2_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM2_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM2_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM2_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm2_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWLTR = (p->DFSDM2_AWLTR & ~DFSDM_DFSDM2_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM2_AWLTR_AWLT); }
inline void dfsdm_dfsdm2_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWLTR = (p->DFSDM2_AWLTR & ~DFSDM_DFSDM2_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM2_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm2_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM2_AWLTR & DFSDM_DFSDM2_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM2_AWLTR & DFSDM_DFSDM2_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM2_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM2_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM2_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm2_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM2_AWSR & DFSDM_DFSDM2_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM2_AWSR & DFSDM_DFSDM2_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM2_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM2_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM2_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm2_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWCFR = (p->DFSDM2_AWCFR & ~DFSDM_DFSDM2_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM2_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm2_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWCFR = (p->DFSDM2_AWCFR & ~DFSDM_DFSDM2_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM2_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm2_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM2_AWCFR & DFSDM_DFSDM2_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM2_AWCFR & DFSDM_DFSDM2_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM2_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM2_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM2_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm2_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM2_EXMAX & DFSDM_DFSDM2_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM2_EXMAX & DFSDM_DFSDM2_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM2_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM2_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM2_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm2_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM2_EXMIN & DFSDM_DFSDM2_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM2_EXMIN & DFSDM_DFSDM2_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM2_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM2_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm2_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM2_CNVTIMR & DFSDM_DFSDM2_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM3_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM3_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM3_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm3_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWHTR = (p->DFSDM3_AWHTR & ~DFSDM_DFSDM3_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM3_AWHTR_AWHT); }
inline void dfsdm_dfsdm3_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWHTR = (p->DFSDM3_AWHTR & ~DFSDM_DFSDM3_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM3_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm3_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM3_AWHTR & DFSDM_DFSDM3_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM3_AWHTR & DFSDM_DFSDM3_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM3_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM3_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM3_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm3_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWLTR = (p->DFSDM3_AWLTR & ~DFSDM_DFSDM3_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM3_AWLTR_AWLT); }
inline void dfsdm_dfsdm3_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWLTR = (p->DFSDM3_AWLTR & ~DFSDM_DFSDM3_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM3_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm3_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM3_AWLTR & DFSDM_DFSDM3_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM3_AWLTR & DFSDM_DFSDM3_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM3_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM3_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM3_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm3_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM3_AWSR & DFSDM_DFSDM3_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM3_AWSR & DFSDM_DFSDM3_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM3_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM3_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM3_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm3_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWCFR = (p->DFSDM3_AWCFR & ~DFSDM_DFSDM3_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM3_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm3_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWCFR = (p->DFSDM3_AWCFR & ~DFSDM_DFSDM3_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM3_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm3_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM3_AWCFR & DFSDM_DFSDM3_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM3_AWCFR & DFSDM_DFSDM3_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM3_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM3_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM3_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm3_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM3_EXMAX & DFSDM_DFSDM3_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM3_EXMAX & DFSDM_DFSDM3_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM3_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM3_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM3_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm3_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM3_EXMIN & DFSDM_DFSDM3_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM3_EXMIN & DFSDM_DFSDM3_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM3_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM3_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm3_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM3_CNVTIMR & DFSDM_DFSDM3_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM3_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM3_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM3_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM3_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm3_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_FORD) | ((val<<29) & DFSDM_DFSDM3_FCR_FORD); }
inline void dfsdm_dfsdm3_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM3_FCR_FOSR); }
inline void dfsdm_dfsdm3_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM3_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm3_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm3_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm3_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM3_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM3_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM3_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM3_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm3_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM3_RDATAR & DFSDM_DFSDM3_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM3_RDATAR & DFSDM_DFSDM3_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM3_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM3_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM3_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM3_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM3_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM3_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM3_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM3_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM3_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM3_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM3_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM3_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM3_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM3_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM3_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm3_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_RCH) | ((val<<24) & DFSDM_DFSDM3_CR1_RCH); }
inline void dfsdm_dfsdm3_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM3_CR1_JEXTEN); }
inline void dfsdm_dfsdm3_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM3_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm3_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm3_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM3_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM3_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM3_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM3_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM3_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM3_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM3_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM3_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM3_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM3_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm3_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR2 = (p->DFSDM3_CR2 & ~DFSDM_DFSDM3_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM3_CR2_AWDCH); }
inline void dfsdm_dfsdm3_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR2 = (p->DFSDM3_CR2 & ~DFSDM_DFSDM3_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM3_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm3_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM3_CR2 & DFSDM_DFSDM3_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm3_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM3_CR2 & DFSDM_DFSDM3_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM3_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM3_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM3_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM3_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM3_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM3_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM3_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM3_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM3_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM3_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm3_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM3_ISR & DFSDM_DFSDM3_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM3_ISR & DFSDM_DFSDM3_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM3_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM3_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM3_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM3_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM3_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm3_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_ICR = (p->DFSDM3_ICR & ~DFSDM_DFSDM3_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM3_ICR_CLRSCDF); }
inline void dfsdm_dfsdm3_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_ICR = (p->DFSDM3_ICR & ~DFSDM_DFSDM3_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM3_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm3_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM3_ICR & DFSDM_DFSDM3_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM3_ICR & DFSDM_DFSDM3_ICR_CLRCKABF) >> 16 ; }


/* DMA controller */
struct DMA2_Type {
	__I uint32_t LISR; // @0 low interrupt status register
	__I uint32_t HISR; // @4 high interrupt status register
	__IO uint32_t LIFCR; // @8 low interrupt flag clear register
	__IO uint32_t HIFCR; // @12 high interrupt flag clear register
	__IO uint32_t S0CR; // @16 stream x configuration register
	__IO uint16_t S0NDTR; // @20 stream x number of data register
	 uint8_t RESERVED0[2]; // @22 
	__IO uint32_t S0PAR; // @24 stream x peripheral address register
	__IO uint32_t S0M0AR; // @28 stream x memory 0 address register
	__IO uint32_t S0M1AR; // @32 stream x memory 1 address register
	__IO uint8_t S0FCR; // @36 stream x FIFO control register
	 uint8_t RESERVED1[3]; // @37 
	__IO uint32_t S1CR; // @40 stream x configuration register
	__IO uint16_t S1NDTR; // @44 stream x number of data register
	 uint8_t RESERVED2[2]; // @46 
	__IO uint32_t S1PAR; // @48 stream x peripheral address register
	__IO uint32_t S1M0AR; // @52 stream x memory 0 address register
	__IO uint32_t S1M1AR; // @56 stream x memory 1 address register
	__IO uint8_t S1FCR; // @60 stream x FIFO control register
	 uint8_t RESERVED3[3]; // @61 
	__IO uint32_t S2CR; // @64 stream x configuration register
	__IO uint16_t S2NDTR; // @68 stream x number of data register
	 uint8_t RESERVED4[2]; // @70 
	__IO uint32_t S2PAR; // @72 stream x peripheral address register
	__IO uint32_t S2M0AR; // @76 stream x memory 0 address register
	__IO uint32_t S2M1AR; // @80 stream x memory 1 address register
	__IO uint8_t S2FCR; // @84 stream x FIFO control register
	 uint8_t RESERVED5[3]; // @85 
	__IO uint32_t S3CR; // @88 stream x configuration register
	__IO uint16_t S3NDTR; // @92 stream x number of data register
	 uint8_t RESERVED6[2]; // @94 
	__IO uint32_t S3PAR; // @96 stream x peripheral address register
	__IO uint32_t S3M0AR; // @100 stream x memory 0 address register
	__IO uint32_t S3M1AR; // @104 stream x memory 1 address register
	__IO uint8_t S3FCR; // @108 stream x FIFO control register
	 uint8_t RESERVED7[3]; // @109 
	__IO uint32_t S4CR; // @112 stream x configuration register
	__IO uint16_t S4NDTR; // @116 stream x number of data register
	 uint8_t RESERVED8[2]; // @118 
	__IO uint32_t S4PAR; // @120 stream x peripheral address register
	__IO uint32_t S4M0AR; // @124 stream x memory 0 address register
	__IO uint32_t S4M1AR; // @128 stream x memory 1 address register
	__IO uint8_t S4FCR; // @132 stream x FIFO control register
	 uint8_t RESERVED9[3]; // @133 
	__IO uint32_t S5CR; // @136 stream x configuration register
	__IO uint16_t S5NDTR; // @140 stream x number of data register
	 uint8_t RESERVED10[2]; // @142 
	__IO uint32_t S5PAR; // @144 stream x peripheral address register
	__IO uint32_t S5M0AR; // @148 stream x memory 0 address register
	__IO uint32_t S5M1AR; // @152 stream x memory 1 address register
	__IO uint8_t S5FCR; // @156 stream x FIFO control register
	 uint8_t RESERVED11[3]; // @157 
	__IO uint32_t S6CR; // @160 stream x configuration register
	__IO uint16_t S6NDTR; // @164 stream x number of data register
	 uint8_t RESERVED12[2]; // @166 
	__IO uint32_t S6PAR; // @168 stream x peripheral address register
	__IO uint32_t S6M0AR; // @172 stream x memory 0 address register
	__IO uint32_t S6M1AR; // @176 stream x memory 1 address register
	__IO uint8_t S6FCR; // @180 stream x FIFO control register
	 uint8_t RESERVED13[3]; // @181 
	__IO uint32_t S7CR; // @184 stream x configuration register
	__IO uint16_t S7NDTR; // @188 stream x number of data register
	 uint8_t RESERVED14[2]; // @190 
	__IO uint32_t S7PAR; // @192 stream x peripheral address register
	__IO uint32_t S7M0AR; // @196 stream x memory 0 address register
	__IO uint32_t S7M1AR; // @200 stream x memory 1 address register
	__IO uint8_t S7FCR; // @204 stream x FIFO control register
};

// DMA2->LISR low interrupt status register
enum {
	DMA2_LISR_TCIF3 = 1UL<<27, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF3 = 1UL<<26, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF3 = 1UL<<25, // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF3 = 1UL<<24, // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF3 = 1UL<<22, // Stream x FIFO error interrupt flag (x=3..0)
	DMA2_LISR_TCIF2 = 1UL<<21, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF2 = 1UL<<20, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF2 = 1UL<<19, // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF2 = 1UL<<18, // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF2 = 1UL<<16, // Stream x FIFO error interrupt flag (x=3..0)
	DMA2_LISR_TCIF1 = 1UL<<11, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF1 = 1UL<<10, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF1 = 1UL<<9, // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF1 = 1UL<<8, // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF1 = 1UL<<6, // Stream x FIFO error interrupt flag (x=3..0)
	DMA2_LISR_TCIF0 = 1UL<<5, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA2_LISR_HTIF0 = 1UL<<4, // Stream x half transfer interrupt flag (x=3..0)
	DMA2_LISR_TEIF0 = 1UL<<3, // Stream x transfer error interrupt flag (x=3..0)
	DMA2_LISR_DMEIF0 = 1UL<<2, // Stream x direct mode error interrupt flag (x=3..0)
	DMA2_LISR_FEIF0 = 1UL<<0, // Stream x FIFO error interrupt flag (x=3..0)		
};

// DMA2->HISR high interrupt status register
enum {
	DMA2_HISR_TCIF7 = 1UL<<27, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF7 = 1UL<<26, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF7 = 1UL<<25, // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF7 = 1UL<<24, // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF7 = 1UL<<22, // Stream x FIFO error interrupt flag (x=7..4)
	DMA2_HISR_TCIF6 = 1UL<<21, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF6 = 1UL<<20, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF6 = 1UL<<19, // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF6 = 1UL<<18, // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF6 = 1UL<<16, // Stream x FIFO error interrupt flag (x=7..4)
	DMA2_HISR_TCIF5 = 1UL<<11, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF5 = 1UL<<10, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF5 = 1UL<<9, // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF5 = 1UL<<8, // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF5 = 1UL<<6, // Stream x FIFO error interrupt flag (x=7..4)
	DMA2_HISR_TCIF4 = 1UL<<5, // Stream x transfer complete interrupt flag (x=7..4)
	DMA2_HISR_HTIF4 = 1UL<<4, // Stream x half transfer interrupt flag (x=7..4)
	DMA2_HISR_TEIF4 = 1UL<<3, // Stream x transfer error interrupt flag (x=7..4)
	DMA2_HISR_DMEIF4 = 1UL<<2, // Stream x direct mode error interrupt flag (x=7..4)
	DMA2_HISR_FEIF4 = 1UL<<0, // Stream x FIFO error interrupt flag (x=7..4)		
};

// DMA2->LIFCR low interrupt flag clear register
enum {
	DMA2_LIFCR_CTCIF3 = 1UL<<27, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF3 = 1UL<<26, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF3 = 1UL<<25, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF3 = 1UL<<24, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF3 = 1UL<<22, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA2_LIFCR_CTCIF2 = 1UL<<21, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF2 = 1UL<<20, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF2 = 1UL<<19, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF2 = 1UL<<18, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF2 = 1UL<<16, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA2_LIFCR_CTCIF1 = 1UL<<11, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF1 = 1UL<<10, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF1 = 1UL<<9, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF1 = 1UL<<8, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF1 = 1UL<<6, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA2_LIFCR_CTCIF0 = 1UL<<5, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA2_LIFCR_CHTIF0 = 1UL<<4, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA2_LIFCR_CTEIF0 = 1UL<<3, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA2_LIFCR_CDMEIF0 = 1UL<<2, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA2_LIFCR_CFEIF0 = 1UL<<0, // Stream x clear FIFO error interrupt flag (x = 3..0)		
};

// DMA2->HIFCR high interrupt flag clear register
enum {
	DMA2_HIFCR_CTCIF7 = 1UL<<27, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF7 = 1UL<<26, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF7 = 1UL<<25, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF7 = 1UL<<24, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF7 = 1UL<<22, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA2_HIFCR_CTCIF6 = 1UL<<21, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF6 = 1UL<<20, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF6 = 1UL<<19, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF6 = 1UL<<18, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF6 = 1UL<<16, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA2_HIFCR_CTCIF5 = 1UL<<11, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF5 = 1UL<<10, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF5 = 1UL<<9, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF5 = 1UL<<8, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF5 = 1UL<<6, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA2_HIFCR_CTCIF4 = 1UL<<5, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA2_HIFCR_CHTIF4 = 1UL<<4, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA2_HIFCR_CTEIF4 = 1UL<<3, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA2_HIFCR_CDMEIF4 = 1UL<<2, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA2_HIFCR_CFEIF4 = 1UL<<0, // Stream x clear FIFO error interrupt flag (x = 7..4)		
};

// DMA2->S0CR stream x configuration register
enum {
	DMA2_S0CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S0CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S0CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S0CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S0CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S0CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S0CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S0CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S0CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S0CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S0CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S0CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S0CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S0CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S0CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S0CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S0CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S0CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S0CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s0cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_CHSEL) | ((val<<25) & DMA2_S0CR_CHSEL); }
inline void dma2_s0cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_MBURST) | ((val<<23) & DMA2_S0CR_MBURST); }
inline void dma2_s0cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_PBURST) | ((val<<21) & DMA2_S0CR_PBURST); }
inline void dma2_s0cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_PL) | ((val<<16) & DMA2_S0CR_PL); }
inline void dma2_s0cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_MSIZE) | ((val<<13) & DMA2_S0CR_MSIZE); }
inline void dma2_s0cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_PSIZE) | ((val<<11) & DMA2_S0CR_PSIZE); }
inline void dma2_s0cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA2_S0CR_DIR) | ((val<<6) & DMA2_S0CR_DIR); }
inline uint32_t dma2_s0cr_get_chsel(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s0cr_get_mburst(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_MBURST) >> 23 ; }
inline uint32_t dma2_s0cr_get_pburst(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_PBURST) >> 21 ; }
inline uint32_t dma2_s0cr_get_pl(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_PL) >> 16 ; }
inline uint32_t dma2_s0cr_get_msize(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s0cr_get_psize(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s0cr_get_dir(struct DMA2_Type* p) { return (p->S0CR & DMA2_S0CR_DIR) >> 6 ; }

// DMA2->S0FCR stream x FIFO control register
enum {
	DMA2_S0FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S0FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S0FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S0FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s0fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S0FCR = (p->S0FCR & ~DMA2_S0FCR_FS) | ((val<<3) & DMA2_S0FCR_FS); }
inline void dma2_s0fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S0FCR = (p->S0FCR & ~DMA2_S0FCR_FTH) | ((val<<0) & DMA2_S0FCR_FTH); }
inline uint32_t dma2_s0fcr_get_fs(struct DMA2_Type* p) { return (p->S0FCR & DMA2_S0FCR_FS) >> 3 ; }
inline uint32_t dma2_s0fcr_get_fth(struct DMA2_Type* p) { return (p->S0FCR & DMA2_S0FCR_FTH) >> 0 ; }

// DMA2->S1CR stream x configuration register
enum {
	DMA2_S1CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S1CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S1CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S1CR_ACK = 1UL<<20, // ACK
	DMA2_S1CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S1CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S1CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S1CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S1CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S1CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S1CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S1CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S1CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S1CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S1CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S1CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S1CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S1CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S1CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S1CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s1cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_CHSEL) | ((val<<25) & DMA2_S1CR_CHSEL); }
inline void dma2_s1cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_MBURST) | ((val<<23) & DMA2_S1CR_MBURST); }
inline void dma2_s1cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_PBURST) | ((val<<21) & DMA2_S1CR_PBURST); }
inline void dma2_s1cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_PL) | ((val<<16) & DMA2_S1CR_PL); }
inline void dma2_s1cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_MSIZE) | ((val<<13) & DMA2_S1CR_MSIZE); }
inline void dma2_s1cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_PSIZE) | ((val<<11) & DMA2_S1CR_PSIZE); }
inline void dma2_s1cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA2_S1CR_DIR) | ((val<<6) & DMA2_S1CR_DIR); }
inline uint32_t dma2_s1cr_get_chsel(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s1cr_get_mburst(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_MBURST) >> 23 ; }
inline uint32_t dma2_s1cr_get_pburst(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_PBURST) >> 21 ; }
inline uint32_t dma2_s1cr_get_pl(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_PL) >> 16 ; }
inline uint32_t dma2_s1cr_get_msize(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s1cr_get_psize(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s1cr_get_dir(struct DMA2_Type* p) { return (p->S1CR & DMA2_S1CR_DIR) >> 6 ; }

// DMA2->S1FCR stream x FIFO control register
enum {
	DMA2_S1FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S1FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S1FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S1FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s1fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S1FCR = (p->S1FCR & ~DMA2_S1FCR_FS) | ((val<<3) & DMA2_S1FCR_FS); }
inline void dma2_s1fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S1FCR = (p->S1FCR & ~DMA2_S1FCR_FTH) | ((val<<0) & DMA2_S1FCR_FTH); }
inline uint32_t dma2_s1fcr_get_fs(struct DMA2_Type* p) { return (p->S1FCR & DMA2_S1FCR_FS) >> 3 ; }
inline uint32_t dma2_s1fcr_get_fth(struct DMA2_Type* p) { return (p->S1FCR & DMA2_S1FCR_FTH) >> 0 ; }

// DMA2->S2CR stream x configuration register
enum {
	DMA2_S2CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S2CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S2CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S2CR_ACK = 1UL<<20, // ACK
	DMA2_S2CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S2CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S2CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S2CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S2CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S2CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S2CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S2CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S2CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S2CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S2CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S2CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S2CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S2CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S2CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S2CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s2cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_CHSEL) | ((val<<25) & DMA2_S2CR_CHSEL); }
inline void dma2_s2cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_MBURST) | ((val<<23) & DMA2_S2CR_MBURST); }
inline void dma2_s2cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_PBURST) | ((val<<21) & DMA2_S2CR_PBURST); }
inline void dma2_s2cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_PL) | ((val<<16) & DMA2_S2CR_PL); }
inline void dma2_s2cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_MSIZE) | ((val<<13) & DMA2_S2CR_MSIZE); }
inline void dma2_s2cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_PSIZE) | ((val<<11) & DMA2_S2CR_PSIZE); }
inline void dma2_s2cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA2_S2CR_DIR) | ((val<<6) & DMA2_S2CR_DIR); }
inline uint32_t dma2_s2cr_get_chsel(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s2cr_get_mburst(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_MBURST) >> 23 ; }
inline uint32_t dma2_s2cr_get_pburst(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_PBURST) >> 21 ; }
inline uint32_t dma2_s2cr_get_pl(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_PL) >> 16 ; }
inline uint32_t dma2_s2cr_get_msize(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s2cr_get_psize(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s2cr_get_dir(struct DMA2_Type* p) { return (p->S2CR & DMA2_S2CR_DIR) >> 6 ; }

// DMA2->S2FCR stream x FIFO control register
enum {
	DMA2_S2FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S2FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S2FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S2FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s2fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S2FCR = (p->S2FCR & ~DMA2_S2FCR_FS) | ((val<<3) & DMA2_S2FCR_FS); }
inline void dma2_s2fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S2FCR = (p->S2FCR & ~DMA2_S2FCR_FTH) | ((val<<0) & DMA2_S2FCR_FTH); }
inline uint32_t dma2_s2fcr_get_fs(struct DMA2_Type* p) { return (p->S2FCR & DMA2_S2FCR_FS) >> 3 ; }
inline uint32_t dma2_s2fcr_get_fth(struct DMA2_Type* p) { return (p->S2FCR & DMA2_S2FCR_FTH) >> 0 ; }

// DMA2->S3CR stream x configuration register
enum {
	DMA2_S3CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S3CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S3CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S3CR_ACK = 1UL<<20, // ACK
	DMA2_S3CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S3CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S3CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S3CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S3CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S3CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S3CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S3CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S3CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S3CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S3CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S3CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S3CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S3CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S3CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S3CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s3cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_CHSEL) | ((val<<25) & DMA2_S3CR_CHSEL); }
inline void dma2_s3cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_MBURST) | ((val<<23) & DMA2_S3CR_MBURST); }
inline void dma2_s3cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_PBURST) | ((val<<21) & DMA2_S3CR_PBURST); }
inline void dma2_s3cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_PL) | ((val<<16) & DMA2_S3CR_PL); }
inline void dma2_s3cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_MSIZE) | ((val<<13) & DMA2_S3CR_MSIZE); }
inline void dma2_s3cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_PSIZE) | ((val<<11) & DMA2_S3CR_PSIZE); }
inline void dma2_s3cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA2_S3CR_DIR) | ((val<<6) & DMA2_S3CR_DIR); }
inline uint32_t dma2_s3cr_get_chsel(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s3cr_get_mburst(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_MBURST) >> 23 ; }
inline uint32_t dma2_s3cr_get_pburst(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_PBURST) >> 21 ; }
inline uint32_t dma2_s3cr_get_pl(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_PL) >> 16 ; }
inline uint32_t dma2_s3cr_get_msize(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s3cr_get_psize(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s3cr_get_dir(struct DMA2_Type* p) { return (p->S3CR & DMA2_S3CR_DIR) >> 6 ; }

// DMA2->S3FCR stream x FIFO control register
enum {
	DMA2_S3FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S3FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S3FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S3FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s3fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S3FCR = (p->S3FCR & ~DMA2_S3FCR_FS) | ((val<<3) & DMA2_S3FCR_FS); }
inline void dma2_s3fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S3FCR = (p->S3FCR & ~DMA2_S3FCR_FTH) | ((val<<0) & DMA2_S3FCR_FTH); }
inline uint32_t dma2_s3fcr_get_fs(struct DMA2_Type* p) { return (p->S3FCR & DMA2_S3FCR_FS) >> 3 ; }
inline uint32_t dma2_s3fcr_get_fth(struct DMA2_Type* p) { return (p->S3FCR & DMA2_S3FCR_FTH) >> 0 ; }

// DMA2->S4CR stream x configuration register
enum {
	DMA2_S4CR_CHSEL = ((1UL<<3)-1) << 25, // Channel selection
	DMA2_S4CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S4CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S4CR_ACK = 1UL<<20, // ACK
	DMA2_S4CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S4CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S4CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S4CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S4CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S4CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S4CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S4CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S4CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S4CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S4CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S4CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S4CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S4CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S4CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S4CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s4cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_CHSEL) | ((val<<25) & DMA2_S4CR_CHSEL); }
inline void dma2_s4cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_MBURST) | ((val<<23) & DMA2_S4CR_MBURST); }
inline void dma2_s4cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_PBURST) | ((val<<21) & DMA2_S4CR_PBURST); }
inline void dma2_s4cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_PL) | ((val<<16) & DMA2_S4CR_PL); }
inline void dma2_s4cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_MSIZE) | ((val<<13) & DMA2_S4CR_MSIZE); }
inline void dma2_s4cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_PSIZE) | ((val<<11) & DMA2_S4CR_PSIZE); }
inline void dma2_s4cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA2_S4CR_DIR) | ((val<<6) & DMA2_S4CR_DIR); }
inline uint32_t dma2_s4cr_get_chsel(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s4cr_get_mburst(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_MBURST) >> 23 ; }
inline uint32_t dma2_s4cr_get_pburst(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_PBURST) >> 21 ; }
inline uint32_t dma2_s4cr_get_pl(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_PL) >> 16 ; }
inline uint32_t dma2_s4cr_get_msize(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s4cr_get_psize(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s4cr_get_dir(struct DMA2_Type* p) { return (p->S4CR & DMA2_S4CR_DIR) >> 6 ; }

// DMA2->S4FCR stream x FIFO control register
enum {
	DMA2_S4FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S4FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S4FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S4FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s4fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S4FCR = (p->S4FCR & ~DMA2_S4FCR_FS) | ((val<<3) & DMA2_S4FCR_FS); }
inline void dma2_s4fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S4FCR = (p->S4FCR & ~DMA2_S4FCR_FTH) | ((val<<0) & DMA2_S4FCR_FTH); }
inline uint32_t dma2_s4fcr_get_fs(struct DMA2_Type* p) { return (p->S4FCR & DMA2_S4FCR_FS) >> 3 ; }
inline uint32_t dma2_s4fcr_get_fth(struct DMA2_Type* p) { return (p->S4FCR & DMA2_S4FCR_FTH) >> 0 ; }

// DMA2->S5CR stream x configuration register
enum {
	DMA2_S5CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S5CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S5CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S5CR_ACK = 1UL<<20, // ACK
	DMA2_S5CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S5CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S5CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S5CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S5CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S5CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S5CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S5CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S5CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S5CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S5CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S5CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S5CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S5CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S5CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S5CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s5cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_CHSEL) | ((val<<25) & DMA2_S5CR_CHSEL); }
inline void dma2_s5cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_MBURST) | ((val<<23) & DMA2_S5CR_MBURST); }
inline void dma2_s5cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_PBURST) | ((val<<21) & DMA2_S5CR_PBURST); }
inline void dma2_s5cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_PL) | ((val<<16) & DMA2_S5CR_PL); }
inline void dma2_s5cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_MSIZE) | ((val<<13) & DMA2_S5CR_MSIZE); }
inline void dma2_s5cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_PSIZE) | ((val<<11) & DMA2_S5CR_PSIZE); }
inline void dma2_s5cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA2_S5CR_DIR) | ((val<<6) & DMA2_S5CR_DIR); }
inline uint32_t dma2_s5cr_get_chsel(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s5cr_get_mburst(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_MBURST) >> 23 ; }
inline uint32_t dma2_s5cr_get_pburst(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_PBURST) >> 21 ; }
inline uint32_t dma2_s5cr_get_pl(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_PL) >> 16 ; }
inline uint32_t dma2_s5cr_get_msize(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s5cr_get_psize(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s5cr_get_dir(struct DMA2_Type* p) { return (p->S5CR & DMA2_S5CR_DIR) >> 6 ; }

// DMA2->S5FCR stream x FIFO control register
enum {
	DMA2_S5FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S5FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S5FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S5FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s5fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S5FCR = (p->S5FCR & ~DMA2_S5FCR_FS) | ((val<<3) & DMA2_S5FCR_FS); }
inline void dma2_s5fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S5FCR = (p->S5FCR & ~DMA2_S5FCR_FTH) | ((val<<0) & DMA2_S5FCR_FTH); }
inline uint32_t dma2_s5fcr_get_fs(struct DMA2_Type* p) { return (p->S5FCR & DMA2_S5FCR_FS) >> 3 ; }
inline uint32_t dma2_s5fcr_get_fth(struct DMA2_Type* p) { return (p->S5FCR & DMA2_S5FCR_FTH) >> 0 ; }

// DMA2->S6CR stream x configuration register
enum {
	DMA2_S6CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S6CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S6CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S6CR_ACK = 1UL<<20, // ACK
	DMA2_S6CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S6CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S6CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S6CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S6CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S6CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S6CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S6CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S6CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S6CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S6CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S6CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S6CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S6CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S6CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S6CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s6cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_CHSEL) | ((val<<25) & DMA2_S6CR_CHSEL); }
inline void dma2_s6cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_MBURST) | ((val<<23) & DMA2_S6CR_MBURST); }
inline void dma2_s6cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_PBURST) | ((val<<21) & DMA2_S6CR_PBURST); }
inline void dma2_s6cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_PL) | ((val<<16) & DMA2_S6CR_PL); }
inline void dma2_s6cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_MSIZE) | ((val<<13) & DMA2_S6CR_MSIZE); }
inline void dma2_s6cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_PSIZE) | ((val<<11) & DMA2_S6CR_PSIZE); }
inline void dma2_s6cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA2_S6CR_DIR) | ((val<<6) & DMA2_S6CR_DIR); }
inline uint32_t dma2_s6cr_get_chsel(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s6cr_get_mburst(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_MBURST) >> 23 ; }
inline uint32_t dma2_s6cr_get_pburst(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_PBURST) >> 21 ; }
inline uint32_t dma2_s6cr_get_pl(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_PL) >> 16 ; }
inline uint32_t dma2_s6cr_get_msize(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s6cr_get_psize(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s6cr_get_dir(struct DMA2_Type* p) { return (p->S6CR & DMA2_S6CR_DIR) >> 6 ; }

// DMA2->S6FCR stream x FIFO control register
enum {
	DMA2_S6FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S6FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S6FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S6FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s6fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S6FCR = (p->S6FCR & ~DMA2_S6FCR_FS) | ((val<<3) & DMA2_S6FCR_FS); }
inline void dma2_s6fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S6FCR = (p->S6FCR & ~DMA2_S6FCR_FTH) | ((val<<0) & DMA2_S6FCR_FTH); }
inline uint32_t dma2_s6fcr_get_fs(struct DMA2_Type* p) { return (p->S6FCR & DMA2_S6FCR_FS) >> 3 ; }
inline uint32_t dma2_s6fcr_get_fth(struct DMA2_Type* p) { return (p->S6FCR & DMA2_S6FCR_FTH) >> 0 ; }

// DMA2->S7CR stream x configuration register
enum {
	DMA2_S7CR_CHSEL = ((1UL<<4)-1) << 25, // Channel selection
	DMA2_S7CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA2_S7CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA2_S7CR_ACK = 1UL<<20, // ACK
	DMA2_S7CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA2_S7CR_DBM = 1UL<<18, // Double buffer mode
	DMA2_S7CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA2_S7CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA2_S7CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA2_S7CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA2_S7CR_MINC = 1UL<<10, // Memory increment mode
	DMA2_S7CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA2_S7CR_CIRC = 1UL<<8, // Circular mode
	DMA2_S7CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA2_S7CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA2_S7CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA2_S7CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA2_S7CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA2_S7CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA2_S7CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma2_s7cr_set_chsel(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_CHSEL) | ((val<<25) & DMA2_S7CR_CHSEL); }
inline void dma2_s7cr_set_mburst(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_MBURST) | ((val<<23) & DMA2_S7CR_MBURST); }
inline void dma2_s7cr_set_pburst(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_PBURST) | ((val<<21) & DMA2_S7CR_PBURST); }
inline void dma2_s7cr_set_pl(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_PL) | ((val<<16) & DMA2_S7CR_PL); }
inline void dma2_s7cr_set_msize(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_MSIZE) | ((val<<13) & DMA2_S7CR_MSIZE); }
inline void dma2_s7cr_set_psize(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_PSIZE) | ((val<<11) & DMA2_S7CR_PSIZE); }
inline void dma2_s7cr_set_dir(struct DMA2_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA2_S7CR_DIR) | ((val<<6) & DMA2_S7CR_DIR); }
inline uint32_t dma2_s7cr_get_chsel(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_CHSEL) >> 25 ; }
inline uint32_t dma2_s7cr_get_mburst(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_MBURST) >> 23 ; }
inline uint32_t dma2_s7cr_get_pburst(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_PBURST) >> 21 ; }
inline uint32_t dma2_s7cr_get_pl(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_PL) >> 16 ; }
inline uint32_t dma2_s7cr_get_msize(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_MSIZE) >> 13 ; }
inline uint32_t dma2_s7cr_get_psize(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_PSIZE) >> 11 ; }
inline uint32_t dma2_s7cr_get_dir(struct DMA2_Type* p) { return (p->S7CR & DMA2_S7CR_DIR) >> 6 ; }

// DMA2->S7FCR stream x FIFO control register
enum {
	DMA2_S7FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA2_S7FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA2_S7FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA2_S7FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma2_s7fcr_set_fs(struct DMA2_Type* p, uint32_t val) { p->S7FCR = (p->S7FCR & ~DMA2_S7FCR_FS) | ((val<<3) & DMA2_S7FCR_FS); }
inline void dma2_s7fcr_set_fth(struct DMA2_Type* p, uint32_t val) { p->S7FCR = (p->S7FCR & ~DMA2_S7FCR_FTH) | ((val<<0) & DMA2_S7FCR_FTH); }
inline uint32_t dma2_s7fcr_get_fs(struct DMA2_Type* p) { return (p->S7FCR & DMA2_S7FCR_FS) >> 3 ; }
inline uint32_t dma2_s7fcr_get_fth(struct DMA2_Type* p) { return (p->S7FCR & DMA2_S7FCR_FTH) >> 0 ; }

/* DMA2D controller */
struct DMA2D_Type {
	__IO uint32_t CR; // @0 control register
	__I uint8_t ISR; // @4 Interrupt Status Register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t IFCR; // @8 interrupt flag clear register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t FGMAR; // @12 foreground memory address register
	__IO uint16_t FGOR; // @16 foreground offset register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint32_t BGMAR; // @20 background memory address register
	__IO uint16_t BGOR; // @24 background offset register
	 uint8_t RESERVED3[2]; // @26 
	__IO uint32_t FGPFCCR; // @28 foreground PFC control register
	__IO uint32_t FGCOLR; // @32 foreground color register
	__IO uint32_t BGPFCCR; // @36 background PFC control register
	__IO uint32_t BGCOLR; // @40 background color register
	__IO uint32_t FGCMAR; // @44 foreground CLUT memory address register
	__IO uint32_t BGCMAR; // @48 background CLUT memory address register
	__IO uint8_t OPFCCR; // @52 output PFC control register
	 uint8_t RESERVED4[3]; // @53 
	__IO uint32_t OCOLR; // @56 output color register
	__IO uint32_t OMAR; // @60 output memory address register
	__IO uint16_t OOR; // @64 output offset register
	 uint8_t RESERVED5[2]; // @66 
	__IO uint32_t NLR; // @68 number of line register
	__IO uint16_t LWR; // @72 line watermark register
	 uint8_t RESERVED6[2]; // @74 
	__IO uint16_t AMTCR; // @76 AHB master timer configuration register
	 uint8_t RESERVED7[946]; // @78 
	__IO uint32_t FGCLUT; // @1024 FGCLUT
	 uint8_t RESERVED8[1020]; // @1028 
	__IO uint32_t BGCLUT; // @2048 BGCLUT
};

// DMA2D->CR control register
enum {
	DMA2D_CR_MODE = ((1UL<<2)-1) << 16, // DMA2D mode
	DMA2D_CR_CEIE = 1UL<<13, // Configuration Error Interrupt Enable
	DMA2D_CR_CTCIE = 1UL<<12, // CLUT transfer complete interrupt enable
	DMA2D_CR_CAEIE = 1UL<<11, // CLUT access error interrupt enable
	DMA2D_CR_TWIE = 1UL<<10, // Transfer watermark interrupt enable
	DMA2D_CR_TCIE = 1UL<<9, // Transfer complete interrupt enable
	DMA2D_CR_TEIE = 1UL<<8, // Transfer error interrupt enable
	DMA2D_CR_ABORT = 1UL<<2, // Abort
	DMA2D_CR_SUSP = 1UL<<1, // Suspend
	DMA2D_CR_START = 1UL<<0, // Start		
};
inline void dma2d_cr_set_mode(struct DMA2D_Type* p, uint32_t val) { p->CR = (p->CR & ~DMA2D_CR_MODE) | ((val<<16) & DMA2D_CR_MODE); }
inline uint32_t dma2d_cr_get_mode(struct DMA2D_Type* p) { return (p->CR & DMA2D_CR_MODE) >> 16 ; }

// DMA2D->ISR Interrupt Status Register
enum {
	DMA2D_ISR_CEIF = 1UL<<5, // Configuration error interrupt flag
	DMA2D_ISR_CTCIF = 1UL<<4, // CLUT transfer complete interrupt flag
	DMA2D_ISR_CAEIF = 1UL<<3, // CLUT access error interrupt flag
	DMA2D_ISR_TWIF = 1UL<<2, // Transfer watermark interrupt flag
	DMA2D_ISR_TCIF = 1UL<<1, // Transfer complete interrupt flag
	DMA2D_ISR_TEIF = 1UL<<0, // Transfer error interrupt flag		
};

// DMA2D->IFCR interrupt flag clear register
enum {
	DMA2D_IFCR_CCEIF = 1UL<<5, // Clear configuration error interrupt flag
	DMA2D_IFCR_CCTCIF = 1UL<<4, // Clear CLUT transfer complete interrupt flag
	DMA2D_IFCR_CAECIF = 1UL<<3, // Clear CLUT access error interrupt flag
	DMA2D_IFCR_CTWIF = 1UL<<2, // Clear transfer watermark interrupt flag
	DMA2D_IFCR_CTCIF = 1UL<<1, // Clear transfer complete interrupt flag
	DMA2D_IFCR_CTEIF = 1UL<<0, // Clear Transfer error interrupt flag		
};

// DMA2D->FGOR foreground offset register
enum {
	DMA2D_FGOR_LO = ((1UL<<14)-1) << 0, // Line offset		
};
inline void dma2d_fgor_set_lo(struct DMA2D_Type* p, uint32_t val) { p->FGOR = (p->FGOR & ~DMA2D_FGOR_LO) | ((val<<0) & DMA2D_FGOR_LO); }
inline uint32_t dma2d_fgor_get_lo(struct DMA2D_Type* p) { return (p->FGOR & DMA2D_FGOR_LO) >> 0 ; }

// DMA2D->BGOR background offset register
enum {
	DMA2D_BGOR_LO = ((1UL<<14)-1) << 0, // Line offset		
};
inline void dma2d_bgor_set_lo(struct DMA2D_Type* p, uint32_t val) { p->BGOR = (p->BGOR & ~DMA2D_BGOR_LO) | ((val<<0) & DMA2D_BGOR_LO); }
inline uint32_t dma2d_bgor_get_lo(struct DMA2D_Type* p) { return (p->BGOR & DMA2D_BGOR_LO) >> 0 ; }

// DMA2D->FGPFCCR foreground PFC control register
enum {
	DMA2D_FGPFCCR_ALPHA = ((1UL<<8)-1) << 24, // Alpha value
	DMA2D_FGPFCCR_AM = ((1UL<<2)-1) << 16, // Alpha mode
	DMA2D_FGPFCCR_CS = ((1UL<<8)-1) << 8, // CLUT size
	DMA2D_FGPFCCR_START = 1UL<<5, // Start
	DMA2D_FGPFCCR_CCM = 1UL<<4, // CLUT color mode
	DMA2D_FGPFCCR_CM = ((1UL<<4)-1) << 0, // Color mode		
};
inline void dma2d_fgpfccr_set_alpha(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_ALPHA) | ((val<<24) & DMA2D_FGPFCCR_ALPHA); }
inline void dma2d_fgpfccr_set_am(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_AM) | ((val<<16) & DMA2D_FGPFCCR_AM); }
inline void dma2d_fgpfccr_set_cs(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_CS) | ((val<<8) & DMA2D_FGPFCCR_CS); }
inline void dma2d_fgpfccr_set_cm(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_CM) | ((val<<0) & DMA2D_FGPFCCR_CM); }
inline uint32_t dma2d_fgpfccr_get_alpha(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_ALPHA) >> 24 ; }
inline uint32_t dma2d_fgpfccr_get_am(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_AM) >> 16 ; }
inline uint32_t dma2d_fgpfccr_get_cs(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_CS) >> 8 ; }
inline uint32_t dma2d_fgpfccr_get_cm(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_CM) >> 0 ; }

// DMA2D->FGCOLR foreground color register
enum {
	DMA2D_FGCOLR_RED = ((1UL<<8)-1) << 16, // Red Value
	DMA2D_FGCOLR_GREEN = ((1UL<<8)-1) << 8, // Green Value
	DMA2D_FGCOLR_BLUE = ((1UL<<8)-1) << 0, // Blue Value		
};
inline void dma2d_fgcolr_set_red(struct DMA2D_Type* p, uint32_t val) { p->FGCOLR = (p->FGCOLR & ~DMA2D_FGCOLR_RED) | ((val<<16) & DMA2D_FGCOLR_RED); }
inline void dma2d_fgcolr_set_green(struct DMA2D_Type* p, uint32_t val) { p->FGCOLR = (p->FGCOLR & ~DMA2D_FGCOLR_GREEN) | ((val<<8) & DMA2D_FGCOLR_GREEN); }
inline void dma2d_fgcolr_set_blue(struct DMA2D_Type* p, uint32_t val) { p->FGCOLR = (p->FGCOLR & ~DMA2D_FGCOLR_BLUE) | ((val<<0) & DMA2D_FGCOLR_BLUE); }
inline uint32_t dma2d_fgcolr_get_red(struct DMA2D_Type* p) { return (p->FGCOLR & DMA2D_FGCOLR_RED) >> 16 ; }
inline uint32_t dma2d_fgcolr_get_green(struct DMA2D_Type* p) { return (p->FGCOLR & DMA2D_FGCOLR_GREEN) >> 8 ; }
inline uint32_t dma2d_fgcolr_get_blue(struct DMA2D_Type* p) { return (p->FGCOLR & DMA2D_FGCOLR_BLUE) >> 0 ; }

// DMA2D->BGPFCCR background PFC control register
enum {
	DMA2D_BGPFCCR_ALPHA = ((1UL<<8)-1) << 24, // Alpha value
	DMA2D_BGPFCCR_AM = ((1UL<<2)-1) << 16, // Alpha mode
	DMA2D_BGPFCCR_CS = ((1UL<<8)-1) << 8, // CLUT size
	DMA2D_BGPFCCR_START = 1UL<<5, // Start
	DMA2D_BGPFCCR_CCM = 1UL<<4, // CLUT Color mode
	DMA2D_BGPFCCR_CM = ((1UL<<4)-1) << 0, // Color mode		
};
inline void dma2d_bgpfccr_set_alpha(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_ALPHA) | ((val<<24) & DMA2D_BGPFCCR_ALPHA); }
inline void dma2d_bgpfccr_set_am(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_AM) | ((val<<16) & DMA2D_BGPFCCR_AM); }
inline void dma2d_bgpfccr_set_cs(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_CS) | ((val<<8) & DMA2D_BGPFCCR_CS); }
inline void dma2d_bgpfccr_set_cm(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_CM) | ((val<<0) & DMA2D_BGPFCCR_CM); }
inline uint32_t dma2d_bgpfccr_get_alpha(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_ALPHA) >> 24 ; }
inline uint32_t dma2d_bgpfccr_get_am(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_AM) >> 16 ; }
inline uint32_t dma2d_bgpfccr_get_cs(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_CS) >> 8 ; }
inline uint32_t dma2d_bgpfccr_get_cm(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_CM) >> 0 ; }

// DMA2D->BGCOLR background color register
enum {
	DMA2D_BGCOLR_RED = ((1UL<<8)-1) << 16, // Red Value
	DMA2D_BGCOLR_GREEN = ((1UL<<8)-1) << 8, // Green Value
	DMA2D_BGCOLR_BLUE = ((1UL<<8)-1) << 0, // Blue Value		
};
inline void dma2d_bgcolr_set_red(struct DMA2D_Type* p, uint32_t val) { p->BGCOLR = (p->BGCOLR & ~DMA2D_BGCOLR_RED) | ((val<<16) & DMA2D_BGCOLR_RED); }
inline void dma2d_bgcolr_set_green(struct DMA2D_Type* p, uint32_t val) { p->BGCOLR = (p->BGCOLR & ~DMA2D_BGCOLR_GREEN) | ((val<<8) & DMA2D_BGCOLR_GREEN); }
inline void dma2d_bgcolr_set_blue(struct DMA2D_Type* p, uint32_t val) { p->BGCOLR = (p->BGCOLR & ~DMA2D_BGCOLR_BLUE) | ((val<<0) & DMA2D_BGCOLR_BLUE); }
inline uint32_t dma2d_bgcolr_get_red(struct DMA2D_Type* p) { return (p->BGCOLR & DMA2D_BGCOLR_RED) >> 16 ; }
inline uint32_t dma2d_bgcolr_get_green(struct DMA2D_Type* p) { return (p->BGCOLR & DMA2D_BGCOLR_GREEN) >> 8 ; }
inline uint32_t dma2d_bgcolr_get_blue(struct DMA2D_Type* p) { return (p->BGCOLR & DMA2D_BGCOLR_BLUE) >> 0 ; }

// DMA2D->OPFCCR output PFC control register
enum {
	DMA2D_OPFCCR_CM = ((1UL<<3)-1) << 0, // Color mode		
};
inline void dma2d_opfccr_set_cm(struct DMA2D_Type* p, uint32_t val) { p->OPFCCR = (p->OPFCCR & ~DMA2D_OPFCCR_CM) | ((val<<0) & DMA2D_OPFCCR_CM); }
inline uint32_t dma2d_opfccr_get_cm(struct DMA2D_Type* p) { return (p->OPFCCR & DMA2D_OPFCCR_CM) >> 0 ; }

// DMA2D->OCOLR output color register
enum {
	DMA2D_OCOLR_APLHA = ((1UL<<8)-1) << 24, // Alpha Channel Value
	DMA2D_OCOLR_RED = ((1UL<<8)-1) << 16, // Red Value
	DMA2D_OCOLR_GREEN = ((1UL<<8)-1) << 8, // Green Value
	DMA2D_OCOLR_BLUE = ((1UL<<8)-1) << 0, // Blue Value		
};
inline void dma2d_ocolr_set_aplha(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_APLHA) | ((val<<24) & DMA2D_OCOLR_APLHA); }
inline void dma2d_ocolr_set_red(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_RED) | ((val<<16) & DMA2D_OCOLR_RED); }
inline void dma2d_ocolr_set_green(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_GREEN) | ((val<<8) & DMA2D_OCOLR_GREEN); }
inline void dma2d_ocolr_set_blue(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_BLUE) | ((val<<0) & DMA2D_OCOLR_BLUE); }
inline uint32_t dma2d_ocolr_get_aplha(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_APLHA) >> 24 ; }
inline uint32_t dma2d_ocolr_get_red(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_RED) >> 16 ; }
inline uint32_t dma2d_ocolr_get_green(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_GREEN) >> 8 ; }
inline uint32_t dma2d_ocolr_get_blue(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_BLUE) >> 0 ; }

// DMA2D->OOR output offset register
enum {
	DMA2D_OOR_LO = ((1UL<<14)-1) << 0, // Line Offset		
};
inline void dma2d_oor_set_lo(struct DMA2D_Type* p, uint32_t val) { p->OOR = (p->OOR & ~DMA2D_OOR_LO) | ((val<<0) & DMA2D_OOR_LO); }
inline uint32_t dma2d_oor_get_lo(struct DMA2D_Type* p) { return (p->OOR & DMA2D_OOR_LO) >> 0 ; }

// DMA2D->NLR number of line register
enum {
	DMA2D_NLR_PL = ((1UL<<14)-1) << 16, // Pixel per lines
	DMA2D_NLR_NL = ((1UL<<16)-1) << 0, // Number of lines		
};
inline void dma2d_nlr_set_pl(struct DMA2D_Type* p, uint32_t val) { p->NLR = (p->NLR & ~DMA2D_NLR_PL) | ((val<<16) & DMA2D_NLR_PL); }
inline void dma2d_nlr_set_nl(struct DMA2D_Type* p, uint32_t val) { p->NLR = (p->NLR & ~DMA2D_NLR_NL) | ((val<<0) & DMA2D_NLR_NL); }
inline uint32_t dma2d_nlr_get_pl(struct DMA2D_Type* p) { return (p->NLR & DMA2D_NLR_PL) >> 16 ; }
inline uint32_t dma2d_nlr_get_nl(struct DMA2D_Type* p) { return (p->NLR & DMA2D_NLR_NL) >> 0 ; }

// DMA2D->AMTCR AHB master timer configuration register
enum {
	DMA2D_AMTCR_DT = ((1UL<<8)-1) << 8, // Dead Time
	DMA2D_AMTCR_EN = 1UL<<0, // Enable		
};
inline void dma2d_amtcr_set_dt(struct DMA2D_Type* p, uint32_t val) { p->AMTCR = (p->AMTCR & ~DMA2D_AMTCR_DT) | ((val<<8) & DMA2D_AMTCR_DT); }
inline uint32_t dma2d_amtcr_get_dt(struct DMA2D_Type* p) { return (p->AMTCR & DMA2D_AMTCR_DT) >> 8 ; }

// DMA2D->FGCLUT FGCLUT
enum {
	DMA2D_FGCLUT_APLHA = ((1UL<<8)-1) << 24, // APLHA
	DMA2D_FGCLUT_RED = ((1UL<<8)-1) << 16, // RED
	DMA2D_FGCLUT_GREEN = ((1UL<<8)-1) << 8, // GREEN
	DMA2D_FGCLUT_BLUE = ((1UL<<8)-1) << 0, // BLUE		
};
inline void dma2d_fgclut_set_aplha(struct DMA2D_Type* p, uint32_t val) { p->FGCLUT = (p->FGCLUT & ~DMA2D_FGCLUT_APLHA) | ((val<<24) & DMA2D_FGCLUT_APLHA); }
inline void dma2d_fgclut_set_red(struct DMA2D_Type* p, uint32_t val) { p->FGCLUT = (p->FGCLUT & ~DMA2D_FGCLUT_RED) | ((val<<16) & DMA2D_FGCLUT_RED); }
inline void dma2d_fgclut_set_green(struct DMA2D_Type* p, uint32_t val) { p->FGCLUT = (p->FGCLUT & ~DMA2D_FGCLUT_GREEN) | ((val<<8) & DMA2D_FGCLUT_GREEN); }
inline void dma2d_fgclut_set_blue(struct DMA2D_Type* p, uint32_t val) { p->FGCLUT = (p->FGCLUT & ~DMA2D_FGCLUT_BLUE) | ((val<<0) & DMA2D_FGCLUT_BLUE); }
inline uint32_t dma2d_fgclut_get_aplha(struct DMA2D_Type* p) { return (p->FGCLUT & DMA2D_FGCLUT_APLHA) >> 24 ; }
inline uint32_t dma2d_fgclut_get_red(struct DMA2D_Type* p) { return (p->FGCLUT & DMA2D_FGCLUT_RED) >> 16 ; }
inline uint32_t dma2d_fgclut_get_green(struct DMA2D_Type* p) { return (p->FGCLUT & DMA2D_FGCLUT_GREEN) >> 8 ; }
inline uint32_t dma2d_fgclut_get_blue(struct DMA2D_Type* p) { return (p->FGCLUT & DMA2D_FGCLUT_BLUE) >> 0 ; }

// DMA2D->BGCLUT BGCLUT
enum {
	DMA2D_BGCLUT_APLHA = ((1UL<<8)-1) << 24, // APLHA
	DMA2D_BGCLUT_RED = ((1UL<<8)-1) << 16, // RED
	DMA2D_BGCLUT_GREEN = ((1UL<<8)-1) << 8, // GREEN
	DMA2D_BGCLUT_BLUE = ((1UL<<8)-1) << 0, // BLUE		
};
inline void dma2d_bgclut_set_aplha(struct DMA2D_Type* p, uint32_t val) { p->BGCLUT = (p->BGCLUT & ~DMA2D_BGCLUT_APLHA) | ((val<<24) & DMA2D_BGCLUT_APLHA); }
inline void dma2d_bgclut_set_red(struct DMA2D_Type* p, uint32_t val) { p->BGCLUT = (p->BGCLUT & ~DMA2D_BGCLUT_RED) | ((val<<16) & DMA2D_BGCLUT_RED); }
inline void dma2d_bgclut_set_green(struct DMA2D_Type* p, uint32_t val) { p->BGCLUT = (p->BGCLUT & ~DMA2D_BGCLUT_GREEN) | ((val<<8) & DMA2D_BGCLUT_GREEN); }
inline void dma2d_bgclut_set_blue(struct DMA2D_Type* p, uint32_t val) { p->BGCLUT = (p->BGCLUT & ~DMA2D_BGCLUT_BLUE) | ((val<<0) & DMA2D_BGCLUT_BLUE); }
inline uint32_t dma2d_bgclut_get_aplha(struct DMA2D_Type* p) { return (p->BGCLUT & DMA2D_BGCLUT_APLHA) >> 24 ; }
inline uint32_t dma2d_bgclut_get_red(struct DMA2D_Type* p) { return (p->BGCLUT & DMA2D_BGCLUT_RED) >> 16 ; }
inline uint32_t dma2d_bgclut_get_green(struct DMA2D_Type* p) { return (p->BGCLUT & DMA2D_BGCLUT_GREEN) >> 8 ; }
inline uint32_t dma2d_bgclut_get_blue(struct DMA2D_Type* p) { return (p->BGCLUT & DMA2D_BGCLUT_BLUE) >> 0 ; }

/* DSI Host */
struct DSI_Type {
	__I uint32_t VR; // @0 DSI Host Version Register
	__IO uint8_t CR; // @4 DSI Host Control Register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint16_t CCR; // @8 DSI HOST Clock Control Register
	 uint8_t RESERVED1[2]; // @10 
	__IO uint8_t LVCIDR; // @12 DSI Host LTDC VCID Register
	 uint8_t RESERVED2[3]; // @13 
	__IO uint16_t LCOLCR; // @16 DSI Host LTDC Color Coding Register
	 uint8_t RESERVED3[2]; // @18 
	__IO uint8_t LPCR; // @20 DSI Host LTDC Polarity Configuration Register
	 uint8_t RESERVED4[3]; // @21 
	__IO uint32_t LPMCR; // @24 DSI Host Low-Power mode Configuration Register
	 uint8_t RESERVED5[16]; // @28 
	__IO uint8_t PCR; // @44 DSI Host Protocol Configuration Register
	 uint8_t RESERVED6[3]; // @45 
	__IO uint8_t GVCIDR; // @48 DSI Host Generic VCID Register
	 uint8_t RESERVED7[3]; // @49 
	__IO uint8_t MCR; // @52 DSI Host mode Configuration Register
	 uint8_t RESERVED8[3]; // @53 
	__IO uint32_t VMCR; // @56 DSI Host Video mode Configuration Register
	__IO uint16_t VPCR; // @60 DSI Host Video Packet Configuration Register
	 uint8_t RESERVED9[2]; // @62 
	__IO uint16_t VCCR; // @64 DSI Host Video Chunks Configuration Register
	 uint8_t RESERVED10[2]; // @66 
	__IO uint16_t VNPCR; // @68 DSI Host Video Null Packet Configuration Register
	 uint8_t RESERVED11[2]; // @70 
	__IO uint16_t VHSACR; // @72 DSI Host Video HSA Configuration Register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t VHBPCR; // @76 DSI Host Video HBP Configuration Register
	 uint8_t RESERVED13[2]; // @78 
	__IO uint16_t VLCR; // @80 DSI Host Video Line Configuration Register
	 uint8_t RESERVED14[2]; // @82 
	__IO uint16_t VVSACR; // @84 DSI Host Video VSA Configuration Register
	 uint8_t RESERVED15[2]; // @86 
	__IO uint16_t VVBPCR; // @88 DSI Host Video VBP Configuration Register
	 uint8_t RESERVED16[2]; // @90 
	__IO uint16_t VVFPCR; // @92 DSI Host Video VFP Configuration Register
	 uint8_t RESERVED17[2]; // @94 
	__IO uint16_t VVACR; // @96 DSI Host Video VA Configuration Register
	 uint8_t RESERVED18[2]; // @98 
	__IO uint16_t LCCR; // @100 DSI Host LTDC Command Configuration Register
	 uint8_t RESERVED19[2]; // @102 
	__IO uint32_t CMCR; // @104 DSI Host Command mode Configuration Register
	__IO uint32_t GHCR; // @108 DSI Host Generic Header Configuration Register
	__IO uint32_t GPDR; // @112 DSI Host Generic Payload Data Register
	__I uint8_t GPSR; // @116 DSI Host Generic Packet Status Register
	 uint8_t RESERVED20[3]; // @117 
	__IO uint32_t TCCR0; // @120 DSI Host Timeout Counter Configuration Register 0
	__IO uint16_t TCCR1; // @124 DSI Host Timeout Counter Configuration Register 1
	 uint8_t RESERVED21[2]; // @126 
	__IO uint16_t TCCR2; // @128 DSI Host Timeout Counter Configuration Register 2
	 uint8_t RESERVED22[2]; // @130 
	__IO uint32_t TCCR3; // @132 DSI Host Timeout Counter Configuration Register 3
	__IO uint16_t TCCR4; // @136 DSI Host Timeout Counter Configuration Register 4
	 uint8_t RESERVED23[2]; // @138 
	__IO uint16_t TCCR5; // @140 DSI Host Timeout Counter Configuration Register 5
	 uint8_t RESERVED24[6]; // @142 
	__IO uint8_t CLCR; // @148 DSI Host Clock Lane Configuration Register
	 uint8_t RESERVED25[3]; // @149 
	__IO uint32_t CLTCR; // @152 DSI Host Clock Lane Timer Configuration Register
	__IO uint32_t DLTCR; // @156 DSI Host Data Lane Timer Configuration Register
	__IO uint8_t PCTLR; // @160 DSI Host PHY Control Register
	 uint8_t RESERVED26[3]; // @161 
	__IO uint16_t PCONFR; // @164 DSI Host PHY Configuration Register
	 uint8_t RESERVED27[2]; // @166 
	__IO uint8_t PUCR; // @168 DSI Host PHY ULPS Control Register
	 uint8_t RESERVED28[3]; // @169 
	__IO uint8_t PTTCR; // @172 DSI Host PHY TX Triggers Configuration Register
	 uint8_t RESERVED29[3]; // @173 
	__I uint16_t PSR; // @176 DSI Host PHY Status Register
	 uint8_t RESERVED30[10]; // @178 
	__I uint32_t ISR0; // @188 DSI Host Interrupt & Status Register 0
	__I uint16_t ISR1; // @192 DSI Host Interrupt & Status Register 1
	 uint8_t RESERVED31[2]; // @194 
	__IO uint32_t IER0; // @196 DSI Host Interrupt Enable Register 0
	__IO uint16_t IER1; // @200 DSI Host Interrupt Enable Register 1
	 uint8_t RESERVED32[14]; // @202 
	__O uint32_t FIR0; // @216 DSI Host Force Interrupt Register 0
	__O uint16_t FIR1; // @220 DSI Host Force Interrupt Register 1
	 uint8_t RESERVED33[34]; // @222 
	__IO uint16_t VSCR; // @256 DSI Host Video Shadow Control Register
	 uint8_t RESERVED34[10]; // @258 
	__I uint8_t LCVCIDR; // @268 DSI Host LTDC Current VCID Register
	 uint8_t RESERVED35[3]; // @269 
	__I uint16_t LCCCR; // @272 DSI Host LTDC Current Color Coding Register
	 uint8_t RESERVED36[6]; // @274 
	__I uint32_t LPMCCR; // @280 DSI Host Low-Power mode Current Configuration Register
	 uint8_t RESERVED37[28]; // @284 
	__I uint16_t VMCCR; // @312 DSI Host Video mode Current Configuration Register
	 uint8_t RESERVED38[2]; // @314 
	__I uint16_t VPCCR; // @316 DSI Host Video Packet Current Configuration Register
	 uint8_t RESERVED39[2]; // @318 
	__I uint16_t VCCCR; // @320 DSI Host Video Chunks Current Configuration Register
	 uint8_t RESERVED40[2]; // @322 
	__I uint16_t VNPCCR; // @324 DSI Host Video Null Packet Current Configuration Register
	 uint8_t RESERVED41[2]; // @326 
	__I uint16_t VHSACCR; // @328 DSI Host Video HSA Current Configuration Register
	 uint8_t RESERVED42[2]; // @330 
	__I uint16_t VHBPCCR; // @332 DSI Host Video HBP Current Configuration Register
	 uint8_t RESERVED43[2]; // @334 
	__I uint16_t VLCCR; // @336 DSI Host Video Line Current Configuration Register
	 uint8_t RESERVED44[2]; // @338 
	__I uint16_t VVSACCR; // @340 DSI Host Video VSA Current Configuration Register
	 uint8_t RESERVED45[2]; // @342 
	__I uint16_t VVBPCCR; // @344 DSI Host Video VBP Current Configuration Register
	 uint8_t RESERVED46[2]; // @346 
	__I uint16_t VVFPCCR; // @348 DSI Host Video VFP Current Configuration Register
	 uint8_t RESERVED47[2]; // @350 
	__I uint16_t VVACCR; // @352 DSI Host Video VA Current Configuration Register
	 uint8_t RESERVED48[670]; // @354 
	__IO uint8_t WCFGR; // @1024 DSI Wrapper Configuration Register
	 uint8_t RESERVED49[3]; // @1025 
	__IO uint8_t WCR; // @1028 DSI Wrapper Control Register
	 uint8_t RESERVED50[3]; // @1029 
	__IO uint16_t WIER; // @1032 DSI Wrapper Interrupt Enable Register
	 uint8_t RESERVED51[2]; // @1034 
	__I uint16_t WISR; // @1036 DSI Wrapper Interrupt & Status Register
	 uint8_t RESERVED52[2]; // @1038 
	__IO uint16_t WIFCR; // @1040 DSI Wrapper Interrupt Flag Clear Register
	 uint8_t RESERVED53[6]; // @1042 
	__IO uint32_t WPCR1; // @1048 DSI Wrapper PHY Configuration Register 1
	__IO uint32_t WPCR2; // @1052 DSI Wrapper PHY Configuration Register 2
	__IO uint32_t WPCR3; // @1056 DSI Wrapper PHY Configuration Register 3
	__IO uint32_t WPCR4; // @1060 DSI_WPCR4
	__IO uint8_t WPCR5; // @1064 DSI Wrapper PHY Configuration Register 5
	 uint8_t RESERVED54[7]; // @1065 
	__IO uint32_t WRPCR; // @1072 DSI Wrapper Regulator and PLL Control Register
};

// DSI->CR DSI Host Control Register
enum {
	DSI_CR_EN = 1UL<<0, // Enable		
};

// DSI->CCR DSI HOST Clock Control Register
enum {
	DSI_CCR_TOCKDIV = ((1UL<<8)-1) << 8, // Timeout Clock Division
	DSI_CCR_TXECKDIV = ((1UL<<8)-1) << 0, // TX Escape Clock Division		
};
inline void dsi_ccr_set_tockdiv(struct DSI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~DSI_CCR_TOCKDIV) | ((val<<8) & DSI_CCR_TOCKDIV); }
inline void dsi_ccr_set_txeckdiv(struct DSI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~DSI_CCR_TXECKDIV) | ((val<<0) & DSI_CCR_TXECKDIV); }
inline uint32_t dsi_ccr_get_tockdiv(struct DSI_Type* p) { return (p->CCR & DSI_CCR_TOCKDIV) >> 8 ; }
inline uint32_t dsi_ccr_get_txeckdiv(struct DSI_Type* p) { return (p->CCR & DSI_CCR_TXECKDIV) >> 0 ; }

// DSI->LVCIDR DSI Host LTDC VCID Register
enum {
	DSI_LVCIDR_VCID = ((1UL<<2)-1) << 0, // Virtual Channel ID		
};
inline void dsi_lvcidr_set_vcid(struct DSI_Type* p, uint32_t val) { p->LVCIDR = (p->LVCIDR & ~DSI_LVCIDR_VCID) | ((val<<0) & DSI_LVCIDR_VCID); }
inline uint32_t dsi_lvcidr_get_vcid(struct DSI_Type* p) { return (p->LVCIDR & DSI_LVCIDR_VCID) >> 0 ; }

// DSI->LCOLCR DSI Host LTDC Color Coding Register
enum {
	DSI_LCOLCR_LPE = 1UL<<8, // Loosely Packet Enable
	DSI_LCOLCR_COLC = ((1UL<<4)-1) << 0, // Color Coding		
};
inline void dsi_lcolcr_set_colc(struct DSI_Type* p, uint32_t val) { p->LCOLCR = (p->LCOLCR & ~DSI_LCOLCR_COLC) | ((val<<0) & DSI_LCOLCR_COLC); }
inline uint32_t dsi_lcolcr_get_colc(struct DSI_Type* p) { return (p->LCOLCR & DSI_LCOLCR_COLC) >> 0 ; }

// DSI->LPCR DSI Host LTDC Polarity Configuration Register
enum {
	DSI_LPCR_HSP = 1UL<<2, // HSYNC Polarity
	DSI_LPCR_VSP = 1UL<<1, // VSYNC Polarity
	DSI_LPCR_DEP = 1UL<<0, // Data Enable Polarity		
};

// DSI->LPMCR DSI Host Low-Power mode Configuration Register
enum {
	DSI_LPMCR_LPSIZE = ((1UL<<8)-1) << 16, // Largest Packet Size
	DSI_LPMCR_VLPSIZE = ((1UL<<8)-1) << 0, // VACT Largest Packet Size		
};
inline void dsi_lpmcr_set_lpsize(struct DSI_Type* p, uint32_t val) { p->LPMCR = (p->LPMCR & ~DSI_LPMCR_LPSIZE) | ((val<<16) & DSI_LPMCR_LPSIZE); }
inline void dsi_lpmcr_set_vlpsize(struct DSI_Type* p, uint32_t val) { p->LPMCR = (p->LPMCR & ~DSI_LPMCR_VLPSIZE) | ((val<<0) & DSI_LPMCR_VLPSIZE); }
inline uint32_t dsi_lpmcr_get_lpsize(struct DSI_Type* p) { return (p->LPMCR & DSI_LPMCR_LPSIZE) >> 16 ; }
inline uint32_t dsi_lpmcr_get_vlpsize(struct DSI_Type* p) { return (p->LPMCR & DSI_LPMCR_VLPSIZE) >> 0 ; }

// DSI->PCR DSI Host Protocol Configuration Register
enum {
	DSI_PCR_CRCRXE = 1UL<<4, // CRC Reception Enable
	DSI_PCR_ECCRXE = 1UL<<3, // ECC Reception Enable
	DSI_PCR_BTAE = 1UL<<2, // Bus Turn Around Enable
	DSI_PCR_ETRXE = 1UL<<1, // EoTp Reception Enable
	DSI_PCR_ETTXE = 1UL<<0, // EoTp Transmission Enable		
};

// DSI->GVCIDR DSI Host Generic VCID Register
enum {
	DSI_GVCIDR_VCID = ((1UL<<2)-1) << 0, // Virtual Channel ID		
};
inline void dsi_gvcidr_set_vcid(struct DSI_Type* p, uint32_t val) { p->GVCIDR = (p->GVCIDR & ~DSI_GVCIDR_VCID) | ((val<<0) & DSI_GVCIDR_VCID); }
inline uint32_t dsi_gvcidr_get_vcid(struct DSI_Type* p) { return (p->GVCIDR & DSI_GVCIDR_VCID) >> 0 ; }

// DSI->MCR DSI Host mode Configuration Register
enum {
	DSI_MCR_CMDM = 1UL<<0, // Command mode		
};

// DSI->VMCR DSI Host Video mode Configuration Register
enum {
	DSI_VMCR_PGO = 1UL<<24, // Pattern Generator Orientation
	DSI_VMCR_PGM = 1UL<<20, // Pattern Generator mode
	DSI_VMCR_PGE = 1UL<<16, // Pattern Generator Enable
	DSI_VMCR_LPCE = 1UL<<15, // Low-Power Command Enable
	DSI_VMCR_FBTAAE = 1UL<<14, // Frame Bus-Turn-Around Acknowledge Enable
	DSI_VMCR_LPHFPE = 1UL<<13, // Low-Power Horizontal Front-Porch Enable
	DSI_VMCR_LPHBPE = 1UL<<12, // Low-Power Horizontal Back-Porch Enable
	DSI_VMCR_LPVAE = 1UL<<11, // Low-Power Vertical Active Enable
	DSI_VMCR_LPVFPE = 1UL<<10, // Low-power Vertical Front-porch Enable
	DSI_VMCR_LPVBPE = 1UL<<9, // Low-power Vertical Back-Porch Enable
	DSI_VMCR_LPVSAE = 1UL<<8, // Low-Power Vertical Sync Active Enable
	DSI_VMCR_VMT = ((1UL<<2)-1) << 0, // Video mode Type		
};
inline void dsi_vmcr_set_vmt(struct DSI_Type* p, uint32_t val) { p->VMCR = (p->VMCR & ~DSI_VMCR_VMT) | ((val<<0) & DSI_VMCR_VMT); }
inline uint32_t dsi_vmcr_get_vmt(struct DSI_Type* p) { return (p->VMCR & DSI_VMCR_VMT) >> 0 ; }

// DSI->VPCR DSI Host Video Packet Configuration Register
enum {
	DSI_VPCR_VPSIZE = ((1UL<<14)-1) << 0, // Video Packet Size		
};
inline void dsi_vpcr_set_vpsize(struct DSI_Type* p, uint32_t val) { p->VPCR = (p->VPCR & ~DSI_VPCR_VPSIZE) | ((val<<0) & DSI_VPCR_VPSIZE); }
inline uint32_t dsi_vpcr_get_vpsize(struct DSI_Type* p) { return (p->VPCR & DSI_VPCR_VPSIZE) >> 0 ; }

// DSI->VCCR DSI Host Video Chunks Configuration Register
enum {
	DSI_VCCR_NUMC = ((1UL<<13)-1) << 0, // Number of Chunks		
};
inline void dsi_vccr_set_numc(struct DSI_Type* p, uint32_t val) { p->VCCR = (p->VCCR & ~DSI_VCCR_NUMC) | ((val<<0) & DSI_VCCR_NUMC); }
inline uint32_t dsi_vccr_get_numc(struct DSI_Type* p) { return (p->VCCR & DSI_VCCR_NUMC) >> 0 ; }

// DSI->VNPCR DSI Host Video Null Packet Configuration Register
enum {
	DSI_VNPCR_NPSIZE = ((1UL<<13)-1) << 0, // Null Packet Size		
};
inline void dsi_vnpcr_set_npsize(struct DSI_Type* p, uint32_t val) { p->VNPCR = (p->VNPCR & ~DSI_VNPCR_NPSIZE) | ((val<<0) & DSI_VNPCR_NPSIZE); }
inline uint32_t dsi_vnpcr_get_npsize(struct DSI_Type* p) { return (p->VNPCR & DSI_VNPCR_NPSIZE) >> 0 ; }

// DSI->VHSACR DSI Host Video HSA Configuration Register
enum {
	DSI_VHSACR_HSA = ((1UL<<12)-1) << 0, // Horizontal Synchronism Active duration		
};
inline void dsi_vhsacr_set_hsa(struct DSI_Type* p, uint32_t val) { p->VHSACR = (p->VHSACR & ~DSI_VHSACR_HSA) | ((val<<0) & DSI_VHSACR_HSA); }
inline uint32_t dsi_vhsacr_get_hsa(struct DSI_Type* p) { return (p->VHSACR & DSI_VHSACR_HSA) >> 0 ; }

// DSI->VHBPCR DSI Host Video HBP Configuration Register
enum {
	DSI_VHBPCR_HBP = ((1UL<<12)-1) << 0, // Horizontal Back-Porch duration		
};
inline void dsi_vhbpcr_set_hbp(struct DSI_Type* p, uint32_t val) { p->VHBPCR = (p->VHBPCR & ~DSI_VHBPCR_HBP) | ((val<<0) & DSI_VHBPCR_HBP); }
inline uint32_t dsi_vhbpcr_get_hbp(struct DSI_Type* p) { return (p->VHBPCR & DSI_VHBPCR_HBP) >> 0 ; }

// DSI->VLCR DSI Host Video Line Configuration Register
enum {
	DSI_VLCR_HLINE = ((1UL<<15)-1) << 0, // Horizontal Line duration		
};
inline void dsi_vlcr_set_hline(struct DSI_Type* p, uint32_t val) { p->VLCR = (p->VLCR & ~DSI_VLCR_HLINE) | ((val<<0) & DSI_VLCR_HLINE); }
inline uint32_t dsi_vlcr_get_hline(struct DSI_Type* p) { return (p->VLCR & DSI_VLCR_HLINE) >> 0 ; }

// DSI->VVSACR DSI Host Video VSA Configuration Register
enum {
	DSI_VVSACR_VSA = ((1UL<<10)-1) << 0, // Vertical Synchronism Active duration		
};
inline void dsi_vvsacr_set_vsa(struct DSI_Type* p, uint32_t val) { p->VVSACR = (p->VVSACR & ~DSI_VVSACR_VSA) | ((val<<0) & DSI_VVSACR_VSA); }
inline uint32_t dsi_vvsacr_get_vsa(struct DSI_Type* p) { return (p->VVSACR & DSI_VVSACR_VSA) >> 0 ; }

// DSI->VVBPCR DSI Host Video VBP Configuration Register
enum {
	DSI_VVBPCR_VBP = ((1UL<<10)-1) << 0, // Vertical Back-Porch duration		
};
inline void dsi_vvbpcr_set_vbp(struct DSI_Type* p, uint32_t val) { p->VVBPCR = (p->VVBPCR & ~DSI_VVBPCR_VBP) | ((val<<0) & DSI_VVBPCR_VBP); }
inline uint32_t dsi_vvbpcr_get_vbp(struct DSI_Type* p) { return (p->VVBPCR & DSI_VVBPCR_VBP) >> 0 ; }

// DSI->VVFPCR DSI Host Video VFP Configuration Register
enum {
	DSI_VVFPCR_VFP = ((1UL<<10)-1) << 0, // Vertical Front-Porch duration		
};
inline void dsi_vvfpcr_set_vfp(struct DSI_Type* p, uint32_t val) { p->VVFPCR = (p->VVFPCR & ~DSI_VVFPCR_VFP) | ((val<<0) & DSI_VVFPCR_VFP); }
inline uint32_t dsi_vvfpcr_get_vfp(struct DSI_Type* p) { return (p->VVFPCR & DSI_VVFPCR_VFP) >> 0 ; }

// DSI->VVACR DSI Host Video VA Configuration Register
enum {
	DSI_VVACR_VA = ((1UL<<14)-1) << 0, // Vertical Active duration		
};
inline void dsi_vvacr_set_va(struct DSI_Type* p, uint32_t val) { p->VVACR = (p->VVACR & ~DSI_VVACR_VA) | ((val<<0) & DSI_VVACR_VA); }
inline uint32_t dsi_vvacr_get_va(struct DSI_Type* p) { return (p->VVACR & DSI_VVACR_VA) >> 0 ; }

// DSI->CMCR DSI Host Command mode Configuration Register
enum {
	DSI_CMCR_MRDPS = 1UL<<24, // Maximum Read Packet Size
	DSI_CMCR_DLWTX = 1UL<<19, // DCS Long Write Transmission
	DSI_CMCR_DSR0TX = 1UL<<18, // DCS Short Read Zero parameter Transmission
	DSI_CMCR_DSW1TX = 1UL<<17, // DCS Short Read One parameter Transmission
	DSI_CMCR_DSW0TX = 1UL<<16, // DCS Short Write Zero parameter Transmission
	DSI_CMCR_GLWTX = 1UL<<14, // Generic Long Write Transmission
	DSI_CMCR_GSR2TX = 1UL<<13, // Generic Short Read Two parameters Transmission
	DSI_CMCR_GSR1TX = 1UL<<12, // Generic Short Read One parameters Transmission
	DSI_CMCR_GSR0TX = 1UL<<11, // Generic Short Read Zero parameters Transmission
	DSI_CMCR_GSW2TX = 1UL<<10, // Generic Short Write Two parameters Transmission
	DSI_CMCR_GSW1TX = 1UL<<9, // Generic Short Write One parameters Transmission
	DSI_CMCR_GSW0TX = 1UL<<8, // Generic Short Write Zero parameters Transmission
	DSI_CMCR_ARE = 1UL<<1, // Acknowledge Request Enable
	DSI_CMCR_TEARE = 1UL<<0, // Tearing Effect Acknowledge Request Enable		
};

// DSI->GHCR DSI Host Generic Header Configuration Register
enum {
	DSI_GHCR_WCMSB = ((1UL<<8)-1) << 16, // WordCount MSB
	DSI_GHCR_WCLSB = ((1UL<<8)-1) << 8, // WordCount LSB
	DSI_GHCR_VCID = ((1UL<<2)-1) << 6, // Channel
	DSI_GHCR_DT = ((1UL<<6)-1) << 0, // Type		
};
inline void dsi_ghcr_set_wcmsb(struct DSI_Type* p, uint32_t val) { p->GHCR = (p->GHCR & ~DSI_GHCR_WCMSB) | ((val<<16) & DSI_GHCR_WCMSB); }
inline void dsi_ghcr_set_wclsb(struct DSI_Type* p, uint32_t val) { p->GHCR = (p->GHCR & ~DSI_GHCR_WCLSB) | ((val<<8) & DSI_GHCR_WCLSB); }
inline void dsi_ghcr_set_vcid(struct DSI_Type* p, uint32_t val) { p->GHCR = (p->GHCR & ~DSI_GHCR_VCID) | ((val<<6) & DSI_GHCR_VCID); }
inline void dsi_ghcr_set_dt(struct DSI_Type* p, uint32_t val) { p->GHCR = (p->GHCR & ~DSI_GHCR_DT) | ((val<<0) & DSI_GHCR_DT); }
inline uint32_t dsi_ghcr_get_wcmsb(struct DSI_Type* p) { return (p->GHCR & DSI_GHCR_WCMSB) >> 16 ; }
inline uint32_t dsi_ghcr_get_wclsb(struct DSI_Type* p) { return (p->GHCR & DSI_GHCR_WCLSB) >> 8 ; }
inline uint32_t dsi_ghcr_get_vcid(struct DSI_Type* p) { return (p->GHCR & DSI_GHCR_VCID) >> 6 ; }
inline uint32_t dsi_ghcr_get_dt(struct DSI_Type* p) { return (p->GHCR & DSI_GHCR_DT) >> 0 ; }

// DSI->GPDR DSI Host Generic Payload Data Register
enum {
	DSI_GPDR_DATA4 = ((1UL<<8)-1) << 24, // Payload Byte 4
	DSI_GPDR_DATA3 = ((1UL<<8)-1) << 16, // Payload Byte 3
	DSI_GPDR_DATA2 = ((1UL<<8)-1) << 8, // Payload Byte 2
	DSI_GPDR_DATA1 = ((1UL<<8)-1) << 0, // Payload Byte 1		
};
inline void dsi_gpdr_set_data4(struct DSI_Type* p, uint32_t val) { p->GPDR = (p->GPDR & ~DSI_GPDR_DATA4) | ((val<<24) & DSI_GPDR_DATA4); }
inline void dsi_gpdr_set_data3(struct DSI_Type* p, uint32_t val) { p->GPDR = (p->GPDR & ~DSI_GPDR_DATA3) | ((val<<16) & DSI_GPDR_DATA3); }
inline void dsi_gpdr_set_data2(struct DSI_Type* p, uint32_t val) { p->GPDR = (p->GPDR & ~DSI_GPDR_DATA2) | ((val<<8) & DSI_GPDR_DATA2); }
inline void dsi_gpdr_set_data1(struct DSI_Type* p, uint32_t val) { p->GPDR = (p->GPDR & ~DSI_GPDR_DATA1) | ((val<<0) & DSI_GPDR_DATA1); }
inline uint32_t dsi_gpdr_get_data4(struct DSI_Type* p) { return (p->GPDR & DSI_GPDR_DATA4) >> 24 ; }
inline uint32_t dsi_gpdr_get_data3(struct DSI_Type* p) { return (p->GPDR & DSI_GPDR_DATA3) >> 16 ; }
inline uint32_t dsi_gpdr_get_data2(struct DSI_Type* p) { return (p->GPDR & DSI_GPDR_DATA2) >> 8 ; }
inline uint32_t dsi_gpdr_get_data1(struct DSI_Type* p) { return (p->GPDR & DSI_GPDR_DATA1) >> 0 ; }

// DSI->GPSR DSI Host Generic Packet Status Register
enum {
	DSI_GPSR_RCB = 1UL<<6, // Read Command Busy
	DSI_GPSR_PRDFF = 1UL<<5, // Payload Read FIFO Full
	DSI_GPSR_PRDFE = 1UL<<4, // Payload Read FIFO Empty
	DSI_GPSR_PWRFF = 1UL<<3, // Payload Write FIFO Full
	DSI_GPSR_PWRFE = 1UL<<2, // Payload Write FIFO Empty
	DSI_GPSR_CMDFF = 1UL<<1, // Command FIFO Full
	DSI_GPSR_CMDFE = 1UL<<0, // Command FIFO Empty		
};

// DSI->TCCR0 DSI Host Timeout Counter Configuration Register 0
enum {
	DSI_TCCR0_HSTX_TOCNT = ((1UL<<16)-1) << 16, // High-Speed Transmission Timeout Counter
	DSI_TCCR0_LPRX_TOCNT = ((1UL<<16)-1) << 0, // Low-power Reception Timeout Counter		
};
inline void dsi_tccr0_set_hstx_tocnt(struct DSI_Type* p, uint32_t val) { p->TCCR0 = (p->TCCR0 & ~DSI_TCCR0_HSTX_TOCNT) | ((val<<16) & DSI_TCCR0_HSTX_TOCNT); }
inline void dsi_tccr0_set_lprx_tocnt(struct DSI_Type* p, uint32_t val) { p->TCCR0 = (p->TCCR0 & ~DSI_TCCR0_LPRX_TOCNT) | ((val<<0) & DSI_TCCR0_LPRX_TOCNT); }
inline uint32_t dsi_tccr0_get_hstx_tocnt(struct DSI_Type* p) { return (p->TCCR0 & DSI_TCCR0_HSTX_TOCNT) >> 16 ; }
inline uint32_t dsi_tccr0_get_lprx_tocnt(struct DSI_Type* p) { return (p->TCCR0 & DSI_TCCR0_LPRX_TOCNT) >> 0 ; }

// DSI->TCCR3 DSI Host Timeout Counter Configuration Register 3
enum {
	DSI_TCCR3_PM = 1UL<<24, // Presp mode
	DSI_TCCR3_HSWR_TOCNT = ((1UL<<16)-1) << 0, // High-Speed Write Timeout Counter		
};
inline void dsi_tccr3_set_hswr_tocnt(struct DSI_Type* p, uint32_t val) { p->TCCR3 = (p->TCCR3 & ~DSI_TCCR3_HSWR_TOCNT) | ((val<<0) & DSI_TCCR3_HSWR_TOCNT); }
inline uint32_t dsi_tccr3_get_hswr_tocnt(struct DSI_Type* p) { return (p->TCCR3 & DSI_TCCR3_HSWR_TOCNT) >> 0 ; }

// DSI->CLCR DSI Host Clock Lane Configuration Register
enum {
	DSI_CLCR_ACR = 1UL<<1, // Automatic Clock lane Control
	DSI_CLCR_DPCC = 1UL<<0, // D-PHY Clock Control		
};

// DSI->CLTCR DSI Host Clock Lane Timer Configuration Register
enum {
	DSI_CLTCR_HS2LP_TIME = ((1UL<<10)-1) << 16, // High-Speed to Low-Power Time
	DSI_CLTCR_LP2HS_TIME = ((1UL<<10)-1) << 0, // Low-Power to High-Speed Time		
};
inline void dsi_cltcr_set_hs2lp_time(struct DSI_Type* p, uint32_t val) { p->CLTCR = (p->CLTCR & ~DSI_CLTCR_HS2LP_TIME) | ((val<<16) & DSI_CLTCR_HS2LP_TIME); }
inline void dsi_cltcr_set_lp2hs_time(struct DSI_Type* p, uint32_t val) { p->CLTCR = (p->CLTCR & ~DSI_CLTCR_LP2HS_TIME) | ((val<<0) & DSI_CLTCR_LP2HS_TIME); }
inline uint32_t dsi_cltcr_get_hs2lp_time(struct DSI_Type* p) { return (p->CLTCR & DSI_CLTCR_HS2LP_TIME) >> 16 ; }
inline uint32_t dsi_cltcr_get_lp2hs_time(struct DSI_Type* p) { return (p->CLTCR & DSI_CLTCR_LP2HS_TIME) >> 0 ; }

// DSI->DLTCR DSI Host Data Lane Timer Configuration Register
enum {
	DSI_DLTCR_HS2LP_TIME = ((1UL<<8)-1) << 24, // High-Speed To Low-Power Time
	DSI_DLTCR_LP2HS_TIME = ((1UL<<8)-1) << 16, // Low-Power To High-Speed Time
	DSI_DLTCR_MRD_TIME = ((1UL<<15)-1) << 0, // Maximum Read Time		
};
inline void dsi_dltcr_set_hs2lp_time(struct DSI_Type* p, uint32_t val) { p->DLTCR = (p->DLTCR & ~DSI_DLTCR_HS2LP_TIME) | ((val<<24) & DSI_DLTCR_HS2LP_TIME); }
inline void dsi_dltcr_set_lp2hs_time(struct DSI_Type* p, uint32_t val) { p->DLTCR = (p->DLTCR & ~DSI_DLTCR_LP2HS_TIME) | ((val<<16) & DSI_DLTCR_LP2HS_TIME); }
inline void dsi_dltcr_set_mrd_time(struct DSI_Type* p, uint32_t val) { p->DLTCR = (p->DLTCR & ~DSI_DLTCR_MRD_TIME) | ((val<<0) & DSI_DLTCR_MRD_TIME); }
inline uint32_t dsi_dltcr_get_hs2lp_time(struct DSI_Type* p) { return (p->DLTCR & DSI_DLTCR_HS2LP_TIME) >> 24 ; }
inline uint32_t dsi_dltcr_get_lp2hs_time(struct DSI_Type* p) { return (p->DLTCR & DSI_DLTCR_LP2HS_TIME) >> 16 ; }
inline uint32_t dsi_dltcr_get_mrd_time(struct DSI_Type* p) { return (p->DLTCR & DSI_DLTCR_MRD_TIME) >> 0 ; }

// DSI->PCTLR DSI Host PHY Control Register
enum {
	DSI_PCTLR_CKE = 1UL<<2, // Clock Enable
	DSI_PCTLR_DEN = 1UL<<1, // Digital Enable		
};

// DSI->PCONFR DSI Host PHY Configuration Register
enum {
	DSI_PCONFR_SW_TIME = ((1UL<<8)-1) << 8, // Stop Wait Time
	DSI_PCONFR_NL = ((1UL<<2)-1) << 0, // Number of Lanes		
};
inline void dsi_pconfr_set_sw_time(struct DSI_Type* p, uint32_t val) { p->PCONFR = (p->PCONFR & ~DSI_PCONFR_SW_TIME) | ((val<<8) & DSI_PCONFR_SW_TIME); }
inline void dsi_pconfr_set_nl(struct DSI_Type* p, uint32_t val) { p->PCONFR = (p->PCONFR & ~DSI_PCONFR_NL) | ((val<<0) & DSI_PCONFR_NL); }
inline uint32_t dsi_pconfr_get_sw_time(struct DSI_Type* p) { return (p->PCONFR & DSI_PCONFR_SW_TIME) >> 8 ; }
inline uint32_t dsi_pconfr_get_nl(struct DSI_Type* p) { return (p->PCONFR & DSI_PCONFR_NL) >> 0 ; }

// DSI->PUCR DSI Host PHY ULPS Control Register
enum {
	DSI_PUCR_UEDL = 1UL<<3, // ULPS Exit on Data Lane
	DSI_PUCR_URDL = 1UL<<2, // ULPS Request on Data Lane
	DSI_PUCR_UECL = 1UL<<1, // ULPS Exit on Clock Lane
	DSI_PUCR_URCL = 1UL<<0, // ULPS Request on Clock Lane		
};

// DSI->PTTCR DSI Host PHY TX Triggers Configuration Register
enum {
	DSI_PTTCR_TX_TRIG = ((1UL<<4)-1) << 0, // Transmission Trigger		
};
inline void dsi_pttcr_set_tx_trig(struct DSI_Type* p, uint32_t val) { p->PTTCR = (p->PTTCR & ~DSI_PTTCR_TX_TRIG) | ((val<<0) & DSI_PTTCR_TX_TRIG); }
inline uint32_t dsi_pttcr_get_tx_trig(struct DSI_Type* p) { return (p->PTTCR & DSI_PTTCR_TX_TRIG) >> 0 ; }

// DSI->PSR DSI Host PHY Status Register
enum {
	DSI_PSR_UAN1 = 1UL<<8, // ULPS Active Not lane 1
	DSI_PSR_PSS1 = 1UL<<7, // PHY Stop State lane 1
	DSI_PSR_RUE0 = 1UL<<6, // RX ULPS Escape lane 0
	DSI_PSR_UAN0 = 1UL<<5, // ULPS Active Not lane 1
	DSI_PSR_PSS0 = 1UL<<4, // PHY Stop State lane 0
	DSI_PSR_UANC = 1UL<<3, // ULPS Active Not Clock lane
	DSI_PSR_PSSC = 1UL<<2, // PHY Stop State Clock lane
	DSI_PSR_PD = 1UL<<1, // PHY Direction		
};

// DSI->ISR0 DSI Host Interrupt & Status Register 0
enum {
	DSI_ISR0_PE4 = 1UL<<20, // PHY Error 4
	DSI_ISR0_PE3 = 1UL<<19, // PHY Error 3
	DSI_ISR0_PE2 = 1UL<<18, // PHY Error 2
	DSI_ISR0_PE1 = 1UL<<17, // PHY Error 1
	DSI_ISR0_PE0 = 1UL<<16, // PHY Error 0
	DSI_ISR0_AE15 = 1UL<<15, // Acknowledge Error 15
	DSI_ISR0_AE14 = 1UL<<14, // Acknowledge Error 14
	DSI_ISR0_AE13 = 1UL<<13, // Acknowledge Error 13
	DSI_ISR0_AE12 = 1UL<<12, // Acknowledge Error 12
	DSI_ISR0_AE11 = 1UL<<11, // Acknowledge Error 11
	DSI_ISR0_AE10 = 1UL<<10, // Acknowledge Error 10
	DSI_ISR0_AE9 = 1UL<<9, // Acknowledge Error 9
	DSI_ISR0_AE8 = 1UL<<8, // Acknowledge Error 8
	DSI_ISR0_AE7 = 1UL<<7, // Acknowledge Error 7
	DSI_ISR0_AE6 = 1UL<<6, // Acknowledge Error 6
	DSI_ISR0_AE5 = 1UL<<5, // Acknowledge Error 5
	DSI_ISR0_AE4 = 1UL<<4, // Acknowledge Error 4
	DSI_ISR0_AE3 = 1UL<<3, // Acknowledge Error 3
	DSI_ISR0_AE2 = 1UL<<2, // Acknowledge Error 2
	DSI_ISR0_AE1 = 1UL<<1, // Acknowledge Error 1
	DSI_ISR0_AE0 = 1UL<<0, // Acknowledge Error 0		
};

// DSI->ISR1 DSI Host Interrupt & Status Register 1
enum {
	DSI_ISR1_GPRXE = 1UL<<12, // Generic Payload Receive Error
	DSI_ISR1_GPRDE = 1UL<<11, // Generic Payload Read Error
	DSI_ISR1_GPTXE = 1UL<<10, // Generic Payload Transmit Error
	DSI_ISR1_GPWRE = 1UL<<9, // Generic Payload Write Error
	DSI_ISR1_GCWRE = 1UL<<8, // Generic Command Write Error
	DSI_ISR1_LPWRE = 1UL<<7, // LTDC Payload Write Error
	DSI_ISR1_EOTPE = 1UL<<6, // EoTp Error
	DSI_ISR1_PSE = 1UL<<5, // Packet Size Error
	DSI_ISR1_CRCE = 1UL<<4, // CRC Error
	DSI_ISR1_ECCME = 1UL<<3, // ECC Multi-bit Error
	DSI_ISR1_ECCSE = 1UL<<2, // ECC Single-bit Error
	DSI_ISR1_TOLPRX = 1UL<<1, // Timeout Low-Power Reception
	DSI_ISR1_TOHSTX = 1UL<<0, // Timeout High-Speed Transmission		
};

// DSI->IER0 DSI Host Interrupt Enable Register 0
enum {
	DSI_IER0_PE4IE = 1UL<<20, // PHY Error 4 Interrupt Enable
	DSI_IER0_PE3IE = 1UL<<19, // PHY Error 3 Interrupt Enable
	DSI_IER0_PE2IE = 1UL<<18, // PHY Error 2 Interrupt Enable
	DSI_IER0_PE1IE = 1UL<<17, // PHY Error 1 Interrupt Enable
	DSI_IER0_PE0IE = 1UL<<16, // PHY Error 0 Interrupt Enable
	DSI_IER0_AE15IE = 1UL<<15, // Acknowledge Error 15 Interrupt Enable
	DSI_IER0_AE14IE = 1UL<<14, // Acknowledge Error 14 Interrupt Enable
	DSI_IER0_AE13IE = 1UL<<13, // Acknowledge Error 13 Interrupt Enable
	DSI_IER0_AE12IE = 1UL<<12, // Acknowledge Error 12 Interrupt Enable
	DSI_IER0_AE11IE = 1UL<<11, // Acknowledge Error 11 Interrupt Enable
	DSI_IER0_AE10IE = 1UL<<10, // Acknowledge Error 10 Interrupt Enable
	DSI_IER0_AE9IE = 1UL<<9, // Acknowledge Error 9 Interrupt Enable
	DSI_IER0_AE8IE = 1UL<<8, // Acknowledge Error 8 Interrupt Enable
	DSI_IER0_AE7IE = 1UL<<7, // Acknowledge Error 7 Interrupt Enable
	DSI_IER0_AE6IE = 1UL<<6, // Acknowledge Error 6 Interrupt Enable
	DSI_IER0_AE5IE = 1UL<<5, // Acknowledge Error 5 Interrupt Enable
	DSI_IER0_AE4IE = 1UL<<4, // Acknowledge Error 4 Interrupt Enable
	DSI_IER0_AE3IE = 1UL<<3, // Acknowledge Error 3 Interrupt Enable
	DSI_IER0_AE2IE = 1UL<<2, // Acknowledge Error 2 Interrupt Enable
	DSI_IER0_AE1IE = 1UL<<1, // Acknowledge Error 1 Interrupt Enable
	DSI_IER0_AE0IE = 1UL<<0, // Acknowledge Error 0 Interrupt Enable		
};

// DSI->IER1 DSI Host Interrupt Enable Register 1
enum {
	DSI_IER1_GPRXEIE = 1UL<<12, // Generic Payload Receive Error Interrupt Enable
	DSI_IER1_GPRDEIE = 1UL<<11, // Generic Payload Read Error Interrupt Enable
	DSI_IER1_GPTXEIE = 1UL<<10, // Generic Payload Transmit Error Interrupt Enable
	DSI_IER1_GPWREIE = 1UL<<9, // Generic Payload Write Error Interrupt Enable
	DSI_IER1_GCWREIE = 1UL<<8, // Generic Command Write Error Interrupt Enable
	DSI_IER1_LPWREIE = 1UL<<7, // LTDC Payload Write Error Interrupt Enable
	DSI_IER1_EOTPEIE = 1UL<<6, // EoTp Error Interrupt Enable
	DSI_IER1_PSEIE = 1UL<<5, // Packet Size Error Interrupt Enable
	DSI_IER1_CRCEIE = 1UL<<4, // CRC Error Interrupt Enable
	DSI_IER1_ECCMEIE = 1UL<<3, // ECC Multi-bit Error Interrupt Enable
	DSI_IER1_ECCSEIE = 1UL<<2, // ECC Single-bit Error Interrupt Enable
	DSI_IER1_TOLPRXIE = 1UL<<1, // Timeout Low-Power Reception Interrupt Enable
	DSI_IER1_TOHSTXIE = 1UL<<0, // Timeout High-Speed Transmission Interrupt Enable		
};

// DSI->FIR0 DSI Host Force Interrupt Register 0
enum {
	DSI_FIR0_FPE4 = 1UL<<20, // Force PHY Error 4
	DSI_FIR0_FPE3 = 1UL<<19, // Force PHY Error 3
	DSI_FIR0_FPE2 = 1UL<<18, // Force PHY Error 2
	DSI_FIR0_FPE1 = 1UL<<17, // Force PHY Error 1
	DSI_FIR0_FPE0 = 1UL<<16, // Force PHY Error 0
	DSI_FIR0_FAE15 = 1UL<<15, // Force Acknowledge Error 15
	DSI_FIR0_FAE14 = 1UL<<14, // Force Acknowledge Error 14
	DSI_FIR0_FAE13 = 1UL<<13, // Force Acknowledge Error 13
	DSI_FIR0_FAE12 = 1UL<<12, // Force Acknowledge Error 12
	DSI_FIR0_FAE11 = 1UL<<11, // Force Acknowledge Error 11
	DSI_FIR0_FAE10 = 1UL<<10, // Force Acknowledge Error 10
	DSI_FIR0_FAE9 = 1UL<<9, // Force Acknowledge Error 9
	DSI_FIR0_FAE8 = 1UL<<8, // Force Acknowledge Error 8
	DSI_FIR0_FAE7 = 1UL<<7, // Force Acknowledge Error 7
	DSI_FIR0_FAE6 = 1UL<<6, // Force Acknowledge Error 6
	DSI_FIR0_FAE5 = 1UL<<5, // Force Acknowledge Error 5
	DSI_FIR0_FAE4 = 1UL<<4, // Force Acknowledge Error 4
	DSI_FIR0_FAE3 = 1UL<<3, // Force Acknowledge Error 3
	DSI_FIR0_FAE2 = 1UL<<2, // Force Acknowledge Error 2
	DSI_FIR0_FAE1 = 1UL<<1, // Force Acknowledge Error 1
	DSI_FIR0_FAE0 = 1UL<<0, // Force Acknowledge Error 0		
};

// DSI->FIR1 DSI Host Force Interrupt Register 1
enum {
	DSI_FIR1_FGPRXE = 1UL<<12, // Force Generic Payload Receive Error
	DSI_FIR1_FGPRDE = 1UL<<11, // Force Generic Payload Read Error
	DSI_FIR1_FGPTXE = 1UL<<10, // Force Generic Payload Transmit Error
	DSI_FIR1_FGPWRE = 1UL<<9, // Force Generic Payload Write Error
	DSI_FIR1_FGCWRE = 1UL<<8, // Force Generic Command Write Error
	DSI_FIR1_FLPWRE = 1UL<<7, // Force LTDC Payload Write Error
	DSI_FIR1_FEOTPE = 1UL<<6, // Force EoTp Error
	DSI_FIR1_FPSE = 1UL<<5, // Force Packet Size Error
	DSI_FIR1_FCRCE = 1UL<<4, // Force CRC Error
	DSI_FIR1_FECCME = 1UL<<3, // Force ECC Multi-bit Error
	DSI_FIR1_FECCSE = 1UL<<2, // Force ECC Single-bit Error
	DSI_FIR1_FTOLPRX = 1UL<<1, // Force Timeout Low-Power Reception
	DSI_FIR1_FTOHSTX = 1UL<<0, // Force Timeout High-Speed Transmission		
};

// DSI->VSCR DSI Host Video Shadow Control Register
enum {
	DSI_VSCR_UR = 1UL<<8, // Update Register
	DSI_VSCR_EN = 1UL<<0, // Enable		
};

// DSI->LCVCIDR DSI Host LTDC Current VCID Register
enum {
	DSI_LCVCIDR_VCID = ((1UL<<2)-1) << 0, // Virtual Channel ID		
};
inline uint32_t dsi_lcvcidr_get_vcid(struct DSI_Type* p) { return (p->LCVCIDR & DSI_LCVCIDR_VCID) >> 0 ; }

// DSI->LCCCR DSI Host LTDC Current Color Coding Register
enum {
	DSI_LCCCR_LPE = 1UL<<8, // Loosely Packed Enable
	DSI_LCCCR_COLC = ((1UL<<4)-1) << 0, // Color Coding		
};
inline uint32_t dsi_lcccr_get_colc(struct DSI_Type* p) { return (p->LCCCR & DSI_LCCCR_COLC) >> 0 ; }

// DSI->LPMCCR DSI Host Low-Power mode Current Configuration Register
enum {
	DSI_LPMCCR_LPSIZE = ((1UL<<8)-1) << 16, // Largest Packet Size
	DSI_LPMCCR_VLPSIZE = ((1UL<<8)-1) << 0, // VACT Largest Packet Size		
};
inline uint32_t dsi_lpmccr_get_lpsize(struct DSI_Type* p) { return (p->LPMCCR & DSI_LPMCCR_LPSIZE) >> 16 ; }
inline uint32_t dsi_lpmccr_get_vlpsize(struct DSI_Type* p) { return (p->LPMCCR & DSI_LPMCCR_VLPSIZE) >> 0 ; }

// DSI->VMCCR DSI Host Video mode Current Configuration Register
enum {
	DSI_VMCCR_LPCE = 1UL<<9, // Low-Power Command Enable
	DSI_VMCCR_FBTAAE = 1UL<<8, // Frame BTA Acknowledge Enable
	DSI_VMCCR_LPHFE = 1UL<<7, // Low-Power Horizontal Front-Porch Enable
	DSI_VMCCR_LPHBPE = 1UL<<6, // Low-power Horizontal Back-Porch Enable
	DSI_VMCCR_LPVAE = 1UL<<5, // Low-Power Vertical Active Enable
	DSI_VMCCR_LPVFPE = 1UL<<4, // Low-power Vertical Front-Porch Enable
	DSI_VMCCR_LPVBPE = 1UL<<3, // Low-power Vertical Back-Porch Enable
	DSI_VMCCR_LPVSAE = 1UL<<2, // Low-Power Vertical Sync time Enable
	DSI_VMCCR_VMT = ((1UL<<2)-1) << 0, // Video mode Type		
};
inline uint32_t dsi_vmccr_get_vmt(struct DSI_Type* p) { return (p->VMCCR & DSI_VMCCR_VMT) >> 0 ; }

// DSI->VPCCR DSI Host Video Packet Current Configuration Register
enum {
	DSI_VPCCR_VPSIZE = ((1UL<<14)-1) << 0, // Video Packet Size		
};
inline uint32_t dsi_vpccr_get_vpsize(struct DSI_Type* p) { return (p->VPCCR & DSI_VPCCR_VPSIZE) >> 0 ; }

// DSI->VCCCR DSI Host Video Chunks Current Configuration Register
enum {
	DSI_VCCCR_NUMC = ((1UL<<13)-1) << 0, // Number of Chunks		
};
inline uint32_t dsi_vcccr_get_numc(struct DSI_Type* p) { return (p->VCCCR & DSI_VCCCR_NUMC) >> 0 ; }

// DSI->VNPCCR DSI Host Video Null Packet Current Configuration Register
enum {
	DSI_VNPCCR_NPSIZE = ((1UL<<13)-1) << 0, // Null Packet Size		
};
inline uint32_t dsi_vnpccr_get_npsize(struct DSI_Type* p) { return (p->VNPCCR & DSI_VNPCCR_NPSIZE) >> 0 ; }

// DSI->VHSACCR DSI Host Video HSA Current Configuration Register
enum {
	DSI_VHSACCR_HSA = ((1UL<<12)-1) << 0, // Horizontal Synchronism Active duration		
};
inline uint32_t dsi_vhsaccr_get_hsa(struct DSI_Type* p) { return (p->VHSACCR & DSI_VHSACCR_HSA) >> 0 ; }

// DSI->VHBPCCR DSI Host Video HBP Current Configuration Register
enum {
	DSI_VHBPCCR_HBP = ((1UL<<12)-1) << 0, // Horizontal Back-Porch duration		
};
inline uint32_t dsi_vhbpccr_get_hbp(struct DSI_Type* p) { return (p->VHBPCCR & DSI_VHBPCCR_HBP) >> 0 ; }

// DSI->VLCCR DSI Host Video Line Current Configuration Register
enum {
	DSI_VLCCR_HLINE = ((1UL<<15)-1) << 0, // Horizontal Line duration		
};
inline uint32_t dsi_vlccr_get_hline(struct DSI_Type* p) { return (p->VLCCR & DSI_VLCCR_HLINE) >> 0 ; }

// DSI->VVSACCR DSI Host Video VSA Current Configuration Register
enum {
	DSI_VVSACCR_VSA = ((1UL<<10)-1) << 0, // Vertical Synchronism Active duration		
};
inline uint32_t dsi_vvsaccr_get_vsa(struct DSI_Type* p) { return (p->VVSACCR & DSI_VVSACCR_VSA) >> 0 ; }

// DSI->VVBPCCR DSI Host Video VBP Current Configuration Register
enum {
	DSI_VVBPCCR_VBP = ((1UL<<10)-1) << 0, // Vertical Back-Porch duration		
};
inline uint32_t dsi_vvbpccr_get_vbp(struct DSI_Type* p) { return (p->VVBPCCR & DSI_VVBPCCR_VBP) >> 0 ; }

// DSI->VVFPCCR DSI Host Video VFP Current Configuration Register
enum {
	DSI_VVFPCCR_VFP = ((1UL<<10)-1) << 0, // Vertical Front-Porch duration		
};
inline uint32_t dsi_vvfpccr_get_vfp(struct DSI_Type* p) { return (p->VVFPCCR & DSI_VVFPCCR_VFP) >> 0 ; }

// DSI->VVACCR DSI Host Video VA Current Configuration Register
enum {
	DSI_VVACCR_VA = ((1UL<<14)-1) << 0, // Vertical Active duration		
};
inline uint32_t dsi_vvaccr_get_va(struct DSI_Type* p) { return (p->VVACCR & DSI_VVACCR_VA) >> 0 ; }

// DSI->WCFGR DSI Wrapper Configuration Register
enum {
	DSI_WCFGR_VSPOL = 1UL<<7, // VSync Polarity
	DSI_WCFGR_AR = 1UL<<6, // Automatic Refresh
	DSI_WCFGR_TEPOL = 1UL<<5, // TE Polarity
	DSI_WCFGR_TESRC = 1UL<<4, // TE Source
	DSI_WCFGR_COLMUX = ((1UL<<3)-1) << 1, // Color Multiplexing
	DSI_WCFGR_DSIM = 1UL<<0, // DSI Mode		
};
inline void dsi_wcfgr_set_colmux(struct DSI_Type* p, uint32_t val) { p->WCFGR = (p->WCFGR & ~DSI_WCFGR_COLMUX) | ((val<<1) & DSI_WCFGR_COLMUX); }
inline uint32_t dsi_wcfgr_get_colmux(struct DSI_Type* p) { return (p->WCFGR & DSI_WCFGR_COLMUX) >> 1 ; }

// DSI->WCR DSI Wrapper Control Register
enum {
	DSI_WCR_DSIEN = 1UL<<3, // DSI Enable
	DSI_WCR_LTDCEN = 1UL<<2, // LTDC Enable
	DSI_WCR_SHTDN = 1UL<<1, // Shutdown
	DSI_WCR_COLM = 1UL<<0, // Color Mode		
};

// DSI->WIER DSI Wrapper Interrupt Enable Register
enum {
	DSI_WIER_RRIE = 1UL<<13, // Regulator Ready Interrupt Enable
	DSI_WIER_PLLUIE = 1UL<<10, // PLL Unlock Interrupt Enable
	DSI_WIER_PLLLIE = 1UL<<9, // PLL Lock Interrupt Enable
	DSI_WIER_ERIE = 1UL<<1, // End of Refresh Interrupt Enable
	DSI_WIER_TEIE = 1UL<<0, // Tearing Effect Interrupt Enable		
};

// DSI->WISR DSI Wrapper Interrupt & Status Register
enum {
	DSI_WISR_RRIF = 1UL<<13, // Regulator Ready Interrupt Flag
	DSI_WISR_RRS = 1UL<<12, // Regulator Ready Status
	DSI_WISR_PLLUIF = 1UL<<10, // PLL Unlock Interrupt Flag
	DSI_WISR_PLLLIF = 1UL<<9, // PLL Lock Interrupt Flag
	DSI_WISR_PLLLS = 1UL<<8, // PLL Lock Status
	DSI_WISR_BUSY = 1UL<<2, // Busy Flag
	DSI_WISR_ERIF = 1UL<<1, // End of Refresh Interrupt Flag
	DSI_WISR_TEIF = 1UL<<0, // Tearing Effect Interrupt Flag		
};

// DSI->WIFCR DSI Wrapper Interrupt Flag Clear Register
enum {
	DSI_WIFCR_CRRIF = 1UL<<13, // Clear Regulator Ready Interrupt Flag
	DSI_WIFCR_CPLLUIF = 1UL<<10, // Clear PLL Unlock Interrupt Flag
	DSI_WIFCR_CPLLLIF = 1UL<<9, // Clear PLL Lock Interrupt Flag
	DSI_WIFCR_CERIF = 1UL<<1, // Clear End of Refresh Interrupt Flag
	DSI_WIFCR_CTEIF = 1UL<<0, // Clear Tearing Effect Interrupt Flag		
};

// DSI->WPCR1 DSI Wrapper PHY Configuration Register 1
enum {
	DSI_WPCR1_TCLKPOSTEN = 1UL<<27, // custom time for tCLK-POST Enable
	DSI_WPCR1_TLPXCEN = 1UL<<26, // custom time for tLPX for Clock lane Enable
	DSI_WPCR1_THSEXITEN = 1UL<<25, // custom time for tHS-EXIT Enable
	DSI_WPCR1_TLPXDEN = 1UL<<24, // custom time for tLPX for Data lanes Enable
	DSI_WPCR1_THSZEROEN = 1UL<<23, // custom time for tHS-ZERO Enable
	DSI_WPCR1_THSTRAILEN = 1UL<<22, // custom time for tHS-TRAIL Enable
	DSI_WPCR1_THSPREPEN = 1UL<<21, // custom time for tHS-PREPARE Enable
	DSI_WPCR1_TCLKZEROEN = 1UL<<20, // custom time for tCLK-ZERO Enable
	DSI_WPCR1_TCLKPREPEN = 1UL<<19, // custom time for tCLK-PREPARE Enable
	DSI_WPCR1_PDEN = 1UL<<18, // Pull-Down Enable
	DSI_WPCR1_TDDL = 1UL<<16, // Turn Disable Data Lanes
	DSI_WPCR1_CDOFFDL = 1UL<<14, // Contention Detection OFF on Data Lanes
	DSI_WPCR1_FTXSMDL = 1UL<<13, // Force in TX Stop Mode the Data Lanes
	DSI_WPCR1_FTXSMCL = 1UL<<12, // Force in TX Stop Mode the Clock Lane
	DSI_WPCR1_HSIDL1 = 1UL<<11, // Invert the High-Speed data signal on Data Lane 1
	DSI_WPCR1_HSIDL0 = 1UL<<10, // Invert the Hight-Speed data signal on Data Lane 0
	DSI_WPCR1_HSICL = 1UL<<9, // Invert Hight-Speed data signal on Clock Lane
	DSI_WPCR1_SWDL1 = 1UL<<8, // Swap Data Lane 1 pins
	DSI_WPCR1_SWDL0 = 1UL<<7, // Swap Data Lane 0 pins
	DSI_WPCR1_SWCL = 1UL<<6, // Swap Clock Lane pins
	DSI_WPCR1_UIX4 = ((1UL<<6)-1) << 0, // Unit Interval multiplied by 4		
};
inline void dsi_wpcr1_set_uix4(struct DSI_Type* p, uint32_t val) { p->WPCR1 = (p->WPCR1 & ~DSI_WPCR1_UIX4) | ((val<<0) & DSI_WPCR1_UIX4); }
inline uint32_t dsi_wpcr1_get_uix4(struct DSI_Type* p) { return (p->WPCR1 & DSI_WPCR1_UIX4) >> 0 ; }

// DSI->WPCR2 DSI Wrapper PHY Configuration Register 2
enum {
	DSI_WPCR2_LPRXFT = ((1UL<<2)-1) << 25, // Low-Power RX low-pass Filtering Tuning
	DSI_WPCR2_FLPRXLPM = 1UL<<22, // Forces LP Receiver in Low-Power Mode
	DSI_WPCR2_HSTXSRCDL = ((1UL<<2)-1) << 18, // High-Speed Transmission Slew Rate Control on Data Lanes
	DSI_WPCR2_HSTXSRCCL = ((1UL<<2)-1) << 16, // High-Speed Transmission Slew Rate Control on Clock Lane
	DSI_WPCR2_SDCC = 1UL<<12, // SDD Control
	DSI_WPCR2_LPSRDL = ((1UL<<2)-1) << 8, // Low-Power transmission Slew Rate Compensation on Data Lanes
	DSI_WPCR2_LPSRCL = ((1UL<<2)-1) << 6, // Low-Power transmission Slew Rate Compensation on Clock Lane
	DSI_WPCR2_HSTXDLL = ((1UL<<2)-1) << 2, // High-Speed Transmission Delay on Data Lanes
	DSI_WPCR2_HSTXDCL = ((1UL<<2)-1) << 0, // High-Speed Transmission Delay on Clock Lane		
};
inline void dsi_wpcr2_set_lprxft(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_LPRXFT) | ((val<<25) & DSI_WPCR2_LPRXFT); }
inline void dsi_wpcr2_set_hstxsrcdl(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_HSTXSRCDL) | ((val<<18) & DSI_WPCR2_HSTXSRCDL); }
inline void dsi_wpcr2_set_hstxsrccl(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_HSTXSRCCL) | ((val<<16) & DSI_WPCR2_HSTXSRCCL); }
inline void dsi_wpcr2_set_lpsrdl(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_LPSRDL) | ((val<<8) & DSI_WPCR2_LPSRDL); }
inline void dsi_wpcr2_set_lpsrcl(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_LPSRCL) | ((val<<6) & DSI_WPCR2_LPSRCL); }
inline void dsi_wpcr2_set_hstxdll(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_HSTXDLL) | ((val<<2) & DSI_WPCR2_HSTXDLL); }
inline void dsi_wpcr2_set_hstxdcl(struct DSI_Type* p, uint32_t val) { p->WPCR2 = (p->WPCR2 & ~DSI_WPCR2_HSTXDCL) | ((val<<0) & DSI_WPCR2_HSTXDCL); }
inline uint32_t dsi_wpcr2_get_lprxft(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_LPRXFT) >> 25 ; }
inline uint32_t dsi_wpcr2_get_hstxsrcdl(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_HSTXSRCDL) >> 18 ; }
inline uint32_t dsi_wpcr2_get_hstxsrccl(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_HSTXSRCCL) >> 16 ; }
inline uint32_t dsi_wpcr2_get_lpsrdl(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_LPSRDL) >> 8 ; }
inline uint32_t dsi_wpcr2_get_lpsrcl(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_LPSRCL) >> 6 ; }
inline uint32_t dsi_wpcr2_get_hstxdll(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_HSTXDLL) >> 2 ; }
inline uint32_t dsi_wpcr2_get_hstxdcl(struct DSI_Type* p) { return (p->WPCR2 & DSI_WPCR2_HSTXDCL) >> 0 ; }

// DSI->WPCR3 DSI Wrapper PHY Configuration Register 3
enum {
	DSI_WPCR3_THSTRAIL = ((1UL<<8)-1) << 24, // tHSTRAIL
	DSI_WPCR3_THSPREP = ((1UL<<8)-1) << 16, // tHS-PREPARE
	DSI_WPCR3_TCLKZEO = ((1UL<<8)-1) << 8, // tCLK-ZERO
	DSI_WPCR3_TCLKPREP = ((1UL<<8)-1) << 0, // tCLK-PREPARE		
};
inline void dsi_wpcr3_set_thstrail(struct DSI_Type* p, uint32_t val) { p->WPCR3 = (p->WPCR3 & ~DSI_WPCR3_THSTRAIL) | ((val<<24) & DSI_WPCR3_THSTRAIL); }
inline void dsi_wpcr3_set_thsprep(struct DSI_Type* p, uint32_t val) { p->WPCR3 = (p->WPCR3 & ~DSI_WPCR3_THSPREP) | ((val<<16) & DSI_WPCR3_THSPREP); }
inline void dsi_wpcr3_set_tclkzeo(struct DSI_Type* p, uint32_t val) { p->WPCR3 = (p->WPCR3 & ~DSI_WPCR3_TCLKZEO) | ((val<<8) & DSI_WPCR3_TCLKZEO); }
inline void dsi_wpcr3_set_tclkprep(struct DSI_Type* p, uint32_t val) { p->WPCR3 = (p->WPCR3 & ~DSI_WPCR3_TCLKPREP) | ((val<<0) & DSI_WPCR3_TCLKPREP); }
inline uint32_t dsi_wpcr3_get_thstrail(struct DSI_Type* p) { return (p->WPCR3 & DSI_WPCR3_THSTRAIL) >> 24 ; }
inline uint32_t dsi_wpcr3_get_thsprep(struct DSI_Type* p) { return (p->WPCR3 & DSI_WPCR3_THSPREP) >> 16 ; }
inline uint32_t dsi_wpcr3_get_tclkzeo(struct DSI_Type* p) { return (p->WPCR3 & DSI_WPCR3_TCLKZEO) >> 8 ; }
inline uint32_t dsi_wpcr3_get_tclkprep(struct DSI_Type* p) { return (p->WPCR3 & DSI_WPCR3_TCLKPREP) >> 0 ; }

// DSI->WPCR4 DSI_WPCR4
enum {
	DSI_WPCR4_TLPXC = ((1UL<<8)-1) << 24, // tLPXC for Clock lane
	DSI_WPCR4_THSEXIT = ((1UL<<8)-1) << 16, // tHSEXIT
	DSI_WPCR4_TLPXD = ((1UL<<8)-1) << 8, // tLPX for Data lanes
	DSI_WPCR4_THSZERO = ((1UL<<8)-1) << 0, // tHS-ZERO		
};
inline void dsi_wpcr4_set_tlpxc(struct DSI_Type* p, uint32_t val) { p->WPCR4 = (p->WPCR4 & ~DSI_WPCR4_TLPXC) | ((val<<24) & DSI_WPCR4_TLPXC); }
inline void dsi_wpcr4_set_thsexit(struct DSI_Type* p, uint32_t val) { p->WPCR4 = (p->WPCR4 & ~DSI_WPCR4_THSEXIT) | ((val<<16) & DSI_WPCR4_THSEXIT); }
inline void dsi_wpcr4_set_tlpxd(struct DSI_Type* p, uint32_t val) { p->WPCR4 = (p->WPCR4 & ~DSI_WPCR4_TLPXD) | ((val<<8) & DSI_WPCR4_TLPXD); }
inline void dsi_wpcr4_set_thszero(struct DSI_Type* p, uint32_t val) { p->WPCR4 = (p->WPCR4 & ~DSI_WPCR4_THSZERO) | ((val<<0) & DSI_WPCR4_THSZERO); }
inline uint32_t dsi_wpcr4_get_tlpxc(struct DSI_Type* p) { return (p->WPCR4 & DSI_WPCR4_TLPXC) >> 24 ; }
inline uint32_t dsi_wpcr4_get_thsexit(struct DSI_Type* p) { return (p->WPCR4 & DSI_WPCR4_THSEXIT) >> 16 ; }
inline uint32_t dsi_wpcr4_get_tlpxd(struct DSI_Type* p) { return (p->WPCR4 & DSI_WPCR4_TLPXD) >> 8 ; }
inline uint32_t dsi_wpcr4_get_thszero(struct DSI_Type* p) { return (p->WPCR4 & DSI_WPCR4_THSZERO) >> 0 ; }

// DSI->WRPCR DSI Wrapper Regulator and PLL Control Register
enum {
	DSI_WRPCR_REGEN = 1UL<<24, // Regulator Enable
	DSI_WRPCR_ODF = ((1UL<<2)-1) << 16, // PLL Output Division Factor
	DSI_WRPCR_IDF = ((1UL<<4)-1) << 11, // PLL Input Division Factor
	DSI_WRPCR_NDIV = ((1UL<<7)-1) << 2, // PLL Loop Division Factor
	DSI_WRPCR_PLLEN = 1UL<<0, // PLL Enable		
};
inline void dsi_wrpcr_set_odf(struct DSI_Type* p, uint32_t val) { p->WRPCR = (p->WRPCR & ~DSI_WRPCR_ODF) | ((val<<16) & DSI_WRPCR_ODF); }
inline void dsi_wrpcr_set_idf(struct DSI_Type* p, uint32_t val) { p->WRPCR = (p->WRPCR & ~DSI_WRPCR_IDF) | ((val<<11) & DSI_WRPCR_IDF); }
inline void dsi_wrpcr_set_ndiv(struct DSI_Type* p, uint32_t val) { p->WRPCR = (p->WRPCR & ~DSI_WRPCR_NDIV) | ((val<<2) & DSI_WRPCR_NDIV); }
inline uint32_t dsi_wrpcr_get_odf(struct DSI_Type* p) { return (p->WRPCR & DSI_WRPCR_ODF) >> 16 ; }
inline uint32_t dsi_wrpcr_get_idf(struct DSI_Type* p) { return (p->WRPCR & DSI_WRPCR_IDF) >> 11 ; }
inline uint32_t dsi_wrpcr_get_ndiv(struct DSI_Type* p) { return (p->WRPCR & DSI_WRPCR_NDIV) >> 2 ; }

/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t IMR; // @0 Interrupt mask register (EXTI_IMR)
	__IO uint32_t EMR; // @4 Event mask register (EXTI_EMR)
	__IO uint32_t RTSR; // @8 Rising Trigger selection register (EXTI_RTSR)
	__IO uint32_t FTSR; // @12 Falling Trigger selection register (EXTI_FTSR)
	__IO uint32_t SWIER; // @16 Software interrupt event register (EXTI_SWIER)
	__IO uint32_t PR; // @20 Pending register (EXTI_PR)
};

// EXTI->IMR Interrupt mask register (EXTI_IMR)
enum {
	EXTI_IMR_MRX  = ((1UL<<23)-1) << 0, // Merged Interrupt Mask on line 22		
};
inline void exti_imr_set_mrx (struct EXTI_Type* p, uint32_t val) { p->IMR = (p->IMR & ~EXTI_IMR_MRX ) | ((val<<0) & EXTI_IMR_MRX ); }
inline uint32_t exti_imr_get_mrx (struct EXTI_Type* p) { return (p->IMR & EXTI_IMR_MRX ) >> 0 ; }

// EXTI->EMR Event mask register (EXTI_EMR)
enum {
	EXTI_EMR_MRX  = ((1UL<<23)-1) << 0, // Merged Event Mask on line 22		
};
inline void exti_emr_set_mrx (struct EXTI_Type* p, uint32_t val) { p->EMR = (p->EMR & ~EXTI_EMR_MRX ) | ((val<<0) & EXTI_EMR_MRX ); }
inline uint32_t exti_emr_get_mrx (struct EXTI_Type* p) { return (p->EMR & EXTI_EMR_MRX ) >> 0 ; }

// EXTI->RTSR Rising Trigger selection register (EXTI_RTSR)
enum {
	EXTI_RTSR_TRX  = ((1UL<<23)-1) << 0, // Merged Rising trigger event configuration of line 22		
};
inline void exti_rtsr_set_trx (struct EXTI_Type* p, uint32_t val) { p->RTSR = (p->RTSR & ~EXTI_RTSR_TRX ) | ((val<<0) & EXTI_RTSR_TRX ); }
inline uint32_t exti_rtsr_get_trx (struct EXTI_Type* p) { return (p->RTSR & EXTI_RTSR_TRX ) >> 0 ; }

// EXTI->FTSR Falling Trigger selection register (EXTI_FTSR)
enum {
	EXTI_FTSR_TRX  = ((1UL<<23)-1) << 0, // Merged Falling trigger event configuration of line 22		
};
inline void exti_ftsr_set_trx (struct EXTI_Type* p, uint32_t val) { p->FTSR = (p->FTSR & ~EXTI_FTSR_TRX ) | ((val<<0) & EXTI_FTSR_TRX ); }
inline uint32_t exti_ftsr_get_trx (struct EXTI_Type* p) { return (p->FTSR & EXTI_FTSR_TRX ) >> 0 ; }

// EXTI->SWIER Software interrupt event register (EXTI_SWIER)
enum {
	EXTI_SWIER_SWIERX  = ((1UL<<23)-1) << 0, // Merged Software Interrupt on line 22		
};
inline void exti_swier_set_swierx (struct EXTI_Type* p, uint32_t val) { p->SWIER = (p->SWIER & ~EXTI_SWIER_SWIERX ) | ((val<<0) & EXTI_SWIER_SWIERX ); }
inline uint32_t exti_swier_get_swierx (struct EXTI_Type* p) { return (p->SWIER & EXTI_SWIER_SWIERX ) >> 0 ; }

// EXTI->PR Pending register (EXTI_PR)
enum {
	EXTI_PR_PRX  = ((1UL<<23)-1) << 0, // Merged Pending bit 22		
};
inline void exti_pr_set_prx (struct EXTI_Type* p, uint32_t val) { p->PR = (p->PR & ~EXTI_PR_PRX ) | ((val<<0) & EXTI_PR_PRX ); }
inline uint32_t exti_pr_get_prx (struct EXTI_Type* p) { return (p->PR & EXTI_PR_PRX ) >> 0 ; }

/* Ethernet: DMA controller operation */
struct Ethernet_DMA_Type {
	__IO uint32_t DMABMR; // @0 Ethernet DMA bus mode register
	__IO uint32_t DMATPDR; // @4 Ethernet DMA transmit poll demand register
	__IO uint32_t DMARPDR; // @8 EHERNET DMA receive poll demand register
	__IO uint32_t DMARDLAR; // @12 Ethernet DMA receive descriptor list address register
	__IO uint32_t DMATDLAR; // @16 Ethernet DMA transmit descriptor list address register
	__IO uint32_t DMASR; // @20 Ethernet DMA status register
	__IO uint32_t DMAOMR; // @24 Ethernet DMA operation mode register
	__IO uint32_t DMAIER; // @28 Ethernet DMA interrupt enable register
	__IO uint32_t DMAMFBOCR; // @32 Ethernet DMA missed frame and buffer overflow counter register
	__IO uint8_t DMARSWTR; // @36 Ethernet DMA receive status watchdog timer register
	 uint8_t RESERVED0[35]; // @37 
	__I uint32_t DMACHTDR; // @72 Ethernet DMA current host transmit descriptor register
	__I uint32_t DMACHRDR; // @76 Ethernet DMA current host receive descriptor register
	__I uint32_t DMACHTBAR; // @80 Ethernet DMA current host transmit buffer address register
	__I uint32_t DMACHRBAR; // @84 Ethernet DMA current host receive buffer address register
};

// Ethernet_DMA->DMABMR Ethernet DMA bus mode register
enum {
	ETHERNET_DMA_DMABMR_MB = 1UL<<26, // MB
	ETHERNET_DMA_DMABMR_AAB = 1UL<<25, // AAB
	ETHERNET_DMA_DMABMR_FPM = 1UL<<24, // FPM
	ETHERNET_DMA_DMABMR_USP = 1UL<<23, // USP
	ETHERNET_DMA_DMABMR_RDP = ((1UL<<6)-1) << 17, // RDP
	ETHERNET_DMA_DMABMR_FB = 1UL<<16, // FB
	ETHERNET_DMA_DMABMR_RTPR = ((1UL<<2)-1) << 14, // RTPR
	ETHERNET_DMA_DMABMR_PBL = ((1UL<<6)-1) << 8, // PBL
	ETHERNET_DMA_DMABMR_EDFE = 1UL<<7, // EDFE
	ETHERNET_DMA_DMABMR_DSL = ((1UL<<5)-1) << 2, // DSL
	ETHERNET_DMA_DMABMR_DA = 1UL<<1, // DA
	ETHERNET_DMA_DMABMR_SR = 1UL<<0, // SR		
};
inline void ethernet_dma_dmabmr_set_rdp(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMABMR = (p->DMABMR & ~ETHERNET_DMA_DMABMR_RDP) | ((val<<17) & ETHERNET_DMA_DMABMR_RDP); }
inline void ethernet_dma_dmabmr_set_rtpr(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMABMR = (p->DMABMR & ~ETHERNET_DMA_DMABMR_RTPR) | ((val<<14) & ETHERNET_DMA_DMABMR_RTPR); }
inline void ethernet_dma_dmabmr_set_pbl(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMABMR = (p->DMABMR & ~ETHERNET_DMA_DMABMR_PBL) | ((val<<8) & ETHERNET_DMA_DMABMR_PBL); }
inline void ethernet_dma_dmabmr_set_dsl(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMABMR = (p->DMABMR & ~ETHERNET_DMA_DMABMR_DSL) | ((val<<2) & ETHERNET_DMA_DMABMR_DSL); }
inline uint32_t ethernet_dma_dmabmr_get_rdp(struct Ethernet_DMA_Type* p) { return (p->DMABMR & ETHERNET_DMA_DMABMR_RDP) >> 17 ; }
inline uint32_t ethernet_dma_dmabmr_get_rtpr(struct Ethernet_DMA_Type* p) { return (p->DMABMR & ETHERNET_DMA_DMABMR_RTPR) >> 14 ; }
inline uint32_t ethernet_dma_dmabmr_get_pbl(struct Ethernet_DMA_Type* p) { return (p->DMABMR & ETHERNET_DMA_DMABMR_PBL) >> 8 ; }
inline uint32_t ethernet_dma_dmabmr_get_dsl(struct Ethernet_DMA_Type* p) { return (p->DMABMR & ETHERNET_DMA_DMABMR_DSL) >> 2 ; }

// Ethernet_DMA->DMASR Ethernet DMA status register
enum {
	ETHERNET_DMA_DMASR_TSTS = 1UL<<29, // TSTS
	ETHERNET_DMA_DMASR_PMTS = 1UL<<28, // PMTS
	ETHERNET_DMA_DMASR_MMCS = 1UL<<27, // MMCS
	ETHERNET_DMA_DMASR_EBS = ((1UL<<3)-1) << 23, // EBS
	ETHERNET_DMA_DMASR_TPS = ((1UL<<3)-1) << 20, // TPS
	ETHERNET_DMA_DMASR_RPS = ((1UL<<3)-1) << 17, // RPS
	ETHERNET_DMA_DMASR_NIS = 1UL<<16, // NIS
	ETHERNET_DMA_DMASR_AIS = 1UL<<15, // AIS
	ETHERNET_DMA_DMASR_ERS = 1UL<<14, // ERS
	ETHERNET_DMA_DMASR_FBES = 1UL<<13, // FBES
	ETHERNET_DMA_DMASR_ETS = 1UL<<10, // ETS
	ETHERNET_DMA_DMASR_PWTS = 1UL<<9, // PWTS
	ETHERNET_DMA_DMASR_RPSS = 1UL<<8, // RPSS
	ETHERNET_DMA_DMASR_RBUS = 1UL<<7, // RBUS
	ETHERNET_DMA_DMASR_RS = 1UL<<6, // RS
	ETHERNET_DMA_DMASR_TUS = 1UL<<5, // TUS
	ETHERNET_DMA_DMASR_ROS = 1UL<<4, // ROS
	ETHERNET_DMA_DMASR_TJTS = 1UL<<3, // TJTS
	ETHERNET_DMA_DMASR_TBUS = 1UL<<2, // TBUS
	ETHERNET_DMA_DMASR_TPSS = 1UL<<1, // TPSS
	ETHERNET_DMA_DMASR_TS = 1UL<<0, // TS		
};
inline void ethernet_dma_dmasr_set_ebs(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMASR = (p->DMASR & ~ETHERNET_DMA_DMASR_EBS) | ((val<<23) & ETHERNET_DMA_DMASR_EBS); }
inline void ethernet_dma_dmasr_set_tps(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMASR = (p->DMASR & ~ETHERNET_DMA_DMASR_TPS) | ((val<<20) & ETHERNET_DMA_DMASR_TPS); }
inline void ethernet_dma_dmasr_set_rps(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMASR = (p->DMASR & ~ETHERNET_DMA_DMASR_RPS) | ((val<<17) & ETHERNET_DMA_DMASR_RPS); }
inline uint32_t ethernet_dma_dmasr_get_ebs(struct Ethernet_DMA_Type* p) { return (p->DMASR & ETHERNET_DMA_DMASR_EBS) >> 23 ; }
inline uint32_t ethernet_dma_dmasr_get_tps(struct Ethernet_DMA_Type* p) { return (p->DMASR & ETHERNET_DMA_DMASR_TPS) >> 20 ; }
inline uint32_t ethernet_dma_dmasr_get_rps(struct Ethernet_DMA_Type* p) { return (p->DMASR & ETHERNET_DMA_DMASR_RPS) >> 17 ; }

// Ethernet_DMA->DMAOMR Ethernet DMA operation mode register
enum {
	ETHERNET_DMA_DMAOMR_DTCEFD = 1UL<<26, // DTCEFD
	ETHERNET_DMA_DMAOMR_RSF = 1UL<<25, // RSF
	ETHERNET_DMA_DMAOMR_DFRF = 1UL<<24, // DFRF
	ETHERNET_DMA_DMAOMR_TSF = 1UL<<21, // TSF
	ETHERNET_DMA_DMAOMR_FTF = 1UL<<20, // FTF
	ETHERNET_DMA_DMAOMR_TTC = ((1UL<<3)-1) << 14, // TTC
	ETHERNET_DMA_DMAOMR_ST = 1UL<<13, // ST
	ETHERNET_DMA_DMAOMR_FEF = 1UL<<7, // FEF
	ETHERNET_DMA_DMAOMR_FUGF = 1UL<<6, // FUGF
	ETHERNET_DMA_DMAOMR_RTC = ((1UL<<2)-1) << 3, // RTC
	ETHERNET_DMA_DMAOMR_OSF = 1UL<<2, // OSF
	ETHERNET_DMA_DMAOMR_SR = 1UL<<1, // SR		
};
inline void ethernet_dma_dmaomr_set_ttc(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMAOMR = (p->DMAOMR & ~ETHERNET_DMA_DMAOMR_TTC) | ((val<<14) & ETHERNET_DMA_DMAOMR_TTC); }
inline void ethernet_dma_dmaomr_set_rtc(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMAOMR = (p->DMAOMR & ~ETHERNET_DMA_DMAOMR_RTC) | ((val<<3) & ETHERNET_DMA_DMAOMR_RTC); }
inline uint32_t ethernet_dma_dmaomr_get_ttc(struct Ethernet_DMA_Type* p) { return (p->DMAOMR & ETHERNET_DMA_DMAOMR_TTC) >> 14 ; }
inline uint32_t ethernet_dma_dmaomr_get_rtc(struct Ethernet_DMA_Type* p) { return (p->DMAOMR & ETHERNET_DMA_DMAOMR_RTC) >> 3 ; }

// Ethernet_DMA->DMAIER Ethernet DMA interrupt enable register
enum {
	ETHERNET_DMA_DMAIER_NISE = 1UL<<16, // NISE
	ETHERNET_DMA_DMAIER_AISE = 1UL<<15, // AISE
	ETHERNET_DMA_DMAIER_ERIE = 1UL<<14, // ERIE
	ETHERNET_DMA_DMAIER_FBEIE = 1UL<<13, // FBEIE
	ETHERNET_DMA_DMAIER_ETIE = 1UL<<10, // ETIE
	ETHERNET_DMA_DMAIER_RWTIE = 1UL<<9, // RWTIE
	ETHERNET_DMA_DMAIER_RPSIE = 1UL<<8, // RPSIE
	ETHERNET_DMA_DMAIER_RBUIE = 1UL<<7, // RBUIE
	ETHERNET_DMA_DMAIER_RIE = 1UL<<6, // RIE
	ETHERNET_DMA_DMAIER_TUIE = 1UL<<5, // TUIE
	ETHERNET_DMA_DMAIER_ROIE = 1UL<<4, // ROIE
	ETHERNET_DMA_DMAIER_TJTIE = 1UL<<3, // TJTIE
	ETHERNET_DMA_DMAIER_TBUIE = 1UL<<2, // TBUIE
	ETHERNET_DMA_DMAIER_TPSIE = 1UL<<1, // TPSIE
	ETHERNET_DMA_DMAIER_TIE = 1UL<<0, // TIE		
};

// Ethernet_DMA->DMAMFBOCR Ethernet DMA missed frame and buffer overflow counter register
enum {
	ETHERNET_DMA_DMAMFBOCR_OFOC = 1UL<<28, // OFOC
	ETHERNET_DMA_DMAMFBOCR_MFA = ((1UL<<11)-1) << 17, // MFA
	ETHERNET_DMA_DMAMFBOCR_OMFC = 1UL<<16, // OMFC
	ETHERNET_DMA_DMAMFBOCR_MFC = ((1UL<<16)-1) << 0, // MFC		
};
inline void ethernet_dma_dmamfbocr_set_mfa(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMAMFBOCR = (p->DMAMFBOCR & ~ETHERNET_DMA_DMAMFBOCR_MFA) | ((val<<17) & ETHERNET_DMA_DMAMFBOCR_MFA); }
inline void ethernet_dma_dmamfbocr_set_mfc(struct Ethernet_DMA_Type* p, uint32_t val) { p->DMAMFBOCR = (p->DMAMFBOCR & ~ETHERNET_DMA_DMAMFBOCR_MFC) | ((val<<0) & ETHERNET_DMA_DMAMFBOCR_MFC); }
inline uint32_t ethernet_dma_dmamfbocr_get_mfa(struct Ethernet_DMA_Type* p) { return (p->DMAMFBOCR & ETHERNET_DMA_DMAMFBOCR_MFA) >> 17 ; }
inline uint32_t ethernet_dma_dmamfbocr_get_mfc(struct Ethernet_DMA_Type* p) { return (p->DMAMFBOCR & ETHERNET_DMA_DMAMFBOCR_MFC) >> 0 ; }

/* Ethernet: media access control (MAC) */
struct Ethernet_MAC_Type {
	__IO uint32_t MACCR; // @0 Ethernet MAC configuration register
	__IO uint32_t MACFFR; // @4 Ethernet MAC frame filter register
	__IO uint32_t MACHTHR; // @8 Ethernet MAC hash table high register
	__IO uint32_t MACHTLR; // @12 Ethernet MAC hash table low register
	__IO uint16_t MACMIIAR; // @16 Ethernet MAC MII address register
	 uint8_t RESERVED0[2]; // @18 
	__IO uint16_t MACMIIDR; // @20 Ethernet MAC MII data register
	 uint8_t RESERVED1[2]; // @22 
	__IO uint32_t MACFCR; // @24 Ethernet MAC flow control register
	__IO uint32_t MACVLANTR; // @28 Ethernet MAC VLAN tag register
	 uint8_t RESERVED2[12]; // @32 
	__IO uint32_t MACPMTCSR; // @44 Ethernet MAC PMT control and status register
	 uint8_t RESERVED3[4]; // @48 
	__I uint8_t MACDBGR; // @52 Ethernet MAC debug register
	 uint8_t RESERVED4[3]; // @53 
	__IO uint16_t MACSR; // @56 Ethernet MAC interrupt status register
	 uint8_t RESERVED5[2]; // @58 
	__IO uint16_t MACIMR; // @60 Ethernet MAC interrupt mask register
	 uint8_t RESERVED6[2]; // @62 
	__IO uint32_t MACA0HR; // @64 Ethernet MAC address 0 high register
	__IO uint32_t MACA0LR; // @68 Ethernet MAC address 0 low register
	__IO uint32_t MACA1HR; // @72 Ethernet MAC address 1 high register
	__IO uint32_t MACA1LR; // @76 Ethernet MAC address1 low register
	__IO uint32_t MACA2HR; // @80 Ethernet MAC address 2 high register
	__IO uint32_t MACA2LR; // @84 Ethernet MAC address 2 low register
	__IO uint32_t MACA3HR; // @88 Ethernet MAC address 3 high register
	__IO uint32_t MACA3LR; // @92 Ethernet MAC address 3 low register
	__IO uint32_t MACRWUFFER; // @96 Ethernet MAC remote wakeup frame filter register
};

// Ethernet_MAC->MACCR Ethernet MAC configuration register
enum {
	ETHERNET_MAC_MACCR_CSTF = 1UL<<25, // CSTF
	ETHERNET_MAC_MACCR_WD = 1UL<<23, // WD
	ETHERNET_MAC_MACCR_JD = 1UL<<22, // JD
	ETHERNET_MAC_MACCR_IFG = ((1UL<<3)-1) << 17, // IFG
	ETHERNET_MAC_MACCR_CSD = 1UL<<16, // CSD
	ETHERNET_MAC_MACCR_FES = 1UL<<14, // FES
	ETHERNET_MAC_MACCR_ROD = 1UL<<13, // ROD
	ETHERNET_MAC_MACCR_LM = 1UL<<12, // LM
	ETHERNET_MAC_MACCR_DM = 1UL<<11, // DM
	ETHERNET_MAC_MACCR_IPCO = 1UL<<10, // IPCO
	ETHERNET_MAC_MACCR_RD = 1UL<<9, // RD
	ETHERNET_MAC_MACCR_APCS = 1UL<<7, // APCS
	ETHERNET_MAC_MACCR_BL = ((1UL<<2)-1) << 5, // BL
	ETHERNET_MAC_MACCR_DC = 1UL<<4, // DC
	ETHERNET_MAC_MACCR_TE = 1UL<<3, // TE
	ETHERNET_MAC_MACCR_RE = 1UL<<2, // RE		
};
inline void ethernet_mac_maccr_set_ifg(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACCR = (p->MACCR & ~ETHERNET_MAC_MACCR_IFG) | ((val<<17) & ETHERNET_MAC_MACCR_IFG); }
inline void ethernet_mac_maccr_set_bl(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACCR = (p->MACCR & ~ETHERNET_MAC_MACCR_BL) | ((val<<5) & ETHERNET_MAC_MACCR_BL); }
inline uint32_t ethernet_mac_maccr_get_ifg(struct Ethernet_MAC_Type* p) { return (p->MACCR & ETHERNET_MAC_MACCR_IFG) >> 17 ; }
inline uint32_t ethernet_mac_maccr_get_bl(struct Ethernet_MAC_Type* p) { return (p->MACCR & ETHERNET_MAC_MACCR_BL) >> 5 ; }

// Ethernet_MAC->MACFFR Ethernet MAC frame filter register
enum {
	ETHERNET_MAC_MACFFR_RA = 1UL<<31, // RA
	ETHERNET_MAC_MACFFR_HPF = 1UL<<9, // HPF
	ETHERNET_MAC_MACFFR_SAF = 1UL<<8, // SAF
	ETHERNET_MAC_MACFFR_SAIF = 1UL<<7, // SAIF
	ETHERNET_MAC_MACFFR_PCF = 1UL<<6, // PCF
	ETHERNET_MAC_MACFFR_BFD = 1UL<<5, // BFD
	ETHERNET_MAC_MACFFR_RAM = 1UL<<4, // RAM
	ETHERNET_MAC_MACFFR_DAIF = 1UL<<3, // DAIF
	ETHERNET_MAC_MACFFR_HM = 1UL<<2, // HM
	ETHERNET_MAC_MACFFR_HU = 1UL<<1, // HU
	ETHERNET_MAC_MACFFR_PM = 1UL<<0, // PM		
};

// Ethernet_MAC->MACMIIAR Ethernet MAC MII address register
enum {
	ETHERNET_MAC_MACMIIAR_PA = ((1UL<<5)-1) << 11, // PA
	ETHERNET_MAC_MACMIIAR_MR = ((1UL<<5)-1) << 6, // MR
	ETHERNET_MAC_MACMIIAR_CR = ((1UL<<3)-1) << 2, // CR
	ETHERNET_MAC_MACMIIAR_MW = 1UL<<1, // MW
	ETHERNET_MAC_MACMIIAR_MB = 1UL<<0, // MB		
};
inline void ethernet_mac_macmiiar_set_pa(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMIIAR = (p->MACMIIAR & ~ETHERNET_MAC_MACMIIAR_PA) | ((val<<11) & ETHERNET_MAC_MACMIIAR_PA); }
inline void ethernet_mac_macmiiar_set_mr(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMIIAR = (p->MACMIIAR & ~ETHERNET_MAC_MACMIIAR_MR) | ((val<<6) & ETHERNET_MAC_MACMIIAR_MR); }
inline void ethernet_mac_macmiiar_set_cr(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMIIAR = (p->MACMIIAR & ~ETHERNET_MAC_MACMIIAR_CR) | ((val<<2) & ETHERNET_MAC_MACMIIAR_CR); }
inline uint32_t ethernet_mac_macmiiar_get_pa(struct Ethernet_MAC_Type* p) { return (p->MACMIIAR & ETHERNET_MAC_MACMIIAR_PA) >> 11 ; }
inline uint32_t ethernet_mac_macmiiar_get_mr(struct Ethernet_MAC_Type* p) { return (p->MACMIIAR & ETHERNET_MAC_MACMIIAR_MR) >> 6 ; }
inline uint32_t ethernet_mac_macmiiar_get_cr(struct Ethernet_MAC_Type* p) { return (p->MACMIIAR & ETHERNET_MAC_MACMIIAR_CR) >> 2 ; }

// Ethernet_MAC->MACFCR Ethernet MAC flow control register
enum {
	ETHERNET_MAC_MACFCR_PT = ((1UL<<16)-1) << 16, // PT
	ETHERNET_MAC_MACFCR_ZQPD = 1UL<<7, // ZQPD
	ETHERNET_MAC_MACFCR_PLT = ((1UL<<2)-1) << 4, // PLT
	ETHERNET_MAC_MACFCR_UPFD = 1UL<<3, // UPFD
	ETHERNET_MAC_MACFCR_RFCE = 1UL<<2, // RFCE
	ETHERNET_MAC_MACFCR_TFCE = 1UL<<1, // TFCE
	ETHERNET_MAC_MACFCR_FCB = 1UL<<0, // FCB		
};
inline void ethernet_mac_macfcr_set_pt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACFCR = (p->MACFCR & ~ETHERNET_MAC_MACFCR_PT) | ((val<<16) & ETHERNET_MAC_MACFCR_PT); }
inline void ethernet_mac_macfcr_set_plt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACFCR = (p->MACFCR & ~ETHERNET_MAC_MACFCR_PLT) | ((val<<4) & ETHERNET_MAC_MACFCR_PLT); }
inline uint32_t ethernet_mac_macfcr_get_pt(struct Ethernet_MAC_Type* p) { return (p->MACFCR & ETHERNET_MAC_MACFCR_PT) >> 16 ; }
inline uint32_t ethernet_mac_macfcr_get_plt(struct Ethernet_MAC_Type* p) { return (p->MACFCR & ETHERNET_MAC_MACFCR_PLT) >> 4 ; }

// Ethernet_MAC->MACVLANTR Ethernet MAC VLAN tag register
enum {
	ETHERNET_MAC_MACVLANTR_VLANTC = 1UL<<16, // VLANTC
	ETHERNET_MAC_MACVLANTR_VLANTI = ((1UL<<16)-1) << 0, // VLANTI		
};
inline void ethernet_mac_macvlantr_set_vlanti(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACVLANTR = (p->MACVLANTR & ~ETHERNET_MAC_MACVLANTR_VLANTI) | ((val<<0) & ETHERNET_MAC_MACVLANTR_VLANTI); }
inline uint32_t ethernet_mac_macvlantr_get_vlanti(struct Ethernet_MAC_Type* p) { return (p->MACVLANTR & ETHERNET_MAC_MACVLANTR_VLANTI) >> 0 ; }

// Ethernet_MAC->MACPMTCSR Ethernet MAC PMT control and status register
enum {
	ETHERNET_MAC_MACPMTCSR_WFFRPR = 1UL<<31, // WFFRPR
	ETHERNET_MAC_MACPMTCSR_GU = 1UL<<9, // GU
	ETHERNET_MAC_MACPMTCSR_WFR = 1UL<<6, // WFR
	ETHERNET_MAC_MACPMTCSR_MPR = 1UL<<5, // MPR
	ETHERNET_MAC_MACPMTCSR_WFE = 1UL<<2, // WFE
	ETHERNET_MAC_MACPMTCSR_MPE = 1UL<<1, // MPE
	ETHERNET_MAC_MACPMTCSR_PD = 1UL<<0, // PD		
};

// Ethernet_MAC->MACDBGR Ethernet MAC debug register
enum {
	ETHERNET_MAC_MACDBGR_MCFHP = 1UL<<5, // MCFHP
	ETHERNET_MAC_MACDBGR_MCP = 1UL<<4, // MCP
	ETHERNET_MAC_MACDBGR_MCF = 1UL<<3, // MCF
	ETHERNET_MAC_MACDBGR_ROR = 1UL<<2, // ROR
	ETHERNET_MAC_MACDBGR_CSR = 1UL<<1, // CSR
	ETHERNET_MAC_MACDBGR_CR = 1UL<<0, // CR		
};

// Ethernet_MAC->MACSR Ethernet MAC interrupt status register
enum {
	ETHERNET_MAC_MACSR_TSTS = 1UL<<9, // TSTS
	ETHERNET_MAC_MACSR_MMCTS = 1UL<<6, // MMCTS
	ETHERNET_MAC_MACSR_MMCRS = 1UL<<5, // MMCRS
	ETHERNET_MAC_MACSR_MMCS = 1UL<<4, // MMCS
	ETHERNET_MAC_MACSR_PMTS = 1UL<<3, // PMTS		
};

// Ethernet_MAC->MACIMR Ethernet MAC interrupt mask register
enum {
	ETHERNET_MAC_MACIMR_TSTIM = 1UL<<9, // TSTIM
	ETHERNET_MAC_MACIMR_PMTIM = 1UL<<3, // PMTIM		
};

// Ethernet_MAC->MACA0HR Ethernet MAC address 0 high register
enum {
	ETHERNET_MAC_MACA0HR_MO = 1UL<<31, // Always 1
	ETHERNET_MAC_MACA0HR_MACA0H = ((1UL<<16)-1) << 0, // MAC address0 high		
};
inline void ethernet_mac_maca0hr_set_maca0h(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA0HR = (p->MACA0HR & ~ETHERNET_MAC_MACA0HR_MACA0H) | ((val<<0) & ETHERNET_MAC_MACA0HR_MACA0H); }
inline uint32_t ethernet_mac_maca0hr_get_maca0h(struct Ethernet_MAC_Type* p) { return (p->MACA0HR & ETHERNET_MAC_MACA0HR_MACA0H) >> 0 ; }

// Ethernet_MAC->MACA1HR Ethernet MAC address 1 high register
enum {
	ETHERNET_MAC_MACA1HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA1HR_SA = 1UL<<30, // SA
	ETHERNET_MAC_MACA1HR_MBC = ((1UL<<6)-1) << 24, // MBC
	ETHERNET_MAC_MACA1HR_MACA1H = ((1UL<<16)-1) << 0, // MACA1H		
};
inline void ethernet_mac_maca1hr_set_mbc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA1HR = (p->MACA1HR & ~ETHERNET_MAC_MACA1HR_MBC) | ((val<<24) & ETHERNET_MAC_MACA1HR_MBC); }
inline void ethernet_mac_maca1hr_set_maca1h(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA1HR = (p->MACA1HR & ~ETHERNET_MAC_MACA1HR_MACA1H) | ((val<<0) & ETHERNET_MAC_MACA1HR_MACA1H); }
inline uint32_t ethernet_mac_maca1hr_get_mbc(struct Ethernet_MAC_Type* p) { return (p->MACA1HR & ETHERNET_MAC_MACA1HR_MBC) >> 24 ; }
inline uint32_t ethernet_mac_maca1hr_get_maca1h(struct Ethernet_MAC_Type* p) { return (p->MACA1HR & ETHERNET_MAC_MACA1HR_MACA1H) >> 0 ; }

// Ethernet_MAC->MACA2HR Ethernet MAC address 2 high register
enum {
	ETHERNET_MAC_MACA2HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA2HR_SA = 1UL<<30, // SA
	ETHERNET_MAC_MACA2HR_MBC = ((1UL<<6)-1) << 24, // MBC
	ETHERNET_MAC_MACA2HR_MAC2AH = ((1UL<<16)-1) << 0, // MAC2AH		
};
inline void ethernet_mac_maca2hr_set_mbc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA2HR = (p->MACA2HR & ~ETHERNET_MAC_MACA2HR_MBC) | ((val<<24) & ETHERNET_MAC_MACA2HR_MBC); }
inline void ethernet_mac_maca2hr_set_mac2ah(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA2HR = (p->MACA2HR & ~ETHERNET_MAC_MACA2HR_MAC2AH) | ((val<<0) & ETHERNET_MAC_MACA2HR_MAC2AH); }
inline uint32_t ethernet_mac_maca2hr_get_mbc(struct Ethernet_MAC_Type* p) { return (p->MACA2HR & ETHERNET_MAC_MACA2HR_MBC) >> 24 ; }
inline uint32_t ethernet_mac_maca2hr_get_mac2ah(struct Ethernet_MAC_Type* p) { return (p->MACA2HR & ETHERNET_MAC_MACA2HR_MAC2AH) >> 0 ; }

// Ethernet_MAC->MACA2LR Ethernet MAC address 2 low register
enum {
	ETHERNET_MAC_MACA2LR_MACA2L = ((1UL<<31)-1) << 0, // MACA2L		
};
inline void ethernet_mac_maca2lr_set_maca2l(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA2LR = (p->MACA2LR & ~ETHERNET_MAC_MACA2LR_MACA2L) | ((val<<0) & ETHERNET_MAC_MACA2LR_MACA2L); }
inline uint32_t ethernet_mac_maca2lr_get_maca2l(struct Ethernet_MAC_Type* p) { return (p->MACA2LR & ETHERNET_MAC_MACA2LR_MACA2L) >> 0 ; }

// Ethernet_MAC->MACA3HR Ethernet MAC address 3 high register
enum {
	ETHERNET_MAC_MACA3HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA3HR_SA = 1UL<<30, // SA
	ETHERNET_MAC_MACA3HR_MBC = ((1UL<<6)-1) << 24, // MBC
	ETHERNET_MAC_MACA3HR_MACA3H = ((1UL<<16)-1) << 0, // MACA3H		
};
inline void ethernet_mac_maca3hr_set_mbc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA3HR = (p->MACA3HR & ~ETHERNET_MAC_MACA3HR_MBC) | ((val<<24) & ETHERNET_MAC_MACA3HR_MBC); }
inline void ethernet_mac_maca3hr_set_maca3h(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA3HR = (p->MACA3HR & ~ETHERNET_MAC_MACA3HR_MACA3H) | ((val<<0) & ETHERNET_MAC_MACA3HR_MACA3H); }
inline uint32_t ethernet_mac_maca3hr_get_mbc(struct Ethernet_MAC_Type* p) { return (p->MACA3HR & ETHERNET_MAC_MACA3HR_MBC) >> 24 ; }
inline uint32_t ethernet_mac_maca3hr_get_maca3h(struct Ethernet_MAC_Type* p) { return (p->MACA3HR & ETHERNET_MAC_MACA3HR_MACA3H) >> 0 ; }

/* Ethernet: MAC management counters */
struct Ethernet_MMC_Type {
	__IO uint8_t MMCCR; // @0 Ethernet MMC control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t MMCRIR; // @4 Ethernet MMC receive interrupt register
	__I uint32_t MMCTIR; // @8 Ethernet MMC transmit interrupt register
	__IO uint32_t MMCRIMR; // @12 Ethernet MMC receive interrupt mask register
	__IO uint32_t MMCTIMR; // @16 Ethernet MMC transmit interrupt mask register
	 uint8_t RESERVED1[56]; // @20 
	__I uint32_t MMCTGFSCCR; // @76 Ethernet MMC transmitted good frames after a single collision counter
	__I uint32_t MMCTGFMSCCR; // @80 Ethernet MMC transmitted good frames after more than a single collision
	 uint8_t RESERVED2[20]; // @84 
	__I uint32_t MMCTGFCR; // @104 Ethernet MMC transmitted good frames counter register
	 uint8_t RESERVED3[40]; // @108 
	__I uint32_t MMCRFCECR; // @148 Ethernet MMC received frames with CRC error counter register
	__I uint32_t MMCRFAECR; // @152 Ethernet MMC received frames with alignment error counter register
	 uint8_t RESERVED4[40]; // @156 
	__I uint32_t MMCRGUFCR; // @196 MMC received good unicast frames counter register
};

// Ethernet_MMC->MMCCR Ethernet MMC control register
enum {
	ETHERNET_MMC_MMCCR_MCFHP = 1UL<<5, // MCFHP
	ETHERNET_MMC_MMCCR_MCP = 1UL<<4, // MCP
	ETHERNET_MMC_MMCCR_MCF = 1UL<<3, // MCF
	ETHERNET_MMC_MMCCR_ROR = 1UL<<2, // ROR
	ETHERNET_MMC_MMCCR_CSR = 1UL<<1, // CSR
	ETHERNET_MMC_MMCCR_CR = 1UL<<0, // CR		
};

// Ethernet_MMC->MMCRIR Ethernet MMC receive interrupt register
enum {
	ETHERNET_MMC_MMCRIR_RGUFS = 1UL<<17, // RGUFS
	ETHERNET_MMC_MMCRIR_RFAES = 1UL<<6, // RFAES
	ETHERNET_MMC_MMCRIR_RFCES = 1UL<<5, // RFCES		
};

// Ethernet_MMC->MMCTIR Ethernet MMC transmit interrupt register
enum {
	ETHERNET_MMC_MMCTIR_TGFS = 1UL<<21, // TGFS
	ETHERNET_MMC_MMCTIR_TGFMSCS = 1UL<<15, // TGFMSCS
	ETHERNET_MMC_MMCTIR_TGFSCS = 1UL<<14, // TGFSCS		
};

// Ethernet_MMC->MMCRIMR Ethernet MMC receive interrupt mask register
enum {
	ETHERNET_MMC_MMCRIMR_RGUFM = 1UL<<17, // RGUFM
	ETHERNET_MMC_MMCRIMR_RFAEM = 1UL<<6, // RFAEM
	ETHERNET_MMC_MMCRIMR_RFCEM = 1UL<<5, // RFCEM		
};

// Ethernet_MMC->MMCTIMR Ethernet MMC transmit interrupt mask register
enum {
	ETHERNET_MMC_MMCTIMR_TGFM = 1UL<<16, // TGFM
	ETHERNET_MMC_MMCTIMR_TGFMSCM = 1UL<<15, // TGFMSCM
	ETHERNET_MMC_MMCTIMR_TGFSCM = 1UL<<14, // TGFSCM		
};

/* Ethernet: Precision time protocol */
struct Ethernet_PTP_Type {
	__IO uint32_t PTPTSCR; // @0 Ethernet PTP time stamp control register
	__IO uint8_t PTPSSIR; // @4 Ethernet PTP subsecond increment register
	 uint8_t RESERVED0[3]; // @5 
	__I uint32_t PTPTSHR; // @8 Ethernet PTP time stamp high register
	__I uint32_t PTPTSLR; // @12 Ethernet PTP time stamp low register
	__IO uint32_t PTPTSHUR; // @16 Ethernet PTP time stamp high update register
	__IO uint32_t PTPTSLUR; // @20 Ethernet PTP time stamp low update register
	__IO uint32_t PTPTSAR; // @24 Ethernet PTP time stamp addend register
	__IO uint32_t PTPTTHR; // @28 Ethernet PTP target time high register
	__IO uint32_t PTPTTLR; // @32 Ethernet PTP target time low register
	 uint8_t RESERVED1[4]; // @36 
	__I uint8_t PTPTSSR; // @40 Ethernet PTP time stamp status register
	 uint8_t RESERVED2[3]; // @41 
	__I uint8_t PTPPPSCR; // @44 Ethernet PTP PPS control register
};

// Ethernet_PTP->PTPTSCR Ethernet PTP time stamp control register
enum {
	ETHERNET_PTP_PTPTSCR_TSPFFMAE = 1UL<<18, // TSPFFMAE
	ETHERNET_PTP_PTPTSCR_TSCNT = ((1UL<<2)-1) << 16, // TSCNT
	ETHERNET_PTP_PTPTSCR_TSSMRME = 1UL<<15, // TSSMRME
	ETHERNET_PTP_PTPTSCR_TSSEME = 1UL<<14, // TSSEME
	ETHERNET_PTP_PTPTSCR_TSSIPV4FE = 1UL<<13, // TSSIPV4FE
	ETHERNET_PTP_PTPTSCR_TSSIPV6FE = 1UL<<12, // TSSIPV6FE
	ETHERNET_PTP_PTPTSCR_TSSPTPOEFE = 1UL<<11, // TSSPTPOEFE
	ETHERNET_PTP_PTPTSCR_TSPTPPSV2E = 1UL<<10, // TSPTPPSV2E
	ETHERNET_PTP_PTPTSCR_TSSSR = 1UL<<9, // TSSSR
	ETHERNET_PTP_PTPTSCR_TSSARFE = 1UL<<8, // TSSARFE
	ETHERNET_PTP_PTPTSCR_TTSARU = 1UL<<5, // TTSARU
	ETHERNET_PTP_PTPTSCR_TSITE = 1UL<<4, // TSITE
	ETHERNET_PTP_PTPTSCR_TSSTU = 1UL<<3, // TSSTU
	ETHERNET_PTP_PTPTSCR_TSSTI = 1UL<<2, // TSSTI
	ETHERNET_PTP_PTPTSCR_TSFCU = 1UL<<1, // TSFCU
	ETHERNET_PTP_PTPTSCR_TSE = 1UL<<0, // TSE		
};
inline void ethernet_ptp_ptptscr_set_tscnt(struct Ethernet_PTP_Type* p, uint32_t val) { p->PTPTSCR = (p->PTPTSCR & ~ETHERNET_PTP_PTPTSCR_TSCNT) | ((val<<16) & ETHERNET_PTP_PTPTSCR_TSCNT); }
inline uint32_t ethernet_ptp_ptptscr_get_tscnt(struct Ethernet_PTP_Type* p) { return (p->PTPTSCR & ETHERNET_PTP_PTPTSCR_TSCNT) >> 16 ; }

// Ethernet_PTP->PTPTSLR Ethernet PTP time stamp low register
enum {
	ETHERNET_PTP_PTPTSLR_STPNS = 1UL<<31, // STPNS
	ETHERNET_PTP_PTPTSLR_STSS = ((1UL<<31)-1) << 0, // STSS		
};
inline uint32_t ethernet_ptp_ptptslr_get_stss(struct Ethernet_PTP_Type* p) { return (p->PTPTSLR & ETHERNET_PTP_PTPTSLR_STSS) >> 0 ; }

// Ethernet_PTP->PTPTSLUR Ethernet PTP time stamp low update register
enum {
	ETHERNET_PTP_PTPTSLUR_TSUPNS = 1UL<<31, // TSUPNS
	ETHERNET_PTP_PTPTSLUR_TSUSS = ((1UL<<31)-1) << 0, // TSUSS		
};
inline void ethernet_ptp_ptptslur_set_tsuss(struct Ethernet_PTP_Type* p, uint32_t val) { p->PTPTSLUR = (p->PTPTSLUR & ~ETHERNET_PTP_PTPTSLUR_TSUSS) | ((val<<0) & ETHERNET_PTP_PTPTSLUR_TSUSS); }
inline uint32_t ethernet_ptp_ptptslur_get_tsuss(struct Ethernet_PTP_Type* p) { return (p->PTPTSLUR & ETHERNET_PTP_PTPTSLUR_TSUSS) >> 0 ; }

// Ethernet_PTP->PTPTSSR Ethernet PTP time stamp status register
enum {
	ETHERNET_PTP_PTPTSSR_TSTTR = 1UL<<1, // TSTTR
	ETHERNET_PTP_PTPTSSR_TSSO = 1UL<<0, // TSSO		
};

// Ethernet_PTP->PTPPPSCR Ethernet PTP PPS control register
enum {
	ETHERNET_PTP_PTPPPSCR_TSTTR = 1UL<<1, // TSTTR
	ETHERNET_PTP_PTPPPSCR_TSSO = 1UL<<0, // TSSO		
};

/* FLASH */
struct FLASH_Type {
	__IO uint16_t ACR; // @0 Flash access control register
	 uint8_t RESERVED0[2]; // @2 
	__O uint32_t KEYR; // @4 Flash key register
	__O uint32_t OPTKEYR; // @8 Flash option key register
	__IO uint32_t SR; // @12 Status register
	__IO uint32_t CR; // @16 Control register
	__IO uint32_t OPTCR; // @20 Flash option control register
	__IO uint32_t OPTCR1; // @24 Flash option control register 1
};

// FLASH->ACR Flash access control register
enum {
	FLASH_ACR_ARTRST = 1UL<<11, // ART Accelerator reset
	FLASH_ACR_ARTEN = 1UL<<9, // ART Accelerator Enable
	FLASH_ACR_PRFTEN = 1UL<<8, // Prefetch enable
	FLASH_ACR_LATENCY = ((1UL<<4)-1) << 0, // Latency		
};
inline void flash_acr_set_latency(struct FLASH_Type* p, uint32_t val) { p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val<<0) & FLASH_ACR_LATENCY); }
inline uint32_t flash_acr_get_latency(struct FLASH_Type* p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0 ; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY = 1UL<<16, // Busy
	FLASH_SR_ERSERR = 1UL<<7, // Programming sequence error
	FLASH_SR_PGPERR = 1UL<<6, // Programming parallelism error
	FLASH_SR_PGAERR = 1UL<<5, // Programming alignment error
	FLASH_SR_WRPERR = 1UL<<4, // Write protection error
	FLASH_SR_OPERR = 1UL<<1, // Operation error
	FLASH_SR_EOP = 1UL<<0, // End of operation		
};

// FLASH->CR Control register
enum {
	FLASH_CR_LOCK = 1UL<<31, // Lock
	FLASH_CR_ERRIE = 1UL<<25, // Error interrupt enable
	FLASH_CR_EOPIE = 1UL<<24, // End of operation interrupt enable
	FLASH_CR_STRT = 1UL<<16, // Start
	FLASH_CR_MER2 = 1UL<<15, // Mass Erase of sectors 12 to 23
	FLASH_CR_PSIZE = ((1UL<<2)-1) << 8, // Program size
	FLASH_CR_SNB = ((1UL<<5)-1) << 3, // Sector number
	FLASH_CR_MER1 = 1UL<<2, // Mass Erase of sectors 0 to 11
	FLASH_CR_SER = 1UL<<1, // Sector Erase
	FLASH_CR_PG = 1UL<<0, // Programming		
};
inline void flash_cr_set_psize(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_PSIZE) | ((val<<8) & FLASH_CR_PSIZE); }
inline void flash_cr_set_snb(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_SNB) | ((val<<3) & FLASH_CR_SNB); }
inline uint32_t flash_cr_get_psize(struct FLASH_Type* p) { return (p->CR & FLASH_CR_PSIZE) >> 8 ; }
inline uint32_t flash_cr_get_snb(struct FLASH_Type* p) { return (p->CR & FLASH_CR_SNB) >> 3 ; }

// FLASH->OPTCR Flash option control register
enum {
	FLASH_OPTCR_IWDG_STOP = 1UL<<31, // Independent watchdog counter freeze in Stop mode
	FLASH_OPTCR_IWDG_STDBY = 1UL<<30, // Independent watchdog counter freeze in standby mode
	FLASH_OPTCR_NDBANK = 1UL<<29, // Not dual bank mode
	FLASH_OPTCR_NDBOOT = 1UL<<28, // Dual Boot mode (valid only when nDBANK=0)
	FLASH_OPTCR_NWRP = ((1UL<<12)-1) << 16, // Not write protect
	FLASH_OPTCR_RDP = ((1UL<<8)-1) << 8, // Read protect
	FLASH_OPTCR_NRST_STDBY = 1UL<<7, // User option bytes
	FLASH_OPTCR_NRST_STOP = 1UL<<6, // User option bytes
	FLASH_OPTCR_IWDG_SW = 1UL<<5, // User option bytes
	FLASH_OPTCR_WWDG_SW = 1UL<<4, // User option bytes
	FLASH_OPTCR_BOR_LEV = ((1UL<<2)-1) << 2, // BOR reset Level
	FLASH_OPTCR_OPTSTRT = 1UL<<1, // Option start
	FLASH_OPTCR_OPTLOCK = 1UL<<0, // Option lock		
};
inline void flash_optcr_set_nwrp(struct FLASH_Type* p, uint32_t val) { p->OPTCR = (p->OPTCR & ~FLASH_OPTCR_NWRP) | ((val<<16) & FLASH_OPTCR_NWRP); }
inline void flash_optcr_set_rdp(struct FLASH_Type* p, uint32_t val) { p->OPTCR = (p->OPTCR & ~FLASH_OPTCR_RDP) | ((val<<8) & FLASH_OPTCR_RDP); }
inline void flash_optcr_set_bor_lev(struct FLASH_Type* p, uint32_t val) { p->OPTCR = (p->OPTCR & ~FLASH_OPTCR_BOR_LEV) | ((val<<2) & FLASH_OPTCR_BOR_LEV); }
inline uint32_t flash_optcr_get_nwrp(struct FLASH_Type* p) { return (p->OPTCR & FLASH_OPTCR_NWRP) >> 16 ; }
inline uint32_t flash_optcr_get_rdp(struct FLASH_Type* p) { return (p->OPTCR & FLASH_OPTCR_RDP) >> 8 ; }
inline uint32_t flash_optcr_get_bor_lev(struct FLASH_Type* p) { return (p->OPTCR & FLASH_OPTCR_BOR_LEV) >> 2 ; }

// FLASH->OPTCR1 Flash option control register 1
enum {
	FLASH_OPTCR1_BOOT_ADD1 = ((1UL<<16)-1) << 16, // Boot base address when Boot pin =1
	FLASH_OPTCR1_BOOT_ADD0 = ((1UL<<16)-1) << 0, // Boot base address when Boot pin =0		
};
inline void flash_optcr1_set_boot_add1(struct FLASH_Type* p, uint32_t val) { p->OPTCR1 = (p->OPTCR1 & ~FLASH_OPTCR1_BOOT_ADD1) | ((val<<16) & FLASH_OPTCR1_BOOT_ADD1); }
inline void flash_optcr1_set_boot_add0(struct FLASH_Type* p, uint32_t val) { p->OPTCR1 = (p->OPTCR1 & ~FLASH_OPTCR1_BOOT_ADD0) | ((val<<0) & FLASH_OPTCR1_BOOT_ADD0); }
inline uint32_t flash_optcr1_get_boot_add1(struct FLASH_Type* p) { return (p->OPTCR1 & FLASH_OPTCR1_BOOT_ADD1) >> 16 ; }
inline uint32_t flash_optcr1_get_boot_add0(struct FLASH_Type* p) { return (p->OPTCR1 & FLASH_OPTCR1_BOOT_ADD0) >> 0 ; }

/* Flexible memory controller */
struct FMC_Type {
	__IO uint32_t BCR1; // @0 SRAM/NOR-Flash chip-select control register 1
	__IO uint32_t BTR1; // @4 SRAM/NOR-Flash chip-select timing register 1
	__IO uint32_t BCR2; // @8 SRAM/NOR-Flash chip-select control register 2
	__IO uint32_t BTR2; // @12 SRAM/NOR-Flash chip-select timing register 2
	__IO uint32_t BCR3; // @16 SRAM/NOR-Flash chip-select control register 3
	__IO uint32_t BTR3; // @20 SRAM/NOR-Flash chip-select timing register 3
	__IO uint32_t BCR4; // @24 SRAM/NOR-Flash chip-select control register 4
	__IO uint32_t BTR4; // @28 SRAM/NOR-Flash chip-select timing register 4
	 uint8_t RESERVED0[96]; // @32 
	__IO uint32_t PCR; // @128 PC Card/NAND Flash control register
	__IO uint8_t SR; // @132 FIFO status and interrupt register
	 uint8_t RESERVED1[3]; // @133 
	__IO uint32_t PMEM; // @136 Common memory space timing register
	__IO uint32_t PATT; // @140 Attribute memory space timing register
	 uint8_t RESERVED2[4]; // @144 
	__I uint32_t ECCR; // @148 ECC result register
	 uint8_t RESERVED3[108]; // @152 
	__IO uint32_t BWTR1; // @260 SRAM/NOR-Flash write timing registers 1
	 uint8_t RESERVED4[4]; // @264 
	__IO uint32_t BWTR2; // @268 SRAM/NOR-Flash write timing registers 2
	 uint8_t RESERVED5[4]; // @272 
	__IO uint32_t BWTR3; // @276 SRAM/NOR-Flash write timing registers 3
	 uint8_t RESERVED6[4]; // @280 
	__IO uint32_t BWTR4; // @284 SRAM/NOR-Flash write timing registers 4
	 uint8_t RESERVED7[32]; // @288 
	__IO uint16_t SDCR1; // @320 SDRAM Control Register 1
	 uint8_t RESERVED8[2]; // @322 
	__IO uint16_t SDCR2; // @324 SDRAM Control Register 2
	 uint8_t RESERVED9[2]; // @326 
	__IO uint32_t SDTR1; // @328 SDRAM Timing register 1
	__IO uint32_t SDTR2; // @332 SDRAM Timing register 2
	__IO uint32_t SDCMR; // @336 SDRAM Command Mode register
	__IO uint16_t SDRTR; // @340 SDRAM Refresh Timer register
	 uint8_t RESERVED10[2]; // @342 
	__I uint8_t SDSR; // @344 SDRAM Status register
};

// FMC->BCR1 SRAM/NOR-Flash chip-select control register 1
enum {
	FMC_BCR1_CCLKEN = 1UL<<20, // CCLKEN
	FMC_BCR1_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR1_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR1_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR1_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR1_WREN = 1UL<<12, // WREN
	FMC_BCR1_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR1_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR1_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR1_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR1_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR1_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR1_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR1_MBKEN = 1UL<<0, // MBKEN		
};
inline void fmc_bcr1_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~FMC_BCR1_MWID) | ((val<<4) & FMC_BCR1_MWID); }
inline void fmc_bcr1_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~FMC_BCR1_MTYP) | ((val<<2) & FMC_BCR1_MTYP); }
inline uint32_t fmc_bcr1_get_mwid(struct FMC_Type* p) { return (p->BCR1 & FMC_BCR1_MWID) >> 4 ; }
inline uint32_t fmc_bcr1_get_mtyp(struct FMC_Type* p) { return (p->BCR1 & FMC_BCR1_MTYP) >> 2 ; }

// FMC->BTR1 SRAM/NOR-Flash chip-select timing register 1
enum {
	FMC_BTR1_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR1_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR1_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR1_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR1_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR1_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR1_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_btr1_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_ACCMOD) | ((val<<28) & FMC_BTR1_ACCMOD); }
inline void fmc_btr1_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATLAT) | ((val<<24) & FMC_BTR1_DATLAT); }
inline void fmc_btr1_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_CLKDIV) | ((val<<20) & FMC_BTR1_CLKDIV); }
inline void fmc_btr1_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_BUSTURN) | ((val<<16) & FMC_BTR1_BUSTURN); }
inline void fmc_btr1_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATAST) | ((val<<8) & FMC_BTR1_DATAST); }
inline void fmc_btr1_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_ADDHLD) | ((val<<4) & FMC_BTR1_ADDHLD); }
inline void fmc_btr1_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_ADDSET) | ((val<<0) & FMC_BTR1_ADDSET); }
inline uint32_t fmc_btr1_get_accmod(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr1_get_datlat(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_DATLAT) >> 24 ; }
inline uint32_t fmc_btr1_get_clkdiv(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr1_get_busturn(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr1_get_datast(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_DATAST) >> 8 ; }
inline uint32_t fmc_btr1_get_addhld(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr1_get_addset(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_ADDSET) >> 0 ; }

// FMC->BCR2 SRAM/NOR-Flash chip-select control register 2
enum {
	FMC_BCR2_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR2_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR2_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR2_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR2_WREN = 1UL<<12, // WREN
	FMC_BCR2_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR2_WRAPMOD = 1UL<<10, // WRAPMOD
	FMC_BCR2_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR2_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR2_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR2_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR2_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR2_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR2_MBKEN = 1UL<<0, // MBKEN		
};
inline void fmc_bcr2_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~FMC_BCR2_MWID) | ((val<<4) & FMC_BCR2_MWID); }
inline void fmc_bcr2_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~FMC_BCR2_MTYP) | ((val<<2) & FMC_BCR2_MTYP); }
inline uint32_t fmc_bcr2_get_mwid(struct FMC_Type* p) { return (p->BCR2 & FMC_BCR2_MWID) >> 4 ; }
inline uint32_t fmc_bcr2_get_mtyp(struct FMC_Type* p) { return (p->BCR2 & FMC_BCR2_MTYP) >> 2 ; }

// FMC->BTR2 SRAM/NOR-Flash chip-select timing register 2
enum {
	FMC_BTR2_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR2_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR2_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR2_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR2_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR2_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR2_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_btr2_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_ACCMOD) | ((val<<28) & FMC_BTR2_ACCMOD); }
inline void fmc_btr2_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATLAT) | ((val<<24) & FMC_BTR2_DATLAT); }
inline void fmc_btr2_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_CLKDIV) | ((val<<20) & FMC_BTR2_CLKDIV); }
inline void fmc_btr2_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_BUSTURN) | ((val<<16) & FMC_BTR2_BUSTURN); }
inline void fmc_btr2_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATAST) | ((val<<8) & FMC_BTR2_DATAST); }
inline void fmc_btr2_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_ADDHLD) | ((val<<4) & FMC_BTR2_ADDHLD); }
inline void fmc_btr2_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_ADDSET) | ((val<<0) & FMC_BTR2_ADDSET); }
inline uint32_t fmc_btr2_get_accmod(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr2_get_datlat(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_DATLAT) >> 24 ; }
inline uint32_t fmc_btr2_get_clkdiv(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr2_get_busturn(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr2_get_datast(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_DATAST) >> 8 ; }
inline uint32_t fmc_btr2_get_addhld(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr2_get_addset(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_ADDSET) >> 0 ; }

// FMC->BCR3 SRAM/NOR-Flash chip-select control register 3
enum {
	FMC_BCR3_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR3_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR3_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR3_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR3_WREN = 1UL<<12, // WREN
	FMC_BCR3_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR3_WRAPMOD = 1UL<<10, // WRAPMOD
	FMC_BCR3_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR3_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR3_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR3_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR3_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR3_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR3_MBKEN = 1UL<<0, // MBKEN		
};
inline void fmc_bcr3_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR3 = (p->BCR3 & ~FMC_BCR3_MWID) | ((val<<4) & FMC_BCR3_MWID); }
inline void fmc_bcr3_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR3 = (p->BCR3 & ~FMC_BCR3_MTYP) | ((val<<2) & FMC_BCR3_MTYP); }
inline uint32_t fmc_bcr3_get_mwid(struct FMC_Type* p) { return (p->BCR3 & FMC_BCR3_MWID) >> 4 ; }
inline uint32_t fmc_bcr3_get_mtyp(struct FMC_Type* p) { return (p->BCR3 & FMC_BCR3_MTYP) >> 2 ; }

// FMC->BTR3 SRAM/NOR-Flash chip-select timing register 3
enum {
	FMC_BTR3_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR3_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR3_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR3_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR3_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR3_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR3_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_btr3_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_ACCMOD) | ((val<<28) & FMC_BTR3_ACCMOD); }
inline void fmc_btr3_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATLAT) | ((val<<24) & FMC_BTR3_DATLAT); }
inline void fmc_btr3_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_CLKDIV) | ((val<<20) & FMC_BTR3_CLKDIV); }
inline void fmc_btr3_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_BUSTURN) | ((val<<16) & FMC_BTR3_BUSTURN); }
inline void fmc_btr3_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATAST) | ((val<<8) & FMC_BTR3_DATAST); }
inline void fmc_btr3_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_ADDHLD) | ((val<<4) & FMC_BTR3_ADDHLD); }
inline void fmc_btr3_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_ADDSET) | ((val<<0) & FMC_BTR3_ADDSET); }
inline uint32_t fmc_btr3_get_accmod(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr3_get_datlat(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_DATLAT) >> 24 ; }
inline uint32_t fmc_btr3_get_clkdiv(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr3_get_busturn(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr3_get_datast(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_DATAST) >> 8 ; }
inline uint32_t fmc_btr3_get_addhld(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr3_get_addset(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_ADDSET) >> 0 ; }

// FMC->BCR4 SRAM/NOR-Flash chip-select control register 4
enum {
	FMC_BCR4_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR4_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR4_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR4_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR4_WREN = 1UL<<12, // WREN
	FMC_BCR4_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR4_WRAPMOD = 1UL<<10, // WRAPMOD
	FMC_BCR4_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR4_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR4_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR4_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR4_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR4_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR4_MBKEN = 1UL<<0, // MBKEN		
};
inline void fmc_bcr4_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR4 = (p->BCR4 & ~FMC_BCR4_MWID) | ((val<<4) & FMC_BCR4_MWID); }
inline void fmc_bcr4_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR4 = (p->BCR4 & ~FMC_BCR4_MTYP) | ((val<<2) & FMC_BCR4_MTYP); }
inline uint32_t fmc_bcr4_get_mwid(struct FMC_Type* p) { return (p->BCR4 & FMC_BCR4_MWID) >> 4 ; }
inline uint32_t fmc_bcr4_get_mtyp(struct FMC_Type* p) { return (p->BCR4 & FMC_BCR4_MTYP) >> 2 ; }

// FMC->BTR4 SRAM/NOR-Flash chip-select timing register 4
enum {
	FMC_BTR4_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR4_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR4_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR4_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR4_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR4_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR4_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_btr4_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_ACCMOD) | ((val<<28) & FMC_BTR4_ACCMOD); }
inline void fmc_btr4_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATLAT) | ((val<<24) & FMC_BTR4_DATLAT); }
inline void fmc_btr4_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_CLKDIV) | ((val<<20) & FMC_BTR4_CLKDIV); }
inline void fmc_btr4_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_BUSTURN) | ((val<<16) & FMC_BTR4_BUSTURN); }
inline void fmc_btr4_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATAST) | ((val<<8) & FMC_BTR4_DATAST); }
inline void fmc_btr4_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_ADDHLD) | ((val<<4) & FMC_BTR4_ADDHLD); }
inline void fmc_btr4_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_ADDSET) | ((val<<0) & FMC_BTR4_ADDSET); }
inline uint32_t fmc_btr4_get_accmod(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr4_get_datlat(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_DATLAT) >> 24 ; }
inline uint32_t fmc_btr4_get_clkdiv(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr4_get_busturn(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr4_get_datast(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_DATAST) >> 8 ; }
inline uint32_t fmc_btr4_get_addhld(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr4_get_addset(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_ADDSET) >> 0 ; }

// FMC->PCR PC Card/NAND Flash control register
enum {
	FMC_PCR_ECCPS = ((1UL<<3)-1) << 17, // ECCPS
	FMC_PCR_TAR = ((1UL<<4)-1) << 13, // TAR
	FMC_PCR_TCLR = ((1UL<<4)-1) << 9, // TCLR
	FMC_PCR_ECCEN = 1UL<<6, // ECCEN
	FMC_PCR_PWID = ((1UL<<2)-1) << 4, // PWID
	FMC_PCR_PTYP = 1UL<<3, // PTYP
	FMC_PCR_PBKEN = 1UL<<2, // PBKEN
	FMC_PCR_PWAITEN = 1UL<<1, // PWAITEN		
};
inline void fmc_pcr_set_eccps(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_ECCPS) | ((val<<17) & FMC_PCR_ECCPS); }
inline void fmc_pcr_set_tar(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_TAR) | ((val<<13) & FMC_PCR_TAR); }
inline void fmc_pcr_set_tclr(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_TCLR) | ((val<<9) & FMC_PCR_TCLR); }
inline void fmc_pcr_set_pwid(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_PWID) | ((val<<4) & FMC_PCR_PWID); }
inline uint32_t fmc_pcr_get_eccps(struct FMC_Type* p) { return (p->PCR & FMC_PCR_ECCPS) >> 17 ; }
inline uint32_t fmc_pcr_get_tar(struct FMC_Type* p) { return (p->PCR & FMC_PCR_TAR) >> 13 ; }
inline uint32_t fmc_pcr_get_tclr(struct FMC_Type* p) { return (p->PCR & FMC_PCR_TCLR) >> 9 ; }
inline uint32_t fmc_pcr_get_pwid(struct FMC_Type* p) { return (p->PCR & FMC_PCR_PWID) >> 4 ; }

// FMC->SR FIFO status and interrupt register
enum {
	FMC_SR_FEMPT = 1UL<<6, // FEMPT
	FMC_SR_IFEN = 1UL<<5, // IFEN
	FMC_SR_ILEN = 1UL<<4, // ILEN
	FMC_SR_IREN = 1UL<<3, // IREN
	FMC_SR_IFS = 1UL<<2, // IFS
	FMC_SR_ILS = 1UL<<1, // ILS
	FMC_SR_IRS = 1UL<<0, // IRS		
};

// FMC->PMEM Common memory space timing register
enum {
	FMC_PMEM_MEMHIZX = ((1UL<<8)-1) << 24, // MEMHIZx
	FMC_PMEM_MEMHOLDX = ((1UL<<8)-1) << 16, // MEMHOLDx
	FMC_PMEM_MEMWAITX = ((1UL<<8)-1) << 8, // MEMWAITx
	FMC_PMEM_MEMSETX = ((1UL<<8)-1) << 0, // MEMSETx		
};
inline void fmc_pmem_set_memhizx(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMHIZX) | ((val<<24) & FMC_PMEM_MEMHIZX); }
inline void fmc_pmem_set_memholdx(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMHOLDX) | ((val<<16) & FMC_PMEM_MEMHOLDX); }
inline void fmc_pmem_set_memwaitx(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMWAITX) | ((val<<8) & FMC_PMEM_MEMWAITX); }
inline void fmc_pmem_set_memsetx(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMSETX) | ((val<<0) & FMC_PMEM_MEMSETX); }
inline uint32_t fmc_pmem_get_memhizx(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMHIZX) >> 24 ; }
inline uint32_t fmc_pmem_get_memholdx(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMHOLDX) >> 16 ; }
inline uint32_t fmc_pmem_get_memwaitx(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMWAITX) >> 8 ; }
inline uint32_t fmc_pmem_get_memsetx(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMSETX) >> 0 ; }

// FMC->PATT Attribute memory space timing register
enum {
	FMC_PATT_ATTHIZX = ((1UL<<8)-1) << 24, // ATTHIZx
	FMC_PATT_ATTHOLDX = ((1UL<<8)-1) << 16, // ATTHOLDx
	FMC_PATT_ATTWAITX = ((1UL<<8)-1) << 8, // ATTWAITx
	FMC_PATT_ATTSETX = ((1UL<<8)-1) << 0, // ATTSETx		
};
inline void fmc_patt_set_atthizx(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTHIZX) | ((val<<24) & FMC_PATT_ATTHIZX); }
inline void fmc_patt_set_attholdx(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTHOLDX) | ((val<<16) & FMC_PATT_ATTHOLDX); }
inline void fmc_patt_set_attwaitx(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTWAITX) | ((val<<8) & FMC_PATT_ATTWAITX); }
inline void fmc_patt_set_attsetx(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTSETX) | ((val<<0) & FMC_PATT_ATTSETX); }
inline uint32_t fmc_patt_get_atthizx(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTHIZX) >> 24 ; }
inline uint32_t fmc_patt_get_attholdx(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTHOLDX) >> 16 ; }
inline uint32_t fmc_patt_get_attwaitx(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTWAITX) >> 8 ; }
inline uint32_t fmc_patt_get_attsetx(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTSETX) >> 0 ; }

// FMC->BWTR1 SRAM/NOR-Flash write timing registers 1
enum {
	FMC_BWTR1_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR1_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BWTR1_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BWTR1_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR1_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR1_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_bwtr1_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ACCMOD) | ((val<<28) & FMC_BWTR1_ACCMOD); }
inline void fmc_bwtr1_set_datlat(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_DATLAT) | ((val<<24) & FMC_BWTR1_DATLAT); }
inline void fmc_bwtr1_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_CLKDIV) | ((val<<20) & FMC_BWTR1_CLKDIV); }
inline void fmc_bwtr1_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_DATAST) | ((val<<8) & FMC_BWTR1_DATAST); }
inline void fmc_bwtr1_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ADDHLD) | ((val<<4) & FMC_BWTR1_ADDHLD); }
inline void fmc_bwtr1_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ADDSET) | ((val<<0) & FMC_BWTR1_ADDSET); }
inline uint32_t fmc_bwtr1_get_accmod(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr1_get_datlat(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_DATLAT) >> 24 ; }
inline uint32_t fmc_bwtr1_get_clkdiv(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_CLKDIV) >> 20 ; }
inline uint32_t fmc_bwtr1_get_datast(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr1_get_addhld(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr1_get_addset(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_ADDSET) >> 0 ; }

// FMC->BWTR2 SRAM/NOR-Flash write timing registers 2
enum {
	FMC_BWTR2_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR2_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BWTR2_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BWTR2_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR2_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR2_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_bwtr2_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ACCMOD) | ((val<<28) & FMC_BWTR2_ACCMOD); }
inline void fmc_bwtr2_set_datlat(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_DATLAT) | ((val<<24) & FMC_BWTR2_DATLAT); }
inline void fmc_bwtr2_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_CLKDIV) | ((val<<20) & FMC_BWTR2_CLKDIV); }
inline void fmc_bwtr2_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_DATAST) | ((val<<8) & FMC_BWTR2_DATAST); }
inline void fmc_bwtr2_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ADDHLD) | ((val<<4) & FMC_BWTR2_ADDHLD); }
inline void fmc_bwtr2_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ADDSET) | ((val<<0) & FMC_BWTR2_ADDSET); }
inline uint32_t fmc_bwtr2_get_accmod(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr2_get_datlat(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_DATLAT) >> 24 ; }
inline uint32_t fmc_bwtr2_get_clkdiv(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_CLKDIV) >> 20 ; }
inline uint32_t fmc_bwtr2_get_datast(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr2_get_addhld(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr2_get_addset(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_ADDSET) >> 0 ; }

// FMC->BWTR3 SRAM/NOR-Flash write timing registers 3
enum {
	FMC_BWTR3_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR3_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BWTR3_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BWTR3_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR3_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR3_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_bwtr3_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ACCMOD) | ((val<<28) & FMC_BWTR3_ACCMOD); }
inline void fmc_bwtr3_set_datlat(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_DATLAT) | ((val<<24) & FMC_BWTR3_DATLAT); }
inline void fmc_bwtr3_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_CLKDIV) | ((val<<20) & FMC_BWTR3_CLKDIV); }
inline void fmc_bwtr3_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_DATAST) | ((val<<8) & FMC_BWTR3_DATAST); }
inline void fmc_bwtr3_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ADDHLD) | ((val<<4) & FMC_BWTR3_ADDHLD); }
inline void fmc_bwtr3_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ADDSET) | ((val<<0) & FMC_BWTR3_ADDSET); }
inline uint32_t fmc_bwtr3_get_accmod(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr3_get_datlat(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_DATLAT) >> 24 ; }
inline uint32_t fmc_bwtr3_get_clkdiv(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_CLKDIV) >> 20 ; }
inline uint32_t fmc_bwtr3_get_datast(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr3_get_addhld(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr3_get_addset(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_ADDSET) >> 0 ; }

// FMC->BWTR4 SRAM/NOR-Flash write timing registers 4
enum {
	FMC_BWTR4_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR4_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BWTR4_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BWTR4_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR4_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR4_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
inline void fmc_bwtr4_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ACCMOD) | ((val<<28) & FMC_BWTR4_ACCMOD); }
inline void fmc_bwtr4_set_datlat(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_DATLAT) | ((val<<24) & FMC_BWTR4_DATLAT); }
inline void fmc_bwtr4_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_CLKDIV) | ((val<<20) & FMC_BWTR4_CLKDIV); }
inline void fmc_bwtr4_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_DATAST) | ((val<<8) & FMC_BWTR4_DATAST); }
inline void fmc_bwtr4_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ADDHLD) | ((val<<4) & FMC_BWTR4_ADDHLD); }
inline void fmc_bwtr4_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ADDSET) | ((val<<0) & FMC_BWTR4_ADDSET); }
inline uint32_t fmc_bwtr4_get_accmod(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr4_get_datlat(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_DATLAT) >> 24 ; }
inline uint32_t fmc_bwtr4_get_clkdiv(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_CLKDIV) >> 20 ; }
inline uint32_t fmc_bwtr4_get_datast(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr4_get_addhld(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr4_get_addset(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_ADDSET) >> 0 ; }

// FMC->SDCR1 SDRAM Control Register 1
enum {
	FMC_SDCR1_RPIPE = ((1UL<<2)-1) << 13, // Read pipe
	FMC_SDCR1_RBURST = 1UL<<12, // Burst read
	FMC_SDCR1_SDCLK = ((1UL<<2)-1) << 10, // SDRAM clock configuration
	FMC_SDCR1_WP = 1UL<<9, // Write protection
	FMC_SDCR1_CAS = ((1UL<<2)-1) << 7, // CAS latency
	FMC_SDCR1_NB = 1UL<<6, // Number of internal banks
	FMC_SDCR1_MWID = ((1UL<<2)-1) << 4, // Memory data bus width
	FMC_SDCR1_NR = ((1UL<<2)-1) << 2, // Number of row address bits
	FMC_SDCR1_NC = ((1UL<<2)-1) << 0, // Number of column address bits		
};
inline void fmc_sdcr1_set_rpipe(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_RPIPE) | ((val<<13) & FMC_SDCR1_RPIPE); }
inline void fmc_sdcr1_set_sdclk(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_SDCLK) | ((val<<10) & FMC_SDCR1_SDCLK); }
inline void fmc_sdcr1_set_cas(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_CAS) | ((val<<7) & FMC_SDCR1_CAS); }
inline void fmc_sdcr1_set_mwid(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_MWID) | ((val<<4) & FMC_SDCR1_MWID); }
inline void fmc_sdcr1_set_nr(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_NR) | ((val<<2) & FMC_SDCR1_NR); }
inline void fmc_sdcr1_set_nc(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_NC) | ((val<<0) & FMC_SDCR1_NC); }
inline uint32_t fmc_sdcr1_get_rpipe(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_RPIPE) >> 13 ; }
inline uint32_t fmc_sdcr1_get_sdclk(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_SDCLK) >> 10 ; }
inline uint32_t fmc_sdcr1_get_cas(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_CAS) >> 7 ; }
inline uint32_t fmc_sdcr1_get_mwid(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_MWID) >> 4 ; }
inline uint32_t fmc_sdcr1_get_nr(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_NR) >> 2 ; }
inline uint32_t fmc_sdcr1_get_nc(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_NC) >> 0 ; }

// FMC->SDCR2 SDRAM Control Register 2
enum {
	FMC_SDCR2_RPIPE = ((1UL<<2)-1) << 13, // Read pipe
	FMC_SDCR2_RBURST = 1UL<<12, // Burst read
	FMC_SDCR2_SDCLK = ((1UL<<2)-1) << 10, // SDRAM clock configuration
	FMC_SDCR2_WP = 1UL<<9, // Write protection
	FMC_SDCR2_CAS = ((1UL<<2)-1) << 7, // CAS latency
	FMC_SDCR2_NB = 1UL<<6, // Number of internal banks
	FMC_SDCR2_MWID = ((1UL<<2)-1) << 4, // Memory data bus width
	FMC_SDCR2_NR = ((1UL<<2)-1) << 2, // Number of row address bits
	FMC_SDCR2_NC = ((1UL<<2)-1) << 0, // Number of column address bits		
};
inline void fmc_sdcr2_set_rpipe(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_RPIPE) | ((val<<13) & FMC_SDCR2_RPIPE); }
inline void fmc_sdcr2_set_sdclk(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_SDCLK) | ((val<<10) & FMC_SDCR2_SDCLK); }
inline void fmc_sdcr2_set_cas(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_CAS) | ((val<<7) & FMC_SDCR2_CAS); }
inline void fmc_sdcr2_set_mwid(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_MWID) | ((val<<4) & FMC_SDCR2_MWID); }
inline void fmc_sdcr2_set_nr(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_NR) | ((val<<2) & FMC_SDCR2_NR); }
inline void fmc_sdcr2_set_nc(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_NC) | ((val<<0) & FMC_SDCR2_NC); }
inline uint32_t fmc_sdcr2_get_rpipe(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_RPIPE) >> 13 ; }
inline uint32_t fmc_sdcr2_get_sdclk(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_SDCLK) >> 10 ; }
inline uint32_t fmc_sdcr2_get_cas(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_CAS) >> 7 ; }
inline uint32_t fmc_sdcr2_get_mwid(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_MWID) >> 4 ; }
inline uint32_t fmc_sdcr2_get_nr(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_NR) >> 2 ; }
inline uint32_t fmc_sdcr2_get_nc(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_NC) >> 0 ; }

// FMC->SDTR1 SDRAM Timing register 1
enum {
	FMC_SDTR1_TRCD = ((1UL<<4)-1) << 24, // Row to column delay
	FMC_SDTR1_TRP = ((1UL<<4)-1) << 20, // Row precharge delay
	FMC_SDTR1_TWR = ((1UL<<4)-1) << 16, // Recovery delay
	FMC_SDTR1_TRC = ((1UL<<4)-1) << 12, // Row cycle delay
	FMC_SDTR1_TRAS = ((1UL<<4)-1) << 8, // Self refresh time
	FMC_SDTR1_TXSR = ((1UL<<4)-1) << 4, // Exit self-refresh delay
	FMC_SDTR1_TMRD = ((1UL<<4)-1) << 0, // Load Mode Register to Active		
};
inline void fmc_sdtr1_set_trcd(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRCD) | ((val<<24) & FMC_SDTR1_TRCD); }
inline void fmc_sdtr1_set_trp(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRP) | ((val<<20) & FMC_SDTR1_TRP); }
inline void fmc_sdtr1_set_twr(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TWR) | ((val<<16) & FMC_SDTR1_TWR); }
inline void fmc_sdtr1_set_trc(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRC) | ((val<<12) & FMC_SDTR1_TRC); }
inline void fmc_sdtr1_set_tras(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRAS) | ((val<<8) & FMC_SDTR1_TRAS); }
inline void fmc_sdtr1_set_txsr(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TXSR) | ((val<<4) & FMC_SDTR1_TXSR); }
inline void fmc_sdtr1_set_tmrd(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TMRD) | ((val<<0) & FMC_SDTR1_TMRD); }
inline uint32_t fmc_sdtr1_get_trcd(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRCD) >> 24 ; }
inline uint32_t fmc_sdtr1_get_trp(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRP) >> 20 ; }
inline uint32_t fmc_sdtr1_get_twr(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TWR) >> 16 ; }
inline uint32_t fmc_sdtr1_get_trc(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRC) >> 12 ; }
inline uint32_t fmc_sdtr1_get_tras(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRAS) >> 8 ; }
inline uint32_t fmc_sdtr1_get_txsr(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TXSR) >> 4 ; }
inline uint32_t fmc_sdtr1_get_tmrd(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TMRD) >> 0 ; }

// FMC->SDTR2 SDRAM Timing register 2
enum {
	FMC_SDTR2_TRCD = ((1UL<<4)-1) << 24, // Row to column delay
	FMC_SDTR2_TRP = ((1UL<<4)-1) << 20, // Row precharge delay
	FMC_SDTR2_TWR = ((1UL<<4)-1) << 16, // Recovery delay
	FMC_SDTR2_TRC = ((1UL<<4)-1) << 12, // Row cycle delay
	FMC_SDTR2_TRAS = ((1UL<<4)-1) << 8, // Self refresh time
	FMC_SDTR2_TXSR = ((1UL<<4)-1) << 4, // Exit self-refresh delay
	FMC_SDTR2_TMRD = ((1UL<<4)-1) << 0, // Load Mode Register to Active		
};
inline void fmc_sdtr2_set_trcd(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRCD) | ((val<<24) & FMC_SDTR2_TRCD); }
inline void fmc_sdtr2_set_trp(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRP) | ((val<<20) & FMC_SDTR2_TRP); }
inline void fmc_sdtr2_set_twr(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TWR) | ((val<<16) & FMC_SDTR2_TWR); }
inline void fmc_sdtr2_set_trc(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRC) | ((val<<12) & FMC_SDTR2_TRC); }
inline void fmc_sdtr2_set_tras(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRAS) | ((val<<8) & FMC_SDTR2_TRAS); }
inline void fmc_sdtr2_set_txsr(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TXSR) | ((val<<4) & FMC_SDTR2_TXSR); }
inline void fmc_sdtr2_set_tmrd(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TMRD) | ((val<<0) & FMC_SDTR2_TMRD); }
inline uint32_t fmc_sdtr2_get_trcd(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRCD) >> 24 ; }
inline uint32_t fmc_sdtr2_get_trp(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRP) >> 20 ; }
inline uint32_t fmc_sdtr2_get_twr(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TWR) >> 16 ; }
inline uint32_t fmc_sdtr2_get_trc(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRC) >> 12 ; }
inline uint32_t fmc_sdtr2_get_tras(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRAS) >> 8 ; }
inline uint32_t fmc_sdtr2_get_txsr(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TXSR) >> 4 ; }
inline uint32_t fmc_sdtr2_get_tmrd(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TMRD) >> 0 ; }

// FMC->SDCMR SDRAM Command Mode register
enum {
	FMC_SDCMR_MRD = ((1UL<<13)-1) << 9, // Mode Register definition
	FMC_SDCMR_NRFS = ((1UL<<4)-1) << 5, // Number of Auto-refresh
	FMC_SDCMR_CTB1 = 1UL<<4, // Command target bank 1
	FMC_SDCMR_CTB2 = 1UL<<3, // Command target bank 2
	FMC_SDCMR_MODE = ((1UL<<3)-1) << 0, // Command mode		
};
inline void fmc_sdcmr_set_mrd(struct FMC_Type* p, uint32_t val) { p->SDCMR = (p->SDCMR & ~FMC_SDCMR_MRD) | ((val<<9) & FMC_SDCMR_MRD); }
inline void fmc_sdcmr_set_nrfs(struct FMC_Type* p, uint32_t val) { p->SDCMR = (p->SDCMR & ~FMC_SDCMR_NRFS) | ((val<<5) & FMC_SDCMR_NRFS); }
inline void fmc_sdcmr_set_mode(struct FMC_Type* p, uint32_t val) { p->SDCMR = (p->SDCMR & ~FMC_SDCMR_MODE) | ((val<<0) & FMC_SDCMR_MODE); }
inline uint32_t fmc_sdcmr_get_mrd(struct FMC_Type* p) { return (p->SDCMR & FMC_SDCMR_MRD) >> 9 ; }
inline uint32_t fmc_sdcmr_get_nrfs(struct FMC_Type* p) { return (p->SDCMR & FMC_SDCMR_NRFS) >> 5 ; }
inline uint32_t fmc_sdcmr_get_mode(struct FMC_Type* p) { return (p->SDCMR & FMC_SDCMR_MODE) >> 0 ; }

// FMC->SDRTR SDRAM Refresh Timer register
enum {
	FMC_SDRTR_REIE = 1UL<<14, // RES Interrupt Enable
	FMC_SDRTR_COUNT = ((1UL<<13)-1) << 1, // Refresh Timer Count
	FMC_SDRTR_CRE = 1UL<<0, // Clear Refresh error flag		
};
inline void fmc_sdrtr_set_count(struct FMC_Type* p, uint32_t val) { p->SDRTR = (p->SDRTR & ~FMC_SDRTR_COUNT) | ((val<<1) & FMC_SDRTR_COUNT); }
inline uint32_t fmc_sdrtr_get_count(struct FMC_Type* p) { return (p->SDRTR & FMC_SDRTR_COUNT) >> 1 ; }

// FMC->SDSR SDRAM Status register
enum {
	FMC_SDSR_BUSY = 1UL<<5, // Busy status
	FMC_SDSR_MODES2 = ((1UL<<2)-1) << 3, // Status Mode for Bank 2
	FMC_SDSR_MODES1 = ((1UL<<2)-1) << 1, // Status Mode for Bank 1
	FMC_SDSR_RE = 1UL<<0, // Refresh error flag		
};
inline uint32_t fmc_sdsr_get_modes2(struct FMC_Type* p) { return (p->SDSR & FMC_SDSR_MODES2) >> 3 ; }
inline uint32_t fmc_sdsr_get_modes1(struct FMC_Type* p) { return (p->SDSR & FMC_SDSR_MODES1) >> 1 ; }

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN = 1UL<<31, // ASPEN
	FPU_FPCCR_LSPEN = 1UL<<30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL<<8, // MONRDY
	FPU_FPCCR_BFRDY = 1UL<<6, // BFRDY
	FPU_FPCCR_MMRDY = 1UL<<5, // MMRDY
	FPU_FPCCR_HFRDY = 1UL<<4, // HFRDY
	FPU_FPCCR_THREAD = 1UL<<3, // THREAD
	FPU_FPCCR_USER = 1UL<<1, // USER
	FPU_FPCCR_LSPACT = 1UL<<0, // LSPACT		
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL<<29)-1) << 3, // Location of unpopulated floating-point		
};
inline void fpu_fpcar_set_address(struct FPU_Type* p, uint32_t val) { p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val<<3) & FPU_FPCAR_ADDRESS); }
inline uint32_t fpu_fpcar_get_address(struct FPU_Type* p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3 ; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N = 1UL<<31, // Negative condition code flag
	FPU_FPSCR_Z = 1UL<<30, // Zero condition code flag
	FPU_FPSCR_C = 1UL<<29, // Carry condition code flag
	FPU_FPSCR_V = 1UL<<28, // Overflow condition code flag
	FPU_FPSCR_AHP = 1UL<<26, // Alternative half-precision control bit
	FPU_FPSCR_DN = 1UL<<25, // Default NaN mode control bit
	FPU_FPSCR_FZ = 1UL<<24, // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL<<2)-1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC = 1UL<<7, // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC = 1UL<<4, // Inexact cumulative exception bit
	FPU_FPSCR_UFC = 1UL<<3, // Underflow cumulative exception bit
	FPU_FPSCR_OFC = 1UL<<2, // Overflow cumulative exception bit
	FPU_FPSCR_DZC = 1UL<<1, // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC = 1UL<<0, // Invalid operation cumulative exception bit		
};
inline void fpu_fpscr_set_rmode(struct FPU_Type* p, uint32_t val) { p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val<<22) & FPU_FPSCR_RMODE); }
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type* p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22 ; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL<<4)-1) << 20, // CP		
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type* p, uint32_t val) { p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val<<20) & FPU_CPACR_CPACR_CP); }
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type* p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20 ; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER; // @0 GPIO port mode register
	__IO uint16_t OTYPER; // @4 GPIO port output type register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t OSPEEDR; // @8 GPIO port output speed register
	__IO uint32_t PUPDR; // @12 GPIO port pull-up/pull-down register
	__I uint16_t IDR; // @16 GPIO port input data register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t ODR; // @20 GPIO port output data register
	 uint8_t RESERVED2[2]; // @22 
	__O uint32_t BSRR; // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR; // @28 GPIO port configuration lock register
	__IO uint32_t AFRL; // @32 GPIO alternate function low register
	__IO uint32_t AFRH; // @36 GPIO alternate function high register
	__IO uint16_t BRR; // @40 GPIO port bit reset register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_moder_set_moder15(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val<<30) & GPIOA_MODER_MODER15); }
inline void gpioa_moder_set_moder14(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val<<28) & GPIOA_MODER_MODER14); }
inline void gpioa_moder_set_moder13(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val<<26) & GPIOA_MODER_MODER13); }
inline void gpioa_moder_set_moder12(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val<<24) & GPIOA_MODER_MODER12); }
inline void gpioa_moder_set_moder11(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val<<22) & GPIOA_MODER_MODER11); }
inline void gpioa_moder_set_moder10(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val<<20) & GPIOA_MODER_MODER10); }
inline void gpioa_moder_set_moder9(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val<<18) & GPIOA_MODER_MODER9); }
inline void gpioa_moder_set_moder8(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val<<16) & GPIOA_MODER_MODER8); }
inline void gpioa_moder_set_moder7(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val<<14) & GPIOA_MODER_MODER7); }
inline void gpioa_moder_set_moder6(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val<<12) & GPIOA_MODER_MODER6); }
inline void gpioa_moder_set_moder5(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val<<10) & GPIOA_MODER_MODER5); }
inline void gpioa_moder_set_moder4(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val<<8) & GPIOA_MODER_MODER4); }
inline void gpioa_moder_set_moder3(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val<<6) & GPIOA_MODER_MODER3); }
inline void gpioa_moder_set_moder2(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val<<4) & GPIOA_MODER_MODER2); }
inline void gpioa_moder_set_moder1(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val<<2) & GPIOA_MODER_MODER1); }
inline void gpioa_moder_set_moder0(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val<<0) & GPIOA_MODER_MODER0); }
inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30 ; }
inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28 ; }
inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26 ; }
inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24 ; }
inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22 ; }
inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20 ; }
inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18 ; }
inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16 ; }
inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14 ; }
inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12 ; }
inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10 ; }
inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8 ; }
inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6 ; }
inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4 ; }
inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2 ; }
inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0 ; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val<<30) & GPIOA_OSPEEDR_OSPEEDR15); }
inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val<<28) & GPIOA_OSPEEDR_OSPEEDR14); }
inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val<<26) & GPIOA_OSPEEDR_OSPEEDR13); }
inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val<<24) & GPIOA_OSPEEDR_OSPEEDR12); }
inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val<<22) & GPIOA_OSPEEDR_OSPEEDR11); }
inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val<<20) & GPIOA_OSPEEDR_OSPEEDR10); }
inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val<<18) & GPIOA_OSPEEDR_OSPEEDR9); }
inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val<<16) & GPIOA_OSPEEDR_OSPEEDR8); }
inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val<<14) & GPIOA_OSPEEDR_OSPEEDR7); }
inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val<<12) & GPIOA_OSPEEDR_OSPEEDR6); }
inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val<<10) & GPIOA_OSPEEDR_OSPEEDR5); }
inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val<<8) & GPIOA_OSPEEDR_OSPEEDR4); }
inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val<<6) & GPIOA_OSPEEDR_OSPEEDR3); }
inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val<<4) & GPIOA_OSPEEDR_OSPEEDR2); }
inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val<<2) & GPIOA_OSPEEDR_OSPEEDR1); }
inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val<<0) & GPIOA_OSPEEDR_OSPEEDR0); }
inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0 ; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val<<30) & GPIOA_PUPDR_PUPDR15); }
inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val<<28) & GPIOA_PUPDR_PUPDR14); }
inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val<<26) & GPIOA_PUPDR_PUPDR13); }
inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val<<24) & GPIOA_PUPDR_PUPDR12); }
inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val<<22) & GPIOA_PUPDR_PUPDR11); }
inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val<<20) & GPIOA_PUPDR_PUPDR10); }
inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val<<18) & GPIOA_PUPDR_PUPDR9); }
inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val<<16) & GPIOA_PUPDR_PUPDR8); }
inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val<<14) & GPIOA_PUPDR_PUPDR7); }
inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val<<12) & GPIOA_PUPDR_PUPDR6); }
inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val<<10) & GPIOA_PUPDR_PUPDR5); }
inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val<<8) & GPIOA_PUPDR_PUPDR4); }
inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val<<6) & GPIOA_PUPDR_PUPDR3); }
inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val<<4) & GPIOA_PUPDR_PUPDR2); }
inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val<<2) & GPIOA_PUPDR_PUPDR1); }
inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val<<0) & GPIOA_PUPDR_PUPDR0); }
inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30 ; }
inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28 ; }
inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26 ; }
inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24 ; }
inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22 ; }
inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20 ; }
inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18 ; }
inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16 ; }
inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14 ; }
inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12 ; }
inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10 ; }
inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8 ; }
inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6 ; }
inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4 ; }
inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2 ; }
inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0 ; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL<<31, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL<<30, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL<<29, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL<<28, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL<<27, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL<<26, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9 = 1UL<<25, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8 = 1UL<<24, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7 = 1UL<<23, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6 = 1UL<<22, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5 = 1UL<<21, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4 = 1UL<<20, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3 = 1UL<<19, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2 = 1UL<<18, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1 = 1UL<<17, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0 = 1UL<<16, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL<<15, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL<<14, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL<<13, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL<<12, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL<<11, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL<<10, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9 = 1UL<<9, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8 = 1UL<<8, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7 = 1UL<<7, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6 = 1UL<<6, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5 = 1UL<<5, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4 = 1UL<<4, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3 = 1UL<<3, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2 = 1UL<<2, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1 = 1UL<<1, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0 = 1UL<<0, // Port x set bit y (y= 0..15)		
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK = 1UL<<16, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL<<15, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL<<14, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL<<13, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL<<12, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL<<11, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL<<10, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9 = 1UL<<9, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8 = 1UL<<8, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7 = 1UL<<7, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6 = 1UL<<6, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5 = 1UL<<5, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4 = 1UL<<4, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3 = 1UL<<3, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2 = 1UL<<2, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1 = 1UL<<1, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0 = 1UL<<0, // Port x lock bit y (y= 0..15)		
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFRL7 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL6 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL5 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL4 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL3 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL2 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL1 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL0 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 0..7)		
};
inline void gpioa_afrl_set_afrl7(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL7) | ((val<<28) & GPIOA_AFRL_AFRL7); }
inline void gpioa_afrl_set_afrl6(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL6) | ((val<<24) & GPIOA_AFRL_AFRL6); }
inline void gpioa_afrl_set_afrl5(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL5) | ((val<<20) & GPIOA_AFRL_AFRL5); }
inline void gpioa_afrl_set_afrl4(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL4) | ((val<<16) & GPIOA_AFRL_AFRL4); }
inline void gpioa_afrl_set_afrl3(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL3) | ((val<<12) & GPIOA_AFRL_AFRL3); }
inline void gpioa_afrl_set_afrl2(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL2) | ((val<<8) & GPIOA_AFRL_AFRL2); }
inline void gpioa_afrl_set_afrl1(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL1) | ((val<<4) & GPIOA_AFRL_AFRL1); }
inline void gpioa_afrl_set_afrl0(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL0) | ((val<<0) & GPIOA_AFRL_AFRL0); }
inline uint32_t gpioa_afrl_get_afrl7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL7) >> 28 ; }
inline uint32_t gpioa_afrl_get_afrl6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL6) >> 24 ; }
inline uint32_t gpioa_afrl_get_afrl5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL5) >> 20 ; }
inline uint32_t gpioa_afrl_get_afrl4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL4) >> 16 ; }
inline uint32_t gpioa_afrl_get_afrl3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL3) >> 12 ; }
inline uint32_t gpioa_afrl_get_afrl2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL2) >> 8 ; }
inline uint32_t gpioa_afrl_get_afrl1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL1) >> 4 ; }
inline uint32_t gpioa_afrl_get_afrl0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL0) >> 0 ; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFRH15 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH14 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH13 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH12 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH11 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH10 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH9 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH8 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 8..15)		
};
inline void gpioa_afrh_set_afrh15(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH15) | ((val<<28) & GPIOA_AFRH_AFRH15); }
inline void gpioa_afrh_set_afrh14(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH14) | ((val<<24) & GPIOA_AFRH_AFRH14); }
inline void gpioa_afrh_set_afrh13(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH13) | ((val<<20) & GPIOA_AFRH_AFRH13); }
inline void gpioa_afrh_set_afrh12(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH12) | ((val<<16) & GPIOA_AFRH_AFRH12); }
inline void gpioa_afrh_set_afrh11(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH11) | ((val<<12) & GPIOA_AFRH_AFRH11); }
inline void gpioa_afrh_set_afrh10(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH10) | ((val<<8) & GPIOA_AFRH_AFRH10); }
inline void gpioa_afrh_set_afrh9(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH9) | ((val<<4) & GPIOA_AFRH_AFRH9); }
inline void gpioa_afrh_set_afrh8(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH8) | ((val<<0) & GPIOA_AFRH_AFRH8); }
inline uint32_t gpioa_afrh_get_afrh15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH15) >> 28 ; }
inline uint32_t gpioa_afrh_get_afrh14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH14) >> 24 ; }
inline uint32_t gpioa_afrh_get_afrh13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH13) >> 20 ; }
inline uint32_t gpioa_afrh_get_afrh12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH12) >> 16 ; }
inline uint32_t gpioa_afrh_get_afrh11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH11) >> 12 ; }
inline uint32_t gpioa_afrh_get_afrh10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH10) >> 8 ; }
inline uint32_t gpioa_afrh_get_afrh9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH9) >> 4 ; }
inline uint32_t gpioa_afrh_get_afrh8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH8) >> 0 ; }











/* Hash processor */
struct HASH_Type {
	__IO uint32_t CR; // @0 control register
	__IO uint32_t DIN; // @4 data input register
	__IO uint16_t STR; // @8 start register
	 uint8_t RESERVED0[2]; // @10 
	__I uint32_t HR0; // @12 digest registers
	__I uint32_t HR1; // @16 digest registers
	__I uint32_t HR2; // @20 digest registers
	__I uint32_t HR3; // @24 digest registers
	__I uint32_t HR4; // @28 digest registers
	__IO uint8_t IMR; // @32 interrupt enable register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t SR; // @36 status register
	 uint8_t RESERVED2[211]; // @37 
	__IO uint32_t CSR0; // @248 context swap registers
	__IO uint32_t CSR1; // @252 context swap registers
	__IO uint32_t CSR2; // @256 context swap registers
	__IO uint32_t CSR3; // @260 context swap registers
	__IO uint32_t CSR4; // @264 context swap registers
	__IO uint32_t CSR5; // @268 context swap registers
	__IO uint32_t CSR6; // @272 context swap registers
	__IO uint32_t CSR7; // @276 context swap registers
	__IO uint32_t CSR8; // @280 context swap registers
	__IO uint32_t CSR9; // @284 context swap registers
	__IO uint32_t CSR10; // @288 context swap registers
	__IO uint32_t CSR11; // @292 context swap registers
	__IO uint32_t CSR12; // @296 context swap registers
	__IO uint32_t CSR13; // @300 context swap registers
	__IO uint32_t CSR14; // @304 context swap registers
	__IO uint32_t CSR15; // @308 context swap registers
	__IO uint32_t CSR16; // @312 context swap registers
	__IO uint32_t CSR17; // @316 context swap registers
	__IO uint32_t CSR18; // @320 context swap registers
	__IO uint32_t CSR19; // @324 context swap registers
	__IO uint32_t CSR20; // @328 context swap registers
	__IO uint32_t CSR21; // @332 context swap registers
	__IO uint32_t CSR22; // @336 context swap registers
	__IO uint32_t CSR23; // @340 context swap registers
	__IO uint32_t CSR24; // @344 context swap registers
	__IO uint32_t CSR25; // @348 context swap registers
	__IO uint32_t CSR26; // @352 context swap registers
	__IO uint32_t CSR27; // @356 context swap registers
	__IO uint32_t CSR28; // @360 context swap registers
	__IO uint32_t CSR29; // @364 context swap registers
	__IO uint32_t CSR30; // @368 context swap registers
	__IO uint32_t CSR31; // @372 context swap registers
	__IO uint32_t CSR32; // @376 context swap registers
	__IO uint32_t CSR33; // @380 context swap registers
	__IO uint32_t CSR34; // @384 context swap registers
	__IO uint32_t CSR35; // @388 context swap registers
	__IO uint32_t CSR36; // @392 context swap registers
	__IO uint32_t CSR37; // @396 context swap registers
	__IO uint32_t CSR38; // @400 context swap registers
	__IO uint32_t CSR39; // @404 context swap registers
	__IO uint32_t CSR40; // @408 context swap registers
	__IO uint32_t CSR41; // @412 context swap registers
	__IO uint32_t CSR42; // @416 context swap registers
	__IO uint32_t CSR43; // @420 context swap registers
	__IO uint32_t CSR44; // @424 context swap registers
	__IO uint32_t CSR45; // @428 context swap registers
	__IO uint32_t CSR46; // @432 context swap registers
	__IO uint32_t CSR47; // @436 context swap registers
	__IO uint32_t CSR48; // @440 context swap registers
	__IO uint32_t CSR49; // @444 context swap registers
	__IO uint32_t CSR50; // @448 context swap registers
	__IO uint32_t CSR51; // @452 context swap registers
	__IO uint32_t CSR52; // @456 context swap registers
	__IO uint32_t CSR53; // @460 context swap registers
	 uint8_t RESERVED3[320]; // @464 
	__I uint32_t HHR0; // @784 HASH digest register
	__I uint32_t HHR1; // @788 read-only
	__I uint32_t HHR2; // @792 read-only
	__I uint32_t HHR3; // @796 read-only
	__I uint32_t HHR4; // @800 read-only
	__I uint32_t HHR5; // @804 read-only
	__I uint32_t HHR6; // @808 read-only
	__I uint32_t HHR7; // @812 read-only
};

// HASH->CR control register
enum {
	HASH_CR_ALGO1 = 1UL<<18, // ALGO
	HASH_CR_LKEY = 1UL<<16, // Long key selection
	HASH_CR_MDMAT = 1UL<<13, // Multiple DMA Transfers
	HASH_CR_DINNE = 1UL<<12, // DIN not empty
	HASH_CR_NBW = ((1UL<<4)-1) << 8, // Number of words already pushed
	HASH_CR_ALGO0 = 1UL<<7, // Algorithm selection
	HASH_CR_MODE = 1UL<<6, // Mode selection
	HASH_CR_DATATYPE = ((1UL<<2)-1) << 4, // Data type selection
	HASH_CR_DMAE = 1UL<<3, // DMA enable
	HASH_CR_INIT = 1UL<<2, // Initialize message digest calculation		
};
inline void hash_cr_set_nbw(struct HASH_Type* p, uint32_t val) { p->CR = (p->CR & ~HASH_CR_NBW) | ((val<<8) & HASH_CR_NBW); }
inline void hash_cr_set_datatype(struct HASH_Type* p, uint32_t val) { p->CR = (p->CR & ~HASH_CR_DATATYPE) | ((val<<4) & HASH_CR_DATATYPE); }
inline uint32_t hash_cr_get_nbw(struct HASH_Type* p) { return (p->CR & HASH_CR_NBW) >> 8 ; }
inline uint32_t hash_cr_get_datatype(struct HASH_Type* p) { return (p->CR & HASH_CR_DATATYPE) >> 4 ; }

// HASH->STR start register
enum {
	HASH_STR_DCAL = 1UL<<8, // Digest calculation
	HASH_STR_NBLW = ((1UL<<5)-1) << 0, // Number of valid bits in the last word of the message		
};
inline void hash_str_set_nblw(struct HASH_Type* p, uint32_t val) { p->STR = (p->STR & ~HASH_STR_NBLW) | ((val<<0) & HASH_STR_NBLW); }
inline uint32_t hash_str_get_nblw(struct HASH_Type* p) { return (p->STR & HASH_STR_NBLW) >> 0 ; }

// HASH->IMR interrupt enable register
enum {
	HASH_IMR_DCIE = 1UL<<1, // Digest calculation completion interrupt enable
	HASH_IMR_DINIE = 1UL<<0, // Data input interrupt enable		
};

// HASH->SR status register
enum {
	HASH_SR_BUSY = 1UL<<3, // Busy bit
	HASH_SR_DMAS = 1UL<<2, // DMA Status
	HASH_SR_DCIS = 1UL<<1, // Digest calculation completion interrupt status
	HASH_SR_DINIS = 1UL<<0, // Data input interrupt status		
};

/* Inter-integrated circuit */
struct I2C1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint16_t OAR1; // @8 Own address register 1
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t OAR2; // @12 Own address register 2
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t TIMINGR; // @16 Timing register
	__IO uint32_t TIMEOUTR; // @20 Status register 1
	__IO uint32_t ISR; // @24 Interrupt and Status register
	__O uint16_t ICR; // @28 Interrupt clear register
	 uint8_t RESERVED2[2]; // @30 
	__I uint8_t PECR; // @32 PEC register
	 uint8_t RESERVED3[3]; // @33 
	__I uint8_t RXDR; // @36 Receive data register
	 uint8_t RESERVED4[3]; // @37 
	__IO uint8_t TXDR; // @40 Transmit data register
};

// I2C1->CR1 Control register 1
enum {
	I2C1_CR1_PECEN = 1UL<<23, // PEC enable
	I2C1_CR1_ALERTEN = 1UL<<22, // SMBUS alert enable
	I2C1_CR1_SMBDEN = 1UL<<21, // SMBus Device Default address enable
	I2C1_CR1_SMBHEN = 1UL<<20, // SMBus Host address enable
	I2C1_CR1_GCEN = 1UL<<19, // General call enable
	I2C1_CR1_WUPEN = 1UL<<18, // Wakeup from STOP enable
	I2C1_CR1_NOSTRETCH = 1UL<<17, // Clock stretching disable
	I2C1_CR1_SBC = 1UL<<16, // Slave byte control
	I2C1_CR1_RXDMAEN = 1UL<<15, // DMA reception requests enable
	I2C1_CR1_TXDMAEN = 1UL<<14, // DMA transmission requests enable
	I2C1_CR1_ANFOFF = 1UL<<12, // Analog noise filter OFF
	I2C1_CR1_DNF = ((1UL<<4)-1) << 8, // Digital noise filter
	I2C1_CR1_ERRIE = 1UL<<7, // Error interrupts enable
	I2C1_CR1_TCIE = 1UL<<6, // Transfer Complete interrupt enable
	I2C1_CR1_STOPIE = 1UL<<5, // STOP detection Interrupt enable
	I2C1_CR1_NACKIE = 1UL<<4, // Not acknowledge received interrupt enable
	I2C1_CR1_ADDRIE = 1UL<<3, // Address match interrupt enable (slave only)
	I2C1_CR1_RXIE = 1UL<<2, // RX Interrupt enable
	I2C1_CR1_TXIE = 1UL<<1, // TX Interrupt enable
	I2C1_CR1_PE = 1UL<<0, // Peripheral enable		
};
inline void i2c1_cr1_set_dnf(struct I2C1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C1_CR1_DNF) | ((val<<8) & I2C1_CR1_DNF); }
inline uint32_t i2c1_cr1_get_dnf(struct I2C1_Type* p) { return (p->CR1 & I2C1_CR1_DNF) >> 8 ; }

// I2C1->CR2 Control register 2
enum {
	I2C1_CR2_PECBYTE = 1UL<<26, // Packet error checking byte
	I2C1_CR2_AUTOEND = 1UL<<25, // Automatic end mode (master mode)
	I2C1_CR2_RELOAD = 1UL<<24, // NBYTES reload mode
	I2C1_CR2_NBYTES = ((1UL<<8)-1) << 16, // Number of bytes
	I2C1_CR2_NACK = 1UL<<15, // NACK generation (slave mode)
	I2C1_CR2_STOP = 1UL<<14, // Stop generation (master mode)
	I2C1_CR2_START = 1UL<<13, // Start generation
	I2C1_CR2_HEAD10R = 1UL<<12, // 10-bit address header only read direction (master receiver mode)
	I2C1_CR2_ADD10 = 1UL<<11, // 10-bit addressing mode (master mode)
	I2C1_CR2_RD_WRN = 1UL<<10, // Transfer direction (master mode)
	I2C1_CR2_SADD = ((1UL<<10)-1) << 0, // Slave address bit (master mode)		
};
inline void i2c1_cr2_set_nbytes(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_NBYTES) | ((val<<16) & I2C1_CR2_NBYTES); }
inline void i2c1_cr2_set_sadd(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_SADD) | ((val<<0) & I2C1_CR2_SADD); }
inline uint32_t i2c1_cr2_get_nbytes(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_NBYTES) >> 16 ; }
inline uint32_t i2c1_cr2_get_sadd(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_SADD) >> 0 ; }

// I2C1->OAR1 Own address register 1
enum {
	I2C1_OAR1_OA1EN = 1UL<<15, // Own Address 1 enable
	I2C1_OAR1_OA1MODE = 1UL<<10, // Own Address 1 10-bit mode
	I2C1_OAR1_OA1 = ((1UL<<10)-1) << 0, // Interface address		
};
inline void i2c1_oar1_set_oa1(struct I2C1_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1) | ((val<<0) & I2C1_OAR1_OA1); }
inline uint32_t i2c1_oar1_get_oa1(struct I2C1_Type* p) { return (p->OAR1 & I2C1_OAR1_OA1) >> 0 ; }

// I2C1->OAR2 Own address register 2
enum {
	I2C1_OAR2_OA2EN = 1UL<<15, // Own Address 2 enable
	I2C1_OAR2_OA2MSK = ((1UL<<3)-1) << 8, // Own Address 2 masks
	I2C1_OAR2_OA2 = ((1UL<<7)-1) << 1, // Interface address		
};
inline void i2c1_oar2_set_oa2msk(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2MSK) | ((val<<8) & I2C1_OAR2_OA2MSK); }
inline void i2c1_oar2_set_oa2(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2) | ((val<<1) & I2C1_OAR2_OA2); }
inline uint32_t i2c1_oar2_get_oa2msk(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2MSK) >> 8 ; }
inline uint32_t i2c1_oar2_get_oa2(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2) >> 1 ; }

// I2C1->TIMINGR Timing register
enum {
	I2C1_TIMINGR_PRESC = ((1UL<<4)-1) << 28, // Timing prescaler
	I2C1_TIMINGR_SCLDEL = ((1UL<<4)-1) << 20, // Data setup time
	I2C1_TIMINGR_SDADEL = ((1UL<<4)-1) << 16, // Data hold time
	I2C1_TIMINGR_SCLH = ((1UL<<8)-1) << 8, // SCL high period (master mode)
	I2C1_TIMINGR_SCLL = ((1UL<<8)-1) << 0, // SCL low period (master mode)		
};
inline void i2c1_timingr_set_presc(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_PRESC) | ((val<<28) & I2C1_TIMINGR_PRESC); }
inline void i2c1_timingr_set_scldel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLDEL) | ((val<<20) & I2C1_TIMINGR_SCLDEL); }
inline void i2c1_timingr_set_sdadel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SDADEL) | ((val<<16) & I2C1_TIMINGR_SDADEL); }
inline void i2c1_timingr_set_sclh(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLH) | ((val<<8) & I2C1_TIMINGR_SCLH); }
inline void i2c1_timingr_set_scll(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLL) | ((val<<0) & I2C1_TIMINGR_SCLL); }
inline uint32_t i2c1_timingr_get_presc(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_PRESC) >> 28 ; }
inline uint32_t i2c1_timingr_get_scldel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLDEL) >> 20 ; }
inline uint32_t i2c1_timingr_get_sdadel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SDADEL) >> 16 ; }
inline uint32_t i2c1_timingr_get_sclh(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLH) >> 8 ; }
inline uint32_t i2c1_timingr_get_scll(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLL) >> 0 ; }

// I2C1->TIMEOUTR Status register 1
enum {
	I2C1_TIMEOUTR_TEXTEN = 1UL<<31, // Extended clock timeout enable
	I2C1_TIMEOUTR_TIMEOUTB = ((1UL<<12)-1) << 16, // Bus timeout B
	I2C1_TIMEOUTR_TIMOUTEN = 1UL<<15, // Clock timeout enable
	I2C1_TIMEOUTR_TIDLE = 1UL<<12, // Idle clock timeout detection
	I2C1_TIMEOUTR_TIMEOUTA = ((1UL<<12)-1) << 0, // Bus timeout A		
};
inline void i2c1_timeoutr_set_timeoutb(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTB) | ((val<<16) & I2C1_TIMEOUTR_TIMEOUTB); }
inline void i2c1_timeoutr_set_timeouta(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTA) | ((val<<0) & I2C1_TIMEOUTR_TIMEOUTA); }
inline uint32_t i2c1_timeoutr_get_timeoutb(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTB) >> 16 ; }
inline uint32_t i2c1_timeoutr_get_timeouta(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTA) >> 0 ; }

// I2C1->ISR Interrupt and Status register
enum {
	I2C1_ISR_ADDCODE = ((1UL<<7)-1) << 17, // Address match code (Slave mode)
	I2C1_ISR_DIR = 1UL<<16, // Transfer direction (Slave mode)
	I2C1_ISR_BUSY = 1UL<<15, // Bus busy
	I2C1_ISR_ALERT = 1UL<<13, // SMBus alert
	I2C1_ISR_TIMEOUT = 1UL<<12, // Timeout or t_low detection flag
	I2C1_ISR_PECERR = 1UL<<11, // PEC Error in reception
	I2C1_ISR_OVR = 1UL<<10, // Overrun/Underrun (slave mode)
	I2C1_ISR_ARLO = 1UL<<9, // Arbitration lost
	I2C1_ISR_BERR = 1UL<<8, // Bus error
	I2C1_ISR_TCR = 1UL<<7, // Transfer Complete Reload
	I2C1_ISR_TC = 1UL<<6, // Transfer Complete (master mode)
	I2C1_ISR_STOPF = 1UL<<5, // Stop detection flag
	I2C1_ISR_NACKF = 1UL<<4, // Not acknowledge received flag
	I2C1_ISR_ADDR = 1UL<<3, // Address matched (slave mode)
	I2C1_ISR_RXNE = 1UL<<2, // Receive data register not empty (receivers)
	I2C1_ISR_TXIS = 1UL<<1, // Transmit interrupt status (transmitters)
	I2C1_ISR_TXE = 1UL<<0, // Transmit data register empty (transmitters)		
};
inline void i2c1_isr_set_addcode(struct I2C1_Type* p, uint32_t val) { p->ISR = (p->ISR & ~I2C1_ISR_ADDCODE) | ((val<<17) & I2C1_ISR_ADDCODE); }
inline uint32_t i2c1_isr_get_addcode(struct I2C1_Type* p) { return (p->ISR & I2C1_ISR_ADDCODE) >> 17 ; }

// I2C1->ICR Interrupt clear register
enum {
	I2C1_ICR_ALERTCF = 1UL<<13, // Alert flag clear
	I2C1_ICR_TIMOUTCF = 1UL<<12, // Timeout detection flag clear
	I2C1_ICR_PECCF = 1UL<<11, // PEC Error flag clear
	I2C1_ICR_OVRCF = 1UL<<10, // Overrun/Underrun flag clear
	I2C1_ICR_ARLOCF = 1UL<<9, // Arbitration lost flag clear
	I2C1_ICR_BERRCF = 1UL<<8, // Bus error flag clear
	I2C1_ICR_STOPCF = 1UL<<5, // Stop detection flag clear
	I2C1_ICR_NACKCF = 1UL<<4, // Not Acknowledge flag clear
	I2C1_ICR_ADDRCF = 1UL<<3, // Address Matched flag clear		
};




/* Independent watchdog */
struct IWDG_Type {
	__O uint16_t KR; // @0 Key register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t PR; // @4 Prescaler register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t RLR; // @8 Reload register
	 uint8_t RESERVED2[2]; // @10 
	__I uint8_t SR; // @12 Status register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t WINR; // @16 Window register
};

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL<<3)-1) << 0, // Prescaler divider		
};
inline void iwdg_pr_set_pr(struct IWDG_Type* p, uint32_t val) { p->PR = (p->PR & ~IWDG_PR_PR) | ((val<<0) & IWDG_PR_PR); }
inline uint32_t iwdg_pr_get_pr(struct IWDG_Type* p) { return (p->PR & IWDG_PR_PR) >> 0 ; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL<<12)-1) << 0, // Watchdog counter reload value		
};
inline void iwdg_rlr_set_rl(struct IWDG_Type* p, uint32_t val) { p->RLR = (p->RLR & ~IWDG_RLR_RL) | ((val<<0) & IWDG_RLR_RL); }
inline uint32_t iwdg_rlr_get_rl(struct IWDG_Type* p) { return (p->RLR & IWDG_RLR_RL) >> 0 ; }

// IWDG->SR Status register
enum {
	IWDG_SR_RVU = 1UL<<1, // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL<<0, // Watchdog prescaler value update		
};

// IWDG->WINR Window register
enum {
	IWDG_WINR_WIN = ((1UL<<12)-1) << 0, // Watchdog counter window value		
};
inline void iwdg_winr_set_win(struct IWDG_Type* p, uint32_t val) { p->WINR = (p->WINR & ~IWDG_WINR_WIN) | ((val<<0) & IWDG_WINR_WIN); }
inline uint32_t iwdg_winr_get_win(struct IWDG_Type* p) { return (p->WINR & IWDG_WINR_WIN) >> 0 ; }

/* JPEG codec */
struct JPEG_Type {
	__O uint8_t CONFR0; // @0 JPEG codec configuration register 0
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CONFR1; // @4 JPEG codec configuration register 1
	__IO uint32_t CONFR2; // @8 JPEG codec configuration register 2
	__IO uint32_t CONFR3; // @12 JPEG codec configuration register 3
	__IO uint16_t CONFR4; // @16 JPEG codec configuration register 4
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t CONFR5; // @20 JPEG codec configuration register 5
	 uint8_t RESERVED2[2]; // @22 
	__IO uint16_t CONFR6; // @24 JPEG codec configuration register 6
	 uint8_t RESERVED3[2]; // @26 
	__IO uint16_t CONFR7; // @28 JPEG codec configuration register 7
	 uint8_t RESERVED4[18]; // @30 
	__IO uint16_t CR; // @48 JPEG control register
	 uint8_t RESERVED5[2]; // @50 
	__I uint8_t SR; // @52 JPEG status register
	 uint8_t RESERVED6[3]; // @53 
	__O uint8_t CFR; // @56 JPEG clear flag register
	 uint8_t RESERVED7[7]; // @57 
	__O uint32_t DIR; // @64 JPEG data input register
	__I uint32_t DOR; // @68 JPEG data output register
	 uint8_t RESERVED8[8]; // @72 
	__IO uint32_t QMEM0_0; // @80 JPEG quantization tables
	__IO uint32_t QMEM0_1; // @84 JPEG quantization tables
	__IO uint32_t QMEM0_2; // @88 JPEG quantization tables
	__IO uint32_t QMEM0_3; // @92 JPEG quantization tables
	__IO uint32_t QMEM0_4; // @96 JPEG quantization tables
	__IO uint32_t QMEM0_5; // @100 JPEG quantization tables
	__IO uint32_t QMEM0_6; // @104 JPEG quantization tables
	__IO uint32_t QMEM0_7; // @108 JPEG quantization tables
	__IO uint32_t QMEM0_8; // @112 JPEG quantization tables
	__IO uint32_t QMEM0_9; // @116 JPEG quantization tables
	__IO uint32_t QMEM0_10; // @120 JPEG quantization tables
	__IO uint32_t QMEM0_11; // @124 JPEG quantization tables
	__IO uint32_t QMEM0_12; // @128 JPEG quantization tables
	__IO uint32_t QMEM0_13; // @132 JPEG quantization tables
	__IO uint32_t QMEM0_14; // @136 JPEG quantization tables
	__IO uint32_t QMEM0_15; // @140 JPEG quantization tables
	__IO uint32_t QMEM1_0; // @144 JPEG quantization tables
	__IO uint32_t QMEM1_1; // @148 JPEG quantization tables
	__IO uint32_t QMEM1_2; // @152 JPEG quantization tables
	__IO uint32_t QMEM1_3; // @156 JPEG quantization tables
	__IO uint32_t QMEM1_4; // @160 JPEG quantization tables
	__IO uint32_t QMEM1_5; // @164 JPEG quantization tables
	__IO uint32_t QMEM1_6; // @168 JPEG quantization tables
	__IO uint32_t QMEM1_7; // @172 JPEG quantization tables
	__IO uint32_t QMEM1_8; // @176 JPEG quantization tables
	__IO uint32_t QMEM1_9; // @180 JPEG quantization tables
	__IO uint32_t QMEM1_10; // @184 JPEG quantization tables
	__IO uint32_t QMEM1_11; // @188 JPEG quantization tables
	__IO uint32_t QMEM1_12; // @192 JPEG quantization tables
	__IO uint32_t QMEM1_13; // @196 JPEG quantization tables
	__IO uint32_t QMEM1_14; // @200 JPEG quantization tables
	__IO uint32_t QMEM1_15; // @204 JPEG quantization tables
	__IO uint32_t QMEM2_0; // @208 JPEG quantization tables
	__IO uint32_t QMEM2_1; // @212 JPEG quantization tables
	__IO uint32_t QMEM2_2; // @216 JPEG quantization tables
	__IO uint32_t QMEM2_3; // @220 JPEG quantization tables
	__IO uint32_t QMEM2_4; // @224 JPEG quantization tables
	__IO uint32_t QMEM2_5; // @228 JPEG quantization tables
	__IO uint32_t QMEM2_6; // @232 JPEG quantization tables
	__IO uint32_t QMEM2_7; // @236 JPEG quantization tables
	__IO uint32_t QMEM2_8; // @240 JPEG quantization tables
	__IO uint32_t QMEM2_9; // @244 JPEG quantization tables
	__IO uint32_t QMEM2_10; // @248 JPEG quantization tables
	__IO uint32_t QMEM2_11; // @252 JPEG quantization tables
	__IO uint32_t QMEM2_12; // @256 JPEG quantization tables
	__IO uint32_t QMEM2_13; // @260 JPEG quantization tables
	__IO uint32_t QMEM2_14; // @264 JPEG quantization tables
	__IO uint32_t QMEM2_15; // @268 JPEG quantization tables
	__IO uint32_t QMEM3_0; // @272 JPEG quantization tables
	__IO uint32_t QMEM3_1; // @276 JPEG quantization tables
	__IO uint32_t QMEM3_2; // @280 JPEG quantization tables
	__IO uint32_t QMEM3_3; // @284 JPEG quantization tables
	__IO uint32_t QMEM3_4; // @288 JPEG quantization tables
	__IO uint32_t QMEM3_5; // @292 JPEG quantization tables
	__IO uint32_t QMEM3_6; // @296 JPEG quantization tables
	__IO uint32_t QMEM3_7; // @300 JPEG quantization tables
	__IO uint32_t QMEM3_8; // @304 JPEG quantization tables
	__IO uint32_t QMEM3_9; // @308 JPEG quantization tables
	__IO uint32_t QMEM3_10; // @312 JPEG quantization tables
	__IO uint32_t QMEM3_11; // @316 JPEG quantization tables
	__IO uint32_t QMEM3_12; // @320 JPEG quantization tables
	__IO uint32_t QMEM3_13; // @324 JPEG quantization tables
	__IO uint32_t QMEM3_14; // @328 JPEG quantization tables
	__IO uint32_t QMEM3_15; // @332 JPEG quantization tables
	__IO uint32_t HUFFMIN_0; // @336 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_1; // @340 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_2; // @344 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_3; // @348 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_4; // @352 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_5; // @356 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_6; // @360 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_7; // @364 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_8; // @368 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_9; // @372 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_10; // @376 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_11; // @380 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_12; // @384 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_13; // @388 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_14; // @392 JPEG HuffMin tables
	__IO uint32_t HUFFMIN_15; // @396 JPEG HuffMin tables
	__IO uint32_t HUFFBASE0; // @400 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE1; // @404 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE2; // @408 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE3; // @412 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE4; // @416 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE5; // @420 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE6; // @424 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE7; // @428 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE8; // @432 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE9; // @436 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE10; // @440 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE11; // @444 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE12; // @448 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE13; // @452 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE14; // @456 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE15; // @460 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE16; // @464 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE17; // @468 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE18; // @472 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE19; // @476 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE20; // @480 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE21; // @484 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE22; // @488 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE23; // @492 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE24; // @496 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE25; // @500 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE26; // @504 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE27; // @508 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE28; // @512 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE29; // @516 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE30; // @520 JPEG HuffSymb tables
	__IO uint32_t HUFFBASE31; // @524 JPEG HuffSymb tables
	__IO uint32_t HUFFSYMB0; // @528 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB1; // @532 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB2; // @536 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB3; // @540 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB4; // @544 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB5; // @548 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB6; // @552 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB7; // @556 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB8; // @560 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB9; // @564 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB10; // @568 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB11; // @572 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB12; // @576 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB13; // @580 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB14; // @584 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB15; // @588 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB16; // @592 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB17; // @596 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB18; // @600 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB19; // @604 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB20; // @608 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB21; // @612 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB22; // @616 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB23; // @620 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB24; // @624 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB25; // @628 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB26; // @632 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB27; // @636 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB28; // @640 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB29; // @644 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB30; // @648 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB31; // @652 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB32; // @656 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB33; // @660 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB34; // @664 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB35; // @668 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB36; // @672 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB37; // @676 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB38; // @680 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB39; // @684 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB40; // @688 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB41; // @692 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB42; // @696 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB43; // @700 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB44; // @704 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB45; // @708 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB46; // @712 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB47; // @716 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB48; // @720 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB49; // @724 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB50; // @728 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB51; // @732 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB52; // @736 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB53; // @740 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB54; // @744 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB55; // @748 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB56; // @752 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB57; // @756 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB58; // @760 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB59; // @764 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB60; // @768 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB61; // @772 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB62; // @776 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB63; // @780 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB64; // @784 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB65; // @788 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB66; // @792 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB67; // @796 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB68; // @800 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB69; // @804 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB70; // @808 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB71; // @812 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB72; // @816 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB73; // @820 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB74; // @824 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB75; // @828 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB76; // @832 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB77; // @836 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB78; // @840 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB79; // @844 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB80; // @848 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB81; // @852 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB82; // @856 JPEG HUFFSYMB tables
	__IO uint32_t HUFFSYMB83; // @860 JPEG HUFFSYMB tables
	__IO uint32_t DHTMEM0; // @864 JPEG DHTMem tables
	__IO uint32_t DHTMEM2; // @868 JPEG DHTMem tables
	__IO uint32_t DHTMEM3; // @872 JPEG DHTMem tables
	__IO uint32_t DHTMEM4; // @876 JPEG DHTMem tables
	__IO uint32_t DHTMEM5; // @880 JPEG DHTMem tables
	__IO uint32_t DHTMEM6; // @884 JPEG DHTMem tables
	__IO uint32_t DHTMEM7; // @888 JPEG DHTMem tables
	__IO uint32_t DHTMEM8; // @892 JPEG DHTMem tables
	__IO uint32_t DHTMEM9; // @896 JPEG DHTMem tables
	__IO uint32_t DHTMEM10; // @900 JPEG DHTMem tables
	__IO uint32_t DHTMEM11; // @904 JPEG DHTMem tables
	__IO uint32_t DHTMEM12; // @908 JPEG DHTMem tables
	__IO uint32_t DHTMEM13; // @912 JPEG DHTMem tables
	__IO uint32_t DHTMEM14; // @916 JPEG DHTMem tables
	__IO uint32_t DHTMEM15; // @920 JPEG DHTMem tables
	__IO uint32_t DHTMEM16; // @924 JPEG DHTMem tables
	__IO uint32_t DHTMEM17; // @928 JPEG DHTMem tables
	__IO uint32_t DHTMEM18; // @932 JPEG DHTMem tables
	__IO uint32_t DHTMEM19; // @936 JPEG DHTMem tables
	__IO uint32_t DHTMEM20; // @940 JPEG DHTMem tables
	__IO uint32_t DHTMEM21; // @944 JPEG DHTMem tables
	__IO uint32_t DHTMEM22; // @948 JPEG DHTMem tables
	__IO uint32_t DHTMEM23; // @952 JPEG DHTMem tables
	__IO uint32_t DHTMEM24; // @956 JPEG DHTMem tables
	__IO uint32_t DHTMEM25; // @960 JPEG DHTMem tables
	__IO uint32_t DHTMEM26; // @964 JPEG DHTMem tables
	__IO uint32_t DHTMEM27; // @968 JPEG DHTMem tables
	__IO uint32_t DHTMEM28; // @972 JPEG DHTMem tables
	__IO uint32_t DHTMEM29; // @976 JPEG DHTMem tables
	__IO uint32_t DHTMEM30; // @980 JPEG DHTMem tables
	__IO uint32_t DHTMEM31; // @984 JPEG DHTMem tables
	__IO uint32_t DHTMEM32; // @988 JPEG DHTMem tables
	__IO uint32_t DHTMEM33; // @992 JPEG DHTMem tables
	__IO uint32_t DHTMEM34; // @996 JPEG DHTMem tables
	__IO uint32_t DHTMEM35; // @1000 JPEG DHTMem tables
	__IO uint32_t DHTMEM36; // @1004 JPEG DHTMem tables
	__IO uint32_t DHTMEM37; // @1008 JPEG DHTMem tables
	__IO uint32_t DHTMEM38; // @1012 JPEG DHTMem tables
	__IO uint32_t DHTMEM39; // @1016 JPEG DHTMem tables
	__IO uint32_t DHTMEM40; // @1020 JPEG DHTMem tables
	__IO uint32_t DHTMEM41; // @1024 JPEG DHTMem tables
	__IO uint32_t DHTMEM42; // @1028 JPEG DHTMem tables
	__IO uint32_t DHTMEM43; // @1032 JPEG DHTMem tables
	__IO uint32_t DHTMEM44; // @1036 JPEG DHTMem tables
	__IO uint32_t DHTMEM45; // @1040 JPEG DHTMem tables
	__IO uint32_t DHTMEM46; // @1044 JPEG DHTMem tables
	__IO uint32_t DHTMEM47; // @1048 JPEG DHTMem tables
	__IO uint32_t DHTMEM48; // @1052 JPEG DHTMem tables
	__IO uint32_t DHTMEM49; // @1056 JPEG DHTMem tables
	__IO uint32_t DHTMEM50; // @1060 JPEG DHTMem tables
	__IO uint32_t DHTMEM51; // @1064 JPEG DHTMem tables
	__IO uint32_t DHTMEM52; // @1068 JPEG DHTMem tables
	__IO uint32_t DHTMEM53; // @1072 JPEG DHTMem tables
	__IO uint32_t DHTMEM54; // @1076 JPEG DHTMem tables
	__IO uint32_t DHTMEM55; // @1080 JPEG DHTMem tables
	__IO uint32_t DHTMEM56; // @1084 JPEG DHTMem tables
	__IO uint32_t DHTMEM57; // @1088 JPEG DHTMem tables
	__IO uint32_t DHTMEM58; // @1092 JPEG DHTMem tables
	__IO uint32_t DHTMEM59; // @1096 JPEG DHTMem tables
	__IO uint32_t DHTMEM60; // @1100 JPEG DHTMem tables
	__IO uint32_t DHTMEM61; // @1104 JPEG DHTMem tables
	__IO uint32_t DHTMEM62; // @1108 JPEG DHTMem tables
	__IO uint32_t DHTMEM63; // @1112 JPEG DHTMem tables
	__IO uint32_t DHTMEM64; // @1116 JPEG DHTMem tables
	__IO uint32_t DHTMEM65; // @1120 JPEG DHTMem tables
	__IO uint32_t DHTMEM66; // @1124 JPEG DHTMem tables
	__IO uint32_t DHTMEM67; // @1128 JPEG DHTMem tables
	__IO uint32_t DHTMEM68; // @1132 JPEG DHTMem tables
	__IO uint32_t DHTMEM69; // @1136 JPEG DHTMem tables
	__IO uint32_t DHTMEM70; // @1140 JPEG DHTMem tables
	__IO uint32_t DHTMEM71; // @1144 JPEG DHTMem tables
	__IO uint32_t DHTMEM72; // @1148 JPEG DHTMem tables
	__IO uint32_t DHTMEM73; // @1152 JPEG DHTMem tables
	__IO uint32_t DHTMEM74; // @1156 JPEG DHTMem tables
	__IO uint32_t DHTMEM75; // @1160 JPEG DHTMem tables
	__IO uint32_t DHTMEM76; // @1164 JPEG DHTMem tables
	__IO uint32_t DHTMEM77; // @1168 JPEG DHTMem tables
	__IO uint32_t DHTMEM78; // @1172 JPEG DHTMem tables
	__IO uint32_t DHTMEM79; // @1176 JPEG DHTMem tables
	__IO uint32_t DHTMEM80; // @1180 JPEG DHTMem tables
	__IO uint32_t DHTMEM81; // @1184 JPEG DHTMem tables
	__IO uint32_t DHTMEM82; // @1188 JPEG DHTMem tables
	__IO uint32_t DHTMEM83; // @1192 JPEG DHTMem tables
	__IO uint32_t DHTMEM84; // @1196 JPEG DHTMem tables
	__IO uint32_t DHTMEM85; // @1200 JPEG DHTMem tables
	__IO uint32_t DHTMEM86; // @1204 JPEG DHTMem tables
	__IO uint32_t DHTMEM87; // @1208 JPEG DHTMem tables
	__IO uint32_t DHTMEM88; // @1212 JPEG DHTMem tables
	__IO uint32_t DHTMEM89; // @1216 JPEG DHTMem tables
	__IO uint32_t DHTMEM90; // @1220 JPEG DHTMem tables
	__IO uint32_t DHTMEM91; // @1224 JPEG DHTMem tables
	__IO uint32_t DHTMEM92; // @1228 JPEG DHTMem tables
	__IO uint32_t DHTMEM93; // @1232 JPEG DHTMem tables
	__IO uint32_t DHTMEM94; // @1236 JPEG DHTMem tables
	__IO uint32_t DHTMEM95; // @1240 JPEG DHTMem tables
	__IO uint32_t DHTMEM96; // @1244 JPEG DHTMem tables
	__IO uint32_t DHTMEM97; // @1248 JPEG DHTMem tables
	__IO uint32_t DHTMEM98; // @1252 JPEG DHTMem tables
	__IO uint32_t DHTMEM99; // @1256 JPEG DHTMem tables
	__IO uint32_t DHTMEM100; // @1260 JPEG DHTMem tables
	__IO uint32_t DHTMEM101; // @1264 JPEG DHTMem tables
	__IO uint32_t DHTMEM102; // @1268 JPEG DHTMem tables
	__IO uint32_t DHTMEM103; // @1272 JPEG DHTMem tables
	 uint8_t RESERVED9[4]; // @1276 
	__IO uint32_t HUFFENC_AC0_0; // @1280 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_1; // @1284 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_2; // @1288 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_3; // @1292 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_4; // @1296 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_5; // @1300 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_6; // @1304 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_7; // @1308 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_8; // @1312 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_9; // @1316 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_10; // @1320 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_11; // @1324 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_12; // @1328 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_13; // @1332 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_14; // @1336 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_15; // @1340 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_16; // @1344 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_17; // @1348 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_18; // @1352 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_19; // @1356 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_20; // @1360 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_21; // @1364 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_22; // @1368 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_23; // @1372 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_24; // @1376 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_25; // @1380 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_26; // @1384 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_27; // @1388 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_28; // @1392 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_29; // @1396 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_30; // @1400 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_31; // @1404 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_32; // @1408 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_33; // @1412 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_34; // @1416 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_35; // @1420 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_36; // @1424 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_37; // @1428 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_38; // @1432 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_39; // @1436 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_40; // @1440 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_41; // @1444 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_42; // @1448 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_43; // @1452 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_44; // @1456 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_45; // @1460 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_46; // @1464 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_47; // @1468 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_48; // @1472 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_49; // @1476 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_50; // @1480 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_51; // @1484 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_52; // @1488 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_53; // @1492 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_54; // @1496 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_55; // @1500 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_56; // @1504 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_57; // @1508 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_58; // @1512 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_59; // @1516 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_60; // @1520 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_61; // @1524 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_62; // @1528 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_63; // @1532 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_64; // @1536 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_65; // @1540 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_66; // @1544 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_67; // @1548 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_68; // @1552 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_69; // @1556 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_70; // @1560 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_71; // @1564 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_72; // @1568 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_73; // @1572 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_74; // @1576 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_75; // @1580 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_76; // @1584 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_77; // @1588 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_78; // @1592 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_79; // @1596 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_80; // @1600 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_81; // @1604 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_82; // @1608 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_83; // @1612 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_84; // @1616 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_85; // @1620 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_86; // @1624 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC0_87; // @1628 JPEG encoder, AC Huffman table 0
	__IO uint32_t HUFFENC_AC1_0; // @1632 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_1; // @1636 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_2; // @1640 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_3; // @1644 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_4; // @1648 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_5; // @1652 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_6; // @1656 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_7; // @1660 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_8; // @1664 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_9; // @1668 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_10; // @1672 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_11; // @1676 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_12; // @1680 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_13; // @1684 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_14; // @1688 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_15; // @1692 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_16; // @1696 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_17; // @1700 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_18; // @1704 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_19; // @1708 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_20; // @1712 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_21; // @1716 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_22; // @1720 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_23; // @1724 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_24; // @1728 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_25; // @1732 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_26; // @1736 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_27; // @1740 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_28; // @1744 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_29; // @1748 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_30; // @1752 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_31; // @1756 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_32; // @1760 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_33; // @1764 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_34; // @1768 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_35; // @1772 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_36; // @1776 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_37; // @1780 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_38; // @1784 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_39; // @1788 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_40; // @1792 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_41; // @1796 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_42; // @1800 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_43; // @1804 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_44; // @1808 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_45; // @1812 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_46; // @1816 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_47; // @1820 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_48; // @1824 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_49; // @1828 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_50; // @1832 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_51; // @1836 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_52; // @1840 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_53; // @1844 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_54; // @1848 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_55; // @1852 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_56; // @1856 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_57; // @1860 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_58; // @1864 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_59; // @1868 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_60; // @1872 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_61; // @1876 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_62; // @1880 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_63; // @1884 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_64; // @1888 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_65; // @1892 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_66; // @1896 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_67; // @1900 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_68; // @1904 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_69; // @1908 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_70; // @1912 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_71; // @1916 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_72; // @1920 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_73; // @1924 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_74; // @1928 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_75; // @1932 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_76; // @1936 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_77; // @1940 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_78; // @1944 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_79; // @1948 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_80; // @1952 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_81; // @1956 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_82; // @1960 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_83; // @1964 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_84; // @1968 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_85; // @1972 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_86; // @1976 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_AC1_87; // @1980 JPEG encoder, AC Huffman table 1
	__IO uint32_t HUFFENC_DC0_0; // @1984 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_1; // @1988 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_2; // @1992 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_3; // @1996 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_4; // @2000 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_5; // @2004 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_6; // @2008 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC0_7; // @2012 JPEG encoder, DC Huffman table 0
	__IO uint32_t HUFFENC_DC1_0; // @2016 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_1; // @2020 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_2; // @2024 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_3; // @2028 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_4; // @2032 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_5; // @2036 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_6; // @2040 JPEG encoder, DC Huffman table 1
	__IO uint32_t HUFFENC_DC1_7; // @2044 JPEG encoder, DC Huffman table 1
};

// JPEG->CONFR0 JPEG codec configuration register 0
enum {
	JPEG_CONFR0_START = 1UL<<0, // Start		
};

// JPEG->CONFR1 JPEG codec configuration register 1
enum {
	JPEG_CONFR1_YSIZE = ((1UL<<16)-1) << 16, // Y Size
	JPEG_CONFR1_HDR = 1UL<<8, // Header Processing
	JPEG_CONFR1_NS = ((1UL<<2)-1) << 6, // Number of components for Scan
	JPEG_CONFR1_COLORSPACE = ((1UL<<2)-1) << 4, // Color Space
	JPEG_CONFR1_DE = 1UL<<3, // Decoding Enable
	JPEG_CONFR1_NF = ((1UL<<2)-1) << 0, // Number of color components		
};
inline void jpeg_confr1_set_ysize(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_YSIZE) | ((val<<16) & JPEG_CONFR1_YSIZE); }
inline void jpeg_confr1_set_ns(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_NS) | ((val<<6) & JPEG_CONFR1_NS); }
inline void jpeg_confr1_set_colorspace(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_COLORSPACE) | ((val<<4) & JPEG_CONFR1_COLORSPACE); }
inline void jpeg_confr1_set_nf(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_NF) | ((val<<0) & JPEG_CONFR1_NF); }
inline uint32_t jpeg_confr1_get_ysize(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_YSIZE) >> 16 ; }
inline uint32_t jpeg_confr1_get_ns(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_NS) >> 6 ; }
inline uint32_t jpeg_confr1_get_colorspace(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_COLORSPACE) >> 4 ; }
inline uint32_t jpeg_confr1_get_nf(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_NF) >> 0 ; }

// JPEG->CONFR2 JPEG codec configuration register 2
enum {
	JPEG_CONFR2_NMCU = ((1UL<<26)-1) << 0, // Number of MCU		
};
inline void jpeg_confr2_set_nmcu(struct JPEG_Type* p, uint32_t val) { p->CONFR2 = (p->CONFR2 & ~JPEG_CONFR2_NMCU) | ((val<<0) & JPEG_CONFR2_NMCU); }
inline uint32_t jpeg_confr2_get_nmcu(struct JPEG_Type* p) { return (p->CONFR2 & JPEG_CONFR2_NMCU) >> 0 ; }

// JPEG->CONFR3 JPEG codec configuration register 3
enum {
	JPEG_CONFR3_XSIZE = ((1UL<<16)-1) << 16, // X size		
};
inline void jpeg_confr3_set_xsize(struct JPEG_Type* p, uint32_t val) { p->CONFR3 = (p->CONFR3 & ~JPEG_CONFR3_XSIZE) | ((val<<16) & JPEG_CONFR3_XSIZE); }
inline uint32_t jpeg_confr3_get_xsize(struct JPEG_Type* p) { return (p->CONFR3 & JPEG_CONFR3_XSIZE) >> 16 ; }

// JPEG->CONFR4 JPEG codec configuration register 4
enum {
	JPEG_CONFR4_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor
	JPEG_CONFR4_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor
	JPEG_CONFR4_NB = ((1UL<<4)-1) << 4, // Number of Block
	JPEG_CONFR4_QT = ((1UL<<2)-1) << 2, // Quantization Table
	JPEG_CONFR4_HA = 1UL<<1, // Huffman AC
	JPEG_CONFR4_HD = 1UL<<0, // Huffman DC		
};
inline void jpeg_confr4_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFR4 = (p->CONFR4 & ~JPEG_CONFR4_HSF) | ((val<<12) & JPEG_CONFR4_HSF); }
inline void jpeg_confr4_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFR4 = (p->CONFR4 & ~JPEG_CONFR4_VSF) | ((val<<8) & JPEG_CONFR4_VSF); }
inline void jpeg_confr4_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFR4 = (p->CONFR4 & ~JPEG_CONFR4_NB) | ((val<<4) & JPEG_CONFR4_NB); }
inline void jpeg_confr4_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFR4 = (p->CONFR4 & ~JPEG_CONFR4_QT) | ((val<<2) & JPEG_CONFR4_QT); }
inline uint32_t jpeg_confr4_get_hsf(struct JPEG_Type* p) { return (p->CONFR4 & JPEG_CONFR4_HSF) >> 12 ; }
inline uint32_t jpeg_confr4_get_vsf(struct JPEG_Type* p) { return (p->CONFR4 & JPEG_CONFR4_VSF) >> 8 ; }
inline uint32_t jpeg_confr4_get_nb(struct JPEG_Type* p) { return (p->CONFR4 & JPEG_CONFR4_NB) >> 4 ; }
inline uint32_t jpeg_confr4_get_qt(struct JPEG_Type* p) { return (p->CONFR4 & JPEG_CONFR4_QT) >> 2 ; }

// JPEG->CONFR5 JPEG codec configuration register 5
enum {
	JPEG_CONFR5_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor
	JPEG_CONFR5_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor
	JPEG_CONFR5_NB = ((1UL<<4)-1) << 4, // Number of Block
	JPEG_CONFR5_QT = ((1UL<<2)-1) << 2, // Quantization Table
	JPEG_CONFR5_HA = 1UL<<1, // Huffman AC
	JPEG_CONFR5_HD = 1UL<<0, // Huffman DC		
};
inline void jpeg_confr5_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFR5 = (p->CONFR5 & ~JPEG_CONFR5_HSF) | ((val<<12) & JPEG_CONFR5_HSF); }
inline void jpeg_confr5_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFR5 = (p->CONFR5 & ~JPEG_CONFR5_VSF) | ((val<<8) & JPEG_CONFR5_VSF); }
inline void jpeg_confr5_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFR5 = (p->CONFR5 & ~JPEG_CONFR5_NB) | ((val<<4) & JPEG_CONFR5_NB); }
inline void jpeg_confr5_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFR5 = (p->CONFR5 & ~JPEG_CONFR5_QT) | ((val<<2) & JPEG_CONFR5_QT); }
inline uint32_t jpeg_confr5_get_hsf(struct JPEG_Type* p) { return (p->CONFR5 & JPEG_CONFR5_HSF) >> 12 ; }
inline uint32_t jpeg_confr5_get_vsf(struct JPEG_Type* p) { return (p->CONFR5 & JPEG_CONFR5_VSF) >> 8 ; }
inline uint32_t jpeg_confr5_get_nb(struct JPEG_Type* p) { return (p->CONFR5 & JPEG_CONFR5_NB) >> 4 ; }
inline uint32_t jpeg_confr5_get_qt(struct JPEG_Type* p) { return (p->CONFR5 & JPEG_CONFR5_QT) >> 2 ; }

// JPEG->CONFR6 JPEG codec configuration register 6
enum {
	JPEG_CONFR6_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor
	JPEG_CONFR6_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor
	JPEG_CONFR6_NB = ((1UL<<4)-1) << 4, // Number of Block
	JPEG_CONFR6_QT = ((1UL<<2)-1) << 2, // Quantization Table
	JPEG_CONFR6_HA = 1UL<<1, // Huffman AC
	JPEG_CONFR6_HD = 1UL<<0, // Huffman DC		
};
inline void jpeg_confr6_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFR6 = (p->CONFR6 & ~JPEG_CONFR6_HSF) | ((val<<12) & JPEG_CONFR6_HSF); }
inline void jpeg_confr6_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFR6 = (p->CONFR6 & ~JPEG_CONFR6_VSF) | ((val<<8) & JPEG_CONFR6_VSF); }
inline void jpeg_confr6_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFR6 = (p->CONFR6 & ~JPEG_CONFR6_NB) | ((val<<4) & JPEG_CONFR6_NB); }
inline void jpeg_confr6_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFR6 = (p->CONFR6 & ~JPEG_CONFR6_QT) | ((val<<2) & JPEG_CONFR6_QT); }
inline uint32_t jpeg_confr6_get_hsf(struct JPEG_Type* p) { return (p->CONFR6 & JPEG_CONFR6_HSF) >> 12 ; }
inline uint32_t jpeg_confr6_get_vsf(struct JPEG_Type* p) { return (p->CONFR6 & JPEG_CONFR6_VSF) >> 8 ; }
inline uint32_t jpeg_confr6_get_nb(struct JPEG_Type* p) { return (p->CONFR6 & JPEG_CONFR6_NB) >> 4 ; }
inline uint32_t jpeg_confr6_get_qt(struct JPEG_Type* p) { return (p->CONFR6 & JPEG_CONFR6_QT) >> 2 ; }

// JPEG->CONFR7 JPEG codec configuration register 7
enum {
	JPEG_CONFR7_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor
	JPEG_CONFR7_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor
	JPEG_CONFR7_NB = ((1UL<<4)-1) << 4, // Number of Block
	JPEG_CONFR7_QT = ((1UL<<2)-1) << 2, // Quantization Table
	JPEG_CONFR7_HA = 1UL<<1, // Huffman AC
	JPEG_CONFR7_HD = 1UL<<0, // Huffman DC		
};
inline void jpeg_confr7_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFR7 = (p->CONFR7 & ~JPEG_CONFR7_HSF) | ((val<<12) & JPEG_CONFR7_HSF); }
inline void jpeg_confr7_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFR7 = (p->CONFR7 & ~JPEG_CONFR7_VSF) | ((val<<8) & JPEG_CONFR7_VSF); }
inline void jpeg_confr7_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFR7 = (p->CONFR7 & ~JPEG_CONFR7_NB) | ((val<<4) & JPEG_CONFR7_NB); }
inline void jpeg_confr7_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFR7 = (p->CONFR7 & ~JPEG_CONFR7_QT) | ((val<<2) & JPEG_CONFR7_QT); }
inline uint32_t jpeg_confr7_get_hsf(struct JPEG_Type* p) { return (p->CONFR7 & JPEG_CONFR7_HSF) >> 12 ; }
inline uint32_t jpeg_confr7_get_vsf(struct JPEG_Type* p) { return (p->CONFR7 & JPEG_CONFR7_VSF) >> 8 ; }
inline uint32_t jpeg_confr7_get_nb(struct JPEG_Type* p) { return (p->CONFR7 & JPEG_CONFR7_NB) >> 4 ; }
inline uint32_t jpeg_confr7_get_qt(struct JPEG_Type* p) { return (p->CONFR7 & JPEG_CONFR7_QT) >> 2 ; }

// JPEG->CR JPEG control register
enum {
	JPEG_CR_OFF = 1UL<<14, // Output FIFO Flush
	JPEG_CR_IFF = 1UL<<13, // Input FIFO Flush
	JPEG_CR_ODMAEN = 1UL<<12, // Output DMA Enable
	JPEG_CR_IDMAEN = 1UL<<11, // Input DMA Enable
	JPEG_CR_HPDIE = 1UL<<6, // Header Parsing Done Interrupt Enable
	JPEG_CR_EOCIE = 1UL<<5, // End of Conversion Interrupt Enable
	JPEG_CR_OFNEIE = 1UL<<4, // Output FIFO Not Empty Interrupt Enable
	JPEG_CR_OFTIE = 1UL<<3, // Output FIFO Threshold Interrupt Enable
	JPEG_CR_IFNFIE = 1UL<<2, // Input FIFO Not Full Interrupt Enable
	JPEG_CR_IFTIE = 1UL<<1, // Input FIFO Threshold Interrupt Enable
	JPEG_CR_JCEN = 1UL<<0, // JPEG Core Enable		
};

// JPEG->SR JPEG status register
enum {
	JPEG_SR_COF = 1UL<<7, // Codec Operation Flag
	JPEG_SR_HPDF = 1UL<<6, // Header Parsing Done Flag
	JPEG_SR_EOCF = 1UL<<5, // End of Conversion Flag
	JPEG_SR_OFNEF = 1UL<<4, // Output FIFO Not Empty Flag
	JPEG_SR_OFTF = 1UL<<3, // Output FIFO Threshold Flag
	JPEG_SR_IFNFF = 1UL<<2, // Input FIFO Not Full Flag
	JPEG_SR_IFTF = 1UL<<1, // Input FIFO Threshold Flag		
};

// JPEG->CFR JPEG clear flag register
enum {
	JPEG_CFR_CHPDF = 1UL<<6, // Clear Header Parsing Done Flag
	JPEG_CFR_CEOCF = 1UL<<5, // Clear End of Conversion Flag		
};

// JPEG->HUFFBASE0 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE0_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE0_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase0_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE0 = (p->HUFFBASE0 & ~JPEG_HUFFBASE0_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE0_HUFFBASE_RAM_1); }
inline void jpeg_huffbase0_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE0 = (p->HUFFBASE0 & ~JPEG_HUFFBASE0_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE0_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase0_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE0 & JPEG_HUFFBASE0_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase0_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE0 & JPEG_HUFFBASE0_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE1 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE1_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE1_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase1_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE1 = (p->HUFFBASE1 & ~JPEG_HUFFBASE1_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE1_HUFFBASE_RAM_1); }
inline void jpeg_huffbase1_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE1 = (p->HUFFBASE1 & ~JPEG_HUFFBASE1_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE1_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase1_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE1 & JPEG_HUFFBASE1_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase1_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE1 & JPEG_HUFFBASE1_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE2 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE2_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE2_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase2_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE2 = (p->HUFFBASE2 & ~JPEG_HUFFBASE2_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE2_HUFFBASE_RAM_1); }
inline void jpeg_huffbase2_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE2 = (p->HUFFBASE2 & ~JPEG_HUFFBASE2_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE2_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase2_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE2 & JPEG_HUFFBASE2_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase2_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE2 & JPEG_HUFFBASE2_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE3 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE3_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE3_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase3_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE3 = (p->HUFFBASE3 & ~JPEG_HUFFBASE3_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE3_HUFFBASE_RAM_1); }
inline void jpeg_huffbase3_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE3 = (p->HUFFBASE3 & ~JPEG_HUFFBASE3_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE3_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase3_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE3 & JPEG_HUFFBASE3_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase3_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE3 & JPEG_HUFFBASE3_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE4 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE4_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE4_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase4_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE4 = (p->HUFFBASE4 & ~JPEG_HUFFBASE4_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE4_HUFFBASE_RAM_1); }
inline void jpeg_huffbase4_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE4 = (p->HUFFBASE4 & ~JPEG_HUFFBASE4_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE4_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase4_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE4 & JPEG_HUFFBASE4_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase4_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE4 & JPEG_HUFFBASE4_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE5 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE5_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE5_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase5_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE5 = (p->HUFFBASE5 & ~JPEG_HUFFBASE5_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE5_HUFFBASE_RAM_1); }
inline void jpeg_huffbase5_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE5 = (p->HUFFBASE5 & ~JPEG_HUFFBASE5_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE5_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase5_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE5 & JPEG_HUFFBASE5_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase5_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE5 & JPEG_HUFFBASE5_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE6 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE6_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE6_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase6_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE6 = (p->HUFFBASE6 & ~JPEG_HUFFBASE6_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE6_HUFFBASE_RAM_1); }
inline void jpeg_huffbase6_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE6 = (p->HUFFBASE6 & ~JPEG_HUFFBASE6_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE6_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase6_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE6 & JPEG_HUFFBASE6_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase6_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE6 & JPEG_HUFFBASE6_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE7 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE7_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE7_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase7_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE7 = (p->HUFFBASE7 & ~JPEG_HUFFBASE7_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE7_HUFFBASE_RAM_1); }
inline void jpeg_huffbase7_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE7 = (p->HUFFBASE7 & ~JPEG_HUFFBASE7_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE7_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase7_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE7 & JPEG_HUFFBASE7_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase7_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE7 & JPEG_HUFFBASE7_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE8 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE8_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE8_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase8_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE8 = (p->HUFFBASE8 & ~JPEG_HUFFBASE8_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE8_HUFFBASE_RAM_1); }
inline void jpeg_huffbase8_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE8 = (p->HUFFBASE8 & ~JPEG_HUFFBASE8_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE8_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase8_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE8 & JPEG_HUFFBASE8_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase8_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE8 & JPEG_HUFFBASE8_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE9 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE9_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE9_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase9_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE9 = (p->HUFFBASE9 & ~JPEG_HUFFBASE9_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE9_HUFFBASE_RAM_1); }
inline void jpeg_huffbase9_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE9 = (p->HUFFBASE9 & ~JPEG_HUFFBASE9_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE9_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase9_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE9 & JPEG_HUFFBASE9_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase9_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE9 & JPEG_HUFFBASE9_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE10 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE10_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE10_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase10_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE10 = (p->HUFFBASE10 & ~JPEG_HUFFBASE10_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE10_HUFFBASE_RAM_1); }
inline void jpeg_huffbase10_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE10 = (p->HUFFBASE10 & ~JPEG_HUFFBASE10_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE10_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase10_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE10 & JPEG_HUFFBASE10_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase10_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE10 & JPEG_HUFFBASE10_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE11 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE11_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE11_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase11_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE11 = (p->HUFFBASE11 & ~JPEG_HUFFBASE11_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE11_HUFFBASE_RAM_1); }
inline void jpeg_huffbase11_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE11 = (p->HUFFBASE11 & ~JPEG_HUFFBASE11_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE11_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase11_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE11 & JPEG_HUFFBASE11_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase11_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE11 & JPEG_HUFFBASE11_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE12 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE12_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE12_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase12_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE12 = (p->HUFFBASE12 & ~JPEG_HUFFBASE12_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE12_HUFFBASE_RAM_1); }
inline void jpeg_huffbase12_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE12 = (p->HUFFBASE12 & ~JPEG_HUFFBASE12_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE12_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase12_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE12 & JPEG_HUFFBASE12_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase12_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE12 & JPEG_HUFFBASE12_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE13 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE13_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE13_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase13_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE13 = (p->HUFFBASE13 & ~JPEG_HUFFBASE13_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE13_HUFFBASE_RAM_1); }
inline void jpeg_huffbase13_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE13 = (p->HUFFBASE13 & ~JPEG_HUFFBASE13_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE13_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase13_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE13 & JPEG_HUFFBASE13_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase13_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE13 & JPEG_HUFFBASE13_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE14 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE14_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE14_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase14_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE14 = (p->HUFFBASE14 & ~JPEG_HUFFBASE14_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE14_HUFFBASE_RAM_1); }
inline void jpeg_huffbase14_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE14 = (p->HUFFBASE14 & ~JPEG_HUFFBASE14_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE14_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase14_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE14 & JPEG_HUFFBASE14_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase14_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE14 & JPEG_HUFFBASE14_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE15 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE15_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE15_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase15_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE15 = (p->HUFFBASE15 & ~JPEG_HUFFBASE15_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE15_HUFFBASE_RAM_1); }
inline void jpeg_huffbase15_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE15 = (p->HUFFBASE15 & ~JPEG_HUFFBASE15_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE15_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase15_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE15 & JPEG_HUFFBASE15_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase15_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE15 & JPEG_HUFFBASE15_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE16 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE16_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE16_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase16_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE16 = (p->HUFFBASE16 & ~JPEG_HUFFBASE16_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE16_HUFFBASE_RAM_1); }
inline void jpeg_huffbase16_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE16 = (p->HUFFBASE16 & ~JPEG_HUFFBASE16_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE16_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase16_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE16 & JPEG_HUFFBASE16_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase16_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE16 & JPEG_HUFFBASE16_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE17 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE17_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE17_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase17_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE17 = (p->HUFFBASE17 & ~JPEG_HUFFBASE17_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE17_HUFFBASE_RAM_1); }
inline void jpeg_huffbase17_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE17 = (p->HUFFBASE17 & ~JPEG_HUFFBASE17_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE17_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase17_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE17 & JPEG_HUFFBASE17_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase17_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE17 & JPEG_HUFFBASE17_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE18 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE18_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE18_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase18_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE18 = (p->HUFFBASE18 & ~JPEG_HUFFBASE18_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE18_HUFFBASE_RAM_1); }
inline void jpeg_huffbase18_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE18 = (p->HUFFBASE18 & ~JPEG_HUFFBASE18_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE18_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase18_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE18 & JPEG_HUFFBASE18_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase18_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE18 & JPEG_HUFFBASE18_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE19 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE19_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE19_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase19_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE19 = (p->HUFFBASE19 & ~JPEG_HUFFBASE19_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE19_HUFFBASE_RAM_1); }
inline void jpeg_huffbase19_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE19 = (p->HUFFBASE19 & ~JPEG_HUFFBASE19_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE19_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase19_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE19 & JPEG_HUFFBASE19_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase19_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE19 & JPEG_HUFFBASE19_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE20 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE20_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE20_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase20_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE20 = (p->HUFFBASE20 & ~JPEG_HUFFBASE20_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE20_HUFFBASE_RAM_1); }
inline void jpeg_huffbase20_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE20 = (p->HUFFBASE20 & ~JPEG_HUFFBASE20_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE20_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase20_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE20 & JPEG_HUFFBASE20_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase20_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE20 & JPEG_HUFFBASE20_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE21 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE21_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE21_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase21_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE21 = (p->HUFFBASE21 & ~JPEG_HUFFBASE21_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE21_HUFFBASE_RAM_1); }
inline void jpeg_huffbase21_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE21 = (p->HUFFBASE21 & ~JPEG_HUFFBASE21_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE21_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase21_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE21 & JPEG_HUFFBASE21_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase21_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE21 & JPEG_HUFFBASE21_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE22 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE22_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE22_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase22_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE22 = (p->HUFFBASE22 & ~JPEG_HUFFBASE22_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE22_HUFFBASE_RAM_1); }
inline void jpeg_huffbase22_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE22 = (p->HUFFBASE22 & ~JPEG_HUFFBASE22_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE22_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase22_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE22 & JPEG_HUFFBASE22_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase22_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE22 & JPEG_HUFFBASE22_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE23 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE23_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE23_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase23_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE23 = (p->HUFFBASE23 & ~JPEG_HUFFBASE23_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE23_HUFFBASE_RAM_1); }
inline void jpeg_huffbase23_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE23 = (p->HUFFBASE23 & ~JPEG_HUFFBASE23_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE23_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase23_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE23 & JPEG_HUFFBASE23_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase23_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE23 & JPEG_HUFFBASE23_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE24 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE24_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE24_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase24_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE24 = (p->HUFFBASE24 & ~JPEG_HUFFBASE24_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE24_HUFFBASE_RAM_1); }
inline void jpeg_huffbase24_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE24 = (p->HUFFBASE24 & ~JPEG_HUFFBASE24_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE24_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase24_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE24 & JPEG_HUFFBASE24_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase24_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE24 & JPEG_HUFFBASE24_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE25 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE25_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE25_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase25_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE25 = (p->HUFFBASE25 & ~JPEG_HUFFBASE25_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE25_HUFFBASE_RAM_1); }
inline void jpeg_huffbase25_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE25 = (p->HUFFBASE25 & ~JPEG_HUFFBASE25_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE25_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase25_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE25 & JPEG_HUFFBASE25_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase25_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE25 & JPEG_HUFFBASE25_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE26 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE26_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE26_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase26_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE26 = (p->HUFFBASE26 & ~JPEG_HUFFBASE26_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE26_HUFFBASE_RAM_1); }
inline void jpeg_huffbase26_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE26 = (p->HUFFBASE26 & ~JPEG_HUFFBASE26_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE26_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase26_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE26 & JPEG_HUFFBASE26_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase26_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE26 & JPEG_HUFFBASE26_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE27 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE27_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE27_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase27_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE27 = (p->HUFFBASE27 & ~JPEG_HUFFBASE27_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE27_HUFFBASE_RAM_1); }
inline void jpeg_huffbase27_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE27 = (p->HUFFBASE27 & ~JPEG_HUFFBASE27_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE27_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase27_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE27 & JPEG_HUFFBASE27_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase27_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE27 & JPEG_HUFFBASE27_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE28 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE28_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE28_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase28_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE28 = (p->HUFFBASE28 & ~JPEG_HUFFBASE28_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE28_HUFFBASE_RAM_1); }
inline void jpeg_huffbase28_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE28 = (p->HUFFBASE28 & ~JPEG_HUFFBASE28_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE28_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase28_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE28 & JPEG_HUFFBASE28_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase28_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE28 & JPEG_HUFFBASE28_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE29 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE29_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE29_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase29_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE29 = (p->HUFFBASE29 & ~JPEG_HUFFBASE29_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE29_HUFFBASE_RAM_1); }
inline void jpeg_huffbase29_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE29 = (p->HUFFBASE29 & ~JPEG_HUFFBASE29_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE29_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase29_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE29 & JPEG_HUFFBASE29_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase29_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE29 & JPEG_HUFFBASE29_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE30 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE30_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE30_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase30_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE30 = (p->HUFFBASE30 & ~JPEG_HUFFBASE30_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE30_HUFFBASE_RAM_1); }
inline void jpeg_huffbase30_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE30 = (p->HUFFBASE30 & ~JPEG_HUFFBASE30_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE30_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase30_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE30 & JPEG_HUFFBASE30_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase30_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE30 & JPEG_HUFFBASE30_HUFFBASE_RAM_0) >> 0 ; }

// JPEG->HUFFBASE31 JPEG HuffSymb tables
enum {
	JPEG_HUFFBASE31_HUFFBASE_RAM_1 = ((1UL<<9)-1) << 16, // HuffBase RAM
	JPEG_HUFFBASE31_HUFFBASE_RAM_0 = ((1UL<<9)-1) << 0, // HuffBase RAM		
};
inline void jpeg_huffbase31_set_huffbase_ram_1(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE31 = (p->HUFFBASE31 & ~JPEG_HUFFBASE31_HUFFBASE_RAM_1) | ((val<<16) & JPEG_HUFFBASE31_HUFFBASE_RAM_1); }
inline void jpeg_huffbase31_set_huffbase_ram_0(struct JPEG_Type* p, uint32_t val) { p->HUFFBASE31 = (p->HUFFBASE31 & ~JPEG_HUFFBASE31_HUFFBASE_RAM_0) | ((val<<0) & JPEG_HUFFBASE31_HUFFBASE_RAM_0); }
inline uint32_t jpeg_huffbase31_get_huffbase_ram_1(struct JPEG_Type* p) { return (p->HUFFBASE31 & JPEG_HUFFBASE31_HUFFBASE_RAM_1) >> 16 ; }
inline uint32_t jpeg_huffbase31_get_huffbase_ram_0(struct JPEG_Type* p) { return (p->HUFFBASE31 & JPEG_HUFFBASE31_HUFFBASE_RAM_0) >> 0 ; }

/* Low power timer */
struct LPTIM1_Type {
	__I uint8_t ISR; // @0 Interrupt and Status Register
	 uint8_t RESERVED0[3]; // @1 
	__O uint8_t ICR; // @4 Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t IER; // @8 Interrupt Enable Register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint32_t CFGR; // @12 Configuration Register
	__IO uint8_t CR; // @16 Control Register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t CMP; // @20 Compare Register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t ARR; // @24 Autoreload Register
	 uint8_t RESERVED5[2]; // @26 
	__I uint16_t CNT; // @28 Counter Register
};

// LPTIM1->ISR Interrupt and Status Register
enum {
	LPTIM1_ISR_DOWN = 1UL<<6, // Counter direction change up to down
	LPTIM1_ISR_UP = 1UL<<5, // Counter direction change down to up
	LPTIM1_ISR_ARROK = 1UL<<4, // Autoreload register update OK
	LPTIM1_ISR_CMPOK = 1UL<<3, // Compare register update OK
	LPTIM1_ISR_EXTTRIG = 1UL<<2, // External trigger edge event
	LPTIM1_ISR_ARRM = 1UL<<1, // Autoreload match
	LPTIM1_ISR_CMPM = 1UL<<0, // Compare match		
};

// LPTIM1->ICR Interrupt Clear Register
enum {
	LPTIM1_ICR_DOWNCF = 1UL<<6, // Direction change to down Clear Flag
	LPTIM1_ICR_UPCF = 1UL<<5, // Direction change to UP Clear Flag
	LPTIM1_ICR_ARROKCF = 1UL<<4, // Autoreload register update OK Clear Flag
	LPTIM1_ICR_CMPOKCF = 1UL<<3, // Compare register update OK Clear Flag
	LPTIM1_ICR_EXTTRIGCF = 1UL<<2, // External trigger valid edge Clear Flag
	LPTIM1_ICR_ARRMCF = 1UL<<1, // Autoreload match Clear Flag
	LPTIM1_ICR_CMPMCF = 1UL<<0, // compare match Clear Flag		
};

// LPTIM1->IER Interrupt Enable Register
enum {
	LPTIM1_IER_DOWNIE = 1UL<<6, // Direction change to down Interrupt Enable
	LPTIM1_IER_UPIE = 1UL<<5, // Direction change to UP Interrupt Enable
	LPTIM1_IER_ARROKIE = 1UL<<4, // Autoreload register update OK Interrupt Enable
	LPTIM1_IER_CMPOKIE = 1UL<<3, // Compare register update OK Interrupt Enable
	LPTIM1_IER_EXTTRIGIE = 1UL<<2, // External trigger valid edge Interrupt Enable
	LPTIM1_IER_ARRMIE = 1UL<<1, // Autoreload match Interrupt Enable
	LPTIM1_IER_CMPMIE = 1UL<<0, // Compare match Interrupt Enable		
};

// LPTIM1->CFGR Configuration Register
enum {
	LPTIM1_CFGR_ENC = 1UL<<24, // Encoder mode enable
	LPTIM1_CFGR_COUNTMODE = 1UL<<23, // counter mode enabled
	LPTIM1_CFGR_PRELOAD = 1UL<<22, // Registers update mode
	LPTIM1_CFGR_WAVPOL = 1UL<<21, // Waveform shape polarity
	LPTIM1_CFGR_WAVE = 1UL<<20, // Waveform shape
	LPTIM1_CFGR_TIMOUT = 1UL<<19, // Timeout enable
	LPTIM1_CFGR_TRIGEN = ((1UL<<2)-1) << 17, // Trigger enable and polarity
	LPTIM1_CFGR_TRIGSEL = ((1UL<<3)-1) << 13, // Trigger selector
	LPTIM1_CFGR_PRESC = ((1UL<<3)-1) << 9, // Clock prescaler
	LPTIM1_CFGR_TRGFLT = ((1UL<<2)-1) << 6, // Configurable digital filter for trigger
	LPTIM1_CFGR_CKFLT = ((1UL<<2)-1) << 3, // Configurable digital filter for external clock
	LPTIM1_CFGR_CKPOL = ((1UL<<2)-1) << 1, // Clock Polarity
	LPTIM1_CFGR_CKSEL = 1UL<<0, // Clock selector		
};
inline void lptim1_cfgr_set_trigen(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGEN) | ((val<<17) & LPTIM1_CFGR_TRIGEN); }
inline void lptim1_cfgr_set_trigsel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGSEL) | ((val<<13) & LPTIM1_CFGR_TRIGSEL); }
inline void lptim1_cfgr_set_presc(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_PRESC) | ((val<<9) & LPTIM1_CFGR_PRESC); }
inline void lptim1_cfgr_set_trgflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRGFLT) | ((val<<6) & LPTIM1_CFGR_TRGFLT); }
inline void lptim1_cfgr_set_ckflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKFLT) | ((val<<3) & LPTIM1_CFGR_CKFLT); }
inline void lptim1_cfgr_set_ckpol(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKPOL) | ((val<<1) & LPTIM1_CFGR_CKPOL); }
inline uint32_t lptim1_cfgr_get_trigen(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGEN) >> 17 ; }
inline uint32_t lptim1_cfgr_get_trigsel(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGSEL) >> 13 ; }
inline uint32_t lptim1_cfgr_get_presc(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_PRESC) >> 9 ; }
inline uint32_t lptim1_cfgr_get_trgflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRGFLT) >> 6 ; }
inline uint32_t lptim1_cfgr_get_ckflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKFLT) >> 3 ; }
inline uint32_t lptim1_cfgr_get_ckpol(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKPOL) >> 1 ; }

// LPTIM1->CR Control Register
enum {
	LPTIM1_CR_CNTSTRT = 1UL<<2, // Timer start in continuous mode
	LPTIM1_CR_SNGSTRT = 1UL<<1, // LPTIM start in single mode
	LPTIM1_CR_ENABLE = 1UL<<0, // LPTIM Enable		
};

/* LCD-TFT Controller */
struct LTCD_Type {
	 uint8_t RESERVED0[8]; // @0 
	__IO uint32_t SSCR; // @8 Synchronization Size Configuration Register
	__IO uint32_t BPCR; // @12 Back Porch Configuration Register
	__IO uint32_t AWCR; // @16 Active Width Configuration Register
	__IO uint32_t TWCR; // @20 Total Width Configuration Register
	__IO uint32_t GCR; // @24 Global Control Register
	 uint8_t RESERVED1[8]; // @28 
	__IO uint8_t SRCR; // @36 Shadow Reload Configuration Register
	 uint8_t RESERVED2[7]; // @37 
	__IO uint32_t BCCR; // @44 Background Color Configuration Register
	 uint8_t RESERVED3[4]; // @48 
	__IO uint8_t IER; // @52 Interrupt Enable Register
	 uint8_t RESERVED4[3]; // @53 
	__I uint8_t ISR; // @56 Interrupt Status Register
	 uint8_t RESERVED5[3]; // @57 
	__O uint8_t ICR; // @60 Interrupt Clear Register
	 uint8_t RESERVED6[3]; // @61 
	__IO uint16_t LIPCR; // @64 Line Interrupt Position Configuration Register
	 uint8_t RESERVED7[2]; // @66 
	__I uint32_t CPSR; // @68 Current Position Status Register
	__I uint8_t CDSR; // @72 Current Display Status Register
	 uint8_t RESERVED8[59]; // @73 
	__IO uint8_t L1CR; // @132 Layerx Control Register
	 uint8_t RESERVED9[3]; // @133 
	__IO uint32_t L1WHPCR; // @136 Layerx Window Horizontal Position Configuration Register
	__IO uint32_t L1WVPCR; // @140 Layerx Window Vertical Position Configuration Register
	__IO uint32_t L1CKCR; // @144 Layerx Color Keying Configuration Register
	__IO uint8_t L1PFCR; // @148 Layerx Pixel Format Configuration Register
	 uint8_t RESERVED10[3]; // @149 
	__IO uint8_t L1CACR; // @152 Layerx Constant Alpha Configuration Register
	 uint8_t RESERVED11[3]; // @153 
	__IO uint32_t L1DCCR; // @156 Layerx Default Color Configuration Register
	__IO uint16_t L1BFCR; // @160 Layerx Blending Factors Configuration Register
	 uint8_t RESERVED12[10]; // @162 
	__IO uint32_t L1CFBAR; // @172 Layerx Color Frame Buffer Address Register
	__IO uint32_t L1CFBLR; // @176 Layerx Color Frame Buffer Length Register
	__IO uint16_t L1CFBLNR; // @180 Layerx ColorFrame Buffer Line Number Register
	 uint8_t RESERVED13[14]; // @182 
	__O uint32_t L1CLUTWR; // @196 Layerx CLUT Write Register
	 uint8_t RESERVED14[60]; // @200 
	__IO uint8_t L2CR; // @260 Layerx Control Register
	 uint8_t RESERVED15[3]; // @261 
	__IO uint32_t L2WHPCR; // @264 Layerx Window Horizontal Position Configuration Register
	__IO uint32_t L2WVPCR; // @268 Layerx Window Vertical Position Configuration Register
	__IO uint32_t L2CKCR; // @272 Layerx Color Keying Configuration Register
	__IO uint8_t L2PFCR; // @276 Layerx Pixel Format Configuration Register
	 uint8_t RESERVED16[3]; // @277 
	__IO uint8_t L2CACR; // @280 Layerx Constant Alpha Configuration Register
	 uint8_t RESERVED17[3]; // @281 
	__IO uint32_t L2DCCR; // @284 Layerx Default Color Configuration Register
	__IO uint16_t L2BFCR; // @288 Layerx Blending Factors Configuration Register
	 uint8_t RESERVED18[10]; // @290 
	__IO uint32_t L2CFBAR; // @300 Layerx Color Frame Buffer Address Register
	__IO uint32_t L2CFBLR; // @304 Layerx Color Frame Buffer Length Register
	__IO uint16_t L2CFBLNR; // @308 Layerx ColorFrame Buffer Line Number Register
	 uint8_t RESERVED19[14]; // @310 
	__O uint32_t L2CLUTWR; // @324 Layerx CLUT Write Register
};

// LTCD->SSCR Synchronization Size Configuration Register
enum {
	LTCD_SSCR_HSW = ((1UL<<10)-1) << 16, // Horizontal Synchronization Width (in units of pixel clock period)
	LTCD_SSCR_VSH = ((1UL<<11)-1) << 0, // Vertical Synchronization Height (in units of horizontal scan line)		
};
inline void ltcd_sscr_set_hsw(struct LTCD_Type* p, uint32_t val) { p->SSCR = (p->SSCR & ~LTCD_SSCR_HSW) | ((val<<16) & LTCD_SSCR_HSW); }
inline void ltcd_sscr_set_vsh(struct LTCD_Type* p, uint32_t val) { p->SSCR = (p->SSCR & ~LTCD_SSCR_VSH) | ((val<<0) & LTCD_SSCR_VSH); }
inline uint32_t ltcd_sscr_get_hsw(struct LTCD_Type* p) { return (p->SSCR & LTCD_SSCR_HSW) >> 16 ; }
inline uint32_t ltcd_sscr_get_vsh(struct LTCD_Type* p) { return (p->SSCR & LTCD_SSCR_VSH) >> 0 ; }

// LTCD->BPCR Back Porch Configuration Register
enum {
	LTCD_BPCR_AHBP = ((1UL<<10)-1) << 16, // Accumulated Horizontal back porch (in units of pixel clock period)
	LTCD_BPCR_AVBP = ((1UL<<11)-1) << 0, // Accumulated Vertical back porch (in units of horizontal scan line)		
};
inline void ltcd_bpcr_set_ahbp(struct LTCD_Type* p, uint32_t val) { p->BPCR = (p->BPCR & ~LTCD_BPCR_AHBP) | ((val<<16) & LTCD_BPCR_AHBP); }
inline void ltcd_bpcr_set_avbp(struct LTCD_Type* p, uint32_t val) { p->BPCR = (p->BPCR & ~LTCD_BPCR_AVBP) | ((val<<0) & LTCD_BPCR_AVBP); }
inline uint32_t ltcd_bpcr_get_ahbp(struct LTCD_Type* p) { return (p->BPCR & LTCD_BPCR_AHBP) >> 16 ; }
inline uint32_t ltcd_bpcr_get_avbp(struct LTCD_Type* p) { return (p->BPCR & LTCD_BPCR_AVBP) >> 0 ; }

// LTCD->AWCR Active Width Configuration Register
enum {
	LTCD_AWCR_AAV = ((1UL<<10)-1) << 16, // AAV
	LTCD_AWCR_AAH = ((1UL<<11)-1) << 0, // Accumulated Active Height (in units of horizontal scan line)		
};
inline void ltcd_awcr_set_aav(struct LTCD_Type* p, uint32_t val) { p->AWCR = (p->AWCR & ~LTCD_AWCR_AAV) | ((val<<16) & LTCD_AWCR_AAV); }
inline void ltcd_awcr_set_aah(struct LTCD_Type* p, uint32_t val) { p->AWCR = (p->AWCR & ~LTCD_AWCR_AAH) | ((val<<0) & LTCD_AWCR_AAH); }
inline uint32_t ltcd_awcr_get_aav(struct LTCD_Type* p) { return (p->AWCR & LTCD_AWCR_AAV) >> 16 ; }
inline uint32_t ltcd_awcr_get_aah(struct LTCD_Type* p) { return (p->AWCR & LTCD_AWCR_AAH) >> 0 ; }

// LTCD->TWCR Total Width Configuration Register
enum {
	LTCD_TWCR_TOTALW = ((1UL<<10)-1) << 16, // Total Width (in units of pixel clock period)
	LTCD_TWCR_TOTALH = ((1UL<<11)-1) << 0, // Total Height (in units of horizontal scan line)		
};
inline void ltcd_twcr_set_totalw(struct LTCD_Type* p, uint32_t val) { p->TWCR = (p->TWCR & ~LTCD_TWCR_TOTALW) | ((val<<16) & LTCD_TWCR_TOTALW); }
inline void ltcd_twcr_set_totalh(struct LTCD_Type* p, uint32_t val) { p->TWCR = (p->TWCR & ~LTCD_TWCR_TOTALH) | ((val<<0) & LTCD_TWCR_TOTALH); }
inline uint32_t ltcd_twcr_get_totalw(struct LTCD_Type* p) { return (p->TWCR & LTCD_TWCR_TOTALW) >> 16 ; }
inline uint32_t ltcd_twcr_get_totalh(struct LTCD_Type* p) { return (p->TWCR & LTCD_TWCR_TOTALH) >> 0 ; }

// LTCD->GCR Global Control Register
enum {
	LTCD_GCR_HSPOL = 1UL<<31, // Horizontal Synchronization Polarity
	LTCD_GCR_VSPOL = 1UL<<30, // Vertical Synchronization Polarity
	LTCD_GCR_DEPOL = 1UL<<29, // Data Enable Polarity
	LTCD_GCR_PCPOL = 1UL<<28, // Pixel Clock Polarity
	LTCD_GCR_DEN = 1UL<<16, // Dither Enable
	LTCD_GCR_DRW = ((1UL<<3)-1) << 12, // Dither Red Width
	LTCD_GCR_DGW = ((1UL<<3)-1) << 8, // Dither Green Width
	LTCD_GCR_DBW = ((1UL<<3)-1) << 4, // Dither Blue Width
	LTCD_GCR_LTDCEN = 1UL<<0, // LCD-TFT controller enable bit		
};
inline void ltcd_gcr_set_drw(struct LTCD_Type* p, uint32_t val) { p->GCR = (p->GCR & ~LTCD_GCR_DRW) | ((val<<12) & LTCD_GCR_DRW); }
inline void ltcd_gcr_set_dgw(struct LTCD_Type* p, uint32_t val) { p->GCR = (p->GCR & ~LTCD_GCR_DGW) | ((val<<8) & LTCD_GCR_DGW); }
inline void ltcd_gcr_set_dbw(struct LTCD_Type* p, uint32_t val) { p->GCR = (p->GCR & ~LTCD_GCR_DBW) | ((val<<4) & LTCD_GCR_DBW); }
inline uint32_t ltcd_gcr_get_drw(struct LTCD_Type* p) { return (p->GCR & LTCD_GCR_DRW) >> 12 ; }
inline uint32_t ltcd_gcr_get_dgw(struct LTCD_Type* p) { return (p->GCR & LTCD_GCR_DGW) >> 8 ; }
inline uint32_t ltcd_gcr_get_dbw(struct LTCD_Type* p) { return (p->GCR & LTCD_GCR_DBW) >> 4 ; }

// LTCD->SRCR Shadow Reload Configuration Register
enum {
	LTCD_SRCR_VBR = 1UL<<1, // Vertical Blanking Reload
	LTCD_SRCR_IMR = 1UL<<0, // Immediate Reload		
};

// LTCD->BCCR Background Color Configuration Register
enum {
	LTCD_BCCR_BC = ((1UL<<24)-1) << 0, // Background Color Red value		
};
inline void ltcd_bccr_set_bc(struct LTCD_Type* p, uint32_t val) { p->BCCR = (p->BCCR & ~LTCD_BCCR_BC) | ((val<<0) & LTCD_BCCR_BC); }
inline uint32_t ltcd_bccr_get_bc(struct LTCD_Type* p) { return (p->BCCR & LTCD_BCCR_BC) >> 0 ; }

// LTCD->IER Interrupt Enable Register
enum {
	LTCD_IER_RRIE = 1UL<<3, // Register Reload interrupt enable
	LTCD_IER_TERRIE = 1UL<<2, // Transfer Error Interrupt Enable
	LTCD_IER_FUIE = 1UL<<1, // FIFO Underrun Interrupt Enable
	LTCD_IER_LIE = 1UL<<0, // Line Interrupt Enable		
};

// LTCD->ISR Interrupt Status Register
enum {
	LTCD_ISR_RRIF = 1UL<<3, // Register Reload Interrupt Flag
	LTCD_ISR_TERRIF = 1UL<<2, // Transfer Error interrupt flag
	LTCD_ISR_FUIF = 1UL<<1, // FIFO Underrun Interrupt flag
	LTCD_ISR_LIF = 1UL<<0, // Line Interrupt flag		
};

// LTCD->ICR Interrupt Clear Register
enum {
	LTCD_ICR_CRRIF = 1UL<<3, // Clears Register Reload Interrupt Flag
	LTCD_ICR_CTERRIF = 1UL<<2, // Clears the Transfer Error Interrupt Flag
	LTCD_ICR_CFUIF = 1UL<<1, // Clears the FIFO Underrun Interrupt flag
	LTCD_ICR_CLIF = 1UL<<0, // Clears the Line Interrupt Flag		
};

// LTCD->LIPCR Line Interrupt Position Configuration Register
enum {
	LTCD_LIPCR_LIPOS = ((1UL<<11)-1) << 0, // Line Interrupt Position		
};
inline void ltcd_lipcr_set_lipos(struct LTCD_Type* p, uint32_t val) { p->LIPCR = (p->LIPCR & ~LTCD_LIPCR_LIPOS) | ((val<<0) & LTCD_LIPCR_LIPOS); }
inline uint32_t ltcd_lipcr_get_lipos(struct LTCD_Type* p) { return (p->LIPCR & LTCD_LIPCR_LIPOS) >> 0 ; }

// LTCD->CPSR Current Position Status Register
enum {
	LTCD_CPSR_CXPOS = ((1UL<<16)-1) << 16, // Current X Position
	LTCD_CPSR_CYPOS = ((1UL<<16)-1) << 0, // Current Y Position		
};
inline uint32_t ltcd_cpsr_get_cxpos(struct LTCD_Type* p) { return (p->CPSR & LTCD_CPSR_CXPOS) >> 16 ; }
inline uint32_t ltcd_cpsr_get_cypos(struct LTCD_Type* p) { return (p->CPSR & LTCD_CPSR_CYPOS) >> 0 ; }

// LTCD->CDSR Current Display Status Register
enum {
	LTCD_CDSR_HSYNCS = 1UL<<3, // Horizontal Synchronization display Status
	LTCD_CDSR_VSYNCS = 1UL<<2, // Vertical Synchronization display Status
	LTCD_CDSR_HDES = 1UL<<1, // Horizontal Data Enable display Status
	LTCD_CDSR_VDES = 1UL<<0, // Vertical Data Enable display Status		
};

// LTCD->L1CR Layerx Control Register
enum {
	LTCD_L1CR_CLUTEN = 1UL<<4, // Color Look-Up Table Enable
	LTCD_L1CR_COLKEN = 1UL<<1, // Color Keying Enable
	LTCD_L1CR_LEN = 1UL<<0, // Layer Enable		
};

// LTCD->L1WHPCR Layerx Window Horizontal Position Configuration Register
enum {
	LTCD_L1WHPCR_WHSPPOS = ((1UL<<12)-1) << 16, // Window Horizontal Stop Position
	LTCD_L1WHPCR_WHSTPOS = ((1UL<<12)-1) << 0, // Window Horizontal Start Position		
};
inline void ltcd_l1whpcr_set_whsppos(struct LTCD_Type* p, uint32_t val) { p->L1WHPCR = (p->L1WHPCR & ~LTCD_L1WHPCR_WHSPPOS) | ((val<<16) & LTCD_L1WHPCR_WHSPPOS); }
inline void ltcd_l1whpcr_set_whstpos(struct LTCD_Type* p, uint32_t val) { p->L1WHPCR = (p->L1WHPCR & ~LTCD_L1WHPCR_WHSTPOS) | ((val<<0) & LTCD_L1WHPCR_WHSTPOS); }
inline uint32_t ltcd_l1whpcr_get_whsppos(struct LTCD_Type* p) { return (p->L1WHPCR & LTCD_L1WHPCR_WHSPPOS) >> 16 ; }
inline uint32_t ltcd_l1whpcr_get_whstpos(struct LTCD_Type* p) { return (p->L1WHPCR & LTCD_L1WHPCR_WHSTPOS) >> 0 ; }

// LTCD->L1WVPCR Layerx Window Vertical Position Configuration Register
enum {
	LTCD_L1WVPCR_WVSPPOS = ((1UL<<11)-1) << 16, // Window Vertical Stop Position
	LTCD_L1WVPCR_WVSTPOS = ((1UL<<11)-1) << 0, // Window Vertical Start Position		
};
inline void ltcd_l1wvpcr_set_wvsppos(struct LTCD_Type* p, uint32_t val) { p->L1WVPCR = (p->L1WVPCR & ~LTCD_L1WVPCR_WVSPPOS) | ((val<<16) & LTCD_L1WVPCR_WVSPPOS); }
inline void ltcd_l1wvpcr_set_wvstpos(struct LTCD_Type* p, uint32_t val) { p->L1WVPCR = (p->L1WVPCR & ~LTCD_L1WVPCR_WVSTPOS) | ((val<<0) & LTCD_L1WVPCR_WVSTPOS); }
inline uint32_t ltcd_l1wvpcr_get_wvsppos(struct LTCD_Type* p) { return (p->L1WVPCR & LTCD_L1WVPCR_WVSPPOS) >> 16 ; }
inline uint32_t ltcd_l1wvpcr_get_wvstpos(struct LTCD_Type* p) { return (p->L1WVPCR & LTCD_L1WVPCR_WVSTPOS) >> 0 ; }

// LTCD->L1CKCR Layerx Color Keying Configuration Register
enum {
	LTCD_L1CKCR_CKRED = ((1UL<<8)-1) << 16, // Color Key Red value
	LTCD_L1CKCR_CKGREEN = ((1UL<<8)-1) << 8, // Color Key Green value
	LTCD_L1CKCR_CKBLUE = ((1UL<<8)-1) << 0, // Color Key Blue value		
};
inline void ltcd_l1ckcr_set_ckred(struct LTCD_Type* p, uint32_t val) { p->L1CKCR = (p->L1CKCR & ~LTCD_L1CKCR_CKRED) | ((val<<16) & LTCD_L1CKCR_CKRED); }
inline void ltcd_l1ckcr_set_ckgreen(struct LTCD_Type* p, uint32_t val) { p->L1CKCR = (p->L1CKCR & ~LTCD_L1CKCR_CKGREEN) | ((val<<8) & LTCD_L1CKCR_CKGREEN); }
inline void ltcd_l1ckcr_set_ckblue(struct LTCD_Type* p, uint32_t val) { p->L1CKCR = (p->L1CKCR & ~LTCD_L1CKCR_CKBLUE) | ((val<<0) & LTCD_L1CKCR_CKBLUE); }
inline uint32_t ltcd_l1ckcr_get_ckred(struct LTCD_Type* p) { return (p->L1CKCR & LTCD_L1CKCR_CKRED) >> 16 ; }
inline uint32_t ltcd_l1ckcr_get_ckgreen(struct LTCD_Type* p) { return (p->L1CKCR & LTCD_L1CKCR_CKGREEN) >> 8 ; }
inline uint32_t ltcd_l1ckcr_get_ckblue(struct LTCD_Type* p) { return (p->L1CKCR & LTCD_L1CKCR_CKBLUE) >> 0 ; }

// LTCD->L1PFCR Layerx Pixel Format Configuration Register
enum {
	LTCD_L1PFCR_PF = ((1UL<<3)-1) << 0, // Pixel Format		
};
inline void ltcd_l1pfcr_set_pf(struct LTCD_Type* p, uint32_t val) { p->L1PFCR = (p->L1PFCR & ~LTCD_L1PFCR_PF) | ((val<<0) & LTCD_L1PFCR_PF); }
inline uint32_t ltcd_l1pfcr_get_pf(struct LTCD_Type* p) { return (p->L1PFCR & LTCD_L1PFCR_PF) >> 0 ; }

// LTCD->L1DCCR Layerx Default Color Configuration Register
enum {
	LTCD_L1DCCR_DCALPHA = ((1UL<<8)-1) << 24, // Default Color Alpha
	LTCD_L1DCCR_DCRED = ((1UL<<8)-1) << 16, // Default Color Red
	LTCD_L1DCCR_DCGREEN = ((1UL<<8)-1) << 8, // Default Color Green
	LTCD_L1DCCR_DCBLUE = ((1UL<<8)-1) << 0, // Default Color Blue		
};
inline void ltcd_l1dccr_set_dcalpha(struct LTCD_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTCD_L1DCCR_DCALPHA) | ((val<<24) & LTCD_L1DCCR_DCALPHA); }
inline void ltcd_l1dccr_set_dcred(struct LTCD_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTCD_L1DCCR_DCRED) | ((val<<16) & LTCD_L1DCCR_DCRED); }
inline void ltcd_l1dccr_set_dcgreen(struct LTCD_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTCD_L1DCCR_DCGREEN) | ((val<<8) & LTCD_L1DCCR_DCGREEN); }
inline void ltcd_l1dccr_set_dcblue(struct LTCD_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTCD_L1DCCR_DCBLUE) | ((val<<0) & LTCD_L1DCCR_DCBLUE); }
inline uint32_t ltcd_l1dccr_get_dcalpha(struct LTCD_Type* p) { return (p->L1DCCR & LTCD_L1DCCR_DCALPHA) >> 24 ; }
inline uint32_t ltcd_l1dccr_get_dcred(struct LTCD_Type* p) { return (p->L1DCCR & LTCD_L1DCCR_DCRED) >> 16 ; }
inline uint32_t ltcd_l1dccr_get_dcgreen(struct LTCD_Type* p) { return (p->L1DCCR & LTCD_L1DCCR_DCGREEN) >> 8 ; }
inline uint32_t ltcd_l1dccr_get_dcblue(struct LTCD_Type* p) { return (p->L1DCCR & LTCD_L1DCCR_DCBLUE) >> 0 ; }

// LTCD->L1BFCR Layerx Blending Factors Configuration Register
enum {
	LTCD_L1BFCR_BF1 = ((1UL<<3)-1) << 8, // Blending Factor 1
	LTCD_L1BFCR_BF2 = ((1UL<<3)-1) << 0, // Blending Factor 2		
};
inline void ltcd_l1bfcr_set_bf1(struct LTCD_Type* p, uint32_t val) { p->L1BFCR = (p->L1BFCR & ~LTCD_L1BFCR_BF1) | ((val<<8) & LTCD_L1BFCR_BF1); }
inline void ltcd_l1bfcr_set_bf2(struct LTCD_Type* p, uint32_t val) { p->L1BFCR = (p->L1BFCR & ~LTCD_L1BFCR_BF2) | ((val<<0) & LTCD_L1BFCR_BF2); }
inline uint32_t ltcd_l1bfcr_get_bf1(struct LTCD_Type* p) { return (p->L1BFCR & LTCD_L1BFCR_BF1) >> 8 ; }
inline uint32_t ltcd_l1bfcr_get_bf2(struct LTCD_Type* p) { return (p->L1BFCR & LTCD_L1BFCR_BF2) >> 0 ; }

// LTCD->L1CFBLR Layerx Color Frame Buffer Length Register
enum {
	LTCD_L1CFBLR_CFBP = ((1UL<<13)-1) << 16, // Color Frame Buffer Pitch in bytes
	LTCD_L1CFBLR_CFBLL = ((1UL<<13)-1) << 0, // Color Frame Buffer Line Length		
};
inline void ltcd_l1cfblr_set_cfbp(struct LTCD_Type* p, uint32_t val) { p->L1CFBLR = (p->L1CFBLR & ~LTCD_L1CFBLR_CFBP) | ((val<<16) & LTCD_L1CFBLR_CFBP); }
inline void ltcd_l1cfblr_set_cfbll(struct LTCD_Type* p, uint32_t val) { p->L1CFBLR = (p->L1CFBLR & ~LTCD_L1CFBLR_CFBLL) | ((val<<0) & LTCD_L1CFBLR_CFBLL); }
inline uint32_t ltcd_l1cfblr_get_cfbp(struct LTCD_Type* p) { return (p->L1CFBLR & LTCD_L1CFBLR_CFBP) >> 16 ; }
inline uint32_t ltcd_l1cfblr_get_cfbll(struct LTCD_Type* p) { return (p->L1CFBLR & LTCD_L1CFBLR_CFBLL) >> 0 ; }

// LTCD->L1CFBLNR Layerx ColorFrame Buffer Line Number Register
enum {
	LTCD_L1CFBLNR_CFBLNBR = ((1UL<<11)-1) << 0, // Frame Buffer Line Number		
};
inline void ltcd_l1cfblnr_set_cfblnbr(struct LTCD_Type* p, uint32_t val) { p->L1CFBLNR = (p->L1CFBLNR & ~LTCD_L1CFBLNR_CFBLNBR) | ((val<<0) & LTCD_L1CFBLNR_CFBLNBR); }
inline uint32_t ltcd_l1cfblnr_get_cfblnbr(struct LTCD_Type* p) { return (p->L1CFBLNR & LTCD_L1CFBLNR_CFBLNBR) >> 0 ; }

// LTCD->L1CLUTWR Layerx CLUT Write Register
enum {
	LTCD_L1CLUTWR_CLUTADD = ((1UL<<8)-1) << 24, // CLUT Address
	LTCD_L1CLUTWR_RED = ((1UL<<8)-1) << 16, // Red value
	LTCD_L1CLUTWR_GREEN = ((1UL<<8)-1) << 8, // Green value
	LTCD_L1CLUTWR_BLUE = ((1UL<<8)-1) << 0, // Blue value		
};
inline void ltcd_l1clutwr_set_clutadd(struct LTCD_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTCD_L1CLUTWR_CLUTADD) | ((val<<24) & LTCD_L1CLUTWR_CLUTADD); }
inline void ltcd_l1clutwr_set_red(struct LTCD_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTCD_L1CLUTWR_RED) | ((val<<16) & LTCD_L1CLUTWR_RED); }
inline void ltcd_l1clutwr_set_green(struct LTCD_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTCD_L1CLUTWR_GREEN) | ((val<<8) & LTCD_L1CLUTWR_GREEN); }
inline void ltcd_l1clutwr_set_blue(struct LTCD_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTCD_L1CLUTWR_BLUE) | ((val<<0) & LTCD_L1CLUTWR_BLUE); }
inline uint32_t ltcd_l1clutwr_get_clutadd(struct LTCD_Type* p) { return (p->L1CLUTWR & LTCD_L1CLUTWR_CLUTADD) >> 24 ; }
inline uint32_t ltcd_l1clutwr_get_red(struct LTCD_Type* p) { return (p->L1CLUTWR & LTCD_L1CLUTWR_RED) >> 16 ; }
inline uint32_t ltcd_l1clutwr_get_green(struct LTCD_Type* p) { return (p->L1CLUTWR & LTCD_L1CLUTWR_GREEN) >> 8 ; }
inline uint32_t ltcd_l1clutwr_get_blue(struct LTCD_Type* p) { return (p->L1CLUTWR & LTCD_L1CLUTWR_BLUE) >> 0 ; }

// LTCD->L2CR Layerx Control Register
enum {
	LTCD_L2CR_CLUTEN = 1UL<<4, // Color Look-Up Table Enable
	LTCD_L2CR_COLKEN = 1UL<<1, // Color Keying Enable
	LTCD_L2CR_LEN = 1UL<<0, // Layer Enable		
};

// LTCD->L2WHPCR Layerx Window Horizontal Position Configuration Register
enum {
	LTCD_L2WHPCR_WHSPPOS = ((1UL<<12)-1) << 16, // Window Horizontal Stop Position
	LTCD_L2WHPCR_WHSTPOS = ((1UL<<12)-1) << 0, // Window Horizontal Start Position		
};
inline void ltcd_l2whpcr_set_whsppos(struct LTCD_Type* p, uint32_t val) { p->L2WHPCR = (p->L2WHPCR & ~LTCD_L2WHPCR_WHSPPOS) | ((val<<16) & LTCD_L2WHPCR_WHSPPOS); }
inline void ltcd_l2whpcr_set_whstpos(struct LTCD_Type* p, uint32_t val) { p->L2WHPCR = (p->L2WHPCR & ~LTCD_L2WHPCR_WHSTPOS) | ((val<<0) & LTCD_L2WHPCR_WHSTPOS); }
inline uint32_t ltcd_l2whpcr_get_whsppos(struct LTCD_Type* p) { return (p->L2WHPCR & LTCD_L2WHPCR_WHSPPOS) >> 16 ; }
inline uint32_t ltcd_l2whpcr_get_whstpos(struct LTCD_Type* p) { return (p->L2WHPCR & LTCD_L2WHPCR_WHSTPOS) >> 0 ; }

// LTCD->L2WVPCR Layerx Window Vertical Position Configuration Register
enum {
	LTCD_L2WVPCR_WVSPPOS = ((1UL<<11)-1) << 16, // Window Vertical Stop Position
	LTCD_L2WVPCR_WVSTPOS = ((1UL<<11)-1) << 0, // Window Vertical Start Position		
};
inline void ltcd_l2wvpcr_set_wvsppos(struct LTCD_Type* p, uint32_t val) { p->L2WVPCR = (p->L2WVPCR & ~LTCD_L2WVPCR_WVSPPOS) | ((val<<16) & LTCD_L2WVPCR_WVSPPOS); }
inline void ltcd_l2wvpcr_set_wvstpos(struct LTCD_Type* p, uint32_t val) { p->L2WVPCR = (p->L2WVPCR & ~LTCD_L2WVPCR_WVSTPOS) | ((val<<0) & LTCD_L2WVPCR_WVSTPOS); }
inline uint32_t ltcd_l2wvpcr_get_wvsppos(struct LTCD_Type* p) { return (p->L2WVPCR & LTCD_L2WVPCR_WVSPPOS) >> 16 ; }
inline uint32_t ltcd_l2wvpcr_get_wvstpos(struct LTCD_Type* p) { return (p->L2WVPCR & LTCD_L2WVPCR_WVSTPOS) >> 0 ; }

// LTCD->L2CKCR Layerx Color Keying Configuration Register
enum {
	LTCD_L2CKCR_CKRED = ((1UL<<9)-1) << 15, // Color Key Red value
	LTCD_L2CKCR_CKGREEN = ((1UL<<7)-1) << 8, // Color Key Green value
	LTCD_L2CKCR_CKBLUE = ((1UL<<8)-1) << 0, // Color Key Blue value		
};
inline void ltcd_l2ckcr_set_ckred(struct LTCD_Type* p, uint32_t val) { p->L2CKCR = (p->L2CKCR & ~LTCD_L2CKCR_CKRED) | ((val<<15) & LTCD_L2CKCR_CKRED); }
inline void ltcd_l2ckcr_set_ckgreen(struct LTCD_Type* p, uint32_t val) { p->L2CKCR = (p->L2CKCR & ~LTCD_L2CKCR_CKGREEN) | ((val<<8) & LTCD_L2CKCR_CKGREEN); }
inline void ltcd_l2ckcr_set_ckblue(struct LTCD_Type* p, uint32_t val) { p->L2CKCR = (p->L2CKCR & ~LTCD_L2CKCR_CKBLUE) | ((val<<0) & LTCD_L2CKCR_CKBLUE); }
inline uint32_t ltcd_l2ckcr_get_ckred(struct LTCD_Type* p) { return (p->L2CKCR & LTCD_L2CKCR_CKRED) >> 15 ; }
inline uint32_t ltcd_l2ckcr_get_ckgreen(struct LTCD_Type* p) { return (p->L2CKCR & LTCD_L2CKCR_CKGREEN) >> 8 ; }
inline uint32_t ltcd_l2ckcr_get_ckblue(struct LTCD_Type* p) { return (p->L2CKCR & LTCD_L2CKCR_CKBLUE) >> 0 ; }

// LTCD->L2PFCR Layerx Pixel Format Configuration Register
enum {
	LTCD_L2PFCR_PF = ((1UL<<3)-1) << 0, // Pixel Format		
};
inline void ltcd_l2pfcr_set_pf(struct LTCD_Type* p, uint32_t val) { p->L2PFCR = (p->L2PFCR & ~LTCD_L2PFCR_PF) | ((val<<0) & LTCD_L2PFCR_PF); }
inline uint32_t ltcd_l2pfcr_get_pf(struct LTCD_Type* p) { return (p->L2PFCR & LTCD_L2PFCR_PF) >> 0 ; }

// LTCD->L2DCCR Layerx Default Color Configuration Register
enum {
	LTCD_L2DCCR_DCALPHA = ((1UL<<8)-1) << 24, // Default Color Alpha
	LTCD_L2DCCR_DCRED = ((1UL<<8)-1) << 16, // Default Color Red
	LTCD_L2DCCR_DCGREEN = ((1UL<<8)-1) << 8, // Default Color Green
	LTCD_L2DCCR_DCBLUE = ((1UL<<8)-1) << 0, // Default Color Blue		
};
inline void ltcd_l2dccr_set_dcalpha(struct LTCD_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTCD_L2DCCR_DCALPHA) | ((val<<24) & LTCD_L2DCCR_DCALPHA); }
inline void ltcd_l2dccr_set_dcred(struct LTCD_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTCD_L2DCCR_DCRED) | ((val<<16) & LTCD_L2DCCR_DCRED); }
inline void ltcd_l2dccr_set_dcgreen(struct LTCD_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTCD_L2DCCR_DCGREEN) | ((val<<8) & LTCD_L2DCCR_DCGREEN); }
inline void ltcd_l2dccr_set_dcblue(struct LTCD_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTCD_L2DCCR_DCBLUE) | ((val<<0) & LTCD_L2DCCR_DCBLUE); }
inline uint32_t ltcd_l2dccr_get_dcalpha(struct LTCD_Type* p) { return (p->L2DCCR & LTCD_L2DCCR_DCALPHA) >> 24 ; }
inline uint32_t ltcd_l2dccr_get_dcred(struct LTCD_Type* p) { return (p->L2DCCR & LTCD_L2DCCR_DCRED) >> 16 ; }
inline uint32_t ltcd_l2dccr_get_dcgreen(struct LTCD_Type* p) { return (p->L2DCCR & LTCD_L2DCCR_DCGREEN) >> 8 ; }
inline uint32_t ltcd_l2dccr_get_dcblue(struct LTCD_Type* p) { return (p->L2DCCR & LTCD_L2DCCR_DCBLUE) >> 0 ; }

// LTCD->L2BFCR Layerx Blending Factors Configuration Register
enum {
	LTCD_L2BFCR_BF1 = ((1UL<<3)-1) << 8, // Blending Factor 1
	LTCD_L2BFCR_BF2 = ((1UL<<3)-1) << 0, // Blending Factor 2		
};
inline void ltcd_l2bfcr_set_bf1(struct LTCD_Type* p, uint32_t val) { p->L2BFCR = (p->L2BFCR & ~LTCD_L2BFCR_BF1) | ((val<<8) & LTCD_L2BFCR_BF1); }
inline void ltcd_l2bfcr_set_bf2(struct LTCD_Type* p, uint32_t val) { p->L2BFCR = (p->L2BFCR & ~LTCD_L2BFCR_BF2) | ((val<<0) & LTCD_L2BFCR_BF2); }
inline uint32_t ltcd_l2bfcr_get_bf1(struct LTCD_Type* p) { return (p->L2BFCR & LTCD_L2BFCR_BF1) >> 8 ; }
inline uint32_t ltcd_l2bfcr_get_bf2(struct LTCD_Type* p) { return (p->L2BFCR & LTCD_L2BFCR_BF2) >> 0 ; }

// LTCD->L2CFBLR Layerx Color Frame Buffer Length Register
enum {
	LTCD_L2CFBLR_CFBP = ((1UL<<13)-1) << 16, // Color Frame Buffer Pitch in bytes
	LTCD_L2CFBLR_CFBLL = ((1UL<<13)-1) << 0, // Color Frame Buffer Line Length		
};
inline void ltcd_l2cfblr_set_cfbp(struct LTCD_Type* p, uint32_t val) { p->L2CFBLR = (p->L2CFBLR & ~LTCD_L2CFBLR_CFBP) | ((val<<16) & LTCD_L2CFBLR_CFBP); }
inline void ltcd_l2cfblr_set_cfbll(struct LTCD_Type* p, uint32_t val) { p->L2CFBLR = (p->L2CFBLR & ~LTCD_L2CFBLR_CFBLL) | ((val<<0) & LTCD_L2CFBLR_CFBLL); }
inline uint32_t ltcd_l2cfblr_get_cfbp(struct LTCD_Type* p) { return (p->L2CFBLR & LTCD_L2CFBLR_CFBP) >> 16 ; }
inline uint32_t ltcd_l2cfblr_get_cfbll(struct LTCD_Type* p) { return (p->L2CFBLR & LTCD_L2CFBLR_CFBLL) >> 0 ; }

// LTCD->L2CFBLNR Layerx ColorFrame Buffer Line Number Register
enum {
	LTCD_L2CFBLNR_CFBLNBR = ((1UL<<11)-1) << 0, // Frame Buffer Line Number		
};
inline void ltcd_l2cfblnr_set_cfblnbr(struct LTCD_Type* p, uint32_t val) { p->L2CFBLNR = (p->L2CFBLNR & ~LTCD_L2CFBLNR_CFBLNBR) | ((val<<0) & LTCD_L2CFBLNR_CFBLNBR); }
inline uint32_t ltcd_l2cfblnr_get_cfblnbr(struct LTCD_Type* p) { return (p->L2CFBLNR & LTCD_L2CFBLNR_CFBLNBR) >> 0 ; }

// LTCD->L2CLUTWR Layerx CLUT Write Register
enum {
	LTCD_L2CLUTWR_CLUTADD = ((1UL<<8)-1) << 24, // CLUT Address
	LTCD_L2CLUTWR_RED = ((1UL<<8)-1) << 16, // Red value
	LTCD_L2CLUTWR_GREEN = ((1UL<<8)-1) << 8, // Green value
	LTCD_L2CLUTWR_BLUE = ((1UL<<8)-1) << 0, // Blue value		
};
inline void ltcd_l2clutwr_set_clutadd(struct LTCD_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTCD_L2CLUTWR_CLUTADD) | ((val<<24) & LTCD_L2CLUTWR_CLUTADD); }
inline void ltcd_l2clutwr_set_red(struct LTCD_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTCD_L2CLUTWR_RED) | ((val<<16) & LTCD_L2CLUTWR_RED); }
inline void ltcd_l2clutwr_set_green(struct LTCD_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTCD_L2CLUTWR_GREEN) | ((val<<8) & LTCD_L2CLUTWR_GREEN); }
inline void ltcd_l2clutwr_set_blue(struct LTCD_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTCD_L2CLUTWR_BLUE) | ((val<<0) & LTCD_L2CLUTWR_BLUE); }
inline uint32_t ltcd_l2clutwr_get_clutadd(struct LTCD_Type* p) { return (p->L2CLUTWR & LTCD_L2CLUTWR_CLUTADD) >> 24 ; }
inline uint32_t ltcd_l2clutwr_get_red(struct LTCD_Type* p) { return (p->L2CLUTWR & LTCD_L2CLUTWR_RED) >> 16 ; }
inline uint32_t ltcd_l2clutwr_get_green(struct LTCD_Type* p) { return (p->L2CLUTWR & LTCD_L2CLUTWR_GREEN) >> 8 ; }
inline uint32_t ltcd_l2clutwr_get_blue(struct LTCD_Type* p) { return (p->L2CLUTWR & LTCD_L2CLUTWR_BLUE) >> 0 ; }

/* Management data input/output slave */
struct MDIOS_Type {
	__IO uint16_t CR; // @0 MDIOS configuration register
	 uint8_t RESERVED0[2]; // @2 
	__I uint32_t WRFR; // @4 MDIOS write flag register
	__IO uint32_t CWRFR; // @8 MDIOS clear write flag register
	__I uint32_t RDFR; // @12 MDIOS read flag register
	__IO uint32_t CRDFR; // @16 MDIOS clear read flag register
	__I uint8_t SR; // @20 MDIOS status register
	 uint8_t RESERVED1[3]; // @21 
	__IO uint8_t CLRFR; // @24 MDIOS clear flag register
	 uint8_t RESERVED2[3]; // @25 
	__I uint16_t DINR0; // @28 MDIOS input data register 0
	 uint8_t RESERVED3[2]; // @30 
	__I uint16_t DINR1; // @32 MDIOS input data register 1
	 uint8_t RESERVED4[2]; // @34 
	__I uint16_t DINR2; // @36 MDIOS input data register 2
	 uint8_t RESERVED5[2]; // @38 
	__I uint16_t DINR3; // @40 MDIOS input data register 3
	 uint8_t RESERVED6[2]; // @42 
	__I uint16_t DINR4; // @44 MDIOS input data register 4
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t DINR5; // @48 MDIOS input data register 5
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t DINR6; // @52 MDIOS input data register 6
	 uint8_t RESERVED9[2]; // @54 
	__I uint16_t DINR7; // @56 MDIOS input data register 7
	 uint8_t RESERVED10[2]; // @58 
	__I uint16_t DINR8; // @60 MDIOS input data register 8
	 uint8_t RESERVED11[2]; // @62 
	__I uint16_t DINR9; // @64 MDIOS input data register 9
	 uint8_t RESERVED12[2]; // @66 
	__I uint16_t DINR10; // @68 MDIOS input data register 10
	 uint8_t RESERVED13[2]; // @70 
	__I uint16_t DINR11; // @72 MDIOS input data register 11
	 uint8_t RESERVED14[2]; // @74 
	__I uint16_t DINR12; // @76 MDIOS input data register 12
	 uint8_t RESERVED15[2]; // @78 
	__I uint16_t DINR13; // @80 MDIOS input data register 13
	 uint8_t RESERVED16[2]; // @82 
	__I uint16_t DINR14; // @84 MDIOS input data register 14
	 uint8_t RESERVED17[2]; // @86 
	__I uint16_t DINR15; // @88 MDIOS input data register 15
	 uint8_t RESERVED18[2]; // @90 
	__I uint16_t DINR16; // @92 MDIOS input data register 16
	 uint8_t RESERVED19[2]; // @94 
	__I uint16_t DINR17; // @96 MDIOS input data register 17
	 uint8_t RESERVED20[2]; // @98 
	__I uint16_t DINR18; // @100 MDIOS input data register 18
	 uint8_t RESERVED21[2]; // @102 
	__I uint16_t DINR19; // @104 MDIOS input data register 19
	 uint8_t RESERVED22[2]; // @106 
	__I uint16_t DINR20; // @108 MDIOS input data register 20
	 uint8_t RESERVED23[2]; // @110 
	__I uint16_t DINR21; // @112 MDIOS input data register 21
	 uint8_t RESERVED24[2]; // @114 
	__I uint16_t DINR22; // @116 MDIOS input data register 22
	 uint8_t RESERVED25[2]; // @118 
	__I uint16_t DINR23; // @120 MDIOS input data register 23
	 uint8_t RESERVED26[2]; // @122 
	__I uint16_t DINR24; // @124 MDIOS input data register 24
	 uint8_t RESERVED27[2]; // @126 
	__I uint16_t DINR25; // @128 MDIOS input data register 25
	 uint8_t RESERVED28[2]; // @130 
	__I uint16_t DINR26; // @132 MDIOS input data register 26
	 uint8_t RESERVED29[2]; // @134 
	__I uint16_t DINR27; // @136 MDIOS input data register 27
	 uint8_t RESERVED30[2]; // @138 
	__I uint16_t DINR28; // @140 MDIOS input data register 28
	 uint8_t RESERVED31[2]; // @142 
	__I uint16_t DINR29; // @144 MDIOS input data register 29
	 uint8_t RESERVED32[2]; // @146 
	__I uint16_t DINR30; // @148 MDIOS input data register 30
	 uint8_t RESERVED33[2]; // @150 
	__I uint16_t DINR31; // @152 MDIOS input data register 31
	 uint8_t RESERVED34[2]; // @154 
	__IO uint16_t DOUTR0; // @156 MDIOS output data register 0
	 uint8_t RESERVED35[2]; // @158 
	__IO uint16_t DOUTR1; // @160 MDIOS output data register 1
	 uint8_t RESERVED36[2]; // @162 
	__IO uint16_t DOUTR2; // @164 MDIOS output data register 2
	 uint8_t RESERVED37[2]; // @166 
	__IO uint16_t DOUTR3; // @168 MDIOS output data register 3
	 uint8_t RESERVED38[2]; // @170 
	__IO uint16_t DOUTR4; // @172 MDIOS output data register 4
	 uint8_t RESERVED39[2]; // @174 
	__IO uint16_t DOUTR5; // @176 MDIOS output data register 5
	 uint8_t RESERVED40[2]; // @178 
	__IO uint16_t DOUTR6; // @180 MDIOS output data register 6
	 uint8_t RESERVED41[2]; // @182 
	__IO uint16_t DOUTR7; // @184 MDIOS output data register 7
	 uint8_t RESERVED42[2]; // @186 
	__IO uint16_t DOUTR8; // @188 MDIOS output data register 8
	 uint8_t RESERVED43[2]; // @190 
	__IO uint16_t DOUTR9; // @192 MDIOS output data register 9
	 uint8_t RESERVED44[2]; // @194 
	__IO uint16_t DOUTR10; // @196 MDIOS output data register 10
	 uint8_t RESERVED45[2]; // @198 
	__IO uint16_t DOUTR11; // @200 MDIOS output data register 11
	 uint8_t RESERVED46[2]; // @202 
	__IO uint16_t DOUTR12; // @204 MDIOS output data register 12
	 uint8_t RESERVED47[2]; // @206 
	__IO uint16_t DOUTR13; // @208 MDIOS output data register 13
	 uint8_t RESERVED48[2]; // @210 
	__IO uint16_t DOUTR14; // @212 MDIOS output data register 14
	 uint8_t RESERVED49[2]; // @214 
	__IO uint16_t DOUTR15; // @216 MDIOS output data register 15
	 uint8_t RESERVED50[2]; // @218 
	__IO uint16_t DOUTR16; // @220 MDIOS output data register 16
	 uint8_t RESERVED51[2]; // @222 
	__IO uint16_t DOUTR17; // @224 MDIOS output data register 17
	 uint8_t RESERVED52[2]; // @226 
	__IO uint16_t DOUTR18; // @228 MDIOS output data register 18
	 uint8_t RESERVED53[2]; // @230 
	__IO uint16_t DOUTR19; // @232 MDIOS output data register 19
	 uint8_t RESERVED54[2]; // @234 
	__IO uint16_t DOUTR20; // @236 MDIOS output data register 20
	 uint8_t RESERVED55[2]; // @238 
	__IO uint16_t DOUTR21; // @240 MDIOS output data register 21
	 uint8_t RESERVED56[2]; // @242 
	__IO uint16_t DOUTR22; // @244 MDIOS output data register 22
	 uint8_t RESERVED57[2]; // @246 
	__IO uint16_t DOUTR23; // @248 MDIOS output data register 23
	 uint8_t RESERVED58[2]; // @250 
	__IO uint16_t DOUTR24; // @252 MDIOS output data register 24
	 uint8_t RESERVED59[2]; // @254 
	__IO uint16_t DOUTR25; // @256 MDIOS output data register 25
	 uint8_t RESERVED60[2]; // @258 
	__IO uint16_t DOUTR26; // @260 MDIOS output data register 26
	 uint8_t RESERVED61[2]; // @262 
	__IO uint16_t DOUTR27; // @264 MDIOS output data register 27
	 uint8_t RESERVED62[2]; // @266 
	__IO uint16_t DOUTR28; // @268 MDIOS output data register 28
	 uint8_t RESERVED63[2]; // @270 
	__IO uint16_t DOUTR29; // @272 MDIOS output data register 29
	 uint8_t RESERVED64[2]; // @274 
	__IO uint16_t DOUTR30; // @276 MDIOS output data register 30
	 uint8_t RESERVED65[2]; // @278 
	__IO uint16_t DOUTR31; // @280 MDIOS output data register 31
};

// MDIOS->CR MDIOS configuration register
enum {
	MDIOS_CR_PORT_ADDRESS = ((1UL<<5)-1) << 8, // Slaves's address
	MDIOS_CR_DPC = 1UL<<7, // Disable Preamble Check
	MDIOS_CR_EIE = 1UL<<3, // Error interrupt enable
	MDIOS_CR_RDIE = 1UL<<2, // Register Read Interrupt Enable
	MDIOS_CR_WRIE = 1UL<<1, // Register write interrupt enable
	MDIOS_CR_EN = 1UL<<0, // Peripheral enable		
};
inline void mdios_cr_set_port_address(struct MDIOS_Type* p, uint32_t val) { p->CR = (p->CR & ~MDIOS_CR_PORT_ADDRESS) | ((val<<8) & MDIOS_CR_PORT_ADDRESS); }
inline uint32_t mdios_cr_get_port_address(struct MDIOS_Type* p) { return (p->CR & MDIOS_CR_PORT_ADDRESS) >> 8 ; }

// MDIOS->SR MDIOS status register
enum {
	MDIOS_SR_TERF = 1UL<<2, // Turnaround error flag
	MDIOS_SR_SERF = 1UL<<1, // Start error flag
	MDIOS_SR_PERF = 1UL<<0, // Preamble error flag		
};

// MDIOS->CLRFR MDIOS clear flag register
enum {
	MDIOS_CLRFR_CTERF = 1UL<<2, // Clear the turnaround error flag
	MDIOS_CLRFR_CSERF = 1UL<<1, // Clear the start error flag
	MDIOS_CLRFR_CPERF = 1UL<<0, // Clear the preamble error flag		
};

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t TYPER; // @0 MPU type register
	__I uint8_t CTRL; // @4 MPU control register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t RNR; // @8 MPU region number register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t RBAR; // @12 MPU region base address register
	__IO uint32_t RASR; // @16 MPU region attribute and size register
};

// MPU->TYPER MPU type register
enum {
	MPU_TYPER_IREGION = ((1UL<<8)-1) << 16, // Number of MPU instruction regions
	MPU_TYPER_DREGION = ((1UL<<8)-1) << 8, // Number of MPU data regions
	MPU_TYPER_SEPARATE = 1UL<<0, // Separate flag		
};
inline uint32_t mpu_typer_get_iregion(struct MPU_Type* p) { return (p->TYPER & MPU_TYPER_IREGION) >> 16 ; }
inline uint32_t mpu_typer_get_dregion(struct MPU_Type* p) { return (p->TYPER & MPU_TYPER_DREGION) >> 8 ; }

// MPU->CTRL MPU control register
enum {
	MPU_CTRL_PRIVDEFENA = 1UL<<2, // Enable priviliged software access to default memory map
	MPU_CTRL_HFNMIENA = 1UL<<1, // Enables the operation of MPU during hard fault
	MPU_CTRL_ENABLE = 1UL<<0, // Enables the MPU		
};

// MPU->RBAR MPU region base address register
enum {
	MPU_RBAR_ADDR = ((1UL<<27)-1) << 5, // Region base address field
	MPU_RBAR_VALID = 1UL<<4, // MPU region number valid
	MPU_RBAR_REGION = ((1UL<<4)-1) << 0, // MPU region field		
};
inline void mpu_rbar_set_addr(struct MPU_Type* p, uint32_t val) { p->RBAR = (p->RBAR & ~MPU_RBAR_ADDR) | ((val<<5) & MPU_RBAR_ADDR); }
inline void mpu_rbar_set_region(struct MPU_Type* p, uint32_t val) { p->RBAR = (p->RBAR & ~MPU_RBAR_REGION) | ((val<<0) & MPU_RBAR_REGION); }
inline uint32_t mpu_rbar_get_addr(struct MPU_Type* p) { return (p->RBAR & MPU_RBAR_ADDR) >> 5 ; }
inline uint32_t mpu_rbar_get_region(struct MPU_Type* p) { return (p->RBAR & MPU_RBAR_REGION) >> 0 ; }

// MPU->RASR MPU region attribute and size register
enum {
	MPU_RASR_XN = 1UL<<28, // Instruction access disable bit
	MPU_RASR_AP = ((1UL<<3)-1) << 24, // Access permission
	MPU_RASR_TEX = ((1UL<<3)-1) << 19, // memory attribute
	MPU_RASR_S = 1UL<<18, // Shareable memory attribute
	MPU_RASR_C = 1UL<<17, // memory attribute
	MPU_RASR_B = 1UL<<16, // memory attribute
	MPU_RASR_SRD = ((1UL<<8)-1) << 8, // Subregion disable bits
	MPU_RASR_SIZE = ((1UL<<5)-1) << 1, // Size of the MPU protection region
	MPU_RASR_ENABLE = 1UL<<0, // Region enable bit.		
};
inline void mpu_rasr_set_ap(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_AP) | ((val<<24) & MPU_RASR_AP); }
inline void mpu_rasr_set_tex(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_TEX) | ((val<<19) & MPU_RASR_TEX); }
inline void mpu_rasr_set_srd(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_SRD) | ((val<<8) & MPU_RASR_SRD); }
inline void mpu_rasr_set_size(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_SIZE) | ((val<<1) & MPU_RASR_SIZE); }
inline uint32_t mpu_rasr_get_ap(struct MPU_Type* p) { return (p->RASR & MPU_RASR_AP) >> 24 ; }
inline uint32_t mpu_rasr_get_tex(struct MPU_Type* p) { return (p->RASR & MPU_RASR_TEX) >> 19 ; }
inline uint32_t mpu_rasr_get_srd(struct MPU_Type* p) { return (p->RASR & MPU_RASR_SRD) >> 8 ; }
inline uint32_t mpu_rasr_get_size(struct MPU_Type* p) { return (p->RASR & MPU_RASR_SIZE) >> 1 ; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER0; // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1; // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2; // @8 Interrupt Set-Enable Register
	 uint8_t RESERVED0[116]; // @12 
	__IO uint32_t ICER0; // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1; // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2; // @136 Interrupt Clear-Enable Register
	 uint8_t RESERVED1[116]; // @140 
	__IO uint32_t ISPR0; // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1; // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2; // @264 Interrupt Set-Pending Register
	 uint8_t RESERVED2[116]; // @268 
	__IO uint32_t ICPR0; // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1; // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2; // @392 Interrupt Clear-Pending Register
	 uint8_t RESERVED3[116]; // @396 
	__I uint32_t IABR0; // @512 Interrupt Active Bit Register
	__I uint32_t IABR1; // @516 Interrupt Active Bit Register
	__I uint32_t IABR2; // @520 Interrupt Active Bit Register
	 uint8_t RESERVED4[244]; // @524 
	__IO uint32_t IPR0; // @768 Interrupt Priority Register
	__IO uint32_t IPR1; // @772 Interrupt Priority Register
	__IO uint32_t IPR2; // @776 Interrupt Priority Register
	__IO uint32_t IPR3; // @780 Interrupt Priority Register
	__IO uint32_t IPR4; // @784 Interrupt Priority Register
	__IO uint32_t IPR5; // @788 Interrupt Priority Register
	__IO uint32_t IPR6; // @792 Interrupt Priority Register
	__IO uint32_t IPR7; // @796 Interrupt Priority Register
	__IO uint32_t IPR8; // @800 Interrupt Priority Register
	__IO uint32_t IPR9; // @804 Interrupt Priority Register
	__IO uint32_t IPR10; // @808 Interrupt Priority Register
	__IO uint32_t IPR11; // @812 Interrupt Priority Register
	__IO uint32_t IPR12; // @816 Interrupt Priority Register
	__IO uint32_t IPR13; // @820 Interrupt Priority Register
	__IO uint32_t IPR14; // @824 Interrupt Priority Register
	__IO uint32_t IPR15; // @828 Interrupt Priority Register
	__IO uint32_t IPR16; // @832 Interrupt Priority Register
	__IO uint32_t IPR17; // @836 Interrupt Priority Register
	__IO uint32_t IPR18; // @840 Interrupt Priority Register
	__IO uint32_t IPR19; // @844 Interrupt Priority Register
	__IO uint32_t IPR20; // @848 Interrupt Priority Register
	__IO uint32_t IPR21; // @852 Interrupt Priority Register
	__IO uint32_t IPR22; // @856 Interrupt Priority Register
	__IO uint32_t IPR23; // @860 Interrupt Priority Register
	__IO uint32_t IPR24; // @864 Interrupt Priority Register
	__IO uint32_t IPR25; // @868 Interrupt Priority Register
	__IO uint32_t IPR26; // @872 Interrupt Priority Register
	__IO uint32_t IPR27; // @876 Interrupt Priority Register
	__IO uint32_t IPR28; // @880 Interrupt Priority Register
};

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr0_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N3) | ((val<<24) & NVIC_IPR0_IPR_N3); }
inline void nvic_ipr0_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N2) | ((val<<16) & NVIC_IPR0_IPR_N2); }
inline void nvic_ipr0_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N1) | ((val<<8) & NVIC_IPR0_IPR_N1); }
inline void nvic_ipr0_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N0) | ((val<<0) & NVIC_IPR0_IPR_N0); }
inline uint32_t nvic_ipr0_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr0_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr0_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr0_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N0) >> 0 ; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr1_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N3) | ((val<<24) & NVIC_IPR1_IPR_N3); }
inline void nvic_ipr1_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N2) | ((val<<16) & NVIC_IPR1_IPR_N2); }
inline void nvic_ipr1_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N1) | ((val<<8) & NVIC_IPR1_IPR_N1); }
inline void nvic_ipr1_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N0) | ((val<<0) & NVIC_IPR1_IPR_N0); }
inline uint32_t nvic_ipr1_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr1_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr1_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr1_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N0) >> 0 ; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr2_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N3) | ((val<<24) & NVIC_IPR2_IPR_N3); }
inline void nvic_ipr2_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N2) | ((val<<16) & NVIC_IPR2_IPR_N2); }
inline void nvic_ipr2_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N1) | ((val<<8) & NVIC_IPR2_IPR_N1); }
inline void nvic_ipr2_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N0) | ((val<<0) & NVIC_IPR2_IPR_N0); }
inline uint32_t nvic_ipr2_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr2_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr2_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr2_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N0) >> 0 ; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr3_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N3) | ((val<<24) & NVIC_IPR3_IPR_N3); }
inline void nvic_ipr3_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N2) | ((val<<16) & NVIC_IPR3_IPR_N2); }
inline void nvic_ipr3_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N1) | ((val<<8) & NVIC_IPR3_IPR_N1); }
inline void nvic_ipr3_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N0) | ((val<<0) & NVIC_IPR3_IPR_N0); }
inline uint32_t nvic_ipr3_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr3_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr3_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr3_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N0) >> 0 ; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr4_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N3) | ((val<<24) & NVIC_IPR4_IPR_N3); }
inline void nvic_ipr4_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N2) | ((val<<16) & NVIC_IPR4_IPR_N2); }
inline void nvic_ipr4_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N1) | ((val<<8) & NVIC_IPR4_IPR_N1); }
inline void nvic_ipr4_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N0) | ((val<<0) & NVIC_IPR4_IPR_N0); }
inline uint32_t nvic_ipr4_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr4_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr4_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr4_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N0) >> 0 ; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr5_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N3) | ((val<<24) & NVIC_IPR5_IPR_N3); }
inline void nvic_ipr5_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N2) | ((val<<16) & NVIC_IPR5_IPR_N2); }
inline void nvic_ipr5_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N1) | ((val<<8) & NVIC_IPR5_IPR_N1); }
inline void nvic_ipr5_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N0) | ((val<<0) & NVIC_IPR5_IPR_N0); }
inline uint32_t nvic_ipr5_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr5_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr5_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr5_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N0) >> 0 ; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr6_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N3) | ((val<<24) & NVIC_IPR6_IPR_N3); }
inline void nvic_ipr6_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N2) | ((val<<16) & NVIC_IPR6_IPR_N2); }
inline void nvic_ipr6_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N1) | ((val<<8) & NVIC_IPR6_IPR_N1); }
inline void nvic_ipr6_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N0) | ((val<<0) & NVIC_IPR6_IPR_N0); }
inline uint32_t nvic_ipr6_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr6_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr6_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr6_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N0) >> 0 ; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr7_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N3) | ((val<<24) & NVIC_IPR7_IPR_N3); }
inline void nvic_ipr7_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N2) | ((val<<16) & NVIC_IPR7_IPR_N2); }
inline void nvic_ipr7_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N1) | ((val<<8) & NVIC_IPR7_IPR_N1); }
inline void nvic_ipr7_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N0) | ((val<<0) & NVIC_IPR7_IPR_N0); }
inline uint32_t nvic_ipr7_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr7_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr7_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr7_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N0) >> 0 ; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr8_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N3) | ((val<<24) & NVIC_IPR8_IPR_N3); }
inline void nvic_ipr8_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N2) | ((val<<16) & NVIC_IPR8_IPR_N2); }
inline void nvic_ipr8_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N1) | ((val<<8) & NVIC_IPR8_IPR_N1); }
inline void nvic_ipr8_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N0) | ((val<<0) & NVIC_IPR8_IPR_N0); }
inline uint32_t nvic_ipr8_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr8_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr8_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr8_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N0) >> 0 ; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr9_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N3) | ((val<<24) & NVIC_IPR9_IPR_N3); }
inline void nvic_ipr9_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N2) | ((val<<16) & NVIC_IPR9_IPR_N2); }
inline void nvic_ipr9_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N1) | ((val<<8) & NVIC_IPR9_IPR_N1); }
inline void nvic_ipr9_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N0) | ((val<<0) & NVIC_IPR9_IPR_N0); }
inline uint32_t nvic_ipr9_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr9_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr9_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr9_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N0) >> 0 ; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr10_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N3) | ((val<<24) & NVIC_IPR10_IPR_N3); }
inline void nvic_ipr10_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N2) | ((val<<16) & NVIC_IPR10_IPR_N2); }
inline void nvic_ipr10_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N1) | ((val<<8) & NVIC_IPR10_IPR_N1); }
inline void nvic_ipr10_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N0) | ((val<<0) & NVIC_IPR10_IPR_N0); }
inline uint32_t nvic_ipr10_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr10_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr10_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr10_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N0) >> 0 ; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr11_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N3) | ((val<<24) & NVIC_IPR11_IPR_N3); }
inline void nvic_ipr11_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N2) | ((val<<16) & NVIC_IPR11_IPR_N2); }
inline void nvic_ipr11_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N1) | ((val<<8) & NVIC_IPR11_IPR_N1); }
inline void nvic_ipr11_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N0) | ((val<<0) & NVIC_IPR11_IPR_N0); }
inline uint32_t nvic_ipr11_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr11_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr11_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr11_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N0) >> 0 ; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr12_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N3) | ((val<<24) & NVIC_IPR12_IPR_N3); }
inline void nvic_ipr12_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N2) | ((val<<16) & NVIC_IPR12_IPR_N2); }
inline void nvic_ipr12_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N1) | ((val<<8) & NVIC_IPR12_IPR_N1); }
inline void nvic_ipr12_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N0) | ((val<<0) & NVIC_IPR12_IPR_N0); }
inline uint32_t nvic_ipr12_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr12_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr12_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr12_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N0) >> 0 ; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr13_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N3) | ((val<<24) & NVIC_IPR13_IPR_N3); }
inline void nvic_ipr13_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N2) | ((val<<16) & NVIC_IPR13_IPR_N2); }
inline void nvic_ipr13_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N1) | ((val<<8) & NVIC_IPR13_IPR_N1); }
inline void nvic_ipr13_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N0) | ((val<<0) & NVIC_IPR13_IPR_N0); }
inline uint32_t nvic_ipr13_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr13_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr13_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr13_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N0) >> 0 ; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr14_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N3) | ((val<<24) & NVIC_IPR14_IPR_N3); }
inline void nvic_ipr14_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N2) | ((val<<16) & NVIC_IPR14_IPR_N2); }
inline void nvic_ipr14_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N1) | ((val<<8) & NVIC_IPR14_IPR_N1); }
inline void nvic_ipr14_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N0) | ((val<<0) & NVIC_IPR14_IPR_N0); }
inline uint32_t nvic_ipr14_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr14_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr14_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr14_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N0) >> 0 ; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr15_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N3) | ((val<<24) & NVIC_IPR15_IPR_N3); }
inline void nvic_ipr15_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N2) | ((val<<16) & NVIC_IPR15_IPR_N2); }
inline void nvic_ipr15_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N1) | ((val<<8) & NVIC_IPR15_IPR_N1); }
inline void nvic_ipr15_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N0) | ((val<<0) & NVIC_IPR15_IPR_N0); }
inline uint32_t nvic_ipr15_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr15_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr15_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr15_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N0) >> 0 ; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr16_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N3) | ((val<<24) & NVIC_IPR16_IPR_N3); }
inline void nvic_ipr16_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N2) | ((val<<16) & NVIC_IPR16_IPR_N2); }
inline void nvic_ipr16_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N1) | ((val<<8) & NVIC_IPR16_IPR_N1); }
inline void nvic_ipr16_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N0) | ((val<<0) & NVIC_IPR16_IPR_N0); }
inline uint32_t nvic_ipr16_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr16_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr16_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr16_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N0) >> 0 ; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr17_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N3) | ((val<<24) & NVIC_IPR17_IPR_N3); }
inline void nvic_ipr17_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N2) | ((val<<16) & NVIC_IPR17_IPR_N2); }
inline void nvic_ipr17_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N1) | ((val<<8) & NVIC_IPR17_IPR_N1); }
inline void nvic_ipr17_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N0) | ((val<<0) & NVIC_IPR17_IPR_N0); }
inline uint32_t nvic_ipr17_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr17_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr17_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr17_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N0) >> 0 ; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr18_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N3) | ((val<<24) & NVIC_IPR18_IPR_N3); }
inline void nvic_ipr18_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N2) | ((val<<16) & NVIC_IPR18_IPR_N2); }
inline void nvic_ipr18_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N1) | ((val<<8) & NVIC_IPR18_IPR_N1); }
inline void nvic_ipr18_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N0) | ((val<<0) & NVIC_IPR18_IPR_N0); }
inline uint32_t nvic_ipr18_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr18_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr18_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr18_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N0) >> 0 ; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr19_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N3) | ((val<<24) & NVIC_IPR19_IPR_N3); }
inline void nvic_ipr19_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N2) | ((val<<16) & NVIC_IPR19_IPR_N2); }
inline void nvic_ipr19_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N1) | ((val<<8) & NVIC_IPR19_IPR_N1); }
inline void nvic_ipr19_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N0) | ((val<<0) & NVIC_IPR19_IPR_N0); }
inline uint32_t nvic_ipr19_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr19_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr19_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr19_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N0) >> 0 ; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr20_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N3) | ((val<<24) & NVIC_IPR20_IPR_N3); }
inline void nvic_ipr20_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N2) | ((val<<16) & NVIC_IPR20_IPR_N2); }
inline void nvic_ipr20_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N1) | ((val<<8) & NVIC_IPR20_IPR_N1); }
inline void nvic_ipr20_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N0) | ((val<<0) & NVIC_IPR20_IPR_N0); }
inline uint32_t nvic_ipr20_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr20_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr20_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr20_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N0) >> 0 ; }

// NVIC->IPR21 Interrupt Priority Register
enum {
	NVIC_IPR21_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR21_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR21_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR21_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr21_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N3) | ((val<<24) & NVIC_IPR21_IPR_N3); }
inline void nvic_ipr21_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N2) | ((val<<16) & NVIC_IPR21_IPR_N2); }
inline void nvic_ipr21_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N1) | ((val<<8) & NVIC_IPR21_IPR_N1); }
inline void nvic_ipr21_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N0) | ((val<<0) & NVIC_IPR21_IPR_N0); }
inline uint32_t nvic_ipr21_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr21_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr21_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr21_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N0) >> 0 ; }

// NVIC->IPR22 Interrupt Priority Register
enum {
	NVIC_IPR22_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR22_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR22_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR22_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr22_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N3) | ((val<<24) & NVIC_IPR22_IPR_N3); }
inline void nvic_ipr22_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N2) | ((val<<16) & NVIC_IPR22_IPR_N2); }
inline void nvic_ipr22_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N1) | ((val<<8) & NVIC_IPR22_IPR_N1); }
inline void nvic_ipr22_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N0) | ((val<<0) & NVIC_IPR22_IPR_N0); }
inline uint32_t nvic_ipr22_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr22_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr22_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr22_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N0) >> 0 ; }

// NVIC->IPR23 Interrupt Priority Register
enum {
	NVIC_IPR23_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR23_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR23_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR23_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr23_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N3) | ((val<<24) & NVIC_IPR23_IPR_N3); }
inline void nvic_ipr23_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N2) | ((val<<16) & NVIC_IPR23_IPR_N2); }
inline void nvic_ipr23_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N1) | ((val<<8) & NVIC_IPR23_IPR_N1); }
inline void nvic_ipr23_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N0) | ((val<<0) & NVIC_IPR23_IPR_N0); }
inline uint32_t nvic_ipr23_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr23_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr23_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr23_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N0) >> 0 ; }

// NVIC->IPR24 Interrupt Priority Register
enum {
	NVIC_IPR24_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR24_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR24_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR24_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr24_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N3) | ((val<<24) & NVIC_IPR24_IPR_N3); }
inline void nvic_ipr24_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N2) | ((val<<16) & NVIC_IPR24_IPR_N2); }
inline void nvic_ipr24_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N1) | ((val<<8) & NVIC_IPR24_IPR_N1); }
inline void nvic_ipr24_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N0) | ((val<<0) & NVIC_IPR24_IPR_N0); }
inline uint32_t nvic_ipr24_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr24_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr24_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr24_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N0) >> 0 ; }

// NVIC->IPR25 Interrupt Priority Register
enum {
	NVIC_IPR25_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR25_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR25_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR25_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr25_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N3) | ((val<<24) & NVIC_IPR25_IPR_N3); }
inline void nvic_ipr25_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N2) | ((val<<16) & NVIC_IPR25_IPR_N2); }
inline void nvic_ipr25_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N1) | ((val<<8) & NVIC_IPR25_IPR_N1); }
inline void nvic_ipr25_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N0) | ((val<<0) & NVIC_IPR25_IPR_N0); }
inline uint32_t nvic_ipr25_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr25_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr25_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr25_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N0) >> 0 ; }

// NVIC->IPR26 Interrupt Priority Register
enum {
	NVIC_IPR26_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR26_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR26_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR26_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr26_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N3) | ((val<<24) & NVIC_IPR26_IPR_N3); }
inline void nvic_ipr26_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N2) | ((val<<16) & NVIC_IPR26_IPR_N2); }
inline void nvic_ipr26_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N1) | ((val<<8) & NVIC_IPR26_IPR_N1); }
inline void nvic_ipr26_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N0) | ((val<<0) & NVIC_IPR26_IPR_N0); }
inline uint32_t nvic_ipr26_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr26_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr26_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr26_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N0) >> 0 ; }

// NVIC->IPR27 Interrupt Priority Register
enum {
	NVIC_IPR27_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR27_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR27_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR27_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr27_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N3) | ((val<<24) & NVIC_IPR27_IPR_N3); }
inline void nvic_ipr27_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N2) | ((val<<16) & NVIC_IPR27_IPR_N2); }
inline void nvic_ipr27_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N1) | ((val<<8) & NVIC_IPR27_IPR_N1); }
inline void nvic_ipr27_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N0) | ((val<<0) & NVIC_IPR27_IPR_N0); }
inline uint32_t nvic_ipr27_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr27_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr27_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr27_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N0) >> 0 ; }

// NVIC->IPR28 Interrupt Priority Register
enum {
	NVIC_IPR28_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR28_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR28_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR28_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr28_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N3) | ((val<<24) & NVIC_IPR28_IPR_N3); }
inline void nvic_ipr28_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N2) | ((val<<16) & NVIC_IPR28_IPR_N2); }
inline void nvic_ipr28_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N1) | ((val<<8) & NVIC_IPR28_IPR_N1); }
inline void nvic_ipr28_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N0) | ((val<<0) & NVIC_IPR28_IPR_N0); }
inline uint32_t nvic_ipr28_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr28_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr28_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr28_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N0) >> 0 ; }

/* Nested vectored interrupt controller */
struct NVIC_STIR_Type {
	__IO uint16_t STIR; // @0 Software trigger interrupt register
};

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL<<9)-1) << 0, // Software generated interrupt ID		
};
inline void nvic_stir_stir_set_intid(struct NVIC_STIR_Type* p, uint32_t val) { p->STIR = (p->STIR & ~NVIC_STIR_STIR_INTID) | ((val<<0) & NVIC_STIR_STIR_INTID); }
inline uint32_t nvic_stir_stir_get_intid(struct NVIC_STIR_Type* p) { return (p->STIR & NVIC_STIR_STIR_INTID) >> 0 ; }

/* USB on the go full speed */
struct OTG_FS_DEVICE_Type {
	__IO uint16_t OTG_FS_DCFG; // @0 OTG_FS device configuration register (OTG_FS_DCFG)
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t OTG_FS_DCTL; // @4 OTG_FS device control register (OTG_FS_DCTL)
	 uint8_t RESERVED1[2]; // @6 
	__I uint32_t OTG_FS_DSTS; // @8 OTG_FS device status register (OTG_FS_DSTS)
	 uint8_t RESERVED2[4]; // @12 
	__IO uint8_t OTG_FS_DIEPMSK; // @16 OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
	 uint8_t RESERVED3[3]; // @17 
	__IO uint8_t OTG_FS_DOEPMSK; // @20 OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
	 uint8_t RESERVED4[3]; // @21 
	__I uint32_t OTG_FS_DAINT; // @24 OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
	__IO uint32_t OTG_FS_DAINTMSK; // @28 OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
	 uint8_t RESERVED5[8]; // @32 
	__IO uint16_t OTG_FS_DVBUSDIS; // @40 OTG_FS device VBUS discharge time register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t OTG_FS_DVBUSPULSE; // @44 OTG_FS device VBUS pulsing time register
	 uint8_t RESERVED7[6]; // @46 
	__IO uint16_t OTG_FS_DIEPEMPMSK; // @52 OTG_FS device IN endpoint FIFO empty interrupt mask register
	 uint8_t RESERVED8[202]; // @54 
	__IO uint32_t OTG_FS_DIEPCTL0; // @256 OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
	 uint8_t RESERVED9[4]; // @260 
	__IO uint8_t OTG_FS_DIEPINT0; // @264 device endpoint-x interrupt register
	 uint8_t RESERVED10[7]; // @265 
	__IO uint32_t OTG_FS_DIEPTSIZ0; // @272 device endpoint-0 transfer size register
	 uint8_t RESERVED11[4]; // @276 
	__I uint16_t OTG_FS_DTXFSTS0; // @280 OTG_FS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED12[6]; // @282 
	__IO uint32_t OTG_FS_DIEPCTL1; // @288 OTG device endpoint-1 control register
	 uint8_t RESERVED13[4]; // @292 
	__IO uint8_t OTG_FS_DIEPINT1; // @296 device endpoint-1 interrupt register
	 uint8_t RESERVED14[7]; // @297 
	__IO uint32_t OTG_FS_DIEPTSIZ1; // @304 device endpoint-1 transfer size register
	 uint8_t RESERVED15[4]; // @308 
	__I uint16_t OTG_FS_DTXFSTS1; // @312 OTG_FS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED16[6]; // @314 
	__IO uint32_t OTG_FS_DIEPCTL2; // @320 OTG device endpoint-2 control register
	 uint8_t RESERVED17[4]; // @324 
	__IO uint8_t OTG_FS_DIEPINT2; // @328 device endpoint-2 interrupt register
	 uint8_t RESERVED18[7]; // @329 
	__IO uint32_t OTG_FS_DIEPTSIZ2; // @336 device endpoint-2 transfer size register
	 uint8_t RESERVED19[4]; // @340 
	__I uint16_t OTG_FS_DTXFSTS2; // @344 OTG_FS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED20[6]; // @346 
	__IO uint32_t OTG_FS_DIEPCTL3; // @352 OTG device endpoint-3 control register
	 uint8_t RESERVED21[4]; // @356 
	__IO uint8_t OTG_FS_DIEPINT3; // @360 device endpoint-3 interrupt register
	 uint8_t RESERVED22[7]; // @361 
	__IO uint32_t OTG_FS_DIEPTSIZ3; // @368 device endpoint-3 transfer size register
	 uint8_t RESERVED23[4]; // @372 
	__I uint16_t OTG_FS_DTXFSTS3; // @376 OTG_FS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED24[6]; // @378 
	__IO uint32_t OTG_FS_DIEPCTL4; // @384 OTG device endpoint-4 control register
	 uint8_t RESERVED25[4]; // @388 
	__IO uint8_t OTG_FS_DIEPINT4; // @392 device endpoint-4 interrupt register
	 uint8_t RESERVED26[11]; // @393 
	__IO uint32_t OTG_FS_DIEPTSIZ4; // @404 device endpoint-4 transfer size register
	 uint8_t RESERVED27[4]; // @408 
	__IO uint16_t OTG_FS_DTXFSTS4; // @412 OTG_FS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED28[2]; // @414 
	__IO uint32_t OTG_FS_DIEPCTL5; // @416 OTG device endpoint-5 control register
	 uint8_t RESERVED29[4]; // @420 
	__IO uint8_t OTG_FS_DIEPINT5; // @424 device endpoint-5 interrupt register
	 uint8_t RESERVED30[7]; // @425 
	__IO uint32_t OTG_FS_DIEPTSIZ55; // @432 device endpoint-5 transfer size register
	 uint8_t RESERVED31[4]; // @436 
	__IO uint16_t OTG_FS_DTXFSTS55; // @440 OTG_FS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED32[326]; // @442 
	__IO uint32_t OTG_FS_DOEPCTL0; // @768 device endpoint-0 control register
	 uint8_t RESERVED33[4]; // @772 
	__IO uint8_t OTG_FS_DOEPINT0; // @776 device endpoint-0 interrupt register
	 uint8_t RESERVED34[7]; // @777 
	__IO uint32_t OTG_FS_DOEPTSIZ0; // @784 device OUT endpoint-0 transfer size register
	 uint8_t RESERVED35[12]; // @788 
	__IO uint32_t OTG_FS_DOEPCTL1; // @800 device endpoint-1 control register
	 uint8_t RESERVED36[4]; // @804 
	__IO uint8_t OTG_FS_DOEPINT1; // @808 device endpoint-1 interrupt register
	 uint8_t RESERVED37[7]; // @809 
	__IO uint32_t OTG_FS_DOEPTSIZ1; // @816 device OUT endpoint-1 transfer size register
	 uint8_t RESERVED38[12]; // @820 
	__IO uint32_t OTG_FS_DOEPCTL2; // @832 device endpoint-2 control register
	 uint8_t RESERVED39[4]; // @836 
	__IO uint8_t OTG_FS_DOEPINT2; // @840 device endpoint-2 interrupt register
	 uint8_t RESERVED40[7]; // @841 
	__IO uint32_t OTG_FS_DOEPTSIZ2; // @848 device OUT endpoint-2 transfer size register
	 uint8_t RESERVED41[12]; // @852 
	__IO uint32_t OTG_FS_DOEPCTL3; // @864 device endpoint-3 control register
	 uint8_t RESERVED42[4]; // @868 
	__IO uint8_t OTG_FS_DOEPINT3; // @872 device endpoint-3 interrupt register
	 uint8_t RESERVED43[7]; // @873 
	__IO uint32_t OTG_FS_DOEPTSIZ3; // @880 device OUT endpoint-3 transfer size register
	 uint8_t RESERVED44[4]; // @884 
	__IO uint32_t OTG_FS_DOEPCTL4; // @888 device endpoint-4 control register
	 uint8_t RESERVED45[4]; // @892 
	__IO uint8_t OTG_FS_DOEPINT4; // @896 device endpoint-4 interrupt register
	 uint8_t RESERVED46[7]; // @897 
	__IO uint32_t OTG_FS_DOEPTSIZ4; // @904 device OUT endpoint-4 transfer size register
	 uint8_t RESERVED47[4]; // @908 
	__IO uint32_t OTG_FS_DOEPCTL5; // @912 device endpoint-5 control register
	 uint8_t RESERVED48[4]; // @916 
	__IO uint8_t OTG_FS_DOEPINT5; // @920 device endpoint-5 interrupt register
	 uint8_t RESERVED49[7]; // @921 
	__IO uint32_t OTG_FS_DOEPTSIZ5; // @928 device OUT endpoint-5 transfer size register
};

// OTG_FS_DEVICE->OTG_FS_DCFG OTG_FS device configuration register (OTG_FS_DCFG)
enum {
	OTG_FS_DEVICE_OTG_FS_DCFG_PFIVL = ((1UL<<2)-1) << 11, // Periodic frame interval
	OTG_FS_DEVICE_OTG_FS_DCFG_DAD = ((1UL<<7)-1) << 4, // Device address
	OTG_FS_DEVICE_OTG_FS_DCFG_NZLSOHSK = 1UL<<2, // Non-zero-length status OUT handshake
	OTG_FS_DEVICE_OTG_FS_DCFG_DSPD = ((1UL<<2)-1) << 0, // Device speed		
};
inline void otg_fs_device_otg_fs_dcfg_set_pfivl(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DCFG = (p->OTG_FS_DCFG & ~OTG_FS_DEVICE_OTG_FS_DCFG_PFIVL) | ((val<<11) & OTG_FS_DEVICE_OTG_FS_DCFG_PFIVL); }
inline void otg_fs_device_otg_fs_dcfg_set_dad(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DCFG = (p->OTG_FS_DCFG & ~OTG_FS_DEVICE_OTG_FS_DCFG_DAD) | ((val<<4) & OTG_FS_DEVICE_OTG_FS_DCFG_DAD); }
inline void otg_fs_device_otg_fs_dcfg_set_dspd(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DCFG = (p->OTG_FS_DCFG & ~OTG_FS_DEVICE_OTG_FS_DCFG_DSPD) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DCFG_DSPD); }
inline uint32_t otg_fs_device_otg_fs_dcfg_get_pfivl(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DCFG & OTG_FS_DEVICE_OTG_FS_DCFG_PFIVL) >> 11 ; }
inline uint32_t otg_fs_device_otg_fs_dcfg_get_dad(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DCFG & OTG_FS_DEVICE_OTG_FS_DCFG_DAD) >> 4 ; }
inline uint32_t otg_fs_device_otg_fs_dcfg_get_dspd(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DCFG & OTG_FS_DEVICE_OTG_FS_DCFG_DSPD) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DCTL OTG_FS device control register (OTG_FS_DCTL)
enum {
	OTG_FS_DEVICE_OTG_FS_DCTL_POPRGDNE = 1UL<<11, // Power-on programming done
	OTG_FS_DEVICE_OTG_FS_DCTL_CGONAK = 1UL<<10, // Clear global OUT NAK
	OTG_FS_DEVICE_OTG_FS_DCTL_SGONAK = 1UL<<9, // Set global OUT NAK
	OTG_FS_DEVICE_OTG_FS_DCTL_CGINAK = 1UL<<8, // Clear global IN NAK
	OTG_FS_DEVICE_OTG_FS_DCTL_SGINAK = 1UL<<7, // Set global IN NAK
	OTG_FS_DEVICE_OTG_FS_DCTL_TCTL = ((1UL<<3)-1) << 4, // Test control
	OTG_FS_DEVICE_OTG_FS_DCTL_GONSTS = 1UL<<3, // Global OUT NAK status
	OTG_FS_DEVICE_OTG_FS_DCTL_GINSTS = 1UL<<2, // Global IN NAK status
	OTG_FS_DEVICE_OTG_FS_DCTL_SDIS = 1UL<<1, // Soft disconnect
	OTG_FS_DEVICE_OTG_FS_DCTL_RWUSIG = 1UL<<0, // Remote wakeup signaling		
};
inline void otg_fs_device_otg_fs_dctl_set_tctl(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DCTL = (p->OTG_FS_DCTL & ~OTG_FS_DEVICE_OTG_FS_DCTL_TCTL) | ((val<<4) & OTG_FS_DEVICE_OTG_FS_DCTL_TCTL); }
inline uint32_t otg_fs_device_otg_fs_dctl_get_tctl(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DCTL & OTG_FS_DEVICE_OTG_FS_DCTL_TCTL) >> 4 ; }

// OTG_FS_DEVICE->OTG_FS_DSTS OTG_FS device status register (OTG_FS_DSTS)
enum {
	OTG_FS_DEVICE_OTG_FS_DSTS_FNSOF = ((1UL<<14)-1) << 8, // Frame number of the received SOF
	OTG_FS_DEVICE_OTG_FS_DSTS_EERR = 1UL<<3, // Erratic error
	OTG_FS_DEVICE_OTG_FS_DSTS_ENUMSPD = ((1UL<<2)-1) << 1, // Enumerated speed
	OTG_FS_DEVICE_OTG_FS_DSTS_SUSPSTS = 1UL<<0, // Suspend status		
};
inline uint32_t otg_fs_device_otg_fs_dsts_get_fnsof(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DSTS & OTG_FS_DEVICE_OTG_FS_DSTS_FNSOF) >> 8 ; }
inline uint32_t otg_fs_device_otg_fs_dsts_get_enumspd(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DSTS & OTG_FS_DEVICE_OTG_FS_DSTS_ENUMSPD) >> 1 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPMSK OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPMSK_INEPNEM = 1UL<<6, // IN endpoint NAK effective mask
	OTG_FS_DEVICE_OTG_FS_DIEPMSK_INEPNMM = 1UL<<5, // IN token received with EP mismatch mask
	OTG_FS_DEVICE_OTG_FS_DIEPMSK_ITTXFEMSK = 1UL<<4, // IN token received when TxFIFO empty mask
	OTG_FS_DEVICE_OTG_FS_DIEPMSK_TOM = 1UL<<3, // Timeout condition mask (Non-isochronous endpoints)
	OTG_FS_DEVICE_OTG_FS_DIEPMSK_EPDM = 1UL<<1, // Endpoint disabled interrupt mask
	OTG_FS_DEVICE_OTG_FS_DIEPMSK_XFRCM = 1UL<<0, // Transfer completed interrupt mask		
};

// OTG_FS_DEVICE->OTG_FS_DOEPMSK OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPMSK_OTEPDM = 1UL<<4, // OUT token received when endpoint disabled mask
	OTG_FS_DEVICE_OTG_FS_DOEPMSK_STUPM = 1UL<<3, // SETUP phase done mask
	OTG_FS_DEVICE_OTG_FS_DOEPMSK_EPDM = 1UL<<1, // Endpoint disabled interrupt mask
	OTG_FS_DEVICE_OTG_FS_DOEPMSK_XFRCM = 1UL<<0, // Transfer completed interrupt mask		
};

// OTG_FS_DEVICE->OTG_FS_DAINT OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
enum {
	OTG_FS_DEVICE_OTG_FS_DAINT_OEPINT = ((1UL<<16)-1) << 16, // OUT endpoint interrupt bits
	OTG_FS_DEVICE_OTG_FS_DAINT_IEPINT = ((1UL<<16)-1) << 0, // IN endpoint interrupt bits		
};
inline uint32_t otg_fs_device_otg_fs_daint_get_oepint(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DAINT & OTG_FS_DEVICE_OTG_FS_DAINT_OEPINT) >> 16 ; }
inline uint32_t otg_fs_device_otg_fs_daint_get_iepint(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DAINT & OTG_FS_DEVICE_OTG_FS_DAINT_IEPINT) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DAINTMSK OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
enum {
	OTG_FS_DEVICE_OTG_FS_DAINTMSK_OEPINT = ((1UL<<16)-1) << 16, // OUT endpoint interrupt bits
	OTG_FS_DEVICE_OTG_FS_DAINTMSK_IEPM = ((1UL<<16)-1) << 0, // IN EP interrupt mask bits		
};
inline void otg_fs_device_otg_fs_daintmsk_set_oepint(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DAINTMSK = (p->OTG_FS_DAINTMSK & ~OTG_FS_DEVICE_OTG_FS_DAINTMSK_OEPINT) | ((val<<16) & OTG_FS_DEVICE_OTG_FS_DAINTMSK_OEPINT); }
inline void otg_fs_device_otg_fs_daintmsk_set_iepm(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DAINTMSK = (p->OTG_FS_DAINTMSK & ~OTG_FS_DEVICE_OTG_FS_DAINTMSK_IEPM) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DAINTMSK_IEPM); }
inline uint32_t otg_fs_device_otg_fs_daintmsk_get_oepint(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DAINTMSK & OTG_FS_DEVICE_OTG_FS_DAINTMSK_OEPINT) >> 16 ; }
inline uint32_t otg_fs_device_otg_fs_daintmsk_get_iepm(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DAINTMSK & OTG_FS_DEVICE_OTG_FS_DAINTMSK_IEPM) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DVBUSPULSE OTG_FS device VBUS pulsing time register
enum {
	OTG_FS_DEVICE_OTG_FS_DVBUSPULSE_DVBUSP = ((1UL<<12)-1) << 0, // Device VBUS pulsing time		
};
inline void otg_fs_device_otg_fs_dvbuspulse_set_dvbusp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DVBUSPULSE = (p->OTG_FS_DVBUSPULSE & ~OTG_FS_DEVICE_OTG_FS_DVBUSPULSE_DVBUSP) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DVBUSPULSE_DVBUSP); }
inline uint32_t otg_fs_device_otg_fs_dvbuspulse_get_dvbusp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DVBUSPULSE & OTG_FS_DEVICE_OTG_FS_DVBUSPULSE_DVBUSP) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPCTL0 OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_EPENA = 1UL<<31, // Endpoint enable
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_EPDIS = 1UL<<30, // Endpoint disable
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_SNAK = 1UL<<27, // Set NAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_CNAK = 1UL<<26, // Clear NAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_STALL = 1UL<<21, // STALL handshake
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_NAKSTS = 1UL<<17, // NAK status
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_USBAEP = 1UL<<15, // USB active endpoint
	OTG_FS_DEVICE_OTG_FS_DIEPCTL0_MPSIZ = ((1UL<<2)-1) << 0, // Maximum packet size		
};
inline void otg_fs_device_otg_fs_diepctl0_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL0 = (p->OTG_FS_DIEPCTL0 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL0_TXFNUM) | ((val<<22) & OTG_FS_DEVICE_OTG_FS_DIEPCTL0_TXFNUM); }
inline void otg_fs_device_otg_fs_diepctl0_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL0 = (p->OTG_FS_DIEPCTL0 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL0_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DIEPCTL0_EPTYP); }
inline void otg_fs_device_otg_fs_diepctl0_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL0 = (p->OTG_FS_DIEPCTL0 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL0_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPCTL0_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_diepctl0_get_txfnum(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL0 & OTG_FS_DEVICE_OTG_FS_DIEPCTL0_TXFNUM) >> 22 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl0_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL0 & OTG_FS_DEVICE_OTG_FS_DIEPCTL0_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl0_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL0 & OTG_FS_DEVICE_OTG_FS_DIEPCTL0_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPINT0 device endpoint-x interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPINT0_TXFE = 1UL<<7, // TXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT0_INEPNE = 1UL<<6, // INEPNE
	OTG_FS_DEVICE_OTG_FS_DIEPINT0_ITTXFE = 1UL<<4, // ITTXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT0_TOC = 1UL<<3, // TOC
	OTG_FS_DEVICE_OTG_FS_DIEPINT0_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DIEPINT0_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DIEPTSIZ0 device endpoint-0 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_PKTCNT = ((1UL<<2)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_XFRSIZ = ((1UL<<7)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_dieptsiz0_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ0 = (p->OTG_FS_DIEPTSIZ0 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_PKTCNT); }
inline void otg_fs_device_otg_fs_dieptsiz0_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ0 = (p->OTG_FS_DIEPTSIZ0 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_dieptsiz0_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ0 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz0_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ0 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ0_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPCTL1 OTG device endpoint-1 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_SODDFRM_SD1PID = 1UL<<29, // SODDFRM/SD1PID
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_TXFNUM = ((1UL<<4)-1) << 22, // TXFNUM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL1_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_diepctl1_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL1 = (p->OTG_FS_DIEPCTL1 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL1_TXFNUM) | ((val<<22) & OTG_FS_DEVICE_OTG_FS_DIEPCTL1_TXFNUM); }
inline void otg_fs_device_otg_fs_diepctl1_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL1 = (p->OTG_FS_DIEPCTL1 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EPTYP); }
inline void otg_fs_device_otg_fs_diepctl1_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL1 = (p->OTG_FS_DIEPCTL1 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL1_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPCTL1_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_diepctl1_get_txfnum(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL1 & OTG_FS_DEVICE_OTG_FS_DIEPCTL1_TXFNUM) >> 22 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl1_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL1 & OTG_FS_DEVICE_OTG_FS_DIEPCTL1_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl1_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL1 & OTG_FS_DEVICE_OTG_FS_DIEPCTL1_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPINT1 device endpoint-1 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPINT1_TXFE = 1UL<<7, // TXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT1_INEPNE = 1UL<<6, // INEPNE
	OTG_FS_DEVICE_OTG_FS_DIEPINT1_ITTXFE = 1UL<<4, // ITTXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT1_TOC = 1UL<<3, // TOC
	OTG_FS_DEVICE_OTG_FS_DIEPINT1_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DIEPINT1_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DIEPTSIZ1 device endpoint-1 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_dieptsiz1_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ1 = (p->OTG_FS_DIEPTSIZ1 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_MCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_MCNT); }
inline void otg_fs_device_otg_fs_dieptsiz1_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ1 = (p->OTG_FS_DIEPTSIZ1 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_PKTCNT); }
inline void otg_fs_device_otg_fs_dieptsiz1_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ1 = (p->OTG_FS_DIEPTSIZ1 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_dieptsiz1_get_mcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ1 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_MCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz1_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ1 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz1_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ1 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ1_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPCTL2 OTG device endpoint-2 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_TXFNUM = ((1UL<<4)-1) << 22, // TXFNUM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL2_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_diepctl2_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL2 = (p->OTG_FS_DIEPCTL2 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL2_TXFNUM) | ((val<<22) & OTG_FS_DEVICE_OTG_FS_DIEPCTL2_TXFNUM); }
inline void otg_fs_device_otg_fs_diepctl2_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL2 = (p->OTG_FS_DIEPCTL2 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EPTYP); }
inline void otg_fs_device_otg_fs_diepctl2_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL2 = (p->OTG_FS_DIEPCTL2 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL2_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPCTL2_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_diepctl2_get_txfnum(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL2 & OTG_FS_DEVICE_OTG_FS_DIEPCTL2_TXFNUM) >> 22 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl2_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL2 & OTG_FS_DEVICE_OTG_FS_DIEPCTL2_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl2_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL2 & OTG_FS_DEVICE_OTG_FS_DIEPCTL2_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPINT2 device endpoint-2 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPINT2_TXFE = 1UL<<7, // TXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT2_INEPNE = 1UL<<6, // INEPNE
	OTG_FS_DEVICE_OTG_FS_DIEPINT2_ITTXFE = 1UL<<4, // ITTXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT2_TOC = 1UL<<3, // TOC
	OTG_FS_DEVICE_OTG_FS_DIEPINT2_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DIEPINT2_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DIEPTSIZ2 device endpoint-2 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_dieptsiz2_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ2 = (p->OTG_FS_DIEPTSIZ2 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_MCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_MCNT); }
inline void otg_fs_device_otg_fs_dieptsiz2_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ2 = (p->OTG_FS_DIEPTSIZ2 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_PKTCNT); }
inline void otg_fs_device_otg_fs_dieptsiz2_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ2 = (p->OTG_FS_DIEPTSIZ2 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_dieptsiz2_get_mcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ2 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_MCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz2_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ2 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz2_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ2 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ2_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPCTL3 OTG device endpoint-3 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_TXFNUM = ((1UL<<4)-1) << 22, // TXFNUM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL3_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_diepctl3_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL3 = (p->OTG_FS_DIEPCTL3 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL3_TXFNUM) | ((val<<22) & OTG_FS_DEVICE_OTG_FS_DIEPCTL3_TXFNUM); }
inline void otg_fs_device_otg_fs_diepctl3_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL3 = (p->OTG_FS_DIEPCTL3 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EPTYP); }
inline void otg_fs_device_otg_fs_diepctl3_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL3 = (p->OTG_FS_DIEPCTL3 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL3_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPCTL3_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_diepctl3_get_txfnum(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL3 & OTG_FS_DEVICE_OTG_FS_DIEPCTL3_TXFNUM) >> 22 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl3_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL3 & OTG_FS_DEVICE_OTG_FS_DIEPCTL3_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl3_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL3 & OTG_FS_DEVICE_OTG_FS_DIEPCTL3_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPINT3 device endpoint-3 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPINT3_TXFE = 1UL<<7, // TXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT3_INEPNE = 1UL<<6, // INEPNE
	OTG_FS_DEVICE_OTG_FS_DIEPINT3_ITTXFE = 1UL<<4, // ITTXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT3_TOC = 1UL<<3, // TOC
	OTG_FS_DEVICE_OTG_FS_DIEPINT3_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DIEPINT3_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DIEPTSIZ3 device endpoint-3 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_dieptsiz3_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ3 = (p->OTG_FS_DIEPTSIZ3 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_MCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_MCNT); }
inline void otg_fs_device_otg_fs_dieptsiz3_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ3 = (p->OTG_FS_DIEPTSIZ3 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_PKTCNT); }
inline void otg_fs_device_otg_fs_dieptsiz3_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ3 = (p->OTG_FS_DIEPTSIZ3 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_dieptsiz3_get_mcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ3 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_MCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz3_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ3 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz3_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ3 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ3_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPCTL4 OTG device endpoint-4 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_TXFNUM = ((1UL<<4)-1) << 22, // TXFNUM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL4_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_diepctl4_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL4 = (p->OTG_FS_DIEPCTL4 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL4_TXFNUM) | ((val<<22) & OTG_FS_DEVICE_OTG_FS_DIEPCTL4_TXFNUM); }
inline void otg_fs_device_otg_fs_diepctl4_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL4 = (p->OTG_FS_DIEPCTL4 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EPTYP); }
inline void otg_fs_device_otg_fs_diepctl4_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL4 = (p->OTG_FS_DIEPCTL4 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL4_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPCTL4_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_diepctl4_get_txfnum(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL4 & OTG_FS_DEVICE_OTG_FS_DIEPCTL4_TXFNUM) >> 22 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl4_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL4 & OTG_FS_DEVICE_OTG_FS_DIEPCTL4_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl4_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL4 & OTG_FS_DEVICE_OTG_FS_DIEPCTL4_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPINT4 device endpoint-4 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPINT4_TXFE = 1UL<<7, // TXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT4_INEPNE = 1UL<<6, // INEPNE
	OTG_FS_DEVICE_OTG_FS_DIEPINT4_ITTXFE = 1UL<<4, // ITTXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT4_TOC = 1UL<<3, // TOC
	OTG_FS_DEVICE_OTG_FS_DIEPINT4_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DIEPINT4_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DIEPTSIZ4 device endpoint-4 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_dieptsiz4_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ4 = (p->OTG_FS_DIEPTSIZ4 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_MCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_MCNT); }
inline void otg_fs_device_otg_fs_dieptsiz4_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ4 = (p->OTG_FS_DIEPTSIZ4 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_PKTCNT); }
inline void otg_fs_device_otg_fs_dieptsiz4_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ4 = (p->OTG_FS_DIEPTSIZ4 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_dieptsiz4_get_mcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ4 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_MCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz4_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ4 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz4_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ4 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ4_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPCTL5 OTG device endpoint-5 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_TXFNUM = ((1UL<<4)-1) << 22, // TXFNUM
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DIEPCTL5_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_diepctl5_set_txfnum(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL5 = (p->OTG_FS_DIEPCTL5 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL5_TXFNUM) | ((val<<22) & OTG_FS_DEVICE_OTG_FS_DIEPCTL5_TXFNUM); }
inline void otg_fs_device_otg_fs_diepctl5_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL5 = (p->OTG_FS_DIEPCTL5 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EPTYP); }
inline void otg_fs_device_otg_fs_diepctl5_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPCTL5 = (p->OTG_FS_DIEPCTL5 & ~OTG_FS_DEVICE_OTG_FS_DIEPCTL5_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPCTL5_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_diepctl5_get_txfnum(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL5 & OTG_FS_DEVICE_OTG_FS_DIEPCTL5_TXFNUM) >> 22 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl5_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL5 & OTG_FS_DEVICE_OTG_FS_DIEPCTL5_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_diepctl5_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPCTL5 & OTG_FS_DEVICE_OTG_FS_DIEPCTL5_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DIEPINT5 device endpoint-5 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPINT5_TXFE = 1UL<<7, // TXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT5_INEPNE = 1UL<<6, // INEPNE
	OTG_FS_DEVICE_OTG_FS_DIEPINT5_ITTXFE = 1UL<<4, // ITTXFE
	OTG_FS_DEVICE_OTG_FS_DIEPINT5_TOC = 1UL<<3, // TOC
	OTG_FS_DEVICE_OTG_FS_DIEPINT5_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DIEPINT5_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DIEPTSIZ55 device endpoint-5 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_dieptsiz55_set_mcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ55 = (p->OTG_FS_DIEPTSIZ55 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_MCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_MCNT); }
inline void otg_fs_device_otg_fs_dieptsiz55_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ55 = (p->OTG_FS_DIEPTSIZ55 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_PKTCNT); }
inline void otg_fs_device_otg_fs_dieptsiz55_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DIEPTSIZ55 = (p->OTG_FS_DIEPTSIZ55 & ~OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_dieptsiz55_get_mcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ55 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_MCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz55_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ55 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_dieptsiz55_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DIEPTSIZ55 & OTG_FS_DEVICE_OTG_FS_DIEPTSIZ55_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPCTL0 device endpoint-0 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_SNPM = 1UL<<20, // SNPM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL0_MPSIZ = ((1UL<<2)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_doepctl0_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL0 = (p->OTG_FS_DOEPCTL0 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL0_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DOEPCTL0_EPTYP); }
inline void otg_fs_device_otg_fs_doepctl0_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL0 = (p->OTG_FS_DOEPCTL0 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL0_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPCTL0_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_doepctl0_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL0 & OTG_FS_DEVICE_OTG_FS_DOEPCTL0_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_doepctl0_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL0 & OTG_FS_DEVICE_OTG_FS_DOEPCTL0_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPINT0 device endpoint-0 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPINT0_B2BSTUP = 1UL<<6, // B2BSTUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT0_OTEPDIS = 1UL<<4, // OTEPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPINT0_STUP = 1UL<<3, // STUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT0_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DOEPINT0_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DOEPTSIZ0 device OUT endpoint-0 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_STUPCNT = ((1UL<<2)-1) << 29, // SETUP packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_PKTCNT = 1UL<<19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_XFRSIZ = ((1UL<<7)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_doeptsiz0_set_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ0 = (p->OTG_FS_DOEPTSIZ0 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_STUPCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_STUPCNT); }
inline void otg_fs_device_otg_fs_doeptsiz0_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ0 = (p->OTG_FS_DOEPTSIZ0 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_doeptsiz0_get_stupcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ0 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_STUPCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz0_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ0 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ0_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPCTL1 device endpoint-1 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_SNPM = 1UL<<20, // SNPM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL1_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_doepctl1_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL1 = (p->OTG_FS_DOEPCTL1 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EPTYP); }
inline void otg_fs_device_otg_fs_doepctl1_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL1 = (p->OTG_FS_DOEPCTL1 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL1_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPCTL1_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_doepctl1_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL1 & OTG_FS_DEVICE_OTG_FS_DOEPCTL1_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_doepctl1_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL1 & OTG_FS_DEVICE_OTG_FS_DOEPCTL1_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPINT1 device endpoint-1 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPINT1_B2BSTUP = 1UL<<6, // B2BSTUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT1_OTEPDIS = 1UL<<4, // OTEPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPINT1_STUP = 1UL<<3, // STUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT1_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DOEPINT1_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DOEPTSIZ1 device OUT endpoint-1 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_doeptsiz1_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ1 = (p->OTG_FS_DOEPTSIZ1 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_RXDPID_STUPCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_RXDPID_STUPCNT); }
inline void otg_fs_device_otg_fs_doeptsiz1_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ1 = (p->OTG_FS_DOEPTSIZ1 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_PKTCNT); }
inline void otg_fs_device_otg_fs_doeptsiz1_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ1 = (p->OTG_FS_DOEPTSIZ1 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_doeptsiz1_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ1 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz1_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ1 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz1_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ1 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ1_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPCTL2 device endpoint-2 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_SNPM = 1UL<<20, // SNPM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL2_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_doepctl2_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL2 = (p->OTG_FS_DOEPCTL2 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EPTYP); }
inline void otg_fs_device_otg_fs_doepctl2_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL2 = (p->OTG_FS_DOEPCTL2 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL2_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPCTL2_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_doepctl2_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL2 & OTG_FS_DEVICE_OTG_FS_DOEPCTL2_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_doepctl2_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL2 & OTG_FS_DEVICE_OTG_FS_DOEPCTL2_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPINT2 device endpoint-2 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPINT2_B2BSTUP = 1UL<<6, // B2BSTUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT2_OTEPDIS = 1UL<<4, // OTEPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPINT2_STUP = 1UL<<3, // STUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT2_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DOEPINT2_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DOEPTSIZ2 device OUT endpoint-2 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_doeptsiz2_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ2 = (p->OTG_FS_DOEPTSIZ2 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_RXDPID_STUPCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_RXDPID_STUPCNT); }
inline void otg_fs_device_otg_fs_doeptsiz2_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ2 = (p->OTG_FS_DOEPTSIZ2 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_PKTCNT); }
inline void otg_fs_device_otg_fs_doeptsiz2_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ2 = (p->OTG_FS_DOEPTSIZ2 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_doeptsiz2_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ2 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz2_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ2 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz2_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ2 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ2_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPCTL3 device endpoint-3 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_SNPM = 1UL<<20, // SNPM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL3_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_doepctl3_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL3 = (p->OTG_FS_DOEPCTL3 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EPTYP); }
inline void otg_fs_device_otg_fs_doepctl3_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL3 = (p->OTG_FS_DOEPCTL3 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL3_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPCTL3_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_doepctl3_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL3 & OTG_FS_DEVICE_OTG_FS_DOEPCTL3_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_doepctl3_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL3 & OTG_FS_DEVICE_OTG_FS_DOEPCTL3_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPINT3 device endpoint-3 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPINT3_B2BSTUP = 1UL<<6, // B2BSTUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT3_OTEPDIS = 1UL<<4, // OTEPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPINT3_STUP = 1UL<<3, // STUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT3_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DOEPINT3_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DOEPTSIZ3 device OUT endpoint-3 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_doeptsiz3_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ3 = (p->OTG_FS_DOEPTSIZ3 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_RXDPID_STUPCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_RXDPID_STUPCNT); }
inline void otg_fs_device_otg_fs_doeptsiz3_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ3 = (p->OTG_FS_DOEPTSIZ3 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_PKTCNT); }
inline void otg_fs_device_otg_fs_doeptsiz3_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ3 = (p->OTG_FS_DOEPTSIZ3 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_doeptsiz3_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ3 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz3_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ3 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz3_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ3 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ3_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPCTL4 device endpoint-4 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_SNPM = 1UL<<20, // SNPM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL4_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_doepctl4_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL4 = (p->OTG_FS_DOEPCTL4 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EPTYP); }
inline void otg_fs_device_otg_fs_doepctl4_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL4 = (p->OTG_FS_DOEPCTL4 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL4_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPCTL4_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_doepctl4_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL4 & OTG_FS_DEVICE_OTG_FS_DOEPCTL4_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_doepctl4_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL4 & OTG_FS_DEVICE_OTG_FS_DOEPCTL4_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPINT4 device endpoint-4 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPINT4_B2BSTUP = 1UL<<6, // B2BSTUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT4_OTEPDIS = 1UL<<4, // OTEPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPINT4_STUP = 1UL<<3, // STUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT4_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DOEPINT4_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DOEPTSIZ4 device OUT endpoint-4 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_doeptsiz4_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ4 = (p->OTG_FS_DOEPTSIZ4 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_RXDPID_STUPCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_RXDPID_STUPCNT); }
inline void otg_fs_device_otg_fs_doeptsiz4_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ4 = (p->OTG_FS_DOEPTSIZ4 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_PKTCNT); }
inline void otg_fs_device_otg_fs_doeptsiz4_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ4 = (p->OTG_FS_DOEPTSIZ4 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_doeptsiz4_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ4 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz4_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ4 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz4_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ4 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ4_XFRSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPCTL5 device endpoint-5 control register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EPENA = 1UL<<31, // EPENA
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EPDIS = 1UL<<30, // EPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_SODDFRM = 1UL<<29, // SODDFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_SD0PID_SEVNFRM = 1UL<<28, // SD0PID/SEVNFRM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_SNAK = 1UL<<27, // SNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_CNAK = 1UL<<26, // CNAK
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_STALL = 1UL<<21, // Stall
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_SNPM = 1UL<<20, // SNPM
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EPTYP = ((1UL<<2)-1) << 18, // EPTYP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_NAKSTS = 1UL<<17, // NAKSTS
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EONUM_DPID = 1UL<<16, // EONUM/DPID
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_USBAEP = 1UL<<15, // USBAEP
	OTG_FS_DEVICE_OTG_FS_DOEPCTL5_MPSIZ = ((1UL<<11)-1) << 0, // MPSIZ		
};
inline void otg_fs_device_otg_fs_doepctl5_set_eptyp(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL5 = (p->OTG_FS_DOEPCTL5 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EPTYP) | ((val<<18) & OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EPTYP); }
inline void otg_fs_device_otg_fs_doepctl5_set_mpsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPCTL5 = (p->OTG_FS_DOEPCTL5 & ~OTG_FS_DEVICE_OTG_FS_DOEPCTL5_MPSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPCTL5_MPSIZ); }
inline uint32_t otg_fs_device_otg_fs_doepctl5_get_eptyp(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL5 & OTG_FS_DEVICE_OTG_FS_DOEPCTL5_EPTYP) >> 18 ; }
inline uint32_t otg_fs_device_otg_fs_doepctl5_get_mpsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPCTL5 & OTG_FS_DEVICE_OTG_FS_DOEPCTL5_MPSIZ) >> 0 ; }

// OTG_FS_DEVICE->OTG_FS_DOEPINT5 device endpoint-5 interrupt register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPINT5_B2BSTUP = 1UL<<6, // B2BSTUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT5_OTEPDIS = 1UL<<4, // OTEPDIS
	OTG_FS_DEVICE_OTG_FS_DOEPINT5_STUP = 1UL<<3, // STUP
	OTG_FS_DEVICE_OTG_FS_DOEPINT5_EPDISD = 1UL<<1, // EPDISD
	OTG_FS_DEVICE_OTG_FS_DOEPINT5_XFRC = 1UL<<0, // XFRC		
};

// OTG_FS_DEVICE->OTG_FS_DOEPTSIZ5 device OUT endpoint-5 transfer size register
enum {
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_device_otg_fs_doeptsiz5_set_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ5 = (p->OTG_FS_DOEPTSIZ5 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_RXDPID_STUPCNT) | ((val<<29) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_RXDPID_STUPCNT); }
inline void otg_fs_device_otg_fs_doeptsiz5_set_pktcnt(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ5 = (p->OTG_FS_DOEPTSIZ5 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_PKTCNT) | ((val<<19) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_PKTCNT); }
inline void otg_fs_device_otg_fs_doeptsiz5_set_xfrsiz(struct OTG_FS_DEVICE_Type* p, uint32_t val) { p->OTG_FS_DOEPTSIZ5 = (p->OTG_FS_DOEPTSIZ5 & ~OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_XFRSIZ) | ((val<<0) & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_XFRSIZ); }
inline uint32_t otg_fs_device_otg_fs_doeptsiz5_get_rxdpid_stupcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ5 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz5_get_pktcnt(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ5 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_device_otg_fs_doeptsiz5_get_xfrsiz(struct OTG_FS_DEVICE_Type* p) { return (p->OTG_FS_DOEPTSIZ5 & OTG_FS_DEVICE_OTG_FS_DOEPTSIZ5_XFRSIZ) >> 0 ; }

/* USB on the go full speed */
struct OTG_FS_GLOBAL_Type {
	__IO uint32_t OTG_FS_GOTGCTL; // @0 OTG_FS control and status register (OTG_FS_GOTGCTL)
	__IO uint32_t OTG_FS_GOTGINT; // @4 OTG_FS interrupt register (OTG_FS_GOTGINT)
	__IO uint16_t OTG_FS_GAHBCFG; // @8 OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t OTG_FS_GUSBCFG; // @12 OTG_FS USB configuration register (OTG_FS_GUSBCFG)
	__IO uint32_t OTG_FS_GRSTCTL; // @16 OTG_FS reset register (OTG_FS_GRSTCTL)
	__IO uint32_t OTG_FS_GINTSTS; // @20 OTG_FS core interrupt register (OTG_FS_GINTSTS)
	__IO uint32_t OTG_FS_GINTMSK; // @24 OTG_FS interrupt mask register (OTG_FS_GINTMSK)
	union {  // @28
		__I uint32_t OTG_FS_GRXSTSR_Device; // OTG_FS Receive status debug read(Device mode)
		__I uint32_t OTG_FS_GRXSTSR_Host; // OTG_FS Receive status debug read(Host mode)
	};
	union {  // @32
		__I uint32_t OTG_FS_GRXSTSP_Device; // OTG status read and pop register (Device mode)
		__I uint32_t OTG_FS_GRXSTSP_Host; // OTG status read and pop register (Host mode)
	};
	__IO uint16_t OTG_FS_GRXFSIZ; // @36 OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
	 uint8_t RESERVED1[2]; // @38 
	union {  // @40
		__IO uint32_t OTG_FS_DIEPTXF0_Device; // OTG_FS Endpoint 0 Transmit FIFO size
		__IO uint32_t OTG_FS_HNPTXFSIZ_Host; // OTG_FS Host non-periodic transmit FIFO size register
	};
	__I uint32_t OTG_FS_HNPTXSTS; // @44 OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
	__IO uint32_t OTG_FS_GI2CCTL; // @48 OTG I2C access register
	 uint8_t RESERVED2[4]; // @52 
	__IO uint32_t OTG_FS_GCCFG; // @56 OTG_FS general core configuration register (OTG_FS_GCCFG)
	__IO uint32_t OTG_FS_CID; // @60 core ID register
	 uint8_t RESERVED3[20]; // @64 
	__IO uint32_t OTG_FS_GLPMCFG; // @84 OTG core LPM configuration register
	__IO uint32_t OTG_FS_GPWRDN; // @88 OTG power down register
	 uint8_t RESERVED4[4]; // @92 
	__IO uint32_t OTG_FS_GADPCTL; // @96 OTG ADP timer, control and status register
	 uint8_t RESERVED5[156]; // @100 
	__IO uint32_t OTG_FS_HPTXFSIZ; // @256 OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
	__IO uint32_t OTG_FS_DIEPTXF1; // @260 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
	__IO uint32_t OTG_FS_DIEPTXF2; // @264 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
	__IO uint32_t OTG_FS_DIEPTXF3; // @268 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
	__IO uint32_t OTG_FS_DIEPTXF4; // @272 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
	__IO uint32_t OTG_FS_DIEPTXF5; // @276 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)
};

// OTG_FS_GLOBAL->OTG_FS_GOTGCTL OTG_FS control and status register (OTG_FS_GOTGCTL)
enum {
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_OTGVER = 1UL<<20, // OTG version
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_BSVLD = 1UL<<19, // B-session valid
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_ASVLD = 1UL<<18, // A-session valid
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_DBCT = 1UL<<17, // Long/short debounce time
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_CIDSTS = 1UL<<16, // Connector ID status
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_EHEN = 1UL<<12, // Embedded host enable
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_DHNPEN = 1UL<<11, // Device HNP enabled
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_HSHNPEN = 1UL<<10, // Host set HNP enable
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_HNPRQ = 1UL<<9, // HNP request
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_HNGSCS = 1UL<<8, // Host negotiation success
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_BVALOVAL = 1UL<<7, // B-peripheral session valid override value
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_BVALOEN = 1UL<<6, // B-peripheral session valid override enable
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_AVALOVAL = 1UL<<5, // A-peripheral session valid override value
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_AVALOEN = 1UL<<4, // A-peripheral session valid override enable
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_VBVALOVAL = 1UL<<3, // VBUS valid override value
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_VBVALOEN = 1UL<<2, // VBUS valid override enable
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_SRQ = 1UL<<1, // Session request
	OTG_FS_GLOBAL_OTG_FS_GOTGCTL_SRQSCS = 1UL<<0, // Session request success		
};

// OTG_FS_GLOBAL->OTG_FS_GOTGINT OTG_FS interrupt register (OTG_FS_GOTGINT)
enum {
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_IDCHNG = 1UL<<20, // ID input pin changed
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_DBCDNE = 1UL<<19, // Debounce done
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_ADTOCHG = 1UL<<18, // A-device timeout change
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_HNGDET = 1UL<<17, // Host negotiation detected
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_HNSSCHG = 1UL<<9, // Host negotiation success status change
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_SRSSCHG = 1UL<<8, // Session request success status change
	OTG_FS_GLOBAL_OTG_FS_GOTGINT_SEDET = 1UL<<2, // Session end detected		
};

// OTG_FS_GLOBAL->OTG_FS_GAHBCFG OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
enum {
	OTG_FS_GLOBAL_OTG_FS_GAHBCFG_PTXFELVL = 1UL<<8, // Periodic TxFIFO empty level
	OTG_FS_GLOBAL_OTG_FS_GAHBCFG_TXFELVL = 1UL<<7, // TxFIFO empty level
	OTG_FS_GLOBAL_OTG_FS_GAHBCFG_GINT = 1UL<<0, // Global interrupt mask		
};

// OTG_FS_GLOBAL->OTG_FS_GUSBCFG OTG_FS USB configuration register (OTG_FS_GUSBCFG)
enum {
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_FDMOD = 1UL<<30, // Force device mode
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_FHMOD = 1UL<<29, // Force host mode
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TRDT = ((1UL<<4)-1) << 10, // USB turnaround time
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_HNPCAP = 1UL<<9, // HNP-capable
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_SRPCAP = 1UL<<8, // SRP-capable
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_PHYSEL = 1UL<<6, // Full Speed serial transceiver select
	OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TOCAL = ((1UL<<3)-1) << 0, // FS timeout calibration		
};
inline void otg_fs_global_otg_fs_gusbcfg_set_trdt(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GUSBCFG = (p->OTG_FS_GUSBCFG & ~OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TRDT) | ((val<<10) & OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TRDT); }
inline void otg_fs_global_otg_fs_gusbcfg_set_tocal(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GUSBCFG = (p->OTG_FS_GUSBCFG & ~OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TOCAL) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TOCAL); }
inline uint32_t otg_fs_global_otg_fs_gusbcfg_get_trdt(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GUSBCFG & OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TRDT) >> 10 ; }
inline uint32_t otg_fs_global_otg_fs_gusbcfg_get_tocal(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GUSBCFG & OTG_FS_GLOBAL_OTG_FS_GUSBCFG_TOCAL) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_GRSTCTL OTG_FS reset register (OTG_FS_GRSTCTL)
enum {
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_AHBIDL = 1UL<<31, // AHB master idle
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_TXFNUM = ((1UL<<5)-1) << 6, // TxFIFO number
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_TXFFLSH = 1UL<<5, // TxFIFO flush
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_RXFFLSH = 1UL<<4, // RxFIFO flush
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_FCRST = 1UL<<2, // Host frame counter reset
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_HSRST = 1UL<<1, // HCLK soft reset
	OTG_FS_GLOBAL_OTG_FS_GRSTCTL_CSRST = 1UL<<0, // Core soft reset		
};
inline void otg_fs_global_otg_fs_grstctl_set_txfnum(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GRSTCTL = (p->OTG_FS_GRSTCTL & ~OTG_FS_GLOBAL_OTG_FS_GRSTCTL_TXFNUM) | ((val<<6) & OTG_FS_GLOBAL_OTG_FS_GRSTCTL_TXFNUM); }
inline uint32_t otg_fs_global_otg_fs_grstctl_get_txfnum(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRSTCTL & OTG_FS_GLOBAL_OTG_FS_GRSTCTL_TXFNUM) >> 6 ; }

// OTG_FS_GLOBAL->OTG_FS_GINTSTS OTG_FS core interrupt register (OTG_FS_GINTSTS)
enum {
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_WKUPINT = 1UL<<31, // Resume/remote wakeup detected interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_SRQINT = 1UL<<30, // Session request/new session detected interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_DISCINT = 1UL<<29, // Disconnect detected interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_CIDSCHG = 1UL<<28, // Connector ID status change
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_PTXFE = 1UL<<26, // Periodic TxFIFO empty
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_HCINT = 1UL<<25, // Host channels interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_HPRTINT = 1UL<<24, // Host port interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_RSTDET = 1UL<<23, // Reset detected interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_IPXFR_INCOMPISOOUT = 1UL<<21, // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_IISOIXFR = 1UL<<20, // Incomplete isochronous IN transfer
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_OEPINT = 1UL<<19, // OUT endpoint interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_IEPINT = 1UL<<18, // IN endpoint interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_EOPF = 1UL<<15, // End of periodic frame interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_ISOODRP = 1UL<<14, // Isochronous OUT packet dropped interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_ENUMDNE = 1UL<<13, // Enumeration done
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_USBRST = 1UL<<12, // USB reset
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_USBSUSP = 1UL<<11, // USB suspend
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_ESUSP = 1UL<<10, // Early suspend
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_GOUTNAKEFF = 1UL<<7, // Global OUT NAK effective
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_GINAKEFF = 1UL<<6, // Global IN non-periodic NAK effective
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_NPTXFE = 1UL<<5, // Non-periodic TxFIFO empty
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_RXFLVL = 1UL<<4, // RxFIFO non-empty
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_SOF = 1UL<<3, // Start of frame
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_OTGINT = 1UL<<2, // OTG interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_MMIS = 1UL<<1, // Mode mismatch interrupt
	OTG_FS_GLOBAL_OTG_FS_GINTSTS_CMOD = 1UL<<0, // Current mode of operation		
};

// OTG_FS_GLOBAL->OTG_FS_GINTMSK OTG_FS interrupt mask register (OTG_FS_GINTMSK)
enum {
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_WUIM = 1UL<<31, // Resume/remote wakeup detected interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_SRQIM = 1UL<<30, // Session request/new session detected interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_DISCINT = 1UL<<29, // Disconnect detected interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_CIDSCHGM = 1UL<<28, // Connector ID status change mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_LPMIN = 1UL<<27, // LPM interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_PTXFEM = 1UL<<26, // Periodic TxFIFO empty mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_HCIM = 1UL<<25, // Host channels interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_PRTIM = 1UL<<24, // Host port interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_RSTDETM = 1UL<<23, // Reset detected interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_IPXFRM_IISOOXFRM = 1UL<<21, // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_IISOIXFRM = 1UL<<20, // Incomplete isochronous IN transfer mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_OEPINT = 1UL<<19, // OUT endpoints interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_IEPINT = 1UL<<18, // IN endpoints interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_EOPFM = 1UL<<15, // End of periodic frame interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_ISOODRPM = 1UL<<14, // Isochronous OUT packet dropped interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_ENUMDNEM = 1UL<<13, // Enumeration done mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_USBRST = 1UL<<12, // USB reset mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_USBSUSPM = 1UL<<11, // USB suspend mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_ESUSPM = 1UL<<10, // Early suspend mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_GONAKEFFM = 1UL<<7, // Global OUT NAK effective mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_GINAKEFFM = 1UL<<6, // Global non-periodic IN NAK effective mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_NPTXFEM = 1UL<<5, // Non-periodic TxFIFO empty mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_RXFLVLM = 1UL<<4, // Receive FIFO non-empty mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_SOFM = 1UL<<3, // Start of frame mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_OTGINT = 1UL<<2, // OTG interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GINTMSK_MMISM = 1UL<<1, // Mode mismatch interrupt mask		
};

// OTG_FS_GLOBAL->OTG_FS_GRXSTSR_Device OTG_FS Receive status debug read(Device mode)
enum {
	OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_FRMNUM = ((1UL<<4)-1) << 21, // Frame number
	OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_PKTSTS = ((1UL<<4)-1) << 17, // Packet status
	OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_DPID = ((1UL<<2)-1) << 15, // Data PID
	OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_BCNT = ((1UL<<11)-1) << 4, // Byte count
	OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_EPNUM = ((1UL<<4)-1) << 0, // Endpoint number		
};
inline uint32_t otg_fs_global_otg_fs_grxstsr_device_get_frmnum(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSR_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_FRMNUM) >> 21 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsr_device_get_pktsts(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSR_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_PKTSTS) >> 17 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsr_device_get_dpid(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSR_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_DPID) >> 15 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsr_device_get_bcnt(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSR_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_BCNT) >> 4 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsr_device_get_epnum(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSR_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSR_DEVICE_EPNUM) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_GRXSTSP_Device OTG status read and pop register (Device mode)
enum {
	OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_FRMNUM = ((1UL<<4)-1) << 21, // Frame number
	OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_PKTSTS = ((1UL<<4)-1) << 17, // Packet status
	OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_DPID = ((1UL<<2)-1) << 15, // Data PID
	OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_BCNT = ((1UL<<11)-1) << 4, // Byte count
	OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_EPNUM = ((1UL<<4)-1) << 0, // Endpoint number		
};
inline uint32_t otg_fs_global_otg_fs_grxstsp_device_get_frmnum(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSP_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_FRMNUM) >> 21 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsp_device_get_pktsts(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSP_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_PKTSTS) >> 17 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsp_device_get_dpid(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSP_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_DPID) >> 15 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsp_device_get_bcnt(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSP_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_BCNT) >> 4 ; }
inline uint32_t otg_fs_global_otg_fs_grxstsp_device_get_epnum(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GRXSTSP_Device & OTG_FS_GLOBAL_OTG_FS_GRXSTSP_DEVICE_EPNUM) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_DIEPTXF0_Device OTG_FS Endpoint 0 Transmit FIFO size
enum {
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FD = ((1UL<<16)-1) << 16, // Endpoint 0 TxFIFO depth
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FSA = ((1UL<<16)-1) << 0, // Endpoint 0 transmit RAM start address		
};
inline void otg_fs_global_otg_fs_dieptxf0_device_set_tx0fd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF0_Device = (p->OTG_FS_DIEPTXF0_Device & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FD) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FD); }
inline void otg_fs_global_otg_fs_dieptxf0_device_set_tx0fsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF0_Device = (p->OTG_FS_DIEPTXF0_Device & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FSA); }
inline uint32_t otg_fs_global_otg_fs_dieptxf0_device_get_tx0fd(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF0_Device & OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FD) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_dieptxf0_device_get_tx0fsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF0_Device & OTG_FS_GLOBAL_OTG_FS_DIEPTXF0_DEVICE_TX0FSA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_HNPTXSTS OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
enum {
	OTG_FS_GLOBAL_OTG_FS_HNPTXSTS_NPTXQTOP = ((1UL<<7)-1) << 24, // Top of the non-periodic transmit request queue
	OTG_FS_GLOBAL_OTG_FS_HNPTXSTS_NPTQXSAV = ((1UL<<8)-1) << 16, // Non-periodic transmit request queue space available
	OTG_FS_GLOBAL_OTG_FS_HNPTXSTS_NPTXFSAV = ((1UL<<16)-1) << 0, // Non-periodic TxFIFO space available		
};
inline uint32_t otg_fs_global_otg_fs_hnptxsts_get_nptxqtop(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_HNPTXSTS & OTG_FS_GLOBAL_OTG_FS_HNPTXSTS_NPTXQTOP) >> 24 ; }
inline uint32_t otg_fs_global_otg_fs_hnptxsts_get_nptqxsav(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_HNPTXSTS & OTG_FS_GLOBAL_OTG_FS_HNPTXSTS_NPTQXSAV) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_hnptxsts_get_nptxfsav(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_HNPTXSTS & OTG_FS_GLOBAL_OTG_FS_HNPTXSTS_NPTXFSAV) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_GI2CCTL OTG I2C access register
enum {
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_BSYDNE = 1UL<<31, // I2C Busy/Done
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_RW = 1UL<<30, // Read/Write Indicator
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_I2CDATSE0 = 1UL<<28, // I2C DatSe0 USB mode
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_I2CDEVADR = ((1UL<<2)-1) << 26, // I2C Device Address
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_ACK = 1UL<<24, // I2C ACK
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_I2CEN = 1UL<<23, // I2C Enable
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_ADDR = ((1UL<<7)-1) << 16, // I2C Address
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_REGADDR = ((1UL<<8)-1) << 8, // I2C Register Address
	OTG_FS_GLOBAL_OTG_FS_GI2CCTL_RWDATA = ((1UL<<8)-1) << 0, // I2C Read/Write Data		
};
inline void otg_fs_global_otg_fs_gi2cctl_set_i2cdevadr(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GI2CCTL = (p->OTG_FS_GI2CCTL & ~OTG_FS_GLOBAL_OTG_FS_GI2CCTL_I2CDEVADR) | ((val<<26) & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_I2CDEVADR); }
inline void otg_fs_global_otg_fs_gi2cctl_set_addr(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GI2CCTL = (p->OTG_FS_GI2CCTL & ~OTG_FS_GLOBAL_OTG_FS_GI2CCTL_ADDR) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_ADDR); }
inline void otg_fs_global_otg_fs_gi2cctl_set_regaddr(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GI2CCTL = (p->OTG_FS_GI2CCTL & ~OTG_FS_GLOBAL_OTG_FS_GI2CCTL_REGADDR) | ((val<<8) & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_REGADDR); }
inline void otg_fs_global_otg_fs_gi2cctl_set_rwdata(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GI2CCTL = (p->OTG_FS_GI2CCTL & ~OTG_FS_GLOBAL_OTG_FS_GI2CCTL_RWDATA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_RWDATA); }
inline uint32_t otg_fs_global_otg_fs_gi2cctl_get_i2cdevadr(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GI2CCTL & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_I2CDEVADR) >> 26 ; }
inline uint32_t otg_fs_global_otg_fs_gi2cctl_get_addr(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GI2CCTL & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_ADDR) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_gi2cctl_get_regaddr(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GI2CCTL & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_REGADDR) >> 8 ; }
inline uint32_t otg_fs_global_otg_fs_gi2cctl_get_rwdata(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GI2CCTL & OTG_FS_GLOBAL_OTG_FS_GI2CCTL_RWDATA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_GCCFG OTG_FS general core configuration register (OTG_FS_GCCFG)
enum {
	OTG_FS_GLOBAL_OTG_FS_GCCFG_VBDEN = 1UL<<21, // USB VBUS detection enable
	OTG_FS_GLOBAL_OTG_FS_GCCFG_SDEN = 1UL<<20, // Secondary detection (SD) mode enable
	OTG_FS_GLOBAL_OTG_FS_GCCFG_PDEN = 1UL<<19, // Primary detection (PD) mode enable
	OTG_FS_GLOBAL_OTG_FS_GCCFG_DCDEN = 1UL<<18, // Data contact detection (DCD) mode enable
	OTG_FS_GLOBAL_OTG_FS_GCCFG_BCDEN = 1UL<<17, // Battery charging detector (BCD) enable
	OTG_FS_GLOBAL_OTG_FS_GCCFG_PWRDWN = 1UL<<16, // Power down
	OTG_FS_GLOBAL_OTG_FS_GCCFG_PS2DET = 1UL<<3, // DM pull-up detection status
	OTG_FS_GLOBAL_OTG_FS_GCCFG_SDET = 1UL<<2, // Secondary detection (SD) status
	OTG_FS_GLOBAL_OTG_FS_GCCFG_PDET = 1UL<<1, // Primary detection (PD) status
	OTG_FS_GLOBAL_OTG_FS_GCCFG_DCDET = 1UL<<0, // Data contact detection (DCD) status		
};

// OTG_FS_GLOBAL->OTG_FS_GLPMCFG OTG core LPM configuration register
enum {
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_ENBESL = 1UL<<28, // Enable best effort service latency
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNTSTS = ((1UL<<3)-1) << 25, // LPM retry count status
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_SNDLPM = 1UL<<24, // Send LPM transaction
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNT = ((1UL<<3)-1) << 21, // LPM retry count
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMCHIDX = ((1UL<<4)-1) << 17, // LPM Channel Index
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_L1RSMOK = 1UL<<16, // Sleep State Resume OK
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_SLPSTS = 1UL<<15, // Port sleep status
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRST = ((1UL<<2)-1) << 13, // LPM response
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_L1DSEN = 1UL<<12, // L1 deep sleep enable
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESLTHRS = ((1UL<<4)-1) << 8, // BESL threshold
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_L1SSEN = 1UL<<7, // L1 Shallow Sleep enable
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_REMWAKE = 1UL<<6, // bRemoteWake value
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESL = ((1UL<<4)-1) << 2, // Best effort service latency
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMACK = 1UL<<1, // LPM token acknowledge enable
	OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMEN = 1UL<<0, // LPM support enable		
};
inline void otg_fs_global_otg_fs_glpmcfg_set_lpmrcntsts(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GLPMCFG = (p->OTG_FS_GLPMCFG & ~OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNTSTS) | ((val<<25) & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNTSTS); }
inline void otg_fs_global_otg_fs_glpmcfg_set_lpmrcnt(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GLPMCFG = (p->OTG_FS_GLPMCFG & ~OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNT) | ((val<<21) & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNT); }
inline void otg_fs_global_otg_fs_glpmcfg_set_lpmchidx(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GLPMCFG = (p->OTG_FS_GLPMCFG & ~OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMCHIDX) | ((val<<17) & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMCHIDX); }
inline void otg_fs_global_otg_fs_glpmcfg_set_lpmrst(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GLPMCFG = (p->OTG_FS_GLPMCFG & ~OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRST) | ((val<<13) & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRST); }
inline void otg_fs_global_otg_fs_glpmcfg_set_beslthrs(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GLPMCFG = (p->OTG_FS_GLPMCFG & ~OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESLTHRS) | ((val<<8) & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESLTHRS); }
inline void otg_fs_global_otg_fs_glpmcfg_set_besl(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GLPMCFG = (p->OTG_FS_GLPMCFG & ~OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESL) | ((val<<2) & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESL); }
inline uint32_t otg_fs_global_otg_fs_glpmcfg_get_lpmrcntsts(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GLPMCFG & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNTSTS) >> 25 ; }
inline uint32_t otg_fs_global_otg_fs_glpmcfg_get_lpmrcnt(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GLPMCFG & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRCNT) >> 21 ; }
inline uint32_t otg_fs_global_otg_fs_glpmcfg_get_lpmchidx(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GLPMCFG & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMCHIDX) >> 17 ; }
inline uint32_t otg_fs_global_otg_fs_glpmcfg_get_lpmrst(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GLPMCFG & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_LPMRST) >> 13 ; }
inline uint32_t otg_fs_global_otg_fs_glpmcfg_get_beslthrs(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GLPMCFG & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESLTHRS) >> 8 ; }
inline uint32_t otg_fs_global_otg_fs_glpmcfg_get_besl(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GLPMCFG & OTG_FS_GLOBAL_OTG_FS_GLPMCFG_BESL) >> 2 ; }

// OTG_FS_GLOBAL->OTG_FS_GPWRDN OTG power down register
enum {
	OTG_FS_GLOBAL_OTG_FS_GPWRDN_ADPIF = 1UL<<23, // ADP interrupt flag
	OTG_FS_GLOBAL_OTG_FS_GPWRDN_ADPMEN = 1UL<<0, // ADP module enable		
};

// OTG_FS_GLOBAL->OTG_FS_GADPCTL OTG ADP timer, control and status register
enum {
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_AR = ((1UL<<2)-1) << 27, // Access request
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPTOIM = 1UL<<26, // ADP timeout interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPSNSIM = 1UL<<25, // ADP sense interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPPRBIM = 1UL<<24, // ADP probe interrupt mask
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPTOIF = 1UL<<23, // ADP timeout interrupt flag
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPSNSIF = 1UL<<22, // ADP sense interrupt flag
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPPRBIF = 1UL<<21, // ADP probe interrupt flag
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPEN = 1UL<<20, // ADP enable
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ADPRST = 1UL<<19, // ADP reset
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ENASNS = 1UL<<18, // Enable sense
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_ENAPRB = 1UL<<17, // Enable probe
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_RTIM = ((1UL<<11)-1) << 6, // Ramp time
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBPER = ((1UL<<2)-1) << 4, // Probe period
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDELTA = ((1UL<<2)-1) << 2, // Probe delta
	OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDSCHG = ((1UL<<2)-1) << 0, // Probe discharge		
};
inline void otg_fs_global_otg_fs_gadpctl_set_ar(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GADPCTL = (p->OTG_FS_GADPCTL & ~OTG_FS_GLOBAL_OTG_FS_GADPCTL_AR) | ((val<<27) & OTG_FS_GLOBAL_OTG_FS_GADPCTL_AR); }
inline void otg_fs_global_otg_fs_gadpctl_set_rtim(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GADPCTL = (p->OTG_FS_GADPCTL & ~OTG_FS_GLOBAL_OTG_FS_GADPCTL_RTIM) | ((val<<6) & OTG_FS_GLOBAL_OTG_FS_GADPCTL_RTIM); }
inline void otg_fs_global_otg_fs_gadpctl_set_prbper(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GADPCTL = (p->OTG_FS_GADPCTL & ~OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBPER) | ((val<<4) & OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBPER); }
inline void otg_fs_global_otg_fs_gadpctl_set_prbdelta(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GADPCTL = (p->OTG_FS_GADPCTL & ~OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDELTA) | ((val<<2) & OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDELTA); }
inline void otg_fs_global_otg_fs_gadpctl_set_prbdschg(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_GADPCTL = (p->OTG_FS_GADPCTL & ~OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDSCHG) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDSCHG); }
inline uint32_t otg_fs_global_otg_fs_gadpctl_get_ar(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GADPCTL & OTG_FS_GLOBAL_OTG_FS_GADPCTL_AR) >> 27 ; }
inline uint32_t otg_fs_global_otg_fs_gadpctl_get_rtim(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GADPCTL & OTG_FS_GLOBAL_OTG_FS_GADPCTL_RTIM) >> 6 ; }
inline uint32_t otg_fs_global_otg_fs_gadpctl_get_prbper(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GADPCTL & OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBPER) >> 4 ; }
inline uint32_t otg_fs_global_otg_fs_gadpctl_get_prbdelta(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GADPCTL & OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDELTA) >> 2 ; }
inline uint32_t otg_fs_global_otg_fs_gadpctl_get_prbdschg(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_GADPCTL & OTG_FS_GLOBAL_OTG_FS_GADPCTL_PRBDSCHG) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_HPTXFSIZ OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
enum {
	OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXFSIZ = ((1UL<<16)-1) << 16, // Host periodic TxFIFO depth
	OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXSA = ((1UL<<16)-1) << 0, // Host periodic TxFIFO start address		
};
inline void otg_fs_global_otg_fs_hptxfsiz_set_ptxfsiz(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_HPTXFSIZ = (p->OTG_FS_HPTXFSIZ & ~OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXFSIZ) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXFSIZ); }
inline void otg_fs_global_otg_fs_hptxfsiz_set_ptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_HPTXFSIZ = (p->OTG_FS_HPTXFSIZ & ~OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXSA); }
inline uint32_t otg_fs_global_otg_fs_hptxfsiz_get_ptxfsiz(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_HPTXFSIZ & OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXFSIZ) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_hptxfsiz_get_ptxsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_HPTXFSIZ & OTG_FS_GLOBAL_OTG_FS_HPTXFSIZ_PTXSA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_DIEPTXF1 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
enum {
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFO2 transmit RAM start address		
};
inline void otg_fs_global_otg_fs_dieptxf1_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF1 = (p->OTG_FS_DIEPTXF1 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXFD) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXFD); }
inline void otg_fs_global_otg_fs_dieptxf1_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF1 = (p->OTG_FS_DIEPTXF1 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXSA); }
inline uint32_t otg_fs_global_otg_fs_dieptxf1_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF1 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXFD) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_dieptxf1_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF1 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF1_INEPTXSA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_DIEPTXF2 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
enum {
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFO3 transmit RAM start address		
};
inline void otg_fs_global_otg_fs_dieptxf2_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF2 = (p->OTG_FS_DIEPTXF2 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXFD) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXFD); }
inline void otg_fs_global_otg_fs_dieptxf2_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF2 = (p->OTG_FS_DIEPTXF2 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXSA); }
inline uint32_t otg_fs_global_otg_fs_dieptxf2_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF2 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXFD) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_dieptxf2_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF2 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF2_INEPTXSA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_DIEPTXF3 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
enum {
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFO4 transmit RAM start address		
};
inline void otg_fs_global_otg_fs_dieptxf3_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF3 = (p->OTG_FS_DIEPTXF3 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXFD) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXFD); }
inline void otg_fs_global_otg_fs_dieptxf3_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF3 = (p->OTG_FS_DIEPTXF3 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXSA); }
inline uint32_t otg_fs_global_otg_fs_dieptxf3_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF3 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXFD) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_dieptxf3_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF3 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF3_INEPTXSA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_DIEPTXF4 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
enum {
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint Tx FIFO depth
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_fs_global_otg_fs_dieptxf4_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF4 = (p->OTG_FS_DIEPTXF4 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXFD) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXFD); }
inline void otg_fs_global_otg_fs_dieptxf4_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF4 = (p->OTG_FS_DIEPTXF4 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXSA); }
inline uint32_t otg_fs_global_otg_fs_dieptxf4_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF4 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXFD) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_dieptxf4_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF4 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF4_INEPTXSA) >> 0 ; }

// OTG_FS_GLOBAL->OTG_FS_DIEPTXF5 OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)
enum {
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint Tx FIFO depth
	OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_fs_global_otg_fs_dieptxf5_set_ineptxfd(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF5 = (p->OTG_FS_DIEPTXF5 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXFD) | ((val<<16) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXFD); }
inline void otg_fs_global_otg_fs_dieptxf5_set_ineptxsa(struct OTG_FS_GLOBAL_Type* p, uint32_t val) { p->OTG_FS_DIEPTXF5 = (p->OTG_FS_DIEPTXF5 & ~OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXSA) | ((val<<0) & OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXSA); }
inline uint32_t otg_fs_global_otg_fs_dieptxf5_get_ineptxfd(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF5 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXFD) >> 16 ; }
inline uint32_t otg_fs_global_otg_fs_dieptxf5_get_ineptxsa(struct OTG_FS_GLOBAL_Type* p) { return (p->OTG_FS_DIEPTXF5 & OTG_FS_GLOBAL_OTG_FS_DIEPTXF5_INEPTXSA) >> 0 ; }

/* USB on the go full speed */
struct OTG_FS_HOST_Type {
	__IO uint8_t OTG_FS_HCFG; // @0 OTG_FS host configuration register (OTG_FS_HCFG)
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t OTG_FS_HFIR; // @4 OTG_FS Host frame interval register
	 uint8_t RESERVED1[2]; // @6 
	__I uint32_t OTG_FS_HFNUM; // @8 OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
	 uint8_t RESERVED2[4]; // @12 
	__IO uint32_t OTG_FS_HPTXSTS; // @16 OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
	__I uint16_t OTG_FS_HAINT; // @20 OTG_FS Host all channels interrupt register
	 uint8_t RESERVED3[2]; // @22 
	__IO uint16_t OTG_FS_HAINTMSK; // @24 OTG_FS host all channels interrupt mask register
	 uint8_t RESERVED4[38]; // @26 
	__IO uint32_t OTG_FS_HPRT; // @64 OTG_FS host port control and status register (OTG_FS_HPRT)
	 uint8_t RESERVED5[188]; // @68 
	__IO uint32_t OTG_FS_HCCHAR0; // @256 OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
	 uint8_t RESERVED6[4]; // @260 
	__IO uint16_t OTG_FS_HCINT0; // @264 OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
	 uint8_t RESERVED7[2]; // @266 
	__IO uint16_t OTG_FS_HCINTMSK0; // @268 OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
	 uint8_t RESERVED8[2]; // @270 
	__IO uint32_t OTG_FS_HCTSIZ0; // @272 OTG_FS host channel-0 transfer size register
	 uint8_t RESERVED9[12]; // @276 
	__IO uint32_t OTG_FS_HCCHAR1; // @288 OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
	 uint8_t RESERVED10[4]; // @292 
	__IO uint16_t OTG_FS_HCINT1; // @296 OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
	 uint8_t RESERVED11[2]; // @298 
	__IO uint16_t OTG_FS_HCINTMSK1; // @300 OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
	 uint8_t RESERVED12[2]; // @302 
	__IO uint32_t OTG_FS_HCTSIZ1; // @304 OTG_FS host channel-1 transfer size register
	 uint8_t RESERVED13[12]; // @308 
	__IO uint32_t OTG_FS_HCCHAR2; // @320 OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
	 uint8_t RESERVED14[4]; // @324 
	__IO uint16_t OTG_FS_HCINT2; // @328 OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
	 uint8_t RESERVED15[2]; // @330 
	__IO uint16_t OTG_FS_HCINTMSK2; // @332 OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
	 uint8_t RESERVED16[2]; // @334 
	__IO uint32_t OTG_FS_HCTSIZ2; // @336 OTG_FS host channel-2 transfer size register
	 uint8_t RESERVED17[12]; // @340 
	__IO uint32_t OTG_FS_HCCHAR3; // @352 OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
	 uint8_t RESERVED18[4]; // @356 
	__IO uint16_t OTG_FS_HCINT3; // @360 OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
	 uint8_t RESERVED19[2]; // @362 
	__IO uint16_t OTG_FS_HCINTMSK3; // @364 OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
	 uint8_t RESERVED20[2]; // @366 
	__IO uint32_t OTG_FS_HCTSIZ3; // @368 OTG_FS host channel-3 transfer size register
	 uint8_t RESERVED21[12]; // @372 
	__IO uint32_t OTG_FS_HCCHAR4; // @384 OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
	 uint8_t RESERVED22[4]; // @388 
	__IO uint16_t OTG_FS_HCINT4; // @392 OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
	 uint8_t RESERVED23[2]; // @394 
	__IO uint16_t OTG_FS_HCINTMSK4; // @396 OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
	 uint8_t RESERVED24[2]; // @398 
	__IO uint32_t OTG_FS_HCTSIZ4; // @400 OTG_FS host channel-x transfer size register
	 uint8_t RESERVED25[12]; // @404 
	__IO uint32_t OTG_FS_HCCHAR5; // @416 OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
	 uint8_t RESERVED26[4]; // @420 
	__IO uint16_t OTG_FS_HCINT5; // @424 OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
	 uint8_t RESERVED27[2]; // @426 
	__IO uint16_t OTG_FS_HCINTMSK5; // @428 OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
	 uint8_t RESERVED28[2]; // @430 
	__IO uint32_t OTG_FS_HCTSIZ5; // @432 OTG_FS host channel-5 transfer size register
	 uint8_t RESERVED29[12]; // @436 
	__IO uint32_t OTG_FS_HCCHAR6; // @448 OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
	 uint8_t RESERVED30[4]; // @452 
	__IO uint16_t OTG_FS_HCINT6; // @456 OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
	 uint8_t RESERVED31[2]; // @458 
	__IO uint16_t OTG_FS_HCINTMSK6; // @460 OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
	 uint8_t RESERVED32[2]; // @462 
	__IO uint32_t OTG_FS_HCTSIZ6; // @464 OTG_FS host channel-6 transfer size register
	 uint8_t RESERVED33[12]; // @468 
	__IO uint32_t OTG_FS_HCCHAR7; // @480 OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
	 uint8_t RESERVED34[4]; // @484 
	__IO uint16_t OTG_FS_HCINT7; // @488 OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
	 uint8_t RESERVED35[2]; // @490 
	__IO uint16_t OTG_FS_HCINTMSK7; // @492 OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
	 uint8_t RESERVED36[2]; // @494 
	__IO uint32_t OTG_FS_HCTSIZ7; // @496 OTG_FS host channel-7 transfer size register
	__IO uint32_t OTG_FS_HCCHAR8; // @500 OTG_FS host channel-8 characteristics register
	__IO uint16_t OTG_FS_HCINT8; // @504 OTG_FS host channel-8 interrupt register
	 uint8_t RESERVED37[2]; // @506 
	__IO uint16_t OTG_FS_HCINTMSK8; // @508 OTG_FS host channel-8 mask register
	 uint8_t RESERVED38[2]; // @510 
	__IO uint32_t OTG_FS_HCTSIZ8; // @512 OTG_FS host channel-8 transfer size register
	__IO uint32_t OTG_FS_HCCHAR9; // @516 OTG_FS host channel-9 characteristics register
	__IO uint16_t OTG_FS_HCINT9; // @520 OTG_FS host channel-9 interrupt register
	 uint8_t RESERVED39[2]; // @522 
	__IO uint16_t OTG_FS_HCINTMSK9; // @524 OTG_FS host channel-9 mask register
	 uint8_t RESERVED40[2]; // @526 
	__IO uint32_t OTG_FS_HCTSIZ9; // @528 OTG_FS host channel-9 transfer size register
	__IO uint32_t OTG_FS_HCCHAR10; // @532 OTG_FS host channel-10 characteristics register
	__IO uint16_t OTG_FS_HCINT10; // @536 OTG_FS host channel-10 interrupt register
	 uint8_t RESERVED41[2]; // @538 
	__IO uint16_t OTG_FS_HCINTMSK10; // @540 OTG_FS host channel-10 mask register
	 uint8_t RESERVED42[2]; // @542 
	__IO uint32_t OTG_FS_HCTSIZ10; // @544 OTG_FS host channel-10 transfer size register
	__IO uint32_t OTG_FS_HCCHAR11; // @548 OTG_FS host channel-11 characteristics register
	__IO uint16_t OTG_FS_HCINT11; // @552 OTG_FS host channel-11 interrupt register
	 uint8_t RESERVED43[2]; // @554 
	__IO uint16_t OTG_FS_HCINTMSK11; // @556 OTG_FS host channel-11 mask register
	 uint8_t RESERVED44[2]; // @558 
	__IO uint32_t OTG_FS_HCTSIZ11; // @560 OTG_FS host channel-11 transfer size register
};

// OTG_FS_HOST->OTG_FS_HCFG OTG_FS host configuration register (OTG_FS_HCFG)
enum {
	OTG_FS_HOST_OTG_FS_HCFG_FSLSS = 1UL<<2, // FS- and LS-only support
	OTG_FS_HOST_OTG_FS_HCFG_FSLSPCS = ((1UL<<2)-1) << 0, // FS/LS PHY clock select		
};
inline void otg_fs_host_otg_fs_hcfg_set_fslspcs(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCFG = (p->OTG_FS_HCFG & ~OTG_FS_HOST_OTG_FS_HCFG_FSLSPCS) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCFG_FSLSPCS); }
inline uint32_t otg_fs_host_otg_fs_hcfg_get_fslspcs(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCFG & OTG_FS_HOST_OTG_FS_HCFG_FSLSPCS) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HFNUM OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
enum {
	OTG_FS_HOST_OTG_FS_HFNUM_FTREM = ((1UL<<16)-1) << 16, // Frame time remaining
	OTG_FS_HOST_OTG_FS_HFNUM_FRNUM = ((1UL<<16)-1) << 0, // Frame number		
};
inline uint32_t otg_fs_host_otg_fs_hfnum_get_ftrem(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HFNUM & OTG_FS_HOST_OTG_FS_HFNUM_FTREM) >> 16 ; }
inline uint32_t otg_fs_host_otg_fs_hfnum_get_frnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HFNUM & OTG_FS_HOST_OTG_FS_HFNUM_FRNUM) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HPTXSTS OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
enum {
	OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQTOP = ((1UL<<8)-1) << 24, // Top of the periodic transmit request queue
	OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQSAV = ((1UL<<8)-1) << 16, // Periodic transmit request queue space available
	OTG_FS_HOST_OTG_FS_HPTXSTS_PTXFSAVL = ((1UL<<16)-1) << 0, // Periodic transmit data FIFO space available		
};
inline void otg_fs_host_otg_fs_hptxsts_set_ptxqtop(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HPTXSTS = (p->OTG_FS_HPTXSTS & ~OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQTOP) | ((val<<24) & OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQTOP); }
inline void otg_fs_host_otg_fs_hptxsts_set_ptxqsav(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HPTXSTS = (p->OTG_FS_HPTXSTS & ~OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQSAV) | ((val<<16) & OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQSAV); }
inline void otg_fs_host_otg_fs_hptxsts_set_ptxfsavl(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HPTXSTS = (p->OTG_FS_HPTXSTS & ~OTG_FS_HOST_OTG_FS_HPTXSTS_PTXFSAVL) | ((val<<0) & OTG_FS_HOST_OTG_FS_HPTXSTS_PTXFSAVL); }
inline uint32_t otg_fs_host_otg_fs_hptxsts_get_ptxqtop(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HPTXSTS & OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQTOP) >> 24 ; }
inline uint32_t otg_fs_host_otg_fs_hptxsts_get_ptxqsav(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HPTXSTS & OTG_FS_HOST_OTG_FS_HPTXSTS_PTXQSAV) >> 16 ; }
inline uint32_t otg_fs_host_otg_fs_hptxsts_get_ptxfsavl(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HPTXSTS & OTG_FS_HOST_OTG_FS_HPTXSTS_PTXFSAVL) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HPRT OTG_FS host port control and status register (OTG_FS_HPRT)
enum {
	OTG_FS_HOST_OTG_FS_HPRT_PSPD = ((1UL<<2)-1) << 17, // Port speed
	OTG_FS_HOST_OTG_FS_HPRT_PTCTL = ((1UL<<4)-1) << 13, // Port test control
	OTG_FS_HOST_OTG_FS_HPRT_PPWR = 1UL<<12, // Port power
	OTG_FS_HOST_OTG_FS_HPRT_PLSTS = ((1UL<<2)-1) << 10, // Port line status
	OTG_FS_HOST_OTG_FS_HPRT_PRST = 1UL<<8, // Port reset
	OTG_FS_HOST_OTG_FS_HPRT_PSUSP = 1UL<<7, // Port suspend
	OTG_FS_HOST_OTG_FS_HPRT_PRES = 1UL<<6, // Port resume
	OTG_FS_HOST_OTG_FS_HPRT_POCCHNG = 1UL<<5, // Port overcurrent change
	OTG_FS_HOST_OTG_FS_HPRT_POCA = 1UL<<4, // Port overcurrent active
	OTG_FS_HOST_OTG_FS_HPRT_PENCHNG = 1UL<<3, // Port enable/disable change
	OTG_FS_HOST_OTG_FS_HPRT_PENA = 1UL<<2, // Port enable
	OTG_FS_HOST_OTG_FS_HPRT_PCDET = 1UL<<1, // Port connect detected
	OTG_FS_HOST_OTG_FS_HPRT_PCSTS = 1UL<<0, // Port connect status		
};
inline void otg_fs_host_otg_fs_hprt_set_pspd(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HPRT = (p->OTG_FS_HPRT & ~OTG_FS_HOST_OTG_FS_HPRT_PSPD) | ((val<<17) & OTG_FS_HOST_OTG_FS_HPRT_PSPD); }
inline void otg_fs_host_otg_fs_hprt_set_ptctl(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HPRT = (p->OTG_FS_HPRT & ~OTG_FS_HOST_OTG_FS_HPRT_PTCTL) | ((val<<13) & OTG_FS_HOST_OTG_FS_HPRT_PTCTL); }
inline void otg_fs_host_otg_fs_hprt_set_plsts(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HPRT = (p->OTG_FS_HPRT & ~OTG_FS_HOST_OTG_FS_HPRT_PLSTS) | ((val<<10) & OTG_FS_HOST_OTG_FS_HPRT_PLSTS); }
inline uint32_t otg_fs_host_otg_fs_hprt_get_pspd(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HPRT & OTG_FS_HOST_OTG_FS_HPRT_PSPD) >> 17 ; }
inline uint32_t otg_fs_host_otg_fs_hprt_get_ptctl(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HPRT & OTG_FS_HOST_OTG_FS_HPRT_PTCTL) >> 13 ; }
inline uint32_t otg_fs_host_otg_fs_hprt_get_plsts(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HPRT & OTG_FS_HOST_OTG_FS_HPRT_PLSTS) >> 10 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR0 OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR0_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR0_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR0_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR0_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR0_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR0_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR0_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR0_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR0_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar0_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR0 = (p->OTG_FS_HCCHAR0 & ~OTG_FS_HOST_OTG_FS_HCCHAR0_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR0_DAD); }
inline void otg_fs_host_otg_fs_hcchar0_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR0 = (p->OTG_FS_HCCHAR0 & ~OTG_FS_HOST_OTG_FS_HCCHAR0_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR0_MCNT); }
inline void otg_fs_host_otg_fs_hcchar0_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR0 = (p->OTG_FS_HCCHAR0 & ~OTG_FS_HOST_OTG_FS_HCCHAR0_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR0_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar0_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR0 = (p->OTG_FS_HCCHAR0 & ~OTG_FS_HOST_OTG_FS_HCCHAR0_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR0_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar0_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR0 = (p->OTG_FS_HCCHAR0 & ~OTG_FS_HOST_OTG_FS_HCCHAR0_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR0_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar0_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR0 & OTG_FS_HOST_OTG_FS_HCCHAR0_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar0_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR0 & OTG_FS_HOST_OTG_FS_HCCHAR0_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar0_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR0 & OTG_FS_HOST_OTG_FS_HCCHAR0_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar0_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR0 & OTG_FS_HOST_OTG_FS_HCCHAR0_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar0_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR0 & OTG_FS_HOST_OTG_FS_HCCHAR0_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT0 OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
enum {
	OTG_FS_HOST_OTG_FS_HCINT0_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT0_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT0_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT0_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT0_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT0_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT0_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT0_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT0_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK0 OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK0_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK0_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ0 OTG_FS host channel-0 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ0_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ0_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ0_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz0_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ0 = (p->OTG_FS_HCTSIZ0 & ~OTG_FS_HOST_OTG_FS_HCTSIZ0_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ0_DPID); }
inline void otg_fs_host_otg_fs_hctsiz0_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ0 = (p->OTG_FS_HCTSIZ0 & ~OTG_FS_HOST_OTG_FS_HCTSIZ0_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ0_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz0_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ0 = (p->OTG_FS_HCTSIZ0 & ~OTG_FS_HOST_OTG_FS_HCTSIZ0_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ0_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz0_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ0 & OTG_FS_HOST_OTG_FS_HCTSIZ0_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz0_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ0 & OTG_FS_HOST_OTG_FS_HCTSIZ0_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz0_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ0 & OTG_FS_HOST_OTG_FS_HCTSIZ0_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR1 OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR1_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR1_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR1_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR1_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR1_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR1_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR1_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR1_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar1_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR1 = (p->OTG_FS_HCCHAR1 & ~OTG_FS_HOST_OTG_FS_HCCHAR1_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR1_DAD); }
inline void otg_fs_host_otg_fs_hcchar1_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR1 = (p->OTG_FS_HCCHAR1 & ~OTG_FS_HOST_OTG_FS_HCCHAR1_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR1_MCNT); }
inline void otg_fs_host_otg_fs_hcchar1_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR1 = (p->OTG_FS_HCCHAR1 & ~OTG_FS_HOST_OTG_FS_HCCHAR1_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR1_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar1_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR1 = (p->OTG_FS_HCCHAR1 & ~OTG_FS_HOST_OTG_FS_HCCHAR1_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR1_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar1_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR1 = (p->OTG_FS_HCCHAR1 & ~OTG_FS_HOST_OTG_FS_HCCHAR1_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR1_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar1_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR1 & OTG_FS_HOST_OTG_FS_HCCHAR1_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar1_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR1 & OTG_FS_HOST_OTG_FS_HCCHAR1_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar1_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR1 & OTG_FS_HOST_OTG_FS_HCCHAR1_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar1_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR1 & OTG_FS_HOST_OTG_FS_HCCHAR1_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar1_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR1 & OTG_FS_HOST_OTG_FS_HCCHAR1_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT1 OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
enum {
	OTG_FS_HOST_OTG_FS_HCINT1_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT1_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT1_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT1_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT1_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT1_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT1_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT1_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT1_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK1 OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK1_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK1_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ1 OTG_FS host channel-1 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ1_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz1_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ1 = (p->OTG_FS_HCTSIZ1 & ~OTG_FS_HOST_OTG_FS_HCTSIZ1_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ1_DPID); }
inline void otg_fs_host_otg_fs_hctsiz1_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ1 = (p->OTG_FS_HCTSIZ1 & ~OTG_FS_HOST_OTG_FS_HCTSIZ1_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ1_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz1_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ1 = (p->OTG_FS_HCTSIZ1 & ~OTG_FS_HOST_OTG_FS_HCTSIZ1_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ1_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz1_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ1 & OTG_FS_HOST_OTG_FS_HCTSIZ1_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz1_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ1 & OTG_FS_HOST_OTG_FS_HCTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz1_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ1 & OTG_FS_HOST_OTG_FS_HCTSIZ1_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR2 OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR2_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR2_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR2_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR2_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR2_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR2_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR2_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR2_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar2_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR2 = (p->OTG_FS_HCCHAR2 & ~OTG_FS_HOST_OTG_FS_HCCHAR2_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR2_DAD); }
inline void otg_fs_host_otg_fs_hcchar2_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR2 = (p->OTG_FS_HCCHAR2 & ~OTG_FS_HOST_OTG_FS_HCCHAR2_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR2_MCNT); }
inline void otg_fs_host_otg_fs_hcchar2_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR2 = (p->OTG_FS_HCCHAR2 & ~OTG_FS_HOST_OTG_FS_HCCHAR2_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR2_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar2_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR2 = (p->OTG_FS_HCCHAR2 & ~OTG_FS_HOST_OTG_FS_HCCHAR2_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR2_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar2_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR2 = (p->OTG_FS_HCCHAR2 & ~OTG_FS_HOST_OTG_FS_HCCHAR2_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR2_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar2_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR2 & OTG_FS_HOST_OTG_FS_HCCHAR2_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar2_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR2 & OTG_FS_HOST_OTG_FS_HCCHAR2_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar2_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR2 & OTG_FS_HOST_OTG_FS_HCCHAR2_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar2_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR2 & OTG_FS_HOST_OTG_FS_HCCHAR2_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar2_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR2 & OTG_FS_HOST_OTG_FS_HCCHAR2_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT2 OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
enum {
	OTG_FS_HOST_OTG_FS_HCINT2_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT2_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT2_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT2_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT2_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT2_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT2_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT2_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT2_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK2 OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK2_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK2_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ2 OTG_FS host channel-2 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ2_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz2_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ2 = (p->OTG_FS_HCTSIZ2 & ~OTG_FS_HOST_OTG_FS_HCTSIZ2_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ2_DPID); }
inline void otg_fs_host_otg_fs_hctsiz2_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ2 = (p->OTG_FS_HCTSIZ2 & ~OTG_FS_HOST_OTG_FS_HCTSIZ2_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ2_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz2_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ2 = (p->OTG_FS_HCTSIZ2 & ~OTG_FS_HOST_OTG_FS_HCTSIZ2_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ2_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz2_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ2 & OTG_FS_HOST_OTG_FS_HCTSIZ2_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz2_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ2 & OTG_FS_HOST_OTG_FS_HCTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz2_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ2 & OTG_FS_HOST_OTG_FS_HCTSIZ2_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR3 OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR3_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR3_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR3_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR3_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR3_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR3_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR3_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR3_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar3_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR3 = (p->OTG_FS_HCCHAR3 & ~OTG_FS_HOST_OTG_FS_HCCHAR3_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR3_DAD); }
inline void otg_fs_host_otg_fs_hcchar3_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR3 = (p->OTG_FS_HCCHAR3 & ~OTG_FS_HOST_OTG_FS_HCCHAR3_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR3_MCNT); }
inline void otg_fs_host_otg_fs_hcchar3_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR3 = (p->OTG_FS_HCCHAR3 & ~OTG_FS_HOST_OTG_FS_HCCHAR3_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR3_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar3_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR3 = (p->OTG_FS_HCCHAR3 & ~OTG_FS_HOST_OTG_FS_HCCHAR3_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR3_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar3_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR3 = (p->OTG_FS_HCCHAR3 & ~OTG_FS_HOST_OTG_FS_HCCHAR3_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR3_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar3_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR3 & OTG_FS_HOST_OTG_FS_HCCHAR3_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar3_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR3 & OTG_FS_HOST_OTG_FS_HCCHAR3_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar3_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR3 & OTG_FS_HOST_OTG_FS_HCCHAR3_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar3_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR3 & OTG_FS_HOST_OTG_FS_HCCHAR3_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar3_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR3 & OTG_FS_HOST_OTG_FS_HCCHAR3_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT3 OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
enum {
	OTG_FS_HOST_OTG_FS_HCINT3_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT3_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT3_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT3_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT3_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT3_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT3_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT3_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT3_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK3 OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK3_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK3_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ3 OTG_FS host channel-3 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ3_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz3_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ3 = (p->OTG_FS_HCTSIZ3 & ~OTG_FS_HOST_OTG_FS_HCTSIZ3_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ3_DPID); }
inline void otg_fs_host_otg_fs_hctsiz3_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ3 = (p->OTG_FS_HCTSIZ3 & ~OTG_FS_HOST_OTG_FS_HCTSIZ3_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ3_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz3_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ3 = (p->OTG_FS_HCTSIZ3 & ~OTG_FS_HOST_OTG_FS_HCTSIZ3_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ3_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz3_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ3 & OTG_FS_HOST_OTG_FS_HCTSIZ3_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz3_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ3 & OTG_FS_HOST_OTG_FS_HCTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz3_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ3 & OTG_FS_HOST_OTG_FS_HCTSIZ3_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR4 OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR4_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR4_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR4_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR4_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR4_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR4_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR4_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR4_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar4_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR4 = (p->OTG_FS_HCCHAR4 & ~OTG_FS_HOST_OTG_FS_HCCHAR4_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR4_DAD); }
inline void otg_fs_host_otg_fs_hcchar4_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR4 = (p->OTG_FS_HCCHAR4 & ~OTG_FS_HOST_OTG_FS_HCCHAR4_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR4_MCNT); }
inline void otg_fs_host_otg_fs_hcchar4_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR4 = (p->OTG_FS_HCCHAR4 & ~OTG_FS_HOST_OTG_FS_HCCHAR4_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR4_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar4_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR4 = (p->OTG_FS_HCCHAR4 & ~OTG_FS_HOST_OTG_FS_HCCHAR4_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR4_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar4_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR4 = (p->OTG_FS_HCCHAR4 & ~OTG_FS_HOST_OTG_FS_HCCHAR4_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR4_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar4_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR4 & OTG_FS_HOST_OTG_FS_HCCHAR4_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar4_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR4 & OTG_FS_HOST_OTG_FS_HCCHAR4_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar4_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR4 & OTG_FS_HOST_OTG_FS_HCCHAR4_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar4_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR4 & OTG_FS_HOST_OTG_FS_HCCHAR4_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar4_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR4 & OTG_FS_HOST_OTG_FS_HCCHAR4_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT4 OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
enum {
	OTG_FS_HOST_OTG_FS_HCINT4_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT4_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT4_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT4_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT4_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT4_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT4_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT4_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT4_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK4 OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK4_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK4_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ4 OTG_FS host channel-x transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ4_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz4_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ4 = (p->OTG_FS_HCTSIZ4 & ~OTG_FS_HOST_OTG_FS_HCTSIZ4_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ4_DPID); }
inline void otg_fs_host_otg_fs_hctsiz4_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ4 = (p->OTG_FS_HCTSIZ4 & ~OTG_FS_HOST_OTG_FS_HCTSIZ4_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ4_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz4_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ4 = (p->OTG_FS_HCTSIZ4 & ~OTG_FS_HOST_OTG_FS_HCTSIZ4_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ4_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz4_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ4 & OTG_FS_HOST_OTG_FS_HCTSIZ4_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz4_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ4 & OTG_FS_HOST_OTG_FS_HCTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz4_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ4 & OTG_FS_HOST_OTG_FS_HCTSIZ4_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR5 OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR5_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR5_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR5_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR5_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR5_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR5_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR5_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR5_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar5_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR5 = (p->OTG_FS_HCCHAR5 & ~OTG_FS_HOST_OTG_FS_HCCHAR5_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR5_DAD); }
inline void otg_fs_host_otg_fs_hcchar5_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR5 = (p->OTG_FS_HCCHAR5 & ~OTG_FS_HOST_OTG_FS_HCCHAR5_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR5_MCNT); }
inline void otg_fs_host_otg_fs_hcchar5_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR5 = (p->OTG_FS_HCCHAR5 & ~OTG_FS_HOST_OTG_FS_HCCHAR5_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR5_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar5_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR5 = (p->OTG_FS_HCCHAR5 & ~OTG_FS_HOST_OTG_FS_HCCHAR5_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR5_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar5_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR5 = (p->OTG_FS_HCCHAR5 & ~OTG_FS_HOST_OTG_FS_HCCHAR5_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR5_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar5_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR5 & OTG_FS_HOST_OTG_FS_HCCHAR5_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar5_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR5 & OTG_FS_HOST_OTG_FS_HCCHAR5_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar5_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR5 & OTG_FS_HOST_OTG_FS_HCCHAR5_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar5_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR5 & OTG_FS_HOST_OTG_FS_HCCHAR5_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar5_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR5 & OTG_FS_HOST_OTG_FS_HCCHAR5_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT5 OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
enum {
	OTG_FS_HOST_OTG_FS_HCINT5_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT5_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT5_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT5_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT5_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT5_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT5_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT5_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT5_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK5 OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK5_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK5_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ5 OTG_FS host channel-5 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ5_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz5_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ5 = (p->OTG_FS_HCTSIZ5 & ~OTG_FS_HOST_OTG_FS_HCTSIZ5_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ5_DPID); }
inline void otg_fs_host_otg_fs_hctsiz5_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ5 = (p->OTG_FS_HCTSIZ5 & ~OTG_FS_HOST_OTG_FS_HCTSIZ5_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ5_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz5_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ5 = (p->OTG_FS_HCTSIZ5 & ~OTG_FS_HOST_OTG_FS_HCTSIZ5_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ5_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz5_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ5 & OTG_FS_HOST_OTG_FS_HCTSIZ5_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz5_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ5 & OTG_FS_HOST_OTG_FS_HCTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz5_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ5 & OTG_FS_HOST_OTG_FS_HCTSIZ5_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR6 OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR6_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR6_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR6_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR6_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR6_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR6_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR6_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR6_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar6_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR6 = (p->OTG_FS_HCCHAR6 & ~OTG_FS_HOST_OTG_FS_HCCHAR6_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR6_DAD); }
inline void otg_fs_host_otg_fs_hcchar6_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR6 = (p->OTG_FS_HCCHAR6 & ~OTG_FS_HOST_OTG_FS_HCCHAR6_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR6_MCNT); }
inline void otg_fs_host_otg_fs_hcchar6_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR6 = (p->OTG_FS_HCCHAR6 & ~OTG_FS_HOST_OTG_FS_HCCHAR6_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR6_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar6_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR6 = (p->OTG_FS_HCCHAR6 & ~OTG_FS_HOST_OTG_FS_HCCHAR6_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR6_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar6_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR6 = (p->OTG_FS_HCCHAR6 & ~OTG_FS_HOST_OTG_FS_HCCHAR6_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR6_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar6_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR6 & OTG_FS_HOST_OTG_FS_HCCHAR6_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar6_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR6 & OTG_FS_HOST_OTG_FS_HCCHAR6_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar6_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR6 & OTG_FS_HOST_OTG_FS_HCCHAR6_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar6_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR6 & OTG_FS_HOST_OTG_FS_HCCHAR6_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar6_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR6 & OTG_FS_HOST_OTG_FS_HCCHAR6_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT6 OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
enum {
	OTG_FS_HOST_OTG_FS_HCINT6_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT6_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT6_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT6_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT6_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT6_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT6_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT6_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT6_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK6 OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK6_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK6_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ6 OTG_FS host channel-6 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ6_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ6_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ6_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz6_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ6 = (p->OTG_FS_HCTSIZ6 & ~OTG_FS_HOST_OTG_FS_HCTSIZ6_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ6_DPID); }
inline void otg_fs_host_otg_fs_hctsiz6_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ6 = (p->OTG_FS_HCTSIZ6 & ~OTG_FS_HOST_OTG_FS_HCTSIZ6_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ6_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz6_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ6 = (p->OTG_FS_HCTSIZ6 & ~OTG_FS_HOST_OTG_FS_HCTSIZ6_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ6_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz6_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ6 & OTG_FS_HOST_OTG_FS_HCTSIZ6_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz6_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ6 & OTG_FS_HOST_OTG_FS_HCTSIZ6_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz6_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ6 & OTG_FS_HOST_OTG_FS_HCTSIZ6_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR7 OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR7_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR7_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR7_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR7_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR7_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR7_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR7_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR7_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar7_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR7 = (p->OTG_FS_HCCHAR7 & ~OTG_FS_HOST_OTG_FS_HCCHAR7_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR7_DAD); }
inline void otg_fs_host_otg_fs_hcchar7_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR7 = (p->OTG_FS_HCCHAR7 & ~OTG_FS_HOST_OTG_FS_HCCHAR7_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR7_MCNT); }
inline void otg_fs_host_otg_fs_hcchar7_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR7 = (p->OTG_FS_HCCHAR7 & ~OTG_FS_HOST_OTG_FS_HCCHAR7_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR7_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar7_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR7 = (p->OTG_FS_HCCHAR7 & ~OTG_FS_HOST_OTG_FS_HCCHAR7_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR7_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar7_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR7 = (p->OTG_FS_HCCHAR7 & ~OTG_FS_HOST_OTG_FS_HCCHAR7_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR7_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar7_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR7 & OTG_FS_HOST_OTG_FS_HCCHAR7_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar7_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR7 & OTG_FS_HOST_OTG_FS_HCCHAR7_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar7_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR7 & OTG_FS_HOST_OTG_FS_HCCHAR7_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar7_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR7 & OTG_FS_HOST_OTG_FS_HCCHAR7_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar7_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR7 & OTG_FS_HOST_OTG_FS_HCCHAR7_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT7 OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
enum {
	OTG_FS_HOST_OTG_FS_HCINT7_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT7_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT7_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT7_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT7_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT7_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT7_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT7_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT7_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK7 OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK7_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK7_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ7 OTG_FS host channel-7 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ7_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz7_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ7 = (p->OTG_FS_HCTSIZ7 & ~OTG_FS_HOST_OTG_FS_HCTSIZ7_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ7_DPID); }
inline void otg_fs_host_otg_fs_hctsiz7_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ7 = (p->OTG_FS_HCTSIZ7 & ~OTG_FS_HOST_OTG_FS_HCTSIZ7_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ7_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz7_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ7 = (p->OTG_FS_HCTSIZ7 & ~OTG_FS_HOST_OTG_FS_HCTSIZ7_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ7_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz7_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ7 & OTG_FS_HOST_OTG_FS_HCTSIZ7_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz7_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ7 & OTG_FS_HOST_OTG_FS_HCTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz7_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ7 & OTG_FS_HOST_OTG_FS_HCTSIZ7_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR8 OTG_FS host channel-8 characteristics register
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR8_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR8_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR8_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR8_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR8_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR8_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR8_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR8_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR8_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR8_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar8_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR8 = (p->OTG_FS_HCCHAR8 & ~OTG_FS_HOST_OTG_FS_HCCHAR8_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR8_DAD); }
inline void otg_fs_host_otg_fs_hcchar8_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR8 = (p->OTG_FS_HCCHAR8 & ~OTG_FS_HOST_OTG_FS_HCCHAR8_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR8_MCNT); }
inline void otg_fs_host_otg_fs_hcchar8_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR8 = (p->OTG_FS_HCCHAR8 & ~OTG_FS_HOST_OTG_FS_HCCHAR8_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR8_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar8_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR8 = (p->OTG_FS_HCCHAR8 & ~OTG_FS_HOST_OTG_FS_HCCHAR8_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR8_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar8_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR8 = (p->OTG_FS_HCCHAR8 & ~OTG_FS_HOST_OTG_FS_HCCHAR8_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR8_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar8_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR8 & OTG_FS_HOST_OTG_FS_HCCHAR8_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar8_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR8 & OTG_FS_HOST_OTG_FS_HCCHAR8_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar8_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR8 & OTG_FS_HOST_OTG_FS_HCCHAR8_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar8_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR8 & OTG_FS_HOST_OTG_FS_HCCHAR8_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar8_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR8 & OTG_FS_HOST_OTG_FS_HCCHAR8_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT8 OTG_FS host channel-8 interrupt register
enum {
	OTG_FS_HOST_OTG_FS_HCINT8_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT8_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT8_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT8_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT8_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT8_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT8_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT8_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT8_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK8 OTG_FS host channel-8 mask register
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK8_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_TXERRM = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINTMSK8_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK8_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ8 OTG_FS host channel-8 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ8_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ8_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ8_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz8_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ8 = (p->OTG_FS_HCTSIZ8 & ~OTG_FS_HOST_OTG_FS_HCTSIZ8_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ8_DPID); }
inline void otg_fs_host_otg_fs_hctsiz8_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ8 = (p->OTG_FS_HCTSIZ8 & ~OTG_FS_HOST_OTG_FS_HCTSIZ8_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ8_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz8_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ8 = (p->OTG_FS_HCTSIZ8 & ~OTG_FS_HOST_OTG_FS_HCTSIZ8_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ8_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz8_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ8 & OTG_FS_HOST_OTG_FS_HCTSIZ8_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz8_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ8 & OTG_FS_HOST_OTG_FS_HCTSIZ8_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz8_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ8 & OTG_FS_HOST_OTG_FS_HCTSIZ8_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR9 OTG_FS host channel-9 characteristics register
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR9_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR9_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR9_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR9_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR9_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR9_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR9_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR9_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR9_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR9_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar9_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR9 = (p->OTG_FS_HCCHAR9 & ~OTG_FS_HOST_OTG_FS_HCCHAR9_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR9_DAD); }
inline void otg_fs_host_otg_fs_hcchar9_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR9 = (p->OTG_FS_HCCHAR9 & ~OTG_FS_HOST_OTG_FS_HCCHAR9_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR9_MCNT); }
inline void otg_fs_host_otg_fs_hcchar9_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR9 = (p->OTG_FS_HCCHAR9 & ~OTG_FS_HOST_OTG_FS_HCCHAR9_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR9_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar9_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR9 = (p->OTG_FS_HCCHAR9 & ~OTG_FS_HOST_OTG_FS_HCCHAR9_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR9_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar9_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR9 = (p->OTG_FS_HCCHAR9 & ~OTG_FS_HOST_OTG_FS_HCCHAR9_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR9_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar9_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR9 & OTG_FS_HOST_OTG_FS_HCCHAR9_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar9_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR9 & OTG_FS_HOST_OTG_FS_HCCHAR9_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar9_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR9 & OTG_FS_HOST_OTG_FS_HCCHAR9_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar9_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR9 & OTG_FS_HOST_OTG_FS_HCCHAR9_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar9_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR9 & OTG_FS_HOST_OTG_FS_HCCHAR9_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT9 OTG_FS host channel-9 interrupt register
enum {
	OTG_FS_HOST_OTG_FS_HCINT9_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT9_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT9_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT9_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT9_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT9_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT9_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT9_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT9_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK9 OTG_FS host channel-9 mask register
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK9_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK9_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ9 OTG_FS host channel-9 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ9_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ9_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ9_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz9_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ9 = (p->OTG_FS_HCTSIZ9 & ~OTG_FS_HOST_OTG_FS_HCTSIZ9_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ9_DPID); }
inline void otg_fs_host_otg_fs_hctsiz9_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ9 = (p->OTG_FS_HCTSIZ9 & ~OTG_FS_HOST_OTG_FS_HCTSIZ9_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ9_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz9_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ9 = (p->OTG_FS_HCTSIZ9 & ~OTG_FS_HOST_OTG_FS_HCTSIZ9_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ9_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz9_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ9 & OTG_FS_HOST_OTG_FS_HCTSIZ9_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz9_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ9 & OTG_FS_HOST_OTG_FS_HCTSIZ9_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz9_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ9 & OTG_FS_HOST_OTG_FS_HCTSIZ9_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR10 OTG_FS host channel-10 characteristics register
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR10_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR10_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR10_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR10_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR10_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR10_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR10_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR10_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR10_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR10_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar10_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR10 = (p->OTG_FS_HCCHAR10 & ~OTG_FS_HOST_OTG_FS_HCCHAR10_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR10_DAD); }
inline void otg_fs_host_otg_fs_hcchar10_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR10 = (p->OTG_FS_HCCHAR10 & ~OTG_FS_HOST_OTG_FS_HCCHAR10_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR10_MCNT); }
inline void otg_fs_host_otg_fs_hcchar10_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR10 = (p->OTG_FS_HCCHAR10 & ~OTG_FS_HOST_OTG_FS_HCCHAR10_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR10_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar10_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR10 = (p->OTG_FS_HCCHAR10 & ~OTG_FS_HOST_OTG_FS_HCCHAR10_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR10_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar10_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR10 = (p->OTG_FS_HCCHAR10 & ~OTG_FS_HOST_OTG_FS_HCCHAR10_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR10_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar10_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR10 & OTG_FS_HOST_OTG_FS_HCCHAR10_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar10_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR10 & OTG_FS_HOST_OTG_FS_HCCHAR10_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar10_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR10 & OTG_FS_HOST_OTG_FS_HCCHAR10_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar10_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR10 & OTG_FS_HOST_OTG_FS_HCCHAR10_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar10_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR10 & OTG_FS_HOST_OTG_FS_HCCHAR10_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT10 OTG_FS host channel-10 interrupt register
enum {
	OTG_FS_HOST_OTG_FS_HCINT10_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT10_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT10_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT10_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT10_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT10_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT10_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT10_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT10_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK10 OTG_FS host channel-10 mask register
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK10_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK10_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ10 OTG_FS host channel-10 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ10_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ10_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ10_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz10_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ10 = (p->OTG_FS_HCTSIZ10 & ~OTG_FS_HOST_OTG_FS_HCTSIZ10_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ10_DPID); }
inline void otg_fs_host_otg_fs_hctsiz10_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ10 = (p->OTG_FS_HCTSIZ10 & ~OTG_FS_HOST_OTG_FS_HCTSIZ10_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ10_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz10_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ10 = (p->OTG_FS_HCTSIZ10 & ~OTG_FS_HOST_OTG_FS_HCTSIZ10_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ10_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz10_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ10 & OTG_FS_HOST_OTG_FS_HCTSIZ10_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz10_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ10 & OTG_FS_HOST_OTG_FS_HCTSIZ10_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz10_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ10 & OTG_FS_HOST_OTG_FS_HCTSIZ10_XFRSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCCHAR11 OTG_FS host channel-11 characteristics register
enum {
	OTG_FS_HOST_OTG_FS_HCCHAR11_CHENA = 1UL<<31, // Channel enable
	OTG_FS_HOST_OTG_FS_HCCHAR11_CHDIS = 1UL<<30, // Channel disable
	OTG_FS_HOST_OTG_FS_HCCHAR11_ODDFRM = 1UL<<29, // Odd frame
	OTG_FS_HOST_OTG_FS_HCCHAR11_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_FS_HOST_OTG_FS_HCCHAR11_MCNT = ((1UL<<2)-1) << 20, // Multicount
	OTG_FS_HOST_OTG_FS_HCCHAR11_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_FS_HOST_OTG_FS_HCCHAR11_LSDEV = 1UL<<17, // Low-speed device
	OTG_FS_HOST_OTG_FS_HCCHAR11_EPDIR = 1UL<<15, // Endpoint direction
	OTG_FS_HOST_OTG_FS_HCCHAR11_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_FS_HOST_OTG_FS_HCCHAR11_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_fs_host_otg_fs_hcchar11_set_dad(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR11 = (p->OTG_FS_HCCHAR11 & ~OTG_FS_HOST_OTG_FS_HCCHAR11_DAD) | ((val<<22) & OTG_FS_HOST_OTG_FS_HCCHAR11_DAD); }
inline void otg_fs_host_otg_fs_hcchar11_set_mcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR11 = (p->OTG_FS_HCCHAR11 & ~OTG_FS_HOST_OTG_FS_HCCHAR11_MCNT) | ((val<<20) & OTG_FS_HOST_OTG_FS_HCCHAR11_MCNT); }
inline void otg_fs_host_otg_fs_hcchar11_set_eptyp(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR11 = (p->OTG_FS_HCCHAR11 & ~OTG_FS_HOST_OTG_FS_HCCHAR11_EPTYP) | ((val<<18) & OTG_FS_HOST_OTG_FS_HCCHAR11_EPTYP); }
inline void otg_fs_host_otg_fs_hcchar11_set_epnum(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR11 = (p->OTG_FS_HCCHAR11 & ~OTG_FS_HOST_OTG_FS_HCCHAR11_EPNUM) | ((val<<11) & OTG_FS_HOST_OTG_FS_HCCHAR11_EPNUM); }
inline void otg_fs_host_otg_fs_hcchar11_set_mpsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCCHAR11 = (p->OTG_FS_HCCHAR11 & ~OTG_FS_HOST_OTG_FS_HCCHAR11_MPSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCCHAR11_MPSIZ); }
inline uint32_t otg_fs_host_otg_fs_hcchar11_get_dad(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR11 & OTG_FS_HOST_OTG_FS_HCCHAR11_DAD) >> 22 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar11_get_mcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR11 & OTG_FS_HOST_OTG_FS_HCCHAR11_MCNT) >> 20 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar11_get_eptyp(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR11 & OTG_FS_HOST_OTG_FS_HCCHAR11_EPTYP) >> 18 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar11_get_epnum(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR11 & OTG_FS_HOST_OTG_FS_HCCHAR11_EPNUM) >> 11 ; }
inline uint32_t otg_fs_host_otg_fs_hcchar11_get_mpsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCCHAR11 & OTG_FS_HOST_OTG_FS_HCCHAR11_MPSIZ) >> 0 ; }

// OTG_FS_HOST->OTG_FS_HCINT11 OTG_FS host channel-11 interrupt register
enum {
	OTG_FS_HOST_OTG_FS_HCINT11_DTERR = 1UL<<10, // Data toggle error
	OTG_FS_HOST_OTG_FS_HCINT11_FRMOR = 1UL<<9, // Frame overrun
	OTG_FS_HOST_OTG_FS_HCINT11_BBERR = 1UL<<8, // Babble error
	OTG_FS_HOST_OTG_FS_HCINT11_TXERR = 1UL<<7, // Transaction error
	OTG_FS_HOST_OTG_FS_HCINT11_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_FS_HOST_OTG_FS_HCINT11_NAK = 1UL<<4, // NAK response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT11_STALL = 1UL<<3, // STALL response received interrupt
	OTG_FS_HOST_OTG_FS_HCINT11_CHH = 1UL<<1, // Channel halted
	OTG_FS_HOST_OTG_FS_HCINT11_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_FS_HOST->OTG_FS_HCINTMSK11 OTG_FS host channel-11 mask register
enum {
	OTG_FS_HOST_OTG_FS_HCINTMSK11_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_BBERRM = 1UL<<8, // Babble error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_TXERRM = 1UL<<7, // Transaction error mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_NYET = 1UL<<6, // response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_CHHM = 1UL<<1, // Channel halted mask
	OTG_FS_HOST_OTG_FS_HCINTMSK11_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_FS_HOST->OTG_FS_HCTSIZ11 OTG_FS host channel-11 transfer size register
enum {
	OTG_FS_HOST_OTG_FS_HCTSIZ11_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_FS_HOST_OTG_FS_HCTSIZ11_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_FS_HOST_OTG_FS_HCTSIZ11_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_fs_host_otg_fs_hctsiz11_set_dpid(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ11 = (p->OTG_FS_HCTSIZ11 & ~OTG_FS_HOST_OTG_FS_HCTSIZ11_DPID) | ((val<<29) & OTG_FS_HOST_OTG_FS_HCTSIZ11_DPID); }
inline void otg_fs_host_otg_fs_hctsiz11_set_pktcnt(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ11 = (p->OTG_FS_HCTSIZ11 & ~OTG_FS_HOST_OTG_FS_HCTSIZ11_PKTCNT) | ((val<<19) & OTG_FS_HOST_OTG_FS_HCTSIZ11_PKTCNT); }
inline void otg_fs_host_otg_fs_hctsiz11_set_xfrsiz(struct OTG_FS_HOST_Type* p, uint32_t val) { p->OTG_FS_HCTSIZ11 = (p->OTG_FS_HCTSIZ11 & ~OTG_FS_HOST_OTG_FS_HCTSIZ11_XFRSIZ) | ((val<<0) & OTG_FS_HOST_OTG_FS_HCTSIZ11_XFRSIZ); }
inline uint32_t otg_fs_host_otg_fs_hctsiz11_get_dpid(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ11 & OTG_FS_HOST_OTG_FS_HCTSIZ11_DPID) >> 29 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz11_get_pktcnt(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ11 & OTG_FS_HOST_OTG_FS_HCTSIZ11_PKTCNT) >> 19 ; }
inline uint32_t otg_fs_host_otg_fs_hctsiz11_get_xfrsiz(struct OTG_FS_HOST_Type* p) { return (p->OTG_FS_HCTSIZ11 & OTG_FS_HOST_OTG_FS_HCTSIZ11_XFRSIZ) >> 0 ; }

/* USB on the go full speed */
struct OTG_FS_PWRCLK_Type {
	__IO uint8_t OTG_FS_PCGCCTL; // @0 OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)
};

// OTG_FS_PWRCLK->OTG_FS_PCGCCTL OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)
enum {
	OTG_FS_PWRCLK_OTG_FS_PCGCCTL_PHYSUSP = 1UL<<4, // PHY Suspended
	OTG_FS_PWRCLK_OTG_FS_PCGCCTL_GATEHCLK = 1UL<<1, // Gate HCLK
	OTG_FS_PWRCLK_OTG_FS_PCGCCTL_STPPCLK = 1UL<<0, // Stop PHY clock		
};

/* USB on the go high speed */
struct OTG_HS_DEVICE_Type {
	__IO uint32_t OTG_HS_DCFG; // @0 OTG_HS device configuration register
	__IO uint16_t OTG_HS_DCTL; // @4 OTG_HS device control register
	 uint8_t RESERVED0[2]; // @6 
	__I uint32_t OTG_HS_DSTS; // @8 OTG_HS device status register
	 uint8_t RESERVED1[4]; // @12 
	__IO uint16_t OTG_HS_DIEPMSK; // @16 OTG_HS device IN endpoint common interrupt mask register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint16_t OTG_HS_DOEPMSK; // @20 OTG_HS device OUT endpoint common interrupt mask register
	 uint8_t RESERVED3[2]; // @22 
	__I uint32_t OTG_HS_DAINT; // @24 OTG_HS device all endpoints interrupt register
	__IO uint32_t OTG_HS_DAINTMSK; // @28 OTG_HS all endpoints interrupt mask register
	 uint8_t RESERVED4[8]; // @32 
	__IO uint16_t OTG_HS_DVBUSDIS; // @40 OTG_HS device VBUS discharge time register
	 uint8_t RESERVED5[2]; // @42 
	__IO uint16_t OTG_HS_DVBUSPULSE; // @44 OTG_HS device VBUS pulsing time register
	 uint8_t RESERVED6[2]; // @46 
	__IO uint32_t OTG_HS_DTHRCTL; // @48 OTG_HS Device threshold control register
	__IO uint16_t OTG_HS_DIEPEMPMSK; // @52 OTG_HS device IN endpoint FIFO empty interrupt mask register
	 uint8_t RESERVED7[2]; // @54 
	__IO uint32_t OTG_HS_DEACHINT; // @56 OTG_HS device each endpoint interrupt register
	__IO uint32_t OTG_HS_DEACHINTMSK; // @60 OTG_HS device each endpoint interrupt register mask
	 uint8_t RESERVED8[192]; // @64 
	__IO uint32_t OTG_HS_DIEPCTL0; // @256 OTG device endpoint-0 control register
	 uint8_t RESERVED9[4]; // @260 
	__IO uint16_t OTG_HS_DIEPINT0; // @264 OTG device endpoint-0 interrupt register
	 uint8_t RESERVED10[6]; // @266 
	__IO uint32_t OTG_HS_DIEPTSIZ0; // @272 OTG_HS device IN endpoint 0 transfer size register
	__IO uint32_t OTG_HS_DIEPDMA1; // @276 OTG_HS device endpoint-1 DMA address register
	__I uint16_t OTG_HS_DTXFSTS0; // @280 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED11[6]; // @282 
	__IO uint32_t OTG_HS_DIEPCTL1; // @288 OTG device endpoint-1 control register
	 uint8_t RESERVED12[4]; // @292 
	__IO uint16_t OTG_HS_DIEPINT1; // @296 OTG device endpoint-1 interrupt register
	 uint8_t RESERVED13[6]; // @298 
	__IO uint32_t OTG_HS_DIEPTSIZ1; // @304 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA2; // @308 OTG_HS device endpoint-2 DMA address register
	__I uint16_t OTG_HS_DTXFSTS1; // @312 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED14[6]; // @314 
	__IO uint32_t OTG_HS_DIEPCTL2; // @320 OTG device endpoint-2 control register
	 uint8_t RESERVED15[4]; // @324 
	__IO uint16_t OTG_HS_DIEPINT2; // @328 OTG device endpoint-2 interrupt register
	 uint8_t RESERVED16[6]; // @330 
	__IO uint32_t OTG_HS_DIEPTSIZ2; // @336 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA3; // @340 OTG_HS device endpoint-3 DMA address register
	__I uint16_t OTG_HS_DTXFSTS2; // @344 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED17[6]; // @346 
	__IO uint32_t OTG_HS_DIEPCTL3; // @352 OTG device endpoint-3 control register
	 uint8_t RESERVED18[4]; // @356 
	__IO uint16_t OTG_HS_DIEPINT3; // @360 OTG device endpoint-3 interrupt register
	 uint8_t RESERVED19[6]; // @362 
	__IO uint32_t OTG_HS_DIEPTSIZ3; // @368 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA4; // @372 OTG_HS device endpoint-4 DMA address register
	__I uint16_t OTG_HS_DTXFSTS3; // @376 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED20[6]; // @378 
	__IO uint32_t OTG_HS_DIEPCTL4; // @384 OTG device endpoint-4 control register
	 uint8_t RESERVED21[4]; // @388 
	__IO uint16_t OTG_HS_DIEPINT4; // @392 OTG device endpoint-4 interrupt register
	 uint8_t RESERVED22[6]; // @394 
	__IO uint32_t OTG_HS_DIEPTSIZ4; // @400 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA5; // @404 OTG_HS device endpoint-5 DMA address register
	__I uint16_t OTG_HS_DTXFSTS4; // @408 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED23[6]; // @410 
	union {  // @416
		__IO uint32_t OTG_HS_DIEPCTL5; // OTG device endpoint-5 control register
		__IO uint32_t OTG_HS_DIEPTSIZ6; // OTG_HS device endpoint transfer size register
	};
	__IO uint16_t OTG_HS_DTXFSTS6; // @420 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED24[2]; // @422 
	union {  // @424
		__IO uint32_t OTG_HS_DIEPTSIZ7; // OTG_HS device endpoint transfer size register
		__IO uint16_t OTG_HS_DIEPINT5; // OTG device endpoint-5 interrupt register
	};
	__IO uint16_t OTG_HS_DTXFSTS7; // @428 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED25[2]; // @430 
	__IO uint32_t OTG_HS_DIEPTSIZ5; // @432 OTG_HS device endpoint transfer size register
	 uint8_t RESERVED26[4]; // @436 
	__I uint16_t OTG_HS_DTXFSTS5; // @440 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED27[6]; // @442 
	__IO uint32_t OTG_HS_DIEPCTL6; // @448 OTG device endpoint-6 control register
	 uint8_t RESERVED28[4]; // @452 
	__IO uint16_t OTG_HS_DIEPINT6; // @456 OTG device endpoint-6 interrupt register
	 uint8_t RESERVED29[22]; // @458 
	__IO uint32_t OTG_HS_DIEPCTL7; // @480 OTG device endpoint-7 control register
	 uint8_t RESERVED30[4]; // @484 
	__IO uint16_t OTG_HS_DIEPINT7; // @488 OTG device endpoint-7 interrupt register
	 uint8_t RESERVED31[278]; // @490 
	__IO uint32_t OTG_HS_DOEPCTL0; // @768 OTG_HS device control OUT endpoint 0 control register
	 uint8_t RESERVED32[4]; // @772 
	__IO uint16_t OTG_HS_DOEPINT0; // @776 OTG_HS device endpoint-0 interrupt register
	 uint8_t RESERVED33[6]; // @778 
	__IO uint32_t OTG_HS_DOEPTSIZ0; // @784 OTG_HS device endpoint-0 transfer size register
	 uint8_t RESERVED34[12]; // @788 
	__IO uint32_t OTG_HS_DOEPCTL1; // @800 OTG device endpoint-1 control register
	 uint8_t RESERVED35[4]; // @804 
	__IO uint16_t OTG_HS_DOEPINT1; // @808 OTG_HS device endpoint-1 interrupt register
	 uint8_t RESERVED36[6]; // @810 
	__IO uint32_t OTG_HS_DOEPTSIZ1; // @816 OTG_HS device endpoint-1 transfer size register
	 uint8_t RESERVED37[12]; // @820 
	__IO uint32_t OTG_HS_DOEPCTL2; // @832 OTG device endpoint-2 control register
	 uint8_t RESERVED38[4]; // @836 
	__IO uint16_t OTG_HS_DOEPINT2; // @840 OTG_HS device endpoint-2 interrupt register
	 uint8_t RESERVED39[6]; // @842 
	__IO uint32_t OTG_HS_DOEPTSIZ2; // @848 OTG_HS device endpoint-2 transfer size register
	 uint8_t RESERVED40[12]; // @852 
	__IO uint32_t OTG_HS_DOEPCTL3; // @864 OTG device endpoint-3 control register
	 uint8_t RESERVED41[4]; // @868 
	__IO uint16_t OTG_HS_DOEPINT3; // @872 OTG_HS device endpoint-3 interrupt register
	 uint8_t RESERVED42[6]; // @874 
	__IO uint32_t OTG_HS_DOEPTSIZ3; // @880 OTG_HS device endpoint-3 transfer size register
	 uint8_t RESERVED43[12]; // @884 
	__IO uint32_t OTG_HS_DOEPCTL4; // @896 OTG device endpoint-4 control register
	 uint8_t RESERVED44[4]; // @900 
	__IO uint16_t OTG_HS_DOEPINT4; // @904 OTG_HS device endpoint-4 interrupt register
	 uint8_t RESERVED45[6]; // @906 
	__IO uint32_t OTG_HS_DOEPTSIZ4; // @912 OTG_HS device endpoint-4 transfer size register
	 uint8_t RESERVED46[12]; // @916 
	__IO uint32_t OTG_HS_DOEPCTL5; // @928 OTG device endpoint-5 control register
	 uint8_t RESERVED47[4]; // @932 
	__IO uint16_t OTG_HS_DOEPINT5; // @936 OTG_HS device endpoint-5 interrupt register
	 uint8_t RESERVED48[6]; // @938 
	__IO uint32_t OTG_HS_DOEPTSIZ5; // @944 OTG_HS device endpoint-5 transfer size register
	 uint8_t RESERVED49[12]; // @948 
	__IO uint32_t OTG_HS_DOEPCTL6; // @960 OTG device endpoint-6 control register
	 uint8_t RESERVED50[4]; // @964 
	__IO uint16_t OTG_HS_DOEPINT6; // @968 OTG_HS device endpoint-6 interrupt register
	 uint8_t RESERVED51[6]; // @970 
	__IO uint32_t OTG_HS_DOEPTSIZ6; // @976 OTG_HS device endpoint-6 transfer size register
	 uint8_t RESERVED52[12]; // @980 
	__IO uint32_t OTG_HS_DOEPCTL7; // @992 OTG device endpoint-7 control register
	 uint8_t RESERVED53[4]; // @996 
	__IO uint16_t OTG_HS_DOEPINT7; // @1000 OTG_HS device endpoint-7 interrupt register
	 uint8_t RESERVED54[6]; // @1002 
	__IO uint32_t OTG_HS_DOEPTSIZ7; // @1008 OTG_HS device endpoint-7 transfer size register
};

// OTG_HS_DEVICE->OTG_HS_DCFG OTG_HS device configuration register
enum {
	OTG_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL = ((1UL<<2)-1) << 24, // Periodic scheduling interval
	OTG_HS_DEVICE_OTG_HS_DCFG_PFIVL = ((1UL<<2)-1) << 11, // Periodic (micro)frame interval
	OTG_HS_DEVICE_OTG_HS_DCFG_DAD = ((1UL<<7)-1) << 4, // Device address
	OTG_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK = 1UL<<2, // Nonzero-length status OUT handshake
	OTG_HS_DEVICE_OTG_HS_DCFG_DSPD = ((1UL<<2)-1) << 0, // Device speed		
};
inline void otg_hs_device_otg_hs_dcfg_set_perschivl(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL) | ((val<<24) & OTG_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL); }
inline void otg_hs_device_otg_hs_dcfg_set_pfivl(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG_HS_DEVICE_OTG_HS_DCFG_PFIVL) | ((val<<11) & OTG_HS_DEVICE_OTG_HS_DCFG_PFIVL); }
inline void otg_hs_device_otg_hs_dcfg_set_dad(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG_HS_DEVICE_OTG_HS_DCFG_DAD) | ((val<<4) & OTG_HS_DEVICE_OTG_HS_DCFG_DAD); }
inline void otg_hs_device_otg_hs_dcfg_set_dspd(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG_HS_DEVICE_OTG_HS_DCFG_DSPD) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DCFG_DSPD); }
inline uint32_t otg_hs_device_otg_hs_dcfg_get_perschivl(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL) >> 24 ; }
inline uint32_t otg_hs_device_otg_hs_dcfg_get_pfivl(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG_HS_DEVICE_OTG_HS_DCFG_PFIVL) >> 11 ; }
inline uint32_t otg_hs_device_otg_hs_dcfg_get_dad(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG_HS_DEVICE_OTG_HS_DCFG_DAD) >> 4 ; }
inline uint32_t otg_hs_device_otg_hs_dcfg_get_dspd(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG_HS_DEVICE_OTG_HS_DCFG_DSPD) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DCTL OTG_HS device control register
enum {
	OTG_HS_DEVICE_OTG_HS_DCTL_POPRGDNE = 1UL<<11, // Power-on programming done
	OTG_HS_DEVICE_OTG_HS_DCTL_CGONAK = 1UL<<10, // Clear global OUT NAK
	OTG_HS_DEVICE_OTG_HS_DCTL_SGONAK = 1UL<<9, // Set global OUT NAK
	OTG_HS_DEVICE_OTG_HS_DCTL_CGINAK = 1UL<<8, // Clear global IN NAK
	OTG_HS_DEVICE_OTG_HS_DCTL_SGINAK = 1UL<<7, // Set global IN NAK
	OTG_HS_DEVICE_OTG_HS_DCTL_TCTL = ((1UL<<3)-1) << 4, // Test control
	OTG_HS_DEVICE_OTG_HS_DCTL_GONSTS = 1UL<<3, // Global OUT NAK status
	OTG_HS_DEVICE_OTG_HS_DCTL_GINSTS = 1UL<<2, // Global IN NAK status
	OTG_HS_DEVICE_OTG_HS_DCTL_SDIS = 1UL<<1, // Soft disconnect
	OTG_HS_DEVICE_OTG_HS_DCTL_RWUSIG = 1UL<<0, // Remote wakeup signaling		
};
inline void otg_hs_device_otg_hs_dctl_set_tctl(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCTL = (p->OTG_HS_DCTL & ~OTG_HS_DEVICE_OTG_HS_DCTL_TCTL) | ((val<<4) & OTG_HS_DEVICE_OTG_HS_DCTL_TCTL); }
inline uint32_t otg_hs_device_otg_hs_dctl_get_tctl(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DCTL & OTG_HS_DEVICE_OTG_HS_DCTL_TCTL) >> 4 ; }

// OTG_HS_DEVICE->OTG_HS_DSTS OTG_HS device status register
enum {
	OTG_HS_DEVICE_OTG_HS_DSTS_FNSOF = ((1UL<<14)-1) << 8, // Frame number of the received SOF
	OTG_HS_DEVICE_OTG_HS_DSTS_EERR = 1UL<<3, // Erratic error
	OTG_HS_DEVICE_OTG_HS_DSTS_ENUMSPD = ((1UL<<2)-1) << 1, // Enumerated speed
	OTG_HS_DEVICE_OTG_HS_DSTS_SUSPSTS = 1UL<<0, // Suspend status		
};
inline uint32_t otg_hs_device_otg_hs_dsts_get_fnsof(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DSTS & OTG_HS_DEVICE_OTG_HS_DSTS_FNSOF) >> 8 ; }
inline uint32_t otg_hs_device_otg_hs_dsts_get_enumspd(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DSTS & OTG_HS_DEVICE_OTG_HS_DSTS_ENUMSPD) >> 1 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPMSK OTG_HS device IN endpoint common interrupt mask register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_BIM = 1UL<<9, // BNA interrupt mask
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM = 1UL<<8, // FIFO underrun mask
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM = 1UL<<6, // IN endpoint NAK effective mask
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM = 1UL<<5, // IN token received with EP mismatch mask
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK = 1UL<<4, // IN token received when TxFIFO empty mask
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_TOM = 1UL<<3, // Timeout condition mask (nonisochronous endpoints)
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_EPDM = 1UL<<1, // Endpoint disabled interrupt mask
	OTG_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM = 1UL<<0, // Transfer completed interrupt mask		
};

// OTG_HS_DEVICE->OTG_HS_DOEPMSK OTG_HS device OUT endpoint common interrupt mask register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_BOIM = 1UL<<9, // BNA interrupt mask
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_OPEM = 1UL<<8, // OUT packet error mask
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received mask
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM = 1UL<<4, // OUT token received when endpoint disabled mask
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_STUPM = 1UL<<3, // SETUP phase done mask
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_EPDM = 1UL<<1, // Endpoint disabled interrupt mask
	OTG_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM = 1UL<<0, // Transfer completed interrupt mask		
};

// OTG_HS_DEVICE->OTG_HS_DAINT OTG_HS device all endpoints interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DAINT_OEPINT = ((1UL<<16)-1) << 16, // OUT endpoint interrupt bits
	OTG_HS_DEVICE_OTG_HS_DAINT_IEPINT = ((1UL<<16)-1) << 0, // IN endpoint interrupt bits		
};
inline uint32_t otg_hs_device_otg_hs_daint_get_oepint(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINT & OTG_HS_DEVICE_OTG_HS_DAINT_OEPINT) >> 16 ; }
inline uint32_t otg_hs_device_otg_hs_daint_get_iepint(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINT & OTG_HS_DEVICE_OTG_HS_DAINT_IEPINT) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DAINTMSK OTG_HS all endpoints interrupt mask register
enum {
	OTG_HS_DEVICE_OTG_HS_DAINTMSK_OEPM = ((1UL<<16)-1) << 16, // OUT EP interrupt mask bits
	OTG_HS_DEVICE_OTG_HS_DAINTMSK_IEPM = ((1UL<<16)-1) << 0, // IN EP interrupt mask bits		
};
inline void otg_hs_device_otg_hs_daintmsk_set_oepm(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DAINTMSK = (p->OTG_HS_DAINTMSK & ~OTG_HS_DEVICE_OTG_HS_DAINTMSK_OEPM) | ((val<<16) & OTG_HS_DEVICE_OTG_HS_DAINTMSK_OEPM); }
inline void otg_hs_device_otg_hs_daintmsk_set_iepm(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DAINTMSK = (p->OTG_HS_DAINTMSK & ~OTG_HS_DEVICE_OTG_HS_DAINTMSK_IEPM) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DAINTMSK_IEPM); }
inline uint32_t otg_hs_device_otg_hs_daintmsk_get_oepm(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINTMSK & OTG_HS_DEVICE_OTG_HS_DAINTMSK_OEPM) >> 16 ; }
inline uint32_t otg_hs_device_otg_hs_daintmsk_get_iepm(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINTMSK & OTG_HS_DEVICE_OTG_HS_DAINTMSK_IEPM) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DVBUSPULSE OTG_HS device VBUS pulsing time register
enum {
	OTG_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP = ((1UL<<12)-1) << 0, // Device VBUS pulsing time		
};
inline void otg_hs_device_otg_hs_dvbuspulse_set_dvbusp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DVBUSPULSE = (p->OTG_HS_DVBUSPULSE & ~OTG_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP); }
inline uint32_t otg_hs_device_otg_hs_dvbuspulse_get_dvbusp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DVBUSPULSE & OTG_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DTHRCTL OTG_HS Device threshold control register
enum {
	OTG_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN = 1UL<<27, // Arbiter parking enable
	OTG_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN = ((1UL<<9)-1) << 17, // Receive threshold length
	OTG_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN = 1UL<<16, // Receive threshold enable
	OTG_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN = ((1UL<<9)-1) << 2, // Transmit threshold length
	OTG_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN = 1UL<<1, // ISO IN endpoint threshold enable
	OTG_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN = 1UL<<0, // Nonisochronous IN endpoints threshold enable		
};
inline void otg_hs_device_otg_hs_dthrctl_set_rxthrlen(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DTHRCTL = (p->OTG_HS_DTHRCTL & ~OTG_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN) | ((val<<17) & OTG_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN); }
inline void otg_hs_device_otg_hs_dthrctl_set_txthrlen(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DTHRCTL = (p->OTG_HS_DTHRCTL & ~OTG_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN) | ((val<<2) & OTG_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN); }
inline uint32_t otg_hs_device_otg_hs_dthrctl_get_rxthrlen(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DTHRCTL & OTG_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN) >> 17 ; }
inline uint32_t otg_hs_device_otg_hs_dthrctl_get_txthrlen(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DTHRCTL & OTG_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN) >> 2 ; }

// OTG_HS_DEVICE->OTG_HS_DEACHINT OTG_HS device each endpoint interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT = 1UL<<17, // OUT endpoint 1 interrupt bit
	OTG_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT = 1UL<<1, // IN endpoint 1interrupt bit		
};

// OTG_HS_DEVICE->OTG_HS_DEACHINTMSK OTG_HS device each endpoint interrupt register mask
enum {
	OTG_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM = 1UL<<17, // OUT Endpoint 1 interrupt mask bit
	OTG_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM = 1UL<<1, // IN Endpoint 1 interrupt mask bit		
};

// OTG_HS_DEVICE->OTG_HS_DIEPCTL0 OTG device endpoint-0 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl0_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL0 = (p->OTG_HS_DIEPCTL0 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl0_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL0 = (p->OTG_HS_DIEPCTL0 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl0_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL0 = (p->OTG_HS_DIEPCTL0 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl0_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL0 & OTG_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl0_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL0 & OTG_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl0_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL0 & OTG_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT0 OTG device endpoint-0 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT0_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ0 OTG_HS device IN endpoint 0 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT = ((1UL<<2)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ = ((1UL<<7)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz0_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ0 = (p->OTG_HS_DIEPTSIZ0 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz0_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ0 = (p->OTG_HS_DIEPTSIZ0 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz0_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ0 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz0_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ0 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPCTL1 OTG device endpoint-1 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl1_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL1 = (p->OTG_HS_DIEPCTL1 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl1_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL1 = (p->OTG_HS_DIEPCTL1 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl1_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL1 = (p->OTG_HS_DIEPCTL1 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl1_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL1 & OTG_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl1_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL1 & OTG_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl1_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL1 & OTG_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT1 OTG device endpoint-1 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT1_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ1 OTG_HS device endpoint transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz1_set_mcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ1 = (p->OTG_HS_DIEPTSIZ1 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT); }
inline void otg_hs_device_otg_hs_dieptsiz1_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ1 = (p->OTG_HS_DIEPTSIZ1 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz1_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ1 = (p->OTG_HS_DIEPTSIZ1 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz1_get_mcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ1 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz1_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ1 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz1_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ1 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPCTL2 OTG device endpoint-2 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl2_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL2 = (p->OTG_HS_DIEPCTL2 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl2_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL2 = (p->OTG_HS_DIEPCTL2 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl2_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL2 = (p->OTG_HS_DIEPCTL2 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl2_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL2 & OTG_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl2_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL2 & OTG_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl2_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL2 & OTG_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT2 OTG device endpoint-2 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT2_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ2 OTG_HS device endpoint transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz2_set_mcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ2 = (p->OTG_HS_DIEPTSIZ2 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT); }
inline void otg_hs_device_otg_hs_dieptsiz2_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ2 = (p->OTG_HS_DIEPTSIZ2 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz2_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ2 = (p->OTG_HS_DIEPTSIZ2 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz2_get_mcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ2 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz2_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ2 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz2_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ2 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPCTL3 OTG device endpoint-3 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl3_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL3 = (p->OTG_HS_DIEPCTL3 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl3_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL3 = (p->OTG_HS_DIEPCTL3 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl3_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL3 = (p->OTG_HS_DIEPCTL3 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl3_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL3 & OTG_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl3_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL3 & OTG_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl3_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL3 & OTG_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT3 OTG device endpoint-3 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT3_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ3 OTG_HS device endpoint transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz3_set_mcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ3 = (p->OTG_HS_DIEPTSIZ3 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT); }
inline void otg_hs_device_otg_hs_dieptsiz3_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ3 = (p->OTG_HS_DIEPTSIZ3 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz3_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ3 = (p->OTG_HS_DIEPTSIZ3 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz3_get_mcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ3 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz3_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ3 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz3_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ3 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPCTL4 OTG device endpoint-4 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl4_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL4 = (p->OTG_HS_DIEPCTL4 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl4_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL4 = (p->OTG_HS_DIEPCTL4 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl4_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL4 = (p->OTG_HS_DIEPCTL4 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl4_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL4 & OTG_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl4_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL4 & OTG_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl4_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL4 & OTG_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT4 OTG device endpoint-4 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT4_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ4 OTG_HS device endpoint transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz4_set_mcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ4 = (p->OTG_HS_DIEPTSIZ4 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT); }
inline void otg_hs_device_otg_hs_dieptsiz4_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ4 = (p->OTG_HS_DIEPTSIZ4 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz4_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ4 = (p->OTG_HS_DIEPTSIZ4 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz4_get_mcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ4 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz4_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ4 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz4_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ4 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPCTL5 OTG device endpoint-5 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl5_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL5 = (p->OTG_HS_DIEPCTL5 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl5_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL5 = (p->OTG_HS_DIEPCTL5 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl5_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL5 = (p->OTG_HS_DIEPCTL5 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl5_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL5 & OTG_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl5_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL5 & OTG_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl5_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL5 & OTG_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ7 OTG_HS device endpoint transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz7_set_mcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ7 = (p->OTG_HS_DIEPTSIZ7 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT); }
inline void otg_hs_device_otg_hs_dieptsiz7_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ7 = (p->OTG_HS_DIEPTSIZ7 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz7_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ7 = (p->OTG_HS_DIEPTSIZ7 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz7_get_mcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ7 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz7_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ7 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz7_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ7 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPTSIZ5 OTG_HS device endpoint transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_dieptsiz5_set_mcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ5 = (p->OTG_HS_DIEPTSIZ5 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT); }
inline void otg_hs_device_otg_hs_dieptsiz5_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ5 = (p->OTG_HS_DIEPTSIZ5 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT); }
inline void otg_hs_device_otg_hs_dieptsiz5_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ5 = (p->OTG_HS_DIEPTSIZ5 & ~OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_dieptsiz5_get_mcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ5 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz5_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ5 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_dieptsiz5_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ5 & OTG_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPCTL6 OTG device endpoint-6 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl6_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL6 = (p->OTG_HS_DIEPCTL6 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl6_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL6 = (p->OTG_HS_DIEPCTL6 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl6_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL6 = (p->OTG_HS_DIEPCTL6 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl6_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL6 & OTG_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl6_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL6 & OTG_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl6_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL6 & OTG_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT6 OTG device endpoint-6 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT6_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DIEPCTL7 OTG device endpoint-7 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_diepctl7_set_txfnum(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL7 = (p->OTG_HS_DIEPCTL7 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM) | ((val<<22) & OTG_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM); }
inline void otg_hs_device_otg_hs_diepctl7_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL7 = (p->OTG_HS_DIEPCTL7 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP); }
inline void otg_hs_device_otg_hs_diepctl7_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL7 = (p->OTG_HS_DIEPCTL7 & ~OTG_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_diepctl7_get_txfnum(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL7 & OTG_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM) >> 22 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl7_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL7 & OTG_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_diepctl7_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL7 & OTG_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DIEPINT7 OTG device endpoint-7 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_NAK = 1UL<<13, // NAK interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_BERR = 1UL<<12, // Babble error interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_BNA = 1UL<<9, // Buffer not available interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_TOC = 1UL<<3, // Timeout condition
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DIEPINT7_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPCTL0 OTG_HS device control OUT endpoint 0 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ = ((1UL<<2)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl0_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL0 = (p->OTG_HS_DOEPCTL0 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl0_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL0 = (p->OTG_HS_DOEPCTL0 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl0_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL0 & OTG_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl0_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL0 & OTG_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT0 OTG_HS device endpoint-0 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT0_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT0_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT0_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT0_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT0_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT0_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ0 OTG_HS device endpoint-0 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT = ((1UL<<2)-1) << 29, // SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT = 1UL<<19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ = ((1UL<<7)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz0_set_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ0 = (p->OTG_HS_DOEPTSIZ0 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz0_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ0 = (p->OTG_HS_DOEPTSIZ0 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz0_get_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ0 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz0_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ0 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL1 OTG device endpoint-1 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl1_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL1 = (p->OTG_HS_DOEPCTL1 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl1_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL1 = (p->OTG_HS_DOEPCTL1 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl1_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL1 & OTG_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl1_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL1 & OTG_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT1 OTG_HS device endpoint-1 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT1_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT1_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT1_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT1_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT1_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT1_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ1 OTG_HS device endpoint-1 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz1_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ1 = (p->OTG_HS_DOEPTSIZ1 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz1_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ1 = (p->OTG_HS_DOEPTSIZ1 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz1_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ1 = (p->OTG_HS_DOEPTSIZ1 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz1_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ1 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz1_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ1 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz1_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ1 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL2 OTG device endpoint-2 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl2_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL2 = (p->OTG_HS_DOEPCTL2 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl2_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL2 = (p->OTG_HS_DOEPCTL2 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl2_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL2 & OTG_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl2_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL2 & OTG_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT2 OTG_HS device endpoint-2 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT2_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT2_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT2_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT2_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT2_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT2_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ2 OTG_HS device endpoint-2 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz2_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ2 = (p->OTG_HS_DOEPTSIZ2 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz2_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ2 = (p->OTG_HS_DOEPTSIZ2 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz2_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ2 = (p->OTG_HS_DOEPTSIZ2 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz2_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ2 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz2_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ2 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz2_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ2 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL3 OTG device endpoint-3 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl3_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL3 = (p->OTG_HS_DOEPCTL3 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl3_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL3 = (p->OTG_HS_DOEPCTL3 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl3_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL3 & OTG_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl3_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL3 & OTG_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT3 OTG_HS device endpoint-3 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT3_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT3_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT3_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT3_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT3_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT3_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ3 OTG_HS device endpoint-3 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz3_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ3 = (p->OTG_HS_DOEPTSIZ3 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz3_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ3 = (p->OTG_HS_DOEPTSIZ3 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz3_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ3 = (p->OTG_HS_DOEPTSIZ3 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz3_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ3 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz3_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ3 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz3_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ3 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL4 OTG device endpoint-4 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl4_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL4 = (p->OTG_HS_DOEPCTL4 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl4_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL4 = (p->OTG_HS_DOEPCTL4 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl4_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL4 & OTG_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl4_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL4 & OTG_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT4 OTG_HS device endpoint-4 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT4_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT4_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT4_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT4_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT4_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT4_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ4 OTG_HS device endpoint-4 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz4_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ4 = (p->OTG_HS_DOEPTSIZ4 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz4_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ4 = (p->OTG_HS_DOEPTSIZ4 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz4_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ4 = (p->OTG_HS_DOEPTSIZ4 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz4_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ4 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz4_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ4 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz4_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ4 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL5 OTG device endpoint-5 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl5_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL5 = (p->OTG_HS_DOEPCTL5 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl5_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL5 = (p->OTG_HS_DOEPCTL5 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl5_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL5 & OTG_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl5_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL5 & OTG_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT5 OTG_HS device endpoint-5 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT5_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT5_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT5_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT5_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT5_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT5_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ5 OTG_HS device endpoint-5 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz5_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ5 = (p->OTG_HS_DOEPTSIZ5 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz5_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ5 = (p->OTG_HS_DOEPTSIZ5 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz5_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ5 = (p->OTG_HS_DOEPTSIZ5 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz5_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ5 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz5_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ5 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz5_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ5 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL6 OTG device endpoint-6 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl6_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL6 = (p->OTG_HS_DOEPCTL6 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl6_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL6 = (p->OTG_HS_DOEPCTL6 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl6_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL6 & OTG_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl6_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL6 & OTG_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT6 OTG_HS device endpoint-6 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT6_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT6_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT6_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT6_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT6_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT6_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ6 OTG_HS device endpoint-6 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz6_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ6 = (p->OTG_HS_DOEPTSIZ6 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz6_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ6 = (p->OTG_HS_DOEPTSIZ6 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz6_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ6 = (p->OTG_HS_DOEPTSIZ6 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz6_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ6 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz6_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ6 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz6_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ6 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPCTL7 OTG device endpoint-7 control register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA = 1UL<<31, // Endpoint enable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS = 1UL<<30, // Endpoint disable
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM = 1UL<<29, // Set odd frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK = 1UL<<27, // Set NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK = 1UL<<26, // Clear NAK
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_STALL = 1UL<<21, // STALL handshake
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM = 1UL<<20, // Snoop mode
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS = 1UL<<17, // NAK status
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP = 1UL<<15, // USB active endpoint
	OTG_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_device_otg_hs_doepctl7_set_eptyp(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL7 = (p->OTG_HS_DOEPCTL7 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP) | ((val<<18) & OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP); }
inline void otg_hs_device_otg_hs_doepctl7_set_mpsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL7 = (p->OTG_HS_DOEPCTL7 & ~OTG_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ); }
inline uint32_t otg_hs_device_otg_hs_doepctl7_get_eptyp(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL7 & OTG_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP) >> 18 ; }
inline uint32_t otg_hs_device_otg_hs_doepctl7_get_mpsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL7 & OTG_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ) >> 0 ; }

// OTG_HS_DEVICE->OTG_HS_DOEPINT7 OTG_HS device endpoint-7 interrupt register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPINT7_NYET = 1UL<<14, // NYET interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT7_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG_HS_DEVICE_OTG_HS_DOEPINT7_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG_HS_DEVICE_OTG_HS_DOEPINT7_STUP = 1UL<<3, // SETUP phase done
	OTG_HS_DEVICE_OTG_HS_DOEPINT7_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG_HS_DEVICE_OTG_HS_DOEPINT7_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG_HS_DEVICE->OTG_HS_DOEPTSIZ7 OTG_HS device endpoint-7 transfer size register
enum {
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_device_otg_hs_doeptsiz7_set_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ7 = (p->OTG_HS_DOEPTSIZ7 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT) | ((val<<29) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT); }
inline void otg_hs_device_otg_hs_doeptsiz7_set_pktcnt(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ7 = (p->OTG_HS_DOEPTSIZ7 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT) | ((val<<19) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT); }
inline void otg_hs_device_otg_hs_doeptsiz7_set_xfrsiz(struct OTG_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ7 = (p->OTG_HS_DOEPTSIZ7 & ~OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ) | ((val<<0) & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ); }
inline uint32_t otg_hs_device_otg_hs_doeptsiz7_get_rxdpid_stupcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ7 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz7_get_pktcnt(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ7 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_device_otg_hs_doeptsiz7_get_xfrsiz(struct OTG_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ7 & OTG_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ) >> 0 ; }

/* USB on the go high speed */
struct OTG_HS_GLOBAL_Type {
	__IO uint32_t OTG_HS_GOTGCTL; // @0 OTG_HS control and status register
	__IO uint32_t OTG_HS_GOTGINT; // @4 OTG_HS interrupt register
	__IO uint16_t OTG_HS_GAHBCFG; // @8 OTG_HS AHB configuration register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t OTG_HS_GUSBCFG; // @12 OTG_HS USB configuration register
	__IO uint32_t OTG_HS_GRSTCTL; // @16 OTG_HS reset register
	__IO uint32_t OTG_HS_GINTSTS; // @20 OTG_HS core interrupt register
	__IO uint32_t OTG_HS_GINTMSK; // @24 OTG_HS interrupt mask register
	union {  // @28
		__I uint32_t OTG_HS_GRXSTSR_Host; // OTG_HS Receive status debug read register (host mode)
		__I uint32_t OTG_HS_GRXSTSR_Device; // OTG_HS Receive status debug read register (peripheral mode mode)
	};
	union {  // @32
		__I uint32_t OTG_HS_GRXSTSP_Host; // OTG_HS status read and pop register (host mode)
		__I uint32_t OTG_HS_GRXSTSP_Device; // OTG_HS status read and pop register (peripheral mode)
	};
	__IO uint16_t OTG_HS_GRXFSIZ; // @36 OTG_HS Receive FIFO size register
	 uint8_t RESERVED1[2]; // @38 
	union {  // @40
		__IO uint32_t OTG_HS_HNPTXFSIZ_Host; // OTG_HS nonperiodic transmit FIFO size register (host mode)
		__IO uint32_t OTG_HS_DIEPTXF0_Device; // Endpoint 0 transmit FIFO size (peripheral mode)
	};
	__I uint32_t OTG_HS_GNPTXSTS; // @44 OTG_HS nonperiodic transmit FIFO/queue status register
	 uint8_t RESERVED2[8]; // @48 
	__IO uint32_t OTG_HS_GCCFG; // @56 OTG_HS general core configuration register
	__IO uint32_t OTG_HS_CID; // @60 OTG_HS core ID register
	 uint8_t RESERVED3[20]; // @64 
	__IO uint32_t OTG_HS_GLPMCFG; // @84 OTG core LPM configuration register
	 uint8_t RESERVED4[168]; // @88 
	__IO uint32_t OTG_HS_HPTXFSIZ; // @256 OTG_HS Host periodic transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF1; // @260 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF2; // @264 OTG_HS device IN endpoint transmit FIFO size register
	 uint8_t RESERVED5[16]; // @268 
	__IO uint32_t OTG_HS_DIEPTXF3; // @284 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF4; // @288 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF5; // @292 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF6; // @296 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF7; // @300 OTG_HS device IN endpoint transmit FIFO size register
};

// OTG_HS_GLOBAL->OTG_HS_GOTGCTL OTG_HS control and status register
enum {
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD = 1UL<<19, // B-session valid
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD = 1UL<<18, // A-session valid
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT = 1UL<<17, // Long/short debounce time
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS = 1UL<<16, // Connector ID status
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN = 1UL<<12, // Embedded host enable
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN = 1UL<<11, // Device HNP enabled
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN = 1UL<<10, // Host set HNP enable
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ = 1UL<<9, // HNP request
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS = 1UL<<8, // Host negotiation success
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ = 1UL<<1, // Session request
	OTG_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS = 1UL<<0, // Session request success		
};

// OTG_HS_GLOBAL->OTG_HS_GOTGINT OTG_HS interrupt register
enum {
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG = 1UL<<20, // ID input pin changed
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE = 1UL<<19, // Debounce done
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG = 1UL<<18, // A-device timeout change
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET = 1UL<<17, // Host negotiation detected
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG = 1UL<<9, // Host negotiation success status change
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG = 1UL<<8, // Session request success status change
	OTG_HS_GLOBAL_OTG_HS_GOTGINT_SEDET = 1UL<<2, // Session end detected		
};

// OTG_HS_GLOBAL->OTG_HS_GAHBCFG OTG_HS AHB configuration register
enum {
	OTG_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL = 1UL<<8, // Periodic TxFIFO empty level
	OTG_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL = 1UL<<7, // TxFIFO empty level
	OTG_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN = 1UL<<5, // DMA enable
	OTG_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN = ((1UL<<4)-1) << 1, // Burst length/type
	OTG_HS_GLOBAL_OTG_HS_GAHBCFG_GINT = 1UL<<0, // Global interrupt mask		
};
inline void otg_hs_global_otg_hs_gahbcfg_set_hbstlen(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GAHBCFG = (p->OTG_HS_GAHBCFG & ~OTG_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN) | ((val<<1) & OTG_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN); }
inline uint32_t otg_hs_global_otg_hs_gahbcfg_get_hbstlen(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GAHBCFG & OTG_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN) >> 1 ; }

// OTG_HS_GLOBAL->OTG_HS_GUSBCFG OTG_HS USB configuration register
enum {
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD = 1UL<<30, // Forced peripheral mode
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD = 1UL<<29, // Forced host mode
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD = 1UL<<25, // ULPI interface protect disable
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI = 1UL<<24, // Indicator pass through
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI = 1UL<<23, // Indicator complement
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS = 1UL<<22, // TermSel DLine pulsing selection
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI = 1UL<<21, // ULPI external VBUS indicator
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD = 1UL<<20, // ULPI External VBUS Drive
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM = 1UL<<19, // ULPI Clock SuspendM
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR = 1UL<<18, // ULPI Auto-resume
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS = 1UL<<17, // ULPI FS/LS select
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS = 1UL<<15, // PHY Low-power clock select
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT = ((1UL<<4)-1) << 10, // USB turnaround time
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP = 1UL<<9, // HNP-capable
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP = 1UL<<8, // SRP-capable
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL = 1UL<<6, // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
	OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL = ((1UL<<3)-1) << 0, // FS timeout calibration		
};
inline void otg_hs_global_otg_hs_gusbcfg_set_trdt(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GUSBCFG = (p->OTG_HS_GUSBCFG & ~OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT) | ((val<<10) & OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT); }
inline void otg_hs_global_otg_hs_gusbcfg_set_tocal(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GUSBCFG = (p->OTG_HS_GUSBCFG & ~OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL); }
inline uint32_t otg_hs_global_otg_hs_gusbcfg_get_trdt(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GUSBCFG & OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT) >> 10 ; }
inline uint32_t otg_hs_global_otg_hs_gusbcfg_get_tocal(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GUSBCFG & OTG_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_GRSTCTL OTG_HS reset register
enum {
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL = 1UL<<31, // AHB master idle
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ = 1UL<<30, // DMA request signal enabled for USB OTG HS
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM = ((1UL<<5)-1) << 6, // TxFIFO number
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH = 1UL<<5, // TxFIFO flush
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH = 1UL<<4, // RxFIFO flush
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST = 1UL<<2, // Host frame counter reset
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST = 1UL<<1, // HCLK soft reset
	OTG_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST = 1UL<<0, // Core soft reset		
};
inline void otg_hs_global_otg_hs_grstctl_set_txfnum(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GRSTCTL = (p->OTG_HS_GRSTCTL & ~OTG_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM) | ((val<<6) & OTG_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM); }
inline uint32_t otg_hs_global_otg_hs_grstctl_get_txfnum(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRSTCTL & OTG_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM) >> 6 ; }

// OTG_HS_GLOBAL->OTG_HS_GINTSTS OTG_HS core interrupt register
enum {
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT = 1UL<<31, // Resume/remote wakeup detected interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT = 1UL<<30, // Session request/new session detected interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT = 1UL<<29, // Disconnect detected interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG = 1UL<<28, // Connector ID status change
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE = 1UL<<26, // Periodic TxFIFO empty
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_HCINT = 1UL<<25, // Host channels interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT = 1UL<<24, // Host port interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP = 1UL<<22, // Data fetch suspended
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 1UL<<21, // Incomplete periodic transfer
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR = 1UL<<20, // Incomplete isochronous IN transfer
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT = 1UL<<19, // OUT endpoint interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT = 1UL<<18, // IN endpoint interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_EOPF = 1UL<<15, // End of periodic frame interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP = 1UL<<14, // Isochronous OUT packet dropped interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE = 1UL<<13, // Enumeration done
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_USBRST = 1UL<<12, // USB reset
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP = 1UL<<11, // USB suspend
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP = 1UL<<10, // Early suspend
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF = 1UL<<7, // Global OUT NAK effective
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF = 1UL<<6, // Global IN nonperiodic NAK effective
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE = 1UL<<5, // Nonperiodic TxFIFO empty
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL = 1UL<<4, // RxFIFO nonempty
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_SOF = 1UL<<3, // Start of frame
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT = 1UL<<2, // OTG interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_MMIS = 1UL<<1, // Mode mismatch interrupt
	OTG_HS_GLOBAL_OTG_HS_GINTSTS_CMOD = 1UL<<0, // Current mode of operation		
};

// OTG_HS_GLOBAL->OTG_HS_GINTMSK OTG_HS interrupt mask register
enum {
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_WUIM = 1UL<<31, // Resume/remote wakeup detected interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM = 1UL<<30, // Session request/new session detected interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT = 1UL<<29, // Disconnect detected interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM = 1UL<<28, // Connector ID status change mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM = 1UL<<27, // LPM interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM = 1UL<<26, // Periodic TxFIFO empty mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_HCIM = 1UL<<25, // Host channels interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM = 1UL<<24, // Host port interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE = 1UL<<23, // Reset detected interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM = 1UL<<22, // Data fetch suspended mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 1UL<<21, // Incomplete periodic transfer mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM = 1UL<<20, // Incomplete isochronous IN transfer mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT = 1UL<<19, // OUT endpoints interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT = 1UL<<18, // IN endpoints interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM = 1UL<<15, // End of periodic frame interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM = 1UL<<14, // Isochronous OUT packet dropped interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM = 1UL<<13, // Enumeration done mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_USBRST = 1UL<<12, // USB reset mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM = 1UL<<11, // USB suspend mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM = 1UL<<10, // Early suspend mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM = 1UL<<7, // Global OUT NAK effective mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM = 1UL<<6, // Global nonperiodic IN NAK effective mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM = 1UL<<5, // Nonperiodic TxFIFO empty mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM = 1UL<<4, // Receive FIFO nonempty mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_SOFM = 1UL<<3, // Start of frame mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT = 1UL<<2, // OTG interrupt mask
	OTG_HS_GLOBAL_OTG_HS_GINTMSK_MMISM = 1UL<<1, // Mode mismatch interrupt mask		
};

// OTG_HS_GLOBAL->OTG_HS_GRXSTSR_Host OTG_HS Receive status debug read register (host mode)
enum {
	OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS = ((1UL<<4)-1) << 17, // Packet status
	OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID = ((1UL<<2)-1) << 15, // Data PID
	OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT = ((1UL<<11)-1) << 4, // Byte count
	OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM = ((1UL<<4)-1) << 0, // Channel number		
};
inline uint32_t otg_hs_global_otg_hs_grxstsr_host_get_pktsts(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS) >> 17 ; }
inline uint32_t otg_hs_global_otg_hs_grxstsr_host_get_dpid(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID) >> 15 ; }
inline uint32_t otg_hs_global_otg_hs_grxstsr_host_get_bcnt(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT) >> 4 ; }
inline uint32_t otg_hs_global_otg_hs_grxstsr_host_get_chnum(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_GRXSTSP_Host OTG_HS status read and pop register (host mode)
enum {
	OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS = ((1UL<<4)-1) << 17, // Packet status
	OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID = ((1UL<<2)-1) << 15, // Data PID
	OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT = ((1UL<<11)-1) << 4, // Byte count
	OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM = ((1UL<<4)-1) << 0, // Channel number		
};
inline uint32_t otg_hs_global_otg_hs_grxstsp_host_get_pktsts(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS) >> 17 ; }
inline uint32_t otg_hs_global_otg_hs_grxstsp_host_get_dpid(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID) >> 15 ; }
inline uint32_t otg_hs_global_otg_hs_grxstsp_host_get_bcnt(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT) >> 4 ; }
inline uint32_t otg_hs_global_otg_hs_grxstsp_host_get_chnum(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_HNPTXFSIZ_Host OTG_HS nonperiodic transmit FIFO size register (host mode)
enum {
	OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD = ((1UL<<16)-1) << 16, // Nonperiodic TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA = ((1UL<<16)-1) << 0, // Nonperiodic transmit RAM start address		
};
inline void otg_hs_global_otg_hs_hnptxfsiz_host_set_nptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HNPTXFSIZ_Host = (p->OTG_HS_HNPTXFSIZ_Host & ~OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD); }
inline void otg_hs_global_otg_hs_hnptxfsiz_host_set_nptxfsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HNPTXFSIZ_Host = (p->OTG_HS_HNPTXFSIZ_Host & ~OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA); }
inline uint32_t otg_hs_global_otg_hs_hnptxfsiz_host_get_nptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_HNPTXFSIZ_Host & OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_hnptxfsiz_host_get_nptxfsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_HNPTXFSIZ_Host & OTG_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_GNPTXSTS OTG_HS nonperiodic transmit FIFO/queue status register
enum {
	OTG_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP = ((1UL<<7)-1) << 24, // Top of the nonperiodic transmit request queue
	OTG_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV = ((1UL<<8)-1) << 16, // Nonperiodic transmit request queue space available
	OTG_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV = ((1UL<<16)-1) << 0, // Nonperiodic TxFIFO space available		
};
inline uint32_t otg_hs_global_otg_hs_gnptxsts_get_nptxqtop(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GNPTXSTS & OTG_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP) >> 24 ; }
inline uint32_t otg_hs_global_otg_hs_gnptxsts_get_nptqxsav(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GNPTXSTS & OTG_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_gnptxsts_get_nptxfsav(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GNPTXSTS & OTG_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_GCCFG OTG_HS general core configuration register
enum {
	OTG_HS_GLOBAL_OTG_HS_GCCFG_VBDEN = 1UL<<21, // USB VBUS detection enable
	OTG_HS_GLOBAL_OTG_HS_GCCFG_SDEN = 1UL<<20, // Secondary detection (SD) mode enable
	OTG_HS_GLOBAL_OTG_HS_GCCFG_PDEN = 1UL<<19, // Primary detection (PD) mode enable
	OTG_HS_GLOBAL_OTG_HS_GCCFG_DCDEN = 1UL<<18, // Data contact detection (DCD) mode enable
	OTG_HS_GLOBAL_OTG_HS_GCCFG_BCDEN = 1UL<<17, // Battery charging detector (BCD) enable
	OTG_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN = 1UL<<16, // Power down
	OTG_HS_GLOBAL_OTG_HS_GCCFG_PS2DET = 1UL<<3, // DM pull-up detection status
	OTG_HS_GLOBAL_OTG_HS_GCCFG_SDET = 1UL<<2, // Secondary detection (SD) status
	OTG_HS_GLOBAL_OTG_HS_GCCFG_PDET = 1UL<<1, // Primary detection (PD) status
	OTG_HS_GLOBAL_OTG_HS_GCCFG_DCDET = 1UL<<0, // Data contact detection (DCD) status		
};

// OTG_HS_GLOBAL->OTG_HS_GLPMCFG OTG core LPM configuration register
enum {
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL = 1UL<<28, // Enable best effort service latency
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS = ((1UL<<3)-1) << 25, // LPM retry count status
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM = 1UL<<24, // Send LPM transaction
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT = ((1UL<<3)-1) << 21, // LPM retry count
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX = ((1UL<<4)-1) << 17, // LPM Channel Index
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK = 1UL<<16, // Sleep State Resume OK
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS = 1UL<<15, // Port sleep status
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST = ((1UL<<2)-1) << 13, // LPM response
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN = 1UL<<12, // L1 deep sleep enable
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS = ((1UL<<4)-1) << 8, // BESL threshold
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN = 1UL<<7, // L1 Shallow Sleep enable
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE = 1UL<<6, // bRemoteWake value
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESL = ((1UL<<4)-1) << 2, // Best effort service latency
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK = 1UL<<1, // LPM token acknowledge enable
	OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN = 1UL<<0, // LPM support enable		
};
inline void otg_hs_global_otg_hs_glpmcfg_set_lpmrcntsts(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS) | ((val<<25) & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS); }
inline void otg_hs_global_otg_hs_glpmcfg_set_lpmrcnt(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT) | ((val<<21) & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT); }
inline void otg_hs_global_otg_hs_glpmcfg_set_lpmchidx(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX) | ((val<<17) & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX); }
inline void otg_hs_global_otg_hs_glpmcfg_set_lpmrst(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST) | ((val<<13) & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST); }
inline void otg_hs_global_otg_hs_glpmcfg_set_beslthrs(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS) | ((val<<8) & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS); }
inline void otg_hs_global_otg_hs_glpmcfg_set_besl(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESL) | ((val<<2) & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESL); }
inline uint32_t otg_hs_global_otg_hs_glpmcfg_get_lpmrcntsts(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS) >> 25 ; }
inline uint32_t otg_hs_global_otg_hs_glpmcfg_get_lpmrcnt(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT) >> 21 ; }
inline uint32_t otg_hs_global_otg_hs_glpmcfg_get_lpmchidx(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX) >> 17 ; }
inline uint32_t otg_hs_global_otg_hs_glpmcfg_get_lpmrst(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST) >> 13 ; }
inline uint32_t otg_hs_global_otg_hs_glpmcfg_get_beslthrs(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS) >> 8 ; }
inline uint32_t otg_hs_global_otg_hs_glpmcfg_get_besl(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG_HS_GLOBAL_OTG_HS_GLPMCFG_BESL) >> 2 ; }

// OTG_HS_GLOBAL->OTG_HS_HPTXFSIZ OTG_HS Host periodic transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD = ((1UL<<16)-1) << 16, // Host periodic TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA = ((1UL<<16)-1) << 0, // Host periodic TxFIFO start address		
};
inline void otg_hs_global_otg_hs_hptxfsiz_set_ptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HPTXFSIZ = (p->OTG_HS_HPTXFSIZ & ~OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD); }
inline void otg_hs_global_otg_hs_hptxfsiz_set_ptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HPTXFSIZ = (p->OTG_HS_HPTXFSIZ & ~OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA); }
inline uint32_t otg_hs_global_otg_hs_hptxfsiz_get_ptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_HPTXFSIZ & OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_hptxfsiz_get_ptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_HPTXFSIZ & OTG_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF1 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf1_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF1 = (p->OTG_HS_DIEPTXF1 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf1_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF1 = (p->OTG_HS_DIEPTXF1 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf1_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF1 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf1_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF1 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF2 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf2_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF2 = (p->OTG_HS_DIEPTXF2 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf2_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF2 = (p->OTG_HS_DIEPTXF2 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf2_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF2 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf2_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF2 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF3 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf3_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF3 = (p->OTG_HS_DIEPTXF3 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf3_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF3 = (p->OTG_HS_DIEPTXF3 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf3_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF3 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf3_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF3 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF4 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf4_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF4 = (p->OTG_HS_DIEPTXF4 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf4_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF4 = (p->OTG_HS_DIEPTXF4 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf4_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF4 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf4_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF4 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF5 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf5_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF5 = (p->OTG_HS_DIEPTXF5 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf5_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF5 = (p->OTG_HS_DIEPTXF5 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf5_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF5 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf5_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF5 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF6 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf6_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF6 = (p->OTG_HS_DIEPTXF6 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf6_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF6 = (p->OTG_HS_DIEPTXF6 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf6_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF6 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf6_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF6 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA) >> 0 ; }

// OTG_HS_GLOBAL->OTG_HS_DIEPTXF7 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg_hs_global_otg_hs_dieptxf7_set_ineptxfd(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF7 = (p->OTG_HS_DIEPTXF7 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD) | ((val<<16) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD); }
inline void otg_hs_global_otg_hs_dieptxf7_set_ineptxsa(struct OTG_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF7 = (p->OTG_HS_DIEPTXF7 & ~OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA) | ((val<<0) & OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA); }
inline uint32_t otg_hs_global_otg_hs_dieptxf7_get_ineptxfd(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF7 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD) >> 16 ; }
inline uint32_t otg_hs_global_otg_hs_dieptxf7_get_ineptxsa(struct OTG_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF7 & OTG_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA) >> 0 ; }

/* USB on the go high speed */
struct OTG_HS_HOST_Type {
	__IO uint8_t OTG_HS_HCFG; // @0 OTG_HS host configuration register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t OTG_HS_HFIR; // @4 OTG_HS Host frame interval register
	 uint8_t RESERVED1[2]; // @6 
	__I uint32_t OTG_HS_HFNUM; // @8 OTG_HS host frame number/frame time remaining register
	 uint8_t RESERVED2[4]; // @12 
	__IO uint32_t OTG_HS_HPTXSTS; // @16 OTG_HS_Host periodic transmit FIFO/queue status register
	__I uint16_t OTG_HS_HAINT; // @20 OTG_HS Host all channels interrupt register
	 uint8_t RESERVED3[2]; // @22 
	__IO uint16_t OTG_HS_HAINTMSK; // @24 OTG_HS host all channels interrupt mask register
	 uint8_t RESERVED4[38]; // @26 
	__IO uint32_t OTG_HS_HPRT; // @64 OTG_HS host port control and status register
	 uint8_t RESERVED5[188]; // @68 
	__IO uint32_t OTG_HS_HCCHAR0; // @256 OTG_HS host channel-0 characteristics register
	__IO uint32_t OTG_HS_HCSPLT0; // @260 OTG_HS host channel-0 split control register
	__IO uint16_t OTG_HS_HCINT0; // @264 OTG_HS host channel-11 interrupt register
	 uint8_t RESERVED6[2]; // @266 
	__IO uint16_t OTG_HS_HCINTMSK0; // @268 OTG_HS host channel-11 interrupt mask register
	 uint8_t RESERVED7[2]; // @270 
	__IO uint32_t OTG_HS_HCTSIZ0; // @272 OTG_HS host channel-11 transfer size register
	__IO uint32_t OTG_HS_HCDMA0; // @276 OTG_HS host channel-0 DMA address register
	 uint8_t RESERVED8[8]; // @280 
	__IO uint32_t OTG_HS_HCCHAR1; // @288 OTG_HS host channel-1 characteristics register
	__IO uint32_t OTG_HS_HCSPLT1; // @292 OTG_HS host channel-1 split control register
	__IO uint16_t OTG_HS_HCINT1; // @296 OTG_HS host channel-1 interrupt register
	 uint8_t RESERVED9[2]; // @298 
	__IO uint16_t OTG_HS_HCINTMSK1; // @300 OTG_HS host channel-1 interrupt mask register
	 uint8_t RESERVED10[2]; // @302 
	__IO uint32_t OTG_HS_HCTSIZ1; // @304 OTG_HS host channel-1 transfer size register
	__IO uint32_t OTG_HS_HCDMA1; // @308 OTG_HS host channel-1 DMA address register
	 uint8_t RESERVED11[8]; // @312 
	__IO uint32_t OTG_HS_HCCHAR2; // @320 OTG_HS host channel-2 characteristics register
	__IO uint32_t OTG_HS_HCSPLT2; // @324 OTG_HS host channel-2 split control register
	__IO uint16_t OTG_HS_HCINT2; // @328 OTG_HS host channel-2 interrupt register
	 uint8_t RESERVED12[2]; // @330 
	__IO uint16_t OTG_HS_HCINTMSK2; // @332 OTG_HS host channel-2 interrupt mask register
	 uint8_t RESERVED13[2]; // @334 
	__IO uint32_t OTG_HS_HCTSIZ2; // @336 OTG_HS host channel-2 transfer size register
	__IO uint32_t OTG_HS_HCDMA2; // @340 OTG_HS host channel-2 DMA address register
	 uint8_t RESERVED14[8]; // @344 
	__IO uint32_t OTG_HS_HCCHAR3; // @352 OTG_HS host channel-3 characteristics register
	__IO uint32_t OTG_HS_HCSPLT3; // @356 OTG_HS host channel-3 split control register
	__IO uint16_t OTG_HS_HCINT3; // @360 OTG_HS host channel-3 interrupt register
	 uint8_t RESERVED15[2]; // @362 
	__IO uint16_t OTG_HS_HCINTMSK3; // @364 OTG_HS host channel-3 interrupt mask register
	 uint8_t RESERVED16[2]; // @366 
	__IO uint32_t OTG_HS_HCTSIZ3; // @368 OTG_HS host channel-3 transfer size register
	__IO uint32_t OTG_HS_HCDMA3; // @372 OTG_HS host channel-3 DMA address register
	 uint8_t RESERVED17[8]; // @376 
	__IO uint32_t OTG_HS_HCCHAR4; // @384 OTG_HS host channel-4 characteristics register
	__IO uint32_t OTG_HS_HCSPLT4; // @388 OTG_HS host channel-4 split control register
	__IO uint16_t OTG_HS_HCINT4; // @392 OTG_HS host channel-4 interrupt register
	 uint8_t RESERVED18[2]; // @394 
	__IO uint16_t OTG_HS_HCINTMSK4; // @396 OTG_HS host channel-4 interrupt mask register
	 uint8_t RESERVED19[2]; // @398 
	__IO uint32_t OTG_HS_HCTSIZ4; // @400 OTG_HS host channel-4 transfer size register
	__IO uint32_t OTG_HS_HCDMA4; // @404 OTG_HS host channel-4 DMA address register
	 uint8_t RESERVED20[8]; // @408 
	__IO uint32_t OTG_HS_HCCHAR5; // @416 OTG_HS host channel-5 characteristics register
	__IO uint32_t OTG_HS_HCSPLT5; // @420 OTG_HS host channel-5 split control register
	__IO uint16_t OTG_HS_HCINT5; // @424 OTG_HS host channel-5 interrupt register
	 uint8_t RESERVED21[2]; // @426 
	__IO uint16_t OTG_HS_HCINTMSK5; // @428 OTG_HS host channel-5 interrupt mask register
	 uint8_t RESERVED22[2]; // @430 
	__IO uint32_t OTG_HS_HCTSIZ5; // @432 OTG_HS host channel-5 transfer size register
	__IO uint32_t OTG_HS_HCDMA5; // @436 OTG_HS host channel-5 DMA address register
	 uint8_t RESERVED23[8]; // @440 
	__IO uint32_t OTG_HS_HCCHAR6; // @448 OTG_HS host channel-6 characteristics register
	__IO uint32_t OTG_HS_HCSPLT6; // @452 OTG_HS host channel-6 split control register
	__IO uint16_t OTG_HS_HCINT6; // @456 OTG_HS host channel-6 interrupt register
	 uint8_t RESERVED24[2]; // @458 
	__IO uint16_t OTG_HS_HCINTMSK6; // @460 OTG_HS host channel-6 interrupt mask register
	 uint8_t RESERVED25[2]; // @462 
	__IO uint32_t OTG_HS_HCTSIZ6; // @464 OTG_HS host channel-6 transfer size register
	__IO uint32_t OTG_HS_HCDMA6; // @468 OTG_HS host channel-6 DMA address register
	 uint8_t RESERVED26[8]; // @472 
	__IO uint32_t OTG_HS_HCCHAR7; // @480 OTG_HS host channel-7 characteristics register
	__IO uint32_t OTG_HS_HCSPLT7; // @484 OTG_HS host channel-7 split control register
	__IO uint16_t OTG_HS_HCINT7; // @488 OTG_HS host channel-7 interrupt register
	 uint8_t RESERVED27[2]; // @490 
	__IO uint16_t OTG_HS_HCINTMSK7; // @492 OTG_HS host channel-7 interrupt mask register
	 uint8_t RESERVED28[2]; // @494 
	__IO uint32_t OTG_HS_HCTSIZ7; // @496 OTG_HS host channel-7 transfer size register
	__IO uint32_t OTG_HS_HCDMA7; // @500 OTG_HS host channel-7 DMA address register
	 uint8_t RESERVED29[8]; // @504 
	__IO uint32_t OTG_HS_HCCHAR8; // @512 OTG_HS host channel-8 characteristics register
	__IO uint32_t OTG_HS_HCSPLT8; // @516 OTG_HS host channel-8 split control register
	__IO uint16_t OTG_HS_HCINT8; // @520 OTG_HS host channel-8 interrupt register
	 uint8_t RESERVED30[2]; // @522 
	__IO uint16_t OTG_HS_HCINTMSK8; // @524 OTG_HS host channel-8 interrupt mask register
	 uint8_t RESERVED31[2]; // @526 
	__IO uint32_t OTG_HS_HCTSIZ8; // @528 OTG_HS host channel-8 transfer size register
	__IO uint32_t OTG_HS_HCDMA8; // @532 OTG_HS host channel-8 DMA address register
	 uint8_t RESERVED32[8]; // @536 
	__IO uint32_t OTG_HS_HCCHAR9; // @544 OTG_HS host channel-9 characteristics register
	__IO uint32_t OTG_HS_HCSPLT9; // @548 OTG_HS host channel-9 split control register
	__IO uint16_t OTG_HS_HCINT9; // @552 OTG_HS host channel-9 interrupt register
	 uint8_t RESERVED33[2]; // @554 
	__IO uint16_t OTG_HS_HCINTMSK9; // @556 OTG_HS host channel-9 interrupt mask register
	 uint8_t RESERVED34[2]; // @558 
	__IO uint32_t OTG_HS_HCTSIZ9; // @560 OTG_HS host channel-9 transfer size register
	__IO uint32_t OTG_HS_HCDMA9; // @564 OTG_HS host channel-9 DMA address register
	 uint8_t RESERVED35[8]; // @568 
	__IO uint32_t OTG_HS_HCCHAR10; // @576 OTG_HS host channel-10 characteristics register
	__IO uint32_t OTG_HS_HCSPLT10; // @580 OTG_HS host channel-10 split control register
	__IO uint16_t OTG_HS_HCINT10; // @584 OTG_HS host channel-10 interrupt register
	 uint8_t RESERVED36[2]; // @586 
	__IO uint16_t OTG_HS_HCINTMSK10; // @588 OTG_HS host channel-10 interrupt mask register
	 uint8_t RESERVED37[2]; // @590 
	__IO uint32_t OTG_HS_HCTSIZ10; // @592 OTG_HS host channel-10 transfer size register
	__IO uint32_t OTG_HS_HCDMA10; // @596 OTG_HS host channel-10 DMA address register
	 uint8_t RESERVED38[8]; // @600 
	__IO uint32_t OTG_HS_HCCHAR11; // @608 OTG_HS host channel-11 characteristics register
	__IO uint32_t OTG_HS_HCSPLT11; // @612 OTG_HS host channel-11 split control register
	__IO uint16_t OTG_HS_HCINT11; // @616 OTG_HS host channel-11 interrupt register
	 uint8_t RESERVED39[2]; // @618 
	__IO uint16_t OTG_HS_HCINTMSK11; // @620 OTG_HS host channel-11 interrupt mask register
	 uint8_t RESERVED40[2]; // @622 
	__IO uint32_t OTG_HS_HCTSIZ11; // @624 OTG_HS host channel-11 transfer size register
	__IO uint32_t OTG_HS_HCDMA11; // @628 OTG_HS host channel-11 DMA address register
	__IO uint32_t OTG_HS_HCCHAR12; // @632 OTG_HS host channel-12 characteristics register
	__IO uint32_t OTG_HS_HCSPLT12; // @636 OTG_HS host channel-12 split control register
	__IO uint16_t OTG_HS_HCINT12; // @640 OTG_HS host channel-12 interrupt register
	 uint8_t RESERVED41[2]; // @642 
	__IO uint16_t OTG_HS_HCINTMSK12; // @644 OTG_HS host channel-12 interrupt mask register
	 uint8_t RESERVED42[2]; // @646 
	__IO uint32_t OTG_HS_HCTSIZ12; // @648 OTG_HS host channel-12 transfer size register
	__IO uint32_t OTG_HS_HCDMA12; // @652 OTG_HS host channel-12 DMA address register
	__IO uint32_t OTG_HS_HCCHAR13; // @656 OTG_HS host channel-13 characteristics register
	__IO uint32_t OTG_HS_HCSPLT13; // @660 OTG_HS host channel-13 split control register
	__IO uint16_t OTG_HS_HCINT13; // @664 OTG_HS host channel-13 interrupt register
	 uint8_t RESERVED43[2]; // @666 
	__IO uint16_t OTG_HS_HCINTMSK13; // @668 OTG_HS host channel-13 interrupt mask register
	 uint8_t RESERVED44[2]; // @670 
	__IO uint32_t OTG_HS_HCTSIZ13; // @672 OTG_HS host channel-13 transfer size register
	__IO uint32_t OTG_HS_HCDMA13; // @676 OTG_HS host channel-13 DMA address register
	__IO uint32_t OTG_HS_HCCHAR14; // @680 OTG_HS host channel-14 characteristics register
	__IO uint32_t OTG_HS_HCSPLT14; // @684 OTG_HS host channel-14 split control register
	__IO uint16_t OTG_HS_HCINT14; // @688 OTG_HS host channel-14 interrupt register
	 uint8_t RESERVED45[2]; // @690 
	__IO uint16_t OTG_HS_HCINTMSK14; // @692 OTG_HS host channel-14 interrupt mask register
	 uint8_t RESERVED46[2]; // @694 
	__IO uint32_t OTG_HS_HCTSIZ14; // @696 OTG_HS host channel-14 transfer size register
	__IO uint32_t OTG_HS_HCDMA14; // @700 OTG_HS host channel-14 DMA address register
	__IO uint32_t OTG_HS_HCCHAR15; // @704 OTG_HS host channel-15 characteristics register
	__IO uint32_t OTG_HS_HCSPLT15; // @708 OTG_HS host channel-15 split control register
	__IO uint16_t OTG_HS_HCINT15; // @712 OTG_HS host channel-15 interrupt register
	 uint8_t RESERVED47[2]; // @714 
	__IO uint16_t OTG_HS_HCINTMSK15; // @716 OTG_HS host channel-15 interrupt mask register
	 uint8_t RESERVED48[2]; // @718 
	__IO uint32_t OTG_HS_HCTSIZ15; // @720 OTG_HS host channel-15 transfer size register
	__IO uint32_t OTG_HS_HCDMA15; // @724 OTG_HS host channel-15 DMA address register
};

// OTG_HS_HOST->OTG_HS_HCFG OTG_HS host configuration register
enum {
	OTG_HS_HOST_OTG_HS_HCFG_FSLSS = 1UL<<2, // FS- and LS-only support
	OTG_HS_HOST_OTG_HS_HCFG_FSLSPCS = ((1UL<<2)-1) << 0, // FS/LS PHY clock select		
};
inline void otg_hs_host_otg_hs_hcfg_set_fslspcs(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCFG = (p->OTG_HS_HCFG & ~OTG_HS_HOST_OTG_HS_HCFG_FSLSPCS) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCFG_FSLSPCS); }
inline uint32_t otg_hs_host_otg_hs_hcfg_get_fslspcs(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCFG & OTG_HS_HOST_OTG_HS_HCFG_FSLSPCS) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HFNUM OTG_HS host frame number/frame time remaining register
enum {
	OTG_HS_HOST_OTG_HS_HFNUM_FTREM = ((1UL<<16)-1) << 16, // Frame time remaining
	OTG_HS_HOST_OTG_HS_HFNUM_FRNUM = ((1UL<<16)-1) << 0, // Frame number		
};
inline uint32_t otg_hs_host_otg_hs_hfnum_get_ftrem(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HFNUM & OTG_HS_HOST_OTG_HS_HFNUM_FTREM) >> 16 ; }
inline uint32_t otg_hs_host_otg_hs_hfnum_get_frnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HFNUM & OTG_HS_HOST_OTG_HS_HFNUM_FRNUM) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HPTXSTS OTG_HS_Host periodic transmit FIFO/queue status register
enum {
	OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP = ((1UL<<8)-1) << 24, // Top of the periodic transmit request queue
	OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV = ((1UL<<8)-1) << 16, // Periodic transmit request queue space available
	OTG_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL = ((1UL<<16)-1) << 0, // Periodic transmit data FIFO space available		
};
inline void otg_hs_host_otg_hs_hptxsts_set_ptxqtop(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPTXSTS = (p->OTG_HS_HPTXSTS & ~OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP) | ((val<<24) & OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP); }
inline void otg_hs_host_otg_hs_hptxsts_set_ptxqsav(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPTXSTS = (p->OTG_HS_HPTXSTS & ~OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV) | ((val<<16) & OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV); }
inline void otg_hs_host_otg_hs_hptxsts_set_ptxfsavl(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPTXSTS = (p->OTG_HS_HPTXSTS & ~OTG_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL) | ((val<<0) & OTG_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL); }
inline uint32_t otg_hs_host_otg_hs_hptxsts_get_ptxqtop(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HPTXSTS & OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP) >> 24 ; }
inline uint32_t otg_hs_host_otg_hs_hptxsts_get_ptxqsav(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HPTXSTS & OTG_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV) >> 16 ; }
inline uint32_t otg_hs_host_otg_hs_hptxsts_get_ptxfsavl(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HPTXSTS & OTG_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HPRT OTG_HS host port control and status register
enum {
	OTG_HS_HOST_OTG_HS_HPRT_PSPD = ((1UL<<2)-1) << 17, // Port speed
	OTG_HS_HOST_OTG_HS_HPRT_PTCTL = ((1UL<<4)-1) << 13, // Port test control
	OTG_HS_HOST_OTG_HS_HPRT_PPWR = 1UL<<12, // Port power
	OTG_HS_HOST_OTG_HS_HPRT_PLSTS = ((1UL<<2)-1) << 10, // Port line status
	OTG_HS_HOST_OTG_HS_HPRT_PRST = 1UL<<8, // Port reset
	OTG_HS_HOST_OTG_HS_HPRT_PSUSP = 1UL<<7, // Port suspend
	OTG_HS_HOST_OTG_HS_HPRT_PRES = 1UL<<6, // Port resume
	OTG_HS_HOST_OTG_HS_HPRT_POCCHNG = 1UL<<5, // Port overcurrent change
	OTG_HS_HOST_OTG_HS_HPRT_POCA = 1UL<<4, // Port overcurrent active
	OTG_HS_HOST_OTG_HS_HPRT_PENCHNG = 1UL<<3, // Port enable/disable change
	OTG_HS_HOST_OTG_HS_HPRT_PENA = 1UL<<2, // Port enable
	OTG_HS_HOST_OTG_HS_HPRT_PCDET = 1UL<<1, // Port connect detected
	OTG_HS_HOST_OTG_HS_HPRT_PCSTS = 1UL<<0, // Port connect status		
};
inline void otg_hs_host_otg_hs_hprt_set_pspd(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPRT = (p->OTG_HS_HPRT & ~OTG_HS_HOST_OTG_HS_HPRT_PSPD) | ((val<<17) & OTG_HS_HOST_OTG_HS_HPRT_PSPD); }
inline void otg_hs_host_otg_hs_hprt_set_ptctl(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPRT = (p->OTG_HS_HPRT & ~OTG_HS_HOST_OTG_HS_HPRT_PTCTL) | ((val<<13) & OTG_HS_HOST_OTG_HS_HPRT_PTCTL); }
inline void otg_hs_host_otg_hs_hprt_set_plsts(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPRT = (p->OTG_HS_HPRT & ~OTG_HS_HOST_OTG_HS_HPRT_PLSTS) | ((val<<10) & OTG_HS_HOST_OTG_HS_HPRT_PLSTS); }
inline uint32_t otg_hs_host_otg_hs_hprt_get_pspd(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HPRT & OTG_HS_HOST_OTG_HS_HPRT_PSPD) >> 17 ; }
inline uint32_t otg_hs_host_otg_hs_hprt_get_ptctl(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HPRT & OTG_HS_HOST_OTG_HS_HPRT_PTCTL) >> 13 ; }
inline uint32_t otg_hs_host_otg_hs_hprt_get_plsts(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HPRT & OTG_HS_HOST_OTG_HS_HPRT_PLSTS) >> 10 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR0 OTG_HS host channel-0 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR0_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR0_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR0_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR0_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR0_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR0_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR0_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR0_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR0_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar0_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG_HS_HOST_OTG_HS_HCCHAR0_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR0_DAD); }
inline void otg_hs_host_otg_hs_hcchar0_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG_HS_HOST_OTG_HS_HCCHAR0_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR0_MC); }
inline void otg_hs_host_otg_hs_hcchar0_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG_HS_HOST_OTG_HS_HCCHAR0_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR0_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar0_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG_HS_HOST_OTG_HS_HCCHAR0_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR0_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar0_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG_HS_HOST_OTG_HS_HCCHAR0_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR0_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar0_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG_HS_HOST_OTG_HS_HCCHAR0_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar0_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG_HS_HOST_OTG_HS_HCCHAR0_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar0_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG_HS_HOST_OTG_HS_HCCHAR0_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar0_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG_HS_HOST_OTG_HS_HCCHAR0_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar0_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG_HS_HOST_OTG_HS_HCCHAR0_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT0 OTG_HS host channel-0 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT0_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT0_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT0_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT0_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT0_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt0_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT0 = (p->OTG_HS_HCSPLT0 & ~OTG_HS_HOST_OTG_HS_HCSPLT0_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT0_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt0_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT0 = (p->OTG_HS_HCSPLT0 & ~OTG_HS_HOST_OTG_HS_HCSPLT0_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT0_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt0_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT0 = (p->OTG_HS_HCSPLT0 & ~OTG_HS_HOST_OTG_HS_HCSPLT0_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT0_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt0_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT0 & OTG_HS_HOST_OTG_HS_HCSPLT0_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt0_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT0 & OTG_HS_HOST_OTG_HS_HCSPLT0_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt0_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT0 & OTG_HS_HOST_OTG_HS_HCSPLT0_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT0 OTG_HS host channel-11 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT0_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT0_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT0_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT0_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT0_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT0_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT0_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT0_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT0_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT0_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT0_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK0 OTG_HS host channel-11 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK0_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK0_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK0_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ0 OTG_HS host channel-11 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ0_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz0_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ0 = (p->OTG_HS_HCTSIZ0 & ~OTG_HS_HOST_OTG_HS_HCTSIZ0_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ0_DPID); }
inline void otg_hs_host_otg_hs_hctsiz0_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ0 = (p->OTG_HS_HCTSIZ0 & ~OTG_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz0_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ0 = (p->OTG_HS_HCTSIZ0 & ~OTG_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz0_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ0 & OTG_HS_HOST_OTG_HS_HCTSIZ0_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz0_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ0 & OTG_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz0_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ0 & OTG_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR1 OTG_HS host channel-1 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR1_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR1_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR1_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR1_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR1_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR1_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR1_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR1_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar1_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG_HS_HOST_OTG_HS_HCCHAR1_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR1_DAD); }
inline void otg_hs_host_otg_hs_hcchar1_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG_HS_HOST_OTG_HS_HCCHAR1_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR1_MC); }
inline void otg_hs_host_otg_hs_hcchar1_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG_HS_HOST_OTG_HS_HCCHAR1_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR1_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar1_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG_HS_HOST_OTG_HS_HCCHAR1_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR1_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar1_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG_HS_HOST_OTG_HS_HCCHAR1_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR1_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar1_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG_HS_HOST_OTG_HS_HCCHAR1_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar1_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG_HS_HOST_OTG_HS_HCCHAR1_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar1_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG_HS_HOST_OTG_HS_HCCHAR1_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar1_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG_HS_HOST_OTG_HS_HCCHAR1_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar1_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG_HS_HOST_OTG_HS_HCCHAR1_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT1 OTG_HS host channel-1 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT1_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT1_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT1_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT1_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT1_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt1_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT1 = (p->OTG_HS_HCSPLT1 & ~OTG_HS_HOST_OTG_HS_HCSPLT1_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT1_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt1_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT1 = (p->OTG_HS_HCSPLT1 & ~OTG_HS_HOST_OTG_HS_HCSPLT1_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT1_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt1_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT1 = (p->OTG_HS_HCSPLT1 & ~OTG_HS_HOST_OTG_HS_HCSPLT1_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT1_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt1_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT1 & OTG_HS_HOST_OTG_HS_HCSPLT1_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt1_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT1 & OTG_HS_HOST_OTG_HS_HCSPLT1_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt1_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT1 & OTG_HS_HOST_OTG_HS_HCSPLT1_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT1 OTG_HS host channel-1 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT1_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT1_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT1_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT1_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT1_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT1_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT1_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT1_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT1_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT1_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT1_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK1 OTG_HS host channel-1 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK1_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK1_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK1_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ1 OTG_HS host channel-1 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ1_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz1_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ1 = (p->OTG_HS_HCTSIZ1 & ~OTG_HS_HOST_OTG_HS_HCTSIZ1_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ1_DPID); }
inline void otg_hs_host_otg_hs_hctsiz1_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ1 = (p->OTG_HS_HCTSIZ1 & ~OTG_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz1_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ1 = (p->OTG_HS_HCTSIZ1 & ~OTG_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz1_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ1 & OTG_HS_HOST_OTG_HS_HCTSIZ1_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz1_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ1 & OTG_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz1_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ1 & OTG_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR2 OTG_HS host channel-2 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR2_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR2_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR2_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR2_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR2_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR2_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR2_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR2_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar2_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG_HS_HOST_OTG_HS_HCCHAR2_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR2_DAD); }
inline void otg_hs_host_otg_hs_hcchar2_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG_HS_HOST_OTG_HS_HCCHAR2_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR2_MC); }
inline void otg_hs_host_otg_hs_hcchar2_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG_HS_HOST_OTG_HS_HCCHAR2_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR2_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar2_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG_HS_HOST_OTG_HS_HCCHAR2_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR2_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar2_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG_HS_HOST_OTG_HS_HCCHAR2_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR2_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar2_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG_HS_HOST_OTG_HS_HCCHAR2_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar2_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG_HS_HOST_OTG_HS_HCCHAR2_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar2_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG_HS_HOST_OTG_HS_HCCHAR2_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar2_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG_HS_HOST_OTG_HS_HCCHAR2_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar2_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG_HS_HOST_OTG_HS_HCCHAR2_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT2 OTG_HS host channel-2 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT2_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT2_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT2_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT2_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT2_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt2_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT2 = (p->OTG_HS_HCSPLT2 & ~OTG_HS_HOST_OTG_HS_HCSPLT2_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT2_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt2_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT2 = (p->OTG_HS_HCSPLT2 & ~OTG_HS_HOST_OTG_HS_HCSPLT2_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT2_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt2_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT2 = (p->OTG_HS_HCSPLT2 & ~OTG_HS_HOST_OTG_HS_HCSPLT2_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT2_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt2_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT2 & OTG_HS_HOST_OTG_HS_HCSPLT2_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt2_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT2 & OTG_HS_HOST_OTG_HS_HCSPLT2_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt2_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT2 & OTG_HS_HOST_OTG_HS_HCSPLT2_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT2 OTG_HS host channel-2 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT2_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT2_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT2_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT2_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT2_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT2_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT2_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT2_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT2_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT2_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT2_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK2 OTG_HS host channel-2 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK2_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK2_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK2_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ2 OTG_HS host channel-2 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ2_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz2_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ2 = (p->OTG_HS_HCTSIZ2 & ~OTG_HS_HOST_OTG_HS_HCTSIZ2_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ2_DPID); }
inline void otg_hs_host_otg_hs_hctsiz2_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ2 = (p->OTG_HS_HCTSIZ2 & ~OTG_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz2_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ2 = (p->OTG_HS_HCTSIZ2 & ~OTG_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz2_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ2 & OTG_HS_HOST_OTG_HS_HCTSIZ2_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz2_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ2 & OTG_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz2_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ2 & OTG_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR3 OTG_HS host channel-3 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR3_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR3_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR3_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR3_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR3_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR3_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR3_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR3_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar3_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG_HS_HOST_OTG_HS_HCCHAR3_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR3_DAD); }
inline void otg_hs_host_otg_hs_hcchar3_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG_HS_HOST_OTG_HS_HCCHAR3_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR3_MC); }
inline void otg_hs_host_otg_hs_hcchar3_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG_HS_HOST_OTG_HS_HCCHAR3_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR3_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar3_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG_HS_HOST_OTG_HS_HCCHAR3_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR3_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar3_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG_HS_HOST_OTG_HS_HCCHAR3_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR3_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar3_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG_HS_HOST_OTG_HS_HCCHAR3_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar3_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG_HS_HOST_OTG_HS_HCCHAR3_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar3_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG_HS_HOST_OTG_HS_HCCHAR3_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar3_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG_HS_HOST_OTG_HS_HCCHAR3_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar3_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG_HS_HOST_OTG_HS_HCCHAR3_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT3 OTG_HS host channel-3 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT3_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT3_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT3_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT3_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT3_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt3_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT3 = (p->OTG_HS_HCSPLT3 & ~OTG_HS_HOST_OTG_HS_HCSPLT3_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT3_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt3_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT3 = (p->OTG_HS_HCSPLT3 & ~OTG_HS_HOST_OTG_HS_HCSPLT3_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT3_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt3_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT3 = (p->OTG_HS_HCSPLT3 & ~OTG_HS_HOST_OTG_HS_HCSPLT3_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT3_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt3_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT3 & OTG_HS_HOST_OTG_HS_HCSPLT3_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt3_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT3 & OTG_HS_HOST_OTG_HS_HCSPLT3_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt3_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT3 & OTG_HS_HOST_OTG_HS_HCSPLT3_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT3 OTG_HS host channel-3 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT3_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT3_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT3_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT3_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT3_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT3_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT3_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT3_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT3_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT3_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT3_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK3 OTG_HS host channel-3 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK3_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK3_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK3_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ3 OTG_HS host channel-3 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ3_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz3_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ3 = (p->OTG_HS_HCTSIZ3 & ~OTG_HS_HOST_OTG_HS_HCTSIZ3_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ3_DPID); }
inline void otg_hs_host_otg_hs_hctsiz3_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ3 = (p->OTG_HS_HCTSIZ3 & ~OTG_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz3_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ3 = (p->OTG_HS_HCTSIZ3 & ~OTG_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz3_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ3 & OTG_HS_HOST_OTG_HS_HCTSIZ3_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz3_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ3 & OTG_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz3_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ3 & OTG_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR4 OTG_HS host channel-4 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR4_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR4_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR4_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR4_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR4_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR4_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR4_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR4_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar4_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG_HS_HOST_OTG_HS_HCCHAR4_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR4_DAD); }
inline void otg_hs_host_otg_hs_hcchar4_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG_HS_HOST_OTG_HS_HCCHAR4_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR4_MC); }
inline void otg_hs_host_otg_hs_hcchar4_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG_HS_HOST_OTG_HS_HCCHAR4_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR4_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar4_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG_HS_HOST_OTG_HS_HCCHAR4_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR4_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar4_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG_HS_HOST_OTG_HS_HCCHAR4_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR4_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar4_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG_HS_HOST_OTG_HS_HCCHAR4_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar4_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG_HS_HOST_OTG_HS_HCCHAR4_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar4_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG_HS_HOST_OTG_HS_HCCHAR4_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar4_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG_HS_HOST_OTG_HS_HCCHAR4_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar4_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG_HS_HOST_OTG_HS_HCCHAR4_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT4 OTG_HS host channel-4 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT4_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT4_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT4_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT4_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT4_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt4_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT4 = (p->OTG_HS_HCSPLT4 & ~OTG_HS_HOST_OTG_HS_HCSPLT4_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT4_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt4_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT4 = (p->OTG_HS_HCSPLT4 & ~OTG_HS_HOST_OTG_HS_HCSPLT4_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT4_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt4_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT4 = (p->OTG_HS_HCSPLT4 & ~OTG_HS_HOST_OTG_HS_HCSPLT4_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT4_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt4_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT4 & OTG_HS_HOST_OTG_HS_HCSPLT4_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt4_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT4 & OTG_HS_HOST_OTG_HS_HCSPLT4_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt4_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT4 & OTG_HS_HOST_OTG_HS_HCSPLT4_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT4 OTG_HS host channel-4 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT4_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT4_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT4_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT4_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT4_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT4_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT4_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT4_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT4_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT4_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT4_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK4 OTG_HS host channel-4 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK4_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK4_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK4_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ4 OTG_HS host channel-4 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ4_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz4_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ4 = (p->OTG_HS_HCTSIZ4 & ~OTG_HS_HOST_OTG_HS_HCTSIZ4_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ4_DPID); }
inline void otg_hs_host_otg_hs_hctsiz4_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ4 = (p->OTG_HS_HCTSIZ4 & ~OTG_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz4_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ4 = (p->OTG_HS_HCTSIZ4 & ~OTG_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz4_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ4 & OTG_HS_HOST_OTG_HS_HCTSIZ4_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz4_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ4 & OTG_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz4_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ4 & OTG_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR5 OTG_HS host channel-5 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR5_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR5_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR5_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR5_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR5_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR5_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR5_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR5_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar5_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG_HS_HOST_OTG_HS_HCCHAR5_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR5_DAD); }
inline void otg_hs_host_otg_hs_hcchar5_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG_HS_HOST_OTG_HS_HCCHAR5_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR5_MC); }
inline void otg_hs_host_otg_hs_hcchar5_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG_HS_HOST_OTG_HS_HCCHAR5_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR5_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar5_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG_HS_HOST_OTG_HS_HCCHAR5_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR5_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar5_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG_HS_HOST_OTG_HS_HCCHAR5_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR5_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar5_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG_HS_HOST_OTG_HS_HCCHAR5_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar5_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG_HS_HOST_OTG_HS_HCCHAR5_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar5_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG_HS_HOST_OTG_HS_HCCHAR5_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar5_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG_HS_HOST_OTG_HS_HCCHAR5_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar5_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG_HS_HOST_OTG_HS_HCCHAR5_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT5 OTG_HS host channel-5 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT5_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT5_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT5_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT5_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT5_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt5_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT5 = (p->OTG_HS_HCSPLT5 & ~OTG_HS_HOST_OTG_HS_HCSPLT5_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT5_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt5_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT5 = (p->OTG_HS_HCSPLT5 & ~OTG_HS_HOST_OTG_HS_HCSPLT5_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT5_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt5_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT5 = (p->OTG_HS_HCSPLT5 & ~OTG_HS_HOST_OTG_HS_HCSPLT5_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT5_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt5_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT5 & OTG_HS_HOST_OTG_HS_HCSPLT5_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt5_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT5 & OTG_HS_HOST_OTG_HS_HCSPLT5_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt5_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT5 & OTG_HS_HOST_OTG_HS_HCSPLT5_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT5 OTG_HS host channel-5 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT5_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT5_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT5_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT5_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT5_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT5_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT5_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT5_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT5_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT5_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT5_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK5 OTG_HS host channel-5 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK5_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK5_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK5_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ5 OTG_HS host channel-5 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ5_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz5_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ5 = (p->OTG_HS_HCTSIZ5 & ~OTG_HS_HOST_OTG_HS_HCTSIZ5_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ5_DPID); }
inline void otg_hs_host_otg_hs_hctsiz5_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ5 = (p->OTG_HS_HCTSIZ5 & ~OTG_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz5_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ5 = (p->OTG_HS_HCTSIZ5 & ~OTG_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz5_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ5 & OTG_HS_HOST_OTG_HS_HCTSIZ5_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz5_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ5 & OTG_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz5_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ5 & OTG_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR6 OTG_HS host channel-6 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR6_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR6_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR6_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR6_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR6_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR6_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR6_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR6_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar6_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG_HS_HOST_OTG_HS_HCCHAR6_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR6_DAD); }
inline void otg_hs_host_otg_hs_hcchar6_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG_HS_HOST_OTG_HS_HCCHAR6_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR6_MC); }
inline void otg_hs_host_otg_hs_hcchar6_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG_HS_HOST_OTG_HS_HCCHAR6_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR6_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar6_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG_HS_HOST_OTG_HS_HCCHAR6_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR6_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar6_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG_HS_HOST_OTG_HS_HCCHAR6_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR6_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar6_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG_HS_HOST_OTG_HS_HCCHAR6_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar6_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG_HS_HOST_OTG_HS_HCCHAR6_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar6_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG_HS_HOST_OTG_HS_HCCHAR6_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar6_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG_HS_HOST_OTG_HS_HCCHAR6_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar6_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG_HS_HOST_OTG_HS_HCCHAR6_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT6 OTG_HS host channel-6 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT6_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT6_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT6_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT6_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT6_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt6_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT6 = (p->OTG_HS_HCSPLT6 & ~OTG_HS_HOST_OTG_HS_HCSPLT6_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT6_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt6_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT6 = (p->OTG_HS_HCSPLT6 & ~OTG_HS_HOST_OTG_HS_HCSPLT6_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT6_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt6_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT6 = (p->OTG_HS_HCSPLT6 & ~OTG_HS_HOST_OTG_HS_HCSPLT6_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT6_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt6_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT6 & OTG_HS_HOST_OTG_HS_HCSPLT6_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt6_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT6 & OTG_HS_HOST_OTG_HS_HCSPLT6_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt6_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT6 & OTG_HS_HOST_OTG_HS_HCSPLT6_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT6 OTG_HS host channel-6 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT6_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT6_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT6_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT6_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT6_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT6_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT6_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT6_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT6_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT6_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT6_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK6 OTG_HS host channel-6 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK6_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK6_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK6_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ6 OTG_HS host channel-6 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ6_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz6_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ6 = (p->OTG_HS_HCTSIZ6 & ~OTG_HS_HOST_OTG_HS_HCTSIZ6_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ6_DPID); }
inline void otg_hs_host_otg_hs_hctsiz6_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ6 = (p->OTG_HS_HCTSIZ6 & ~OTG_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz6_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ6 = (p->OTG_HS_HCTSIZ6 & ~OTG_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz6_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ6 & OTG_HS_HOST_OTG_HS_HCTSIZ6_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz6_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ6 & OTG_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz6_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ6 & OTG_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR7 OTG_HS host channel-7 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR7_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR7_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR7_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR7_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR7_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR7_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR7_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR7_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar7_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG_HS_HOST_OTG_HS_HCCHAR7_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR7_DAD); }
inline void otg_hs_host_otg_hs_hcchar7_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG_HS_HOST_OTG_HS_HCCHAR7_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR7_MC); }
inline void otg_hs_host_otg_hs_hcchar7_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG_HS_HOST_OTG_HS_HCCHAR7_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR7_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar7_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG_HS_HOST_OTG_HS_HCCHAR7_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR7_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar7_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG_HS_HOST_OTG_HS_HCCHAR7_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR7_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar7_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG_HS_HOST_OTG_HS_HCCHAR7_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar7_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG_HS_HOST_OTG_HS_HCCHAR7_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar7_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG_HS_HOST_OTG_HS_HCCHAR7_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar7_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG_HS_HOST_OTG_HS_HCCHAR7_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar7_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG_HS_HOST_OTG_HS_HCCHAR7_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT7 OTG_HS host channel-7 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT7_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT7_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT7_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT7_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT7_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt7_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT7 = (p->OTG_HS_HCSPLT7 & ~OTG_HS_HOST_OTG_HS_HCSPLT7_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT7_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt7_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT7 = (p->OTG_HS_HCSPLT7 & ~OTG_HS_HOST_OTG_HS_HCSPLT7_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT7_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt7_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT7 = (p->OTG_HS_HCSPLT7 & ~OTG_HS_HOST_OTG_HS_HCSPLT7_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT7_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt7_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT7 & OTG_HS_HOST_OTG_HS_HCSPLT7_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt7_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT7 & OTG_HS_HOST_OTG_HS_HCSPLT7_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt7_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT7 & OTG_HS_HOST_OTG_HS_HCSPLT7_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT7 OTG_HS host channel-7 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT7_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT7_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT7_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT7_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT7_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT7_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT7_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT7_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT7_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT7_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT7_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK7 OTG_HS host channel-7 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK7_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK7_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK7_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ7 OTG_HS host channel-7 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ7_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz7_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ7 = (p->OTG_HS_HCTSIZ7 & ~OTG_HS_HOST_OTG_HS_HCTSIZ7_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ7_DPID); }
inline void otg_hs_host_otg_hs_hctsiz7_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ7 = (p->OTG_HS_HCTSIZ7 & ~OTG_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz7_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ7 = (p->OTG_HS_HCTSIZ7 & ~OTG_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz7_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ7 & OTG_HS_HOST_OTG_HS_HCTSIZ7_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz7_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ7 & OTG_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz7_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ7 & OTG_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR8 OTG_HS host channel-8 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR8_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR8_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR8_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR8_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR8_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR8_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR8_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR8_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR8_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR8_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar8_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG_HS_HOST_OTG_HS_HCCHAR8_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR8_DAD); }
inline void otg_hs_host_otg_hs_hcchar8_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG_HS_HOST_OTG_HS_HCCHAR8_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR8_MC); }
inline void otg_hs_host_otg_hs_hcchar8_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG_HS_HOST_OTG_HS_HCCHAR8_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR8_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar8_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG_HS_HOST_OTG_HS_HCCHAR8_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR8_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar8_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG_HS_HOST_OTG_HS_HCCHAR8_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR8_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar8_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG_HS_HOST_OTG_HS_HCCHAR8_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar8_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG_HS_HOST_OTG_HS_HCCHAR8_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar8_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG_HS_HOST_OTG_HS_HCCHAR8_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar8_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG_HS_HOST_OTG_HS_HCCHAR8_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar8_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG_HS_HOST_OTG_HS_HCCHAR8_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT8 OTG_HS host channel-8 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT8_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT8_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT8_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT8_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT8_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt8_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT8 = (p->OTG_HS_HCSPLT8 & ~OTG_HS_HOST_OTG_HS_HCSPLT8_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT8_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt8_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT8 = (p->OTG_HS_HCSPLT8 & ~OTG_HS_HOST_OTG_HS_HCSPLT8_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT8_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt8_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT8 = (p->OTG_HS_HCSPLT8 & ~OTG_HS_HOST_OTG_HS_HCSPLT8_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT8_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt8_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT8 & OTG_HS_HOST_OTG_HS_HCSPLT8_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt8_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT8 & OTG_HS_HOST_OTG_HS_HCSPLT8_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt8_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT8 & OTG_HS_HOST_OTG_HS_HCSPLT8_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT8 OTG_HS host channel-8 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT8_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT8_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT8_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT8_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT8_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT8_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT8_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT8_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT8_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT8_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT8_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK8 OTG_HS host channel-8 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK8_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK8_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK8_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ8 OTG_HS host channel-8 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ8_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz8_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ8 = (p->OTG_HS_HCTSIZ8 & ~OTG_HS_HOST_OTG_HS_HCTSIZ8_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ8_DPID); }
inline void otg_hs_host_otg_hs_hctsiz8_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ8 = (p->OTG_HS_HCTSIZ8 & ~OTG_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz8_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ8 = (p->OTG_HS_HCTSIZ8 & ~OTG_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz8_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ8 & OTG_HS_HOST_OTG_HS_HCTSIZ8_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz8_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ8 & OTG_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz8_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ8 & OTG_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR9 OTG_HS host channel-9 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR9_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR9_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR9_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR9_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR9_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR9_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR9_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR9_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR9_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR9_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar9_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG_HS_HOST_OTG_HS_HCCHAR9_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR9_DAD); }
inline void otg_hs_host_otg_hs_hcchar9_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG_HS_HOST_OTG_HS_HCCHAR9_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR9_MC); }
inline void otg_hs_host_otg_hs_hcchar9_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG_HS_HOST_OTG_HS_HCCHAR9_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR9_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar9_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG_HS_HOST_OTG_HS_HCCHAR9_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR9_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar9_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG_HS_HOST_OTG_HS_HCCHAR9_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR9_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar9_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG_HS_HOST_OTG_HS_HCCHAR9_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar9_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG_HS_HOST_OTG_HS_HCCHAR9_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar9_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG_HS_HOST_OTG_HS_HCCHAR9_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar9_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG_HS_HOST_OTG_HS_HCCHAR9_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar9_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG_HS_HOST_OTG_HS_HCCHAR9_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT9 OTG_HS host channel-9 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT9_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT9_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT9_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT9_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT9_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt9_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT9 = (p->OTG_HS_HCSPLT9 & ~OTG_HS_HOST_OTG_HS_HCSPLT9_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT9_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt9_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT9 = (p->OTG_HS_HCSPLT9 & ~OTG_HS_HOST_OTG_HS_HCSPLT9_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT9_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt9_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT9 = (p->OTG_HS_HCSPLT9 & ~OTG_HS_HOST_OTG_HS_HCSPLT9_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT9_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt9_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT9 & OTG_HS_HOST_OTG_HS_HCSPLT9_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt9_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT9 & OTG_HS_HOST_OTG_HS_HCSPLT9_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt9_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT9 & OTG_HS_HOST_OTG_HS_HCSPLT9_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT9 OTG_HS host channel-9 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT9_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT9_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT9_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT9_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT9_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT9_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT9_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT9_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT9_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT9_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT9_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK9 OTG_HS host channel-9 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK9_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK9_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK9_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ9 OTG_HS host channel-9 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ9_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz9_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ9 = (p->OTG_HS_HCTSIZ9 & ~OTG_HS_HOST_OTG_HS_HCTSIZ9_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ9_DPID); }
inline void otg_hs_host_otg_hs_hctsiz9_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ9 = (p->OTG_HS_HCTSIZ9 & ~OTG_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz9_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ9 = (p->OTG_HS_HCTSIZ9 & ~OTG_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz9_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ9 & OTG_HS_HOST_OTG_HS_HCTSIZ9_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz9_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ9 & OTG_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz9_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ9 & OTG_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR10 OTG_HS host channel-10 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR10_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR10_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR10_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR10_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR10_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR10_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR10_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR10_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR10_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR10_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar10_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG_HS_HOST_OTG_HS_HCCHAR10_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR10_DAD); }
inline void otg_hs_host_otg_hs_hcchar10_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG_HS_HOST_OTG_HS_HCCHAR10_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR10_MC); }
inline void otg_hs_host_otg_hs_hcchar10_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG_HS_HOST_OTG_HS_HCCHAR10_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR10_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar10_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG_HS_HOST_OTG_HS_HCCHAR10_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR10_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar10_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG_HS_HOST_OTG_HS_HCCHAR10_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR10_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar10_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG_HS_HOST_OTG_HS_HCCHAR10_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar10_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG_HS_HOST_OTG_HS_HCCHAR10_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar10_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG_HS_HOST_OTG_HS_HCCHAR10_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar10_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG_HS_HOST_OTG_HS_HCCHAR10_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar10_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG_HS_HOST_OTG_HS_HCCHAR10_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT10 OTG_HS host channel-10 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT10_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT10_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT10_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT10_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT10_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt10_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT10 = (p->OTG_HS_HCSPLT10 & ~OTG_HS_HOST_OTG_HS_HCSPLT10_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT10_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt10_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT10 = (p->OTG_HS_HCSPLT10 & ~OTG_HS_HOST_OTG_HS_HCSPLT10_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT10_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt10_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT10 = (p->OTG_HS_HCSPLT10 & ~OTG_HS_HOST_OTG_HS_HCSPLT10_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT10_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt10_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT10 & OTG_HS_HOST_OTG_HS_HCSPLT10_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt10_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT10 & OTG_HS_HOST_OTG_HS_HCSPLT10_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt10_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT10 & OTG_HS_HOST_OTG_HS_HCSPLT10_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT10 OTG_HS host channel-10 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT10_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT10_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT10_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT10_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT10_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT10_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT10_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT10_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT10_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT10_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT10_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK10 OTG_HS host channel-10 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK10_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK10_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK10_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ10 OTG_HS host channel-10 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ10_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz10_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ10 = (p->OTG_HS_HCTSIZ10 & ~OTG_HS_HOST_OTG_HS_HCTSIZ10_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ10_DPID); }
inline void otg_hs_host_otg_hs_hctsiz10_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ10 = (p->OTG_HS_HCTSIZ10 & ~OTG_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz10_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ10 = (p->OTG_HS_HCTSIZ10 & ~OTG_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz10_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ10 & OTG_HS_HOST_OTG_HS_HCTSIZ10_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz10_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ10 & OTG_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz10_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ10 & OTG_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR11 OTG_HS host channel-11 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR11_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR11_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR11_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR11_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR11_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR11_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR11_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR11_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR11_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR11_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar11_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG_HS_HOST_OTG_HS_HCCHAR11_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR11_DAD); }
inline void otg_hs_host_otg_hs_hcchar11_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG_HS_HOST_OTG_HS_HCCHAR11_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR11_MC); }
inline void otg_hs_host_otg_hs_hcchar11_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG_HS_HOST_OTG_HS_HCCHAR11_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR11_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar11_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG_HS_HOST_OTG_HS_HCCHAR11_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR11_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar11_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG_HS_HOST_OTG_HS_HCCHAR11_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR11_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar11_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG_HS_HOST_OTG_HS_HCCHAR11_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar11_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG_HS_HOST_OTG_HS_HCCHAR11_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar11_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG_HS_HOST_OTG_HS_HCCHAR11_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar11_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG_HS_HOST_OTG_HS_HCCHAR11_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar11_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG_HS_HOST_OTG_HS_HCCHAR11_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT11 OTG_HS host channel-11 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT11_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT11_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT11_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT11_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT11_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt11_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT11 = (p->OTG_HS_HCSPLT11 & ~OTG_HS_HOST_OTG_HS_HCSPLT11_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT11_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt11_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT11 = (p->OTG_HS_HCSPLT11 & ~OTG_HS_HOST_OTG_HS_HCSPLT11_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT11_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt11_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT11 = (p->OTG_HS_HCSPLT11 & ~OTG_HS_HOST_OTG_HS_HCSPLT11_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT11_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt11_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT11 & OTG_HS_HOST_OTG_HS_HCSPLT11_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt11_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT11 & OTG_HS_HOST_OTG_HS_HCSPLT11_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt11_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT11 & OTG_HS_HOST_OTG_HS_HCSPLT11_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT11 OTG_HS host channel-11 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT11_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT11_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT11_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT11_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT11_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT11_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT11_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT11_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT11_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT11_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT11_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK11 OTG_HS host channel-11 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK11_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_BBERRM = 1UL<<8, // Babble error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_TXERRM = 1UL<<7, // Transaction error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_NYET = 1UL<<6, // response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK11_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK11_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ11 OTG_HS host channel-11 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ11_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz11_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ11 = (p->OTG_HS_HCTSIZ11 & ~OTG_HS_HOST_OTG_HS_HCTSIZ11_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ11_DPID); }
inline void otg_hs_host_otg_hs_hctsiz11_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ11 = (p->OTG_HS_HCTSIZ11 & ~OTG_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz11_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ11 = (p->OTG_HS_HCTSIZ11 & ~OTG_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz11_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ11 & OTG_HS_HOST_OTG_HS_HCTSIZ11_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz11_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ11 & OTG_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz11_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ11 & OTG_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR12 OTG_HS host channel-12 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR12_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR12_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR12_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR12_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR12_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR12_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR12_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR12_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR12_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR12_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar12_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG_HS_HOST_OTG_HS_HCCHAR12_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR12_DAD); }
inline void otg_hs_host_otg_hs_hcchar12_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG_HS_HOST_OTG_HS_HCCHAR12_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR12_MC); }
inline void otg_hs_host_otg_hs_hcchar12_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG_HS_HOST_OTG_HS_HCCHAR12_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR12_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar12_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG_HS_HOST_OTG_HS_HCCHAR12_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR12_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar12_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG_HS_HOST_OTG_HS_HCCHAR12_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR12_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar12_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG_HS_HOST_OTG_HS_HCCHAR12_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar12_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG_HS_HOST_OTG_HS_HCCHAR12_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar12_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG_HS_HOST_OTG_HS_HCCHAR12_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar12_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG_HS_HOST_OTG_HS_HCCHAR12_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar12_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG_HS_HOST_OTG_HS_HCCHAR12_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT12 OTG_HS host channel-12 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT12_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT12_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT12_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT12_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT12_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt12_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT12 = (p->OTG_HS_HCSPLT12 & ~OTG_HS_HOST_OTG_HS_HCSPLT12_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT12_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt12_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT12 = (p->OTG_HS_HCSPLT12 & ~OTG_HS_HOST_OTG_HS_HCSPLT12_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT12_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt12_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT12 = (p->OTG_HS_HCSPLT12 & ~OTG_HS_HOST_OTG_HS_HCSPLT12_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT12_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt12_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT12 & OTG_HS_HOST_OTG_HS_HCSPLT12_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt12_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT12 & OTG_HS_HOST_OTG_HS_HCSPLT12_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt12_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT12 & OTG_HS_HOST_OTG_HS_HCSPLT12_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT12 OTG_HS host channel-12 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT12_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT12_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT12_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT12_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT12_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT12_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT12_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT12_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT12_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT12_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT12_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK12 OTG_HS host channel-12 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK12_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK12_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK12_BBERRM = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINTMSK12_TXERRM = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINTMSK12_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINTMSK12_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK12_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK12_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK12_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK12_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK12_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ12 OTG_HS host channel-12 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ12_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz12_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ12 = (p->OTG_HS_HCTSIZ12 & ~OTG_HS_HOST_OTG_HS_HCTSIZ12_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ12_DPID); }
inline void otg_hs_host_otg_hs_hctsiz12_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ12 = (p->OTG_HS_HCTSIZ12 & ~OTG_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz12_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ12 = (p->OTG_HS_HCTSIZ12 & ~OTG_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz12_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ12 & OTG_HS_HOST_OTG_HS_HCTSIZ12_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz12_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ12 & OTG_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz12_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ12 & OTG_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR13 OTG_HS host channel-13 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR13_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR13_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR13_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR13_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR13_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR13_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR13_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR13_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR13_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR13_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar13_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG_HS_HOST_OTG_HS_HCCHAR13_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR13_DAD); }
inline void otg_hs_host_otg_hs_hcchar13_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG_HS_HOST_OTG_HS_HCCHAR13_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR13_MC); }
inline void otg_hs_host_otg_hs_hcchar13_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG_HS_HOST_OTG_HS_HCCHAR13_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR13_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar13_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG_HS_HOST_OTG_HS_HCCHAR13_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR13_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar13_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG_HS_HOST_OTG_HS_HCCHAR13_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR13_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar13_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG_HS_HOST_OTG_HS_HCCHAR13_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar13_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG_HS_HOST_OTG_HS_HCCHAR13_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar13_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG_HS_HOST_OTG_HS_HCCHAR13_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar13_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG_HS_HOST_OTG_HS_HCCHAR13_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar13_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG_HS_HOST_OTG_HS_HCCHAR13_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT13 OTG_HS host channel-13 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT13_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT13_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT13_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT13_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT13_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt13_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT13 = (p->OTG_HS_HCSPLT13 & ~OTG_HS_HOST_OTG_HS_HCSPLT13_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT13_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt13_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT13 = (p->OTG_HS_HCSPLT13 & ~OTG_HS_HOST_OTG_HS_HCSPLT13_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT13_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt13_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT13 = (p->OTG_HS_HCSPLT13 & ~OTG_HS_HOST_OTG_HS_HCSPLT13_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT13_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt13_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT13 & OTG_HS_HOST_OTG_HS_HCSPLT13_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt13_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT13 & OTG_HS_HOST_OTG_HS_HCSPLT13_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt13_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT13 & OTG_HS_HOST_OTG_HS_HCSPLT13_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT13 OTG_HS host channel-13 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT13_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT13_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT13_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT13_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT13_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT13_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT13_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT13_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT13_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT13_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT13_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK13 OTG_HS host channel-13 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK13_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK13_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK13_BBERRM = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINTMSK13_TXERRM = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINTMSK13_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINTMSK13_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK13_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK13_STALLM = 1UL<<3, // STALLM response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK13_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK13_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK13_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ13 OTG_HS host channel-13 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ13_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz13_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ13 = (p->OTG_HS_HCTSIZ13 & ~OTG_HS_HOST_OTG_HS_HCTSIZ13_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ13_DPID); }
inline void otg_hs_host_otg_hs_hctsiz13_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ13 = (p->OTG_HS_HCTSIZ13 & ~OTG_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz13_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ13 = (p->OTG_HS_HCTSIZ13 & ~OTG_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz13_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ13 & OTG_HS_HOST_OTG_HS_HCTSIZ13_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz13_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ13 & OTG_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz13_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ13 & OTG_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR14 OTG_HS host channel-14 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR14_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR14_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR14_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR14_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR14_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR14_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR14_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR14_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR14_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR14_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar14_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG_HS_HOST_OTG_HS_HCCHAR14_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR14_DAD); }
inline void otg_hs_host_otg_hs_hcchar14_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG_HS_HOST_OTG_HS_HCCHAR14_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR14_MC); }
inline void otg_hs_host_otg_hs_hcchar14_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG_HS_HOST_OTG_HS_HCCHAR14_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR14_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar14_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG_HS_HOST_OTG_HS_HCCHAR14_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR14_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar14_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG_HS_HOST_OTG_HS_HCCHAR14_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR14_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar14_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG_HS_HOST_OTG_HS_HCCHAR14_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar14_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG_HS_HOST_OTG_HS_HCCHAR14_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar14_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG_HS_HOST_OTG_HS_HCCHAR14_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar14_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG_HS_HOST_OTG_HS_HCCHAR14_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar14_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG_HS_HOST_OTG_HS_HCCHAR14_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT14 OTG_HS host channel-14 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT14_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT14_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT14_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT14_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT14_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt14_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT14 = (p->OTG_HS_HCSPLT14 & ~OTG_HS_HOST_OTG_HS_HCSPLT14_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT14_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt14_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT14 = (p->OTG_HS_HCSPLT14 & ~OTG_HS_HOST_OTG_HS_HCSPLT14_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT14_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt14_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT14 = (p->OTG_HS_HCSPLT14 & ~OTG_HS_HOST_OTG_HS_HCSPLT14_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT14_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt14_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT14 & OTG_HS_HOST_OTG_HS_HCSPLT14_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt14_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT14 & OTG_HS_HOST_OTG_HS_HCSPLT14_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt14_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT14 & OTG_HS_HOST_OTG_HS_HCSPLT14_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT14 OTG_HS host channel-14 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT14_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT14_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT14_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT14_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT14_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT14_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT14_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT14_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT14_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT14_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT14_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK14 OTG_HS host channel-14 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK14_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK14_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK14_BBERRM = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINTMSK14_TXERRM = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINTMSK14_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINTMSK14_ACKM = 1UL<<5, // ACKM response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK14_NAKM = 1UL<<4, // NAKM response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK14_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK14_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK14_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK14_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ14 OTG_HS host channel-14 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ14_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz14_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ14 = (p->OTG_HS_HCTSIZ14 & ~OTG_HS_HOST_OTG_HS_HCTSIZ14_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ14_DPID); }
inline void otg_hs_host_otg_hs_hctsiz14_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ14 = (p->OTG_HS_HCTSIZ14 & ~OTG_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz14_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ14 = (p->OTG_HS_HCTSIZ14 & ~OTG_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz14_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ14 & OTG_HS_HOST_OTG_HS_HCTSIZ14_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz14_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ14 & OTG_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz14_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ14 & OTG_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCCHAR15 OTG_HS host channel-15 characteristics register
enum {
	OTG_HS_HOST_OTG_HS_HCCHAR15_CHENA = 1UL<<31, // Channel enable
	OTG_HS_HOST_OTG_HS_HCCHAR15_CHDIS = 1UL<<30, // Channel disable
	OTG_HS_HOST_OTG_HS_HCCHAR15_ODDFRM = 1UL<<29, // Odd frame
	OTG_HS_HOST_OTG_HS_HCCHAR15_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG_HS_HOST_OTG_HS_HCCHAR15_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG_HS_HOST_OTG_HS_HCCHAR15_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG_HS_HOST_OTG_HS_HCCHAR15_LSDEV = 1UL<<17, // Low-speed device
	OTG_HS_HOST_OTG_HS_HCCHAR15_EPDIR = 1UL<<15, // Endpoint direction
	OTG_HS_HOST_OTG_HS_HCCHAR15_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG_HS_HOST_OTG_HS_HCCHAR15_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg_hs_host_otg_hs_hcchar15_set_dad(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG_HS_HOST_OTG_HS_HCCHAR15_DAD) | ((val<<22) & OTG_HS_HOST_OTG_HS_HCCHAR15_DAD); }
inline void otg_hs_host_otg_hs_hcchar15_set_mc(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG_HS_HOST_OTG_HS_HCCHAR15_MC) | ((val<<20) & OTG_HS_HOST_OTG_HS_HCCHAR15_MC); }
inline void otg_hs_host_otg_hs_hcchar15_set_eptyp(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG_HS_HOST_OTG_HS_HCCHAR15_EPTYP) | ((val<<18) & OTG_HS_HOST_OTG_HS_HCCHAR15_EPTYP); }
inline void otg_hs_host_otg_hs_hcchar15_set_epnum(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG_HS_HOST_OTG_HS_HCCHAR15_EPNUM) | ((val<<11) & OTG_HS_HOST_OTG_HS_HCCHAR15_EPNUM); }
inline void otg_hs_host_otg_hs_hcchar15_set_mpsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG_HS_HOST_OTG_HS_HCCHAR15_MPSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCCHAR15_MPSIZ); }
inline uint32_t otg_hs_host_otg_hs_hcchar15_get_dad(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG_HS_HOST_OTG_HS_HCCHAR15_DAD) >> 22 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar15_get_mc(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG_HS_HOST_OTG_HS_HCCHAR15_MC) >> 20 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar15_get_eptyp(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG_HS_HOST_OTG_HS_HCCHAR15_EPTYP) >> 18 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar15_get_epnum(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG_HS_HOST_OTG_HS_HCCHAR15_EPNUM) >> 11 ; }
inline uint32_t otg_hs_host_otg_hs_hcchar15_get_mpsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG_HS_HOST_OTG_HS_HCCHAR15_MPSIZ) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCSPLT15 OTG_HS host channel-15 split control register
enum {
	OTG_HS_HOST_OTG_HS_HCSPLT15_SPLITEN = 1UL<<31, // Split enable
	OTG_HS_HOST_OTG_HS_HCSPLT15_COMPLSPLT = 1UL<<16, // Do complete split
	OTG_HS_HOST_OTG_HS_HCSPLT15_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG_HS_HOST_OTG_HS_HCSPLT15_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG_HS_HOST_OTG_HS_HCSPLT15_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg_hs_host_otg_hs_hcsplt15_set_xactpos(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT15 = (p->OTG_HS_HCSPLT15 & ~OTG_HS_HOST_OTG_HS_HCSPLT15_XACTPOS) | ((val<<14) & OTG_HS_HOST_OTG_HS_HCSPLT15_XACTPOS); }
inline void otg_hs_host_otg_hs_hcsplt15_set_hubaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT15 = (p->OTG_HS_HCSPLT15 & ~OTG_HS_HOST_OTG_HS_HCSPLT15_HUBADDR) | ((val<<7) & OTG_HS_HOST_OTG_HS_HCSPLT15_HUBADDR); }
inline void otg_hs_host_otg_hs_hcsplt15_set_prtaddr(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT15 = (p->OTG_HS_HCSPLT15 & ~OTG_HS_HOST_OTG_HS_HCSPLT15_PRTADDR) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCSPLT15_PRTADDR); }
inline uint32_t otg_hs_host_otg_hs_hcsplt15_get_xactpos(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT15 & OTG_HS_HOST_OTG_HS_HCSPLT15_XACTPOS) >> 14 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt15_get_hubaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT15 & OTG_HS_HOST_OTG_HS_HCSPLT15_HUBADDR) >> 7 ; }
inline uint32_t otg_hs_host_otg_hs_hcsplt15_get_prtaddr(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT15 & OTG_HS_HOST_OTG_HS_HCSPLT15_PRTADDR) >> 0 ; }

// OTG_HS_HOST->OTG_HS_HCINT15 OTG_HS host channel-15 interrupt register
enum {
	OTG_HS_HOST_OTG_HS_HCINT15_DTERR = 1UL<<10, // Data toggle error
	OTG_HS_HOST_OTG_HS_HCINT15_FRMOR = 1UL<<9, // Frame overrun
	OTG_HS_HOST_OTG_HS_HCINT15_BBERR = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINT15_TXERR = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINT15_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT15_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG_HS_HOST_OTG_HS_HCINT15_NAK = 1UL<<4, // NAK response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT15_STALL = 1UL<<3, // STALL response received interrupt
	OTG_HS_HOST_OTG_HS_HCINT15_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINT15_CHH = 1UL<<1, // Channel halted
	OTG_HS_HOST_OTG_HS_HCINT15_XFRC = 1UL<<0, // Transfer completed		
};

// OTG_HS_HOST->OTG_HS_HCINTMSK15 OTG_HS host channel-15 interrupt mask register
enum {
	OTG_HS_HOST_OTG_HS_HCINTMSK15_DTERRM = 1UL<<10, // Data toggle error mask
	OTG_HS_HOST_OTG_HS_HCINTMSK15_FRMORM = 1UL<<9, // Frame overrun mask
	OTG_HS_HOST_OTG_HS_HCINTMSK15_BBERRM = 1UL<<8, // Babble error
	OTG_HS_HOST_OTG_HS_HCINTMSK15_TXERRM = 1UL<<7, // Transaction error
	OTG_HS_HOST_OTG_HS_HCINTMSK15_NYET = 1UL<<6, // Response received interrupt
	OTG_HS_HOST_OTG_HS_HCINTMSK15_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK15_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK15_STALL = 1UL<<3, // STALL response received interrupt mask
	OTG_HS_HOST_OTG_HS_HCINTMSK15_AHBERR = 1UL<<2, // AHB error
	OTG_HS_HOST_OTG_HS_HCINTMSK15_CHHM = 1UL<<1, // Channel halted mask
	OTG_HS_HOST_OTG_HS_HCINTMSK15_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG_HS_HOST->OTG_HS_HCTSIZ15 OTG_HS host channel-15 transfer size register
enum {
	OTG_HS_HOST_OTG_HS_HCTSIZ15_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg_hs_host_otg_hs_hctsiz15_set_dpid(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ15 = (p->OTG_HS_HCTSIZ15 & ~OTG_HS_HOST_OTG_HS_HCTSIZ15_DPID) | ((val<<29) & OTG_HS_HOST_OTG_HS_HCTSIZ15_DPID); }
inline void otg_hs_host_otg_hs_hctsiz15_set_pktcnt(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ15 = (p->OTG_HS_HCTSIZ15 & ~OTG_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT) | ((val<<19) & OTG_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT); }
inline void otg_hs_host_otg_hs_hctsiz15_set_xfrsiz(struct OTG_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ15 = (p->OTG_HS_HCTSIZ15 & ~OTG_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ) | ((val<<0) & OTG_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ); }
inline uint32_t otg_hs_host_otg_hs_hctsiz15_get_dpid(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ15 & OTG_HS_HOST_OTG_HS_HCTSIZ15_DPID) >> 29 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz15_get_pktcnt(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ15 & OTG_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT) >> 19 ; }
inline uint32_t otg_hs_host_otg_hs_hctsiz15_get_xfrsiz(struct OTG_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ15 & OTG_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ) >> 0 ; }

/* USB on the go high speed */
struct OTG_HS_PWRCLK_Type {
	__IO uint8_t OTG_HS_PCGCR; // @0 Power and clock gating control register
};

// OTG_HS_PWRCLK->OTG_HS_PCGCR Power and clock gating control register
enum {
	OTG_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP = 1UL<<4, // PHY suspended
	OTG_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK = 1UL<<1, // Gate HCLK
	OTG_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK = 1UL<<0, // Stop PHY clock		
};

/* Processor features */
struct PF_Type {
	__I uint32_t CLIDR; // @0 Cache Level ID register
	__I uint32_t CTR; // @4 Cache Type register
	__I uint32_t CCSIDR; // @8 Cache Size ID register
};

// PF->CLIDR Cache Level ID register
enum {
	PF_CLIDR_LOU = ((1UL<<3)-1) << 27, // LoU
	PF_CLIDR_LOC = ((1UL<<3)-1) << 24, // LoC
	PF_CLIDR_LOUIS = ((1UL<<3)-1) << 21, // LoUIS
	PF_CLIDR_CL7 = ((1UL<<3)-1) << 18, // CL7
	PF_CLIDR_CL6 = ((1UL<<3)-1) << 15, // CL6
	PF_CLIDR_CL5 = ((1UL<<3)-1) << 12, // CL5
	PF_CLIDR_CL4 = ((1UL<<3)-1) << 9, // CL4
	PF_CLIDR_CL3 = ((1UL<<3)-1) << 6, // CL3
	PF_CLIDR_CL2 = ((1UL<<3)-1) << 3, // CL2
	PF_CLIDR_CL1 = ((1UL<<3)-1) << 0, // CL1		
};
inline uint32_t pf_clidr_get_lou(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_LOU) >> 27 ; }
inline uint32_t pf_clidr_get_loc(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_LOC) >> 24 ; }
inline uint32_t pf_clidr_get_louis(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_LOUIS) >> 21 ; }
inline uint32_t pf_clidr_get_cl7(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL7) >> 18 ; }
inline uint32_t pf_clidr_get_cl6(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL6) >> 15 ; }
inline uint32_t pf_clidr_get_cl5(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL5) >> 12 ; }
inline uint32_t pf_clidr_get_cl4(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL4) >> 9 ; }
inline uint32_t pf_clidr_get_cl3(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL3) >> 6 ; }
inline uint32_t pf_clidr_get_cl2(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL2) >> 3 ; }
inline uint32_t pf_clidr_get_cl1(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL1) >> 0 ; }

// PF->CTR Cache Type register
enum {
	PF_CTR_FORMAT = ((1UL<<3)-1) << 29, // Format
	PF_CTR_CWG = ((1UL<<4)-1) << 24, // CWG
	PF_CTR_ERG = ((1UL<<4)-1) << 20, // ERG
	PF_CTR_DMINLINE = ((1UL<<4)-1) << 16, // DMinLine
	PF_CTR__IMINLINE = ((1UL<<4)-1) << 0, // IminLine		
};
inline uint32_t pf_ctr_get_format(struct PF_Type* p) { return (p->CTR & PF_CTR_FORMAT) >> 29 ; }
inline uint32_t pf_ctr_get_cwg(struct PF_Type* p) { return (p->CTR & PF_CTR_CWG) >> 24 ; }
inline uint32_t pf_ctr_get_erg(struct PF_Type* p) { return (p->CTR & PF_CTR_ERG) >> 20 ; }
inline uint32_t pf_ctr_get_dminline(struct PF_Type* p) { return (p->CTR & PF_CTR_DMINLINE) >> 16 ; }
inline uint32_t pf_ctr_get__iminline(struct PF_Type* p) { return (p->CTR & PF_CTR__IMINLINE) >> 0 ; }

// PF->CCSIDR Cache Size ID register
enum {
	PF_CCSIDR_WT = 1UL<<31, // WT
	PF_CCSIDR_WB = 1UL<<30, // WB
	PF_CCSIDR_RA = 1UL<<29, // RA
	PF_CCSIDR_WA = 1UL<<28, // WA
	PF_CCSIDR_NUMSETS = ((1UL<<15)-1) << 13, // NumSets
	PF_CCSIDR_ASSOCIATIVITY = ((1UL<<10)-1) << 3, // Associativity
	PF_CCSIDR_LINESIZE = ((1UL<<3)-1) << 0, // LineSize		
};
inline uint32_t pf_ccsidr_get_numsets(struct PF_Type* p) { return (p->CCSIDR & PF_CCSIDR_NUMSETS) >> 13 ; }
inline uint32_t pf_ccsidr_get_associativity(struct PF_Type* p) { return (p->CCSIDR & PF_CCSIDR_ASSOCIATIVITY) >> 3 ; }
inline uint32_t pf_ccsidr_get_linesize(struct PF_Type* p) { return (p->CCSIDR & PF_CCSIDR_LINESIZE) >> 0 ; }

/* Power control */
struct PWR_Type {
	__IO uint32_t CR1; // @0 power control register
	__IO uint32_t CSR1; // @4 power control/status register
	__IO uint16_t CR2; // @8 power control register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t CSR2; // @12 power control/status register
};

// PWR->CR1 power control register
enum {
	PWR_CR1_UDEN = ((1UL<<2)-1) << 18, // Under-drive enable in stop mode
	PWR_CR1_ODSWEN = 1UL<<17, // Over-drive switching enabled
	PWR_CR1_ODEN = 1UL<<16, // Over-drive enable
	PWR_CR1_VOS = ((1UL<<2)-1) << 14, // Regulator voltage scaling output selection
	PWR_CR1_ADCDC1 = 1UL<<13, // ADCDC1
	PWR_CR1_MRUDS = 1UL<<11, // Main regulator in deepsleep under-drive mode
	PWR_CR1_LPUDS = 1UL<<10, // Low-power regulator in deepsleep under-drive mode
	PWR_CR1_FPDS = 1UL<<9, // Flash power down in Stop mode
	PWR_CR1_DBP = 1UL<<8, // Disable backup domain write protection
	PWR_CR1_PLS = ((1UL<<3)-1) << 5, // PVD level selection
	PWR_CR1_PVDE = 1UL<<4, // Power voltage detector enable
	PWR_CR1_CSBF = 1UL<<3, // Clear standby flag
	PWR_CR1_PDDS = 1UL<<1, // Power down deepsleep
	PWR_CR1_LPDS = 1UL<<0, // Low-power deep sleep		
};
inline void pwr_cr1_set_uden(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_UDEN) | ((val<<18) & PWR_CR1_UDEN); }
inline void pwr_cr1_set_vos(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_VOS) | ((val<<14) & PWR_CR1_VOS); }
inline void pwr_cr1_set_pls(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_PLS) | ((val<<5) & PWR_CR1_PLS); }
inline uint32_t pwr_cr1_get_uden(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_UDEN) >> 18 ; }
inline uint32_t pwr_cr1_get_vos(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_VOS) >> 14 ; }
inline uint32_t pwr_cr1_get_pls(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_PLS) >> 5 ; }

// PWR->CSR1 power control/status register
enum {
	PWR_CSR1_UDRDY = ((1UL<<2)-1) << 18, // Under-drive ready flag
	PWR_CSR1_ODSWRDY = 1UL<<17, // Over-drive mode switching ready
	PWR_CSR1_ODRDY = 1UL<<16, // Over-drive mode ready
	PWR_CSR1_VOSRDY = 1UL<<14, // Regulator voltage scaling output selection ready bit
	PWR_CSR1_BRE = 1UL<<9, // Backup regulator enable
	PWR_CSR1_BRR = 1UL<<3, // Backup regulator ready
	PWR_CSR1_PVDO = 1UL<<2, // PVD output
	PWR_CSR1_SBF = 1UL<<1, // Standby flag
	PWR_CSR1_WUIF = 1UL<<0, // Wakeup internal flag		
};
inline void pwr_csr1_set_udrdy(struct PWR_Type* p, uint32_t val) { p->CSR1 = (p->CSR1 & ~PWR_CSR1_UDRDY) | ((val<<18) & PWR_CSR1_UDRDY); }
inline uint32_t pwr_csr1_get_udrdy(struct PWR_Type* p) { return (p->CSR1 & PWR_CSR1_UDRDY) >> 18 ; }

// PWR->CR2 power control register
enum {
	PWR_CR2_WUPP6 = 1UL<<13, // Wakeup pin polarity bit for PI11
	PWR_CR2_WUPP5 = 1UL<<12, // Wakeup pin polarity bit for PI8
	PWR_CR2_WUPP4 = 1UL<<11, // Wakeup pin polarity bit for PC13
	PWR_CR2_WUPP3 = 1UL<<10, // Wakeup pin polarity bit for PC1
	PWR_CR2_WUPP2 = 1UL<<9, // Wakeup pin polarity bit for PA2
	PWR_CR2_WUPP1 = 1UL<<8, // Wakeup pin polarity bit for PA0
	PWR_CR2_CWUPF6 = 1UL<<5, // Clear Wakeup Pin flag for PI11
	PWR_CR2_CWUPF5 = 1UL<<4, // Clear Wakeup Pin flag for PI8
	PWR_CR2_CWUPF4 = 1UL<<3, // Clear Wakeup Pin flag for PC13
	PWR_CR2_CWUPF3 = 1UL<<2, // Clear Wakeup Pin flag for PC1
	PWR_CR2_CWUPF2 = 1UL<<1, // Clear Wakeup Pin flag for PA2
	PWR_CR2_CWUPF1 = 1UL<<0, // Clear Wakeup Pin flag for PA0		
};

// PWR->CSR2 power control/status register
enum {
	PWR_CSR2_EWUP6 = 1UL<<13, // Enable Wakeup pin for PI11
	PWR_CSR2_EWUP5 = 1UL<<12, // Enable Wakeup pin for PI8
	PWR_CSR2_EWUP4 = 1UL<<11, // Enable Wakeup pin for PC13
	PWR_CSR2_EWUP3 = 1UL<<10, // Enable Wakeup pin for PC1
	PWR_CSR2_EWUP2 = 1UL<<9, // Enable Wakeup pin for PA2
	PWR_CSR2_EWUP1 = 1UL<<8, // Enable Wakeup pin for PA0
	PWR_CSR2_WUPF6 = 1UL<<5, // Wakeup Pin flag for PI11
	PWR_CSR2_WUPF5 = 1UL<<4, // Wakeup Pin flag for PI8
	PWR_CSR2_WUPF4 = 1UL<<3, // Wakeup Pin flag for PC13
	PWR_CSR2_WUPF3 = 1UL<<2, // Wakeup Pin flag for PC1
	PWR_CSR2_WUPF2 = 1UL<<1, // Wakeup Pin flag for PA2
	PWR_CSR2_WUPF1 = 1UL<<0, // Wakeup Pin flag for PA0		
};

/* QuadSPI interface */
struct QUADSPI_Type {
	__IO uint32_t CR; // @0 control register
	__IO uint32_t DCR; // @4 device configuration register
	__I uint16_t SR; // @8 status register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint8_t FCR; // @12 flag clear register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint32_t DLR; // @16 data length register
	__IO uint32_t CCR; // @20 communication configuration register
	__IO uint32_t AR; // @24 address register
	__IO uint32_t ABR; // @28 ABR
	__IO uint32_t DR; // @32 data register
	__IO uint32_t PSMKR; // @36 polling status mask register
	__IO uint32_t PSMAR; // @40 polling status match register
	__IO uint16_t PIR; // @44 polling interval register
	 uint8_t RESERVED2[2]; // @46 
	__IO uint16_t LPTR; // @48 low-power timeout register
};

// QUADSPI->CR control register
enum {
	QUADSPI_CR_PRESCALER = ((1UL<<8)-1) << 24, // Clock prescaler
	QUADSPI_CR_PMM = 1UL<<23, // Polling match mode
	QUADSPI_CR_APMS = 1UL<<22, // Automatic poll mode stop
	QUADSPI_CR_TOIE = 1UL<<20, // TimeOut interrupt enable
	QUADSPI_CR_SMIE = 1UL<<19, // Status match interrupt enable
	QUADSPI_CR_FTIE = 1UL<<18, // FIFO threshold interrupt enable
	QUADSPI_CR_TCIE = 1UL<<17, // Transfer complete interrupt enable
	QUADSPI_CR_TEIE = 1UL<<16, // Transfer error interrupt enable
	QUADSPI_CR_FTHRES = ((1UL<<5)-1) << 8, // IFO threshold level
	QUADSPI_CR_FSEL = 1UL<<7, // FLASH memory selection
	QUADSPI_CR_DFM = 1UL<<6, // Dual-flash mode
	QUADSPI_CR_SSHIFT = 1UL<<4, // Sample shift
	QUADSPI_CR_TCEN = 1UL<<3, // Timeout counter enable
	QUADSPI_CR_DMAEN = 1UL<<2, // DMA enable
	QUADSPI_CR_ABORT = 1UL<<1, // Abort request
	QUADSPI_CR_EN = 1UL<<0, // Enable		
};
inline void quadspi_cr_set_prescaler(struct QUADSPI_Type* p, uint32_t val) { p->CR = (p->CR & ~QUADSPI_CR_PRESCALER) | ((val<<24) & QUADSPI_CR_PRESCALER); }
inline void quadspi_cr_set_fthres(struct QUADSPI_Type* p, uint32_t val) { p->CR = (p->CR & ~QUADSPI_CR_FTHRES) | ((val<<8) & QUADSPI_CR_FTHRES); }
inline uint32_t quadspi_cr_get_prescaler(struct QUADSPI_Type* p) { return (p->CR & QUADSPI_CR_PRESCALER) >> 24 ; }
inline uint32_t quadspi_cr_get_fthres(struct QUADSPI_Type* p) { return (p->CR & QUADSPI_CR_FTHRES) >> 8 ; }

// QUADSPI->DCR device configuration register
enum {
	QUADSPI_DCR_FSIZE = ((1UL<<5)-1) << 16, // FLASH memory size
	QUADSPI_DCR_CSHT = ((1UL<<3)-1) << 8, // Chip select high time
	QUADSPI_DCR_CKMODE = 1UL<<0, // Mode 0 / mode 3		
};
inline void quadspi_dcr_set_fsize(struct QUADSPI_Type* p, uint32_t val) { p->DCR = (p->DCR & ~QUADSPI_DCR_FSIZE) | ((val<<16) & QUADSPI_DCR_FSIZE); }
inline void quadspi_dcr_set_csht(struct QUADSPI_Type* p, uint32_t val) { p->DCR = (p->DCR & ~QUADSPI_DCR_CSHT) | ((val<<8) & QUADSPI_DCR_CSHT); }
inline uint32_t quadspi_dcr_get_fsize(struct QUADSPI_Type* p) { return (p->DCR & QUADSPI_DCR_FSIZE) >> 16 ; }
inline uint32_t quadspi_dcr_get_csht(struct QUADSPI_Type* p) { return (p->DCR & QUADSPI_DCR_CSHT) >> 8 ; }

// QUADSPI->SR status register
enum {
	QUADSPI_SR_FLEVEL = ((1UL<<7)-1) << 8, // FIFO level
	QUADSPI_SR_BUSY = 1UL<<5, // Busy
	QUADSPI_SR_TOF = 1UL<<4, // Timeout flag
	QUADSPI_SR_SMF = 1UL<<3, // Status match flag
	QUADSPI_SR_FTF = 1UL<<2, // FIFO threshold flag
	QUADSPI_SR_TCF = 1UL<<1, // Transfer complete flag
	QUADSPI_SR_TEF = 1UL<<0, // Transfer error flag		
};
inline uint32_t quadspi_sr_get_flevel(struct QUADSPI_Type* p) { return (p->SR & QUADSPI_SR_FLEVEL) >> 8 ; }

// QUADSPI->FCR flag clear register
enum {
	QUADSPI_FCR_CTOF = 1UL<<4, // Clear timeout flag
	QUADSPI_FCR_CSMF = 1UL<<3, // Clear status match flag
	QUADSPI_FCR_CTCF = 1UL<<1, // Clear transfer complete flag
	QUADSPI_FCR_CTEF = 1UL<<0, // Clear transfer error flag		
};

// QUADSPI->CCR communication configuration register
enum {
	QUADSPI_CCR_DDRM = 1UL<<31, // Double data rate mode
	QUADSPI_CCR_DHHC = 1UL<<30, // DDR hold half cycle
	QUADSPI_CCR_SIOO = 1UL<<28, // Send instruction only once mode
	QUADSPI_CCR_FMODE = ((1UL<<2)-1) << 26, // Functional mode
	QUADSPI_CCR_DMODE = ((1UL<<2)-1) << 24, // Data mode
	QUADSPI_CCR_DCYC = ((1UL<<5)-1) << 18, // Number of dummy cycles
	QUADSPI_CCR_ABSIZE = ((1UL<<2)-1) << 16, // Alternate bytes size
	QUADSPI_CCR_ABMODE = ((1UL<<2)-1) << 14, // Alternate bytes mode
	QUADSPI_CCR_ADSIZE = ((1UL<<2)-1) << 12, // Address size
	QUADSPI_CCR_ADMODE = ((1UL<<2)-1) << 10, // Address mode
	QUADSPI_CCR_IMODE = ((1UL<<2)-1) << 8, // Instruction mode
	QUADSPI_CCR_INSTRUCTION = ((1UL<<8)-1) << 0, // Instruction		
};
inline void quadspi_ccr_set_fmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_FMODE) | ((val<<26) & QUADSPI_CCR_FMODE); }
inline void quadspi_ccr_set_dmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_DMODE) | ((val<<24) & QUADSPI_CCR_DMODE); }
inline void quadspi_ccr_set_dcyc(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_DCYC) | ((val<<18) & QUADSPI_CCR_DCYC); }
inline void quadspi_ccr_set_absize(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ABSIZE) | ((val<<16) & QUADSPI_CCR_ABSIZE); }
inline void quadspi_ccr_set_abmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ABMODE) | ((val<<14) & QUADSPI_CCR_ABMODE); }
inline void quadspi_ccr_set_adsize(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ADSIZE) | ((val<<12) & QUADSPI_CCR_ADSIZE); }
inline void quadspi_ccr_set_admode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ADMODE) | ((val<<10) & QUADSPI_CCR_ADMODE); }
inline void quadspi_ccr_set_imode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_IMODE) | ((val<<8) & QUADSPI_CCR_IMODE); }
inline void quadspi_ccr_set_instruction(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_INSTRUCTION) | ((val<<0) & QUADSPI_CCR_INSTRUCTION); }
inline uint32_t quadspi_ccr_get_fmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_FMODE) >> 26 ; }
inline uint32_t quadspi_ccr_get_dmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_DMODE) >> 24 ; }
inline uint32_t quadspi_ccr_get_dcyc(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_DCYC) >> 18 ; }
inline uint32_t quadspi_ccr_get_absize(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ABSIZE) >> 16 ; }
inline uint32_t quadspi_ccr_get_abmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ABMODE) >> 14 ; }
inline uint32_t quadspi_ccr_get_adsize(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ADSIZE) >> 12 ; }
inline uint32_t quadspi_ccr_get_admode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ADMODE) >> 10 ; }
inline uint32_t quadspi_ccr_get_imode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_IMODE) >> 8 ; }
inline uint32_t quadspi_ccr_get_instruction(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_INSTRUCTION) >> 0 ; }

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR; // @0 clock control register
	__IO uint32_t PLLCFGR; // @4 PLL configuration register
	__IO uint32_t CFGR; // @8 clock configuration register
	__IO uint32_t CIR; // @12 clock interrupt register
	__IO uint32_t AHB1RSTR; // @16 AHB1 peripheral reset register
	__IO uint8_t AHB2RSTR; // @20 AHB2 peripheral reset register
	 uint8_t RESERVED0[3]; // @21 
	__IO uint8_t AHB3RSTR; // @24 AHB3 peripheral reset register
	 uint8_t RESERVED1[7]; // @25 
	__IO uint32_t APB1RSTR; // @32 APB1 peripheral reset register
	__IO uint32_t APB2RSTR; // @36 APB2 peripheral reset register
	 uint8_t RESERVED2[8]; // @40 
	__IO uint32_t AHB1ENR; // @48 AHB1 peripheral clock register
	__IO uint8_t AHB2ENR; // @52 AHB2 peripheral clock enable register
	 uint8_t RESERVED3[3]; // @53 
	__IO uint8_t AHB3ENR; // @56 AHB3 peripheral clock enable register
	 uint8_t RESERVED4[7]; // @57 
	__IO uint32_t APB1ENR; // @64 APB1 peripheral clock enable register
	__IO uint32_t APB2ENR; // @68 APB2 peripheral clock enable register
	 uint8_t RESERVED5[8]; // @72 
	__IO uint32_t AHB1LPENR; // @80 AHB1 peripheral clock enable in low power mode register
	__IO uint8_t AHB2LPENR; // @84 AHB2 peripheral clock enable in low power mode register
	 uint8_t RESERVED6[3]; // @85 
	__IO uint8_t AHB3LPENR; // @88 AHB3 peripheral clock enable in low power mode register
	 uint8_t RESERVED7[7]; // @89 
	__IO uint32_t APB1LPENR; // @96 APB1 peripheral clock enable in low power mode register
	__IO uint32_t APB2LPENR; // @100 APB2 peripheral clock enabled in low power mode register
	 uint8_t RESERVED8[8]; // @104 
	__IO uint32_t BDCR; // @112 Backup domain control register
	__IO uint32_t CSR; // @116 clock control & status register
	 uint8_t RESERVED9[8]; // @120 
	__IO uint32_t SSCGR; // @128 spread spectrum clock generation register
	__IO uint32_t PLLI2SCFGR; // @132 PLLI2S configuration register
	__IO uint32_t PLLSAICFGR; // @136 PLL configuration register
	__IO uint32_t DKCFGR1; // @140 dedicated clocks configuration register
	__IO uint32_t DKCFGR2; // @144 dedicated clocks configuration register
};

// RCC->CR clock control register
enum {
	RCC_CR_PLLI2SRDY = 1UL<<27, // PLLI2S clock ready flag
	RCC_CR_PLLI2SON = 1UL<<26, // PLLI2S enable
	RCC_CR_PLLRDY = 1UL<<25, // Main PLL (PLL) clock ready flag
	RCC_CR_PLLON = 1UL<<24, // Main PLL (PLL) enable
	RCC_CR_CSSON = 1UL<<19, // Clock security system enable
	RCC_CR_HSEBYP = 1UL<<18, // HSE clock bypass
	RCC_CR_HSERDY = 1UL<<17, // HSE clock ready flag
	RCC_CR_HSEON = 1UL<<16, // HSE clock enable
	RCC_CR_HSICAL = ((1UL<<8)-1) << 8, // Internal high-speed clock calibration
	RCC_CR_HSITRIM = ((1UL<<5)-1) << 3, // Internal high-speed clock trimming
	RCC_CR_HSIRDY = 1UL<<1, // Internal high-speed clock ready flag
	RCC_CR_HSION = 1UL<<0, // Internal high-speed clock enable		
};
inline void rcc_cr_set_hsical(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_HSICAL) | ((val<<8) & RCC_CR_HSICAL); }
inline void rcc_cr_set_hsitrim(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_HSITRIM) | ((val<<3) & RCC_CR_HSITRIM); }
inline uint32_t rcc_cr_get_hsical(struct RCC_Type* p) { return (p->CR & RCC_CR_HSICAL) >> 8 ; }
inline uint32_t rcc_cr_get_hsitrim(struct RCC_Type* p) { return (p->CR & RCC_CR_HSITRIM) >> 3 ; }

// RCC->PLLCFGR PLL configuration register
enum {
	RCC_PLLCFGR_PLLR = ((1UL<<3)-1) << 28, // Main PLL (PLL) division factor for DSI clocks
	RCC_PLLCFGR_PLLQ = ((1UL<<4)-1) << 24, // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
	RCC_PLLCFGR_PLLSRC = 1UL<<22, // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
	RCC_PLLCFGR_PLLP = ((1UL<<2)-1) << 16, // Main PLL (PLL) division factor for main system clock
	RCC_PLLCFGR_PLLN = ((1UL<<8)-1) << 6, // Main PLL (PLL) multiplication factor for VCO
	RCC_PLLCFGR_PLLM = ((1UL<<6)-1) << 0, // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock		
};
inline void rcc_pllcfgr_set_pllr(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLR) | ((val<<28) & RCC_PLLCFGR_PLLR); }
inline void rcc_pllcfgr_set_pllq(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | ((val<<24) & RCC_PLLCFGR_PLLQ); }
inline void rcc_pllcfgr_set_pllp(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLP) | ((val<<16) & RCC_PLLCFGR_PLLP); }
inline void rcc_pllcfgr_set_plln(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLN) | ((val<<6) & RCC_PLLCFGR_PLLN); }
inline void rcc_pllcfgr_set_pllm(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLM) | ((val<<0) & RCC_PLLCFGR_PLLM); }
inline uint32_t rcc_pllcfgr_get_pllr(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLR) >> 28 ; }
inline uint32_t rcc_pllcfgr_get_pllq(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLQ) >> 24 ; }
inline uint32_t rcc_pllcfgr_get_pllp(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLP) >> 16 ; }
inline uint32_t rcc_pllcfgr_get_plln(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6 ; }
inline uint32_t rcc_pllcfgr_get_pllm(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLM) >> 0 ; }

// RCC->CFGR clock configuration register
enum {
	RCC_CFGR_MCO2 = ((1UL<<2)-1) << 30, // Microcontroller clock output 2
	RCC_CFGR_MCO2PRE = ((1UL<<3)-1) << 27, // MCO2 prescaler
	RCC_CFGR_MCO1PRE = ((1UL<<3)-1) << 24, // MCO1 prescaler
	RCC_CFGR_I2SSRC = 1UL<<23, // I2S clock selection
	RCC_CFGR_MCO1 = ((1UL<<2)-1) << 21, // Microcontroller clock output 1
	RCC_CFGR_RTCPRE = ((1UL<<5)-1) << 16, // HSE division factor for RTC clock
	RCC_CFGR_PPRE2 = ((1UL<<3)-1) << 13, // APB high-speed prescaler (APB2)
	RCC_CFGR_PPRE1 = ((1UL<<3)-1) << 10, // APB Low speed prescaler (APB1)
	RCC_CFGR_HPRE = ((1UL<<4)-1) << 4, // AHB prescaler
	RCC_CFGR_SWS = ((1UL<<2)-1) << 2, // System clock switch status
	RCC_CFGR_SW = ((1UL<<2)-1) << 0, // System clock switch		
};
inline void rcc_cfgr_set_mco2(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO2) | ((val<<30) & RCC_CFGR_MCO2); }
inline void rcc_cfgr_set_mco2pre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO2PRE) | ((val<<27) & RCC_CFGR_MCO2PRE); }
inline void rcc_cfgr_set_mco1pre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO1PRE) | ((val<<24) & RCC_CFGR_MCO1PRE); }
inline void rcc_cfgr_set_mco1(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO1) | ((val<<21) & RCC_CFGR_MCO1); }
inline void rcc_cfgr_set_rtcpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_RTCPRE) | ((val<<16) & RCC_CFGR_RTCPRE); }
inline void rcc_cfgr_set_ppre2(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE2) | ((val<<13) & RCC_CFGR_PPRE2); }
inline void rcc_cfgr_set_ppre1(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE1) | ((val<<10) & RCC_CFGR_PPRE1); }
inline void rcc_cfgr_set_hpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_HPRE) | ((val<<4) & RCC_CFGR_HPRE); }
inline void rcc_cfgr_set_sws(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val<<2) & RCC_CFGR_SWS); }
inline void rcc_cfgr_set_sw(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val<<0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mco2(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO2) >> 30 ; }
inline uint32_t rcc_cfgr_get_mco2pre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO2PRE) >> 27 ; }
inline uint32_t rcc_cfgr_get_mco1pre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO1PRE) >> 24 ; }
inline uint32_t rcc_cfgr_get_mco1(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO1) >> 21 ; }
inline uint32_t rcc_cfgr_get_rtcpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_RTCPRE) >> 16 ; }
inline uint32_t rcc_cfgr_get_ppre2(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE2) >> 13 ; }
inline uint32_t rcc_cfgr_get_ppre1(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE1) >> 10 ; }
inline uint32_t rcc_cfgr_get_hpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_HPRE) >> 4 ; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SWS) >> 2 ; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SW) >> 0 ; }

// RCC->CIR clock interrupt register
enum {
	RCC_CIR_CSSC = 1UL<<23, // Clock security system interrupt clear
	RCC_CIR_PLLSAIRDYC = 1UL<<22, // PLLSAI Ready Interrupt Clear
	RCC_CIR_PLLI2SRDYC = 1UL<<21, // PLLI2S ready interrupt clear
	RCC_CIR_PLLRDYC = 1UL<<20, // Main PLL(PLL) ready interrupt clear
	RCC_CIR_HSERDYC = 1UL<<19, // HSE ready interrupt clear
	RCC_CIR_HSIRDYC = 1UL<<18, // HSI ready interrupt clear
	RCC_CIR_LSERDYC = 1UL<<17, // LSE ready interrupt clear
	RCC_CIR_LSIRDYC = 1UL<<16, // LSI ready interrupt clear
	RCC_CIR_PLLSAIRDYIE = 1UL<<14, // PLLSAI Ready Interrupt Enable
	RCC_CIR_PLLI2SRDYIE = 1UL<<13, // PLLI2S ready interrupt enable
	RCC_CIR_PLLRDYIE = 1UL<<12, // Main PLL (PLL) ready interrupt enable
	RCC_CIR_HSERDYIE = 1UL<<11, // HSE ready interrupt enable
	RCC_CIR_HSIRDYIE = 1UL<<10, // HSI ready interrupt enable
	RCC_CIR_LSERDYIE = 1UL<<9, // LSE ready interrupt enable
	RCC_CIR_LSIRDYIE = 1UL<<8, // LSI ready interrupt enable
	RCC_CIR_CSSF = 1UL<<7, // Clock security system interrupt flag
	RCC_CIR_PLLSAIRDYF = 1UL<<6, // PLLSAI ready interrupt flag
	RCC_CIR_PLLI2SRDYF = 1UL<<5, // PLLI2S ready interrupt flag
	RCC_CIR_PLLRDYF = 1UL<<4, // Main PLL (PLL) ready interrupt flag
	RCC_CIR_HSERDYF = 1UL<<3, // HSE ready interrupt flag
	RCC_CIR_HSIRDYF = 1UL<<2, // HSI ready interrupt flag
	RCC_CIR_LSERDYF = 1UL<<1, // LSE ready interrupt flag
	RCC_CIR_LSIRDYF = 1UL<<0, // LSI ready interrupt flag		
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_OTGHSRST = 1UL<<29, // USB OTG HS module reset
	RCC_AHB1RSTR_ETHMACRST = 1UL<<25, // Ethernet MAC reset
	RCC_AHB1RSTR_DMA2DRST = 1UL<<23, // DMA2D reset
	RCC_AHB1RSTR_DMA2RST = 1UL<<22, // DMA2 reset
	RCC_AHB1RSTR_DMA1RST = 1UL<<21, // DMA2 reset
	RCC_AHB1RSTR_CRCRST = 1UL<<12, // CRC reset
	RCC_AHB1RSTR_GPIOKRST = 1UL<<10, // IO port K reset
	RCC_AHB1RSTR_GPIOJRST = 1UL<<9, // IO port J reset
	RCC_AHB1RSTR_GPIOIRST = 1UL<<8, // IO port I reset
	RCC_AHB1RSTR_GPIOHRST = 1UL<<7, // IO port H reset
	RCC_AHB1RSTR_GPIOGRST = 1UL<<6, // IO port G reset
	RCC_AHB1RSTR_GPIOFRST = 1UL<<5, // IO port F reset
	RCC_AHB1RSTR_GPIOERST = 1UL<<4, // IO port E reset
	RCC_AHB1RSTR_GPIODRST = 1UL<<3, // IO port D reset
	RCC_AHB1RSTR_GPIOCRST = 1UL<<2, // IO port C reset
	RCC_AHB1RSTR_GPIOBRST = 1UL<<1, // IO port B reset
	RCC_AHB1RSTR_GPIOARST = 1UL<<0, // IO port A reset		
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_OTGFSRST = 1UL<<7, // USB OTG FS module reset
	RCC_AHB2RSTR_RNGRST = 1UL<<6, // Random number generator module reset
	RCC_AHB2RSTR_HSAHRST = 1UL<<5, // Hash module reset
	RCC_AHB2RSTR_CRYPRST = 1UL<<4, // Cryptographic module reset
	RCC_AHB2RSTR_DCMIRST = 1UL<<0, // Camera interface reset		
};

// RCC->AHB3RSTR AHB3 peripheral reset register
enum {
	RCC_AHB3RSTR_QSPIRST = 1UL<<1, // Quad SPI memory controller reset
	RCC_AHB3RSTR_FMCRST = 1UL<<0, // Flexible memory controller module reset		
};

// RCC->APB1RSTR APB1 peripheral reset register
enum {
	RCC_APB1RSTR_UART8RST = 1UL<<31, // UART8 reset
	RCC_APB1RSTR_UART7RST = 1UL<<30, // UART7 reset
	RCC_APB1RSTR_DACRST = 1UL<<29, // DAC reset
	RCC_APB1RSTR_PWRRST = 1UL<<28, // Power interface reset
	RCC_APB1RSTR_CECRST = 1UL<<27, // HDMI-CEC reset
	RCC_APB1RSTR_CAN2RST = 1UL<<26, // CAN2 reset
	RCC_APB1RSTR_CAN1RST = 1UL<<25, // CAN1 reset
	RCC_APB1RSTR_I2C4RST = 1UL<<24, // I2C 4 reset
	RCC_APB1RSTR_I2C3RST = 1UL<<23, // I2C3 reset
	RCC_APB1RSTR_I2C2RST = 1UL<<22, // I2C 2 reset
	RCC_APB1RSTR_I2C1RST = 1UL<<21, // I2C 1 reset
	RCC_APB1RSTR_UART5RST = 1UL<<20, // USART 5 reset
	RCC_APB1RSTR_UART4RST = 1UL<<19, // USART 4 reset
	RCC_APB1RSTR_UART3RST = 1UL<<18, // USART 3 reset
	RCC_APB1RSTR_UART2RST = 1UL<<17, // USART 2 reset
	RCC_APB1RSTR_SPDIFRXRST = 1UL<<16, // SPDIF-RX reset
	RCC_APB1RSTR_SPI3RST = 1UL<<15, // SPI 3 reset
	RCC_APB1RSTR_SPI2RST = 1UL<<14, // SPI 2 reset
	RCC_APB1RSTR_WWDGRST = 1UL<<11, // Window watchdog reset
	RCC_APB1RSTR_LPTIM1RST = 1UL<<9, // Low power timer 1 reset
	RCC_APB1RSTR_TIM14RST = 1UL<<8, // TIM14 reset
	RCC_APB1RSTR_TIM13RST = 1UL<<7, // TIM13 reset
	RCC_APB1RSTR_TIM12RST = 1UL<<6, // TIM12 reset
	RCC_APB1RSTR_TIM7RST = 1UL<<5, // TIM7 reset
	RCC_APB1RSTR_TIM6RST = 1UL<<4, // TIM6 reset
	RCC_APB1RSTR_TIM5RST = 1UL<<3, // TIM5 reset
	RCC_APB1RSTR_TIM4RST = 1UL<<2, // TIM4 reset
	RCC_APB1RSTR_TIM3RST = 1UL<<1, // TIM3 reset
	RCC_APB1RSTR_TIM2RST = 1UL<<0, // TIM2 reset		
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_LTDCRST = 1UL<<26, // LTDC reset
	RCC_APB2RSTR_SAI2RST = 1UL<<23, // SAI2 reset
	RCC_APB2RSTR_SAI1RST = 1UL<<22, // SAI1 reset
	RCC_APB2RSTR_SPI6RST = 1UL<<21, // SPI6 reset
	RCC_APB2RSTR_SPI5RST = 1UL<<20, // SPI5 reset
	RCC_APB2RSTR_TIM11RST = 1UL<<18, // TIM11 reset
	RCC_APB2RSTR_TIM10RST = 1UL<<17, // TIM10 reset
	RCC_APB2RSTR_TIM9RST = 1UL<<16, // TIM9 reset
	RCC_APB2RSTR_SYSCFGRST = 1UL<<14, // System configuration controller reset
	RCC_APB2RSTR_SPI4RST = 1UL<<13, // SPI4 reset
	RCC_APB2RSTR_SPI1RST = 1UL<<12, // SPI 1 reset
	RCC_APB2RSTR_SDMMC1RST = 1UL<<11, // SDMMC1 reset
	RCC_APB2RSTR_ADCRST = 1UL<<8, // ADC interface reset (common to all ADCs)
	RCC_APB2RSTR_USART6RST = 1UL<<5, // USART6 reset
	RCC_APB2RSTR_USART1RST = 1UL<<4, // USART1 reset
	RCC_APB2RSTR_TIM8RST = 1UL<<1, // TIM8 reset
	RCC_APB2RSTR_TIM1RST = 1UL<<0, // TIM1 reset		
};

// RCC->AHB1ENR AHB1 peripheral clock register
enum {
	RCC_AHB1ENR_OTGHSULPIEN = 1UL<<30, // USB OTG HSULPI clock enable
	RCC_AHB1ENR_OTGHSEN = 1UL<<29, // USB OTG HS clock enable
	RCC_AHB1ENR_ETHMACPTPEN = 1UL<<28, // Ethernet PTP clock enable
	RCC_AHB1ENR_ETHMACRXEN = 1UL<<27, // Ethernet Reception clock enable
	RCC_AHB1ENR_ETHMACTXEN = 1UL<<26, // Ethernet Transmission clock enable
	RCC_AHB1ENR_ETHMACEN = 1UL<<25, // Ethernet MAC clock enable
	RCC_AHB1ENR_DMA2DEN = 1UL<<23, // DMA2D clock enable
	RCC_AHB1ENR_DMA2EN = 1UL<<22, // DMA2 clock enable
	RCC_AHB1ENR_DMA1EN = 1UL<<21, // DMA1 clock enable
	RCC_AHB1ENR_CCMDATARAMEN = 1UL<<20, // CCM data RAM clock enable
	RCC_AHB1ENR_BKPSRAMEN = 1UL<<18, // Backup SRAM interface clock enable
	RCC_AHB1ENR_CRCEN = 1UL<<12, // CRC clock enable
	RCC_AHB1ENR_GPIOKEN = 1UL<<10, // IO port K clock enable
	RCC_AHB1ENR_GPIOJEN = 1UL<<9, // IO port J clock enable
	RCC_AHB1ENR_GPIOIEN = 1UL<<8, // IO port I clock enable
	RCC_AHB1ENR_GPIOHEN = 1UL<<7, // IO port H clock enable
	RCC_AHB1ENR_GPIOGEN = 1UL<<6, // IO port G clock enable
	RCC_AHB1ENR_GPIOFEN = 1UL<<5, // IO port F clock enable
	RCC_AHB1ENR_GPIOEEN = 1UL<<4, // IO port E clock enable
	RCC_AHB1ENR_GPIODEN = 1UL<<3, // IO port D clock enable
	RCC_AHB1ENR_GPIOCEN = 1UL<<2, // IO port C clock enable
	RCC_AHB1ENR_GPIOBEN = 1UL<<1, // IO port B clock enable
	RCC_AHB1ENR_GPIOAEN = 1UL<<0, // IO port A clock enable		
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_OTGFSEN = 1UL<<7, // USB OTG FS clock enable
	RCC_AHB2ENR_RNGEN = 1UL<<6, // Random number generator clock enable
	RCC_AHB2ENR_HASHEN = 1UL<<5, // Hash modules clock enable
	RCC_AHB2ENR_CRYPEN = 1UL<<4, // Cryptographic modules clock enable
	RCC_AHB2ENR_DCMIEN = 1UL<<0, // Camera interface enable		
};

// RCC->AHB3ENR AHB3 peripheral clock enable register
enum {
	RCC_AHB3ENR_QSPIEN = 1UL<<1, // Quad SPI memory controller clock enable
	RCC_AHB3ENR_FMCEN = 1UL<<0, // Flexible memory controller module clock enable		
};

// RCC->APB1ENR APB1 peripheral clock enable register
enum {
	RCC_APB1ENR_UART8ENR = 1UL<<31, // UART8 clock enable
	RCC_APB1ENR_UART7ENR = 1UL<<30, // UART7 clock enable
	RCC_APB1ENR_DACEN = 1UL<<29, // DAC interface clock enable
	RCC_APB1ENR_PWREN = 1UL<<28, // Power interface clock enable
	RCC_APB1ENR_CECEN = 1UL<<27, // HDMI-CEN clock enable
	RCC_APB1ENR_CAN2EN = 1UL<<26, // CAN 2 clock enable
	RCC_APB1ENR_CAN1EN = 1UL<<25, // CAN 1 clock enable
	RCC_APB1ENR_I2C4EN = 1UL<<24, // I2C4 clock enable
	RCC_APB1ENR_I2C3EN = 1UL<<23, // I2C3 clock enable
	RCC_APB1ENR_I2C2EN = 1UL<<22, // I2C2 clock enable
	RCC_APB1ENR_I2C1EN = 1UL<<21, // I2C1 clock enable
	RCC_APB1ENR_UART5EN = 1UL<<20, // UART5 clock enable
	RCC_APB1ENR_UART4EN = 1UL<<19, // UART4 clock enable
	RCC_APB1ENR_USART3EN = 1UL<<18, // USART3 clock enable
	RCC_APB1ENR_USART2EN = 1UL<<17, // USART 2 clock enable
	RCC_APB1ENR_SPDIFRXEN = 1UL<<16, // SPDIF-RX clock enable
	RCC_APB1ENR_SPI3EN = 1UL<<15, // SPI3 clock enable
	RCC_APB1ENR_SPI2EN = 1UL<<14, // SPI2 clock enable
	RCC_APB1ENR_WWDGEN = 1UL<<11, // Window watchdog clock enable
	RCC_APB1ENR_LPTMI1EN = 1UL<<9, // Low power timer 1 clock enable
	RCC_APB1ENR_TIM14EN = 1UL<<8, // TIM14 clock enable
	RCC_APB1ENR_TIM13EN = 1UL<<7, // TIM13 clock enable
	RCC_APB1ENR_TIM12EN = 1UL<<6, // TIM12 clock enable
	RCC_APB1ENR_TIM7EN = 1UL<<5, // TIM7 clock enable
	RCC_APB1ENR_TIM6EN = 1UL<<4, // TIM6 clock enable
	RCC_APB1ENR_TIM5EN = 1UL<<3, // TIM5 clock enable
	RCC_APB1ENR_TIM4EN = 1UL<<2, // TIM4 clock enable
	RCC_APB1ENR_TIM3EN = 1UL<<1, // TIM3 clock enable
	RCC_APB1ENR_TIM2EN = 1UL<<0, // TIM2 clock enable		
};

// RCC->APB2ENR APB2 peripheral clock enable register
enum {
	RCC_APB2ENR_LTDCEN = 1UL<<26, // LTDC clock enable
	RCC_APB2ENR_SAI2EN = 1UL<<23, // SAI2 clock enable
	RCC_APB2ENR_SAI1EN = 1UL<<22, // SAI1 clock enable
	RCC_APB2ENR_SPI6ENR = 1UL<<21, // SPI6 clock enable
	RCC_APB2ENR_SPI5ENR = 1UL<<20, // SPI5 clock enable
	RCC_APB2ENR_TIM11EN = 1UL<<18, // TIM11 clock enable
	RCC_APB2ENR_TIM10EN = 1UL<<17, // TIM10 clock enable
	RCC_APB2ENR_TIM9EN = 1UL<<16, // TIM9 clock enable
	RCC_APB2ENR_SYSCFGEN = 1UL<<14, // System configuration controller clock enable
	RCC_APB2ENR_SPI4ENR = 1UL<<13, // SPI4 clock enable
	RCC_APB2ENR_SPI1EN = 1UL<<12, // SPI1 clock enable
	RCC_APB2ENR_SDMMC1EN = 1UL<<11, // SDMMC1 clock enable
	RCC_APB2ENR_ADC3EN = 1UL<<10, // ADC3 clock enable
	RCC_APB2ENR_ADC2EN = 1UL<<9, // ADC2 clock enable
	RCC_APB2ENR_ADC1EN = 1UL<<8, // ADC1 clock enable
	RCC_APB2ENR_USART6EN = 1UL<<5, // USART6 clock enable
	RCC_APB2ENR_USART1EN = 1UL<<4, // USART1 clock enable
	RCC_APB2ENR_TIM8EN = 1UL<<1, // TIM8 clock enable
	RCC_APB2ENR_TIM1EN = 1UL<<0, // TIM1 clock enable		
};

// RCC->AHB1LPENR AHB1 peripheral clock enable in low power mode register
enum {
	RCC_AHB1LPENR_OTGHSULPILPEN = 1UL<<30, // USB OTG HS ULPI clock enable during Sleep mode
	RCC_AHB1LPENR_OTGHSLPEN = 1UL<<29, // USB OTG HS clock enable during Sleep mode
	RCC_AHB1LPENR_ETHMACPTPLPEN = 1UL<<28, // Ethernet PTP clock enable during Sleep mode
	RCC_AHB1LPENR_ETHMACRXLPEN = 1UL<<27, // Ethernet reception clock enable during Sleep mode
	RCC_AHB1LPENR_ETHMACTXLPEN = 1UL<<26, // Ethernet transmission clock enable during Sleep mode
	RCC_AHB1LPENR_ETHMACLPEN = 1UL<<25, // Ethernet MAC clock enable during Sleep mode
	RCC_AHB1LPENR_DMA2DLPEN = 1UL<<23, // DMA2D clock enable during Sleep mode
	RCC_AHB1LPENR_DMA2LPEN = 1UL<<22, // DMA2 clock enable during Sleep mode
	RCC_AHB1LPENR_DMA1LPEN = 1UL<<21, // DMA1 clock enable during Sleep mode
	RCC_AHB1LPENR_SRAM3LPEN = 1UL<<19, // SRAM 3 interface clock enable during Sleep mode
	RCC_AHB1LPENR_BKPSRAMLPEN = 1UL<<18, // Backup SRAM interface clock enable during Sleep mode
	RCC_AHB1LPENR_SRAM2LPEN = 1UL<<17, // SRAM 2 interface clock enable during Sleep mode
	RCC_AHB1LPENR_SRAM1LPEN = 1UL<<16, // SRAM 1interface clock enable during Sleep mode
	RCC_AHB1LPENR_FLITFLPEN = 1UL<<15, // Flash interface clock enable during Sleep mode
	RCC_AHB1LPENR_CRCLPEN = 1UL<<12, // CRC clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOKLPEN = 1UL<<10, // IO port K clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOJLPEN = 1UL<<9, // IO port J clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOILPEN = 1UL<<8, // IO port I clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOHLPEN = 1UL<<7, // IO port H clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOGLPEN = 1UL<<6, // IO port G clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOFLPEN = 1UL<<5, // IO port F clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOELPEN = 1UL<<4, // IO port E clock enable during Sleep mode
	RCC_AHB1LPENR_GPIODLPEN = 1UL<<3, // IO port D clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOCLPEN = 1UL<<2, // IO port C clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOBLPEN = 1UL<<1, // IO port B clock enable during Sleep mode
	RCC_AHB1LPENR_GPIOALPEN = 1UL<<0, // IO port A clock enable during sleep mode		
};

// RCC->AHB2LPENR AHB2 peripheral clock enable in low power mode register
enum {
	RCC_AHB2LPENR_OTGFSLPEN = 1UL<<7, // USB OTG FS clock enable during Sleep mode
	RCC_AHB2LPENR_RNGLPEN = 1UL<<6, // Random number generator clock enable during Sleep mode
	RCC_AHB2LPENR_HASHLPEN = 1UL<<5, // Hash modules clock enable during Sleep mode
	RCC_AHB2LPENR_CRYPLPEN = 1UL<<4, // Cryptography modules clock enable during Sleep mode
	RCC_AHB2LPENR_DCMILPEN = 1UL<<0, // Camera interface enable during Sleep mode		
};

// RCC->AHB3LPENR AHB3 peripheral clock enable in low power mode register
enum {
	RCC_AHB3LPENR_QSPILPEN = 1UL<<1, // Quand SPI memory controller clock enable during Sleep mode
	RCC_AHB3LPENR_FMCLPEN = 1UL<<0, // Flexible memory controller module clock enable during Sleep mode		
};

// RCC->APB1LPENR APB1 peripheral clock enable in low power mode register
enum {
	RCC_APB1LPENR_UART8LPEN = 1UL<<31, // UART8 clock enable during Sleep mode
	RCC_APB1LPENR_UART7LPEN = 1UL<<30, // UART7 clock enable during Sleep mode
	RCC_APB1LPENR_DACLPEN = 1UL<<29, // DAC interface clock enable during Sleep mode
	RCC_APB1LPENR_PWRLPEN = 1UL<<28, // Power interface clock enable during Sleep mode
	RCC_APB1LPENR_CECLPEN = 1UL<<27, // HDMI-CEN clock enable during Sleep mode
	RCC_APB1LPENR_CAN2LPEN = 1UL<<26, // CAN 2 clock enable during Sleep mode
	RCC_APB1LPENR_CAN1LPEN = 1UL<<25, // CAN 1 clock enable during Sleep mode
	RCC_APB1LPENR_I2C4LPEN = 1UL<<24, // I2C4 clock enable during Sleep mode
	RCC_APB1LPENR_I2C3LPEN = 1UL<<23, // I2C3 clock enable during Sleep mode
	RCC_APB1LPENR_I2C2LPEN = 1UL<<22, // I2C2 clock enable during Sleep mode
	RCC_APB1LPENR_I2C1LPEN = 1UL<<21, // I2C1 clock enable during Sleep mode
	RCC_APB1LPENR_UART5LPEN = 1UL<<20, // UART5 clock enable during Sleep mode
	RCC_APB1LPENR_UART4LPEN = 1UL<<19, // UART4 clock enable during Sleep mode
	RCC_APB1LPENR_USART3LPEN = 1UL<<18, // USART3 clock enable during Sleep mode
	RCC_APB1LPENR_USART2LPEN = 1UL<<17, // USART2 clock enable during Sleep mode
	RCC_APB1LPENR_SPDIFRXLPEN = 1UL<<16, // SPDIF-RX clock enable during sleep mode
	RCC_APB1LPENR_SPI3LPEN = 1UL<<15, // SPI3 clock enable during Sleep mode
	RCC_APB1LPENR_SPI2LPEN = 1UL<<14, // SPI2 clock enable during Sleep mode
	RCC_APB1LPENR_WWDGLPEN = 1UL<<11, // Window watchdog clock enable during Sleep mode
	RCC_APB1LPENR_LPTIM1LPEN = 1UL<<9, // low power timer 1 clock enable during Sleep mode
	RCC_APB1LPENR_TIM14LPEN = 1UL<<8, // TIM14 clock enable during Sleep mode
	RCC_APB1LPENR_TIM13LPEN = 1UL<<7, // TIM13 clock enable during Sleep mode
	RCC_APB1LPENR_TIM12LPEN = 1UL<<6, // TIM12 clock enable during Sleep mode
	RCC_APB1LPENR_TIM7LPEN = 1UL<<5, // TIM7 clock enable during Sleep mode
	RCC_APB1LPENR_TIM6LPEN = 1UL<<4, // TIM6 clock enable during Sleep mode
	RCC_APB1LPENR_TIM5LPEN = 1UL<<3, // TIM5 clock enable during Sleep mode
	RCC_APB1LPENR_TIM4LPEN = 1UL<<2, // TIM4 clock enable during Sleep mode
	RCC_APB1LPENR_TIM3LPEN = 1UL<<1, // TIM3 clock enable during Sleep mode
	RCC_APB1LPENR_TIM2LPEN = 1UL<<0, // TIM2 clock enable during Sleep mode		
};

// RCC->APB2LPENR APB2 peripheral clock enabled in low power mode register
enum {
	RCC_APB2LPENR_LTDCLPEN = 1UL<<26, // LTDC clock enable during sleep mode
	RCC_APB2LPENR_SAI2LPEN = 1UL<<23, // SAI2 clock enable during sleep mode
	RCC_APB2LPENR_SAI1LPEN = 1UL<<22, // SAI1 clock enable during sleep mode
	RCC_APB2LPENR_SPI6LPEN = 1UL<<21, // SPI 6 clock enable during Sleep mode
	RCC_APB2LPENR_SPI5LPEN = 1UL<<20, // SPI 5 clock enable during Sleep mode
	RCC_APB2LPENR_TIM11LPEN = 1UL<<18, // TIM11 clock enable during Sleep mode
	RCC_APB2LPENR_TIM10LPEN = 1UL<<17, // TIM10 clock enable during Sleep mode
	RCC_APB2LPENR_TIM9LPEN = 1UL<<16, // TIM9 clock enable during sleep mode
	RCC_APB2LPENR_SYSCFGLPEN = 1UL<<14, // System configuration controller clock enable during Sleep mode
	RCC_APB2LPENR_SPI4LPEN = 1UL<<13, // SPI 4 clock enable during Sleep mode
	RCC_APB2LPENR_SPI1LPEN = 1UL<<12, // SPI 1 clock enable during Sleep mode
	RCC_APB2LPENR_SDMMC1LPEN = 1UL<<11, // SDMMC1 clock enable during Sleep mode
	RCC_APB2LPENR_ADC3LPEN = 1UL<<10, // ADC 3 clock enable during Sleep mode
	RCC_APB2LPENR_ADC2LPEN = 1UL<<9, // ADC2 clock enable during Sleep mode
	RCC_APB2LPENR_ADC1LPEN = 1UL<<8, // ADC1 clock enable during Sleep mode
	RCC_APB2LPENR_USART6LPEN = 1UL<<5, // USART6 clock enable during Sleep mode
	RCC_APB2LPENR_USART1LPEN = 1UL<<4, // USART1 clock enable during Sleep mode
	RCC_APB2LPENR_TIM8LPEN = 1UL<<1, // TIM8 clock enable during Sleep mode
	RCC_APB2LPENR_TIM1LPEN = 1UL<<0, // TIM1 clock enable during Sleep mode		
};

// RCC->BDCR Backup domain control register
enum {
	RCC_BDCR_BDRST = 1UL<<16, // Backup domain software reset
	RCC_BDCR_RTCEN = 1UL<<15, // RTC clock enable
	RCC_BDCR_RTCSEL1 = 1UL<<9, // RTC clock source selection
	RCC_BDCR_RTCSEL0 = 1UL<<8, // RTC clock source selection
	RCC_BDCR_LSEBYP = 1UL<<2, // External low-speed oscillator bypass
	RCC_BDCR_LSERDY = 1UL<<1, // External low-speed oscillator ready
	RCC_BDCR_LSEON = 1UL<<0, // External low-speed oscillator enable		
};

// RCC->CSR clock control & status register
enum {
	RCC_CSR_LPWRRSTF = 1UL<<31, // Low-power reset flag
	RCC_CSR_WWDGRSTF = 1UL<<30, // Window watchdog reset flag
	RCC_CSR_WDGRSTF = 1UL<<29, // Independent watchdog reset flag
	RCC_CSR_SFTRSTF = 1UL<<28, // Software reset flag
	RCC_CSR_PORRSTF = 1UL<<27, // POR/PDR reset flag
	RCC_CSR_PADRSTF = 1UL<<26, // PIN reset flag
	RCC_CSR_BORRSTF = 1UL<<25, // BOR reset flag
	RCC_CSR_RMVF = 1UL<<24, // Remove reset flag
	RCC_CSR_LSIRDY = 1UL<<1, // Internal low-speed oscillator ready
	RCC_CSR_LSION = 1UL<<0, // Internal low-speed oscillator enable		
};

// RCC->SSCGR spread spectrum clock generation register
enum {
	RCC_SSCGR_SSCGEN = 1UL<<31, // Spread spectrum modulation enable
	RCC_SSCGR_SPREADSEL = 1UL<<30, // Spread Select
	RCC_SSCGR_INCSTEP = ((1UL<<15)-1) << 13, // Incrementation step
	RCC_SSCGR_MODPER = ((1UL<<13)-1) << 0, // Modulation period		
};
inline void rcc_sscgr_set_incstep(struct RCC_Type* p, uint32_t val) { p->SSCGR = (p->SSCGR & ~RCC_SSCGR_INCSTEP) | ((val<<13) & RCC_SSCGR_INCSTEP); }
inline void rcc_sscgr_set_modper(struct RCC_Type* p, uint32_t val) { p->SSCGR = (p->SSCGR & ~RCC_SSCGR_MODPER) | ((val<<0) & RCC_SSCGR_MODPER); }
inline uint32_t rcc_sscgr_get_incstep(struct RCC_Type* p) { return (p->SSCGR & RCC_SSCGR_INCSTEP) >> 13 ; }
inline uint32_t rcc_sscgr_get_modper(struct RCC_Type* p) { return (p->SSCGR & RCC_SSCGR_MODPER) >> 0 ; }

// RCC->PLLI2SCFGR PLLI2S configuration register
enum {
	RCC_PLLI2SCFGR_PLLI2SR = ((1UL<<3)-1) << 28, // PLLI2S division factor for I2S clocks
	RCC_PLLI2SCFGR_PLLI2SQ = ((1UL<<4)-1) << 24, // PLLI2S division factor for SAI1 clock
	RCC_PLLI2SCFGR_PLLI2SN = ((1UL<<9)-1) << 6, // PLLI2S multiplication factor for VCO		
};
inline void rcc_plli2scfgr_set_plli2sr(struct RCC_Type* p, uint32_t val) { p->PLLI2SCFGR = (p->PLLI2SCFGR & ~RCC_PLLI2SCFGR_PLLI2SR) | ((val<<28) & RCC_PLLI2SCFGR_PLLI2SR); }
inline void rcc_plli2scfgr_set_plli2sq(struct RCC_Type* p, uint32_t val) { p->PLLI2SCFGR = (p->PLLI2SCFGR & ~RCC_PLLI2SCFGR_PLLI2SQ) | ((val<<24) & RCC_PLLI2SCFGR_PLLI2SQ); }
inline void rcc_plli2scfgr_set_plli2sn(struct RCC_Type* p, uint32_t val) { p->PLLI2SCFGR = (p->PLLI2SCFGR & ~RCC_PLLI2SCFGR_PLLI2SN) | ((val<<6) & RCC_PLLI2SCFGR_PLLI2SN); }
inline uint32_t rcc_plli2scfgr_get_plli2sr(struct RCC_Type* p) { return (p->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28 ; }
inline uint32_t rcc_plli2scfgr_get_plli2sq(struct RCC_Type* p) { return (p->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24 ; }
inline uint32_t rcc_plli2scfgr_get_plli2sn(struct RCC_Type* p) { return (p->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6 ; }

// RCC->PLLSAICFGR PLL configuration register
enum {
	RCC_PLLSAICFGR_PLLSAIR = ((1UL<<3)-1) << 28, // PLLSAI division factor for LCD clock
	RCC_PLLSAICFGR_PLLSAIQ = ((1UL<<4)-1) << 24, // PLLSAI division factor for SAI clock
	RCC_PLLSAICFGR_PLLSAIP = ((1UL<<2)-1) << 16, // PLLSAI division factor for 48MHz clock
	RCC_PLLSAICFGR_PLLSAIN = ((1UL<<9)-1) << 6, // PLLSAI division factor for VCO		
};
inline void rcc_pllsaicfgr_set_pllsair(struct RCC_Type* p, uint32_t val) { p->PLLSAICFGR = (p->PLLSAICFGR & ~RCC_PLLSAICFGR_PLLSAIR) | ((val<<28) & RCC_PLLSAICFGR_PLLSAIR); }
inline void rcc_pllsaicfgr_set_pllsaiq(struct RCC_Type* p, uint32_t val) { p->PLLSAICFGR = (p->PLLSAICFGR & ~RCC_PLLSAICFGR_PLLSAIQ) | ((val<<24) & RCC_PLLSAICFGR_PLLSAIQ); }
inline void rcc_pllsaicfgr_set_pllsaip(struct RCC_Type* p, uint32_t val) { p->PLLSAICFGR = (p->PLLSAICFGR & ~RCC_PLLSAICFGR_PLLSAIP) | ((val<<16) & RCC_PLLSAICFGR_PLLSAIP); }
inline void rcc_pllsaicfgr_set_pllsain(struct RCC_Type* p, uint32_t val) { p->PLLSAICFGR = (p->PLLSAICFGR & ~RCC_PLLSAICFGR_PLLSAIN) | ((val<<6) & RCC_PLLSAICFGR_PLLSAIN); }
inline uint32_t rcc_pllsaicfgr_get_pllsair(struct RCC_Type* p) { return (p->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> 28 ; }
inline uint32_t rcc_pllsaicfgr_get_pllsaiq(struct RCC_Type* p) { return (p->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24 ; }
inline uint32_t rcc_pllsaicfgr_get_pllsaip(struct RCC_Type* p) { return (p->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> 16 ; }
inline uint32_t rcc_pllsaicfgr_get_pllsain(struct RCC_Type* p) { return (p->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6 ; }

// RCC->DKCFGR1 dedicated clocks configuration register
enum {
	RCC_DKCFGR1_TIMPRE = 1UL<<24, // Timers clocks prescalers selection
	RCC_DKCFGR1_SAI2SEL = ((1UL<<2)-1) << 22, // SAI2 clock source selection
	RCC_DKCFGR1_SAI1SEL = ((1UL<<2)-1) << 20, // SAI1 clock source selection
	RCC_DKCFGR1_PLLSAIDIVR = ((1UL<<2)-1) << 16, // division factor for LCD_CLK
	RCC_DKCFGR1_PLLSAIDIVQ = ((1UL<<5)-1) << 8, // PLLSAI division factor for SAI1 clock
	RCC_DKCFGR1_PLLI2SDIV = ((1UL<<5)-1) << 0, // PLLI2S division factor for SAI1 clock		
};
inline void rcc_dkcfgr1_set_sai2sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR1 = (p->DKCFGR1 & ~RCC_DKCFGR1_SAI2SEL) | ((val<<22) & RCC_DKCFGR1_SAI2SEL); }
inline void rcc_dkcfgr1_set_sai1sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR1 = (p->DKCFGR1 & ~RCC_DKCFGR1_SAI1SEL) | ((val<<20) & RCC_DKCFGR1_SAI1SEL); }
inline void rcc_dkcfgr1_set_pllsaidivr(struct RCC_Type* p, uint32_t val) { p->DKCFGR1 = (p->DKCFGR1 & ~RCC_DKCFGR1_PLLSAIDIVR) | ((val<<16) & RCC_DKCFGR1_PLLSAIDIVR); }
inline void rcc_dkcfgr1_set_pllsaidivq(struct RCC_Type* p, uint32_t val) { p->DKCFGR1 = (p->DKCFGR1 & ~RCC_DKCFGR1_PLLSAIDIVQ) | ((val<<8) & RCC_DKCFGR1_PLLSAIDIVQ); }
inline void rcc_dkcfgr1_set_plli2sdiv(struct RCC_Type* p, uint32_t val) { p->DKCFGR1 = (p->DKCFGR1 & ~RCC_DKCFGR1_PLLI2SDIV) | ((val<<0) & RCC_DKCFGR1_PLLI2SDIV); }
inline uint32_t rcc_dkcfgr1_get_sai2sel(struct RCC_Type* p) { return (p->DKCFGR1 & RCC_DKCFGR1_SAI2SEL) >> 22 ; }
inline uint32_t rcc_dkcfgr1_get_sai1sel(struct RCC_Type* p) { return (p->DKCFGR1 & RCC_DKCFGR1_SAI1SEL) >> 20 ; }
inline uint32_t rcc_dkcfgr1_get_pllsaidivr(struct RCC_Type* p) { return (p->DKCFGR1 & RCC_DKCFGR1_PLLSAIDIVR) >> 16 ; }
inline uint32_t rcc_dkcfgr1_get_pllsaidivq(struct RCC_Type* p) { return (p->DKCFGR1 & RCC_DKCFGR1_PLLSAIDIVQ) >> 8 ; }
inline uint32_t rcc_dkcfgr1_get_plli2sdiv(struct RCC_Type* p) { return (p->DKCFGR1 & RCC_DKCFGR1_PLLI2SDIV) >> 0 ; }

// RCC->DKCFGR2 dedicated clocks configuration register
enum {
	RCC_DKCFGR2_SDMMCSEL = 1UL<<28, // SDMMC clock source selection
	RCC_DKCFGR2_CK48MSEL = 1UL<<27, // 48MHz clock source selection
	RCC_DKCFGR2_CECSEL = 1UL<<26, // HDMI-CEC clock source selection
	RCC_DKCFGR2_LPTIM1SEL = ((1UL<<2)-1) << 24, // Low power timer 1 clock source selection
	RCC_DKCFGR2_I2C4SEL = ((1UL<<2)-1) << 22, // I2C4 clock source selection
	RCC_DKCFGR2_I2C3SEL = ((1UL<<2)-1) << 20, // I2C3 clock source selection
	RCC_DKCFGR2_I2C2SEL = ((1UL<<2)-1) << 18, // I2C2 clock source selection
	RCC_DKCFGR2_I2C1SEL = ((1UL<<2)-1) << 16, // I2C1 clock source selection
	RCC_DKCFGR2_UART8SEL = ((1UL<<2)-1) << 14, // UART 8 clock source selection
	RCC_DKCFGR2_UART7SEL = ((1UL<<2)-1) << 12, // UART 7 clock source selection
	RCC_DKCFGR2_USART6SEL = ((1UL<<2)-1) << 10, // USART 6 clock source selection
	RCC_DKCFGR2_UART5SEL = ((1UL<<2)-1) << 8, // UART 5 clock source selection
	RCC_DKCFGR2_UART4SEL = ((1UL<<2)-1) << 6, // UART 4 clock source selection
	RCC_DKCFGR2_USART3SEL = ((1UL<<2)-1) << 4, // USART 3 clock source selection
	RCC_DKCFGR2_USART2SEL = ((1UL<<2)-1) << 2, // USART 2 clock source selection
	RCC_DKCFGR2_USART1SEL = ((1UL<<2)-1) << 0, // USART 1 clock source selection		
};
inline void rcc_dkcfgr2_set_lptim1sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_LPTIM1SEL) | ((val<<24) & RCC_DKCFGR2_LPTIM1SEL); }
inline void rcc_dkcfgr2_set_i2c4sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_I2C4SEL) | ((val<<22) & RCC_DKCFGR2_I2C4SEL); }
inline void rcc_dkcfgr2_set_i2c3sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_I2C3SEL) | ((val<<20) & RCC_DKCFGR2_I2C3SEL); }
inline void rcc_dkcfgr2_set_i2c2sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_I2C2SEL) | ((val<<18) & RCC_DKCFGR2_I2C2SEL); }
inline void rcc_dkcfgr2_set_i2c1sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_I2C1SEL) | ((val<<16) & RCC_DKCFGR2_I2C1SEL); }
inline void rcc_dkcfgr2_set_uart8sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_UART8SEL) | ((val<<14) & RCC_DKCFGR2_UART8SEL); }
inline void rcc_dkcfgr2_set_uart7sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_UART7SEL) | ((val<<12) & RCC_DKCFGR2_UART7SEL); }
inline void rcc_dkcfgr2_set_usart6sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_USART6SEL) | ((val<<10) & RCC_DKCFGR2_USART6SEL); }
inline void rcc_dkcfgr2_set_uart5sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_UART5SEL) | ((val<<8) & RCC_DKCFGR2_UART5SEL); }
inline void rcc_dkcfgr2_set_uart4sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_UART4SEL) | ((val<<6) & RCC_DKCFGR2_UART4SEL); }
inline void rcc_dkcfgr2_set_usart3sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_USART3SEL) | ((val<<4) & RCC_DKCFGR2_USART3SEL); }
inline void rcc_dkcfgr2_set_usart2sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_USART2SEL) | ((val<<2) & RCC_DKCFGR2_USART2SEL); }
inline void rcc_dkcfgr2_set_usart1sel(struct RCC_Type* p, uint32_t val) { p->DKCFGR2 = (p->DKCFGR2 & ~RCC_DKCFGR2_USART1SEL) | ((val<<0) & RCC_DKCFGR2_USART1SEL); }
inline uint32_t rcc_dkcfgr2_get_lptim1sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_LPTIM1SEL) >> 24 ; }
inline uint32_t rcc_dkcfgr2_get_i2c4sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_I2C4SEL) >> 22 ; }
inline uint32_t rcc_dkcfgr2_get_i2c3sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_I2C3SEL) >> 20 ; }
inline uint32_t rcc_dkcfgr2_get_i2c2sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_I2C2SEL) >> 18 ; }
inline uint32_t rcc_dkcfgr2_get_i2c1sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_I2C1SEL) >> 16 ; }
inline uint32_t rcc_dkcfgr2_get_uart8sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_UART8SEL) >> 14 ; }
inline uint32_t rcc_dkcfgr2_get_uart7sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_UART7SEL) >> 12 ; }
inline uint32_t rcc_dkcfgr2_get_usart6sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_USART6SEL) >> 10 ; }
inline uint32_t rcc_dkcfgr2_get_uart5sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_UART5SEL) >> 8 ; }
inline uint32_t rcc_dkcfgr2_get_uart4sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_UART4SEL) >> 6 ; }
inline uint32_t rcc_dkcfgr2_get_usart3sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_USART3SEL) >> 4 ; }
inline uint32_t rcc_dkcfgr2_get_usart2sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_USART2SEL) >> 2 ; }
inline uint32_t rcc_dkcfgr2_get_usart1sel(struct RCC_Type* p) { return (p->DKCFGR2 & RCC_DKCFGR2_USART1SEL) >> 0 ; }

/* Random number generator */
struct RNG_Type {
	__IO uint8_t CR; // @0 control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t SR; // @4 status register
	 uint8_t RESERVED1[3]; // @5 
	__I uint32_t DR; // @8 data register
};

// RNG->CR control register
enum {
	RNG_CR_IE = 1UL<<3, // Interrupt enable
	RNG_CR_RNGEN = 1UL<<2, // Random number generator enable		
};

// RNG->SR status register
enum {
	RNG_SR_SEIS = 1UL<<6, // Seed error interrupt status
	RNG_SR_CEIS = 1UL<<5, // Clock error interrupt status
	RNG_SR_SECS = 1UL<<2, // Seed error current status
	RNG_SR_CECS = 1UL<<1, // Clock error current status
	RNG_SR_DRDY = 1UL<<0, // Data ready		
};

/* Real-time clock */
struct RTC_Type {
	__IO uint32_t TR; // @0 time register
	__IO uint32_t DR; // @4 date register
	__IO uint32_t CR; // @8 control register
	__IO uint32_t ISR; // @12 initialization and status register
	__IO uint32_t PRER; // @16 prescaler register
	__IO uint16_t WUTR; // @20 wakeup timer register
	 uint8_t RESERVED0[6]; // @22 
	__IO uint32_t ALRMAR; // @28 alarm A register
	__IO uint32_t ALRMBR; // @32 alarm B register
	__O uint8_t WPR; // @36 write protection register
	 uint8_t RESERVED1[3]; // @37 
	__I uint16_t SSR; // @40 sub second register
	 uint8_t RESERVED2[2]; // @42 
	__O uint32_t SHIFTR; // @44 shift control register
	__I uint32_t TSTR; // @48 time stamp time register
	__I uint16_t TSDR; // @52 time stamp date register
	 uint8_t RESERVED3[2]; // @54 
	__I uint16_t TSSSR; // @56 timestamp sub second register
	 uint8_t RESERVED4[2]; // @58 
	__IO uint16_t CALR; // @60 calibration register
	 uint8_t RESERVED5[2]; // @62 
	__IO uint32_t TAMPCR; // @64 tamper configuration register
	__IO uint32_t ALRMASSR; // @68 alarm A sub second register
	__IO uint32_t ALRMBSSR; // @72 alarm B sub second register
	__IO uint8_t OR; // @76 option register
	 uint8_t RESERVED6[3]; // @77 
	__IO uint32_t BKP0R; // @80 backup register
	__IO uint32_t BKP1R; // @84 backup register
	__IO uint32_t BKP2R; // @88 backup register
	__IO uint32_t BKP3R; // @92 backup register
	__IO uint32_t BKP4R; // @96 backup register
	__IO uint32_t BKP5R; // @100 backup register
	__IO uint32_t BKP6R; // @104 backup register
	__IO uint32_t BKP7R; // @108 backup register
	__IO uint32_t BKP8R; // @112 backup register
	__IO uint32_t BKP9R; // @116 backup register
	__IO uint32_t BKP10R; // @120 backup register
	__IO uint32_t BKP11R; // @124 backup register
	__IO uint32_t BKP12R; // @128 backup register
	__IO uint32_t BKP13R; // @132 backup register
	__IO uint32_t BKP14R; // @136 backup register
	__IO uint32_t BKP15R; // @140 backup register
	__IO uint32_t BKP16R; // @144 backup register
	__IO uint32_t BKP17R; // @148 backup register
	__IO uint32_t BKP18R; // @152 backup register
	__IO uint32_t BKP19R; // @156 backup register
	__IO uint32_t BKP20R; // @160 backup register
	__IO uint32_t BKP21R; // @164 backup register
	__IO uint32_t BKP22R; // @168 backup register
	__IO uint32_t BKP23R; // @172 backup register
	__IO uint32_t BKP24R; // @176 backup register
	__IO uint32_t BKP25R; // @180 backup register
	__IO uint32_t BKP26R; // @184 backup register
	__IO uint32_t BKP27R; // @188 backup register
	__IO uint32_t BKP28R; // @192 backup register
	__IO uint32_t BKP29R; // @196 backup register
	__IO uint32_t BKP30R; // @200 backup register
	__IO uint32_t BKP31R; // @204 backup register
};

// RTC->TR time register
enum {
	RTC_TR_PM = 1UL<<22, // AM/PM notation
	RTC_TR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_tr_set_ht(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HT) | ((val<<20) & RTC_TR_HT); }
inline void rtc_tr_set_hu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HU) | ((val<<16) & RTC_TR_HU); }
inline void rtc_tr_set_mnt(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNT) | ((val<<12) & RTC_TR_MNT); }
inline void rtc_tr_set_mnu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNU) | ((val<<8) & RTC_TR_MNU); }
inline void rtc_tr_set_st(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_ST) | ((val<<4) & RTC_TR_ST); }
inline void rtc_tr_set_su(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_SU) | ((val<<0) & RTC_TR_SU); }
inline uint32_t rtc_tr_get_ht(struct RTC_Type* p) { return (p->TR & RTC_TR_HT) >> 20 ; }
inline uint32_t rtc_tr_get_hu(struct RTC_Type* p) { return (p->TR & RTC_TR_HU) >> 16 ; }
inline uint32_t rtc_tr_get_mnt(struct RTC_Type* p) { return (p->TR & RTC_TR_MNT) >> 12 ; }
inline uint32_t rtc_tr_get_mnu(struct RTC_Type* p) { return (p->TR & RTC_TR_MNU) >> 8 ; }
inline uint32_t rtc_tr_get_st(struct RTC_Type* p) { return (p->TR & RTC_TR_ST) >> 4 ; }
inline uint32_t rtc_tr_get_su(struct RTC_Type* p) { return (p->TR & RTC_TR_SU) >> 0 ; }

// RTC->DR date register
enum {
	RTC_DR_YT = ((1UL<<4)-1) << 20, // Year tens in BCD format
	RTC_DR_YU = ((1UL<<4)-1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_DR_MT = 1UL<<12, // Month tens in BCD format
	RTC_DR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_DR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_DR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline void rtc_dr_set_yt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YT) | ((val<<20) & RTC_DR_YT); }
inline void rtc_dr_set_yu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YU) | ((val<<16) & RTC_DR_YU); }
inline void rtc_dr_set_wdu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_WDU) | ((val<<13) & RTC_DR_WDU); }
inline void rtc_dr_set_mu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_MU) | ((val<<8) & RTC_DR_MU); }
inline void rtc_dr_set_dt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DT) | ((val<<4) & RTC_DR_DT); }
inline void rtc_dr_set_du(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DU) | ((val<<0) & RTC_DR_DU); }
inline uint32_t rtc_dr_get_yt(struct RTC_Type* p) { return (p->DR & RTC_DR_YT) >> 20 ; }
inline uint32_t rtc_dr_get_yu(struct RTC_Type* p) { return (p->DR & RTC_DR_YU) >> 16 ; }
inline uint32_t rtc_dr_get_wdu(struct RTC_Type* p) { return (p->DR & RTC_DR_WDU) >> 13 ; }
inline uint32_t rtc_dr_get_mu(struct RTC_Type* p) { return (p->DR & RTC_DR_MU) >> 8 ; }
inline uint32_t rtc_dr_get_dt(struct RTC_Type* p) { return (p->DR & RTC_DR_DT) >> 4 ; }
inline uint32_t rtc_dr_get_du(struct RTC_Type* p) { return (p->DR & RTC_DR_DU) >> 0 ; }

// RTC->CR control register
enum {
	RTC_CR_ITSE = 1UL<<24, // timestamp on internal event enable
	RTC_CR_COE = 1UL<<23, // Calibration output enable
	RTC_CR_OSEL = ((1UL<<2)-1) << 21, // Output selection
	RTC_CR_POL = 1UL<<20, // Output polarity
	RTC_CR_COSEL = 1UL<<19, // Calibration output selection
	RTC_CR_BKP = 1UL<<18, // Backup
	RTC_CR_SUB1H = 1UL<<17, // Subtract 1 hour (winter time change)
	RTC_CR_ADD1H = 1UL<<16, // Add 1 hour (summer time change)
	RTC_CR_TSIE = 1UL<<15, // Time-stamp interrupt enable
	RTC_CR_WUTIE = 1UL<<14, // Wakeup timer interrupt enable
	RTC_CR_ALRBIE = 1UL<<13, // Alarm B interrupt enable
	RTC_CR_ALRAIE = 1UL<<12, // Alarm A interrupt enable
	RTC_CR_TSE = 1UL<<11, // Time stamp enable
	RTC_CR_WUTE = 1UL<<10, // Wakeup timer enable
	RTC_CR_ALRBE = 1UL<<9, // Alarm B enable
	RTC_CR_ALRAE = 1UL<<8, // Alarm A enable
	RTC_CR_FMT = 1UL<<6, // Hour format
	RTC_CR_BYPSHAD = 1UL<<5, // Bypass the shadow registers
	RTC_CR_REFCKON = 1UL<<4, // Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE = 1UL<<3, // Time-stamp event active edge
	RTC_CR_WCKSEL = ((1UL<<3)-1) << 0, // Wakeup clock selection		
};
inline void rtc_cr_set_osel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_OSEL) | ((val<<21) & RTC_CR_OSEL); }
inline void rtc_cr_set_wcksel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_WCKSEL) | ((val<<0) & RTC_CR_WCKSEL); }
inline uint32_t rtc_cr_get_osel(struct RTC_Type* p) { return (p->CR & RTC_CR_OSEL) >> 21 ; }
inline uint32_t rtc_cr_get_wcksel(struct RTC_Type* p) { return (p->CR & RTC_CR_WCKSEL) >> 0 ; }

// RTC->ISR initialization and status register
enum {
	RTC_ISR_RECALPF = 1UL<<16, // Recalibration pending Flag
	RTC_ISR_TAMP3F = 1UL<<15, // RTC_TAMP3 detection flag
	RTC_ISR_TAMP2F = 1UL<<14, // RTC_TAMP2 detection flag
	RTC_ISR_TAMP1F = 1UL<<13, // Tamper detection flag
	RTC_ISR_TSOVF = 1UL<<12, // Time-stamp overflow flag
	RTC_ISR_TSF = 1UL<<11, // Time-stamp flag
	RTC_ISR_WUTF = 1UL<<10, // Wakeup timer flag
	RTC_ISR_ALRBF = 1UL<<9, // Alarm B flag
	RTC_ISR_ALRAF = 1UL<<8, // Alarm A flag
	RTC_ISR_INIT = 1UL<<7, // Initialization mode
	RTC_ISR_INITF = 1UL<<6, // Initialization flag
	RTC_ISR_RSF = 1UL<<5, // Registers synchronization flag
	RTC_ISR_INITS = 1UL<<4, // Initialization status flag
	RTC_ISR_SHPF = 1UL<<3, // Shift operation pending
	RTC_ISR_WUTWF = 1UL<<2, // Wakeup timer write flag
	RTC_ISR_ALRBWF = 1UL<<1, // Alarm B write flag
	RTC_ISR_ALRAWF = 1UL<<0, // Alarm A write flag		
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL<<7)-1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL<<15)-1) << 0, // Synchronous prescaler factor		
};
inline void rtc_prer_set_prediv_a(struct RTC_Type* p, uint32_t val) { p->PRER = (p->PRER & ~RTC_PRER_PREDIV_A) | ((val<<16) & RTC_PRER_PREDIV_A); }
inline void rtc_prer_set_prediv_s(struct RTC_Type* p, uint32_t val) { p->PRER = (p->PRER & ~RTC_PRER_PREDIV_S) | ((val<<0) & RTC_PRER_PREDIV_S); }
inline uint32_t rtc_prer_get_prediv_a(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_A) >> 16 ; }
inline uint32_t rtc_prer_get_prediv_s(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_S) >> 0 ; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4 = 1UL<<31, // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMAR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3 = 1UL<<23, // Alarm A hours mask
	RTC_ALRMAR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMAR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2 = 1UL<<15, // Alarm A minutes mask
	RTC_ALRMAR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMAR_MSK1 = 1UL<<7, // Alarm A seconds mask
	RTC_ALRMAR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMAR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_alrmar_set_dt(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DT) | ((val<<28) & RTC_ALRMAR_DT); }
inline void rtc_alrmar_set_du(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DU) | ((val<<24) & RTC_ALRMAR_DU); }
inline void rtc_alrmar_set_ht(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HT) | ((val<<20) & RTC_ALRMAR_HT); }
inline void rtc_alrmar_set_hu(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HU) | ((val<<16) & RTC_ALRMAR_HU); }
inline void rtc_alrmar_set_mnt(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNT) | ((val<<12) & RTC_ALRMAR_MNT); }
inline void rtc_alrmar_set_mnu(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNU) | ((val<<8) & RTC_ALRMAR_MNU); }
inline void rtc_alrmar_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_ST) | ((val<<4) & RTC_ALRMAR_ST); }
inline void rtc_alrmar_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_SU) | ((val<<0) & RTC_ALRMAR_SU); }
inline uint32_t rtc_alrmar_get_dt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DT) >> 28 ; }
inline uint32_t rtc_alrmar_get_du(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DU) >> 24 ; }
inline uint32_t rtc_alrmar_get_ht(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HT) >> 20 ; }
inline uint32_t rtc_alrmar_get_hu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HU) >> 16 ; }
inline uint32_t rtc_alrmar_get_mnt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNT) >> 12 ; }
inline uint32_t rtc_alrmar_get_mnu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNU) >> 8 ; }
inline uint32_t rtc_alrmar_get_st(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_ST) >> 4 ; }
inline uint32_t rtc_alrmar_get_su(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_SU) >> 0 ; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4 = 1UL<<31, // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMBR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3 = 1UL<<23, // Alarm B hours mask
	RTC_ALRMBR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMBR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2 = 1UL<<15, // Alarm B minutes mask
	RTC_ALRMBR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMBR_MSK1 = 1UL<<7, // Alarm B seconds mask
	RTC_ALRMBR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMBR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_alrmbr_set_dt(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DT) | ((val<<28) & RTC_ALRMBR_DT); }
inline void rtc_alrmbr_set_du(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DU) | ((val<<24) & RTC_ALRMBR_DU); }
inline void rtc_alrmbr_set_ht(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HT) | ((val<<20) & RTC_ALRMBR_HT); }
inline void rtc_alrmbr_set_hu(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HU) | ((val<<16) & RTC_ALRMBR_HU); }
inline void rtc_alrmbr_set_mnt(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNT) | ((val<<12) & RTC_ALRMBR_MNT); }
inline void rtc_alrmbr_set_mnu(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNU) | ((val<<8) & RTC_ALRMBR_MNU); }
inline void rtc_alrmbr_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_ST) | ((val<<4) & RTC_ALRMBR_ST); }
inline void rtc_alrmbr_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_SU) | ((val<<0) & RTC_ALRMBR_SU); }
inline uint32_t rtc_alrmbr_get_dt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DT) >> 28 ; }
inline uint32_t rtc_alrmbr_get_du(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DU) >> 24 ; }
inline uint32_t rtc_alrmbr_get_ht(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HT) >> 20 ; }
inline uint32_t rtc_alrmbr_get_hu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HU) >> 16 ; }
inline uint32_t rtc_alrmbr_get_mnt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNT) >> 12 ; }
inline uint32_t rtc_alrmbr_get_mnu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNU) >> 8 ; }
inline uint32_t rtc_alrmbr_get_st(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_ST) >> 4 ; }
inline uint32_t rtc_alrmbr_get_su(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_SU) >> 0 ; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL<<31, // Add one second
	RTC_SHIFTR_SUBFS = ((1UL<<15)-1) << 0, // Subtract a fraction of a second		
};
inline void rtc_shiftr_set_subfs(struct RTC_Type* p, uint32_t val) { p->SHIFTR = (p->SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val<<0) & RTC_SHIFTR_SUBFS); }
inline uint32_t rtc_shiftr_get_subfs(struct RTC_Type* p) { return (p->SHIFTR & RTC_SHIFTR_SUBFS) >> 0 ; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM = 1UL<<22, // AM/PM notation
	RTC_TSTR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TSTR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TSTR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline uint32_t rtc_tstr_get_ht(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HT) >> 20 ; }
inline uint32_t rtc_tstr_get_hu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HU) >> 16 ; }
inline uint32_t rtc_tstr_get_mnt(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNT) >> 12 ; }
inline uint32_t rtc_tstr_get_mnu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNU) >> 8 ; }
inline uint32_t rtc_tstr_get_st(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_ST) >> 4 ; }
inline uint32_t rtc_tstr_get_su(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_SU) >> 0 ; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_TSDR_MT = 1UL<<12, // Month tens in BCD format
	RTC_TSDR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_TSDR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_TSDR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline uint32_t rtc_tsdr_get_wdu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_WDU) >> 13 ; }
inline uint32_t rtc_tsdr_get_mu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_MU) >> 8 ; }
inline uint32_t rtc_tsdr_get_dt(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DT) >> 4 ; }
inline uint32_t rtc_tsdr_get_du(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DU) >> 0 ; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP = 1UL<<15, // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8 = 1UL<<14, // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL<<13, // Use a 16-second calibration cycle period
	RTC_CALR_CALM = ((1UL<<9)-1) << 0, // Calibration minus		
};
inline void rtc_calr_set_calm(struct RTC_Type* p, uint32_t val) { p->CALR = (p->CALR & ~RTC_CALR_CALM) | ((val<<0) & RTC_CALR_CALM); }
inline uint32_t rtc_calr_get_calm(struct RTC_Type* p) { return (p->CALR & RTC_CALR_CALM) >> 0 ; }

// RTC->TAMPCR tamper configuration register
enum {
	RTC_TAMPCR_TAMP3MF = 1UL<<24, // Tamper 3 mask flag
	RTC_TAMPCR_TAMP3NOERASE = 1UL<<23, // Tamper 3 no erase
	RTC_TAMPCR_TAMP3IE = 1UL<<22, // Tamper 3 interrupt enable
	RTC_TAMPCR_TAMP2MF = 1UL<<21, // Tamper 2 mask flag
	RTC_TAMPCR_TAMP2NOERASE = 1UL<<20, // Tamper 2 no erase
	RTC_TAMPCR_TAMP2IE = 1UL<<19, // Tamper 2 interrupt enable
	RTC_TAMPCR_TAMP1MF = 1UL<<18, // Tamper 1 mask flag
	RTC_TAMPCR_TAMP1NOERASE = 1UL<<17, // Tamper 1 no erase
	RTC_TAMPCR_TAMP1IE = 1UL<<16, // Tamper 1 interrupt enable
	RTC_TAMPCR_TAMPPUDIS = 1UL<<15, // TAMPER pull-up disable
	RTC_TAMPCR_TAMPPRCH = ((1UL<<2)-1) << 13, // Tamper precharge duration
	RTC_TAMPCR_TAMPFLT = ((1UL<<2)-1) << 11, // Tamper filter count
	RTC_TAMPCR_TAMPFREQ = ((1UL<<3)-1) << 8, // Tamper sampling frequency
	RTC_TAMPCR_TAMPTS = 1UL<<7, // Activate timestamp on tamper detection event
	RTC_TAMPCR_TAMP3TRG = 1UL<<6, // Active level for tamper 3
	RTC_TAMPCR_TAMP3E = 1UL<<5, // Tamper 3 detection enable
	RTC_TAMPCR_TAMP2TRG = 1UL<<4, // Active level for tamper 2
	RTC_TAMPCR_TAMP2E = 1UL<<3, // Tamper 2 detection enable
	RTC_TAMPCR_TAMPIE = 1UL<<2, // Tamper interrupt enable
	RTC_TAMPCR_TAMP1TRG = 1UL<<1, // Active level for tamper 1
	RTC_TAMPCR_TAMP1E = 1UL<<0, // Tamper 1 detection enable		
};
inline void rtc_tampcr_set_tampprch(struct RTC_Type* p, uint32_t val) { p->TAMPCR = (p->TAMPCR & ~RTC_TAMPCR_TAMPPRCH) | ((val<<13) & RTC_TAMPCR_TAMPPRCH); }
inline void rtc_tampcr_set_tampflt(struct RTC_Type* p, uint32_t val) { p->TAMPCR = (p->TAMPCR & ~RTC_TAMPCR_TAMPFLT) | ((val<<11) & RTC_TAMPCR_TAMPFLT); }
inline void rtc_tampcr_set_tampfreq(struct RTC_Type* p, uint32_t val) { p->TAMPCR = (p->TAMPCR & ~RTC_TAMPCR_TAMPFREQ) | ((val<<8) & RTC_TAMPCR_TAMPFREQ); }
inline uint32_t rtc_tampcr_get_tampprch(struct RTC_Type* p) { return (p->TAMPCR & RTC_TAMPCR_TAMPPRCH) >> 13 ; }
inline uint32_t rtc_tampcr_get_tampflt(struct RTC_Type* p) { return (p->TAMPCR & RTC_TAMPCR_TAMPFLT) >> 11 ; }
inline uint32_t rtc_tampcr_get_tampfreq(struct RTC_Type* p) { return (p->TAMPCR & RTC_TAMPCR_TAMPFREQ) >> 8 ; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
inline void rtc_alrmassr_set_maskss(struct RTC_Type* p, uint32_t val) { p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val<<24) & RTC_ALRMASSR_MASKSS); }
inline void rtc_alrmassr_set_ss(struct RTC_Type* p, uint32_t val) { p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_SS) | ((val<<0) & RTC_ALRMASSR_SS); }
inline uint32_t rtc_alrmassr_get_maskss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24 ; }
inline uint32_t rtc_alrmassr_get_ss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_SS) >> 0 ; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
inline void rtc_alrmbssr_set_maskss(struct RTC_Type* p, uint32_t val) { p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val<<24) & RTC_ALRMBSSR_MASKSS); }
inline void rtc_alrmbssr_set_ss(struct RTC_Type* p, uint32_t val) { p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val<<0) & RTC_ALRMBSSR_SS); }
inline uint32_t rtc_alrmbssr_get_maskss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24 ; }
inline uint32_t rtc_alrmbssr_get_ss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_SS) >> 0 ; }

// RTC->OR option register
enum {
	RTC_OR_RTC_OUT_RMP = 1UL<<1, // RTC_OUT remap
	RTC_OR_RTC_ALARM_TYPE = 1UL<<0, // RTC_ALARM on PC13 output type		
};

/* Serial audio interface */
struct SAI1_Type {
	__IO uint8_t GCR; // @0 Global configuration register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t ACR1; // @4 AConfiguration register 1
	__IO uint16_t ACR2; // @8 AConfiguration register 2
	 uint8_t RESERVED1[2]; // @10 
	__IO uint32_t AFRCR; // @12 AFRCR
	__IO uint32_t ASLOTR; // @16 ASlot register
	__IO uint8_t AIM; // @20 AInterrupt mask register2
	 uint8_t RESERVED2[3]; // @21 
	__IO uint32_t ASR; // @24 AStatus register
	__IO uint8_t ACLRFR; // @28 AClear flag register
	 uint8_t RESERVED3[3]; // @29 
	__IO uint32_t ADR; // @32 AData register
	__IO uint32_t BCR1; // @36 BConfiguration register 1
	__IO uint16_t BCR2; // @40 BConfiguration register 2
	 uint8_t RESERVED4[2]; // @42 
	__IO uint32_t BFRCR; // @44 BFRCR
	__IO uint32_t BSLOTR; // @48 BSlot register
	__IO uint8_t BIM; // @52 BInterrupt mask register2
	 uint8_t RESERVED5[3]; // @53 
	__I uint32_t BSR; // @56 BStatus register
	__O uint8_t BCLRFR; // @60 BClear flag register
	 uint8_t RESERVED6[3]; // @61 
	__IO uint32_t BDR; // @64 BData register
};

// SAI1->GCR Global configuration register
enum {
	SAI1_GCR_SYNCOUT = ((1UL<<2)-1) << 4, // Synchronization outputs
	SAI1_GCR_SYNCIN = ((1UL<<2)-1) << 0, // Synchronization inputs		
};
inline void sai1_gcr_set_syncout(struct SAI1_Type* p, uint32_t val) { p->GCR = (p->GCR & ~SAI1_GCR_SYNCOUT) | ((val<<4) & SAI1_GCR_SYNCOUT); }
inline void sai1_gcr_set_syncin(struct SAI1_Type* p, uint32_t val) { p->GCR = (p->GCR & ~SAI1_GCR_SYNCIN) | ((val<<0) & SAI1_GCR_SYNCIN); }
inline uint32_t sai1_gcr_get_syncout(struct SAI1_Type* p) { return (p->GCR & SAI1_GCR_SYNCOUT) >> 4 ; }
inline uint32_t sai1_gcr_get_syncin(struct SAI1_Type* p) { return (p->GCR & SAI1_GCR_SYNCIN) >> 0 ; }

// SAI1->ACR1 AConfiguration register 1
enum {
	SAI1_ACR1_MCJDIV = ((1UL<<4)-1) << 20, // Master clock divider
	SAI1_ACR1_NODIV = 1UL<<19, // No divider
	SAI1_ACR1_DMAEN = 1UL<<17, // DMA enable
	SAI1_ACR1_SAIAEN = 1UL<<16, // Audio block A enable
	SAI1_ACR1_OUTDRI = 1UL<<13, // Output drive
	SAI1_ACR1_MONO = 1UL<<12, // Mono mode
	SAI1_ACR1_SYNCEN = ((1UL<<2)-1) << 10, // Synchronization enable
	SAI1_ACR1_CKSTR = 1UL<<9, // Clock strobing edge
	SAI1_ACR1_LSBFIRST = 1UL<<8, // Least significant bit first
	SAI1_ACR1_DS = ((1UL<<3)-1) << 5, // Data size
	SAI1_ACR1_PRTCFG = ((1UL<<2)-1) << 2, // Protocol configuration
	SAI1_ACR1_MODE = ((1UL<<2)-1) << 0, // Audio block mode		
};
inline void sai1_acr1_set_mcjdiv(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_MCJDIV) | ((val<<20) & SAI1_ACR1_MCJDIV); }
inline void sai1_acr1_set_syncen(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_SYNCEN) | ((val<<10) & SAI1_ACR1_SYNCEN); }
inline void sai1_acr1_set_ds(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_DS) | ((val<<5) & SAI1_ACR1_DS); }
inline void sai1_acr1_set_prtcfg(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_PRTCFG) | ((val<<2) & SAI1_ACR1_PRTCFG); }
inline void sai1_acr1_set_mode(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_MODE) | ((val<<0) & SAI1_ACR1_MODE); }
inline uint32_t sai1_acr1_get_mcjdiv(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_MCJDIV) >> 20 ; }
inline uint32_t sai1_acr1_get_syncen(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_SYNCEN) >> 10 ; }
inline uint32_t sai1_acr1_get_ds(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_DS) >> 5 ; }
inline uint32_t sai1_acr1_get_prtcfg(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_PRTCFG) >> 2 ; }
inline uint32_t sai1_acr1_get_mode(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_MODE) >> 0 ; }

// SAI1->ACR2 AConfiguration register 2
enum {
	SAI1_ACR2_COMP = ((1UL<<2)-1) << 14, // Companding mode
	SAI1_ACR2_CPL = 1UL<<13, // Complement bit
	SAI1_ACR2_MUTECN = ((1UL<<6)-1) << 7, // Mute counter
	SAI1_ACR2_MUTEVAL = 1UL<<6, // Mute value
	SAI1_ACR2_MUTE = 1UL<<5, // Mute
	SAI1_ACR2_TRIS = 1UL<<4, // Tristate management on data line
	SAI1_ACR2_FFLUS = 1UL<<3, // FIFO flush
	SAI1_ACR2_FTH = ((1UL<<3)-1) << 0, // FIFO threshold		
};
inline void sai1_acr2_set_comp(struct SAI1_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI1_ACR2_COMP) | ((val<<14) & SAI1_ACR2_COMP); }
inline void sai1_acr2_set_mutecn(struct SAI1_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI1_ACR2_MUTECN) | ((val<<7) & SAI1_ACR2_MUTECN); }
inline void sai1_acr2_set_fth(struct SAI1_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI1_ACR2_FTH) | ((val<<0) & SAI1_ACR2_FTH); }
inline uint32_t sai1_acr2_get_comp(struct SAI1_Type* p) { return (p->ACR2 & SAI1_ACR2_COMP) >> 14 ; }
inline uint32_t sai1_acr2_get_mutecn(struct SAI1_Type* p) { return (p->ACR2 & SAI1_ACR2_MUTECN) >> 7 ; }
inline uint32_t sai1_acr2_get_fth(struct SAI1_Type* p) { return (p->ACR2 & SAI1_ACR2_FTH) >> 0 ; }

// SAI1->AFRCR AFRCR
enum {
	SAI1_AFRCR_FSOFF = 1UL<<18, // Frame synchronization offset
	SAI1_AFRCR_FSPOL = 1UL<<17, // Frame synchronization polarity
	SAI1_AFRCR_FSDEF = 1UL<<16, // Frame synchronization definition
	SAI1_AFRCR_FSALL = ((1UL<<7)-1) << 8, // Frame synchronization active level length
	SAI1_AFRCR_FRL = ((1UL<<8)-1) << 0, // Frame length		
};
inline void sai1_afrcr_set_fsall(struct SAI1_Type* p, uint32_t val) { p->AFRCR = (p->AFRCR & ~SAI1_AFRCR_FSALL) | ((val<<8) & SAI1_AFRCR_FSALL); }
inline void sai1_afrcr_set_frl(struct SAI1_Type* p, uint32_t val) { p->AFRCR = (p->AFRCR & ~SAI1_AFRCR_FRL) | ((val<<0) & SAI1_AFRCR_FRL); }
inline uint32_t sai1_afrcr_get_fsall(struct SAI1_Type* p) { return (p->AFRCR & SAI1_AFRCR_FSALL) >> 8 ; }
inline uint32_t sai1_afrcr_get_frl(struct SAI1_Type* p) { return (p->AFRCR & SAI1_AFRCR_FRL) >> 0 ; }

// SAI1->ASLOTR ASlot register
enum {
	SAI1_ASLOTR_SLOTEN = ((1UL<<16)-1) << 16, // Slot enable
	SAI1_ASLOTR_NBSLOT = ((1UL<<4)-1) << 8, // Number of slots in an audio frame
	SAI1_ASLOTR_SLOTSZ = ((1UL<<2)-1) << 6, // Slot size
	SAI1_ASLOTR_FBOFF = ((1UL<<5)-1) << 0, // First bit offset		
};
inline void sai1_aslotr_set_sloten(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_SLOTEN) | ((val<<16) & SAI1_ASLOTR_SLOTEN); }
inline void sai1_aslotr_set_nbslot(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_NBSLOT) | ((val<<8) & SAI1_ASLOTR_NBSLOT); }
inline void sai1_aslotr_set_slotsz(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_SLOTSZ) | ((val<<6) & SAI1_ASLOTR_SLOTSZ); }
inline void sai1_aslotr_set_fboff(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_FBOFF) | ((val<<0) & SAI1_ASLOTR_FBOFF); }
inline uint32_t sai1_aslotr_get_sloten(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_SLOTEN) >> 16 ; }
inline uint32_t sai1_aslotr_get_nbslot(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_NBSLOT) >> 8 ; }
inline uint32_t sai1_aslotr_get_slotsz(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_SLOTSZ) >> 6 ; }
inline uint32_t sai1_aslotr_get_fboff(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_FBOFF) >> 0 ; }

// SAI1->AIM AInterrupt mask register2
enum {
	SAI1_AIM_LFSDET = 1UL<<6, // Late frame synchronization detection interrupt enable
	SAI1_AIM_AFSDETIE = 1UL<<5, // Anticipated frame synchronization detection interrupt enable
	SAI1_AIM_CNRDYIE = 1UL<<4, // Codec not ready interrupt enable
	SAI1_AIM_FREQIE = 1UL<<3, // FIFO request interrupt enable
	SAI1_AIM_WCKCFG = 1UL<<2, // Wrong clock configuration interrupt enable
	SAI1_AIM_MUTEDET = 1UL<<1, // Mute detection interrupt enable
	SAI1_AIM_OVRUDRIE = 1UL<<0, // Overrun/underrun interrupt enable		
};

// SAI1->ASR AStatus register
enum {
	SAI1_ASR_FLVL = ((1UL<<3)-1) << 16, // FIFO level threshold
	SAI1_ASR_LFSDET = 1UL<<6, // Late frame synchronization detection
	SAI1_ASR_AFSDET = 1UL<<5, // Anticipated frame synchronization detection
	SAI1_ASR_CNRDY = 1UL<<4, // Codec not ready
	SAI1_ASR_FREQ = 1UL<<3, // FIFO request
	SAI1_ASR_WCKCFG = 1UL<<2, // Wrong clock configuration flag. This bit is read only.
	SAI1_ASR_MUTEDET = 1UL<<1, // Mute detection
	SAI1_ASR_OVRUDR = 1UL<<0, // Overrun / underrun		
};
inline void sai1_asr_set_flvl(struct SAI1_Type* p, uint32_t val) { p->ASR = (p->ASR & ~SAI1_ASR_FLVL) | ((val<<16) & SAI1_ASR_FLVL); }
inline uint32_t sai1_asr_get_flvl(struct SAI1_Type* p) { return (p->ASR & SAI1_ASR_FLVL) >> 16 ; }

// SAI1->ACLRFR AClear flag register
enum {
	SAI1_ACLRFR_LFSDET = 1UL<<6, // Clear late frame synchronization detection flag
	SAI1_ACLRFR_CAFSDET = 1UL<<5, // Clear anticipated frame synchronization detection flag.
	SAI1_ACLRFR_CNRDY = 1UL<<4, // Clear codec not ready flag
	SAI1_ACLRFR_WCKCFG = 1UL<<2, // Clear wrong clock configuration flag
	SAI1_ACLRFR_MUTEDET = 1UL<<1, // Mute detection flag
	SAI1_ACLRFR_OVRUDR = 1UL<<0, // Clear overrun / underrun		
};

// SAI1->BCR1 BConfiguration register 1
enum {
	SAI1_BCR1_MCJDIV = ((1UL<<4)-1) << 20, // Master clock divider
	SAI1_BCR1_NODIV = 1UL<<19, // No divider
	SAI1_BCR1_DMAEN = 1UL<<17, // DMA enable
	SAI1_BCR1_SAIBEN = 1UL<<16, // Audio block B enable
	SAI1_BCR1_OUTDRI = 1UL<<13, // Output drive
	SAI1_BCR1_MONO = 1UL<<12, // Mono mode
	SAI1_BCR1_SYNCEN = ((1UL<<2)-1) << 10, // Synchronization enable
	SAI1_BCR1_CKSTR = 1UL<<9, // Clock strobing edge
	SAI1_BCR1_LSBFIRST = 1UL<<8, // Least significant bit first
	SAI1_BCR1_DS = ((1UL<<3)-1) << 5, // Data size
	SAI1_BCR1_PRTCFG = ((1UL<<2)-1) << 2, // Protocol configuration
	SAI1_BCR1_MODE = ((1UL<<2)-1) << 0, // Audio block mode		
};
inline void sai1_bcr1_set_mcjdiv(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_MCJDIV) | ((val<<20) & SAI1_BCR1_MCJDIV); }
inline void sai1_bcr1_set_syncen(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_SYNCEN) | ((val<<10) & SAI1_BCR1_SYNCEN); }
inline void sai1_bcr1_set_ds(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_DS) | ((val<<5) & SAI1_BCR1_DS); }
inline void sai1_bcr1_set_prtcfg(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_PRTCFG) | ((val<<2) & SAI1_BCR1_PRTCFG); }
inline void sai1_bcr1_set_mode(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_MODE) | ((val<<0) & SAI1_BCR1_MODE); }
inline uint32_t sai1_bcr1_get_mcjdiv(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_MCJDIV) >> 20 ; }
inline uint32_t sai1_bcr1_get_syncen(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_SYNCEN) >> 10 ; }
inline uint32_t sai1_bcr1_get_ds(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_DS) >> 5 ; }
inline uint32_t sai1_bcr1_get_prtcfg(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_PRTCFG) >> 2 ; }
inline uint32_t sai1_bcr1_get_mode(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_MODE) >> 0 ; }

// SAI1->BCR2 BConfiguration register 2
enum {
	SAI1_BCR2_COMP = ((1UL<<2)-1) << 14, // Companding mode
	SAI1_BCR2_CPL = 1UL<<13, // Complement bit
	SAI1_BCR2_MUTECN = ((1UL<<6)-1) << 7, // Mute counter
	SAI1_BCR2_MUTEVAL = 1UL<<6, // Mute value
	SAI1_BCR2_MUTE = 1UL<<5, // Mute
	SAI1_BCR2_TRIS = 1UL<<4, // Tristate management on data line
	SAI1_BCR2_FFLUS = 1UL<<3, // FIFO flush
	SAI1_BCR2_FTH = ((1UL<<3)-1) << 0, // FIFO threshold		
};
inline void sai1_bcr2_set_comp(struct SAI1_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI1_BCR2_COMP) | ((val<<14) & SAI1_BCR2_COMP); }
inline void sai1_bcr2_set_mutecn(struct SAI1_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI1_BCR2_MUTECN) | ((val<<7) & SAI1_BCR2_MUTECN); }
inline void sai1_bcr2_set_fth(struct SAI1_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI1_BCR2_FTH) | ((val<<0) & SAI1_BCR2_FTH); }
inline uint32_t sai1_bcr2_get_comp(struct SAI1_Type* p) { return (p->BCR2 & SAI1_BCR2_COMP) >> 14 ; }
inline uint32_t sai1_bcr2_get_mutecn(struct SAI1_Type* p) { return (p->BCR2 & SAI1_BCR2_MUTECN) >> 7 ; }
inline uint32_t sai1_bcr2_get_fth(struct SAI1_Type* p) { return (p->BCR2 & SAI1_BCR2_FTH) >> 0 ; }

// SAI1->BFRCR BFRCR
enum {
	SAI1_BFRCR_FSOFF = 1UL<<18, // Frame synchronization offset
	SAI1_BFRCR_FSPOL = 1UL<<17, // Frame synchronization polarity
	SAI1_BFRCR_FSDEF = 1UL<<16, // Frame synchronization definition
	SAI1_BFRCR_FSALL = ((1UL<<7)-1) << 8, // Frame synchronization active level length
	SAI1_BFRCR_FRL = ((1UL<<8)-1) << 0, // Frame length		
};
inline void sai1_bfrcr_set_fsall(struct SAI1_Type* p, uint32_t val) { p->BFRCR = (p->BFRCR & ~SAI1_BFRCR_FSALL) | ((val<<8) & SAI1_BFRCR_FSALL); }
inline void sai1_bfrcr_set_frl(struct SAI1_Type* p, uint32_t val) { p->BFRCR = (p->BFRCR & ~SAI1_BFRCR_FRL) | ((val<<0) & SAI1_BFRCR_FRL); }
inline uint32_t sai1_bfrcr_get_fsall(struct SAI1_Type* p) { return (p->BFRCR & SAI1_BFRCR_FSALL) >> 8 ; }
inline uint32_t sai1_bfrcr_get_frl(struct SAI1_Type* p) { return (p->BFRCR & SAI1_BFRCR_FRL) >> 0 ; }

// SAI1->BSLOTR BSlot register
enum {
	SAI1_BSLOTR_SLOTEN = ((1UL<<16)-1) << 16, // Slot enable
	SAI1_BSLOTR_NBSLOT = ((1UL<<4)-1) << 8, // Number of slots in an audio frame
	SAI1_BSLOTR_SLOTSZ = ((1UL<<2)-1) << 6, // Slot size
	SAI1_BSLOTR_FBOFF = ((1UL<<5)-1) << 0, // First bit offset		
};
inline void sai1_bslotr_set_sloten(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_SLOTEN) | ((val<<16) & SAI1_BSLOTR_SLOTEN); }
inline void sai1_bslotr_set_nbslot(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_NBSLOT) | ((val<<8) & SAI1_BSLOTR_NBSLOT); }
inline void sai1_bslotr_set_slotsz(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_SLOTSZ) | ((val<<6) & SAI1_BSLOTR_SLOTSZ); }
inline void sai1_bslotr_set_fboff(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_FBOFF) | ((val<<0) & SAI1_BSLOTR_FBOFF); }
inline uint32_t sai1_bslotr_get_sloten(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_SLOTEN) >> 16 ; }
inline uint32_t sai1_bslotr_get_nbslot(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_NBSLOT) >> 8 ; }
inline uint32_t sai1_bslotr_get_slotsz(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_SLOTSZ) >> 6 ; }
inline uint32_t sai1_bslotr_get_fboff(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_FBOFF) >> 0 ; }

// SAI1->BIM BInterrupt mask register2
enum {
	SAI1_BIM_LFSDETIE = 1UL<<6, // Late frame synchronization detection interrupt enable
	SAI1_BIM_AFSDETIE = 1UL<<5, // Anticipated frame synchronization detection interrupt enable
	SAI1_BIM_CNRDYIE = 1UL<<4, // Codec not ready interrupt enable
	SAI1_BIM_FREQIE = 1UL<<3, // FIFO request interrupt enable
	SAI1_BIM_WCKCFG = 1UL<<2, // Wrong clock configuration interrupt enable
	SAI1_BIM_MUTEDET = 1UL<<1, // Mute detection interrupt enable
	SAI1_BIM_OVRUDRIE = 1UL<<0, // Overrun/underrun interrupt enable		
};

// SAI1->BSR BStatus register
enum {
	SAI1_BSR_FLVL = ((1UL<<3)-1) << 16, // FIFO level threshold
	SAI1_BSR_LFSDET = 1UL<<6, // Late frame synchronization detection
	SAI1_BSR_AFSDET = 1UL<<5, // Anticipated frame synchronization detection
	SAI1_BSR_CNRDY = 1UL<<4, // Codec not ready
	SAI1_BSR_FREQ = 1UL<<3, // FIFO request
	SAI1_BSR_WCKCFG = 1UL<<2, // Wrong clock configuration flag
	SAI1_BSR_MUTEDET = 1UL<<1, // Mute detection
	SAI1_BSR_OVRUDR = 1UL<<0, // Overrun / underrun		
};
inline uint32_t sai1_bsr_get_flvl(struct SAI1_Type* p) { return (p->BSR & SAI1_BSR_FLVL) >> 16 ; }

// SAI1->BCLRFR BClear flag register
enum {
	SAI1_BCLRFR_LFSDET = 1UL<<6, // Clear late frame synchronization detection flag
	SAI1_BCLRFR_CAFSDET = 1UL<<5, // Clear anticipated frame synchronization detection flag
	SAI1_BCLRFR_CNRDY = 1UL<<4, // Clear codec not ready flag
	SAI1_BCLRFR_WCKCFG = 1UL<<2, // Clear wrong clock configuration flag
	SAI1_BCLRFR_MUTEDET = 1UL<<1, // Mute detection flag
	SAI1_BCLRFR_OVRUDR = 1UL<<0, // Clear overrun / underrun		
};


/* System control block */
struct SCB_Type {
	__I uint32_t CPUID; // @0 CPUID base register
	__IO uint32_t ICSR; // @4 Interrupt control and state register
	__IO uint32_t VTOR; // @8 Vector table offset register
	__IO uint32_t AIRCR; // @12 Application interrupt and reset control register
	__IO uint8_t SCR; // @16 System control register
	 uint8_t RESERVED0[3]; // @17 
	__IO uint32_t CCR; // @20 Configuration and control register
	__IO uint32_t SHPR1; // @24 System handler priority registers
	__IO uint32_t SHPR2; // @28 System handler priority registers
	__IO uint32_t SHPR3; // @32 System handler priority registers
	__IO uint32_t SHCSR; // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR; // @44 Hard fault status register
	 uint8_t RESERVED1[4]; // @48 
	__IO uint32_t MMFAR; // @52 Memory management fault address register
	__IO uint32_t BFAR; // @56 Bus fault address register
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL<<8)-1) << 24, // Implementer code
	SCB_CPUID_VARIANT = ((1UL<<4)-1) << 20, // Variant number
	SCB_CPUID_CONSTANT = ((1UL<<4)-1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO = ((1UL<<12)-1) << 4, // Part number of the processor
	SCB_CPUID_REVISION = ((1UL<<4)-1) << 0, // Revision number		
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24 ; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20 ; }
inline uint32_t scb_cpuid_get_constant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_CONSTANT) >> 16 ; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4 ; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0 ; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET = 1UL<<31, // NMI set-pending bit.
	SCB_ICSR_PENDSVSET = 1UL<<28, // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR = 1UL<<27, // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET = 1UL<<26, // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR = 1UL<<25, // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING = 1UL<<22, // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL<<7)-1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE = 1UL<<11, // Return to base level
	SCB_ICSR_VECTACTIVE = ((1UL<<9)-1) << 0, // Active vector		
};
inline void scb_icsr_set_vectpending(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val<<12) & SCB_ICSR_VECTPENDING); }
inline void scb_icsr_set_vectactive(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val<<0) & SCB_ICSR_VECTACTIVE); }
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12 ; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0 ; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL<<21)-1) << 9, // Vector table base offset field		
};
inline void scb_vtor_set_tbloff(struct SCB_Type* p, uint32_t val) { p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val<<9) & SCB_VTOR_TBLOFF); }
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type* p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 9 ; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT = ((1UL<<16)-1) << 16, // Register key
	SCB_AIRCR_ENDIANESS = 1UL<<15, // ENDIANESS
	SCB_AIRCR_PRIGROUP = ((1UL<<3)-1) << 8, // PRIGROUP
	SCB_AIRCR_SYSRESETREQ = 1UL<<2, // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL<<1, // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET = 1UL<<0, // VECTRESET		
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val<<16) & SCB_AIRCR_VECTKEYSTAT); }
inline void scb_aircr_set_prigroup(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val<<8) & SCB_AIRCR_PRIGROUP); }
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16 ; }
inline uint32_t scb_aircr_get_prigroup(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_PRIGROUP) >> 8 ; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND = 1UL<<4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP = 1UL<<2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL<<1, // SLEEPONEXIT		
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_BP = 1UL<<18, // BP
	SCB_CCR_IC = 1UL<<17, // IC
	SCB_CCR_DC = 1UL<<16, // DC
	SCB_CCR_STKALIGN = 1UL<<9, // STKALIGN
	SCB_CCR_BFHFNMIGN = 1UL<<8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP = 1UL<<4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP = 1UL<<3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND = 1UL<<1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL<<0, // Configures how the processor enters Thread mode		
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL<<8)-1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL<<8)-1) << 8, // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL<<8)-1) << 0, // Priority of system handler 4		
};
inline void scb_shpr1_set_pri_6(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_6) | ((val<<16) & SCB_SHPR1_PRI_6); }
inline void scb_shpr1_set_pri_5(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_5) | ((val<<8) & SCB_SHPR1_PRI_5); }
inline void scb_shpr1_set_pri_4(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_4) | ((val<<0) & SCB_SHPR1_PRI_4); }
inline uint32_t scb_shpr1_get_pri_6(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_6) >> 16 ; }
inline uint32_t scb_shpr1_get_pri_5(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_5) >> 8 ; }
inline uint32_t scb_shpr1_get_pri_4(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_4) >> 0 ; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL<<8)-1) << 24, // Priority of system handler 11		
};
inline void scb_shpr2_set_pri_11(struct SCB_Type* p, uint32_t val) { p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val<<24) & SCB_SHPR2_PRI_11); }
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type* p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24 ; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL<<8)-1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL<<8)-1) << 16, // Priority of system handler 14		
};
inline void scb_shpr3_set_pri_15(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val<<24) & SCB_SHPR3_PRI_15); }
inline void scb_shpr3_set_pri_14(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val<<16) & SCB_SHPR3_PRI_14); }
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24 ; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16 ; }

// SCB->SHCSR System handler control and state register
enum {
	SCB_SHCSR_USGFAULTENA = 1UL<<18, // Usage fault enable bit
	SCB_SHCSR_BUSFAULTENA = 1UL<<17, // Bus fault enable bit
	SCB_SHCSR_MEMFAULTENA = 1UL<<16, // Memory management fault enable bit
	SCB_SHCSR_SVCALLPENDED = 1UL<<15, // SVC call pending bit
	SCB_SHCSR_BUSFAULTPENDED = 1UL<<14, // Bus fault exception pending bit
	SCB_SHCSR_MEMFAULTPENDED = 1UL<<13, // Memory management fault exception pending bit
	SCB_SHCSR_USGFAULTPENDED = 1UL<<12, // Usage fault exception pending bit
	SCB_SHCSR_SYSTICKACT = 1UL<<11, // SysTick exception active bit
	SCB_SHCSR_PENDSVACT = 1UL<<10, // PendSV exception active bit
	SCB_SHCSR_MONITORACT = 1UL<<8, // Debug monitor active bit
	SCB_SHCSR_SVCALLACT = 1UL<<7, // SVC call active bit
	SCB_SHCSR_USGFAULTACT = 1UL<<3, // Usage fault exception active bit
	SCB_SHCSR_BUSFAULTACT = 1UL<<1, // Bus fault exception active bit
	SCB_SHCSR_MEMFAULTACT = 1UL<<0, // Memory management fault exception active bit		
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 1UL<<25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 1UL<<24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 1UL<<19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 1UL<<18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 1UL<<17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 1UL<<16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 1UL<<15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 1UL<<13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 1UL<<12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 1UL<<11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL<<10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 1UL<<9, // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 1UL<<8, // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 1UL<<7, // MMARVALID
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 1UL<<5, // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 1UL<<4, // MSTKERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 1UL<<3, // MUNSTKERR
	SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL = 1UL<<1, // DACCVIOL
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 1UL<<0, // IACCVIOL		
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL<<31, // Reserved for Debug use
	SCB_HFSR_FORCED = 1UL<<30, // Forced hard fault
	SCB_HFSR_VECTTBL = 1UL<<1, // Vector table hard fault		
};

/* System control block ACTLR */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISITMATBFLUSH = 1UL<<12, // DISITMATBFLUSH
	SCB_ACTRL_ACTRL_DISRAMODE = 1UL<<11, // DISRAMODE
	SCB_ACTRL_ACTRL_FPEXCODIS = 1UL<<10, // FPEXCODIS
	SCB_ACTRL_ACTRL_DISFOLD = 1UL<<2, // DISFOLD		
};

/* Secure digital input/output interface */
struct SDMMC1_Type {
	__IO uint8_t POWER; // @0 power control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CLKCR; // @4 SDI clock control register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t ARG; // @8 argument register
	__IO uint16_t CMD; // @12 command register
	 uint8_t RESERVED2[2]; // @14 
	__I uint8_t RESPCMD; // @16 command response register
	 uint8_t RESERVED3[3]; // @17 
	__I uint32_t RESP1; // @20 response 1..4 register
	__I uint32_t RESP2; // @24 response 1..4 register
	__I uint32_t RESP3; // @28 response 1..4 register
	__I uint32_t RESP4; // @32 response 1..4 register
	__IO uint32_t DTIMER; // @36 data timer register
	__IO uint32_t DLEN; // @40 data length register
	__IO uint16_t DCTRL; // @44 data control register
	 uint8_t RESERVED4[2]; // @46 
	__I uint32_t DCOUNT; // @48 data counter register
	__I uint32_t STA; // @52 status register
	__IO uint32_t ICR; // @56 interrupt clear register
	__IO uint32_t MASK; // @60 mask register
	 uint8_t RESERVED5[8]; // @64 
	__I uint32_t FIFOCNT; // @72 FIFO counter register
	 uint8_t RESERVED6[52]; // @76 
	__IO uint32_t FIFO; // @128 data FIFO register
};

// SDMMC1->POWER power control register
enum {
	SDMMC1_POWER_PWRCTRL = ((1UL<<2)-1) << 0, // PWRCTRL		
};
inline void sdmmc1_power_set_pwrctrl(struct SDMMC1_Type* p, uint32_t val) { p->POWER = (p->POWER & ~SDMMC1_POWER_PWRCTRL) | ((val<<0) & SDMMC1_POWER_PWRCTRL); }
inline uint32_t sdmmc1_power_get_pwrctrl(struct SDMMC1_Type* p) { return (p->POWER & SDMMC1_POWER_PWRCTRL) >> 0 ; }

// SDMMC1->CLKCR SDI clock control register
enum {
	SDMMC1_CLKCR_HWFC_EN = 1UL<<14, // HW Flow Control enable
	SDMMC1_CLKCR_NEGEDGE = 1UL<<13, // SDIO_CK dephasing selection bit
	SDMMC1_CLKCR_WIDBUS = ((1UL<<2)-1) << 11, // Wide bus mode enable bit
	SDMMC1_CLKCR_BYPASS = 1UL<<10, // Clock divider bypass enable bit
	SDMMC1_CLKCR_PWRSAV = 1UL<<9, // Power saving configuration bit
	SDMMC1_CLKCR_CLKEN = 1UL<<8, // Clock enable bit
	SDMMC1_CLKCR_CLKDIV = ((1UL<<8)-1) << 0, // Clock divide factor		
};
inline void sdmmc1_clkcr_set_widbus(struct SDMMC1_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC1_CLKCR_WIDBUS) | ((val<<11) & SDMMC1_CLKCR_WIDBUS); }
inline void sdmmc1_clkcr_set_clkdiv(struct SDMMC1_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC1_CLKCR_CLKDIV) | ((val<<0) & SDMMC1_CLKCR_CLKDIV); }
inline uint32_t sdmmc1_clkcr_get_widbus(struct SDMMC1_Type* p) { return (p->CLKCR & SDMMC1_CLKCR_WIDBUS) >> 11 ; }
inline uint32_t sdmmc1_clkcr_get_clkdiv(struct SDMMC1_Type* p) { return (p->CLKCR & SDMMC1_CLKCR_CLKDIV) >> 0 ; }

// SDMMC1->CMD command register
enum {
	SDMMC1_CMD_CE_ATACMD = 1UL<<14, // CE-ATA command
	SDMMC1_CMD_NIEN = 1UL<<13, // not Interrupt Enable
	SDMMC1_CMD_ENCMDCOMPL = 1UL<<12, // Enable CMD completion
	SDMMC1_CMD_SDIOSUSPEND = 1UL<<11, // SD I/O suspend command
	SDMMC1_CMD_CPSMEN = 1UL<<10, // Command path state machine (CPSM) Enable bit
	SDMMC1_CMD_WAITPEND = 1UL<<9, // CPSM Waits for ends of data transfer (CmdPend internal signal)
	SDMMC1_CMD_WAITINT = 1UL<<8, // CPSM waits for interrupt request
	SDMMC1_CMD_WAITRESP = ((1UL<<2)-1) << 6, // Wait for response bits
	SDMMC1_CMD_CMDINDEX = ((1UL<<6)-1) << 0, // Command index		
};
inline void sdmmc1_cmd_set_waitresp(struct SDMMC1_Type* p, uint32_t val) { p->CMD = (p->CMD & ~SDMMC1_CMD_WAITRESP) | ((val<<6) & SDMMC1_CMD_WAITRESP); }
inline void sdmmc1_cmd_set_cmdindex(struct SDMMC1_Type* p, uint32_t val) { p->CMD = (p->CMD & ~SDMMC1_CMD_CMDINDEX) | ((val<<0) & SDMMC1_CMD_CMDINDEX); }
inline uint32_t sdmmc1_cmd_get_waitresp(struct SDMMC1_Type* p) { return (p->CMD & SDMMC1_CMD_WAITRESP) >> 6 ; }
inline uint32_t sdmmc1_cmd_get_cmdindex(struct SDMMC1_Type* p) { return (p->CMD & SDMMC1_CMD_CMDINDEX) >> 0 ; }

// SDMMC1->RESPCMD command response register
enum {
	SDMMC1_RESPCMD_RESPCMD = ((1UL<<6)-1) << 0, // Response command index		
};
inline uint32_t sdmmc1_respcmd_get_respcmd(struct SDMMC1_Type* p) { return (p->RESPCMD & SDMMC1_RESPCMD_RESPCMD) >> 0 ; }

// SDMMC1->DLEN data length register
enum {
	SDMMC1_DLEN_DATALENGTH = ((1UL<<25)-1) << 0, // Data length value		
};
inline void sdmmc1_dlen_set_datalength(struct SDMMC1_Type* p, uint32_t val) { p->DLEN = (p->DLEN & ~SDMMC1_DLEN_DATALENGTH) | ((val<<0) & SDMMC1_DLEN_DATALENGTH); }
inline uint32_t sdmmc1_dlen_get_datalength(struct SDMMC1_Type* p) { return (p->DLEN & SDMMC1_DLEN_DATALENGTH) >> 0 ; }

// SDMMC1->DCTRL data control register
enum {
	SDMMC1_DCTRL_SDIOEN = 1UL<<11, // SD I/O enable functions
	SDMMC1_DCTRL_RWMOD = 1UL<<10, // Read wait mode
	SDMMC1_DCTRL_RWSTOP = 1UL<<9, // Read wait stop
	SDMMC1_DCTRL_RWSTART = 1UL<<8, // Read wait start
	SDMMC1_DCTRL_DBLOCKSIZE = ((1UL<<4)-1) << 4, // Data block size
	SDMMC1_DCTRL_DMAEN = 1UL<<3, // DMA enable bit
	SDMMC1_DCTRL_DTMODE = 1UL<<2, // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
	SDMMC1_DCTRL_DTDIR = 1UL<<1, // Data transfer direction selection
	SDMMC1_DCTRL_DTEN = 1UL<<0, // DTEN		
};
inline void sdmmc1_dctrl_set_dblocksize(struct SDMMC1_Type* p, uint32_t val) { p->DCTRL = (p->DCTRL & ~SDMMC1_DCTRL_DBLOCKSIZE) | ((val<<4) & SDMMC1_DCTRL_DBLOCKSIZE); }
inline uint32_t sdmmc1_dctrl_get_dblocksize(struct SDMMC1_Type* p) { return (p->DCTRL & SDMMC1_DCTRL_DBLOCKSIZE) >> 4 ; }

// SDMMC1->DCOUNT data counter register
enum {
	SDMMC1_DCOUNT_DATACOUNT = ((1UL<<25)-1) << 0, // Data count value		
};
inline uint32_t sdmmc1_dcount_get_datacount(struct SDMMC1_Type* p) { return (p->DCOUNT & SDMMC1_DCOUNT_DATACOUNT) >> 0 ; }

// SDMMC1->STA status register
enum {
	SDMMC1_STA_CEATAEND = 1UL<<23, // CE-ATA command completion signal received for CMD61
	SDMMC1_STA_SDIOIT = 1UL<<22, // SDIO interrupt received
	SDMMC1_STA_RXDAVL = 1UL<<21, // Data available in receive FIFO
	SDMMC1_STA_TXDAVL = 1UL<<20, // Data available in transmit FIFO
	SDMMC1_STA_RXFIFOE = 1UL<<19, // Receive FIFO empty
	SDMMC1_STA_TXFIFOE = 1UL<<18, // Transmit FIFO empty
	SDMMC1_STA_RXFIFOF = 1UL<<17, // Receive FIFO full
	SDMMC1_STA_TXFIFOF = 1UL<<16, // Transmit FIFO full
	SDMMC1_STA_RXFIFOHF = 1UL<<15, // Receive FIFO half full: there are at least 8 words in the FIFO
	SDMMC1_STA_TXFIFOHE = 1UL<<14, // Transmit FIFO half empty: at least 8 words can be written into the FIFO
	SDMMC1_STA_RXACT = 1UL<<13, // Data receive in progress
	SDMMC1_STA_TXACT = 1UL<<12, // Data transmit in progress
	SDMMC1_STA_CMDACT = 1UL<<11, // Command transfer in progress
	SDMMC1_STA_DBCKEND = 1UL<<10, // Data block sent/received (CRC check passed)
	SDMMC1_STA_STBITERR = 1UL<<9, // Start bit not detected on all data signals in wide bus mode
	SDMMC1_STA_DATAEND = 1UL<<8, // Data end (data counter, SDIDCOUNT, is zero)
	SDMMC1_STA_CMDSENT = 1UL<<7, // Command sent (no response required)
	SDMMC1_STA_CMDREND = 1UL<<6, // Command response received (CRC check passed)
	SDMMC1_STA_RXOVERR = 1UL<<5, // Received FIFO overrun error
	SDMMC1_STA_TXUNDERR = 1UL<<4, // Transmit FIFO underrun error
	SDMMC1_STA_DTIMEOUT = 1UL<<3, // Data timeout
	SDMMC1_STA_CTIMEOUT = 1UL<<2, // Command response timeout
	SDMMC1_STA_DCRCFAIL = 1UL<<1, // Data block sent/received (CRC check failed)
	SDMMC1_STA_CCRCFAIL = 1UL<<0, // Command response received (CRC check failed)		
};

// SDMMC1->ICR interrupt clear register
enum {
	SDMMC1_ICR_CEATAENDC = 1UL<<23, // CEATAEND flag clear bit
	SDMMC1_ICR_SDIOITC = 1UL<<22, // SDIOIT flag clear bit
	SDMMC1_ICR_DBCKENDC = 1UL<<10, // DBCKEND flag clear bit
	SDMMC1_ICR_STBITERRC = 1UL<<9, // STBITERR flag clear bit
	SDMMC1_ICR_DATAENDC = 1UL<<8, // DATAEND flag clear bit
	SDMMC1_ICR_CMDSENTC = 1UL<<7, // CMDSENT flag clear bit
	SDMMC1_ICR_CMDRENDC = 1UL<<6, // CMDREND flag clear bit
	SDMMC1_ICR_RXOVERRC = 1UL<<5, // RXOVERR flag clear bit
	SDMMC1_ICR_TXUNDERRC = 1UL<<4, // TXUNDERR flag clear bit
	SDMMC1_ICR_DTIMEOUTC = 1UL<<3, // DTIMEOUT flag clear bit
	SDMMC1_ICR_CTIMEOUTC = 1UL<<2, // CTIMEOUT flag clear bit
	SDMMC1_ICR_DCRCFAILC = 1UL<<1, // DCRCFAIL flag clear bit
	SDMMC1_ICR_CCRCFAILC = 1UL<<0, // CCRCFAIL flag clear bit		
};

// SDMMC1->MASK mask register
enum {
	SDMMC1_MASK_CEATAENDIE = 1UL<<23, // CE-ATA command completion signal received interrupt enable
	SDMMC1_MASK_SDIOITIE = 1UL<<22, // SDIO mode interrupt received interrupt enable
	SDMMC1_MASK_RXDAVLIE = 1UL<<21, // Data available in Rx FIFO interrupt enable
	SDMMC1_MASK_TXDAVLIE = 1UL<<20, // Data available in Tx FIFO interrupt enable
	SDMMC1_MASK_RXFIFOEIE = 1UL<<19, // Rx FIFO empty interrupt enable
	SDMMC1_MASK_TXFIFOEIE = 1UL<<18, // Tx FIFO empty interrupt enable
	SDMMC1_MASK_RXFIFOFIE = 1UL<<17, // Rx FIFO full interrupt enable
	SDMMC1_MASK_TXFIFOFIE = 1UL<<16, // Tx FIFO full interrupt enable
	SDMMC1_MASK_RXFIFOHFIE = 1UL<<15, // Rx FIFO half full interrupt enable
	SDMMC1_MASK_TXFIFOHEIE = 1UL<<14, // Tx FIFO half empty interrupt enable
	SDMMC1_MASK_RXACTIE = 1UL<<13, // Data receive acting interrupt enable
	SDMMC1_MASK_TXACTIE = 1UL<<12, // Data transmit acting interrupt enable
	SDMMC1_MASK_CMDACTIE = 1UL<<11, // Command acting interrupt enable
	SDMMC1_MASK_DBCKENDIE = 1UL<<10, // Data block end interrupt enable
	SDMMC1_MASK_STBITERRIE = 1UL<<9, // Start bit error interrupt enable
	SDMMC1_MASK_DATAENDIE = 1UL<<8, // Data end interrupt enable
	SDMMC1_MASK_CMDSENTIE = 1UL<<7, // Command sent interrupt enable
	SDMMC1_MASK_CMDRENDIE = 1UL<<6, // Command response received interrupt enable
	SDMMC1_MASK_RXOVERRIE = 1UL<<5, // Rx FIFO overrun error interrupt enable
	SDMMC1_MASK_TXUNDERRIE = 1UL<<4, // Tx FIFO underrun error interrupt enable
	SDMMC1_MASK_DTIMEOUTIE = 1UL<<3, // Data timeout interrupt enable
	SDMMC1_MASK_CTIMEOUTIE = 1UL<<2, // Command timeout interrupt enable
	SDMMC1_MASK_DCRCFAILIE = 1UL<<1, // Data CRC fail interrupt enable
	SDMMC1_MASK_CCRCFAILIE = 1UL<<0, // Command CRC fail interrupt enable		
};

// SDMMC1->FIFOCNT FIFO counter register
enum {
	SDMMC1_FIFOCNT_FIFOCOUNT = ((1UL<<24)-1) << 0, // Remaining number of words to be written to or read from the FIFO		
};
inline uint32_t sdmmc1_fifocnt_get_fifocount(struct SDMMC1_Type* p) { return (p->FIFOCNT & SDMMC1_FIFOCNT_FIFOCOUNT) >> 0 ; }


/* Receiver Interface */
struct SPDIFRX_Type {
	__IO uint32_t CR; // @0 Control register
	__IO uint8_t IMR; // @4 Interrupt mask register
	 uint8_t RESERVED0[3]; // @5 
	__I uint32_t SR; // @8 Status register
	__O uint8_t IFCR; // @12 Interrupt Flag Clear register
	 uint8_t RESERVED1[3]; // @13 
	__I uint32_t DR; // @16 Data input register
	__I uint32_t CSR; // @20 Channel Status register
	__I uint32_t DIR; // @24 Debug Information register
};

// SPDIFRX->CR Control register
enum {
	SPDIFRX_CR_INSEL = ((1UL<<3)-1) << 16, // input selection
	SPDIFRX_CR_WFA = 1UL<<14, // Wait For Activity
	SPDIFRX_CR_NBTR = ((1UL<<2)-1) << 12, // Maximum allowed re-tries during synchronization phase
	SPDIFRX_CR_CHSEL = 1UL<<11, // Channel Selection
	SPDIFRX_CR_CBDMAEN = 1UL<<10, // Control Buffer DMA ENable for control flow
	SPDIFRX_CR_PTMSK = 1UL<<9, // Mask of Preamble Type bits
	SPDIFRX_CR_CUMSK = 1UL<<8, // Mask of channel status and user bits
	SPDIFRX_CR_VMSK = 1UL<<7, // Mask of Validity bit
	SPDIFRX_CR_PMSK = 1UL<<6, // Mask Parity error bit
	SPDIFRX_CR_DRFMT = ((1UL<<2)-1) << 4, // RX Data format
	SPDIFRX_CR_RXSTEO = 1UL<<3, // STerEO Mode
	SPDIFRX_CR_RXDMAEN = 1UL<<2, // Receiver DMA ENable for data flow
	SPDIFRX_CR_SPDIFEN = ((1UL<<2)-1) << 0, // Peripheral Block Enable		
};
inline void spdifrx_cr_set_insel(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_INSEL) | ((val<<16) & SPDIFRX_CR_INSEL); }
inline void spdifrx_cr_set_nbtr(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_NBTR) | ((val<<12) & SPDIFRX_CR_NBTR); }
inline void spdifrx_cr_set_drfmt(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_DRFMT) | ((val<<4) & SPDIFRX_CR_DRFMT); }
inline void spdifrx_cr_set_spdifen(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_SPDIFEN) | ((val<<0) & SPDIFRX_CR_SPDIFEN); }
inline uint32_t spdifrx_cr_get_insel(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_INSEL) >> 16 ; }
inline uint32_t spdifrx_cr_get_nbtr(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_NBTR) >> 12 ; }
inline uint32_t spdifrx_cr_get_drfmt(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_DRFMT) >> 4 ; }
inline uint32_t spdifrx_cr_get_spdifen(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_SPDIFEN) >> 0 ; }

// SPDIFRX->IMR Interrupt mask register
enum {
	SPDIFRX_IMR_IFEIE = 1UL<<6, // Serial Interface Error Interrupt Enable
	SPDIFRX_IMR_SYNCDIE = 1UL<<5, // Synchronization Done
	SPDIFRX_IMR_SBLKIE = 1UL<<4, // Synchronization Block Detected Interrupt Enable
	SPDIFRX_IMR_OVRIE = 1UL<<3, // Overrun error Interrupt Enable
	SPDIFRX_IMR_PERRIE = 1UL<<2, // Parity error interrupt enable
	SPDIFRX_IMR_CSRNEIE = 1UL<<1, // Control Buffer Ready Interrupt Enable
	SPDIFRX_IMR_RXNEIE = 1UL<<0, // RXNE interrupt enable		
};

// SPDIFRX->SR Status register
enum {
	SPDIFRX_SR_WIDTH5 = ((1UL<<15)-1) << 16, // Duration of 5 symbols counted with SPDIF_CLK
	SPDIFRX_SR_TERR = 1UL<<8, // Time-out error
	SPDIFRX_SR_SERR = 1UL<<7, // Synchronization error
	SPDIFRX_SR_FERR = 1UL<<6, // Framing error
	SPDIFRX_SR_SYNCD = 1UL<<5, // Synchronization Done
	SPDIFRX_SR_SBD = 1UL<<4, // Synchronization Block Detected
	SPDIFRX_SR_OVR = 1UL<<3, // Overrun error
	SPDIFRX_SR_PERR = 1UL<<2, // Parity error
	SPDIFRX_SR_CSRNE = 1UL<<1, // Control Buffer register is not empty
	SPDIFRX_SR_RXNE = 1UL<<0, // Read data register not empty		
};
inline uint32_t spdifrx_sr_get_width5(struct SPDIFRX_Type* p) { return (p->SR & SPDIFRX_SR_WIDTH5) >> 16 ; }

// SPDIFRX->IFCR Interrupt Flag Clear register
enum {
	SPDIFRX_IFCR_SYNCDCF = 1UL<<5, // Clears the Synchronization Done flag
	SPDIFRX_IFCR_SBDCF = 1UL<<4, // Clears the Synchronization Block Detected flag
	SPDIFRX_IFCR_OVRCF = 1UL<<3, // Clears the Overrun error flag
	SPDIFRX_IFCR_PERRCF = 1UL<<2, // Clears the Parity error flag		
};

// SPDIFRX->DR Data input register
enum {
	SPDIFRX_DR_PT = ((1UL<<2)-1) << 28, // Preamble Type
	SPDIFRX_DR_C = 1UL<<27, // Channel Status bit
	SPDIFRX_DR_U = 1UL<<26, // User bit
	SPDIFRX_DR_V = 1UL<<25, // Validity bit
	SPDIFRX_DR_PE = 1UL<<24, // Parity Error bit
	SPDIFRX_DR_DR = ((1UL<<24)-1) << 0, // Parity Error bit		
};
inline uint32_t spdifrx_dr_get_pt(struct SPDIFRX_Type* p) { return (p->DR & SPDIFRX_DR_PT) >> 28 ; }
inline uint32_t spdifrx_dr_get_dr(struct SPDIFRX_Type* p) { return (p->DR & SPDIFRX_DR_DR) >> 0 ; }

// SPDIFRX->CSR Channel Status register
enum {
	SPDIFRX_CSR_SOB = 1UL<<24, // Start Of Block
	SPDIFRX_CSR_CS = ((1UL<<8)-1) << 16, // Channel A status information
	SPDIFRX_CSR_USR = ((1UL<<16)-1) << 0, // User data information		
};
inline uint32_t spdifrx_csr_get_cs(struct SPDIFRX_Type* p) { return (p->CSR & SPDIFRX_CSR_CS) >> 16 ; }
inline uint32_t spdifrx_csr_get_usr(struct SPDIFRX_Type* p) { return (p->CSR & SPDIFRX_CSR_USR) >> 0 ; }

// SPDIFRX->DIR Debug Information register
enum {
	SPDIFRX_DIR_TLO = ((1UL<<13)-1) << 16, // Threshold LOW
	SPDIFRX_DIR_THI = ((1UL<<13)-1) << 0, // Threshold HIGH		
};
inline uint32_t spdifrx_dir_get_tlo(struct SPDIFRX_Type* p) { return (p->DIR & SPDIFRX_DIR_TLO) >> 16 ; }
inline uint32_t spdifrx_dir_get_thi(struct SPDIFRX_Type* p) { return (p->DIR & SPDIFRX_DIR_THI) >> 0 ; }

/* Serial peripheral interface */
struct SPI1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SR; // @8 status register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DR; // @12 data register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t CRCPR; // @16 CRC polynomial register
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t RXCRCR; // @20 RX CRC register
	 uint8_t RESERVED5[2]; // @22 
	__I uint16_t TXCRCR; // @24 TX CRC register
	 uint8_t RESERVED6[2]; // @26 
	__IO uint16_t I2SCFGR; // @28 I2S configuration register
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t I2SPR; // @32 I2S prescaler register
};

// SPI1->CR1 control register 1
enum {
	SPI1_CR1_BIDIMODE = 1UL<<15, // Bidirectional data mode enable
	SPI1_CR1_BIDIOE = 1UL<<14, // Output enable in bidirectional mode
	SPI1_CR1_CRCEN = 1UL<<13, // Hardware CRC calculation enable
	SPI1_CR1_CRCNEXT = 1UL<<12, // CRC transfer next
	SPI1_CR1_CRCL = 1UL<<11, // CRC length
	SPI1_CR1_RXONLY = 1UL<<10, // Receive only
	SPI1_CR1_SSM = 1UL<<9, // Software slave management
	SPI1_CR1_SSI = 1UL<<8, // Internal slave select
	SPI1_CR1_LSBFIRST = 1UL<<7, // Frame format
	SPI1_CR1_SPE = 1UL<<6, // SPI enable
	SPI1_CR1_BR = ((1UL<<3)-1) << 3, // Baud rate control
	SPI1_CR1_MSTR = 1UL<<2, // Master selection
	SPI1_CR1_CPOL = 1UL<<1, // Clock polarity
	SPI1_CR1_CPHA = 1UL<<0, // Clock phase		
};
inline void spi1_cr1_set_br(struct SPI1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI1_CR1_BR) | ((val<<3) & SPI1_CR1_BR); }
inline uint32_t spi1_cr1_get_br(struct SPI1_Type* p) { return (p->CR1 & SPI1_CR1_BR) >> 3 ; }

// SPI1->CR2 control register 2
enum {
	SPI1_CR2_LDMA_TX = 1UL<<14, // Last DMA transfer for transmission
	SPI1_CR2_LDMA_RX = 1UL<<13, // Last DMA transfer for reception
	SPI1_CR2_FRXTH = 1UL<<12, // FIFO reception threshold
	SPI1_CR2_DS = ((1UL<<4)-1) << 8, // Data size
	SPI1_CR2_TXEIE = 1UL<<7, // Tx buffer empty interrupt enable
	SPI1_CR2_RXNEIE = 1UL<<6, // RX buffer not empty interrupt enable
	SPI1_CR2_ERRIE = 1UL<<5, // Error interrupt enable
	SPI1_CR2_FRF = 1UL<<4, // Frame format
	SPI1_CR2_NSSP = 1UL<<3, // NSS pulse management
	SPI1_CR2_SSOE = 1UL<<2, // SS output enable
	SPI1_CR2_TXDMAEN = 1UL<<1, // Tx buffer DMA enable
	SPI1_CR2_RXDMAEN = 1UL<<0, // Rx buffer DMA enable		
};
inline void spi1_cr2_set_ds(struct SPI1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_DS) | ((val<<8) & SPI1_CR2_DS); }
inline uint32_t spi1_cr2_get_ds(struct SPI1_Type* p) { return (p->CR2 & SPI1_CR2_DS) >> 8 ; }

// SPI1->SR status register
enum {
	SPI1_SR_FTLVL = ((1UL<<2)-1) << 11, // FIFO Transmission Level
	SPI1_SR_FRLVL = ((1UL<<2)-1) << 9, // FIFO reception level
	SPI1_SR_FRE = 1UL<<8, // Frame format error
	SPI1_SR_BSY = 1UL<<7, // Busy flag
	SPI1_SR_OVR = 1UL<<6, // Overrun flag
	SPI1_SR_MODF = 1UL<<5, // Mode fault
	SPI1_SR_CRCERR = 1UL<<4, // CRC error flag
	SPI1_SR_UDR = 1UL<<3, // Underrun flag
	SPI1_SR_CHSIDE = 1UL<<2, // Channel side
	SPI1_SR_TXE = 1UL<<1, // Transmit buffer empty
	SPI1_SR_RXNE = 1UL<<0, // Receive buffer not empty		
};
inline void spi1_sr_set_ftlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FTLVL) | ((val<<11) & SPI1_SR_FTLVL); }
inline void spi1_sr_set_frlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FRLVL) | ((val<<9) & SPI1_SR_FRLVL); }
inline uint32_t spi1_sr_get_ftlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FTLVL) >> 11 ; }
inline uint32_t spi1_sr_get_frlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FRLVL) >> 9 ; }

// SPI1->I2SCFGR I2S configuration register
enum {
	SPI1_I2SCFGR_ASTRTEN = 1UL<<12, // Asynchronous start enable
	SPI1_I2SCFGR_I2SMOD = 1UL<<11, // I2S mode selection
	SPI1_I2SCFGR_I2SE = 1UL<<10, // I2S Enable
	SPI1_I2SCFGR_I2SCFG = ((1UL<<2)-1) << 8, // I2S configuration mode
	SPI1_I2SCFGR_PCMSYNC = 1UL<<7, // PCM frame synchronization
	SPI1_I2SCFGR_I2SSTD = ((1UL<<2)-1) << 4, // I2S standard selection
	SPI1_I2SCFGR_CKPOL = 1UL<<3, // Steady state clock polarity
	SPI1_I2SCFGR_DATLEN = ((1UL<<2)-1) << 1, // Data length to be transferred
	SPI1_I2SCFGR_CHLEN = 1UL<<0, // Channel length (number of bits per audio channel)		
};
inline void spi1_i2scfgr_set_i2scfg(struct SPI1_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SCFG) | ((val<<8) & SPI1_I2SCFGR_I2SCFG); }
inline void spi1_i2scfgr_set_i2sstd(struct SPI1_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SSTD) | ((val<<4) & SPI1_I2SCFGR_I2SSTD); }
inline void spi1_i2scfgr_set_datlen(struct SPI1_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_DATLEN) | ((val<<1) & SPI1_I2SCFGR_DATLEN); }
inline uint32_t spi1_i2scfgr_get_i2scfg(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SCFG) >> 8 ; }
inline uint32_t spi1_i2scfgr_get_i2sstd(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SSTD) >> 4 ; }
inline uint32_t spi1_i2scfgr_get_datlen(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_DATLEN) >> 1 ; }

// SPI1->I2SPR I2S prescaler register
enum {
	SPI1_I2SPR_MCKOE = 1UL<<9, // Master clock output enable
	SPI1_I2SPR_ODD = 1UL<<8, // Odd factor for the prescaler
	SPI1_I2SPR_I2SDIV = ((1UL<<8)-1) << 0, // I2S Linear prescaler		
};
inline void spi1_i2spr_set_i2sdiv(struct SPI1_Type* p, uint32_t val) { p->I2SPR = (p->I2SPR & ~SPI1_I2SPR_I2SDIV) | ((val<<0) & SPI1_I2SPR_I2SDIV); }
inline uint32_t spi1_i2spr_get_i2sdiv(struct SPI1_Type* p) { return (p->I2SPR & SPI1_I2SPR_I2SDIV) >> 0 ; }






/* SysTick timer */
struct STK_Type {
	__IO uint32_t CSR; // @0 SysTick control and status register
	__IO uint32_t RVR; // @4 SysTick reload value register
	__IO uint32_t CVR; // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};

// STK->CSR SysTick control and status register
enum {
	STK_CSR_COUNTFLAG = 1UL<<16, // COUNTFLAG
	STK_CSR_CLKSOURCE = 1UL<<2, // Clock source selection
	STK_CSR_TICKINT = 1UL<<1, // SysTick exception request enable
	STK_CSR_ENABLE = 1UL<<0, // Counter enable		
};

// STK->RVR SysTick reload value register
enum {
	STK_RVR_RELOAD = ((1UL<<24)-1) << 0, // RELOAD value		
};
inline void stk_rvr_set_reload(struct STK_Type* p, uint32_t val) { p->RVR = (p->RVR & ~STK_RVR_RELOAD) | ((val<<0) & STK_RVR_RELOAD); }
inline uint32_t stk_rvr_get_reload(struct STK_Type* p) { return (p->RVR & STK_RVR_RELOAD) >> 0 ; }

// STK->CVR SysTick current value register
enum {
	STK_CVR_CURRENT = ((1UL<<24)-1) << 0, // Current counter value		
};
inline void stk_cvr_set_current(struct STK_Type* p, uint32_t val) { p->CVR = (p->CVR & ~STK_CVR_CURRENT) | ((val<<0) & STK_CVR_CURRENT); }
inline uint32_t stk_cvr_get_current(struct STK_Type* p) { return (p->CVR & STK_CVR_CURRENT) >> 0 ; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL<<31, // NOREF flag. Reads as zero
	STK_CALIB_SKEW = 1UL<<30, // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL<<24)-1) << 0, // Calibration value		
};
inline void stk_calib_set_tenms(struct STK_Type* p, uint32_t val) { p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val<<0) & STK_CALIB_TENMS); }
inline uint32_t stk_calib_get_tenms(struct STK_Type* p) { return (p->CALIB & STK_CALIB_TENMS) >> 0 ; }

/* System configuration controller */
struct SYSCFG_Type {
	__IO uint16_t MEMRM; // @0 memory remap register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t PMC; // @4 peripheral mode configuration register
	__IO uint16_t EXTICR1; // @8 external interrupt configuration register 1
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t EXTICR2; // @12 external interrupt configuration register 2
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t EXTICR3; // @16 external interrupt configuration register 3
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t EXTICR4; // @20 external interrupt configuration register 4
	 uint8_t RESERVED4[10]; // @22 
	__I uint16_t CMPCR; // @32 Compensation cell control register
};

// SYSCFG->MEMRM memory remap register
enum {
	SYSCFG_MEMRM_SWP_FMC = ((1UL<<2)-1) << 10, // FMC memory mapping swap
	SYSCFG_MEMRM_FB_MODE = 1UL<<8, // Flash bank mode selection
	SYSCFG_MEMRM_MEM_MODE = ((1UL<<3)-1) << 0, // Memory mapping selection		
};
inline void syscfg_memrm_set_swp_fmc(struct SYSCFG_Type* p, uint32_t val) { p->MEMRM = (p->MEMRM & ~SYSCFG_MEMRM_SWP_FMC) | ((val<<10) & SYSCFG_MEMRM_SWP_FMC); }
inline void syscfg_memrm_set_mem_mode(struct SYSCFG_Type* p, uint32_t val) { p->MEMRM = (p->MEMRM & ~SYSCFG_MEMRM_MEM_MODE) | ((val<<0) & SYSCFG_MEMRM_MEM_MODE); }
inline uint32_t syscfg_memrm_get_swp_fmc(struct SYSCFG_Type* p) { return (p->MEMRM & SYSCFG_MEMRM_SWP_FMC) >> 10 ; }
inline uint32_t syscfg_memrm_get_mem_mode(struct SYSCFG_Type* p) { return (p->MEMRM & SYSCFG_MEMRM_MEM_MODE) >> 0 ; }

// SYSCFG->PMC peripheral mode configuration register
enum {
	SYSCFG_PMC_MII_RMII_SEL = 1UL<<23, // Ethernet PHY interface selection
	SYSCFG_PMC_ADC3DC2 = 1UL<<18, // ADC3DC2
	SYSCFG_PMC_ADC2DC2 = 1UL<<17, // ADC2DC2
	SYSCFG_PMC_ADC1DC2 = 1UL<<16, // ADC1DC2		
};

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI2 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI1 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI0 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 0 to 3)		
};
inline void syscfg_exticr1_set_exti3(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val<<12) & SYSCFG_EXTICR1_EXTI3); }
inline void syscfg_exticr1_set_exti2(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val<<8) & SYSCFG_EXTICR1_EXTI2); }
inline void syscfg_exticr1_set_exti1(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val<<4) & SYSCFG_EXTICR1_EXTI1); }
inline void syscfg_exticr1_set_exti0(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val<<0) & SYSCFG_EXTICR1_EXTI0); }
inline uint32_t syscfg_exticr1_get_exti3(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12 ; }
inline uint32_t syscfg_exticr1_get_exti2(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8 ; }
inline uint32_t syscfg_exticr1_get_exti1(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4 ; }
inline uint32_t syscfg_exticr1_get_exti0(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0 ; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI6 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI5 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI4 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 4 to 7)		
};
inline void syscfg_exticr2_set_exti7(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val<<12) & SYSCFG_EXTICR2_EXTI7); }
inline void syscfg_exticr2_set_exti6(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val<<8) & SYSCFG_EXTICR2_EXTI6); }
inline void syscfg_exticr2_set_exti5(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val<<4) & SYSCFG_EXTICR2_EXTI5); }
inline void syscfg_exticr2_set_exti4(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val<<0) & SYSCFG_EXTICR2_EXTI4); }
inline uint32_t syscfg_exticr2_get_exti7(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12 ; }
inline uint32_t syscfg_exticr2_get_exti6(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8 ; }
inline uint32_t syscfg_exticr2_get_exti5(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4 ; }
inline uint32_t syscfg_exticr2_get_exti4(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0 ; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI10 = ((1UL<<4)-1) << 8, // EXTI10
	SYSCFG_EXTICR3_EXTI9 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI8 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 8 to 11)		
};
inline void syscfg_exticr3_set_exti11(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val<<12) & SYSCFG_EXTICR3_EXTI11); }
inline void syscfg_exticr3_set_exti10(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val<<8) & SYSCFG_EXTICR3_EXTI10); }
inline void syscfg_exticr3_set_exti9(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val<<4) & SYSCFG_EXTICR3_EXTI9); }
inline void syscfg_exticr3_set_exti8(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val<<0) & SYSCFG_EXTICR3_EXTI8); }
inline uint32_t syscfg_exticr3_get_exti11(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12 ; }
inline uint32_t syscfg_exticr3_get_exti10(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8 ; }
inline uint32_t syscfg_exticr3_get_exti9(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4 ; }
inline uint32_t syscfg_exticr3_get_exti8(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0 ; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI14 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI13 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI12 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 12 to 15)		
};
inline void syscfg_exticr4_set_exti15(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val<<12) & SYSCFG_EXTICR4_EXTI15); }
inline void syscfg_exticr4_set_exti14(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val<<8) & SYSCFG_EXTICR4_EXTI14); }
inline void syscfg_exticr4_set_exti13(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val<<4) & SYSCFG_EXTICR4_EXTI13); }
inline void syscfg_exticr4_set_exti12(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val<<0) & SYSCFG_EXTICR4_EXTI12); }
inline uint32_t syscfg_exticr4_get_exti15(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12 ; }
inline uint32_t syscfg_exticr4_get_exti14(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8 ; }
inline uint32_t syscfg_exticr4_get_exti13(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4 ; }
inline uint32_t syscfg_exticr4_get_exti12(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0 ; }

// SYSCFG->CMPCR Compensation cell control register
enum {
	SYSCFG_CMPCR_READY = 1UL<<8, // READY
	SYSCFG_CMPCR_CMP_PD = 1UL<<0, // Compensation cell power-down		
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED9[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED10[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED11[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED12[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED13[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED14[2]; // @58 
	__IO uint16_t CCR3; // @60 capture/compare register 3
	 uint8_t RESERVED15[2]; // @62 
	__IO uint16_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED16[2]; // @66 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED17[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED18[6]; // @78 
	__IO uint32_t CCMR3_Output; // @84 capture/compare mode register 3 (output mode)
	__IO uint32_t CCR5; // @88 capture/compare register 5
	__IO uint16_t CRR6; // @92 capture/compare register 6
	 uint8_t RESERVED19[2]; // @94 
	__IO uint16_t AF1; // @96 alternate function option register 1
	 uint8_t RESERVED20[2]; // @98 
	__IO uint16_t AF2; // @100 alternate function option register 2
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM1_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR = 1UL<<4, // Direction
	TIM1_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM1_CR1_URS = 1UL<<2, // Update request source
	TIM1_CR1_UDIS = 1UL<<1, // Update disable
	TIM1_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val<<8) & TIM1_CR1_CKD); }
inline void tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val<<5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8 ; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5 ; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_OIS4 = 1UL<<14, // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL<<13, // Output Idle state 3
	TIM1_CR2_OIS3 = 1UL<<12, // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL<<11, // Output Idle state 2
	TIM1_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM1_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM1_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM1_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM1_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM1_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM1_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
inline void tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val<<4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4 ; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM1_SMCR_ECE = 1UL<<14, // External clock enable
	TIM1_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM1_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM1_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM1_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val<<12) & TIM1_SMCR_ETPS); }
inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val<<8) & TIM1_SMCR_ETF); }
inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val<<4) & TIM1_SMCR_TS); }
inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val<<0) & TIM1_SMCR_SMS); }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12 ; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8 ; }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 4 ; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0 ; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM1_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM1_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM1->SR status register
enum {
	TIM1_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM1_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM1_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM1_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM1_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_BG = 1UL<<7, // Break generation
	TIM1_EGR_TG = 1UL<<6, // Trigger generation
	TIM1_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM1_EGR_UG = 1UL<<0, // Update generation		
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM1_CCMR1_OUTPUT_OC2M); }
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM1_CCMR1_OUTPUT_CC2S); }
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM1_CCMR1_OUTPUT_OC1M); }
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM1_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM1_CCMR2_OUTPUT_OC4M); }
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM1_CCMR2_OUTPUT_CC4S); }
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM1_CCMR2_OUTPUT_OC3M); }
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM1_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL<<10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL<<6, // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_BK2P = 1UL<<25, // Break 2 polarity
	TIM1_BDTR_BK2E = 1UL<<24, // Break 2 enable
	TIM1_BDTR_BK2F = ((1UL<<4)-1) << 20, // Break 2 filter
	TIM1_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM1_BDTR_MOE = 1UL<<15, // Main output enable
	TIM1_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM1_BDTR_BKP = 1UL<<13, // Break polarity
	TIM1_BDTR_BKE = 1UL<<12, // Break enable
	TIM1_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM1_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim1_bdtr_set_bk2f(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BK2F) | ((val<<20) & TIM1_BDTR_BK2F); }
inline void tim1_bdtr_set_bkf(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BKF) | ((val<<16) & TIM1_BDTR_BKF); }
inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val<<8) & TIM1_BDTR_LOCK); }
inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val<<0) & TIM1_BDTR_DTG); }
inline uint32_t tim1_bdtr_get_bk2f(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BK2F) >> 20 ; }
inline uint32_t tim1_bdtr_get_bkf(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BKF) >> 16 ; }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8 ; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0 ; }

// TIM1->DCR DMA control register
enum {
	TIM1_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val<<8) & TIM1_DCR_DBL); }
inline void tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val<<0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8 ; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0 ; }

// TIM1->CCMR3_Output capture/compare mode register 3 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M3 = 1UL<<24, // Output Compare 6 mode
	TIM1_CCMR3_OUTPUT_OC5M3 = 1UL<<16, // Output Compare 5 mode
	TIM1_CCMR3_OUTPUT_OC6CE = 1UL<<15, // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M = ((1UL<<3)-1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE = 1UL<<11, // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE = 1UL<<10, // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE = 1UL<<7, // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M = ((1UL<<3)-1) << 4, // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE = 1UL<<3, // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE = 1UL<<2, // Output compare 5 fast enable		
};
inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val<<12) & TIM1_CCMR3_OUTPUT_OC6M); }
inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val<<4) & TIM1_CCMR3_OUTPUT_OC5M); }
inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12 ; }
inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4 ; }

// TIM1->CCR5 capture/compare register 5
enum {
	TIM1_CCR5_GC5C3 = 1UL<<31, // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL<<30, // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL<<29, // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5 = ((1UL<<16)-1) << 0, // Capture/Compare 5 value		
};
inline void tim1_ccr5_set_ccr5(struct TIM1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val<<0) & TIM1_CCR5_CCR5); }
inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type* p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0 ; }

// TIM1->AF1 alternate function option register 1
enum {
	TIM1_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM1_AF1_BKDFBKE = 1UL<<8, // BRK DFSDM_BREAK[0] enable
	TIM1_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM1->AF2 alternate function option register 2
enum {
	TIM1_AF2_BK2INP = 1UL<<9, // BRK2 BKIN2 input polarity
	TIM1_AF2_BK2DFBKE = 1UL<<8, // BRK2 DFSDM_BREAK enable
	TIM1_AF2_BK2INE = 1UL<<0, // BRK2 BKIN input enable		
};

// Valid Casts:
 
inline struct TIM6_Type* TIM1_as_TIM6_Type(struct TIM1_Type* p) { return (struct TIM6_Type*)p; }


/* General-purpose-timers */
struct TIM10_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[6]; // @2 
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint8_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED2[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED3[3]; // @21 
	union {  // @24
		__IO uint8_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED4[7]; // @25 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED5[3]; // @33 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED6[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[6]; // @46 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED9[26]; // @54 
	__IO uint8_t OR; // @80 option register
};

// TIM10->CR1 control register 1
enum {
	TIM10_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM10_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM10_CR1_URS = 1UL<<2, // Update request source
	TIM10_CR1_UDIS = 1UL<<1, // Update disable
	TIM10_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim10_cr1_set_ckd(struct TIM10_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM10_CR1_CKD) | ((val<<8) & TIM10_CR1_CKD); }
inline uint32_t tim10_cr1_get_ckd(struct TIM10_Type* p) { return (p->CR1 & TIM10_CR1_CKD) >> 8 ; }

// TIM10->SMCR slave mode control register
enum {
	TIM10_SMCR_SMS3 = 1UL<<16, // Slave mode selection
	TIM10_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM10_SMCR_ECE = 1UL<<14, // External clock enable
	TIM10_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM10_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM10_SMCR_MSM = 1UL<<7, // Master/slave mode
	TIM10_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM10_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim10_smcr_set_etps(struct TIM10_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM10_SMCR_ETPS) | ((val<<12) & TIM10_SMCR_ETPS); }
inline void tim10_smcr_set_etf(struct TIM10_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM10_SMCR_ETF) | ((val<<8) & TIM10_SMCR_ETF); }
inline void tim10_smcr_set_ts(struct TIM10_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM10_SMCR_TS) | ((val<<4) & TIM10_SMCR_TS); }
inline void tim10_smcr_set_sms(struct TIM10_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM10_SMCR_SMS) | ((val<<0) & TIM10_SMCR_SMS); }
inline uint32_t tim10_smcr_get_etps(struct TIM10_Type* p) { return (p->SMCR & TIM10_SMCR_ETPS) >> 12 ; }
inline uint32_t tim10_smcr_get_etf(struct TIM10_Type* p) { return (p->SMCR & TIM10_SMCR_ETF) >> 8 ; }
inline uint32_t tim10_smcr_get_ts(struct TIM10_Type* p) { return (p->SMCR & TIM10_SMCR_TS) >> 4 ; }
inline uint32_t tim10_smcr_get_sms(struct TIM10_Type* p) { return (p->SMCR & TIM10_SMCR_SMS) >> 0 ; }

// TIM10->DIER DMA/Interrupt enable register
enum {
	TIM10_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM10_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM10->SR status register
enum {
	TIM10_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM10_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM10_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM10->EGR event generation register
enum {
	TIM10_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM10_EGR_UG = 1UL<<0, // Update generation		
};

// TIM10->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM10_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM10_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM10_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM10_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim10_ccmr1_output_set_oc1m(struct TIM10_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM10_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM10_CCMR1_OUTPUT_OC1M); }
inline void tim10_ccmr1_output_set_cc1s(struct TIM10_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM10_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM10_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim10_ccmr1_output_get_oc1m(struct TIM10_Type* p) { return (p->CCMR1_Output & TIM10_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim10_ccmr1_output_get_cc1s(struct TIM10_Type* p) { return (p->CCMR1_Output & TIM10_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM10->CCER capture/compare enable register
enum {
	TIM10_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM10_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM10_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM10->OR option register
enum {
	TIM10_OR_TI1_RMP = ((1UL<<2)-1) << 0, // TIM11 Input 1 remapping capability		
};
inline void tim10_or_set_ti1_rmp(struct TIM10_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM10_OR_TI1_RMP) | ((val<<0) & TIM10_OR_TI1_RMP); }
inline uint32_t tim10_or_get_ti1_rmp(struct TIM10_Type* p) { return (p->OR & TIM10_OR_TI1_RMP) >> 0 ; }





/* General purpose timers */
struct TIM2_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED9[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED10[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED11[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED13[2]; // @78 
	__IO uint8_t OR1; // @80 TIM2 option register 1
	 uint8_t RESERVED14[15]; // @81 
	__IO uint32_t OR2; // @96 TIM2 option register 2
};

// TIM2->CR1 control register 1
enum {
	TIM2_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM2_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM2_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM2_CR1_DIR = 1UL<<4, // Direction
	TIM2_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM2_CR1_URS = 1UL<<2, // Update request source
	TIM2_CR1_UDIS = 1UL<<1, // Update disable
	TIM2_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim2_cr1_set_ckd(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CKD) | ((val<<8) & TIM2_CR1_CKD); }
inline void tim2_cr1_set_cms(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CMS) | ((val<<5) & TIM2_CR1_CMS); }
inline uint32_t tim2_cr1_get_ckd(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CKD) >> 8 ; }
inline uint32_t tim2_cr1_get_cms(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CMS) >> 5 ; }

// TIM2->CR2 control register 2
enum {
	TIM2_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM2_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM2_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
inline void tim2_cr2_set_mms(struct TIM2_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM2_CR2_MMS) | ((val<<4) & TIM2_CR2_MMS); }
inline uint32_t tim2_cr2_get_mms(struct TIM2_Type* p) { return (p->CR2 & TIM2_CR2_MMS) >> 4 ; }

// TIM2->SMCR slave mode control register
enum {
	TIM2_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM2_SMCR_ECE = 1UL<<14, // External clock enable
	TIM2_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM2_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM2_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM2_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM2_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim2_smcr_set_etps(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETPS) | ((val<<12) & TIM2_SMCR_ETPS); }
inline void tim2_smcr_set_etf(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETF) | ((val<<8) & TIM2_SMCR_ETF); }
inline void tim2_smcr_set_ts(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS) | ((val<<4) & TIM2_SMCR_TS); }
inline void tim2_smcr_set_sms(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_SMS) | ((val<<0) & TIM2_SMCR_SMS); }
inline uint32_t tim2_smcr_get_etps(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETPS) >> 12 ; }
inline uint32_t tim2_smcr_get_etf(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETF) >> 8 ; }
inline uint32_t tim2_smcr_get_ts(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS) >> 4 ; }
inline uint32_t tim2_smcr_get_sms(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_SMS) >> 0 ; }

// TIM2->DIER DMA/Interrupt enable register
enum {
	TIM2_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM2_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM2_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM2_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM2_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM2_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM2_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM2_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM2_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM2_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM2_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM2_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM2->SR status register
enum {
	TIM2_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM2_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM2_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM2_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM2_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM2_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM2_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM2_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM2_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM2_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM2->EGR event generation register
enum {
	TIM2_EGR_TG = 1UL<<6, // Trigger generation
	TIM2_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM2_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM2_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM2_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM2_EGR_UG = 1UL<<0, // Update generation		
};

// TIM2->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM2_CCMR1_OUTPUT_OC2CE = 1UL<<15, // OC2CE
	TIM2_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // OC2M
	TIM2_CCMR1_OUTPUT_OC2PE = 1UL<<11, // OC2PE
	TIM2_CCMR1_OUTPUT_OC2FE = 1UL<<10, // OC2FE
	TIM2_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // CC2S
	TIM2_CCMR1_OUTPUT_OC1CE = 1UL<<7, // OC1CE
	TIM2_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // OC1M
	TIM2_CCMR1_OUTPUT_OC1PE = 1UL<<3, // OC1PE
	TIM2_CCMR1_OUTPUT_OC1FE = 1UL<<2, // OC1FE
	TIM2_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // CC1S		
};
inline void tim2_ccmr1_output_set_oc2m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM2_CCMR1_OUTPUT_OC2M); }
inline void tim2_ccmr1_output_set_cc2s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM2_CCMR1_OUTPUT_CC2S); }
inline void tim2_ccmr1_output_set_oc1m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM2_CCMR1_OUTPUT_OC1M); }
inline void tim2_ccmr1_output_set_cc1s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM2_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim2_ccmr1_output_get_oc2m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim2_ccmr1_output_get_cc2s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim2_ccmr1_output_get_oc1m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim2_ccmr1_output_get_cc1s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM2->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM2_CCMR2_OUTPUT_O24CE = 1UL<<15, // O24CE
	TIM2_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // OC4M
	TIM2_CCMR2_OUTPUT_OC4PE = 1UL<<11, // OC4PE
	TIM2_CCMR2_OUTPUT_OC4FE = 1UL<<10, // OC4FE
	TIM2_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // CC4S
	TIM2_CCMR2_OUTPUT_OC3CE = 1UL<<7, // OC3CE
	TIM2_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // OC3M
	TIM2_CCMR2_OUTPUT_OC3PE = 1UL<<3, // OC3PE
	TIM2_CCMR2_OUTPUT_OC3FE = 1UL<<2, // OC3FE
	TIM2_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // CC3S		
};
inline void tim2_ccmr2_output_set_oc4m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM2_CCMR2_OUTPUT_OC4M); }
inline void tim2_ccmr2_output_set_cc4s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM2_CCMR2_OUTPUT_CC4S); }
inline void tim2_ccmr2_output_set_oc3m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM2_CCMR2_OUTPUT_OC3M); }
inline void tim2_ccmr2_output_set_cc3s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM2_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim2_ccmr2_output_get_oc4m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim2_ccmr2_output_get_cc4s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim2_ccmr2_output_get_oc3m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim2_ccmr2_output_get_cc3s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM2->CCER capture/compare enable register
enum {
	TIM2_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM2_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM2_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM2_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM2_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM2->CNT counter
enum {
	TIM2_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value
	TIM2_CNT_CNT_L = ((1UL<<16)-1) << 0, // Low counter value		
};
inline void tim2_cnt_set_cnt_h(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_H) | ((val<<16) & TIM2_CNT_CNT_H); }
inline void tim2_cnt_set_cnt_l(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_L) | ((val<<0) & TIM2_CNT_CNT_L); }
inline uint32_t tim2_cnt_get_cnt_h(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_H) >> 16 ; }
inline uint32_t tim2_cnt_get_cnt_l(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_L) >> 0 ; }

// TIM2->ARR auto-reload register
enum {
	TIM2_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value
	TIM2_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
inline void tim2_arr_set_arr_h(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_H) | ((val<<16) & TIM2_ARR_ARR_H); }
inline void tim2_arr_set_arr_l(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_L) | ((val<<0) & TIM2_ARR_ARR_L); }
inline uint32_t tim2_arr_get_arr_h(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_H) >> 16 ; }
inline uint32_t tim2_arr_get_arr_l(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_L) >> 0 ; }

// TIM2->CCR1 capture/compare register 1
enum {
	TIM2_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value
	TIM2_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
inline void tim2_ccr1_set_ccr1_h(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_H) | ((val<<16) & TIM2_CCR1_CCR1_H); }
inline void tim2_ccr1_set_ccr1_l(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_L) | ((val<<0) & TIM2_CCR1_CCR1_L); }
inline uint32_t tim2_ccr1_get_ccr1_h(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_H) >> 16 ; }
inline uint32_t tim2_ccr1_get_ccr1_l(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_L) >> 0 ; }

// TIM2->CCR2 capture/compare register 2
enum {
	TIM2_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value
	TIM2_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
inline void tim2_ccr2_set_ccr2_h(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_H) | ((val<<16) & TIM2_CCR2_CCR2_H); }
inline void tim2_ccr2_set_ccr2_l(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_L) | ((val<<0) & TIM2_CCR2_CCR2_L); }
inline uint32_t tim2_ccr2_get_ccr2_h(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_H) >> 16 ; }
inline uint32_t tim2_ccr2_get_ccr2_l(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_L) >> 0 ; }

// TIM2->CCR3 capture/compare register 3
enum {
	TIM2_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM2_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr3_set_ccr3_h(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_H) | ((val<<16) & TIM2_CCR3_CCR3_H); }
inline void tim2_ccr3_set_ccr3_l(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_L) | ((val<<0) & TIM2_CCR3_CCR3_L); }
inline uint32_t tim2_ccr3_get_ccr3_h(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_H) >> 16 ; }
inline uint32_t tim2_ccr3_get_ccr3_l(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_L) >> 0 ; }

// TIM2->CCR4 capture/compare register 4
enum {
	TIM2_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM2_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr4_set_ccr4_h(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_H) | ((val<<16) & TIM2_CCR4_CCR4_H); }
inline void tim2_ccr4_set_ccr4_l(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_L) | ((val<<0) & TIM2_CCR4_CCR4_L); }
inline uint32_t tim2_ccr4_get_ccr4_h(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_H) >> 16 ; }
inline uint32_t tim2_ccr4_get_ccr4_l(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_L) >> 0 ; }

// TIM2->DCR DMA control register
enum {
	TIM2_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM2_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim2_dcr_set_dbl(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBL) | ((val<<8) & TIM2_DCR_DBL); }
inline void tim2_dcr_set_dba(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBA) | ((val<<0) & TIM2_DCR_DBA); }
inline uint32_t tim2_dcr_get_dbl(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBL) >> 8 ; }
inline uint32_t tim2_dcr_get_dba(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBA) >> 0 ; }

// TIM2->OR1 TIM2 option register 1
enum {
	TIM2_OR1_TI4_RMP = ((1UL<<2)-1) << 2, // Input Capture 4 remap
	TIM2_OR1_ETR1_RMP = 1UL<<1, // External trigger remap
	TIM2_OR1_ITR1_RMP = 1UL<<0, // Internal trigger 1 remap		
};
inline void tim2_or1_set_ti4_rmp(struct TIM2_Type* p, uint32_t val) { p->OR1 = (p->OR1 & ~TIM2_OR1_TI4_RMP) | ((val<<2) & TIM2_OR1_TI4_RMP); }
inline uint32_t tim2_or1_get_ti4_rmp(struct TIM2_Type* p) { return (p->OR1 & TIM2_OR1_TI4_RMP) >> 2 ; }

// TIM2->OR2 TIM2 option register 2
enum {
	TIM2_OR2_ETRSEL = ((1UL<<3)-1) << 14, // ETR source selection		
};
inline void tim2_or2_set_etrsel(struct TIM2_Type* p, uint32_t val) { p->OR2 = (p->OR2 & ~TIM2_OR2_ETRSEL) | ((val<<14) & TIM2_OR2_ETRSEL); }
inline uint32_t tim2_or2_get_etrsel(struct TIM2_Type* p) { return (p->OR2 & TIM2_OR2_ETRSEL) >> 14 ; }

// Valid Casts:
 
inline struct TIM4_Type* TIM2_as_TIM4_Type(struct TIM2_Type* p) { return (struct TIM4_Type*)p; }


/* General purpose timers */
struct TIM3_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED9[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED10[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED11[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED13[2]; // @78 
	__IO uint8_t OR1; // @80 TIM3 option register 1
	 uint8_t RESERVED14[15]; // @81 
	__IO uint32_t OR2; // @96 TIM3 option register 2
};

// TIM3->CR1 control register 1
enum {
	TIM3_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM3_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM3_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM3_CR1_DIR = 1UL<<4, // Direction
	TIM3_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM3_CR1_URS = 1UL<<2, // Update request source
	TIM3_CR1_UDIS = 1UL<<1, // Update disable
	TIM3_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim3_cr1_set_ckd(struct TIM3_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM3_CR1_CKD) | ((val<<8) & TIM3_CR1_CKD); }
inline void tim3_cr1_set_cms(struct TIM3_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM3_CR1_CMS) | ((val<<5) & TIM3_CR1_CMS); }
inline uint32_t tim3_cr1_get_ckd(struct TIM3_Type* p) { return (p->CR1 & TIM3_CR1_CKD) >> 8 ; }
inline uint32_t tim3_cr1_get_cms(struct TIM3_Type* p) { return (p->CR1 & TIM3_CR1_CMS) >> 5 ; }

// TIM3->CR2 control register 2
enum {
	TIM3_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM3_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM3_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
inline void tim3_cr2_set_mms(struct TIM3_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM3_CR2_MMS) | ((val<<4) & TIM3_CR2_MMS); }
inline uint32_t tim3_cr2_get_mms(struct TIM3_Type* p) { return (p->CR2 & TIM3_CR2_MMS) >> 4 ; }

// TIM3->SMCR slave mode control register
enum {
	TIM3_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM3_SMCR_ECE = 1UL<<14, // External clock enable
	TIM3_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM3_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM3_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM3_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM3_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim3_smcr_set_etps(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_ETPS) | ((val<<12) & TIM3_SMCR_ETPS); }
inline void tim3_smcr_set_etf(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_ETF) | ((val<<8) & TIM3_SMCR_ETF); }
inline void tim3_smcr_set_ts(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_TS) | ((val<<4) & TIM3_SMCR_TS); }
inline void tim3_smcr_set_sms(struct TIM3_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM3_SMCR_SMS) | ((val<<0) & TIM3_SMCR_SMS); }
inline uint32_t tim3_smcr_get_etps(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_ETPS) >> 12 ; }
inline uint32_t tim3_smcr_get_etf(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_ETF) >> 8 ; }
inline uint32_t tim3_smcr_get_ts(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_TS) >> 4 ; }
inline uint32_t tim3_smcr_get_sms(struct TIM3_Type* p) { return (p->SMCR & TIM3_SMCR_SMS) >> 0 ; }

// TIM3->DIER DMA/Interrupt enable register
enum {
	TIM3_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM3_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM3_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM3_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM3_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM3_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM3_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM3_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM3_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM3_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM3_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM3_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM3->SR status register
enum {
	TIM3_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM3_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM3_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM3_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM3_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM3_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM3_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM3_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM3_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM3_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM3->EGR event generation register
enum {
	TIM3_EGR_TG = 1UL<<6, // Trigger generation
	TIM3_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM3_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM3_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM3_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM3_EGR_UG = 1UL<<0, // Update generation		
};

// TIM3->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM3_CCMR1_OUTPUT_OC2CE = 1UL<<15, // OC2CE
	TIM3_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // OC2M
	TIM3_CCMR1_OUTPUT_OC2PE = 1UL<<11, // OC2PE
	TIM3_CCMR1_OUTPUT_OC2FE = 1UL<<10, // OC2FE
	TIM3_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // CC2S
	TIM3_CCMR1_OUTPUT_OC1CE = 1UL<<7, // OC1CE
	TIM3_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // OC1M
	TIM3_CCMR1_OUTPUT_OC1PE = 1UL<<3, // OC1PE
	TIM3_CCMR1_OUTPUT_OC1FE = 1UL<<2, // OC1FE
	TIM3_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // CC1S		
};
inline void tim3_ccmr1_output_set_oc2m(struct TIM3_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM3_CCMR1_OUTPUT_OC2M); }
inline void tim3_ccmr1_output_set_cc2s(struct TIM3_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM3_CCMR1_OUTPUT_CC2S); }
inline void tim3_ccmr1_output_set_oc1m(struct TIM3_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM3_CCMR1_OUTPUT_OC1M); }
inline void tim3_ccmr1_output_set_cc1s(struct TIM3_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM3_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM3_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim3_ccmr1_output_get_oc2m(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim3_ccmr1_output_get_cc2s(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim3_ccmr1_output_get_oc1m(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim3_ccmr1_output_get_cc1s(struct TIM3_Type* p) { return (p->CCMR1_Output & TIM3_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM3->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM3_CCMR2_OUTPUT_O24CE = 1UL<<15, // O24CE
	TIM3_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // OC4M
	TIM3_CCMR2_OUTPUT_OC4PE = 1UL<<11, // OC4PE
	TIM3_CCMR2_OUTPUT_OC4FE = 1UL<<10, // OC4FE
	TIM3_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // CC4S
	TIM3_CCMR2_OUTPUT_OC3CE = 1UL<<7, // OC3CE
	TIM3_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // OC3M
	TIM3_CCMR2_OUTPUT_OC3PE = 1UL<<3, // OC3PE
	TIM3_CCMR2_OUTPUT_OC3FE = 1UL<<2, // OC3FE
	TIM3_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // CC3S		
};
inline void tim3_ccmr2_output_set_oc4m(struct TIM3_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM3_CCMR2_OUTPUT_OC4M); }
inline void tim3_ccmr2_output_set_cc4s(struct TIM3_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM3_CCMR2_OUTPUT_CC4S); }
inline void tim3_ccmr2_output_set_oc3m(struct TIM3_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM3_CCMR2_OUTPUT_OC3M); }
inline void tim3_ccmr2_output_set_cc3s(struct TIM3_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM3_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM3_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim3_ccmr2_output_get_oc4m(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim3_ccmr2_output_get_cc4s(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim3_ccmr2_output_get_oc3m(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim3_ccmr2_output_get_cc3s(struct TIM3_Type* p) { return (p->CCMR2_Output & TIM3_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM3->CCER capture/compare enable register
enum {
	TIM3_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM3_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM3_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM3_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM3_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM3_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM3_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM3_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM3_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM3_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM3_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM3_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM3->CNT counter
enum {
	TIM3_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value
	TIM3_CNT_CNT_L = ((1UL<<16)-1) << 0, // Low counter value		
};
inline void tim3_cnt_set_cnt_h(struct TIM3_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM3_CNT_CNT_H) | ((val<<16) & TIM3_CNT_CNT_H); }
inline void tim3_cnt_set_cnt_l(struct TIM3_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM3_CNT_CNT_L) | ((val<<0) & TIM3_CNT_CNT_L); }
inline uint32_t tim3_cnt_get_cnt_h(struct TIM3_Type* p) { return (p->CNT & TIM3_CNT_CNT_H) >> 16 ; }
inline uint32_t tim3_cnt_get_cnt_l(struct TIM3_Type* p) { return (p->CNT & TIM3_CNT_CNT_L) >> 0 ; }

// TIM3->ARR auto-reload register
enum {
	TIM3_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value
	TIM3_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
inline void tim3_arr_set_arr_h(struct TIM3_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM3_ARR_ARR_H) | ((val<<16) & TIM3_ARR_ARR_H); }
inline void tim3_arr_set_arr_l(struct TIM3_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM3_ARR_ARR_L) | ((val<<0) & TIM3_ARR_ARR_L); }
inline uint32_t tim3_arr_get_arr_h(struct TIM3_Type* p) { return (p->ARR & TIM3_ARR_ARR_H) >> 16 ; }
inline uint32_t tim3_arr_get_arr_l(struct TIM3_Type* p) { return (p->ARR & TIM3_ARR_ARR_L) >> 0 ; }

// TIM3->CCR1 capture/compare register 1
enum {
	TIM3_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value
	TIM3_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
inline void tim3_ccr1_set_ccr1_h(struct TIM3_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM3_CCR1_CCR1_H) | ((val<<16) & TIM3_CCR1_CCR1_H); }
inline void tim3_ccr1_set_ccr1_l(struct TIM3_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM3_CCR1_CCR1_L) | ((val<<0) & TIM3_CCR1_CCR1_L); }
inline uint32_t tim3_ccr1_get_ccr1_h(struct TIM3_Type* p) { return (p->CCR1 & TIM3_CCR1_CCR1_H) >> 16 ; }
inline uint32_t tim3_ccr1_get_ccr1_l(struct TIM3_Type* p) { return (p->CCR1 & TIM3_CCR1_CCR1_L) >> 0 ; }

// TIM3->CCR2 capture/compare register 2
enum {
	TIM3_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value
	TIM3_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
inline void tim3_ccr2_set_ccr2_h(struct TIM3_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM3_CCR2_CCR2_H) | ((val<<16) & TIM3_CCR2_CCR2_H); }
inline void tim3_ccr2_set_ccr2_l(struct TIM3_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM3_CCR2_CCR2_L) | ((val<<0) & TIM3_CCR2_CCR2_L); }
inline uint32_t tim3_ccr2_get_ccr2_h(struct TIM3_Type* p) { return (p->CCR2 & TIM3_CCR2_CCR2_H) >> 16 ; }
inline uint32_t tim3_ccr2_get_ccr2_l(struct TIM3_Type* p) { return (p->CCR2 & TIM3_CCR2_CCR2_L) >> 0 ; }

// TIM3->CCR3 capture/compare register 3
enum {
	TIM3_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM3_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim3_ccr3_set_ccr3_h(struct TIM3_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM3_CCR3_CCR3_H) | ((val<<16) & TIM3_CCR3_CCR3_H); }
inline void tim3_ccr3_set_ccr3_l(struct TIM3_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM3_CCR3_CCR3_L) | ((val<<0) & TIM3_CCR3_CCR3_L); }
inline uint32_t tim3_ccr3_get_ccr3_h(struct TIM3_Type* p) { return (p->CCR3 & TIM3_CCR3_CCR3_H) >> 16 ; }
inline uint32_t tim3_ccr3_get_ccr3_l(struct TIM3_Type* p) { return (p->CCR3 & TIM3_CCR3_CCR3_L) >> 0 ; }

// TIM3->CCR4 capture/compare register 4
enum {
	TIM3_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM3_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim3_ccr4_set_ccr4_h(struct TIM3_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM3_CCR4_CCR4_H) | ((val<<16) & TIM3_CCR4_CCR4_H); }
inline void tim3_ccr4_set_ccr4_l(struct TIM3_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM3_CCR4_CCR4_L) | ((val<<0) & TIM3_CCR4_CCR4_L); }
inline uint32_t tim3_ccr4_get_ccr4_h(struct TIM3_Type* p) { return (p->CCR4 & TIM3_CCR4_CCR4_H) >> 16 ; }
inline uint32_t tim3_ccr4_get_ccr4_l(struct TIM3_Type* p) { return (p->CCR4 & TIM3_CCR4_CCR4_L) >> 0 ; }

// TIM3->DCR DMA control register
enum {
	TIM3_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM3_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim3_dcr_set_dbl(struct TIM3_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM3_DCR_DBL) | ((val<<8) & TIM3_DCR_DBL); }
inline void tim3_dcr_set_dba(struct TIM3_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM3_DCR_DBA) | ((val<<0) & TIM3_DCR_DBA); }
inline uint32_t tim3_dcr_get_dbl(struct TIM3_Type* p) { return (p->DCR & TIM3_DCR_DBL) >> 8 ; }
inline uint32_t tim3_dcr_get_dba(struct TIM3_Type* p) { return (p->DCR & TIM3_DCR_DBA) >> 0 ; }

// TIM3->OR1 TIM3 option register 1
enum {
	TIM3_OR1_TI1_RMP = ((1UL<<2)-1) << 0, // Input Capture 1 remap		
};
inline void tim3_or1_set_ti1_rmp(struct TIM3_Type* p, uint32_t val) { p->OR1 = (p->OR1 & ~TIM3_OR1_TI1_RMP) | ((val<<0) & TIM3_OR1_TI1_RMP); }
inline uint32_t tim3_or1_get_ti1_rmp(struct TIM3_Type* p) { return (p->OR1 & TIM3_OR1_TI1_RMP) >> 0 ; }

// TIM3->OR2 TIM3 option register 2
enum {
	TIM3_OR2_ETRSEL = ((1UL<<3)-1) << 14, // ETR source selection		
};
inline void tim3_or2_set_etrsel(struct TIM3_Type* p, uint32_t val) { p->OR2 = (p->OR2 & ~TIM3_OR2_ETRSEL) | ((val<<14) & TIM3_OR2_ETRSEL); }
inline uint32_t tim3_or2_get_etrsel(struct TIM3_Type* p) { return (p->OR2 & TIM3_OR2_ETRSEL) >> 14 ; }

// Valid Casts:
 
inline struct TIM4_Type* TIM3_as_TIM4_Type(struct TIM3_Type* p) { return (struct TIM4_Type*)p; }


/* General purpose timers */
struct TIM4_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED9[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED10[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED11[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
};

// TIM4->CR1 control register 1
enum {
	TIM4_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM4_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM4_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM4_CR1_DIR = 1UL<<4, // Direction
	TIM4_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM4_CR1_URS = 1UL<<2, // Update request source
	TIM4_CR1_UDIS = 1UL<<1, // Update disable
	TIM4_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim4_cr1_set_ckd(struct TIM4_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM4_CR1_CKD) | ((val<<8) & TIM4_CR1_CKD); }
inline void tim4_cr1_set_cms(struct TIM4_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM4_CR1_CMS) | ((val<<5) & TIM4_CR1_CMS); }
inline uint32_t tim4_cr1_get_ckd(struct TIM4_Type* p) { return (p->CR1 & TIM4_CR1_CKD) >> 8 ; }
inline uint32_t tim4_cr1_get_cms(struct TIM4_Type* p) { return (p->CR1 & TIM4_CR1_CMS) >> 5 ; }

// TIM4->CR2 control register 2
enum {
	TIM4_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM4_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM4_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
inline void tim4_cr2_set_mms(struct TIM4_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM4_CR2_MMS) | ((val<<4) & TIM4_CR2_MMS); }
inline uint32_t tim4_cr2_get_mms(struct TIM4_Type* p) { return (p->CR2 & TIM4_CR2_MMS) >> 4 ; }

// TIM4->SMCR slave mode control register
enum {
	TIM4_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM4_SMCR_ECE = 1UL<<14, // External clock enable
	TIM4_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM4_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM4_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM4_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM4_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim4_smcr_set_etps(struct TIM4_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM4_SMCR_ETPS) | ((val<<12) & TIM4_SMCR_ETPS); }
inline void tim4_smcr_set_etf(struct TIM4_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM4_SMCR_ETF) | ((val<<8) & TIM4_SMCR_ETF); }
inline void tim4_smcr_set_ts(struct TIM4_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM4_SMCR_TS) | ((val<<4) & TIM4_SMCR_TS); }
inline void tim4_smcr_set_sms(struct TIM4_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM4_SMCR_SMS) | ((val<<0) & TIM4_SMCR_SMS); }
inline uint32_t tim4_smcr_get_etps(struct TIM4_Type* p) { return (p->SMCR & TIM4_SMCR_ETPS) >> 12 ; }
inline uint32_t tim4_smcr_get_etf(struct TIM4_Type* p) { return (p->SMCR & TIM4_SMCR_ETF) >> 8 ; }
inline uint32_t tim4_smcr_get_ts(struct TIM4_Type* p) { return (p->SMCR & TIM4_SMCR_TS) >> 4 ; }
inline uint32_t tim4_smcr_get_sms(struct TIM4_Type* p) { return (p->SMCR & TIM4_SMCR_SMS) >> 0 ; }

// TIM4->DIER DMA/Interrupt enable register
enum {
	TIM4_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM4_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM4_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM4_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM4_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM4_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM4_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM4_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM4_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM4_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM4_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM4_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM4->SR status register
enum {
	TIM4_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM4_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM4_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM4_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM4_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM4_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM4_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM4_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM4_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM4_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM4->EGR event generation register
enum {
	TIM4_EGR_TG = 1UL<<6, // Trigger generation
	TIM4_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM4_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM4_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM4_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM4_EGR_UG = 1UL<<0, // Update generation		
};

// TIM4->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM4_CCMR1_OUTPUT_OC2CE = 1UL<<15, // OC2CE
	TIM4_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // OC2M
	TIM4_CCMR1_OUTPUT_OC2PE = 1UL<<11, // OC2PE
	TIM4_CCMR1_OUTPUT_OC2FE = 1UL<<10, // OC2FE
	TIM4_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // CC2S
	TIM4_CCMR1_OUTPUT_OC1CE = 1UL<<7, // OC1CE
	TIM4_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // OC1M
	TIM4_CCMR1_OUTPUT_OC1PE = 1UL<<3, // OC1PE
	TIM4_CCMR1_OUTPUT_OC1FE = 1UL<<2, // OC1FE
	TIM4_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // CC1S		
};
inline void tim4_ccmr1_output_set_oc2m(struct TIM4_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM4_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM4_CCMR1_OUTPUT_OC2M); }
inline void tim4_ccmr1_output_set_cc2s(struct TIM4_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM4_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM4_CCMR1_OUTPUT_CC2S); }
inline void tim4_ccmr1_output_set_oc1m(struct TIM4_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM4_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM4_CCMR1_OUTPUT_OC1M); }
inline void tim4_ccmr1_output_set_cc1s(struct TIM4_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM4_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM4_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim4_ccmr1_output_get_oc2m(struct TIM4_Type* p) { return (p->CCMR1_Output & TIM4_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim4_ccmr1_output_get_cc2s(struct TIM4_Type* p) { return (p->CCMR1_Output & TIM4_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim4_ccmr1_output_get_oc1m(struct TIM4_Type* p) { return (p->CCMR1_Output & TIM4_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim4_ccmr1_output_get_cc1s(struct TIM4_Type* p) { return (p->CCMR1_Output & TIM4_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM4->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM4_CCMR2_OUTPUT_O24CE = 1UL<<15, // O24CE
	TIM4_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // OC4M
	TIM4_CCMR2_OUTPUT_OC4PE = 1UL<<11, // OC4PE
	TIM4_CCMR2_OUTPUT_OC4FE = 1UL<<10, // OC4FE
	TIM4_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // CC4S
	TIM4_CCMR2_OUTPUT_OC3CE = 1UL<<7, // OC3CE
	TIM4_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // OC3M
	TIM4_CCMR2_OUTPUT_OC3PE = 1UL<<3, // OC3PE
	TIM4_CCMR2_OUTPUT_OC3FE = 1UL<<2, // OC3FE
	TIM4_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // CC3S		
};
inline void tim4_ccmr2_output_set_oc4m(struct TIM4_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM4_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM4_CCMR2_OUTPUT_OC4M); }
inline void tim4_ccmr2_output_set_cc4s(struct TIM4_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM4_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM4_CCMR2_OUTPUT_CC4S); }
inline void tim4_ccmr2_output_set_oc3m(struct TIM4_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM4_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM4_CCMR2_OUTPUT_OC3M); }
inline void tim4_ccmr2_output_set_cc3s(struct TIM4_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM4_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM4_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim4_ccmr2_output_get_oc4m(struct TIM4_Type* p) { return (p->CCMR2_Output & TIM4_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim4_ccmr2_output_get_cc4s(struct TIM4_Type* p) { return (p->CCMR2_Output & TIM4_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim4_ccmr2_output_get_oc3m(struct TIM4_Type* p) { return (p->CCMR2_Output & TIM4_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim4_ccmr2_output_get_cc3s(struct TIM4_Type* p) { return (p->CCMR2_Output & TIM4_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM4->CCER capture/compare enable register
enum {
	TIM4_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM4_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM4_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM4_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM4_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM4_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM4_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM4_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM4_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM4_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM4_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM4_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM4->CNT counter
enum {
	TIM4_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value
	TIM4_CNT_CNT_L = ((1UL<<16)-1) << 0, // Low counter value		
};
inline void tim4_cnt_set_cnt_h(struct TIM4_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM4_CNT_CNT_H) | ((val<<16) & TIM4_CNT_CNT_H); }
inline void tim4_cnt_set_cnt_l(struct TIM4_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM4_CNT_CNT_L) | ((val<<0) & TIM4_CNT_CNT_L); }
inline uint32_t tim4_cnt_get_cnt_h(struct TIM4_Type* p) { return (p->CNT & TIM4_CNT_CNT_H) >> 16 ; }
inline uint32_t tim4_cnt_get_cnt_l(struct TIM4_Type* p) { return (p->CNT & TIM4_CNT_CNT_L) >> 0 ; }

// TIM4->ARR auto-reload register
enum {
	TIM4_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value
	TIM4_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
inline void tim4_arr_set_arr_h(struct TIM4_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM4_ARR_ARR_H) | ((val<<16) & TIM4_ARR_ARR_H); }
inline void tim4_arr_set_arr_l(struct TIM4_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM4_ARR_ARR_L) | ((val<<0) & TIM4_ARR_ARR_L); }
inline uint32_t tim4_arr_get_arr_h(struct TIM4_Type* p) { return (p->ARR & TIM4_ARR_ARR_H) >> 16 ; }
inline uint32_t tim4_arr_get_arr_l(struct TIM4_Type* p) { return (p->ARR & TIM4_ARR_ARR_L) >> 0 ; }

// TIM4->CCR1 capture/compare register 1
enum {
	TIM4_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value
	TIM4_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
inline void tim4_ccr1_set_ccr1_h(struct TIM4_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM4_CCR1_CCR1_H) | ((val<<16) & TIM4_CCR1_CCR1_H); }
inline void tim4_ccr1_set_ccr1_l(struct TIM4_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM4_CCR1_CCR1_L) | ((val<<0) & TIM4_CCR1_CCR1_L); }
inline uint32_t tim4_ccr1_get_ccr1_h(struct TIM4_Type* p) { return (p->CCR1 & TIM4_CCR1_CCR1_H) >> 16 ; }
inline uint32_t tim4_ccr1_get_ccr1_l(struct TIM4_Type* p) { return (p->CCR1 & TIM4_CCR1_CCR1_L) >> 0 ; }

// TIM4->CCR2 capture/compare register 2
enum {
	TIM4_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value
	TIM4_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
inline void tim4_ccr2_set_ccr2_h(struct TIM4_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM4_CCR2_CCR2_H) | ((val<<16) & TIM4_CCR2_CCR2_H); }
inline void tim4_ccr2_set_ccr2_l(struct TIM4_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM4_CCR2_CCR2_L) | ((val<<0) & TIM4_CCR2_CCR2_L); }
inline uint32_t tim4_ccr2_get_ccr2_h(struct TIM4_Type* p) { return (p->CCR2 & TIM4_CCR2_CCR2_H) >> 16 ; }
inline uint32_t tim4_ccr2_get_ccr2_l(struct TIM4_Type* p) { return (p->CCR2 & TIM4_CCR2_CCR2_L) >> 0 ; }

// TIM4->CCR3 capture/compare register 3
enum {
	TIM4_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM4_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim4_ccr3_set_ccr3_h(struct TIM4_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM4_CCR3_CCR3_H) | ((val<<16) & TIM4_CCR3_CCR3_H); }
inline void tim4_ccr3_set_ccr3_l(struct TIM4_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM4_CCR3_CCR3_L) | ((val<<0) & TIM4_CCR3_CCR3_L); }
inline uint32_t tim4_ccr3_get_ccr3_h(struct TIM4_Type* p) { return (p->CCR3 & TIM4_CCR3_CCR3_H) >> 16 ; }
inline uint32_t tim4_ccr3_get_ccr3_l(struct TIM4_Type* p) { return (p->CCR3 & TIM4_CCR3_CCR3_L) >> 0 ; }

// TIM4->CCR4 capture/compare register 4
enum {
	TIM4_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM4_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim4_ccr4_set_ccr4_h(struct TIM4_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM4_CCR4_CCR4_H) | ((val<<16) & TIM4_CCR4_CCR4_H); }
inline void tim4_ccr4_set_ccr4_l(struct TIM4_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM4_CCR4_CCR4_L) | ((val<<0) & TIM4_CCR4_CCR4_L); }
inline uint32_t tim4_ccr4_get_ccr4_h(struct TIM4_Type* p) { return (p->CCR4 & TIM4_CCR4_CCR4_H) >> 16 ; }
inline uint32_t tim4_ccr4_get_ccr4_l(struct TIM4_Type* p) { return (p->CCR4 & TIM4_CCR4_CCR4_L) >> 0 ; }

// TIM4->DCR DMA control register
enum {
	TIM4_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM4_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim4_dcr_set_dbl(struct TIM4_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM4_DCR_DBL) | ((val<<8) & TIM4_DCR_DBL); }
inline void tim4_dcr_set_dba(struct TIM4_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM4_DCR_DBA) | ((val<<0) & TIM4_DCR_DBA); }
inline uint32_t tim4_dcr_get_dbl(struct TIM4_Type* p) { return (p->DCR & TIM4_DCR_DBL) >> 8 ; }
inline uint32_t tim4_dcr_get_dba(struct TIM4_Type* p) { return (p->DCR & TIM4_DCR_DBA) >> 0 ; }


/* Basic timers */
struct TIM6_Type {
	__IO uint8_t CR1; // @0 control register 1
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[7]; // @5 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t SR; // @16 status register
	 uint8_t RESERVED3[3]; // @17 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[15]; // @21 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
};

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM6_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM6_CR1_URS = 1UL<<2, // Update request source
	TIM6_CR1_UDIS = 1UL<<1, // Update disable
	TIM6_CR1_CEN = 1UL<<0, // Counter enable		
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection		
};
inline void tim6_cr2_set_mms(struct TIM6_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val<<4) & TIM6_CR2_MMS); }
inline uint32_t tim6_cr2_get_mms(struct TIM6_Type* p) { return (p->CR2 & TIM6_CR2_MMS) >> 4 ; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM6_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL<<0, // Update generation		
};



/* General purpose timers */
struct TIM9_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[6]; // @2 
	__IO uint8_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint8_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[3]; // @13 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[6]; // @26 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED7[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED8[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED9[6]; // @46 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
};

// TIM9->CR1 control register 1
enum {
	TIM9_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM9_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM9_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM9_CR1_URS = 1UL<<2, // Update request source
	TIM9_CR1_UDIS = 1UL<<1, // Update disable
	TIM9_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim9_cr1_set_ckd(struct TIM9_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM9_CR1_CKD) | ((val<<8) & TIM9_CR1_CKD); }
inline uint32_t tim9_cr1_get_ckd(struct TIM9_Type* p) { return (p->CR1 & TIM9_CR1_CKD) >> 8 ; }

// TIM9->SMCR slave mode control register
enum {
	TIM9_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM9_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM9_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim9_smcr_set_ts(struct TIM9_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM9_SMCR_TS) | ((val<<4) & TIM9_SMCR_TS); }
inline void tim9_smcr_set_sms(struct TIM9_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM9_SMCR_SMS) | ((val<<0) & TIM9_SMCR_SMS); }
inline uint32_t tim9_smcr_get_ts(struct TIM9_Type* p) { return (p->SMCR & TIM9_SMCR_TS) >> 4 ; }
inline uint32_t tim9_smcr_get_sms(struct TIM9_Type* p) { return (p->SMCR & TIM9_SMCR_SMS) >> 0 ; }

// TIM9->DIER DMA/Interrupt enable register
enum {
	TIM9_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM9_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM9_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM9_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM9->SR status register
enum {
	TIM9_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM9_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM9_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM9_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM9_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM9_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM9->EGR event generation register
enum {
	TIM9_EGR_TG = 1UL<<6, // Trigger generation
	TIM9_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM9_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM9_EGR_UG = 1UL<<0, // Update generation		
};

// TIM9->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM9_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM9_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM9_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM9_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM9_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM9_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM9_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM9_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim9_ccmr1_output_set_oc2m(struct TIM9_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM9_CCMR1_OUTPUT_OC2M); }
inline void tim9_ccmr1_output_set_cc2s(struct TIM9_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM9_CCMR1_OUTPUT_CC2S); }
inline void tim9_ccmr1_output_set_oc1m(struct TIM9_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM9_CCMR1_OUTPUT_OC1M); }
inline void tim9_ccmr1_output_set_cc1s(struct TIM9_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM9_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM9_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim9_ccmr1_output_get_oc2m(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim9_ccmr1_output_get_cc2s(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim9_ccmr1_output_get_oc1m(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim9_ccmr1_output_get_cc1s(struct TIM9_Type* p) { return (p->CCMR1_Output & TIM9_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM9->CCER capture/compare enable register
enum {
	TIM9_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM9_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM9_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM9_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM9_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM9_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};





/* Universal synchronous asynchronous receiver transmitter */
struct USART1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint16_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint16_t GTPR; // @16 Guard time and prescaler register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED2[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED3[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
};

// USART1->CR1 Control register 1
enum {
	USART1_CR1_M1 = 1UL<<28, // Word length
	USART1_CR1_EOBIE = 1UL<<27, // End of Block interrupt enable
	USART1_CR1_RTOIE = 1UL<<26, // Receiver timeout interrupt enable
	USART1_CR1_DEAT4 = 1UL<<25, // Driver Enable assertion time
	USART1_CR1_DEAT3 = 1UL<<24, // DEAT3
	USART1_CR1_DEAT2 = 1UL<<23, // DEAT2
	USART1_CR1_DEAT1 = 1UL<<22, // DEAT1
	USART1_CR1_DEAT0 = 1UL<<21, // DEAT0
	USART1_CR1_DEDT4 = 1UL<<20, // Driver Enable de-assertion time
	USART1_CR1_DEDT3 = 1UL<<19, // DEDT3
	USART1_CR1_DEDT2 = 1UL<<18, // DEDT2
	USART1_CR1_DEDT1 = 1UL<<17, // DEDT1
	USART1_CR1_DEDT0 = 1UL<<16, // DEDT0
	USART1_CR1_OVER8 = 1UL<<15, // Oversampling mode
	USART1_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	USART1_CR1_MME = 1UL<<13, // Mute mode enable
	USART1_CR1_M0 = 1UL<<12, // Word length
	USART1_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	USART1_CR1_PCE = 1UL<<10, // Parity control enable
	USART1_CR1_PS = 1UL<<9, // Parity selection
	USART1_CR1_PEIE = 1UL<<8, // PE interrupt enable
	USART1_CR1_TXEIE = 1UL<<7, // interrupt enable
	USART1_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	USART1_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	USART1_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	USART1_CR1_TE = 1UL<<3, // Transmitter enable
	USART1_CR1_RE = 1UL<<2, // Receiver enable
	USART1_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	USART1_CR1_UE = 1UL<<0, // USART enable		
};

// USART1->CR2 Control register 2
enum {
	USART1_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	USART1_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	USART1_CR2_RTOEN = 1UL<<23, // Receiver timeout enable
	USART1_CR2_ABRMOD1 = 1UL<<22, // Auto baud rate mode
	USART1_CR2_ABRMOD0 = 1UL<<21, // ABRMOD0
	USART1_CR2_ABREN = 1UL<<20, // Auto baud rate enable
	USART1_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	USART1_CR2_TAINV = 1UL<<18, // Binary data inversion
	USART1_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	USART1_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	USART1_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	USART1_CR2_LINEN = 1UL<<14, // LIN mode enable
	USART1_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	USART1_CR2_CLKEN = 1UL<<11, // Clock enable
	USART1_CR2_CPOL = 1UL<<10, // Clock polarity
	USART1_CR2_CPHA = 1UL<<9, // Clock phase
	USART1_CR2_LBCL = 1UL<<8, // Last bit clock pulse
	USART1_CR2_LBDIE = 1UL<<6, // LIN break detection interrupt enable
	USART1_CR2_LBDL = 1UL<<5, // LIN break detection length
	USART1_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
inline void usart1_cr2_set_add4_7(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD4_7) | ((val<<28) & USART1_CR2_ADD4_7); }
inline void usart1_cr2_set_add0_3(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD0_3) | ((val<<24) & USART1_CR2_ADD0_3); }
inline void usart1_cr2_set_stop(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_STOP) | ((val<<12) & USART1_CR2_STOP); }
inline uint32_t usart1_cr2_get_add4_7(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD4_7) >> 28 ; }
inline uint32_t usart1_cr2_get_add0_3(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD0_3) >> 24 ; }
inline uint32_t usart1_cr2_get_stop(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_STOP) >> 12 ; }

// USART1->CR3 Control register 3
enum {
	USART1_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	USART1_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	USART1_CR3_SCARCNT = ((1UL<<3)-1) << 17, // Smartcard auto-retry count
	USART1_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	USART1_CR3_DEM = 1UL<<14, // Driver enable mode
	USART1_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	USART1_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	USART1_CR3_ONEBIT = 1UL<<11, // One sample bit method enable
	USART1_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	USART1_CR3_CTSE = 1UL<<9, // CTS enable
	USART1_CR3_RTSE = 1UL<<8, // RTS enable
	USART1_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	USART1_CR3_DMAR = 1UL<<6, // DMA enable receiver
	USART1_CR3_SCEN = 1UL<<5, // Smartcard mode enable
	USART1_CR3_NACK = 1UL<<4, // Smartcard NACK enable
	USART1_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	USART1_CR3_IRLP = 1UL<<2, // Ir low-power
	USART1_CR3_IREN = 1UL<<1, // Ir mode enable
	USART1_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void usart1_cr3_set_wus(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_WUS) | ((val<<20) & USART1_CR3_WUS); }
inline void usart1_cr3_set_scarcnt(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_SCARCNT) | ((val<<17) & USART1_CR3_SCARCNT); }
inline uint32_t usart1_cr3_get_wus(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_WUS) >> 20 ; }
inline uint32_t usart1_cr3_get_scarcnt(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_SCARCNT) >> 17 ; }

// USART1->BRR Baud rate register
enum {
	USART1_BRR_DIV_MANTISSA = ((1UL<<12)-1) << 4, // DIV_Mantissa
	USART1_BRR_DIV_FRACTION = ((1UL<<4)-1) << 0, // DIV_Fraction		
};
inline void usart1_brr_set_div_mantissa(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_DIV_MANTISSA) | ((val<<4) & USART1_BRR_DIV_MANTISSA); }
inline void usart1_brr_set_div_fraction(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_DIV_FRACTION) | ((val<<0) & USART1_BRR_DIV_FRACTION); }
inline uint32_t usart1_brr_get_div_mantissa(struct USART1_Type* p) { return (p->BRR & USART1_BRR_DIV_MANTISSA) >> 4 ; }
inline uint32_t usart1_brr_get_div_fraction(struct USART1_Type* p) { return (p->BRR & USART1_BRR_DIV_FRACTION) >> 0 ; }

// USART1->GTPR Guard time and prescaler register
enum {
	USART1_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	USART1_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
inline void usart1_gtpr_set_gt(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_GT) | ((val<<8) & USART1_GTPR_GT); }
inline void usart1_gtpr_set_psc(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_PSC) | ((val<<0) & USART1_GTPR_PSC); }
inline uint32_t usart1_gtpr_get_gt(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_GT) >> 8 ; }
inline uint32_t usart1_gtpr_get_psc(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_PSC) >> 0 ; }

// USART1->RTOR Receiver timeout register
enum {
	USART1_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	USART1_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
inline void usart1_rtor_set_blen(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_BLEN) | ((val<<24) & USART1_RTOR_BLEN); }
inline void usart1_rtor_set_rto(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_RTO) | ((val<<0) & USART1_RTOR_RTO); }
inline uint32_t usart1_rtor_get_blen(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_BLEN) >> 24 ; }
inline uint32_t usart1_rtor_get_rto(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_RTO) >> 0 ; }

// USART1->RQR Request register
enum {
	USART1_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	USART1_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	USART1_RQR_MMRQ = 1UL<<2, // Mute mode request
	USART1_RQR_SBKRQ = 1UL<<1, // Send break request
	USART1_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// USART1->ISR Interrupt & status register
enum {
	USART1_ISR_REACK = 1UL<<22, // REACK
	USART1_ISR_TEACK = 1UL<<21, // TEACK
	USART1_ISR_WUF = 1UL<<20, // WUF
	USART1_ISR_RWU = 1UL<<19, // RWU
	USART1_ISR_SBKF = 1UL<<18, // SBKF
	USART1_ISR_CMF = 1UL<<17, // CMF
	USART1_ISR_BUSY = 1UL<<16, // BUSY
	USART1_ISR_ABRF = 1UL<<15, // ABRF
	USART1_ISR_ABRE = 1UL<<14, // ABRE
	USART1_ISR_EOBF = 1UL<<12, // EOBF
	USART1_ISR_RTOF = 1UL<<11, // RTOF
	USART1_ISR_CTS = 1UL<<10, // CTS
	USART1_ISR_CTSIF = 1UL<<9, // CTSIF
	USART1_ISR_LBDF = 1UL<<8, // LBDF
	USART1_ISR_TXE = 1UL<<7, // TXE
	USART1_ISR_TC = 1UL<<6, // TC
	USART1_ISR_RXNE = 1UL<<5, // RXNE
	USART1_ISR_IDLE = 1UL<<4, // IDLE
	USART1_ISR_ORE = 1UL<<3, // ORE
	USART1_ISR_NF = 1UL<<2, // NF
	USART1_ISR_FE = 1UL<<1, // FE
	USART1_ISR_PE = 1UL<<0, // PE		
};

// USART1->ICR Interrupt flag clear register
enum {
	USART1_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	USART1_ICR_CMCF = 1UL<<17, // Character match clear flag
	USART1_ICR_EOBCF = 1UL<<12, // End of block clear flag
	USART1_ICR_RTOCF = 1UL<<11, // Receiver timeout clear flag
	USART1_ICR_CTSCF = 1UL<<9, // CTS clear flag
	USART1_ICR_LBDCF = 1UL<<8, // LIN break detection clear flag
	USART1_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	USART1_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	USART1_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	USART1_ICR_NCF = 1UL<<2, // Noise detected clear flag
	USART1_ICR_FECF = 1UL<<1, // Framing error clear flag
	USART1_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// USART1->RDR Receive data register
enum {
	USART1_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t usart1_rdr_get_rdr(struct USART1_Type* p) { return (p->RDR & USART1_RDR_RDR) >> 0 ; }

// USART1->TDR Transmit data register
enum {
	USART1_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void usart1_tdr_set_tdr(struct USART1_Type* p, uint32_t val) { p->TDR = (p->TDR & ~USART1_TDR_TDR) | ((val<<0) & USART1_TDR_TDR); }
inline uint32_t usart1_tdr_get_tdr(struct USART1_Type* p) { return (p->TDR & USART1_TDR_TDR) >> 0 ; }




/* Window watchdog */
struct WWDG_Type {
	__IO uint8_t CR; // @0 Control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CFR; // @4 Configuration register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint8_t SR; // @8 Status register
};

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL<<7, // Activation bit
	WWDG_CR_T = ((1UL<<7)-1) << 0, // 7-bit counter (MSB to LSB)		
};
inline void wwdg_cr_set_t(struct WWDG_Type* p, uint32_t val) { p->CR = (p->CR & ~WWDG_CR_T) | ((val<<0) & WWDG_CR_T); }
inline uint32_t wwdg_cr_get_t(struct WWDG_Type* p) { return (p->CR & WWDG_CR_T) >> 0 ; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_EWI = 1UL<<9, // Early wakeup interrupt
	WWDG_CFR_WDGTB1 = 1UL<<8, // Timer base
	WWDG_CFR_WDGTB0 = 1UL<<7, // Timer base
	WWDG_CFR_W = ((1UL<<7)-1) << 0, // 7-bit window value		
};
inline void wwdg_cfr_set_w(struct WWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_W) | ((val<<0) & WWDG_CFR_W); }
inline uint32_t wwdg_cfr_get_w(struct WWDG_Type* p) { return (p->CFR & WWDG_CFR_W) >> 0 ; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL<<0, // Early wakeup interrupt flag		
};


#undef __I
#undef __O
#undef __IO


extern struct AC_Type	AC;	// @0xE000EF90 
extern struct ADC1_Type	ADC1;	// @0x40012000 
extern struct ADC1_Type 	ADC2;	// @0x40012100
extern struct ADC1_Type 	ADC3;	// @0x40012200
extern struct CAN_Type	CAN1;	// @0x40006400 
extern struct CAN_Type 	CAN2;	// @0x40006800
extern struct CAN_Type 	CAN3;	// @0x40003400
extern struct CEC_Type	CEC;	// @0x40006C00 
extern struct CRC_Type	CRC;	// @0x40023000 
extern struct CRYP_Type	CRYP;	// @0x50060000 
extern struct DAC_Type	DAC;	// @0x40007400 
extern struct DCMI_Type	DCMI;	// @0x50050000 
extern struct DFSDM_Type	DFSDM;	// @0x40017400 
extern struct DMA2_Type 	DMA1;	// @0x40026000
extern struct DMA2_Type	DMA2;	// @0x40026400 
extern struct DMA2D_Type	DMA2D;	// @0x4002B000 
extern struct DSI_Type	DSI;	// @0x40016C00 
extern struct EXTI_Type	EXTI;	// @0x40013C00 
extern struct Ethernet_DMA_Type	Ethernet_DMA;	// @0x40029000 
extern struct Ethernet_MAC_Type	Ethernet_MAC;	// @0x40028000 
extern struct Ethernet_MMC_Type	Ethernet_MMC;	// @0x40028100 
extern struct Ethernet_PTP_Type	Ethernet_PTP;	// @0x40028700 
extern struct FLASH_Type	FLASH;	// @0x40023C00 
extern struct FMC_Type	FMC;	// @0xA0000000 
extern struct FPU_Type	FPU;	// @0xE000EF34 
extern struct FPU_CPACR_Type	FPU_CPACR;	// @0xE000ED88 
extern struct GPIOA_Type	GPIOA;	// @0x40020000 
extern struct GPIOA_Type 	GPIOB;	// @0x40020400
extern struct GPIOA_Type 	GPIOC;	// @0x40020800
extern struct GPIOA_Type 	GPIOD;	// @0x40020C00
extern struct GPIOA_Type 	GPIOE;	// @0x40021000
extern struct GPIOA_Type 	GPIOF;	// @0x40021400
extern struct GPIOA_Type 	GPIOG;	// @0x40021800
extern struct GPIOA_Type 	GPIOH;	// @0x40021C00
extern struct GPIOA_Type 	GPIOI;	// @0x40022000
extern struct GPIOA_Type 	GPIOJ;	// @0x40022400
extern struct GPIOA_Type 	GPIOK;	// @0x40022800
extern struct HASH_Type	HASH;	// @0x50060400 
extern struct I2C1_Type	I2C1;	// @0x40005400 
extern struct I2C1_Type 	I2C2;	// @0x40005800
extern struct I2C1_Type 	I2C3;	// @0x40005C00
extern struct I2C1_Type 	I2C4;	// @0x40006000
extern struct IWDG_Type	IWDG;	// @0x40003000 
extern struct JPEG_Type	JPEG;	// @0x50051000 
extern struct LPTIM1_Type	LPTIM1;	// @0x40002400 
extern struct LTCD_Type	LTCD;	// @0x40016800 
extern struct MDIOS_Type	MDIOS;	// @0x40017800 
extern struct MPU_Type	MPU;	// @0xE000ED90 
extern struct NVIC_Type	NVIC;	// @0xE000E100 
extern struct NVIC_STIR_Type	NVIC_STIR;	// @0xE000EF00 
extern struct OTG_FS_DEVICE_Type	OTG_FS_DEVICE;	// @0x50000800 
extern struct OTG_FS_GLOBAL_Type	OTG_FS_GLOBAL;	// @0x50000000 
extern struct OTG_FS_HOST_Type	OTG_FS_HOST;	// @0x50000400 
extern struct OTG_FS_PWRCLK_Type	OTG_FS_PWRCLK;	// @0x50000E00 
extern struct OTG_HS_DEVICE_Type	OTG_HS_DEVICE;	// @0x40040800 
extern struct OTG_HS_GLOBAL_Type	OTG_HS_GLOBAL;	// @0x40040000 
extern struct OTG_HS_HOST_Type	OTG_HS_HOST;	// @0x40040400 
extern struct OTG_HS_PWRCLK_Type	OTG_HS_PWRCLK;	// @0x40040E00 
extern struct PF_Type	PF;	// @0xE000ED78 
extern struct PWR_Type	PWR;	// @0x40007000 
extern struct QUADSPI_Type	QUADSPI;	// @0xA0001000 
extern struct RCC_Type	RCC;	// @0x40023800 
extern struct RNG_Type	RNG;	// @0x50060800 
extern struct RTC_Type	RTC;	// @0x40002800 
extern struct SAI1_Type	SAI1;	// @0x40015800 
extern struct SAI1_Type 	SAI2;	// @0x40015C00
extern struct SCB_Type	SCB;	// @0xE000ED00 
extern struct SCB_ACTRL_Type	SCB_ACTRL;	// @0xE000E008 
extern struct SDMMC1_Type	SDMMC1;	// @0x40012C00 
extern struct SDMMC1_Type 	SDMMC2;	// @0x40011C00
extern struct SPDIFRX_Type	SPDIFRX;	// @0x40004000 
extern struct SPI1_Type	SPI1;	// @0x40013000 
extern struct SPI1_Type 	SPI2;	// @0x40003800
extern struct SPI1_Type 	SPI3;	// @0x40003C00
extern struct SPI1_Type 	SPI4;	// @0x40013400
extern struct SPI1_Type 	SPI5;	// @0x40015000
extern struct SPI1_Type 	SPI6;	// @0x40015400
extern struct STK_Type	STK;	// @0xE000E010 
extern struct SYSCFG_Type	SYSCFG;	// @0x40013800 
extern struct TIM1_Type	TIM1;	// @0x40010000 Also: TIM6_Type
extern struct TIM10_Type	TIM10;	// @0x40014400 
extern struct TIM10_Type 	TIM11;	// @0x40014800
extern struct TIM9_Type 	TIM12;	// @0x40001800
extern struct TIM10_Type 	TIM13;	// @0x40001C00
extern struct TIM10_Type 	TIM14;	// @0x40002000
extern struct TIM2_Type	TIM2;	// @0x40000000 Also: TIM4_Type
extern struct TIM3_Type	TIM3;	// @0x40000400 Also: TIM4_Type
extern struct TIM4_Type	TIM4;	// @0x40000800 
extern struct TIM4_Type 	TIM5;	// @0x40000C00
extern struct TIM6_Type	TIM6;	// @0x40001000 
extern struct TIM6_Type 	TIM7;	// @0x40001400
extern struct TIM1_Type 	TIM8;	// @0x40010400
extern struct TIM9_Type	TIM9;	// @0x40014000 
extern struct USART1_Type 	UART4;	// @0x40004C00
extern struct USART1_Type 	UART5;	// @0x40005000
extern struct USART1_Type 	UART7;	// @0x40007800
extern struct USART1_Type 	UART8;	// @0x40007C00
extern struct USART1_Type	USART1;	// @0x40011000 
extern struct USART1_Type 	USART2;	// @0x40004400
extern struct USART1_Type 	USART3;	// @0x40004800
extern struct USART1_Type 	USART6;	// @0x40011400
extern struct WWDG_Type	WWDG;	// @0x40002C00 

