#pragma once

// Generated enums and structures for device STM32G031 version 1.2
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ           

	//  Cortex-M3 Processor Exceptions Numbers 
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt                           
	Reserved_3_IRQn       = -13,
	MemoryManagement_IRQn = -12, // 4 Cortex-M3 Memory Management Interrupt            
	BusFault_IRQn         = -11, // 5 Cortex-M3 Bus Fault Interrupt                    
	UsageFault_IRQn       = -10, // 6 Cortex-M3 Usage Fault Interrupt                  
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 Cortex-M3 SV Call Interrupt                     
	DebugMonitor_IRQn     = -4, // 12 Cortex-M3 Debug Monitor Interrupt               
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Cortex-M3 Pend SV Interrupt                     
	SysTick_IRQn          = -1, // 15 Cortex-M3 System Tick Interrupt                 

	//  Device specific Interrupt Numbers
	IRQ_WWDG = 0, // Window watchdog interrupt
	IRQ_PVD = 1, // Power voltage detector interrupt
	IRQ_RTC_TAMP = 2, // RTC and TAMP interrupts
	IRQ_FLASH = 3, // Flash global interrupt
	IRQ_RCC = 4, // RCC global interrupt
	IRQ_EXTI0_1 = 5, // EXTI line 0 & 1 interrupt
	IRQ_EXTI2_3 = 6, // EXTI line 2 & 3 interrupt
	IRQ_EXTI4_15 = 7, // EXTI line 4 to 15 interrupt
	IRQ_DMA_Channel1 = 9, // DMA channel 1 interrupt
	IRQ_DMA_Channel2_3 = 10, // DMA channel 2 & 3 interrupts
	IRQ_DMA_Channel4_5_6_7 = 11, // DMA channel 4, 5, 6 & 7 and DMAMUX
	IRQ_ADC_COMP = 12, // ADC and COMP interrupts
	IRQ_TIM1_BRK_UP_TRG_COM = 13, // TIM1 break, update, trigger
	IRQ_TIM1_CC = 14, // TIM1 Capture Compare interrupt
	IRQ_TIM2 = 15, // TIM2 global interrupt
	IRQ_TIM3 = 16, // TIM3 global interrupt
	IRQ_TIM14 = 19, // TIM14 global interrupt
	IRQ_TIM16 = 21, // TIM16 global interrupt
	IRQ_TIM17 = 22, // TIM17 global interrupt
	IRQ_I2C1 = 23, // I2C1 global interrupt
	IRQ_I2C2 = 24, // I2C2 global interrupt
	IRQ_SPI1 = 25, // SPI1 global interrupt
	IRQ_SPI2 = 26, // SPI2 global interrupt
	IRQ_USART1 = 27, // USART1 global interrupt
	IRQ_USART2 = 28, // USART2 global interrupt
	IRQ_USART3_USART4_LPUART1 = 29, // USART3 + USART4 + LPUART1
	IRQ_CEC = 30, // CEC global interrupt
};


#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions


/* Analog to Digital Converter instance 1 */
struct ADC_Type {
	__IO uint16_t ISR; // @0 ADC interrupt and status register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t IER; // @4 ADC interrupt enable register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t CR; // @8 ADC control register
	__IO uint32_t CFGR1; // @12 ADC configuration register 1
	__IO uint32_t CFGR2; // @16 ADC configuration register 2
	__IO uint32_t SMPR; // @20 ADC sampling time register
	 uint8_t RESERVED2[8]; // @24 
	__IO uint32_t AWD1TR; // @32 watchdog threshold register
	__IO uint32_t AWD2TR; // @36 watchdog threshold register
	union {  // @40
		__IO uint32_t CHSELR_1; // channel selection register CHSELRMOD = 1 in ADC_CFGR1
		__IO uint32_t CHSELR; // channel selection register
	};
	__IO uint32_t AWD3TR; // @44 watchdog threshold register
	 uint8_t RESERVED3[16]; // @48 
	__I uint16_t DR; // @64 ADC group regular conversion data register
	 uint8_t RESERVED4[94]; // @66 
	__IO uint32_t AWD2CR; // @160 ADC analog watchdog 2 configuration register
	__IO uint32_t AWD3CR; // @164 ADC analog watchdog 3 configuration register
	 uint8_t RESERVED5[12]; // @168 
	__IO uint8_t CALFACT; // @180 ADC calibration factors register
	 uint8_t RESERVED6[595]; // @181 
	__IO uint32_t CCR; // @776 ADC common control register
};

// ADC->ISR ADC interrupt and status register
enum {
	ADC_ISR_CCRDY = 1UL<<13, // Channel Configuration Ready flag
	ADC_ISR_EOCAL = 1UL<<11, // End Of Calibration flag
	ADC_ISR_AWD3 = 1UL<<9, // ADC analog watchdog 3 flag
	ADC_ISR_AWD2 = 1UL<<8, // ADC analog watchdog 2 flag
	ADC_ISR_AWD1 = 1UL<<7, // ADC analog watchdog 1 flag
	ADC_ISR_OVR = 1UL<<4, // ADC group regular overrun flag
	ADC_ISR_EOS = 1UL<<3, // ADC group regular end of sequence conversions flag
	ADC_ISR_EOC = 1UL<<2, // ADC group regular end of unitary conversion flag
	ADC_ISR_EOSMP = 1UL<<1, // ADC group regular end of sampling flag
	ADC_ISR_ADRDY = 1UL<<0, // ADC ready flag		
};

// ADC->IER ADC interrupt enable register
enum {
	ADC_IER_CCRDYIE = 1UL<<13, // Channel Configuration Ready Interrupt enable
	ADC_IER_EOCALIE = 1UL<<11, // End of calibration interrupt enable
	ADC_IER_AWD3IE = 1UL<<9, // ADC analog watchdog 3 interrupt
	ADC_IER_AWD2IE = 1UL<<8, // ADC analog watchdog 2 interrupt
	ADC_IER_AWD1IE = 1UL<<7, // ADC analog watchdog 1 interrupt
	ADC_IER_OVRIE = 1UL<<4, // ADC group regular overrun interrupt
	ADC_IER_EOSIE = 1UL<<3, // ADC group regular end of sequence conversions interrupt
	ADC_IER_EOCIE = 1UL<<2, // ADC group regular end of unitary conversion interrupt
	ADC_IER_EOSMPIE = 1UL<<1, // ADC group regular end of sampling interrupt
	ADC_IER_ADRDYIE = 1UL<<0, // ADC ready interrupt		
};

// ADC->CR ADC control register
enum {
	ADC_CR_ADCAL = 1UL<<31, // ADC calibration
	ADC_CR_ADVREGEN = 1UL<<28, // ADC voltage regulator enable
	ADC_CR_ADSTP = 1UL<<4, // ADC group regular conversion stop
	ADC_CR_ADSTART = 1UL<<2, // ADC group regular conversion start
	ADC_CR_ADDIS = 1UL<<1, // ADC disable
	ADC_CR_ADEN = 1UL<<0, // ADC enable		
};

// ADC->CFGR1 ADC configuration register 1
enum {
	ADC_CFGR1_AWDCH1CH = ((1UL<<5)-1) << 26, // ADC analog watchdog 1 monitored channel selection
	ADC_CFGR1_AWD1EN = 1UL<<23, // ADC analog watchdog 1 enable on scope ADC group regular
	ADC_CFGR1_AWD1SGL = 1UL<<22, // ADC analog watchdog 1 monitoring a single channel or all channels
	ADC_CFGR1_CHSELRMOD = 1UL<<21, // Mode selection of the ADC_CHSELR register
	ADC_CFGR1_DISCEN = 1UL<<16, // ADC group regular sequencer discontinuous mode
	ADC_CFGR1_AUTOFF = 1UL<<15, // Auto-off mode
	ADC_CFGR1_WAIT = 1UL<<14, // Wait conversion mode
	ADC_CFGR1_CONT = 1UL<<13, // ADC group regular continuous conversion mode
	ADC_CFGR1_OVRMOD = 1UL<<12, // ADC group regular overrun configuration
	ADC_CFGR1_EXTEN = ((1UL<<2)-1) << 10, // ADC group regular external trigger polarity
	ADC_CFGR1_EXTSEL = ((1UL<<3)-1) << 6, // ADC group regular external trigger source
	ADC_CFGR1_ALIGN = 1UL<<5, // ADC data alignement
	ADC_CFGR1_RES = ((1UL<<2)-1) << 3, // ADC data resolution
	ADC_CFGR1_SCANDIR = 1UL<<2, // Scan sequence direction
	ADC_CFGR1_DMACFG = 1UL<<1, // ADC DMA transfer configuration
	ADC_CFGR1_DMAEN = 1UL<<0, // ADC DMA transfer enable		
};
inline void adc_cfgr1_set_awdch1ch(struct ADC_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~ADC_CFGR1_AWDCH1CH) | ((val<<26) & ADC_CFGR1_AWDCH1CH); }
inline void adc_cfgr1_set_exten(struct ADC_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~ADC_CFGR1_EXTEN) | ((val<<10) & ADC_CFGR1_EXTEN); }
inline void adc_cfgr1_set_extsel(struct ADC_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~ADC_CFGR1_EXTSEL) | ((val<<6) & ADC_CFGR1_EXTSEL); }
inline void adc_cfgr1_set_res(struct ADC_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~ADC_CFGR1_RES) | ((val<<3) & ADC_CFGR1_RES); }
inline uint32_t adc_cfgr1_get_awdch1ch(struct ADC_Type* p) { return (p->CFGR1 & ADC_CFGR1_AWDCH1CH) >> 26 ; }
inline uint32_t adc_cfgr1_get_exten(struct ADC_Type* p) { return (p->CFGR1 & ADC_CFGR1_EXTEN) >> 10 ; }
inline uint32_t adc_cfgr1_get_extsel(struct ADC_Type* p) { return (p->CFGR1 & ADC_CFGR1_EXTSEL) >> 6 ; }
inline uint32_t adc_cfgr1_get_res(struct ADC_Type* p) { return (p->CFGR1 & ADC_CFGR1_RES) >> 3 ; }

// ADC->CFGR2 ADC configuration register 2
enum {
	ADC_CFGR2_CKMODE = ((1UL<<2)-1) << 30, // ADC clock mode
	ADC_CFGR2_LFTRIG = 1UL<<29, // Low frequency trigger mode enable
	ADC_CFGR2_TOVS = 1UL<<9, // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
	ADC_CFGR2_OVSS = ((1UL<<4)-1) << 5, // ADC oversampling shift
	ADC_CFGR2_OVSR = ((1UL<<3)-1) << 2, // ADC oversampling ratio
	ADC_CFGR2_OVSE = 1UL<<0, // ADC oversampler enable on scope ADC group regular		
};
inline void adc_cfgr2_set_ckmode(struct ADC_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC_CFGR2_CKMODE) | ((val<<30) & ADC_CFGR2_CKMODE); }
inline void adc_cfgr2_set_ovss(struct ADC_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC_CFGR2_OVSS) | ((val<<5) & ADC_CFGR2_OVSS); }
inline void adc_cfgr2_set_ovsr(struct ADC_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC_CFGR2_OVSR) | ((val<<2) & ADC_CFGR2_OVSR); }
inline uint32_t adc_cfgr2_get_ckmode(struct ADC_Type* p) { return (p->CFGR2 & ADC_CFGR2_CKMODE) >> 30 ; }
inline uint32_t adc_cfgr2_get_ovss(struct ADC_Type* p) { return (p->CFGR2 & ADC_CFGR2_OVSS) >> 5 ; }
inline uint32_t adc_cfgr2_get_ovsr(struct ADC_Type* p) { return (p->CFGR2 & ADC_CFGR2_OVSR) >> 2 ; }

// ADC->SMPR ADC sampling time register
enum {
	ADC_SMPR_SMPSEL = ((1UL<<19)-1) << 8, // Channel sampling time selection
	ADC_SMPR_SMP2 = ((1UL<<3)-1) << 4, // Sampling time selection
	ADC_SMPR_SMP1 = ((1UL<<3)-1) << 0, // Sampling time selection		
};
inline void adc_smpr_set_smpsel(struct ADC_Type* p, uint32_t val) { p->SMPR = (p->SMPR & ~ADC_SMPR_SMPSEL) | ((val<<8) & ADC_SMPR_SMPSEL); }
inline void adc_smpr_set_smp2(struct ADC_Type* p, uint32_t val) { p->SMPR = (p->SMPR & ~ADC_SMPR_SMP2) | ((val<<4) & ADC_SMPR_SMP2); }
inline void adc_smpr_set_smp1(struct ADC_Type* p, uint32_t val) { p->SMPR = (p->SMPR & ~ADC_SMPR_SMP1) | ((val<<0) & ADC_SMPR_SMP1); }
inline uint32_t adc_smpr_get_smpsel(struct ADC_Type* p) { return (p->SMPR & ADC_SMPR_SMPSEL) >> 8 ; }
inline uint32_t adc_smpr_get_smp2(struct ADC_Type* p) { return (p->SMPR & ADC_SMPR_SMP2) >> 4 ; }
inline uint32_t adc_smpr_get_smp1(struct ADC_Type* p) { return (p->SMPR & ADC_SMPR_SMP1) >> 0 ; }

// ADC->AWD1TR watchdog threshold register
enum {
	ADC_AWD1TR_HT1 = ((1UL<<12)-1) << 16, // ADC analog watchdog 1 threshold high
	ADC_AWD1TR_LT1 = ((1UL<<12)-1) << 0, // ADC analog watchdog 1 threshold low		
};
inline void adc_awd1tr_set_ht1(struct ADC_Type* p, uint32_t val) { p->AWD1TR = (p->AWD1TR & ~ADC_AWD1TR_HT1) | ((val<<16) & ADC_AWD1TR_HT1); }
inline void adc_awd1tr_set_lt1(struct ADC_Type* p, uint32_t val) { p->AWD1TR = (p->AWD1TR & ~ADC_AWD1TR_LT1) | ((val<<0) & ADC_AWD1TR_LT1); }
inline uint32_t adc_awd1tr_get_ht1(struct ADC_Type* p) { return (p->AWD1TR & ADC_AWD1TR_HT1) >> 16 ; }
inline uint32_t adc_awd1tr_get_lt1(struct ADC_Type* p) { return (p->AWD1TR & ADC_AWD1TR_LT1) >> 0 ; }

// ADC->AWD2TR watchdog threshold register
enum {
	ADC_AWD2TR_HT2 = ((1UL<<12)-1) << 16, // ADC analog watchdog 2 threshold high
	ADC_AWD2TR_LT2 = ((1UL<<12)-1) << 0, // ADC analog watchdog 2 threshold low		
};
inline void adc_awd2tr_set_ht2(struct ADC_Type* p, uint32_t val) { p->AWD2TR = (p->AWD2TR & ~ADC_AWD2TR_HT2) | ((val<<16) & ADC_AWD2TR_HT2); }
inline void adc_awd2tr_set_lt2(struct ADC_Type* p, uint32_t val) { p->AWD2TR = (p->AWD2TR & ~ADC_AWD2TR_LT2) | ((val<<0) & ADC_AWD2TR_LT2); }
inline uint32_t adc_awd2tr_get_ht2(struct ADC_Type* p) { return (p->AWD2TR & ADC_AWD2TR_HT2) >> 16 ; }
inline uint32_t adc_awd2tr_get_lt2(struct ADC_Type* p) { return (p->AWD2TR & ADC_AWD2TR_LT2) >> 0 ; }

// ADC->CHSELR_1 channel selection register CHSELRMOD = 1 in ADC_CFGR1
enum {
	ADC_CHSELR_1_SQ8 = ((1UL<<4)-1) << 28, // conversion of the sequence
	ADC_CHSELR_1_SQ7 = ((1UL<<4)-1) << 24, // conversion of the sequence
	ADC_CHSELR_1_SQ6 = ((1UL<<4)-1) << 20, // conversion of the sequence
	ADC_CHSELR_1_SQ5 = ((1UL<<4)-1) << 16, // conversion of the sequence
	ADC_CHSELR_1_SQ4 = ((1UL<<4)-1) << 12, // conversion of the sequence
	ADC_CHSELR_1_SQ3 = ((1UL<<4)-1) << 8, // conversion of the sequence
	ADC_CHSELR_1_SQ2 = ((1UL<<4)-1) << 4, // conversion of the sequence
	ADC_CHSELR_1_SQ1 = ((1UL<<4)-1) << 0, // conversion of the sequence		
};
inline void adc_chselr_1_set_sq8(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ8) | ((val<<28) & ADC_CHSELR_1_SQ8); }
inline void adc_chselr_1_set_sq7(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ7) | ((val<<24) & ADC_CHSELR_1_SQ7); }
inline void adc_chselr_1_set_sq6(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ6) | ((val<<20) & ADC_CHSELR_1_SQ6); }
inline void adc_chselr_1_set_sq5(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ5) | ((val<<16) & ADC_CHSELR_1_SQ5); }
inline void adc_chselr_1_set_sq4(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ4) | ((val<<12) & ADC_CHSELR_1_SQ4); }
inline void adc_chselr_1_set_sq3(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ3) | ((val<<8) & ADC_CHSELR_1_SQ3); }
inline void adc_chselr_1_set_sq2(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ2) | ((val<<4) & ADC_CHSELR_1_SQ2); }
inline void adc_chselr_1_set_sq1(struct ADC_Type* p, uint32_t val) { p->CHSELR_1 = (p->CHSELR_1 & ~ADC_CHSELR_1_SQ1) | ((val<<0) & ADC_CHSELR_1_SQ1); }
inline uint32_t adc_chselr_1_get_sq8(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ8) >> 28 ; }
inline uint32_t adc_chselr_1_get_sq7(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ7) >> 24 ; }
inline uint32_t adc_chselr_1_get_sq6(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ6) >> 20 ; }
inline uint32_t adc_chselr_1_get_sq5(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ5) >> 16 ; }
inline uint32_t adc_chselr_1_get_sq4(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ4) >> 12 ; }
inline uint32_t adc_chselr_1_get_sq3(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ3) >> 8 ; }
inline uint32_t adc_chselr_1_get_sq2(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ2) >> 4 ; }
inline uint32_t adc_chselr_1_get_sq1(struct ADC_Type* p) { return (p->CHSELR_1 & ADC_CHSELR_1_SQ1) >> 0 ; }

// ADC->AWD3TR watchdog threshold register
enum {
	ADC_AWD3TR_HT3 = ((1UL<<12)-1) << 16, // ADC analog watchdog 3 threshold high
	ADC_AWD3TR_LT3 = ((1UL<<12)-1) << 0, // ADC analog watchdog 3 threshold high		
};
inline void adc_awd3tr_set_ht3(struct ADC_Type* p, uint32_t val) { p->AWD3TR = (p->AWD3TR & ~ADC_AWD3TR_HT3) | ((val<<16) & ADC_AWD3TR_HT3); }
inline void adc_awd3tr_set_lt3(struct ADC_Type* p, uint32_t val) { p->AWD3TR = (p->AWD3TR & ~ADC_AWD3TR_LT3) | ((val<<0) & ADC_AWD3TR_LT3); }
inline uint32_t adc_awd3tr_get_ht3(struct ADC_Type* p) { return (p->AWD3TR & ADC_AWD3TR_HT3) >> 16 ; }
inline uint32_t adc_awd3tr_get_lt3(struct ADC_Type* p) { return (p->AWD3TR & ADC_AWD3TR_LT3) >> 0 ; }

// ADC->AWD2CR ADC analog watchdog 2 configuration register
enum {
	ADC_AWD2CR_AWD2CH = ((1UL<<19)-1) << 0, // ADC analog watchdog 2 monitored channel selection		
};
inline void adc_awd2cr_set_awd2ch(struct ADC_Type* p, uint32_t val) { p->AWD2CR = (p->AWD2CR & ~ADC_AWD2CR_AWD2CH) | ((val<<0) & ADC_AWD2CR_AWD2CH); }
inline uint32_t adc_awd2cr_get_awd2ch(struct ADC_Type* p) { return (p->AWD2CR & ADC_AWD2CR_AWD2CH) >> 0 ; }

// ADC->AWD3CR ADC analog watchdog 3 configuration register
enum {
	ADC_AWD3CR_AWD3CH = ((1UL<<19)-1) << 0, // ADC analog watchdog 3 monitored channel selection		
};
inline void adc_awd3cr_set_awd3ch(struct ADC_Type* p, uint32_t val) { p->AWD3CR = (p->AWD3CR & ~ADC_AWD3CR_AWD3CH) | ((val<<0) & ADC_AWD3CR_AWD3CH); }
inline uint32_t adc_awd3cr_get_awd3ch(struct ADC_Type* p) { return (p->AWD3CR & ADC_AWD3CR_AWD3CH) >> 0 ; }

// ADC->CALFACT ADC calibration factors register
enum {
	ADC_CALFACT_CALFACT = ((1UL<<7)-1) << 0, // ADC calibration factor in single-ended mode		
};
inline void adc_calfact_set_calfact(struct ADC_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC_CALFACT_CALFACT) | ((val<<0) & ADC_CALFACT_CALFACT); }
inline uint32_t adc_calfact_get_calfact(struct ADC_Type* p) { return (p->CALFACT & ADC_CALFACT_CALFACT) >> 0 ; }

// ADC->CCR ADC common control register
enum {
	ADC_CCR_VBATEN = 1UL<<24, // VBAT enable
	ADC_CCR_TSEN = 1UL<<23, // Temperature sensor enable
	ADC_CCR_VREFEN = 1UL<<22, // VREFINT enable
	ADC_CCR_PRESC = ((1UL<<4)-1) << 18, // ADC prescaler		
};
inline void adc_ccr_set_presc(struct ADC_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC_CCR_PRESC) | ((val<<18) & ADC_CCR_PRESC); }
inline uint32_t adc_ccr_get_presc(struct ADC_Type* p) { return (p->CCR & ADC_CCR_PRESC) >> 18 ; }

/* Cyclic redundancy check calculation unit */
struct CRC_Type {
	__IO uint32_t DR; // @0 Data register
	__IO uint32_t IDR; // @4 Independent data register
	__IO uint8_t CR; // @8 Control register
	 uint8_t RESERVED0[7]; // @9 
	__IO uint32_t INIT; // @16 Initial CRC value
	__IO uint32_t POL; // @20 polynomial
};

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT = 1UL<<7, // Reverse output data
	CRC_CR_REV_IN = ((1UL<<2)-1) << 5, // Reverse input data
	CRC_CR_POLYSIZE = ((1UL<<2)-1) << 3, // Polynomial size
	CRC_CR_RESET = 1UL<<0, // RESET bit		
};
inline void crc_cr_set_rev_in(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_REV_IN) | ((val<<5) & CRC_CR_REV_IN); }
inline void crc_cr_set_polysize(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_POLYSIZE) | ((val<<3) & CRC_CR_POLYSIZE); }
inline uint32_t crc_cr_get_rev_in(struct CRC_Type* p) { return (p->CR & CRC_CR_REV_IN) >> 5 ; }
inline uint32_t crc_cr_get_polysize(struct CRC_Type* p) { return (p->CR & CRC_CR_POLYSIZE) >> 3 ; }

/* MCU debug component */
struct DBG_Type {
	__I uint32_t IDCODE; // @0 DBGMCU_IDCODE
	__IO uint8_t CR; // @4 Debug MCU configuration register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint32_t APB_FZ1; // @8 Debug MCU APB1 freeze register1
	__IO uint32_t APB_FZ2; // @12 Debug MCU APB1 freeze register 2
};

// DBG->IDCODE DBGMCU_IDCODE
enum {
	DBG_IDCODE_REV_ID = ((1UL<<16)-1) << 16, // Revision identifie
	DBG_IDCODE_DEV_ID = ((1UL<<12)-1) << 0, // Device identifier		
};
inline uint32_t dbg_idcode_get_rev_id(struct DBG_Type* p) { return (p->IDCODE & DBG_IDCODE_REV_ID) >> 16 ; }
inline uint32_t dbg_idcode_get_dev_id(struct DBG_Type* p) { return (p->IDCODE & DBG_IDCODE_DEV_ID) >> 0 ; }

// DBG->CR Debug MCU configuration register
enum {
	DBG_CR_DBG_STANDBY = 1UL<<2, // Debug Standby mode
	DBG_CR_DBG_STOP = 1UL<<1, // Debug Stop mode		
};

// DBG->APB_FZ1 Debug MCU APB1 freeze register1
enum {
	DBG_APB_FZ1_DBG_LPTIM1_STOP = 1UL<<31, // LPTIM1 counter stopped when core is halted
	DBG_APB_FZ1_DBG_LPTIM2_STOP = 1UL<<30, // LPTIM2 counter stopped when core is halted
	DBG_APB_FZ1_DBG_I2C1_STOP = 1UL<<21, // I2C1 SMBUS timeout counter stopped when core is halted
	DBG_APB_FZ1_DBG_IWDG_STOP = 1UL<<12, // Independent watchdog counter stopped when core is halted
	DBG_APB_FZ1_DBG_WWDG_STOP = 1UL<<11, // Window watchdog counter stopped when core is halted
	DBG_APB_FZ1_DBG_RTC_STOP = 1UL<<10, // RTC counter stopped when core is halted
	DBG_APB_FZ1_DBG_TIM3_STOP = 1UL<<1, // TIM3 counter stopped when core is halted
	DBG_APB_FZ1_DBG_TIM2_STOP = 1UL<<0, // TIM2 counter stopped when core is halted		
};

// DBG->APB_FZ2 Debug MCU APB1 freeze register 2
enum {
	DBG_APB_FZ2_DBG_TIM17_STOP = 1UL<<18, // DBG_TIM17_STOP
	DBG_APB_FZ2_DBG_TIM16_STOP = 1UL<<17, // DBG_TIM16_STOP
	DBG_APB_FZ2_DBG_TIM14_STOP = 1UL<<15, // DBG_TIM14_STOP
	DBG_APB_FZ2_DBG_TIM1_STOP = 1UL<<11, // TIM1 counter stopped when core is halted		
};

/* DMA controller */
struct DMA_Type {
	__I uint32_t ISR; // @0 low interrupt status register
	__I uint32_t IFCR; // @4 high interrupt status register
	__IO uint16_t CCR1; // @8 DMA channel x configuration register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t CNDTR1; // @12 DMA channel x number of data register
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t CPAR1; // @16 DMA channel x peripheral address register
	__IO uint32_t CMAR1; // @20 DMA channel x memory address register
	 uint8_t RESERVED2[4]; // @24 
	__IO uint16_t CCR2; // @28 DMA channel x configuration register
	 uint8_t RESERVED3[2]; // @30 
	__IO uint16_t CNDTR2; // @32 DMA channel x number of data register
	 uint8_t RESERVED4[2]; // @34 
	__IO uint32_t CPAR2; // @36 DMA channel x peripheral address register
	__IO uint32_t CMAR2; // @40 DMA channel x memory address register
	 uint8_t RESERVED5[4]; // @44 
	__IO uint16_t CCR3; // @48 DMA channel x configuration register
	 uint8_t RESERVED6[2]; // @50 
	__IO uint16_t CNDTR3; // @52 DMA channel x configuration register
	 uint8_t RESERVED7[2]; // @54 
	__IO uint32_t CPAR3; // @56 DMA channel x peripheral address register
	__IO uint32_t CMAR3; // @60 DMA channel x memory address register
	 uint8_t RESERVED8[4]; // @64 
	__IO uint16_t CCR4; // @68 DMA channel x configuration register
	 uint8_t RESERVED9[2]; // @70 
	__IO uint16_t CNDTR4; // @72 DMA channel x configuration register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint32_t CPAR4; // @76 DMA channel x peripheral address register
	__IO uint32_t CMAR4; // @80 DMA channel x memory address register
	 uint8_t RESERVED11[4]; // @84 
	__IO uint16_t CCR5; // @88 DMA channel x configuration register
	 uint8_t RESERVED12[2]; // @90 
	__IO uint16_t CNDTR5; // @92 DMA channel x configuration register
	 uint8_t RESERVED13[2]; // @94 
	__IO uint32_t CPAR5; // @96 DMA channel x peripheral address register
	__IO uint32_t CMAR5; // @100 DMA channel x memory address register
};

// DMA->ISR low interrupt status register
enum {
	DMA_ISR_TEIF27 = 1UL<<27, // Channel transfer error flag
	DMA_ISR_HTIF26 = 1UL<<26, // Channel half transfer flag
	DMA_ISR_TCIF25 = 1UL<<25, // Channel transfer complete flag
	DMA_ISR_GIF24 = 1UL<<24, // Channel global interrupt flag
	DMA_ISR_TEIF23 = 1UL<<23, // Channel transfer error flag
	DMA_ISR_HTIF22 = 1UL<<22, // Channel half transfer flag
	DMA_ISR_TCIF21 = 1UL<<21, // Channel transfer complete flag
	DMA_ISR_GIF20 = 1UL<<20, // Channel global interrupt flag
	DMA_ISR_TEIF19 = 1UL<<19, // Channel transfer error flag
	DMA_ISR_HTIF18 = 1UL<<18, // Channel half transfer flag
	DMA_ISR_TCIF17 = 1UL<<17, // Channel transfer complete flag
	DMA_ISR_GIF16 = 1UL<<16, // Channel global interrupt flag
	DMA_ISR_TEIF15 = 1UL<<15, // Channel transfer error flag
	DMA_ISR_HTIF14 = 1UL<<14, // Channel half transfer flag
	DMA_ISR_TCIF13 = 1UL<<13, // Channel transfer complete flag
	DMA_ISR_GIF12 = 1UL<<12, // Channel global interrupt flag
	DMA_ISR_TEIF11 = 1UL<<11, // Channel transfer error flag
	DMA_ISR_HTIF10 = 1UL<<10, // Channel half transfer flag
	DMA_ISR_TCIF9 = 1UL<<9, // Channel transfer complete flag
	DMA_ISR_GIF8 = 1UL<<8, // Channel global interrupt flag
	DMA_ISR_TEIF7 = 1UL<<7, // Channel transfer error flag
	DMA_ISR_HTIF6 = 1UL<<6, // Channel half transfer flag
	DMA_ISR_TCIF5 = 1UL<<5, // Channel transfer complete flag
	DMA_ISR_GIF4 = 1UL<<4, // Channel global interrupt flag
	DMA_ISR_TEIF3 = 1UL<<3, // Channel transfer error flag
	DMA_ISR_HTIF2 = 1UL<<2, // Channel half transfer flag
	DMA_ISR_TCIF1 = 1UL<<1, // Channel transfer complete flag
	DMA_ISR_GIF0 = 1UL<<0, // Channel global interrupt flag		
};

// DMA->IFCR high interrupt status register
enum {
	DMA_IFCR_CTEIF27 = 1UL<<27, // Channel transfer error flag
	DMA_IFCR_CHTIF26 = 1UL<<26, // Channel half transfer flag
	DMA_IFCR_CTCIF25 = 1UL<<25, // Channel transfer complete flag
	DMA_IFCR_CGIF24 = 1UL<<24, // Channel global interrupt flag
	DMA_IFCR_CTEIF23 = 1UL<<23, // Channel transfer error flag
	DMA_IFCR_CHTIF22 = 1UL<<22, // Channel half transfer flag
	DMA_IFCR_CTCIF21 = 1UL<<21, // Channel transfer complete flag
	DMA_IFCR_CGIF20 = 1UL<<20, // Channel global interrupt flag
	DMA_IFCR_CTEIF19 = 1UL<<19, // Channel transfer error flag
	DMA_IFCR_CHTIF18 = 1UL<<18, // Channel half transfer flag
	DMA_IFCR_CTCIF17 = 1UL<<17, // Channel transfer complete flag
	DMA_IFCR_CGIF16 = 1UL<<16, // Channel global interrupt flag
	DMA_IFCR_CTEIF15 = 1UL<<15, // Channel transfer error flag
	DMA_IFCR_CHTIF14 = 1UL<<14, // Channel half transfer flag
	DMA_IFCR_CTCIF13 = 1UL<<13, // Channel transfer complete flag
	DMA_IFCR_CGIF12 = 1UL<<12, // Channel global interrupt flag
	DMA_IFCR_CTEIF11 = 1UL<<11, // Channel transfer error flag
	DMA_IFCR_CHTIF10 = 1UL<<10, // Channel half transfer flag
	DMA_IFCR_CTCIF9 = 1UL<<9, // Channel transfer complete flag
	DMA_IFCR_CGIF8 = 1UL<<8, // Channel global interrupt flag
	DMA_IFCR_CTEIF7 = 1UL<<7, // Channel transfer error flag
	DMA_IFCR_CHTIF6 = 1UL<<6, // Channel half transfer flag
	DMA_IFCR_CTCIF5 = 1UL<<5, // Channel transfer complete flag
	DMA_IFCR_CGIF4 = 1UL<<4, // Channel global interrupt flag
	DMA_IFCR_CTEIF3 = 1UL<<3, // Channel transfer error flag
	DMA_IFCR_CHTIF2 = 1UL<<2, // Channel half transfer flag
	DMA_IFCR_CTCIF1 = 1UL<<1, // Channel transfer complete flag
	DMA_IFCR_CGIF0 = 1UL<<0, // Channel global interrupt flag		
};

// DMA->CCR1 DMA channel x configuration register
enum {
	DMA_CCR1_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR1_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR1_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR1_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR1_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR1_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR1_CIRC = 1UL<<5, // Circular mode
	DMA_CCR1_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR1_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR1_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR1_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR1_EN = 1UL<<0, // Channel enable		
};
inline void dma_ccr1_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_PL) | ((val<<12) & DMA_CCR1_PL); }
inline void dma_ccr1_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_MSIZE) | ((val<<10) & DMA_CCR1_MSIZE); }
inline void dma_ccr1_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_PSIZE) | ((val<<8) & DMA_CCR1_PSIZE); }
inline uint32_t dma_ccr1_get_pl(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_PL) >> 12 ; }
inline uint32_t dma_ccr1_get_msize(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_MSIZE) >> 10 ; }
inline uint32_t dma_ccr1_get_psize(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_PSIZE) >> 8 ; }

// DMA->CCR2 DMA channel x configuration register
enum {
	DMA_CCR2_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR2_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR2_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR2_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR2_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR2_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR2_CIRC = 1UL<<5, // Circular mode
	DMA_CCR2_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR2_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR2_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR2_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR2_EN = 1UL<<0, // Channel enable		
};
inline void dma_ccr2_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_PL) | ((val<<12) & DMA_CCR2_PL); }
inline void dma_ccr2_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_MSIZE) | ((val<<10) & DMA_CCR2_MSIZE); }
inline void dma_ccr2_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_PSIZE) | ((val<<8) & DMA_CCR2_PSIZE); }
inline uint32_t dma_ccr2_get_pl(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_PL) >> 12 ; }
inline uint32_t dma_ccr2_get_msize(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_MSIZE) >> 10 ; }
inline uint32_t dma_ccr2_get_psize(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_PSIZE) >> 8 ; }

// DMA->CCR3 DMA channel x configuration register
enum {
	DMA_CCR3_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR3_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR3_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR3_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR3_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR3_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR3_CIRC = 1UL<<5, // Circular mode
	DMA_CCR3_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR3_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR3_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR3_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR3_EN = 1UL<<0, // Channel enable		
};
inline void dma_ccr3_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_PL) | ((val<<12) & DMA_CCR3_PL); }
inline void dma_ccr3_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_MSIZE) | ((val<<10) & DMA_CCR3_MSIZE); }
inline void dma_ccr3_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_PSIZE) | ((val<<8) & DMA_CCR3_PSIZE); }
inline uint32_t dma_ccr3_get_pl(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_PL) >> 12 ; }
inline uint32_t dma_ccr3_get_msize(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_MSIZE) >> 10 ; }
inline uint32_t dma_ccr3_get_psize(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_PSIZE) >> 8 ; }

// DMA->CCR4 DMA channel x configuration register
enum {
	DMA_CCR4_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR4_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR4_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR4_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR4_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR4_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR4_CIRC = 1UL<<5, // Circular mode
	DMA_CCR4_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR4_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR4_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR4_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR4_EN = 1UL<<0, // Channel enable		
};
inline void dma_ccr4_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_PL) | ((val<<12) & DMA_CCR4_PL); }
inline void dma_ccr4_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_MSIZE) | ((val<<10) & DMA_CCR4_MSIZE); }
inline void dma_ccr4_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_PSIZE) | ((val<<8) & DMA_CCR4_PSIZE); }
inline uint32_t dma_ccr4_get_pl(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_PL) >> 12 ; }
inline uint32_t dma_ccr4_get_msize(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_MSIZE) >> 10 ; }
inline uint32_t dma_ccr4_get_psize(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_PSIZE) >> 8 ; }

// DMA->CCR5 DMA channel x configuration register
enum {
	DMA_CCR5_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR5_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR5_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR5_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR5_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR5_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR5_CIRC = 1UL<<5, // Circular mode
	DMA_CCR5_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR5_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR5_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR5_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR5_EN = 1UL<<0, // Channel enable		
};
inline void dma_ccr5_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_PL) | ((val<<12) & DMA_CCR5_PL); }
inline void dma_ccr5_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_MSIZE) | ((val<<10) & DMA_CCR5_MSIZE); }
inline void dma_ccr5_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_PSIZE) | ((val<<8) & DMA_CCR5_PSIZE); }
inline uint32_t dma_ccr5_get_pl(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_PL) >> 12 ; }
inline uint32_t dma_ccr5_get_msize(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_MSIZE) >> 10 ; }
inline uint32_t dma_ccr5_get_psize(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_PSIZE) >> 8 ; }

/* DMAMUX */
struct DMAMUX_Type {
	__IO uint32_t C0CR; // @0 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C1CR; // @4 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C2CR; // @8 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C3CR; // @12 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C4CR; // @16 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C5CR; // @20 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C6CR; // @24 DMAMux - DMA request line multiplexer channel x control register
	 uint8_t RESERVED0[228]; // @28 
	__IO uint32_t RG0CR; // @256 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG1CR; // @260 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG2CR; // @264 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG3CR; // @268 DMAMux - DMA request generator channel x control register
	 uint8_t RESERVED1[48]; // @272 
	__I uint8_t RGSR; // @320 DMAMux - DMA request generator status register
	 uint8_t RESERVED2[3]; // @321 
	__O uint8_t RGCFR; // @324 DMAMux - DMA request generator clear flag register
};

// DMAMUX->C0CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C0CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C0CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C0CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C0CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C0CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C0CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C0CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c0cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX_C0CR_SYNC_ID) | ((val<<24) & DMAMUX_C0CR_SYNC_ID); }
inline void dmamux_c0cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX_C0CR_NBREQ) | ((val<<19) & DMAMUX_C0CR_NBREQ); }
inline void dmamux_c0cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX_C0CR_SPOL) | ((val<<17) & DMAMUX_C0CR_SPOL); }
inline void dmamux_c0cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX_C0CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C0CR_DMAREQ_ID); }
inline uint32_t dmamux_c0cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c0cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c0cr_get_spol(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c0cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C1CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C1CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C1CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C1CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C1CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C1CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C1CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C1CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c1cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX_C1CR_SYNC_ID) | ((val<<24) & DMAMUX_C1CR_SYNC_ID); }
inline void dmamux_c1cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX_C1CR_NBREQ) | ((val<<19) & DMAMUX_C1CR_NBREQ); }
inline void dmamux_c1cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX_C1CR_SPOL) | ((val<<17) & DMAMUX_C1CR_SPOL); }
inline void dmamux_c1cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX_C1CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C1CR_DMAREQ_ID); }
inline uint32_t dmamux_c1cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c1cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c1cr_get_spol(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c1cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C2CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C2CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C2CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C2CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C2CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C2CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C2CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C2CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c2cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX_C2CR_SYNC_ID) | ((val<<24) & DMAMUX_C2CR_SYNC_ID); }
inline void dmamux_c2cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX_C2CR_NBREQ) | ((val<<19) & DMAMUX_C2CR_NBREQ); }
inline void dmamux_c2cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX_C2CR_SPOL) | ((val<<17) & DMAMUX_C2CR_SPOL); }
inline void dmamux_c2cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX_C2CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C2CR_DMAREQ_ID); }
inline uint32_t dmamux_c2cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c2cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c2cr_get_spol(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c2cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C3CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C3CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C3CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C3CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C3CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C3CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C3CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C3CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c3cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX_C3CR_SYNC_ID) | ((val<<24) & DMAMUX_C3CR_SYNC_ID); }
inline void dmamux_c3cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX_C3CR_NBREQ) | ((val<<19) & DMAMUX_C3CR_NBREQ); }
inline void dmamux_c3cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX_C3CR_SPOL) | ((val<<17) & DMAMUX_C3CR_SPOL); }
inline void dmamux_c3cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX_C3CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C3CR_DMAREQ_ID); }
inline uint32_t dmamux_c3cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c3cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c3cr_get_spol(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c3cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C4CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C4CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C4CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C4CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C4CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C4CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C4CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C4CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c4cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX_C4CR_SYNC_ID) | ((val<<24) & DMAMUX_C4CR_SYNC_ID); }
inline void dmamux_c4cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX_C4CR_NBREQ) | ((val<<19) & DMAMUX_C4CR_NBREQ); }
inline void dmamux_c4cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX_C4CR_SPOL) | ((val<<17) & DMAMUX_C4CR_SPOL); }
inline void dmamux_c4cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX_C4CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C4CR_DMAREQ_ID); }
inline uint32_t dmamux_c4cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c4cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c4cr_get_spol(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c4cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C5CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C5CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C5CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C5CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C5CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C5CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C5CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C5CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c5cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX_C5CR_SYNC_ID) | ((val<<24) & DMAMUX_C5CR_SYNC_ID); }
inline void dmamux_c5cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX_C5CR_NBREQ) | ((val<<19) & DMAMUX_C5CR_NBREQ); }
inline void dmamux_c5cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX_C5CR_SPOL) | ((val<<17) & DMAMUX_C5CR_SPOL); }
inline void dmamux_c5cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX_C5CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C5CR_DMAREQ_ID); }
inline uint32_t dmamux_c5cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c5cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c5cr_get_spol(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c5cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C6CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C6CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C6CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C6CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C6CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C6CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C6CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C6CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux_c6cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX_C6CR_SYNC_ID) | ((val<<24) & DMAMUX_C6CR_SYNC_ID); }
inline void dmamux_c6cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX_C6CR_NBREQ) | ((val<<19) & DMAMUX_C6CR_NBREQ); }
inline void dmamux_c6cr_set_spol(struct DMAMUX_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX_C6CR_SPOL) | ((val<<17) & DMAMUX_C6CR_SPOL); }
inline void dmamux_c6cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX_C6CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C6CR_DMAREQ_ID); }
inline uint32_t dmamux_c6cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux_c6cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_NBREQ) >> 19 ; }
inline uint32_t dmamux_c6cr_get_spol(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_SPOL) >> 17 ; }
inline uint32_t dmamux_c6cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->RG0CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG0CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG0CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG0CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG0CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG0CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux_rg0cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_GNBREQ) | ((val<<19) & DMAMUX_RG0CR_GNBREQ); }
inline void dmamux_rg0cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_GPOL) | ((val<<17) & DMAMUX_RG0CR_GPOL); }
inline void dmamux_rg0cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_SIG_ID) | ((val<<0) & DMAMUX_RG0CR_SIG_ID); }
inline uint32_t dmamux_rg0cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG0CR & DMAMUX_RG0CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux_rg0cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG0CR & DMAMUX_RG0CR_GPOL) >> 17 ; }
inline uint32_t dmamux_rg0cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG0CR & DMAMUX_RG0CR_SIG_ID) >> 0 ; }

// DMAMUX->RG1CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG1CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG1CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG1CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG1CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG1CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux_rg1cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_GNBREQ) | ((val<<19) & DMAMUX_RG1CR_GNBREQ); }
inline void dmamux_rg1cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_GPOL) | ((val<<17) & DMAMUX_RG1CR_GPOL); }
inline void dmamux_rg1cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_SIG_ID) | ((val<<0) & DMAMUX_RG1CR_SIG_ID); }
inline uint32_t dmamux_rg1cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG1CR & DMAMUX_RG1CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux_rg1cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG1CR & DMAMUX_RG1CR_GPOL) >> 17 ; }
inline uint32_t dmamux_rg1cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG1CR & DMAMUX_RG1CR_SIG_ID) >> 0 ; }

// DMAMUX->RG2CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG2CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG2CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG2CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG2CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG2CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux_rg2cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_GNBREQ) | ((val<<19) & DMAMUX_RG2CR_GNBREQ); }
inline void dmamux_rg2cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_GPOL) | ((val<<17) & DMAMUX_RG2CR_GPOL); }
inline void dmamux_rg2cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_SIG_ID) | ((val<<0) & DMAMUX_RG2CR_SIG_ID); }
inline uint32_t dmamux_rg2cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG2CR & DMAMUX_RG2CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux_rg2cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG2CR & DMAMUX_RG2CR_GPOL) >> 17 ; }
inline uint32_t dmamux_rg2cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG2CR & DMAMUX_RG2CR_SIG_ID) >> 0 ; }

// DMAMUX->RG3CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG3CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG3CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG3CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG3CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG3CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux_rg3cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_GNBREQ) | ((val<<19) & DMAMUX_RG3CR_GNBREQ); }
inline void dmamux_rg3cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_GPOL) | ((val<<17) & DMAMUX_RG3CR_GPOL); }
inline void dmamux_rg3cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_SIG_ID) | ((val<<0) & DMAMUX_RG3CR_SIG_ID); }
inline uint32_t dmamux_rg3cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG3CR & DMAMUX_RG3CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux_rg3cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG3CR & DMAMUX_RG3CR_GPOL) >> 17 ; }
inline uint32_t dmamux_rg3cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG3CR & DMAMUX_RG3CR_SIG_ID) >> 0 ; }

// DMAMUX->RGSR DMAMux - DMA request generator status register
enum {
	DMAMUX_RGSR_OF = ((1UL<<4)-1) << 0, // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.		
};
inline uint32_t dmamux_rgsr_get_of(struct DMAMUX_Type* p) { return (p->RGSR & DMAMUX_RGSR_OF) >> 0 ; }

// DMAMUX->RGCFR DMAMux - DMA request generator clear flag register
enum {
	DMAMUX_RGCFR_COF = ((1UL<<4)-1) << 0, // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.		
};
inline void dmamux_rgcfr_set_cof(struct DMAMUX_Type* p, uint32_t val) { p->RGCFR = (p->RGCFR & ~DMAMUX_RGCFR_COF) | ((val<<0) & DMAMUX_RGCFR_COF); }
inline uint32_t dmamux_rgcfr_get_cof(struct DMAMUX_Type* p) { return (p->RGCFR & DMAMUX_RGCFR_COF) >> 0 ; }

/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t RTSR1; // @0 EXTI rising trigger selection register
	__IO uint32_t FTSR1; // @4 EXTI falling trigger selection register
	__IO uint32_t SWIER1; // @8 EXTI software interrupt event register
	__IO uint32_t RPR1; // @12 EXTI rising edge pending register
	__IO uint32_t FPR1; // @16 EXTI falling edge pending register
	 uint8_t RESERVED0[76]; // @20 
	__IO uint32_t EXTICR1; // @96 EXTI external interrupt selection register
	__IO uint32_t EXTICR2; // @100 EXTI external interrupt selection register
	__IO uint32_t EXTICR3; // @104 EXTI external interrupt selection register
	__IO uint32_t EXTICR4; // @108 EXTI external interrupt selection register
	 uint8_t RESERVED1[16]; // @112 
	__IO uint32_t IMR1; // @128 EXTI CPU wakeup with interrupt mask register
	__IO uint32_t EMR1; // @132 EXTI CPU wakeup with event mask register
};

// EXTI->RTSR1 EXTI rising trigger selection register
enum {
	EXTI_RTSR1_TRX  = ((1UL<<17)-1) << 0, // Merged Rising trigger event configuration bit of Configurable Event input		
};
inline void exti_rtsr1_set_trx (struct EXTI_Type* p, uint32_t val) { p->RTSR1 = (p->RTSR1 & ~EXTI_RTSR1_TRX ) | ((val<<0) & EXTI_RTSR1_TRX ); }
inline uint32_t exti_rtsr1_get_trx (struct EXTI_Type* p) { return (p->RTSR1 & EXTI_RTSR1_TRX ) >> 0 ; }

// EXTI->FTSR1 EXTI falling trigger selection register
enum {
	EXTI_FTSR1_TRX  = ((1UL<<17)-1) << 0, // Merged Rising trigger event configuration bit of Configurable Event input		
};
inline void exti_ftsr1_set_trx (struct EXTI_Type* p, uint32_t val) { p->FTSR1 = (p->FTSR1 & ~EXTI_FTSR1_TRX ) | ((val<<0) & EXTI_FTSR1_TRX ); }
inline uint32_t exti_ftsr1_get_trx (struct EXTI_Type* p) { return (p->FTSR1 & EXTI_FTSR1_TRX ) >> 0 ; }

// EXTI->SWIER1 EXTI software interrupt event register
enum {
	EXTI_SWIER1_SWIERX  = ((1UL<<17)-1) << 0, // Merged Rising trigger event configuration bit of Configurable Event input		
};
inline void exti_swier1_set_swierx (struct EXTI_Type* p, uint32_t val) { p->SWIER1 = (p->SWIER1 & ~EXTI_SWIER1_SWIERX ) | ((val<<0) & EXTI_SWIER1_SWIERX ); }
inline uint32_t exti_swier1_get_swierx (struct EXTI_Type* p) { return (p->SWIER1 & EXTI_SWIER1_SWIERX ) >> 0 ; }

// EXTI->RPR1 EXTI rising edge pending register
enum {
	EXTI_RPR1_RPIFX  = ((1UL<<17)-1) << 0, // Merged configurable event inputs x rising edge Pending bit.		
};
inline void exti_rpr1_set_rpifx (struct EXTI_Type* p, uint32_t val) { p->RPR1 = (p->RPR1 & ~EXTI_RPR1_RPIFX ) | ((val<<0) & EXTI_RPR1_RPIFX ); }
inline uint32_t exti_rpr1_get_rpifx (struct EXTI_Type* p) { return (p->RPR1 & EXTI_RPR1_RPIFX ) >> 0 ; }

// EXTI->FPR1 EXTI falling edge pending register
enum {
	EXTI_FPR1_FPIFX  = ((1UL<<17)-1) << 0, // Merged configurable event inputs x falling edge pending bit.		
};
inline void exti_fpr1_set_fpifx (struct EXTI_Type* p, uint32_t val) { p->FPR1 = (p->FPR1 & ~EXTI_FPR1_FPIFX ) | ((val<<0) & EXTI_FPR1_FPIFX ); }
inline uint32_t exti_fpr1_get_fpifx (struct EXTI_Type* p) { return (p->FPR1 & EXTI_FPR1_FPIFX ) >> 0 ; }

// EXTI->EXTICR1 EXTI external interrupt selection register
enum {
	EXTI_EXTICR1_EXTI24_31 = ((1UL<<8)-1) << 24, // GPIO port selection
	EXTI_EXTICR1_EXTI16_23 = ((1UL<<8)-1) << 16, // GPIO port selection
	EXTI_EXTICR1_EXTI8_15 = ((1UL<<8)-1) << 8, // GPIO port selection
	EXTI_EXTICR1_EXTI0_7 = ((1UL<<8)-1) << 0, // GPIO port selection		
};
inline void exti_exticr1_set_exti24_31(struct EXTI_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~EXTI_EXTICR1_EXTI24_31) | ((val<<24) & EXTI_EXTICR1_EXTI24_31); }
inline void exti_exticr1_set_exti16_23(struct EXTI_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~EXTI_EXTICR1_EXTI16_23) | ((val<<16) & EXTI_EXTICR1_EXTI16_23); }
inline void exti_exticr1_set_exti8_15(struct EXTI_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~EXTI_EXTICR1_EXTI8_15) | ((val<<8) & EXTI_EXTICR1_EXTI8_15); }
inline void exti_exticr1_set_exti0_7(struct EXTI_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~EXTI_EXTICR1_EXTI0_7) | ((val<<0) & EXTI_EXTICR1_EXTI0_7); }
inline uint32_t exti_exticr1_get_exti24_31(struct EXTI_Type* p) { return (p->EXTICR1 & EXTI_EXTICR1_EXTI24_31) >> 24 ; }
inline uint32_t exti_exticr1_get_exti16_23(struct EXTI_Type* p) { return (p->EXTICR1 & EXTI_EXTICR1_EXTI16_23) >> 16 ; }
inline uint32_t exti_exticr1_get_exti8_15(struct EXTI_Type* p) { return (p->EXTICR1 & EXTI_EXTICR1_EXTI8_15) >> 8 ; }
inline uint32_t exti_exticr1_get_exti0_7(struct EXTI_Type* p) { return (p->EXTICR1 & EXTI_EXTICR1_EXTI0_7) >> 0 ; }

// EXTI->EXTICR2 EXTI external interrupt selection register
enum {
	EXTI_EXTICR2_EXTI24_31 = ((1UL<<8)-1) << 24, // GPIO port selection
	EXTI_EXTICR2_EXTI16_23 = ((1UL<<8)-1) << 16, // GPIO port selection
	EXTI_EXTICR2_EXTI8_15 = ((1UL<<8)-1) << 8, // GPIO port selection
	EXTI_EXTICR2_EXTI0_7 = ((1UL<<8)-1) << 0, // GPIO port selection		
};
inline void exti_exticr2_set_exti24_31(struct EXTI_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~EXTI_EXTICR2_EXTI24_31) | ((val<<24) & EXTI_EXTICR2_EXTI24_31); }
inline void exti_exticr2_set_exti16_23(struct EXTI_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~EXTI_EXTICR2_EXTI16_23) | ((val<<16) & EXTI_EXTICR2_EXTI16_23); }
inline void exti_exticr2_set_exti8_15(struct EXTI_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~EXTI_EXTICR2_EXTI8_15) | ((val<<8) & EXTI_EXTICR2_EXTI8_15); }
inline void exti_exticr2_set_exti0_7(struct EXTI_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~EXTI_EXTICR2_EXTI0_7) | ((val<<0) & EXTI_EXTICR2_EXTI0_7); }
inline uint32_t exti_exticr2_get_exti24_31(struct EXTI_Type* p) { return (p->EXTICR2 & EXTI_EXTICR2_EXTI24_31) >> 24 ; }
inline uint32_t exti_exticr2_get_exti16_23(struct EXTI_Type* p) { return (p->EXTICR2 & EXTI_EXTICR2_EXTI16_23) >> 16 ; }
inline uint32_t exti_exticr2_get_exti8_15(struct EXTI_Type* p) { return (p->EXTICR2 & EXTI_EXTICR2_EXTI8_15) >> 8 ; }
inline uint32_t exti_exticr2_get_exti0_7(struct EXTI_Type* p) { return (p->EXTICR2 & EXTI_EXTICR2_EXTI0_7) >> 0 ; }

// EXTI->EXTICR3 EXTI external interrupt selection register
enum {
	EXTI_EXTICR3_EXTI24_31 = ((1UL<<8)-1) << 24, // GPIO port selection
	EXTI_EXTICR3_EXTI16_23 = ((1UL<<8)-1) << 16, // GPIO port selection
	EXTI_EXTICR3_EXTI8_15 = ((1UL<<8)-1) << 8, // GPIO port selection
	EXTI_EXTICR3_EXTI0_7 = ((1UL<<8)-1) << 0, // GPIO port selection		
};
inline void exti_exticr3_set_exti24_31(struct EXTI_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~EXTI_EXTICR3_EXTI24_31) | ((val<<24) & EXTI_EXTICR3_EXTI24_31); }
inline void exti_exticr3_set_exti16_23(struct EXTI_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~EXTI_EXTICR3_EXTI16_23) | ((val<<16) & EXTI_EXTICR3_EXTI16_23); }
inline void exti_exticr3_set_exti8_15(struct EXTI_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~EXTI_EXTICR3_EXTI8_15) | ((val<<8) & EXTI_EXTICR3_EXTI8_15); }
inline void exti_exticr3_set_exti0_7(struct EXTI_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~EXTI_EXTICR3_EXTI0_7) | ((val<<0) & EXTI_EXTICR3_EXTI0_7); }
inline uint32_t exti_exticr3_get_exti24_31(struct EXTI_Type* p) { return (p->EXTICR3 & EXTI_EXTICR3_EXTI24_31) >> 24 ; }
inline uint32_t exti_exticr3_get_exti16_23(struct EXTI_Type* p) { return (p->EXTICR3 & EXTI_EXTICR3_EXTI16_23) >> 16 ; }
inline uint32_t exti_exticr3_get_exti8_15(struct EXTI_Type* p) { return (p->EXTICR3 & EXTI_EXTICR3_EXTI8_15) >> 8 ; }
inline uint32_t exti_exticr3_get_exti0_7(struct EXTI_Type* p) { return (p->EXTICR3 & EXTI_EXTICR3_EXTI0_7) >> 0 ; }

// EXTI->EXTICR4 EXTI external interrupt selection register
enum {
	EXTI_EXTICR4_EXTI24_31 = ((1UL<<8)-1) << 24, // GPIO port selection
	EXTI_EXTICR4_EXTI16_23 = ((1UL<<8)-1) << 16, // GPIO port selection
	EXTI_EXTICR4_EXTI8_15 = ((1UL<<8)-1) << 8, // GPIO port selection
	EXTI_EXTICR4_EXTI0_7 = ((1UL<<8)-1) << 0, // GPIO port selection		
};
inline void exti_exticr4_set_exti24_31(struct EXTI_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~EXTI_EXTICR4_EXTI24_31) | ((val<<24) & EXTI_EXTICR4_EXTI24_31); }
inline void exti_exticr4_set_exti16_23(struct EXTI_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~EXTI_EXTICR4_EXTI16_23) | ((val<<16) & EXTI_EXTICR4_EXTI16_23); }
inline void exti_exticr4_set_exti8_15(struct EXTI_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~EXTI_EXTICR4_EXTI8_15) | ((val<<8) & EXTI_EXTICR4_EXTI8_15); }
inline void exti_exticr4_set_exti0_7(struct EXTI_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~EXTI_EXTICR4_EXTI0_7) | ((val<<0) & EXTI_EXTICR4_EXTI0_7); }
inline uint32_t exti_exticr4_get_exti24_31(struct EXTI_Type* p) { return (p->EXTICR4 & EXTI_EXTICR4_EXTI24_31) >> 24 ; }
inline uint32_t exti_exticr4_get_exti16_23(struct EXTI_Type* p) { return (p->EXTICR4 & EXTI_EXTICR4_EXTI16_23) >> 16 ; }
inline uint32_t exti_exticr4_get_exti8_15(struct EXTI_Type* p) { return (p->EXTICR4 & EXTI_EXTICR4_EXTI8_15) >> 8 ; }
inline uint32_t exti_exticr4_get_exti0_7(struct EXTI_Type* p) { return (p->EXTICR4 & EXTI_EXTICR4_EXTI0_7) >> 0 ; }

// EXTI->IMR1 EXTI CPU wakeup with interrupt mask register
enum {
	EXTI_IMR1_IM31 = 1UL<<31, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM30 = 1UL<<30, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM29 = 1UL<<29, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM28 = 1UL<<28, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM26 = 1UL<<26, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM25 = 1UL<<25, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM24 = 1UL<<24, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM23 = 1UL<<23, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM22 = 1UL<<22, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM21 = 1UL<<21, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM20 = 1UL<<20, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM19 = 1UL<<19, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM16 = 1UL<<16, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM15 = 1UL<<15, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM14 = 1UL<<14, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM13 = 1UL<<13, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM12 = 1UL<<12, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM11 = 1UL<<11, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM10 = 1UL<<10, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM9 = 1UL<<9, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM8 = 1UL<<8, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM7 = 1UL<<7, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM6 = 1UL<<6, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM5 = 1UL<<5, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM4 = 1UL<<4, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM3 = 1UL<<3, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM2 = 1UL<<2, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM1 = 1UL<<1, // CPU wakeup with interrupt mask on event input
	EXTI_IMR1_IM0 = 1UL<<0, // CPU wakeup with interrupt mask on event input		
};

// EXTI->EMR1 EXTI CPU wakeup with event mask register
enum {
	EXTI_EMR1_EM31 = 1UL<<31, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM30 = 1UL<<30, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM29 = 1UL<<29, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM28 = 1UL<<28, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM26 = 1UL<<26, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM25 = 1UL<<25, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM23 = 1UL<<23, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM21 = 1UL<<21, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM19 = 1UL<<19, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM16 = 1UL<<16, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM15 = 1UL<<15, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM14 = 1UL<<14, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM13 = 1UL<<13, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM12 = 1UL<<12, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM11 = 1UL<<11, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM10 = 1UL<<10, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM9 = 1UL<<9, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM8 = 1UL<<8, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM7 = 1UL<<7, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM6 = 1UL<<6, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM5 = 1UL<<5, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM4 = 1UL<<4, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM3 = 1UL<<3, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM2 = 1UL<<2, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM1 = 1UL<<1, // CPU wakeup with event mask on event input
	EXTI_EMR1_EM0 = 1UL<<0, // CPU wakeup with event mask on event input		
};

/* Flash */
struct FLASH_Type {
	__IO uint32_t ACR; // @0 Access control register
	 uint8_t RESERVED0[4]; // @4 
	__O uint32_t KEYR; // @8 Flash key register
	__O uint32_t OPTKEYR; // @12 Option byte key register
	__IO uint32_t SR; // @16 Status register
	__IO uint32_t CR; // @20 Flash control register
	__IO uint32_t ECCR; // @24 Flash ECC register
	 uint8_t RESERVED1[4]; // @28 
	__IO uint32_t OPTR; // @32 Flash option register
	__I uint8_t PCROP1ASR; // @36 Flash PCROP zone A Start address register
	 uint8_t RESERVED2[3]; // @37 
	__I uint32_t PCROP1AER; // @40 Flash PCROP zone A End address register
	__I uint32_t WRP1AR; // @44 Flash WRP area A address register
	__I uint32_t WRP1BR; // @48 Flash WRP area B address register
	__I uint8_t PCROP1BSR; // @52 Flash PCROP zone B Start address register
	 uint8_t RESERVED3[3]; // @53 
	__I uint8_t PCROP1BER; // @56 Flash PCROP zone B End address register
	 uint8_t RESERVED4[71]; // @57 
	__I uint32_t SECR; // @128 Flash Security register
};

// FLASH->ACR Access control register
enum {
	FLASH_ACR_DBG_SWEN = 1UL<<18, // Debug access software enable
	FLASH_ACR_EMPTY = 1UL<<16, // Flash User area empty
	FLASH_ACR_ICRST = 1UL<<11, // Instruction cache reset
	FLASH_ACR_ICEN = 1UL<<9, // Instruction cache enable
	FLASH_ACR_PRFTEN = 1UL<<8, // Prefetch enable
	FLASH_ACR_LATENCY = ((1UL<<3)-1) << 0, // Latency		
};
inline void flash_acr_set_latency(struct FLASH_Type* p, uint32_t val) { p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val<<0) & FLASH_ACR_LATENCY); }
inline uint32_t flash_acr_get_latency(struct FLASH_Type* p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0 ; }

// FLASH->SR Status register
enum {
	FLASH_SR_CFGBSY = 1UL<<18, // Programming or erase configuration busy.
	FLASH_SR_BSY = 1UL<<16, // Busy
	FLASH_SR_OPTVERR = 1UL<<15, // Option and Engineering bits loading validity error
	FLASH_SR_RDERR = 1UL<<14, // PCROP read error
	FLASH_SR_FASTERR = 1UL<<9, // Fast programming error
	FLASH_SR_MISERR = 1UL<<8, // Fast programming data miss error
	FLASH_SR_PGSERR = 1UL<<7, // Programming sequence error
	FLASH_SR_SIZERR = 1UL<<6, // Size error
	FLASH_SR_PGAERR = 1UL<<5, // Programming alignment error
	FLASH_SR_WRPERR = 1UL<<4, // Write protected error
	FLASH_SR_PROGERR = 1UL<<3, // Programming error
	FLASH_SR_OPERR = 1UL<<1, // Operation error
	FLASH_SR_EOP = 1UL<<0, // End of operation		
};

// FLASH->CR Flash control register
enum {
	FLASH_CR_LOCK = 1UL<<31, // FLASH_CR Lock
	FLASH_CR_OPTLOCK = 1UL<<30, // Options Lock
	FLASH_CR_SEC_PROT = 1UL<<28, // Securable memory area protection enable
	FLASH_CR_OBL_LAUNCH = 1UL<<27, // Force the option byte loading
	FLASH_CR_RDERRIE = 1UL<<26, // PCROP read error interrupt enable
	FLASH_CR_ERRIE = 1UL<<25, // Error interrupt enable
	FLASH_CR_EOPIE = 1UL<<24, // End of operation interrupt enable
	FLASH_CR_FSTPG = 1UL<<18, // Fast programming
	FLASH_CR_OPTSTRT = 1UL<<17, // Options modification start
	FLASH_CR_STRT = 1UL<<16, // Start
	FLASH_CR_PNB = ((1UL<<6)-1) << 3, // Page number
	FLASH_CR_MER = 1UL<<2, // Mass erase
	FLASH_CR_PER = 1UL<<1, // Page erase
	FLASH_CR_PG = 1UL<<0, // Programming		
};
inline void flash_cr_set_pnb(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_PNB) | ((val<<3) & FLASH_CR_PNB); }
inline uint32_t flash_cr_get_pnb(struct FLASH_Type* p) { return (p->CR & FLASH_CR_PNB) >> 3 ; }

// FLASH->ECCR Flash ECC register
enum {
	FLASH_ECCR_ECCD = 1UL<<31, // ECC detection
	FLASH_ECCR_ECCC = 1UL<<30, // ECC correction
	FLASH_ECCR_ECCIE = 1UL<<24, // ECC correction interrupt enable
	FLASH_ECCR_SYSF_ECC = 1UL<<20, // ECC fail for Corrected ECC Error or Double ECC Error in info block
	FLASH_ECCR_ADDR_ECC = ((1UL<<14)-1) << 0, // ECC fail address		
};
inline void flash_eccr_set_addr_ecc(struct FLASH_Type* p, uint32_t val) { p->ECCR = (p->ECCR & ~FLASH_ECCR_ADDR_ECC) | ((val<<0) & FLASH_ECCR_ADDR_ECC); }
inline uint32_t flash_eccr_get_addr_ecc(struct FLASH_Type* p) { return (p->ECCR & FLASH_ECCR_ADDR_ECC) >> 0 ; }

// FLASH->OPTR Flash option register
enum {
	FLASH_OPTR_IRHEN = 1UL<<29, // Internal reset holder enable bit
	FLASH_OPTR_NRST_MODE = ((1UL<<2)-1) << 27, // NRST_MODE
	FLASH_OPTR_NBOOT0 = 1UL<<26, // nBOOT0 option bit
	FLASH_OPTR_NBOOT1 = 1UL<<25, // Boot configuration
	FLASH_OPTR_NBOOT_SEL = 1UL<<24, // nBOOT_SEL
	FLASH_OPTR_RAM_PARITY_CHECK = 1UL<<22, // SRAM parity check control
	FLASH_OPTR_WWDG_SW = 1UL<<19, // Window watchdog selection
	FLASH_OPTR_IWDG_STDBY = 1UL<<18, // Independent watchdog counter freeze in Standby mode
	FLASH_OPTR_IWDG_STOP = 1UL<<17, // Independent watchdog counter freeze in Stop mode
	FLASH_OPTR_IDWG_SW = 1UL<<16, // Independent watchdog selection
	FLASH_OPTR_NRSTS_HDW = 1UL<<15, // nRSTS_HDW
	FLASH_OPTR_NRST_STDBY = 1UL<<14, // nRST_STDBY
	FLASH_OPTR_NRST_STOP = 1UL<<13, // nRST_STOP
	FLASH_OPTR_BORR_LEV = ((1UL<<2)-1) << 11, // These bits contain the VDD supply level threshold that releases the reset.
	FLASH_OPTR_BORF_LEV = ((1UL<<2)-1) << 9, // These bits contain the VDD supply level threshold that activates the reset
	FLASH_OPTR_BOREN = 1UL<<8, // BOR reset Level
	FLASH_OPTR_RDP = ((1UL<<8)-1) << 0, // Read protection level		
};
inline void flash_optr_set_nrst_mode(struct FLASH_Type* p, uint32_t val) { p->OPTR = (p->OPTR & ~FLASH_OPTR_NRST_MODE) | ((val<<27) & FLASH_OPTR_NRST_MODE); }
inline void flash_optr_set_borr_lev(struct FLASH_Type* p, uint32_t val) { p->OPTR = (p->OPTR & ~FLASH_OPTR_BORR_LEV) | ((val<<11) & FLASH_OPTR_BORR_LEV); }
inline void flash_optr_set_borf_lev(struct FLASH_Type* p, uint32_t val) { p->OPTR = (p->OPTR & ~FLASH_OPTR_BORF_LEV) | ((val<<9) & FLASH_OPTR_BORF_LEV); }
inline void flash_optr_set_rdp(struct FLASH_Type* p, uint32_t val) { p->OPTR = (p->OPTR & ~FLASH_OPTR_RDP) | ((val<<0) & FLASH_OPTR_RDP); }
inline uint32_t flash_optr_get_nrst_mode(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_NRST_MODE) >> 27 ; }
inline uint32_t flash_optr_get_borr_lev(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_BORR_LEV) >> 11 ; }
inline uint32_t flash_optr_get_borf_lev(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_BORF_LEV) >> 9 ; }
inline uint32_t flash_optr_get_rdp(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_RDP) >> 0 ; }

// FLASH->PCROP1AER Flash PCROP zone A End address register
enum {
	FLASH_PCROP1AER_PCROP_RDP = 1UL<<31, // PCROP area preserved when RDP level decreased
	FLASH_PCROP1AER_PCROP1A_END = ((1UL<<8)-1) << 0, // PCROP1A area end offset		
};
inline uint32_t flash_pcrop1aer_get_pcrop1a_end(struct FLASH_Type* p) { return (p->PCROP1AER & FLASH_PCROP1AER_PCROP1A_END) >> 0 ; }

// FLASH->WRP1AR Flash WRP area A address register
enum {
	FLASH_WRP1AR_WRP1A_END = ((1UL<<6)-1) << 16, // WRP area A end offset
	FLASH_WRP1AR_WRP1A_STRT = ((1UL<<6)-1) << 0, // WRP area A start offset		
};
inline uint32_t flash_wrp1ar_get_wrp1a_end(struct FLASH_Type* p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_END) >> 16 ; }
inline uint32_t flash_wrp1ar_get_wrp1a_strt(struct FLASH_Type* p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_STRT) >> 0 ; }

// FLASH->WRP1BR Flash WRP area B address register
enum {
	FLASH_WRP1BR_WRP1B_END = ((1UL<<6)-1) << 16, // WRP area B end offset
	FLASH_WRP1BR_WRP1B_STRT = ((1UL<<6)-1) << 0, // WRP area B start offset		
};
inline uint32_t flash_wrp1br_get_wrp1b_end(struct FLASH_Type* p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_END) >> 16 ; }
inline uint32_t flash_wrp1br_get_wrp1b_strt(struct FLASH_Type* p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_STRT) >> 0 ; }

// FLASH->SECR Flash Security register
enum {
	FLASH_SECR_BOOT_LOCK = 1UL<<16, // used to force boot from user area
	FLASH_SECR_SEC_SIZE = ((1UL<<7)-1) << 0, // Securable memory area size		
};
inline uint32_t flash_secr_get_sec_size(struct FLASH_Type* p) { return (p->SECR & FLASH_SECR_SEC_SIZE) >> 0 ; }

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN = 1UL<<31, // ASPEN
	FPU_FPCCR_LSPEN = 1UL<<30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL<<8, // MONRDY
	FPU_FPCCR_BFRDY = 1UL<<6, // BFRDY
	FPU_FPCCR_MMRDY = 1UL<<5, // MMRDY
	FPU_FPCCR_HFRDY = 1UL<<4, // HFRDY
	FPU_FPCCR_THREAD = 1UL<<3, // THREAD
	FPU_FPCCR_USER = 1UL<<1, // USER
	FPU_FPCCR_LSPACT = 1UL<<0, // LSPACT		
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL<<29)-1) << 3, // Location of unpopulated floating-point		
};
inline void fpu_fpcar_set_address(struct FPU_Type* p, uint32_t val) { p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val<<3) & FPU_FPCAR_ADDRESS); }
inline uint32_t fpu_fpcar_get_address(struct FPU_Type* p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3 ; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N = 1UL<<31, // Negative condition code flag
	FPU_FPSCR_Z = 1UL<<30, // Zero condition code flag
	FPU_FPSCR_C = 1UL<<29, // Carry condition code flag
	FPU_FPSCR_V = 1UL<<28, // Overflow condition code flag
	FPU_FPSCR_AHP = 1UL<<26, // Alternative half-precision control bit
	FPU_FPSCR_DN = 1UL<<25, // Default NaN mode control bit
	FPU_FPSCR_FZ = 1UL<<24, // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL<<2)-1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC = 1UL<<7, // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC = 1UL<<4, // Inexact cumulative exception bit
	FPU_FPSCR_UFC = 1UL<<3, // Underflow cumulative exception bit
	FPU_FPSCR_OFC = 1UL<<2, // Overflow cumulative exception bit
	FPU_FPSCR_DZC = 1UL<<1, // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC = 1UL<<0, // Invalid operation cumulative exception bit		
};
inline void fpu_fpscr_set_rmode(struct FPU_Type* p, uint32_t val) { p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val<<22) & FPU_FPSCR_RMODE); }
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type* p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22 ; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL<<4)-1) << 20, // CP		
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type* p, uint32_t val) { p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val<<20) & FPU_CPACR_CPACR_CP); }
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type* p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20 ; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER; // @0 GPIO port mode register
	__IO uint16_t OTYPER; // @4 GPIO port output type register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t OSPEEDR; // @8 GPIO port output speed register
	__IO uint32_t PUPDR; // @12 GPIO port pull-up/pull-down register
	__I uint16_t IDR; // @16 GPIO port input data register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t ODR; // @20 GPIO port output data register
	 uint8_t RESERVED2[2]; // @22 
	__O uint32_t BSRR; // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR; // @28 GPIO port configuration lock register
	__IO uint32_t AFRL; // @32 GPIO alternate function low register
	__IO uint32_t AFRH; // @36 GPIO alternate function high register
	__O uint16_t BRR; // @40 port bit reset register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_moder_set_moder15(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val<<30) & GPIOA_MODER_MODER15); }
inline void gpioa_moder_set_moder14(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val<<28) & GPIOA_MODER_MODER14); }
inline void gpioa_moder_set_moder13(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val<<26) & GPIOA_MODER_MODER13); }
inline void gpioa_moder_set_moder12(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val<<24) & GPIOA_MODER_MODER12); }
inline void gpioa_moder_set_moder11(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val<<22) & GPIOA_MODER_MODER11); }
inline void gpioa_moder_set_moder10(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val<<20) & GPIOA_MODER_MODER10); }
inline void gpioa_moder_set_moder9(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val<<18) & GPIOA_MODER_MODER9); }
inline void gpioa_moder_set_moder8(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val<<16) & GPIOA_MODER_MODER8); }
inline void gpioa_moder_set_moder7(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val<<14) & GPIOA_MODER_MODER7); }
inline void gpioa_moder_set_moder6(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val<<12) & GPIOA_MODER_MODER6); }
inline void gpioa_moder_set_moder5(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val<<10) & GPIOA_MODER_MODER5); }
inline void gpioa_moder_set_moder4(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val<<8) & GPIOA_MODER_MODER4); }
inline void gpioa_moder_set_moder3(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val<<6) & GPIOA_MODER_MODER3); }
inline void gpioa_moder_set_moder2(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val<<4) & GPIOA_MODER_MODER2); }
inline void gpioa_moder_set_moder1(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val<<2) & GPIOA_MODER_MODER1); }
inline void gpioa_moder_set_moder0(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val<<0) & GPIOA_MODER_MODER0); }
inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30 ; }
inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28 ; }
inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26 ; }
inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24 ; }
inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22 ; }
inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20 ; }
inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18 ; }
inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16 ; }
inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14 ; }
inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12 ; }
inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10 ; }
inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8 ; }
inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6 ; }
inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4 ; }
inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2 ; }
inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0 ; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val<<30) & GPIOA_OSPEEDR_OSPEEDR15); }
inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val<<28) & GPIOA_OSPEEDR_OSPEEDR14); }
inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val<<26) & GPIOA_OSPEEDR_OSPEEDR13); }
inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val<<24) & GPIOA_OSPEEDR_OSPEEDR12); }
inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val<<22) & GPIOA_OSPEEDR_OSPEEDR11); }
inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val<<20) & GPIOA_OSPEEDR_OSPEEDR10); }
inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val<<18) & GPIOA_OSPEEDR_OSPEEDR9); }
inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val<<16) & GPIOA_OSPEEDR_OSPEEDR8); }
inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val<<14) & GPIOA_OSPEEDR_OSPEEDR7); }
inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val<<12) & GPIOA_OSPEEDR_OSPEEDR6); }
inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val<<10) & GPIOA_OSPEEDR_OSPEEDR5); }
inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val<<8) & GPIOA_OSPEEDR_OSPEEDR4); }
inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val<<6) & GPIOA_OSPEEDR_OSPEEDR3); }
inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val<<4) & GPIOA_OSPEEDR_OSPEEDR2); }
inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val<<2) & GPIOA_OSPEEDR_OSPEEDR1); }
inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val<<0) & GPIOA_OSPEEDR_OSPEEDR0); }
inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0 ; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val<<30) & GPIOA_PUPDR_PUPDR15); }
inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val<<28) & GPIOA_PUPDR_PUPDR14); }
inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val<<26) & GPIOA_PUPDR_PUPDR13); }
inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val<<24) & GPIOA_PUPDR_PUPDR12); }
inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val<<22) & GPIOA_PUPDR_PUPDR11); }
inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val<<20) & GPIOA_PUPDR_PUPDR10); }
inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val<<18) & GPIOA_PUPDR_PUPDR9); }
inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val<<16) & GPIOA_PUPDR_PUPDR8); }
inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val<<14) & GPIOA_PUPDR_PUPDR7); }
inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val<<12) & GPIOA_PUPDR_PUPDR6); }
inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val<<10) & GPIOA_PUPDR_PUPDR5); }
inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val<<8) & GPIOA_PUPDR_PUPDR4); }
inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val<<6) & GPIOA_PUPDR_PUPDR3); }
inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val<<4) & GPIOA_PUPDR_PUPDR2); }
inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val<<2) & GPIOA_PUPDR_PUPDR1); }
inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val<<0) & GPIOA_PUPDR_PUPDR0); }
inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30 ; }
inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28 ; }
inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26 ; }
inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24 ; }
inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22 ; }
inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20 ; }
inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18 ; }
inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16 ; }
inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14 ; }
inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12 ; }
inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10 ; }
inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8 ; }
inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6 ; }
inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4 ; }
inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2 ; }
inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0 ; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL<<31, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL<<30, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL<<29, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL<<28, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL<<27, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL<<26, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9 = 1UL<<25, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8 = 1UL<<24, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7 = 1UL<<23, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6 = 1UL<<22, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5 = 1UL<<21, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4 = 1UL<<20, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3 = 1UL<<19, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2 = 1UL<<18, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1 = 1UL<<17, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0 = 1UL<<16, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL<<15, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL<<14, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL<<13, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL<<12, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL<<11, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL<<10, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9 = 1UL<<9, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8 = 1UL<<8, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7 = 1UL<<7, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6 = 1UL<<6, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5 = 1UL<<5, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4 = 1UL<<4, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3 = 1UL<<3, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2 = 1UL<<2, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1 = 1UL<<1, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0 = 1UL<<0, // Port x set bit y (y= 0..15)		
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK = 1UL<<16, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL<<15, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL<<14, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL<<13, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL<<12, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL<<11, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL<<10, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9 = 1UL<<9, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8 = 1UL<<8, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7 = 1UL<<7, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6 = 1UL<<6, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5 = 1UL<<5, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4 = 1UL<<4, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3 = 1UL<<3, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2 = 1UL<<2, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1 = 1UL<<1, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0 = 1UL<<0, // Port x lock bit y (y= 0..15)		
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFSEL7 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL6 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL5 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL4 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL3 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL2 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL1 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFSEL0 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 0..7)		
};
inline void gpioa_afrl_set_afsel7(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL7) | ((val<<28) & GPIOA_AFRL_AFSEL7); }
inline void gpioa_afrl_set_afsel6(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL6) | ((val<<24) & GPIOA_AFRL_AFSEL6); }
inline void gpioa_afrl_set_afsel5(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL5) | ((val<<20) & GPIOA_AFRL_AFSEL5); }
inline void gpioa_afrl_set_afsel4(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL4) | ((val<<16) & GPIOA_AFRL_AFSEL4); }
inline void gpioa_afrl_set_afsel3(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL3) | ((val<<12) & GPIOA_AFRL_AFSEL3); }
inline void gpioa_afrl_set_afsel2(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL2) | ((val<<8) & GPIOA_AFRL_AFSEL2); }
inline void gpioa_afrl_set_afsel1(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL1) | ((val<<4) & GPIOA_AFRL_AFSEL1); }
inline void gpioa_afrl_set_afsel0(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL0) | ((val<<0) & GPIOA_AFRL_AFSEL0); }
inline uint32_t gpioa_afrl_get_afsel7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL7) >> 28 ; }
inline uint32_t gpioa_afrl_get_afsel6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL6) >> 24 ; }
inline uint32_t gpioa_afrl_get_afsel5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL5) >> 20 ; }
inline uint32_t gpioa_afrl_get_afsel4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL4) >> 16 ; }
inline uint32_t gpioa_afrl_get_afsel3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL3) >> 12 ; }
inline uint32_t gpioa_afrl_get_afsel2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL2) >> 8 ; }
inline uint32_t gpioa_afrl_get_afsel1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL1) >> 4 ; }
inline uint32_t gpioa_afrl_get_afsel0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL0) >> 0 ; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFSEL15 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL14 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL13 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL12 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL11 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL10 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL9 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFSEL8 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 8..15)		
};
inline void gpioa_afrh_set_afsel15(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL15) | ((val<<28) & GPIOA_AFRH_AFSEL15); }
inline void gpioa_afrh_set_afsel14(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL14) | ((val<<24) & GPIOA_AFRH_AFSEL14); }
inline void gpioa_afrh_set_afsel13(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL13) | ((val<<20) & GPIOA_AFRH_AFSEL13); }
inline void gpioa_afrh_set_afsel12(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL12) | ((val<<16) & GPIOA_AFRH_AFSEL12); }
inline void gpioa_afrh_set_afsel11(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL11) | ((val<<12) & GPIOA_AFRH_AFSEL11); }
inline void gpioa_afrh_set_afsel10(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL10) | ((val<<8) & GPIOA_AFRH_AFSEL10); }
inline void gpioa_afrh_set_afsel9(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL9) | ((val<<4) & GPIOA_AFRH_AFSEL9); }
inline void gpioa_afrh_set_afsel8(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL8) | ((val<<0) & GPIOA_AFRH_AFSEL8); }
inline uint32_t gpioa_afrh_get_afsel15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL15) >> 28 ; }
inline uint32_t gpioa_afrh_get_afsel14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL14) >> 24 ; }
inline uint32_t gpioa_afrh_get_afsel13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL13) >> 20 ; }
inline uint32_t gpioa_afrh_get_afsel12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL12) >> 16 ; }
inline uint32_t gpioa_afrh_get_afsel11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL11) >> 12 ; }
inline uint32_t gpioa_afrh_get_afsel10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL10) >> 8 ; }
inline uint32_t gpioa_afrh_get_afsel9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL9) >> 4 ; }
inline uint32_t gpioa_afrh_get_afsel8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL8) >> 0 ; }





/* Inter-integrated circuit */
struct I2C1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint16_t OAR1; // @8 Own address register 1
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t OAR2; // @12 Own address register 2
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t TIMINGR; // @16 Timing register
	__IO uint32_t TIMEOUTR; // @20 Status register 1
	__IO uint32_t ISR; // @24 Interrupt and Status register
	__O uint16_t ICR; // @28 Interrupt clear register
	 uint8_t RESERVED2[2]; // @30 
	__I uint8_t PECR; // @32 PEC register
	 uint8_t RESERVED3[3]; // @33 
	__I uint8_t RXDR; // @36 Receive data register
	 uint8_t RESERVED4[3]; // @37 
	__IO uint8_t TXDR; // @40 Transmit data register
};

// I2C1->CR1 Control register 1
enum {
	I2C1_CR1_PECEN = 1UL<<23, // PEC enable
	I2C1_CR1_ALERTEN = 1UL<<22, // SMBUS alert enable
	I2C1_CR1_SMBDEN = 1UL<<21, // SMBus Device Default address enable
	I2C1_CR1_SMBHEN = 1UL<<20, // SMBus Host address enable
	I2C1_CR1_GCEN = 1UL<<19, // General call enable
	I2C1_CR1_WUPEN = 1UL<<18, // Wakeup from STOP enable
	I2C1_CR1_NOSTRETCH = 1UL<<17, // Clock stretching disable
	I2C1_CR1_SBC = 1UL<<16, // Slave byte control
	I2C1_CR1_RXDMAEN = 1UL<<15, // DMA reception requests enable
	I2C1_CR1_TXDMAEN = 1UL<<14, // DMA transmission requests enable
	I2C1_CR1_ANFOFF = 1UL<<12, // Analog noise filter OFF
	I2C1_CR1_DNF = ((1UL<<4)-1) << 8, // Digital noise filter
	I2C1_CR1_ERRIE = 1UL<<7, // Error interrupts enable
	I2C1_CR1_TCIE = 1UL<<6, // Transfer Complete interrupt enable
	I2C1_CR1_STOPIE = 1UL<<5, // STOP detection Interrupt enable
	I2C1_CR1_NACKIE = 1UL<<4, // Not acknowledge received interrupt enable
	I2C1_CR1_ADDRIE = 1UL<<3, // Address match interrupt enable (slave only)
	I2C1_CR1_RXIE = 1UL<<2, // RX Interrupt enable
	I2C1_CR1_TXIE = 1UL<<1, // TX Interrupt enable
	I2C1_CR1_PE = 1UL<<0, // Peripheral enable		
};
inline void i2c1_cr1_set_dnf(struct I2C1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C1_CR1_DNF) | ((val<<8) & I2C1_CR1_DNF); }
inline uint32_t i2c1_cr1_get_dnf(struct I2C1_Type* p) { return (p->CR1 & I2C1_CR1_DNF) >> 8 ; }

// I2C1->CR2 Control register 2
enum {
	I2C1_CR2_PECBYTE = 1UL<<26, // Packet error checking byte
	I2C1_CR2_AUTOEND = 1UL<<25, // Automatic end mode (master mode)
	I2C1_CR2_RELOAD = 1UL<<24, // NBYTES reload mode
	I2C1_CR2_NBYTES = ((1UL<<8)-1) << 16, // Number of bytes
	I2C1_CR2_NACK = 1UL<<15, // NACK generation (slave mode)
	I2C1_CR2_STOP = 1UL<<14, // Stop generation (master mode)
	I2C1_CR2_START = 1UL<<13, // Start generation
	I2C1_CR2_HEAD10R = 1UL<<12, // 10-bit address header only read direction (master receiver mode)
	I2C1_CR2_ADD10 = 1UL<<11, // 10-bit addressing mode (master mode)
	I2C1_CR2_RD_WRN = 1UL<<10, // Transfer direction (master mode)
	I2C1_CR2_SADD = ((1UL<<10)-1) << 0, // Slave address bit (master mode)		
};
inline void i2c1_cr2_set_nbytes(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_NBYTES) | ((val<<16) & I2C1_CR2_NBYTES); }
inline void i2c1_cr2_set_sadd(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_SADD) | ((val<<0) & I2C1_CR2_SADD); }
inline uint32_t i2c1_cr2_get_nbytes(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_NBYTES) >> 16 ; }
inline uint32_t i2c1_cr2_get_sadd(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_SADD) >> 0 ; }

// I2C1->OAR1 Own address register 1
enum {
	I2C1_OAR1_OA1EN = 1UL<<15, // Own Address 1 enable
	I2C1_OAR1_OA1MODE = 1UL<<10, // Own Address 1 10-bit mode
	I2C1_OAR1_OA1_8_9 = ((1UL<<2)-1) << 8, // Interface address
	I2C1_OAR1_OA1_7_1 = ((1UL<<7)-1) << 1, // Interface address
	I2C1_OAR1_OA1_0 = 1UL<<0, // Interface address		
};
inline void i2c1_oar1_set_oa1_8_9(struct I2C1_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1_8_9) | ((val<<8) & I2C1_OAR1_OA1_8_9); }
inline void i2c1_oar1_set_oa1_7_1(struct I2C1_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1_7_1) | ((val<<1) & I2C1_OAR1_OA1_7_1); }
inline uint32_t i2c1_oar1_get_oa1_8_9(struct I2C1_Type* p) { return (p->OAR1 & I2C1_OAR1_OA1_8_9) >> 8 ; }
inline uint32_t i2c1_oar1_get_oa1_7_1(struct I2C1_Type* p) { return (p->OAR1 & I2C1_OAR1_OA1_7_1) >> 1 ; }

// I2C1->OAR2 Own address register 2
enum {
	I2C1_OAR2_OA2EN = 1UL<<15, // Own Address 2 enable
	I2C1_OAR2_OA2MSK = ((1UL<<3)-1) << 8, // Own Address 2 masks
	I2C1_OAR2_OA2 = ((1UL<<7)-1) << 1, // Interface address		
};
inline void i2c1_oar2_set_oa2msk(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2MSK) | ((val<<8) & I2C1_OAR2_OA2MSK); }
inline void i2c1_oar2_set_oa2(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2) | ((val<<1) & I2C1_OAR2_OA2); }
inline uint32_t i2c1_oar2_get_oa2msk(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2MSK) >> 8 ; }
inline uint32_t i2c1_oar2_get_oa2(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2) >> 1 ; }

// I2C1->TIMINGR Timing register
enum {
	I2C1_TIMINGR_PRESC = ((1UL<<4)-1) << 28, // Timing prescaler
	I2C1_TIMINGR_SCLDEL = ((1UL<<4)-1) << 20, // Data setup time
	I2C1_TIMINGR_SDADEL = ((1UL<<4)-1) << 16, // Data hold time
	I2C1_TIMINGR_SCLH = ((1UL<<8)-1) << 8, // SCL high period (master mode)
	I2C1_TIMINGR_SCLL = ((1UL<<8)-1) << 0, // SCL low period (master mode)		
};
inline void i2c1_timingr_set_presc(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_PRESC) | ((val<<28) & I2C1_TIMINGR_PRESC); }
inline void i2c1_timingr_set_scldel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLDEL) | ((val<<20) & I2C1_TIMINGR_SCLDEL); }
inline void i2c1_timingr_set_sdadel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SDADEL) | ((val<<16) & I2C1_TIMINGR_SDADEL); }
inline void i2c1_timingr_set_sclh(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLH) | ((val<<8) & I2C1_TIMINGR_SCLH); }
inline void i2c1_timingr_set_scll(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLL) | ((val<<0) & I2C1_TIMINGR_SCLL); }
inline uint32_t i2c1_timingr_get_presc(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_PRESC) >> 28 ; }
inline uint32_t i2c1_timingr_get_scldel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLDEL) >> 20 ; }
inline uint32_t i2c1_timingr_get_sdadel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SDADEL) >> 16 ; }
inline uint32_t i2c1_timingr_get_sclh(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLH) >> 8 ; }
inline uint32_t i2c1_timingr_get_scll(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLL) >> 0 ; }

// I2C1->TIMEOUTR Status register 1
enum {
	I2C1_TIMEOUTR_TEXTEN = 1UL<<31, // Extended clock timeout enable
	I2C1_TIMEOUTR_TIMEOUTB = ((1UL<<12)-1) << 16, // Bus timeout B
	I2C1_TIMEOUTR_TIMOUTEN = 1UL<<15, // Clock timeout enable
	I2C1_TIMEOUTR_TIDLE = 1UL<<12, // Idle clock timeout detection
	I2C1_TIMEOUTR_TIMEOUTA = ((1UL<<12)-1) << 0, // Bus timeout A		
};
inline void i2c1_timeoutr_set_timeoutb(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTB) | ((val<<16) & I2C1_TIMEOUTR_TIMEOUTB); }
inline void i2c1_timeoutr_set_timeouta(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTA) | ((val<<0) & I2C1_TIMEOUTR_TIMEOUTA); }
inline uint32_t i2c1_timeoutr_get_timeoutb(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTB) >> 16 ; }
inline uint32_t i2c1_timeoutr_get_timeouta(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTA) >> 0 ; }

// I2C1->ISR Interrupt and Status register
enum {
	I2C1_ISR_ADDCODE = ((1UL<<7)-1) << 17, // Address match code (Slave mode)
	I2C1_ISR_DIR = 1UL<<16, // Transfer direction (Slave mode)
	I2C1_ISR_BUSY = 1UL<<15, // Bus busy
	I2C1_ISR_ALERT = 1UL<<13, // SMBus alert
	I2C1_ISR_TIMEOUT = 1UL<<12, // Timeout or t_low detection flag
	I2C1_ISR_PECERR = 1UL<<11, // PEC Error in reception
	I2C1_ISR_OVR = 1UL<<10, // Overrun/Underrun (slave mode)
	I2C1_ISR_ARLO = 1UL<<9, // Arbitration lost
	I2C1_ISR_BERR = 1UL<<8, // Bus error
	I2C1_ISR_TCR = 1UL<<7, // Transfer Complete Reload
	I2C1_ISR_TC = 1UL<<6, // Transfer Complete (master mode)
	I2C1_ISR_STOPF = 1UL<<5, // Stop detection flag
	I2C1_ISR_NACKF = 1UL<<4, // Not acknowledge received flag
	I2C1_ISR_ADDR = 1UL<<3, // Address matched (slave mode)
	I2C1_ISR_RXNE = 1UL<<2, // Receive data register not empty (receivers)
	I2C1_ISR_TXIS = 1UL<<1, // Transmit interrupt status (transmitters)
	I2C1_ISR_TXE = 1UL<<0, // Transmit data register empty (transmitters)		
};
inline void i2c1_isr_set_addcode(struct I2C1_Type* p, uint32_t val) { p->ISR = (p->ISR & ~I2C1_ISR_ADDCODE) | ((val<<17) & I2C1_ISR_ADDCODE); }
inline uint32_t i2c1_isr_get_addcode(struct I2C1_Type* p) { return (p->ISR & I2C1_ISR_ADDCODE) >> 17 ; }

// I2C1->ICR Interrupt clear register
enum {
	I2C1_ICR_ALERTCF = 1UL<<13, // Alert flag clear
	I2C1_ICR_TIMOUTCF = 1UL<<12, // Timeout detection flag clear
	I2C1_ICR_PECCF = 1UL<<11, // PEC Error flag clear
	I2C1_ICR_OVRCF = 1UL<<10, // Overrun/Underrun flag clear
	I2C1_ICR_ARLOCF = 1UL<<9, // Arbitration lost flag clear
	I2C1_ICR_BERRCF = 1UL<<8, // Bus error flag clear
	I2C1_ICR_STOPCF = 1UL<<5, // Stop detection flag clear
	I2C1_ICR_NACKCF = 1UL<<4, // Not Acknowledge flag clear
	I2C1_ICR_ADDRCF = 1UL<<3, // Address Matched flag clear		
};


/* Independent watchdog */
struct IWDG_Type {
	__O uint16_t KR; // @0 Key register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t PR; // @4 Prescaler register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t RLR; // @8 Reload register
	 uint8_t RESERVED2[2]; // @10 
	__I uint8_t SR; // @12 Status register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t WINR; // @16 Window register
};

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL<<3)-1) << 0, // Prescaler divider		
};
inline void iwdg_pr_set_pr(struct IWDG_Type* p, uint32_t val) { p->PR = (p->PR & ~IWDG_PR_PR) | ((val<<0) & IWDG_PR_PR); }
inline uint32_t iwdg_pr_get_pr(struct IWDG_Type* p) { return (p->PR & IWDG_PR_PR) >> 0 ; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL<<12)-1) << 0, // Watchdog counter reload value		
};
inline void iwdg_rlr_set_rl(struct IWDG_Type* p, uint32_t val) { p->RLR = (p->RLR & ~IWDG_RLR_RL) | ((val<<0) & IWDG_RLR_RL); }
inline uint32_t iwdg_rlr_get_rl(struct IWDG_Type* p) { return (p->RLR & IWDG_RLR_RL) >> 0 ; }

// IWDG->SR Status register
enum {
	IWDG_SR_WVU = 1UL<<2, // Watchdog counter window value update
	IWDG_SR_RVU = 1UL<<1, // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL<<0, // Watchdog prescaler value update		
};

// IWDG->WINR Window register
enum {
	IWDG_WINR_WIN = ((1UL<<12)-1) << 0, // Watchdog counter window value		
};
inline void iwdg_winr_set_win(struct IWDG_Type* p, uint32_t val) { p->WINR = (p->WINR & ~IWDG_WINR_WIN) | ((val<<0) & IWDG_WINR_WIN); }
inline uint32_t iwdg_winr_get_win(struct IWDG_Type* p) { return (p->WINR & IWDG_WINR_WIN) >> 0 ; }

/* Low power timer */
struct LPTIM1_Type {
	__I uint8_t ISR; // @0 Interrupt and Status Register
	 uint8_t RESERVED0[3]; // @1 
	__O uint8_t ICR; // @4 Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t IER; // @8 Interrupt Enable Register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint32_t CFGR; // @12 Configuration Register
	__IO uint8_t CR; // @16 Control Register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t CMP; // @20 Compare Register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t ARR; // @24 Autoreload Register
	 uint8_t RESERVED5[2]; // @26 
	__I uint16_t CNT; // @28 Counter Register
	 uint8_t RESERVED6[6]; // @30 
	__IO uint8_t CFGR2; // @36 LPTIM configuration register 2
};

// LPTIM1->ISR Interrupt and Status Register
enum {
	LPTIM1_ISR_DOWN = 1UL<<6, // Counter direction change up to down
	LPTIM1_ISR_UP = 1UL<<5, // Counter direction change down to up
	LPTIM1_ISR_ARROK = 1UL<<4, // Autoreload register update OK
	LPTIM1_ISR_CMPOK = 1UL<<3, // Compare register update OK
	LPTIM1_ISR_EXTTRIG = 1UL<<2, // External trigger edge event
	LPTIM1_ISR_ARRM = 1UL<<1, // Autoreload match
	LPTIM1_ISR_CMPM = 1UL<<0, // Compare match		
};

// LPTIM1->ICR Interrupt Clear Register
enum {
	LPTIM1_ICR_DOWNCF = 1UL<<6, // Direction change to down Clear Flag
	LPTIM1_ICR_UPCF = 1UL<<5, // Direction change to UP Clear Flag
	LPTIM1_ICR_ARROKCF = 1UL<<4, // Autoreload register update OK Clear Flag
	LPTIM1_ICR_CMPOKCF = 1UL<<3, // Compare register update OK Clear Flag
	LPTIM1_ICR_EXTTRIGCF = 1UL<<2, // External trigger valid edge Clear Flag
	LPTIM1_ICR_ARRMCF = 1UL<<1, // Autoreload match Clear Flag
	LPTIM1_ICR_CMPMCF = 1UL<<0, // compare match Clear Flag		
};

// LPTIM1->IER Interrupt Enable Register
enum {
	LPTIM1_IER_DOWNIE = 1UL<<6, // Direction change to down Interrupt Enable
	LPTIM1_IER_UPIE = 1UL<<5, // Direction change to UP Interrupt Enable
	LPTIM1_IER_ARROKIE = 1UL<<4, // Autoreload register update OK Interrupt Enable
	LPTIM1_IER_CMPOKIE = 1UL<<3, // Compare register update OK Interrupt Enable
	LPTIM1_IER_EXTTRIGIE = 1UL<<2, // External trigger valid edge Interrupt Enable
	LPTIM1_IER_ARRMIE = 1UL<<1, // Autoreload match Interrupt Enable
	LPTIM1_IER_CMPMIE = 1UL<<0, // Compare match Interrupt Enable		
};

// LPTIM1->CFGR Configuration Register
enum {
	LPTIM1_CFGR_ENC = 1UL<<24, // Encoder mode enable
	LPTIM1_CFGR_COUNTMODE = 1UL<<23, // counter mode enabled
	LPTIM1_CFGR_PRELOAD = 1UL<<22, // Registers update mode
	LPTIM1_CFGR_WAVPOL = 1UL<<21, // Waveform shape polarity
	LPTIM1_CFGR_WAVE = 1UL<<20, // Waveform shape
	LPTIM1_CFGR_TIMOUT = 1UL<<19, // Timeout enable
	LPTIM1_CFGR_TRIGEN = ((1UL<<2)-1) << 17, // Trigger enable and polarity
	LPTIM1_CFGR_TRIGSEL = ((1UL<<3)-1) << 13, // Trigger selector
	LPTIM1_CFGR_PRESC = ((1UL<<3)-1) << 9, // Clock prescaler
	LPTIM1_CFGR_TRGFLT = ((1UL<<2)-1) << 6, // Configurable digital filter for trigger
	LPTIM1_CFGR_CKFLT = ((1UL<<2)-1) << 3, // Configurable digital filter for external clock
	LPTIM1_CFGR_CKPOL = ((1UL<<2)-1) << 1, // Clock Polarity
	LPTIM1_CFGR_CKSEL = 1UL<<0, // Clock selector		
};
inline void lptim1_cfgr_set_trigen(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGEN) | ((val<<17) & LPTIM1_CFGR_TRIGEN); }
inline void lptim1_cfgr_set_trigsel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGSEL) | ((val<<13) & LPTIM1_CFGR_TRIGSEL); }
inline void lptim1_cfgr_set_presc(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_PRESC) | ((val<<9) & LPTIM1_CFGR_PRESC); }
inline void lptim1_cfgr_set_trgflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRGFLT) | ((val<<6) & LPTIM1_CFGR_TRGFLT); }
inline void lptim1_cfgr_set_ckflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKFLT) | ((val<<3) & LPTIM1_CFGR_CKFLT); }
inline void lptim1_cfgr_set_ckpol(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKPOL) | ((val<<1) & LPTIM1_CFGR_CKPOL); }
inline uint32_t lptim1_cfgr_get_trigen(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGEN) >> 17 ; }
inline uint32_t lptim1_cfgr_get_trigsel(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGSEL) >> 13 ; }
inline uint32_t lptim1_cfgr_get_presc(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_PRESC) >> 9 ; }
inline uint32_t lptim1_cfgr_get_trgflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRGFLT) >> 6 ; }
inline uint32_t lptim1_cfgr_get_ckflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKFLT) >> 3 ; }
inline uint32_t lptim1_cfgr_get_ckpol(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKPOL) >> 1 ; }

// LPTIM1->CR Control Register
enum {
	LPTIM1_CR_RSTARE = 1UL<<4, // Reset after read enable
	LPTIM1_CR_COUNTRST = 1UL<<3, // Counter reset
	LPTIM1_CR_CNTSTRT = 1UL<<2, // Timer start in continuous mode
	LPTIM1_CR_SNGSTRT = 1UL<<1, // LPTIM start in single mode
	LPTIM1_CR_ENABLE = 1UL<<0, // LPTIM Enable		
};

// LPTIM1->CFGR2 LPTIM configuration register 2
enum {
	LPTIM1_CFGR2_IN2SEL = ((1UL<<2)-1) << 4, // LPTIM1 Input 2 selection
	LPTIM1_CFGR2_IN1SEL = ((1UL<<2)-1) << 0, // LPTIMx Input 1 selection		
};
inline void lptim1_cfgr2_set_in2sel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~LPTIM1_CFGR2_IN2SEL) | ((val<<4) & LPTIM1_CFGR2_IN2SEL); }
inline void lptim1_cfgr2_set_in1sel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~LPTIM1_CFGR2_IN1SEL) | ((val<<0) & LPTIM1_CFGR2_IN1SEL); }
inline uint32_t lptim1_cfgr2_get_in2sel(struct LPTIM1_Type* p) { return (p->CFGR2 & LPTIM1_CFGR2_IN2SEL) >> 4 ; }
inline uint32_t lptim1_cfgr2_get_in1sel(struct LPTIM1_Type* p) { return (p->CFGR2 & LPTIM1_CFGR2_IN1SEL) >> 0 ; }


/* Universal synchronous asynchronous receiver transmitter */
struct LPUART_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint32_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[8]; // @16 
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED1[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED2[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
	 uint8_t RESERVED3[2]; // @42 
	__IO uint8_t PRESC; // @44 Prescaler register
};

// LPUART->CR1 Control register 1
enum {
	LPUART_CR1_RXFFIE = 1UL<<31, // RXFIFO Full interrupt enable
	LPUART_CR1_TXFEIE = 1UL<<30, // TXFIFO empty interrupt enable
	LPUART_CR1_FIFOEN = 1UL<<29, // FIFO mode enable
	LPUART_CR1_M1 = 1UL<<28, // Word length
	LPUART_CR1_DEAT = ((1UL<<5)-1) << 21, // DEAT0
	LPUART_CR1_DEDT0 = ((1UL<<5)-1) << 16, // DEDT0
	LPUART_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	LPUART_CR1_MME = 1UL<<13, // Mute mode enable
	LPUART_CR1_M0 = 1UL<<12, // Word length
	LPUART_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	LPUART_CR1_PCE = 1UL<<10, // Parity control enable
	LPUART_CR1_PS = 1UL<<9, // Parity selection
	LPUART_CR1_PEIE = 1UL<<8, // PE interrupt enable
	LPUART_CR1_TXEIE = 1UL<<7, // interrupt enable
	LPUART_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	LPUART_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	LPUART_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	LPUART_CR1_TE = 1UL<<3, // Transmitter enable
	LPUART_CR1_RE = 1UL<<2, // Receiver enable
	LPUART_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	LPUART_CR1_UE = 1UL<<0, // USART enable		
};
inline void lpuart_cr1_set_deat(struct LPUART_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~LPUART_CR1_DEAT) | ((val<<21) & LPUART_CR1_DEAT); }
inline void lpuart_cr1_set_dedt0(struct LPUART_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~LPUART_CR1_DEDT0) | ((val<<16) & LPUART_CR1_DEDT0); }
inline uint32_t lpuart_cr1_get_deat(struct LPUART_Type* p) { return (p->CR1 & LPUART_CR1_DEAT) >> 21 ; }
inline uint32_t lpuart_cr1_get_dedt0(struct LPUART_Type* p) { return (p->CR1 & LPUART_CR1_DEDT0) >> 16 ; }

// LPUART->CR2 Control register 2
enum {
	LPUART_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	LPUART_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	LPUART_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	LPUART_CR2_TAINV = 1UL<<18, // Binary data inversion
	LPUART_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	LPUART_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	LPUART_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	LPUART_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	LPUART_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
inline void lpuart_cr2_set_add4_7(struct LPUART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART_CR2_ADD4_7) | ((val<<28) & LPUART_CR2_ADD4_7); }
inline void lpuart_cr2_set_add0_3(struct LPUART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART_CR2_ADD0_3) | ((val<<24) & LPUART_CR2_ADD0_3); }
inline void lpuart_cr2_set_stop(struct LPUART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART_CR2_STOP) | ((val<<12) & LPUART_CR2_STOP); }
inline uint32_t lpuart_cr2_get_add4_7(struct LPUART_Type* p) { return (p->CR2 & LPUART_CR2_ADD4_7) >> 28 ; }
inline uint32_t lpuart_cr2_get_add0_3(struct LPUART_Type* p) { return (p->CR2 & LPUART_CR2_ADD0_3) >> 24 ; }
inline uint32_t lpuart_cr2_get_stop(struct LPUART_Type* p) { return (p->CR2 & LPUART_CR2_STOP) >> 12 ; }

// LPUART->CR3 Control register 3
enum {
	LPUART_CR3_TXFTCFG = ((1UL<<3)-1) << 29, // TXFIFO threshold configuration
	LPUART_CR3_RXFTIE = 1UL<<28, // RXFIFO threshold interrupt enable
	LPUART_CR3_RXFTCFG = ((1UL<<3)-1) << 25, // Receive FIFO threshold configuration
	LPUART_CR3_TXFTIE = 1UL<<23, // threshold interrupt enable
	LPUART_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	LPUART_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	LPUART_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	LPUART_CR3_DEM = 1UL<<14, // Driver enable mode
	LPUART_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	LPUART_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	LPUART_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	LPUART_CR3_CTSE = 1UL<<9, // CTS enable
	LPUART_CR3_RTSE = 1UL<<8, // RTS enable
	LPUART_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	LPUART_CR3_DMAR = 1UL<<6, // DMA enable receiver
	LPUART_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	LPUART_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void lpuart_cr3_set_txftcfg(struct LPUART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART_CR3_TXFTCFG) | ((val<<29) & LPUART_CR3_TXFTCFG); }
inline void lpuart_cr3_set_rxftcfg(struct LPUART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART_CR3_RXFTCFG) | ((val<<25) & LPUART_CR3_RXFTCFG); }
inline void lpuart_cr3_set_wus(struct LPUART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART_CR3_WUS) | ((val<<20) & LPUART_CR3_WUS); }
inline uint32_t lpuart_cr3_get_txftcfg(struct LPUART_Type* p) { return (p->CR3 & LPUART_CR3_TXFTCFG) >> 29 ; }
inline uint32_t lpuart_cr3_get_rxftcfg(struct LPUART_Type* p) { return (p->CR3 & LPUART_CR3_RXFTCFG) >> 25 ; }
inline uint32_t lpuart_cr3_get_wus(struct LPUART_Type* p) { return (p->CR3 & LPUART_CR3_WUS) >> 20 ; }

// LPUART->BRR Baud rate register
enum {
	LPUART_BRR_BRR = ((1UL<<20)-1) << 0, // BRR		
};
inline void lpuart_brr_set_brr(struct LPUART_Type* p, uint32_t val) { p->BRR = (p->BRR & ~LPUART_BRR_BRR) | ((val<<0) & LPUART_BRR_BRR); }
inline uint32_t lpuart_brr_get_brr(struct LPUART_Type* p) { return (p->BRR & LPUART_BRR_BRR) >> 0 ; }

// LPUART->RQR Request register
enum {
	LPUART_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	LPUART_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	LPUART_RQR_MMRQ = 1UL<<2, // Mute mode request
	LPUART_RQR_SBKRQ = 1UL<<1, // Send break request
	LPUART_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// LPUART->ISR Interrupt & status register
enum {
	LPUART_ISR_TXFT = 1UL<<27, // TXFIFO threshold flag
	LPUART_ISR_RXFT = 1UL<<26, // RXFIFO threshold flag
	LPUART_ISR_RXFF = 1UL<<24, // RXFIFO Full
	LPUART_ISR_TXFE = 1UL<<23, // TXFIFO Empty
	LPUART_ISR_REACK = 1UL<<22, // REACK
	LPUART_ISR_TEACK = 1UL<<21, // TEACK
	LPUART_ISR_WUF = 1UL<<20, // WUF
	LPUART_ISR_RWU = 1UL<<19, // RWU
	LPUART_ISR_SBKF = 1UL<<18, // SBKF
	LPUART_ISR_CMF = 1UL<<17, // CMF
	LPUART_ISR_BUSY = 1UL<<16, // BUSY
	LPUART_ISR_CTS = 1UL<<10, // CTS
	LPUART_ISR_CTSIF = 1UL<<9, // CTSIF
	LPUART_ISR_TXE = 1UL<<7, // TXE
	LPUART_ISR_TC = 1UL<<6, // TC
	LPUART_ISR_RXNE = 1UL<<5, // RXNE
	LPUART_ISR_IDLE = 1UL<<4, // IDLE
	LPUART_ISR_ORE = 1UL<<3, // ORE
	LPUART_ISR_NF = 1UL<<2, // NF
	LPUART_ISR_FE = 1UL<<1, // FE
	LPUART_ISR_PE = 1UL<<0, // PE		
};

// LPUART->ICR Interrupt flag clear register
enum {
	LPUART_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	LPUART_ICR_CMCF = 1UL<<17, // Character match clear flag
	LPUART_ICR_CTSCF = 1UL<<9, // CTS clear flag
	LPUART_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	LPUART_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	LPUART_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	LPUART_ICR_NCF = 1UL<<2, // Noise detected clear flag
	LPUART_ICR_FECF = 1UL<<1, // Framing error clear flag
	LPUART_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// LPUART->RDR Receive data register
enum {
	LPUART_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t lpuart_rdr_get_rdr(struct LPUART_Type* p) { return (p->RDR & LPUART_RDR_RDR) >> 0 ; }

// LPUART->TDR Transmit data register
enum {
	LPUART_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void lpuart_tdr_set_tdr(struct LPUART_Type* p, uint32_t val) { p->TDR = (p->TDR & ~LPUART_TDR_TDR) | ((val<<0) & LPUART_TDR_TDR); }
inline uint32_t lpuart_tdr_get_tdr(struct LPUART_Type* p) { return (p->TDR & LPUART_TDR_TDR) >> 0 ; }

// LPUART->PRESC Prescaler register
enum {
	LPUART_PRESC_PRESCALER = ((1UL<<4)-1) << 0, // Clock prescaler		
};
inline void lpuart_presc_set_prescaler(struct LPUART_Type* p, uint32_t val) { p->PRESC = (p->PRESC & ~LPUART_PRESC_PRESCALER) | ((val<<0) & LPUART_PRESC_PRESCALER); }
inline uint32_t lpuart_presc_get_prescaler(struct LPUART_Type* p) { return (p->PRESC & LPUART_PRESC_PRESCALER) >> 0 ; }

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t MPU_TYPER; // @0 MPU type register
	__I uint8_t MPU_CTRL; // @4 MPU control register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t MPU_RNR; // @8 MPU region number register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t MPU_RBAR; // @12 MPU region base address register
	__IO uint32_t MPU_RASR; // @16 MPU region attribute and size register
};

// MPU->MPU_TYPER MPU type register
enum {
	MPU_MPU_TYPER_IREGION = ((1UL<<8)-1) << 16, // Number of MPU instruction regions
	MPU_MPU_TYPER_DREGION = ((1UL<<8)-1) << 8, // Number of MPU data regions
	MPU_MPU_TYPER_SEPARATE = 1UL<<0, // Separate flag		
};
inline uint32_t mpu_mpu_typer_get_iregion(struct MPU_Type* p) { return (p->MPU_TYPER & MPU_MPU_TYPER_IREGION) >> 16 ; }
inline uint32_t mpu_mpu_typer_get_dregion(struct MPU_Type* p) { return (p->MPU_TYPER & MPU_MPU_TYPER_DREGION) >> 8 ; }

// MPU->MPU_CTRL MPU control register
enum {
	MPU_MPU_CTRL_PRIVDEFENA = 1UL<<2, // Enable priviliged software access to default memory map
	MPU_MPU_CTRL_HFNMIENA = 1UL<<1, // Enables the operation of MPU during hard fault
	MPU_MPU_CTRL_ENABLE = 1UL<<0, // Enables the MPU		
};

// MPU->MPU_RBAR MPU region base address register
enum {
	MPU_MPU_RBAR_ADDR = ((1UL<<27)-1) << 5, // Region base address field
	MPU_MPU_RBAR_VALID = 1UL<<4, // MPU region number valid
	MPU_MPU_RBAR_REGION = ((1UL<<4)-1) << 0, // MPU region field		
};
inline void mpu_mpu_rbar_set_addr(struct MPU_Type* p, uint32_t val) { p->MPU_RBAR = (p->MPU_RBAR & ~MPU_MPU_RBAR_ADDR) | ((val<<5) & MPU_MPU_RBAR_ADDR); }
inline void mpu_mpu_rbar_set_region(struct MPU_Type* p, uint32_t val) { p->MPU_RBAR = (p->MPU_RBAR & ~MPU_MPU_RBAR_REGION) | ((val<<0) & MPU_MPU_RBAR_REGION); }
inline uint32_t mpu_mpu_rbar_get_addr(struct MPU_Type* p) { return (p->MPU_RBAR & MPU_MPU_RBAR_ADDR) >> 5 ; }
inline uint32_t mpu_mpu_rbar_get_region(struct MPU_Type* p) { return (p->MPU_RBAR & MPU_MPU_RBAR_REGION) >> 0 ; }

// MPU->MPU_RASR MPU region attribute and size register
enum {
	MPU_MPU_RASR_XN = 1UL<<28, // Instruction access disable bit
	MPU_MPU_RASR_AP = ((1UL<<3)-1) << 24, // Access permission
	MPU_MPU_RASR_TEX = ((1UL<<3)-1) << 19, // memory attribute
	MPU_MPU_RASR_S = 1UL<<18, // Shareable memory attribute
	MPU_MPU_RASR_C = 1UL<<17, // memory attribute
	MPU_MPU_RASR_B = 1UL<<16, // memory attribute
	MPU_MPU_RASR_SRD = ((1UL<<8)-1) << 8, // Subregion disable bits
	MPU_MPU_RASR_SIZE = ((1UL<<5)-1) << 1, // Size of the MPU protection region
	MPU_MPU_RASR_ENABLE = 1UL<<0, // Region enable bit.		
};
inline void mpu_mpu_rasr_set_ap(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_AP) | ((val<<24) & MPU_MPU_RASR_AP); }
inline void mpu_mpu_rasr_set_tex(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_TEX) | ((val<<19) & MPU_MPU_RASR_TEX); }
inline void mpu_mpu_rasr_set_srd(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_SRD) | ((val<<8) & MPU_MPU_RASR_SRD); }
inline void mpu_mpu_rasr_set_size(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_SIZE) | ((val<<1) & MPU_MPU_RASR_SIZE); }
inline uint32_t mpu_mpu_rasr_get_ap(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_AP) >> 24 ; }
inline uint32_t mpu_mpu_rasr_get_tex(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_TEX) >> 19 ; }
inline uint32_t mpu_mpu_rasr_get_srd(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_SRD) >> 8 ; }
inline uint32_t mpu_mpu_rasr_get_size(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_SIZE) >> 1 ; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER; // @0 Interrupt Set Enable Register
	 uint8_t RESERVED0[124]; // @4 
	__IO uint32_t ICER; // @128 Interrupt Clear Enable Register
	 uint8_t RESERVED1[124]; // @132 
	__IO uint32_t ISPR; // @256 Interrupt Set-Pending Register
	 uint8_t RESERVED2[124]; // @260 
	__IO uint32_t ICPR; // @384 Interrupt Clear-Pending Register
	 uint8_t RESERVED3[380]; // @388 
	__IO uint32_t IPR0; // @768 Interrupt Priority Register 0
	__IO uint32_t IPR1; // @772 Interrupt Priority Register 1
	__IO uint32_t IPR2; // @776 Interrupt Priority Register 2
	__IO uint32_t IPR3; // @780 Interrupt Priority Register 3
	__IO uint32_t IPR4; // @784 Interrupt Priority Register 4
	__IO uint32_t IPR5; // @788 Interrupt Priority Register 5
	__IO uint32_t IPR6; // @792 Interrupt Priority Register 6
	__IO uint32_t IPR7; // @796 Interrupt Priority Register 7
	__IO uint32_t IPR8; // @800 Interrupt Priority Register 8
};

// NVIC->IPR0 Interrupt Priority Register 0
enum {
	NVIC_IPR0_PRI_3 = ((1UL<<8)-1) << 24, // priority for interrupt 3
	NVIC_IPR0_PRI_2 = ((1UL<<8)-1) << 16, // priority for interrupt 2
	NVIC_IPR0_PRI_1 = ((1UL<<8)-1) << 8, // priority for interrupt 1
	NVIC_IPR0_PRI_0 = ((1UL<<8)-1) << 0, // priority for interrupt 0		
};
inline void nvic_ipr0_set_pri_3(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_PRI_3) | ((val<<24) & NVIC_IPR0_PRI_3); }
inline void nvic_ipr0_set_pri_2(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_PRI_2) | ((val<<16) & NVIC_IPR0_PRI_2); }
inline void nvic_ipr0_set_pri_1(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_PRI_1) | ((val<<8) & NVIC_IPR0_PRI_1); }
inline void nvic_ipr0_set_pri_0(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_PRI_0) | ((val<<0) & NVIC_IPR0_PRI_0); }
inline uint32_t nvic_ipr0_get_pri_3(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_PRI_3) >> 24 ; }
inline uint32_t nvic_ipr0_get_pri_2(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_PRI_2) >> 16 ; }
inline uint32_t nvic_ipr0_get_pri_1(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_PRI_1) >> 8 ; }
inline uint32_t nvic_ipr0_get_pri_0(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_PRI_0) >> 0 ; }

// NVIC->IPR1 Interrupt Priority Register 1
enum {
	NVIC_IPR1_PRI_7 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR1_PRI_6 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR1_PRI_5 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR1_PRI_4 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr1_set_pri_7(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_PRI_7) | ((val<<24) & NVIC_IPR1_PRI_7); }
inline void nvic_ipr1_set_pri_6(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_PRI_6) | ((val<<16) & NVIC_IPR1_PRI_6); }
inline void nvic_ipr1_set_pri_5(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_PRI_5) | ((val<<8) & NVIC_IPR1_PRI_5); }
inline void nvic_ipr1_set_pri_4(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_PRI_4) | ((val<<0) & NVIC_IPR1_PRI_4); }
inline uint32_t nvic_ipr1_get_pri_7(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_PRI_7) >> 24 ; }
inline uint32_t nvic_ipr1_get_pri_6(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_PRI_6) >> 16 ; }
inline uint32_t nvic_ipr1_get_pri_5(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_PRI_5) >> 8 ; }
inline uint32_t nvic_ipr1_get_pri_4(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_PRI_4) >> 0 ; }

// NVIC->IPR2 Interrupt Priority Register 2
enum {
	NVIC_IPR2_PRI_11 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR2_PRI_10 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR2_PRI_9 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR2_PRI_8 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr2_set_pri_11(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_PRI_11) | ((val<<24) & NVIC_IPR2_PRI_11); }
inline void nvic_ipr2_set_pri_10(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_PRI_10) | ((val<<16) & NVIC_IPR2_PRI_10); }
inline void nvic_ipr2_set_pri_9(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_PRI_9) | ((val<<8) & NVIC_IPR2_PRI_9); }
inline void nvic_ipr2_set_pri_8(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_PRI_8) | ((val<<0) & NVIC_IPR2_PRI_8); }
inline uint32_t nvic_ipr2_get_pri_11(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_PRI_11) >> 24 ; }
inline uint32_t nvic_ipr2_get_pri_10(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_PRI_10) >> 16 ; }
inline uint32_t nvic_ipr2_get_pri_9(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_PRI_9) >> 8 ; }
inline uint32_t nvic_ipr2_get_pri_8(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_PRI_8) >> 0 ; }

// NVIC->IPR3 Interrupt Priority Register 3
enum {
	NVIC_IPR3_PRI_15 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR3_PRI_14 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR3_PRI_13 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR3_PRI_12 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr3_set_pri_15(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_PRI_15) | ((val<<24) & NVIC_IPR3_PRI_15); }
inline void nvic_ipr3_set_pri_14(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_PRI_14) | ((val<<16) & NVIC_IPR3_PRI_14); }
inline void nvic_ipr3_set_pri_13(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_PRI_13) | ((val<<8) & NVIC_IPR3_PRI_13); }
inline void nvic_ipr3_set_pri_12(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_PRI_12) | ((val<<0) & NVIC_IPR3_PRI_12); }
inline uint32_t nvic_ipr3_get_pri_15(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_PRI_15) >> 24 ; }
inline uint32_t nvic_ipr3_get_pri_14(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_PRI_14) >> 16 ; }
inline uint32_t nvic_ipr3_get_pri_13(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_PRI_13) >> 8 ; }
inline uint32_t nvic_ipr3_get_pri_12(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_PRI_12) >> 0 ; }

// NVIC->IPR4 Interrupt Priority Register 4
enum {
	NVIC_IPR4_PRI_19 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR4_PRI_18 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR4_PRI_17 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR4_PRI_16 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr4_set_pri_19(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_PRI_19) | ((val<<24) & NVIC_IPR4_PRI_19); }
inline void nvic_ipr4_set_pri_18(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_PRI_18) | ((val<<16) & NVIC_IPR4_PRI_18); }
inline void nvic_ipr4_set_pri_17(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_PRI_17) | ((val<<8) & NVIC_IPR4_PRI_17); }
inline void nvic_ipr4_set_pri_16(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_PRI_16) | ((val<<0) & NVIC_IPR4_PRI_16); }
inline uint32_t nvic_ipr4_get_pri_19(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_PRI_19) >> 24 ; }
inline uint32_t nvic_ipr4_get_pri_18(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_PRI_18) >> 16 ; }
inline uint32_t nvic_ipr4_get_pri_17(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_PRI_17) >> 8 ; }
inline uint32_t nvic_ipr4_get_pri_16(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_PRI_16) >> 0 ; }

// NVIC->IPR5 Interrupt Priority Register 5
enum {
	NVIC_IPR5_PRI_23 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR5_PRI_22 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR5_PRI_21 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR5_PRI_20 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr5_set_pri_23(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_PRI_23) | ((val<<24) & NVIC_IPR5_PRI_23); }
inline void nvic_ipr5_set_pri_22(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_PRI_22) | ((val<<16) & NVIC_IPR5_PRI_22); }
inline void nvic_ipr5_set_pri_21(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_PRI_21) | ((val<<8) & NVIC_IPR5_PRI_21); }
inline void nvic_ipr5_set_pri_20(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_PRI_20) | ((val<<0) & NVIC_IPR5_PRI_20); }
inline uint32_t nvic_ipr5_get_pri_23(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_PRI_23) >> 24 ; }
inline uint32_t nvic_ipr5_get_pri_22(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_PRI_22) >> 16 ; }
inline uint32_t nvic_ipr5_get_pri_21(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_PRI_21) >> 8 ; }
inline uint32_t nvic_ipr5_get_pri_20(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_PRI_20) >> 0 ; }

// NVIC->IPR6 Interrupt Priority Register 6
enum {
	NVIC_IPR6_PRI_27 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR6_PRI_26 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR6_PRI_25 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR6_PRI_24 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr6_set_pri_27(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_PRI_27) | ((val<<24) & NVIC_IPR6_PRI_27); }
inline void nvic_ipr6_set_pri_26(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_PRI_26) | ((val<<16) & NVIC_IPR6_PRI_26); }
inline void nvic_ipr6_set_pri_25(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_PRI_25) | ((val<<8) & NVIC_IPR6_PRI_25); }
inline void nvic_ipr6_set_pri_24(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_PRI_24) | ((val<<0) & NVIC_IPR6_PRI_24); }
inline uint32_t nvic_ipr6_get_pri_27(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_PRI_27) >> 24 ; }
inline uint32_t nvic_ipr6_get_pri_26(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_PRI_26) >> 16 ; }
inline uint32_t nvic_ipr6_get_pri_25(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_PRI_25) >> 8 ; }
inline uint32_t nvic_ipr6_get_pri_24(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_PRI_24) >> 0 ; }

// NVIC->IPR7 Interrupt Priority Register 7
enum {
	NVIC_IPR7_PRI_31 = ((1UL<<8)-1) << 24, // priority for interrupt n
	NVIC_IPR7_PRI_30 = ((1UL<<8)-1) << 16, // priority for interrupt n
	NVIC_IPR7_PRI_29 = ((1UL<<8)-1) << 8, // priority for interrupt n
	NVIC_IPR7_PRI_28 = ((1UL<<8)-1) << 0, // priority for interrupt n		
};
inline void nvic_ipr7_set_pri_31(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_PRI_31) | ((val<<24) & NVIC_IPR7_PRI_31); }
inline void nvic_ipr7_set_pri_30(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_PRI_30) | ((val<<16) & NVIC_IPR7_PRI_30); }
inline void nvic_ipr7_set_pri_29(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_PRI_29) | ((val<<8) & NVIC_IPR7_PRI_29); }
inline void nvic_ipr7_set_pri_28(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_PRI_28) | ((val<<0) & NVIC_IPR7_PRI_28); }
inline uint32_t nvic_ipr7_get_pri_31(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_PRI_31) >> 24 ; }
inline uint32_t nvic_ipr7_get_pri_30(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_PRI_30) >> 16 ; }
inline uint32_t nvic_ipr7_get_pri_29(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_PRI_29) >> 8 ; }
inline uint32_t nvic_ipr7_get_pri_28(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_PRI_28) >> 0 ; }

/* Nested vectored interrupt controller */
struct NVIC_STIR_Type {
	__IO uint16_t STIR; // @0 Software trigger interrupt register
};

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL<<9)-1) << 0, // Software generated interrupt ID		
};
inline void nvic_stir_stir_set_intid(struct NVIC_STIR_Type* p, uint32_t val) { p->STIR = (p->STIR & ~NVIC_STIR_STIR_INTID) | ((val<<0) & NVIC_STIR_STIR_INTID); }
inline uint32_t nvic_stir_stir_get_intid(struct NVIC_STIR_Type* p) { return (p->STIR & NVIC_STIR_STIR_INTID) >> 0 ; }

/* Power control */
struct PWR_Type {
	__IO uint16_t CR1; // @0 Power control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 Power control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t CR3; // @8 Power control register 3
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t CR4; // @12 Power control register 4
	 uint8_t RESERVED3[2]; // @14 
	__I uint16_t SR1; // @16 Power status register 1
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t SR2; // @20 Power status register 2
	 uint8_t RESERVED5[2]; // @22 
	__O uint16_t SCR; // @24 Power status clear register
	 uint8_t RESERVED6[6]; // @26 
	__IO uint16_t PUCRA; // @32 Power Port A pull-up control register
	 uint8_t RESERVED7[2]; // @34 
	__IO uint16_t PDCRA; // @36 Power Port A pull-down control register
	 uint8_t RESERVED8[2]; // @38 
	__IO uint16_t PUCRB; // @40 Power Port B pull-up control register
	 uint8_t RESERVED9[2]; // @42 
	__IO uint16_t PDCRB; // @44 Power Port B pull-down control register
	 uint8_t RESERVED10[2]; // @46 
	__IO uint16_t PUCRC; // @48 Power Port C pull-up control register
	 uint8_t RESERVED11[2]; // @50 
	__IO uint16_t PDCRC; // @52 Power Port C pull-down control register
	 uint8_t RESERVED12[2]; // @54 
	__IO uint8_t PUCRD; // @56 Power Port D pull-up control register
	 uint8_t RESERVED13[3]; // @57 
	__IO uint16_t PDCRD; // @60 Power Port D pull-down control register
	 uint8_t RESERVED14[10]; // @62 
	__IO uint8_t PUCRF; // @72 Power Port F pull-up control register
	 uint8_t RESERVED15[3]; // @73 
	__IO uint8_t PDCRF; // @76 Power Port F pull-down control register
};

// PWR->CR1 Power control register 1
enum {
	PWR_CR1_LPR = 1UL<<14, // Low-power run
	PWR_CR1_VOS = ((1UL<<2)-1) << 9, // Voltage scaling range selection
	PWR_CR1_DBP = 1UL<<8, // Disable backup domain write protection
	PWR_CR1_FPD_LPSLP = 1UL<<5, // Flash memory powered down during Low-power sleep mode
	PWR_CR1_FPD_LPRUN = 1UL<<4, // Flash memory powered down during Low-power run mode
	PWR_CR1_FPD_STOP = 1UL<<3, // Flash memory powered down during Stop mode
	PWR_CR1_LPMS = ((1UL<<3)-1) << 0, // Low-power mode selection		
};
inline void pwr_cr1_set_vos(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_VOS) | ((val<<9) & PWR_CR1_VOS); }
inline void pwr_cr1_set_lpms(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_LPMS) | ((val<<0) & PWR_CR1_LPMS); }
inline uint32_t pwr_cr1_get_vos(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_VOS) >> 9 ; }
inline uint32_t pwr_cr1_get_lpms(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_LPMS) >> 0 ; }

// PWR->CR2 Power control register 2
enum {
	PWR_CR2_PVDRT = ((1UL<<3)-1) << 4, // Power voltage detector rising threshold selection
	PWR_CR2_PVDFT = ((1UL<<3)-1) << 1, // Power voltage detector falling threshold selection
	PWR_CR2_PVDE = 1UL<<0, // Power voltage detector enable		
};
inline void pwr_cr2_set_pvdrt(struct PWR_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~PWR_CR2_PVDRT) | ((val<<4) & PWR_CR2_PVDRT); }
inline void pwr_cr2_set_pvdft(struct PWR_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~PWR_CR2_PVDFT) | ((val<<1) & PWR_CR2_PVDFT); }
inline uint32_t pwr_cr2_get_pvdrt(struct PWR_Type* p) { return (p->CR2 & PWR_CR2_PVDRT) >> 4 ; }
inline uint32_t pwr_cr2_get_pvdft(struct PWR_Type* p) { return (p->CR2 & PWR_CR2_PVDFT) >> 1 ; }

// PWR->CR3 Power control register 3
enum {
	PWR_CR3_EIWUL = 1UL<<15, // Enable internal wakeup line
	PWR_CR3_APC = 1UL<<10, // Apply pull-up and pull-down configuration
	PWR_CR3_ULPEN = 1UL<<9, // Enable the periodical sampling mode for PDR detection
	PWR_CR3_RRS = 1UL<<8, // SRAM retention in Standby mode
	PWR_CR3_EWUP6 = 1UL<<5, // Enable WKUP6 wakeup pin
	PWR_CR3_EWUP5 = 1UL<<4, // Enable WKUP5 wakeup pin
	PWR_CR3_EWUP4 = 1UL<<3, // Enable Wakeup pin WKUP4
	PWR_CR3_EWUP2 = 1UL<<1, // Enable Wakeup pin WKUP2
	PWR_CR3_EWUP1 = 1UL<<0, // Enable Wakeup pin WKUP1		
};

// PWR->CR4 Power control register 4
enum {
	PWR_CR4_VBRS = 1UL<<9, // VBAT battery charging resistor selection
	PWR_CR4_VBE = 1UL<<8, // VBAT battery charging enable
	PWR_CR4_WP6 = 1UL<<5, // WKUP6 wakeup pin polarity
	PWR_CR4_WP5 = 1UL<<4, // Wakeup pin WKUP5 polarity
	PWR_CR4_WP4 = 1UL<<3, // Wakeup pin WKUP4 polarity
	PWR_CR4_WP2 = 1UL<<1, // Wakeup pin WKUP2 polarity
	PWR_CR4_WP1 = 1UL<<0, // Wakeup pin WKUP1 polarity		
};

// PWR->SR1 Power status register 1
enum {
	PWR_SR1_WUFI = 1UL<<15, // Wakeup flag internal
	PWR_SR1_SBF = 1UL<<8, // Standby flag
	PWR_SR1_WUF6 = 1UL<<5, // Wakeup flag 6
	PWR_SR1_WUF5 = 1UL<<4, // Wakeup flag 5
	PWR_SR1_WUF4 = 1UL<<3, // Wakeup flag 4
	PWR_SR1_WUF2 = 1UL<<1, // Wakeup flag 2
	PWR_SR1_WUF1 = 1UL<<0, // Wakeup flag 1		
};

// PWR->SR2 Power status register 2
enum {
	PWR_SR2_PVDO = 1UL<<11, // Power voltage detector output
	PWR_SR2_VOSF = 1UL<<10, // Voltage scaling flag
	PWR_SR2_REGLPF = 1UL<<9, // Low-power regulator flag
	PWR_SR2_REGLPS = 1UL<<8, // Low-power regulator started
	PWR_SR2_FLASH_RDY = 1UL<<7, // Flash ready flag		
};

// PWR->SCR Power status clear register
enum {
	PWR_SCR_CSBF = 1UL<<8, // Clear standby flag
	PWR_SCR_CWUF6 = 1UL<<5, // Clear wakeup flag 6
	PWR_SCR_CWUF5 = 1UL<<4, // Clear wakeup flag 5
	PWR_SCR_CWUF4 = 1UL<<3, // Clear wakeup flag 4
	PWR_SCR_CWUF2 = 1UL<<1, // Clear wakeup flag 2
	PWR_SCR_CWUF1 = 1UL<<0, // Clear wakeup flag 1		
};

// PWR->PUCRC Power Port C pull-up control register
enum {
	PWR_PUCRC_PU15 = 1UL<<15, // Port C pull-up bit y (y=0..15)
	PWR_PUCRC_PU14 = 1UL<<14, // Port C pull-up bit y (y=0..15)
	PWR_PUCRC_PU13 = 1UL<<13, // Port C pull-up bit y (y=0..15)
	PWR_PUCRC_PU7 = 1UL<<7, // Port C pull-up bit y (y=0..15)
	PWR_PUCRC_PU6 = 1UL<<6, // Port C pull-up bit y (y=0..15)		
};

// PWR->PUCRD Power Port D pull-up control register
enum {
	PWR_PUCRD_PUX  = ((1UL<<4)-1) << 0, // Merged Port D pull-up bit y (y=0..15)		
};
inline void pwr_pucrd_set_pux (struct PWR_Type* p, uint32_t val) { p->PUCRD = (p->PUCRD & ~PWR_PUCRD_PUX ) | ((val<<0) & PWR_PUCRD_PUX ); }
inline uint32_t pwr_pucrd_get_pux (struct PWR_Type* p) { return (p->PUCRD & PWR_PUCRD_PUX ) >> 0 ; }

// PWR->PDCRD Power Port D pull-down control register
enum {
	PWR_PDCRD_PD9 = 1UL<<9, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD8 = 1UL<<8, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD6 = 1UL<<6, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD5 = 1UL<<5, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD4 = 1UL<<4, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD3 = 1UL<<3, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD2 = 1UL<<2, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD1 = 1UL<<1, // Port D pull-down bit y (y=0..15)
	PWR_PDCRD_PD0 = 1UL<<0, // Port D pull-down bit y (y=0..15)		
};

// PWR->PUCRF Power Port F pull-up control register
enum {
	PWR_PUCRF_PUX  = ((1UL<<3)-1) << 0, // Merged Port F pull-up bit y (y=0..15)		
};
inline void pwr_pucrf_set_pux (struct PWR_Type* p, uint32_t val) { p->PUCRF = (p->PUCRF & ~PWR_PUCRF_PUX ) | ((val<<0) & PWR_PUCRF_PUX ); }
inline uint32_t pwr_pucrf_get_pux (struct PWR_Type* p) { return (p->PUCRF & PWR_PUCRF_PUX ) >> 0 ; }

// PWR->PDCRF Power Port F pull-down control register
enum {
	PWR_PDCRF_PDX  = ((1UL<<3)-1) << 0, // Merged Port F pull-down bit y (y=0..15)		
};
inline void pwr_pdcrf_set_pdx (struct PWR_Type* p, uint32_t val) { p->PDCRF = (p->PDCRF & ~PWR_PDCRF_PDX ) | ((val<<0) & PWR_PDCRF_PDX ); }
inline uint32_t pwr_pdcrf_get_pdx (struct PWR_Type* p) { return (p->PDCRF & PWR_PDCRF_PDX ) >> 0 ; }

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR; // @0 Clock control register
	__IO uint16_t ICSCR; // @4 Internal clock sources calibration register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t CFGR; // @8 Clock configuration register
	__IO uint32_t PLLSYSCFGR; // @12 PLL configuration register
	 uint8_t RESERVED1[8]; // @16 
	__IO uint8_t CIER; // @24 Clock interrupt enable register
	 uint8_t RESERVED2[3]; // @25 
	__I uint16_t CIFR; // @28 Clock interrupt flag register
	 uint8_t RESERVED3[2]; // @30 
	__O uint16_t CICR; // @32 Clock interrupt clear register
	 uint8_t RESERVED4[2]; // @34 
	__IO uint8_t IOPRSTR; // @36 GPIO reset register
	 uint8_t RESERVED5[3]; // @37 
	__IO uint16_t AHBRSTR; // @40 AHB peripheral reset register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint32_t APBRSTR1; // @44 APB peripheral reset register 1
	__IO uint32_t APBRSTR2; // @48 APB peripheral reset register 2
	__IO uint8_t IOPENR; // @52 GPIO clock enable register
	 uint8_t RESERVED7[3]; // @53 
	__IO uint16_t AHBENR; // @56 AHB peripheral clock enable register
	 uint8_t RESERVED8[2]; // @58 
	__IO uint32_t APBENR1; // @60 APB peripheral clock enable register 1
	__IO uint32_t APBENR2; // @64 APB peripheral clock enable register 2
	__IO uint8_t IOPSMENR; // @68 GPIO in Sleep mode clock enable register
	 uint8_t RESERVED9[3]; // @69 
	__IO uint16_t AHBSMENR; // @72 AHB peripheral clock enable in Sleep mode register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint32_t APBSMENR1; // @76 APB peripheral clock enable in Sleep mode register 1
	__IO uint32_t APBSMENR2; // @80 APB peripheral clock enable in Sleep mode register 2
	__IO uint32_t CCIPR; // @84 Peripherals independent clock configuration register
	 uint8_t RESERVED11[4]; // @88 
	__IO uint32_t BDCR; // @92 RTC domain control register
	__IO uint32_t CSR; // @96 Control/status register
};

// RCC->CR Clock control register
enum {
	RCC_CR_PLLRDY = 1UL<<25, // PLL clock ready flag
	RCC_CR_PLLON = 1UL<<24, // PLL enable
	RCC_CR_CSSON = 1UL<<19, // Clock security system enable
	RCC_CR_HSEBYP = 1UL<<18, // HSE crystal oscillator bypass
	RCC_CR_HSERDY = 1UL<<17, // HSE clock ready flag
	RCC_CR_HSEON = 1UL<<16, // HSE clock enable
	RCC_CR_HSIDIV = ((1UL<<3)-1) << 11, // HSI16 clock division factor
	RCC_CR_HSIRDY = 1UL<<10, // HSI16 clock ready flag
	RCC_CR_HSIKERON = 1UL<<9, // HSI16 always enable for peripheral kernels
	RCC_CR_HSION = 1UL<<8, // HSI16 clock enable		
};
inline void rcc_cr_set_hsidiv(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_HSIDIV) | ((val<<11) & RCC_CR_HSIDIV); }
inline uint32_t rcc_cr_get_hsidiv(struct RCC_Type* p) { return (p->CR & RCC_CR_HSIDIV) >> 11 ; }

// RCC->ICSCR Internal clock sources calibration register
enum {
	RCC_ICSCR_HSITRIM = ((1UL<<7)-1) << 8, // HSI16 clock trimming
	RCC_ICSCR_HSICAL = ((1UL<<8)-1) << 0, // HSI16 clock calibration		
};
inline void rcc_icscr_set_hsitrim(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSITRIM) | ((val<<8) & RCC_ICSCR_HSITRIM); }
inline void rcc_icscr_set_hsical(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSICAL) | ((val<<0) & RCC_ICSCR_HSICAL); }
inline uint32_t rcc_icscr_get_hsitrim(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSITRIM) >> 8 ; }
inline uint32_t rcc_icscr_get_hsical(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSICAL) >> 0 ; }

// RCC->CFGR Clock configuration register
enum {
	RCC_CFGR_MCOPRE = ((1UL<<3)-1) << 28, // Microcontroller clock output prescaler
	RCC_CFGR_MCOSEL = ((1UL<<3)-1) << 24, // Microcontroller clock output
	RCC_CFGR_PPRE = ((1UL<<3)-1) << 12, // APB prescaler
	RCC_CFGR_HPRE = ((1UL<<4)-1) << 8, // AHB prescaler
	RCC_CFGR_SWS = ((1UL<<3)-1) << 3, // System clock switch status
	RCC_CFGR_SW = ((1UL<<3)-1) << 0, // System clock switch		
};
inline void rcc_cfgr_set_mcopre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCOPRE) | ((val<<28) & RCC_CFGR_MCOPRE); }
inline void rcc_cfgr_set_mcosel(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCOSEL) | ((val<<24) & RCC_CFGR_MCOSEL); }
inline void rcc_cfgr_set_ppre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE) | ((val<<12) & RCC_CFGR_PPRE); }
inline void rcc_cfgr_set_hpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_HPRE) | ((val<<8) & RCC_CFGR_HPRE); }
inline void rcc_cfgr_set_sws(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val<<3) & RCC_CFGR_SWS); }
inline void rcc_cfgr_set_sw(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val<<0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mcopre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCOPRE) >> 28 ; }
inline uint32_t rcc_cfgr_get_mcosel(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCOSEL) >> 24 ; }
inline uint32_t rcc_cfgr_get_ppre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE) >> 12 ; }
inline uint32_t rcc_cfgr_get_hpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_HPRE) >> 8 ; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SWS) >> 3 ; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SW) >> 0 ; }

// RCC->PLLSYSCFGR PLL configuration register
enum {
	RCC_PLLSYSCFGR_PLLR = ((1UL<<3)-1) << 29, // PLL VCO division factor R for PLLRCLK clock output
	RCC_PLLSYSCFGR_PLLREN = 1UL<<28, // PLLRCLK clock output enable
	RCC_PLLSYSCFGR_PLLQ = ((1UL<<3)-1) << 25, // PLL VCO division factor Q for PLLQCLK clock output
	RCC_PLLSYSCFGR_PLLQEN = 1UL<<24, // PLLQCLK clock output enable
	RCC_PLLSYSCFGR_PLLP = ((1UL<<5)-1) << 17, // PLL VCO division factor P for PLLPCLK clock output
	RCC_PLLSYSCFGR_PLLPEN = 1UL<<16, // PLLPCLK clock output enable
	RCC_PLLSYSCFGR_PLLN = ((1UL<<7)-1) << 8, // PLL frequency multiplication factor N
	RCC_PLLSYSCFGR_PLLM = ((1UL<<3)-1) << 4, // Division factor M of the PLL input clock divider
	RCC_PLLSYSCFGR_PLLSRC = ((1UL<<2)-1) << 0, // PLL input clock source		
};
inline void rcc_pllsyscfgr_set_pllr(struct RCC_Type* p, uint32_t val) { p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLR) | ((val<<29) & RCC_PLLSYSCFGR_PLLR); }
inline void rcc_pllsyscfgr_set_pllq(struct RCC_Type* p, uint32_t val) { p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLQ) | ((val<<25) & RCC_PLLSYSCFGR_PLLQ); }
inline void rcc_pllsyscfgr_set_pllp(struct RCC_Type* p, uint32_t val) { p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLP) | ((val<<17) & RCC_PLLSYSCFGR_PLLP); }
inline void rcc_pllsyscfgr_set_plln(struct RCC_Type* p, uint32_t val) { p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLN) | ((val<<8) & RCC_PLLSYSCFGR_PLLN); }
inline void rcc_pllsyscfgr_set_pllm(struct RCC_Type* p, uint32_t val) { p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLM) | ((val<<4) & RCC_PLLSYSCFGR_PLLM); }
inline void rcc_pllsyscfgr_set_pllsrc(struct RCC_Type* p, uint32_t val) { p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSRC) | ((val<<0) & RCC_PLLSYSCFGR_PLLSRC); }
inline uint32_t rcc_pllsyscfgr_get_pllr(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLR) >> 29 ; }
inline uint32_t rcc_pllsyscfgr_get_pllq(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLQ) >> 25 ; }
inline uint32_t rcc_pllsyscfgr_get_pllp(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLP) >> 17 ; }
inline uint32_t rcc_pllsyscfgr_get_plln(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLN) >> 8 ; }
inline uint32_t rcc_pllsyscfgr_get_pllm(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLM) >> 4 ; }
inline uint32_t rcc_pllsyscfgr_get_pllsrc(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSRC) >> 0 ; }

// RCC->CIER Clock interrupt enable register
enum {
	RCC_CIER_PLLSYSRDYIE = 1UL<<5, // PLL ready interrupt enable
	RCC_CIER_HSERDYIE = 1UL<<4, // HSE ready interrupt enable
	RCC_CIER_HSIRDYIE = 1UL<<3, // HSI ready interrupt enable
	RCC_CIER_LSERDYIE = 1UL<<1, // LSE ready interrupt enable
	RCC_CIER_LSIRDYIE = 1UL<<0, // LSI ready interrupt enable		
};

// RCC->CIFR Clock interrupt flag register
enum {
	RCC_CIFR_LSECSSF = 1UL<<9, // LSE Clock security system interrupt flag
	RCC_CIFR_CSSF = 1UL<<8, // Clock security system interrupt flag
	RCC_CIFR_PLLSYSRDYF = 1UL<<5, // PLL ready interrupt flag
	RCC_CIFR_HSERDYF = 1UL<<4, // HSE ready interrupt flag
	RCC_CIFR_HSIRDYF = 1UL<<3, // HSI ready interrupt flag
	RCC_CIFR_LSERDYF = 1UL<<1, // LSE ready interrupt flag
	RCC_CIFR_LSIRDYF = 1UL<<0, // LSI ready interrupt flag		
};

// RCC->CICR Clock interrupt clear register
enum {
	RCC_CICR_LSECSSC = 1UL<<9, // LSE Clock security system interrupt clear
	RCC_CICR_CSSC = 1UL<<8, // Clock security system interrupt clear
	RCC_CICR_PLLSYSRDYC = 1UL<<5, // PLL ready interrupt clear
	RCC_CICR_HSERDYC = 1UL<<4, // HSE ready interrupt clear
	RCC_CICR_HSIRDYC = 1UL<<3, // HSI ready interrupt clear
	RCC_CICR_LSERDYC = 1UL<<1, // LSE ready interrupt clear
	RCC_CICR_LSIRDYC = 1UL<<0, // LSI ready interrupt clear		
};

// RCC->IOPRSTR GPIO reset register
enum {
	RCC_IOPRSTR_IOPFRST = 1UL<<5, // I/O port F reset
	RCC_IOPRSTR_IOPDRST = 1UL<<3, // I/O port D reset
	RCC_IOPRSTR_IOPCRST = 1UL<<2, // I/O port C reset
	RCC_IOPRSTR_IOPBRST = 1UL<<1, // I/O port B reset
	RCC_IOPRSTR_IOPARST = 1UL<<0, // I/O port A reset		
};

// RCC->AHBRSTR AHB peripheral reset register
enum {
	RCC_AHBRSTR_CRCRST = 1UL<<12, // CRC reset
	RCC_AHBRSTR_FLASHRST = 1UL<<8, // FLITF reset
	RCC_AHBRSTR_DMARST = 1UL<<0, // DMA1 reset		
};

// RCC->APBRSTR1 APB peripheral reset register 1
enum {
	RCC_APBRSTR1_LPTIM1RST = 1UL<<31, // Low Power Timer 1 reset
	RCC_APBRSTR1_LPTIM2RST = 1UL<<30, // Low Power Timer 2 reset
	RCC_APBRSTR1_PWRRST = 1UL<<28, // Power interface reset
	RCC_APBRSTR1_DBGRST = 1UL<<27, // Debug support reset
	RCC_APBRSTR1_I2C2RST = 1UL<<22, // I2C2 reset
	RCC_APBRSTR1_I2C1RST = 1UL<<21, // I2C1 reset
	RCC_APBRSTR1_LPUART1RST = 1UL<<20, // LPUART1 reset
	RCC_APBRSTR1_USART2RST = 1UL<<17, // USART2 reset
	RCC_APBRSTR1_SPI2RST = 1UL<<14, // SPI2 reset
	RCC_APBRSTR1_TIM3RST = 1UL<<1, // TIM3 timer reset
	RCC_APBRSTR1_TIM2RST = 1UL<<0, // TIM2 timer reset		
};

// RCC->APBRSTR2 APB peripheral reset register 2
enum {
	RCC_APBRSTR2_ADCRST = 1UL<<20, // ADC reset
	RCC_APBRSTR2_TIM17RST = 1UL<<18, // TIM17 timer reset
	RCC_APBRSTR2_TIM16RST = 1UL<<17, // TIM16 timer reset
	RCC_APBRSTR2_TIM14RST = 1UL<<15, // TIM14 timer reset
	RCC_APBRSTR2_USART1RST = 1UL<<14, // USART1 reset
	RCC_APBRSTR2_SPI1RST = 1UL<<12, // SPI1 reset
	RCC_APBRSTR2_TIM1RST = 1UL<<11, // TIM1 timer reset
	RCC_APBRSTR2_SYSCFGRST = 1UL<<0, // SYSCFG, COMP and VREFBUF reset		
};

// RCC->IOPENR GPIO clock enable register
enum {
	RCC_IOPENR_IOPFEN = 1UL<<5, // I/O port F clock enable
	RCC_IOPENR_IOPDEN = 1UL<<3, // I/O port D clock enable
	RCC_IOPENR_IOPCEN = 1UL<<2, // I/O port C clock enable
	RCC_IOPENR_IOPBEN = 1UL<<1, // I/O port B clock enable
	RCC_IOPENR_IOPAEN = 1UL<<0, // I/O port A clock enable		
};

// RCC->AHBENR AHB peripheral clock enable register
enum {
	RCC_AHBENR_CRCEN = 1UL<<12, // CRC clock enable
	RCC_AHBENR_FLASHEN = 1UL<<8, // Flash memory interface clock enable
	RCC_AHBENR_DMAEN = 1UL<<0, // DMA clock enable		
};

// RCC->APBENR1 APB peripheral clock enable register 1
enum {
	RCC_APBENR1_LPTIM1EN = 1UL<<31, // LPTIM1 clock enable
	RCC_APBENR1_LPTIM2EN = 1UL<<30, // LPTIM2 clock enable
	RCC_APBENR1_PWREN = 1UL<<28, // Power interface clock enable
	RCC_APBENR1_DBGEN = 1UL<<27, // Debug support clock enable
	RCC_APBENR1_I2C2EN = 1UL<<22, // I2C2 clock enable
	RCC_APBENR1_I2C1EN = 1UL<<21, // I2C1 clock enable
	RCC_APBENR1_LPUART1EN = 1UL<<20, // LPUART1 clock enable
	RCC_APBENR1_USART2EN = 1UL<<17, // USART2 clock enable
	RCC_APBENR1_SPI2EN = 1UL<<14, // SPI2 clock enable
	RCC_APBENR1_WWDGEN = 1UL<<11, // WWDG clock enable
	RCC_APBENR1_RTCAPBEN = 1UL<<10, // RTC APB clock enable
	RCC_APBENR1_TIM3EN = 1UL<<1, // TIM3 timer clock enable
	RCC_APBENR1_TIM2EN = 1UL<<0, // TIM2 timer clock enable		
};

// RCC->APBENR2 APB peripheral clock enable register 2
enum {
	RCC_APBENR2_ADCEN = 1UL<<20, // ADC clock enable
	RCC_APBENR2_TIM17EN = 1UL<<18, // TIM16 timer clock enable
	RCC_APBENR2_TIM16EN = 1UL<<17, // TIM16 timer clock enable
	RCC_APBENR2_TIM14EN = 1UL<<15, // TIM14 timer clock enable
	RCC_APBENR2_USART1EN = 1UL<<14, // USART1 clock enable
	RCC_APBENR2_SPI1EN = 1UL<<12, // SPI1 clock enable
	RCC_APBENR2_TIM1EN = 1UL<<11, // TIM1 timer clock enable
	RCC_APBENR2_SYSCFGEN = 1UL<<0, // SYSCFG, COMP and VREFBUF clock enable		
};

// RCC->IOPSMENR GPIO in Sleep mode clock enable register
enum {
	RCC_IOPSMENR_IOPFSMEN = 1UL<<5, // I/O port F clock enable during Sleep mode
	RCC_IOPSMENR_IOPDSMEN = 1UL<<3, // I/O port D clock enable during Sleep mode
	RCC_IOPSMENR_IOPCSMEN = 1UL<<2, // I/O port C clock enable during Sleep mode
	RCC_IOPSMENR_IOPBSMEN = 1UL<<1, // I/O port B clock enable during Sleep mode
	RCC_IOPSMENR_IOPASMEN = 1UL<<0, // I/O port A clock enable during Sleep mode		
};

// RCC->AHBSMENR AHB peripheral clock enable in Sleep mode register
enum {
	RCC_AHBSMENR_CRCSMEN = 1UL<<12, // CRC clock enable during Sleep mode
	RCC_AHBSMENR_SRAMSMEN = 1UL<<9, // SRAM clock enable during Sleep mode
	RCC_AHBSMENR_FLASHSMEN = 1UL<<8, // Flash memory interface clock enable during Sleep mode
	RCC_AHBSMENR_DMASMEN = 1UL<<0, // DMA clock enable during Sleep mode		
};

// RCC->APBSMENR1 APB peripheral clock enable in Sleep mode register 1
enum {
	RCC_APBSMENR1_LPTIM1SMEN = 1UL<<31, // Low Power Timer 1 clock enable during Sleep mode
	RCC_APBSMENR1_LPTIM2SMEN = 1UL<<30, // Low Power Timer 2 clock enable during Sleep mode
	RCC_APBSMENR1_PWRSMEN = 1UL<<28, // Power interface clock enable during Sleep mode
	RCC_APBSMENR1_DBGSMEN = 1UL<<27, // Debug support clock enable during Sleep mode
	RCC_APBSMENR1_I2C2SMEN = 1UL<<22, // I2C2 clock enable during Sleep mode
	RCC_APBSMENR1_I2C1SMEN = 1UL<<21, // I2C1 clock enable during Sleep mode
	RCC_APBSMENR1_LPUART1SMEN = 1UL<<20, // LPUART1 clock enable during Sleep mode
	RCC_APBSMENR1_USART2SMEN = 1UL<<17, // USART2 clock enable during Sleep mode
	RCC_APBSMENR1_SPI2SMEN = 1UL<<14, // SPI2 clock enable during Sleep mode
	RCC_APBSMENR1_WWDGSMEN = 1UL<<11, // WWDG clock enable during Sleep mode
	RCC_APBSMENR1_RTCAPBSMEN = 1UL<<10, // RTC APB clock enable during Sleep mode
	RCC_APBSMENR1_TIM3SMEN = 1UL<<1, // TIM3 timer clock enable during Sleep mode
	RCC_APBSMENR1_TIM2SMEN = 1UL<<0, // TIM2 timer clock enable during Sleep mode		
};

// RCC->APBSMENR2 APB peripheral clock enable in Sleep mode register 2
enum {
	RCC_APBSMENR2_ADCSMEN = 1UL<<20, // ADC clock enable during Sleep mode
	RCC_APBSMENR2_TIM17SMEN = 1UL<<18, // TIM16 timer clock enable during Sleep mode
	RCC_APBSMENR2_TIM16SMEN = 1UL<<17, // TIM16 timer clock enable during Sleep mode
	RCC_APBSMENR2_TIM14SMEN = 1UL<<15, // TIM14 timer clock enable during Sleep mode
	RCC_APBSMENR2_USART1SMEN = 1UL<<14, // USART1 clock enable during Sleep mode
	RCC_APBSMENR2_SPI1SMEN = 1UL<<12, // SPI1 clock enable during Sleep mode
	RCC_APBSMENR2_TIM1SMEN = 1UL<<11, // TIM1 timer clock enable during Sleep mode
	RCC_APBSMENR2_SYSCFGSMEN = 1UL<<0, // SYSCFG, COMP and VREFBUF clock enable during Sleep mode		
};

// RCC->CCIPR Peripherals independent clock configuration register
enum {
	RCC_CCIPR_ADCSEL = ((1UL<<2)-1) << 30, // ADCs clock source selection
	RCC_CCIPR_RNGDIV = ((1UL<<2)-1) << 28, // Division factor of RNG clock divider
	RCC_CCIPR_RNGSEL = ((1UL<<2)-1) << 26, // RNG clock source selection
	RCC_CCIPR_TIM1SEL = 1UL<<22, // TIM1 clock source selection
	RCC_CCIPR_LPTIM2SEL = ((1UL<<2)-1) << 20, // LPTIM2 clock source selection
	RCC_CCIPR_LPTIM1SEL = ((1UL<<2)-1) << 18, // LPTIM1 clock source selection
	RCC_CCIPR_I2S2SEL = ((1UL<<2)-1) << 14, // I2S1 clock source selection
	RCC_CCIPR_I2C1SEL = ((1UL<<2)-1) << 12, // I2C1 clock source selection
	RCC_CCIPR_LPUART1SEL = ((1UL<<2)-1) << 10, // LPUART1 clock source selection
	RCC_CCIPR_USART1SEL = ((1UL<<2)-1) << 0, // USART1 clock source selection		
};
inline void rcc_ccipr_set_adcsel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_ADCSEL) | ((val<<30) & RCC_CCIPR_ADCSEL); }
inline void rcc_ccipr_set_rngdiv(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_RNGDIV) | ((val<<28) & RCC_CCIPR_RNGDIV); }
inline void rcc_ccipr_set_rngsel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_RNGSEL) | ((val<<26) & RCC_CCIPR_RNGSEL); }
inline void rcc_ccipr_set_lptim2sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPTIM2SEL) | ((val<<20) & RCC_CCIPR_LPTIM2SEL); }
inline void rcc_ccipr_set_lptim1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPTIM1SEL) | ((val<<18) & RCC_CCIPR_LPTIM1SEL); }
inline void rcc_ccipr_set_i2s2sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2S2SEL) | ((val<<14) & RCC_CCIPR_I2S2SEL); }
inline void rcc_ccipr_set_i2c1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C1SEL) | ((val<<12) & RCC_CCIPR_I2C1SEL); }
inline void rcc_ccipr_set_lpuart1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPUART1SEL) | ((val<<10) & RCC_CCIPR_LPUART1SEL); }
inline void rcc_ccipr_set_usart1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART1SEL) | ((val<<0) & RCC_CCIPR_USART1SEL); }
inline uint32_t rcc_ccipr_get_adcsel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_ADCSEL) >> 30 ; }
inline uint32_t rcc_ccipr_get_rngdiv(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_RNGDIV) >> 28 ; }
inline uint32_t rcc_ccipr_get_rngsel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_RNGSEL) >> 26 ; }
inline uint32_t rcc_ccipr_get_lptim2sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_LPTIM2SEL) >> 20 ; }
inline uint32_t rcc_ccipr_get_lptim1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_LPTIM1SEL) >> 18 ; }
inline uint32_t rcc_ccipr_get_i2s2sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_I2S2SEL) >> 14 ; }
inline uint32_t rcc_ccipr_get_i2c1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_I2C1SEL) >> 12 ; }
inline uint32_t rcc_ccipr_get_lpuart1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_LPUART1SEL) >> 10 ; }
inline uint32_t rcc_ccipr_get_usart1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_USART1SEL) >> 0 ; }

// RCC->BDCR RTC domain control register
enum {
	RCC_BDCR_LSCOSEL = 1UL<<25, // Low-speed clock output selection
	RCC_BDCR_LSCOEN = 1UL<<24, // Low-speed clock output (LSCO) enable
	RCC_BDCR_BDRST = 1UL<<16, // RTC domain software reset
	RCC_BDCR_RTCEN = 1UL<<15, // RTC clock enable
	RCC_BDCR_RTCSEL = ((1UL<<2)-1) << 8, // RTC clock source selection
	RCC_BDCR_LSECSSD = 1UL<<6, // CSS on LSE failure Detection
	RCC_BDCR_LSECSSON = 1UL<<5, // CSS on LSE enable
	RCC_BDCR_LSEDRV = ((1UL<<2)-1) << 3, // LSE oscillator drive capability
	RCC_BDCR_LSEBYP = 1UL<<2, // LSE oscillator bypass
	RCC_BDCR_LSERDY = 1UL<<1, // LSE oscillator ready
	RCC_BDCR_LSEON = 1UL<<0, // LSE oscillator enable		
};
inline void rcc_bdcr_set_rtcsel(struct RCC_Type* p, uint32_t val) { p->BDCR = (p->BDCR & ~RCC_BDCR_RTCSEL) | ((val<<8) & RCC_BDCR_RTCSEL); }
inline void rcc_bdcr_set_lsedrv(struct RCC_Type* p, uint32_t val) { p->BDCR = (p->BDCR & ~RCC_BDCR_LSEDRV) | ((val<<3) & RCC_BDCR_LSEDRV); }
inline uint32_t rcc_bdcr_get_rtcsel(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_RTCSEL) >> 8 ; }
inline uint32_t rcc_bdcr_get_lsedrv(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_LSEDRV) >> 3 ; }

// RCC->CSR Control/status register
enum {
	RCC_CSR_LPWRRSTF = 1UL<<31, // Low-power reset flag
	RCC_CSR_WWDGRSTF = 1UL<<30, // Window watchdog reset flag
	RCC_CSR_IWDGRSTF = 1UL<<29, // Independent window watchdog reset flag
	RCC_CSR_SFTRSTF = 1UL<<28, // Software reset flag
	RCC_CSR_PWRRSTF = 1UL<<27, // BOR or POR/PDR flag
	RCC_CSR_PINRSTF = 1UL<<26, // Pin reset flag
	RCC_CSR_OBLRSTF = 1UL<<25, // Option byte loader reset flag
	RCC_CSR_RMVF = 1UL<<23, // Remove reset flags
	RCC_CSR_LSIRDY = 1UL<<1, // LSI oscillator ready
	RCC_CSR_LSION = 1UL<<0, // LSI oscillator enable		
};

/* Real-time clock */
struct RTC_Type {
	__IO uint32_t TR; // @0 time register
	__IO uint32_t DR; // @4 date register
	__I uint16_t SSR; // @8 sub second register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t ICSR; // @12 initialization and status register
	__IO uint32_t PRER; // @16 prescaler register
	__IO uint16_t WUTR; // @20 wakeup timer register
	 uint8_t RESERVED1[2]; // @22 
	__IO uint32_t CR; // @24 control register
	 uint8_t RESERVED2[8]; // @28 
	__O uint8_t WPR; // @36 write protection register
	 uint8_t RESERVED3[3]; // @37 
	__IO uint16_t CALR; // @40 calibration register
	 uint8_t RESERVED4[2]; // @42 
	__O uint32_t SHIFTR; // @44 shift control register
	__I uint32_t TSTR; // @48 time stamp time register
	__I uint16_t TSDR; // @52 time stamp date register
	 uint8_t RESERVED5[2]; // @54 
	__I uint16_t TSSSR; // @56 timestamp sub second register
	 uint8_t RESERVED6[6]; // @58 
	__IO uint32_t ALRMAR; // @64 alarm A register
	__IO uint32_t ALRMASSR; // @68 alarm A sub second register
	__IO uint32_t ALRMBR; // @72 alarm B register
	__IO uint32_t ALRMBSSR; // @76 alarm B sub second register
	__I uint8_t SR; // @80 status register
	 uint8_t RESERVED7[3]; // @81 
	__I uint8_t MISR; // @84 masked interrupt status register
	 uint8_t RESERVED8[7]; // @85 
	__IO uint8_t SCR; // @92 status clear register
};

// RTC->TR time register
enum {
	RTC_TR_PM = 1UL<<22, // AM/PM notation
	RTC_TR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_tr_set_ht(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HT) | ((val<<20) & RTC_TR_HT); }
inline void rtc_tr_set_hu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HU) | ((val<<16) & RTC_TR_HU); }
inline void rtc_tr_set_mnt(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNT) | ((val<<12) & RTC_TR_MNT); }
inline void rtc_tr_set_mnu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNU) | ((val<<8) & RTC_TR_MNU); }
inline void rtc_tr_set_st(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_ST) | ((val<<4) & RTC_TR_ST); }
inline void rtc_tr_set_su(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_SU) | ((val<<0) & RTC_TR_SU); }
inline uint32_t rtc_tr_get_ht(struct RTC_Type* p) { return (p->TR & RTC_TR_HT) >> 20 ; }
inline uint32_t rtc_tr_get_hu(struct RTC_Type* p) { return (p->TR & RTC_TR_HU) >> 16 ; }
inline uint32_t rtc_tr_get_mnt(struct RTC_Type* p) { return (p->TR & RTC_TR_MNT) >> 12 ; }
inline uint32_t rtc_tr_get_mnu(struct RTC_Type* p) { return (p->TR & RTC_TR_MNU) >> 8 ; }
inline uint32_t rtc_tr_get_st(struct RTC_Type* p) { return (p->TR & RTC_TR_ST) >> 4 ; }
inline uint32_t rtc_tr_get_su(struct RTC_Type* p) { return (p->TR & RTC_TR_SU) >> 0 ; }

// RTC->DR date register
enum {
	RTC_DR_YT = ((1UL<<4)-1) << 20, // Year tens in BCD format
	RTC_DR_YU = ((1UL<<4)-1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_DR_MT = 1UL<<12, // Month tens in BCD format
	RTC_DR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_DR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_DR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline void rtc_dr_set_yt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YT) | ((val<<20) & RTC_DR_YT); }
inline void rtc_dr_set_yu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YU) | ((val<<16) & RTC_DR_YU); }
inline void rtc_dr_set_wdu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_WDU) | ((val<<13) & RTC_DR_WDU); }
inline void rtc_dr_set_mu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_MU) | ((val<<8) & RTC_DR_MU); }
inline void rtc_dr_set_dt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DT) | ((val<<4) & RTC_DR_DT); }
inline void rtc_dr_set_du(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DU) | ((val<<0) & RTC_DR_DU); }
inline uint32_t rtc_dr_get_yt(struct RTC_Type* p) { return (p->DR & RTC_DR_YT) >> 20 ; }
inline uint32_t rtc_dr_get_yu(struct RTC_Type* p) { return (p->DR & RTC_DR_YU) >> 16 ; }
inline uint32_t rtc_dr_get_wdu(struct RTC_Type* p) { return (p->DR & RTC_DR_WDU) >> 13 ; }
inline uint32_t rtc_dr_get_mu(struct RTC_Type* p) { return (p->DR & RTC_DR_MU) >> 8 ; }
inline uint32_t rtc_dr_get_dt(struct RTC_Type* p) { return (p->DR & RTC_DR_DT) >> 4 ; }
inline uint32_t rtc_dr_get_du(struct RTC_Type* p) { return (p->DR & RTC_DR_DU) >> 0 ; }

// RTC->ICSR initialization and status register
enum {
	RTC_ICSR_RECALPF = 1UL<<16, // Recalibration pending Flag
	RTC_ICSR_INIT = 1UL<<7, // Initialization mode
	RTC_ICSR_INITF = 1UL<<6, // Initialization flag
	RTC_ICSR_RSF = 1UL<<5, // Registers synchronization flag
	RTC_ICSR_INITS = 1UL<<4, // Initialization status flag
	RTC_ICSR_SHPF = 1UL<<3, // Shift operation pending
	RTC_ICSR_WUTWF = 1UL<<2, // Wakeup timer write flag
	RTC_ICSR_ALRBWF = 1UL<<1, // Alarm B write flag
	RTC_ICSR_ALRAWF = 1UL<<0, // Alarm A write flag		
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL<<7)-1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL<<15)-1) << 0, // Synchronous prescaler factor		
};
inline void rtc_prer_set_prediv_a(struct RTC_Type* p, uint32_t val) { p->PRER = (p->PRER & ~RTC_PRER_PREDIV_A) | ((val<<16) & RTC_PRER_PREDIV_A); }
inline void rtc_prer_set_prediv_s(struct RTC_Type* p, uint32_t val) { p->PRER = (p->PRER & ~RTC_PRER_PREDIV_S) | ((val<<0) & RTC_PRER_PREDIV_S); }
inline uint32_t rtc_prer_get_prediv_a(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_A) >> 16 ; }
inline uint32_t rtc_prer_get_prediv_s(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_S) >> 0 ; }

// RTC->CR control register
enum {
	RTC_CR_OUT2EN = 1UL<<31, // OUT2EN
	RTC_CR_TAMPALRM_TYPE = 1UL<<30, // TAMPALRM_TYPE
	RTC_CR_TAMPALRM_PU = 1UL<<29, // TAMPALRM_PU
	RTC_CR_TAMPOE = 1UL<<26, // TAMPOE
	RTC_CR_TAMPTS = 1UL<<25, // TAMPTS
	RTC_CR_ITSE = 1UL<<24, // ITSE
	RTC_CR_COE = 1UL<<23, // COE
	RTC_CR_OSEL = ((1UL<<2)-1) << 21, // OSEL
	RTC_CR_POL = 1UL<<20, // POL
	RTC_CR_COSEL = 1UL<<19, // COSEL
	RTC_CR_BKP = 1UL<<18, // BKP
	RTC_CR_SUB1H = 1UL<<17, // SUB1H
	RTC_CR_ADD1H = 1UL<<16, // ADD1H
	RTC_CR_TSIE = 1UL<<15, // TSIE
	RTC_CR_WUTIE = 1UL<<14, // WUTIE
	RTC_CR_ALRBIE = 1UL<<13, // ALRBIE
	RTC_CR_ALRAIE = 1UL<<12, // ALRAIE
	RTC_CR_TSE = 1UL<<11, // TSE
	RTC_CR_WUTE = 1UL<<10, // WUTE
	RTC_CR_ALRBE = 1UL<<9, // ALRBE
	RTC_CR_ALRAE = 1UL<<8, // ALRAE
	RTC_CR_FMT = 1UL<<6, // FMT
	RTC_CR_BYPSHAD = 1UL<<5, // BYPSHAD
	RTC_CR_REFCKON = 1UL<<4, // REFCKON
	RTC_CR_TSEDGE = 1UL<<3, // TSEDGE
	RTC_CR_WUCKSEL = ((1UL<<3)-1) << 0, // WUCKSEL		
};
inline void rtc_cr_set_osel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_OSEL) | ((val<<21) & RTC_CR_OSEL); }
inline void rtc_cr_set_wucksel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_WUCKSEL) | ((val<<0) & RTC_CR_WUCKSEL); }
inline uint32_t rtc_cr_get_osel(struct RTC_Type* p) { return (p->CR & RTC_CR_OSEL) >> 21 ; }
inline uint32_t rtc_cr_get_wucksel(struct RTC_Type* p) { return (p->CR & RTC_CR_WUCKSEL) >> 0 ; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP = 1UL<<15, // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8 = 1UL<<14, // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL<<13, // Use a 16-second calibration cycle period
	RTC_CALR_CALM = ((1UL<<9)-1) << 0, // Calibration minus		
};
inline void rtc_calr_set_calm(struct RTC_Type* p, uint32_t val) { p->CALR = (p->CALR & ~RTC_CALR_CALM) | ((val<<0) & RTC_CALR_CALM); }
inline uint32_t rtc_calr_get_calm(struct RTC_Type* p) { return (p->CALR & RTC_CALR_CALM) >> 0 ; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL<<31, // Add one second
	RTC_SHIFTR_SUBFS = ((1UL<<15)-1) << 0, // Subtract a fraction of a second		
};
inline void rtc_shiftr_set_subfs(struct RTC_Type* p, uint32_t val) { p->SHIFTR = (p->SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val<<0) & RTC_SHIFTR_SUBFS); }
inline uint32_t rtc_shiftr_get_subfs(struct RTC_Type* p) { return (p->SHIFTR & RTC_SHIFTR_SUBFS) >> 0 ; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM = 1UL<<22, // AM/PM notation
	RTC_TSTR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TSTR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TSTR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline uint32_t rtc_tstr_get_ht(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HT) >> 20 ; }
inline uint32_t rtc_tstr_get_hu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HU) >> 16 ; }
inline uint32_t rtc_tstr_get_mnt(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNT) >> 12 ; }
inline uint32_t rtc_tstr_get_mnu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNU) >> 8 ; }
inline uint32_t rtc_tstr_get_st(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_ST) >> 4 ; }
inline uint32_t rtc_tstr_get_su(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_SU) >> 0 ; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_TSDR_MT = 1UL<<12, // Month tens in BCD format
	RTC_TSDR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_TSDR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_TSDR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline uint32_t rtc_tsdr_get_wdu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_WDU) >> 13 ; }
inline uint32_t rtc_tsdr_get_mu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_MU) >> 8 ; }
inline uint32_t rtc_tsdr_get_dt(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DT) >> 4 ; }
inline uint32_t rtc_tsdr_get_du(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DU) >> 0 ; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4 = 1UL<<31, // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMAR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3 = 1UL<<23, // Alarm A hours mask
	RTC_ALRMAR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMAR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2 = 1UL<<15, // Alarm A minutes mask
	RTC_ALRMAR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMAR_MSK1 = 1UL<<7, // Alarm A seconds mask
	RTC_ALRMAR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMAR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_alrmar_set_dt(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DT) | ((val<<28) & RTC_ALRMAR_DT); }
inline void rtc_alrmar_set_du(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DU) | ((val<<24) & RTC_ALRMAR_DU); }
inline void rtc_alrmar_set_ht(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HT) | ((val<<20) & RTC_ALRMAR_HT); }
inline void rtc_alrmar_set_hu(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HU) | ((val<<16) & RTC_ALRMAR_HU); }
inline void rtc_alrmar_set_mnt(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNT) | ((val<<12) & RTC_ALRMAR_MNT); }
inline void rtc_alrmar_set_mnu(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNU) | ((val<<8) & RTC_ALRMAR_MNU); }
inline void rtc_alrmar_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_ST) | ((val<<4) & RTC_ALRMAR_ST); }
inline void rtc_alrmar_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_SU) | ((val<<0) & RTC_ALRMAR_SU); }
inline uint32_t rtc_alrmar_get_dt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DT) >> 28 ; }
inline uint32_t rtc_alrmar_get_du(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DU) >> 24 ; }
inline uint32_t rtc_alrmar_get_ht(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HT) >> 20 ; }
inline uint32_t rtc_alrmar_get_hu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HU) >> 16 ; }
inline uint32_t rtc_alrmar_get_mnt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNT) >> 12 ; }
inline uint32_t rtc_alrmar_get_mnu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNU) >> 8 ; }
inline uint32_t rtc_alrmar_get_st(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_ST) >> 4 ; }
inline uint32_t rtc_alrmar_get_su(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_SU) >> 0 ; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
inline void rtc_alrmassr_set_maskss(struct RTC_Type* p, uint32_t val) { p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val<<24) & RTC_ALRMASSR_MASKSS); }
inline void rtc_alrmassr_set_ss(struct RTC_Type* p, uint32_t val) { p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_SS) | ((val<<0) & RTC_ALRMASSR_SS); }
inline uint32_t rtc_alrmassr_get_maskss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24 ; }
inline uint32_t rtc_alrmassr_get_ss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_SS) >> 0 ; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4 = 1UL<<31, // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMBR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3 = 1UL<<23, // Alarm B hours mask
	RTC_ALRMBR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMBR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2 = 1UL<<15, // Alarm B minutes mask
	RTC_ALRMBR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMBR_MSK1 = 1UL<<7, // Alarm B seconds mask
	RTC_ALRMBR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMBR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_alrmbr_set_dt(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DT) | ((val<<28) & RTC_ALRMBR_DT); }
inline void rtc_alrmbr_set_du(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DU) | ((val<<24) & RTC_ALRMBR_DU); }
inline void rtc_alrmbr_set_ht(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HT) | ((val<<20) & RTC_ALRMBR_HT); }
inline void rtc_alrmbr_set_hu(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HU) | ((val<<16) & RTC_ALRMBR_HU); }
inline void rtc_alrmbr_set_mnt(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNT) | ((val<<12) & RTC_ALRMBR_MNT); }
inline void rtc_alrmbr_set_mnu(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNU) | ((val<<8) & RTC_ALRMBR_MNU); }
inline void rtc_alrmbr_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_ST) | ((val<<4) & RTC_ALRMBR_ST); }
inline void rtc_alrmbr_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_SU) | ((val<<0) & RTC_ALRMBR_SU); }
inline uint32_t rtc_alrmbr_get_dt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DT) >> 28 ; }
inline uint32_t rtc_alrmbr_get_du(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DU) >> 24 ; }
inline uint32_t rtc_alrmbr_get_ht(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HT) >> 20 ; }
inline uint32_t rtc_alrmbr_get_hu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HU) >> 16 ; }
inline uint32_t rtc_alrmbr_get_mnt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNT) >> 12 ; }
inline uint32_t rtc_alrmbr_get_mnu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNU) >> 8 ; }
inline uint32_t rtc_alrmbr_get_st(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_ST) >> 4 ; }
inline uint32_t rtc_alrmbr_get_su(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_SU) >> 0 ; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
inline void rtc_alrmbssr_set_maskss(struct RTC_Type* p, uint32_t val) { p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val<<24) & RTC_ALRMBSSR_MASKSS); }
inline void rtc_alrmbssr_set_ss(struct RTC_Type* p, uint32_t val) { p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val<<0) & RTC_ALRMBSSR_SS); }
inline uint32_t rtc_alrmbssr_get_maskss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24 ; }
inline uint32_t rtc_alrmbssr_get_ss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_SS) >> 0 ; }

// RTC->SR status register
enum {
	RTC_SR_ITSF = 1UL<<5, // ITSF
	RTC_SR_TSOVF = 1UL<<4, // TSOVF
	RTC_SR_TSF = 1UL<<3, // TSF
	RTC_SR_WUTF = 1UL<<2, // WUTF
	RTC_SR_ALRBF = 1UL<<1, // ALRBF
	RTC_SR_ALRAF = 1UL<<0, // ALRAF		
};

// RTC->MISR masked interrupt status register
enum {
	RTC_MISR_ITSMF = 1UL<<5, // ITSMF
	RTC_MISR_TSOVMF = 1UL<<4, // TSOVMF
	RTC_MISR_TSMF = 1UL<<3, // TSMF
	RTC_MISR_WUTMF = 1UL<<2, // WUTMF
	RTC_MISR_ALRBMF = 1UL<<1, // ALRBMF
	RTC_MISR_ALRAMF = 1UL<<0, // ALRAMF		
};

// RTC->SCR status clear register
enum {
	RTC_SCR_CITSF = 1UL<<5, // CITSF
	RTC_SCR_CTSOVF = 1UL<<4, // CTSOVF
	RTC_SCR_CTSF = 1UL<<3, // CTSF
	RTC_SCR_CWUTF = 1UL<<2, // CWUTF
	RTC_SCR_CALRBF = 1UL<<1, // CALRBF
	RTC_SCR_CALRAF = 1UL<<0, // CALRAF		
};

/* System control block */
struct SCB_Type {
	__I uint32_t CPUID; // @0 CPUID base register
	__IO uint32_t ICSR; // @4 Interrupt control and state register
	__IO uint32_t VTOR; // @8 Vector table offset register
	__IO uint32_t AIRCR; // @12 Application interrupt and reset control register
	__IO uint8_t SCR; // @16 System control register
	 uint8_t RESERVED0[3]; // @17 
	__IO uint16_t CCR; // @20 Configuration and control register
	 uint8_t RESERVED1[6]; // @22 
	__IO uint32_t SHPR2; // @28 System handler priority registers
	__IO uint32_t SHPR3; // @32 System handler priority registers
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL<<8)-1) << 24, // Implementer code
	SCB_CPUID_VARIANT = ((1UL<<4)-1) << 20, // Variant number
	SCB_CPUID_ARCHITECTURE = ((1UL<<4)-1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO = ((1UL<<12)-1) << 4, // Part number of the processor
	SCB_CPUID_REVISION = ((1UL<<4)-1) << 0, // Revision number		
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24 ; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20 ; }
inline uint32_t scb_cpuid_get_architecture(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_ARCHITECTURE) >> 16 ; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4 ; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0 ; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET = 1UL<<31, // NMI set-pending bit.
	SCB_ICSR_PENDSVSET = 1UL<<28, // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR = 1UL<<27, // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET = 1UL<<26, // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR = 1UL<<25, // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING = 1UL<<22, // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL<<7)-1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE = 1UL<<11, // Return to base level
	SCB_ICSR_VECTACTIVE = ((1UL<<9)-1) << 0, // Active vector		
};
inline void scb_icsr_set_vectpending(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val<<12) & SCB_ICSR_VECTPENDING); }
inline void scb_icsr_set_vectactive(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val<<0) & SCB_ICSR_VECTACTIVE); }
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12 ; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0 ; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL<<25)-1) << 7, // Vector table base offset field		
};
inline void scb_vtor_set_tbloff(struct SCB_Type* p, uint32_t val) { p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val<<7) & SCB_VTOR_TBLOFF); }
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type* p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 7 ; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT = ((1UL<<16)-1) << 16, // Register key
	SCB_AIRCR_ENDIANESS = 1UL<<15, // ENDIANESS
	SCB_AIRCR_SYSRESETREQ = 1UL<<2, // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL<<1, // VECTCLRACTIVE		
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val<<16) & SCB_AIRCR_VECTKEYSTAT); }
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16 ; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND = 1UL<<4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP = 1UL<<2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL<<1, // SLEEPONEXIT		
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN = 1UL<<9, // STKALIGN
	SCB_CCR_BFHFNMIGN = 1UL<<8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP = 1UL<<4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP = 1UL<<3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND = 1UL<<1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL<<0, // Configures how the processor enters Thread mode		
};

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL<<8)-1) << 24, // Priority of system handler 11		
};
inline void scb_shpr2_set_pri_11(struct SCB_Type* p, uint32_t val) { p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val<<24) & SCB_SHPR2_PRI_11); }
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type* p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24 ; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL<<8)-1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL<<8)-1) << 16, // Priority of system handler 14		
};
inline void scb_shpr3_set_pri_15(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val<<24) & SCB_SHPR3_PRI_15); }
inline void scb_shpr3_set_pri_14(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val<<16) & SCB_SHPR3_PRI_14); }
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24 ; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16 ; }

/* System control block ACTLR */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISOOFP = 1UL<<9, // DISOOFP
	SCB_ACTRL_ACTRL_DISFPCA = 1UL<<8, // DISFPCA
	SCB_ACTRL_ACTRL_DISFOLD = 1UL<<2, // DISFOLD
	SCB_ACTRL_ACTRL_DISDEFWBUF = 1UL<<1, // DISDEFWBUF
	SCB_ACTRL_ACTRL_DISMCYCINT = 1UL<<0, // DISMCYCINT		
};

/* Serial peripheral interface/Inter-IC sound */
struct SPI1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SR; // @8 status register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DR; // @12 data register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t CRCPR; // @16 CRC polynomial register
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t RXCRCR; // @20 RX CRC register
	 uint8_t RESERVED5[2]; // @22 
	__I uint16_t TXCRCR; // @24 TX CRC register
	 uint8_t RESERVED6[2]; // @26 
	__IO uint16_t I2SCFGR; // @28 configuration register
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t I2SPR; // @32 prescaler register
};

// SPI1->CR1 control register 1
enum {
	SPI1_CR1_BIDIMODE = 1UL<<15, // Bidirectional data mode enable
	SPI1_CR1_BIDIOE = 1UL<<14, // Output enable in bidirectional mode
	SPI1_CR1_CRCEN = 1UL<<13, // Hardware CRC calculation enable
	SPI1_CR1_CRCNEXT = 1UL<<12, // CRC transfer next
	SPI1_CR1_DFF = 1UL<<11, // Data frame format
	SPI1_CR1_RXONLY = 1UL<<10, // Receive only
	SPI1_CR1_SSM = 1UL<<9, // Software slave management
	SPI1_CR1_SSI = 1UL<<8, // Internal slave select
	SPI1_CR1_LSBFIRST = 1UL<<7, // Frame format
	SPI1_CR1_SPE = 1UL<<6, // SPI enable
	SPI1_CR1_BR = ((1UL<<3)-1) << 3, // Baud rate control
	SPI1_CR1_MSTR = 1UL<<2, // Master selection
	SPI1_CR1_CPOL = 1UL<<1, // Clock polarity
	SPI1_CR1_CPHA = 1UL<<0, // Clock phase		
};
inline void spi1_cr1_set_br(struct SPI1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI1_CR1_BR) | ((val<<3) & SPI1_CR1_BR); }
inline uint32_t spi1_cr1_get_br(struct SPI1_Type* p) { return (p->CR1 & SPI1_CR1_BR) >> 3 ; }

// SPI1->CR2 control register 2
enum {
	SPI1_CR2_LDMA_TX = 1UL<<14, // Last DMA transfer for transmission
	SPI1_CR2_LDMA_RX = 1UL<<13, // Last DMA transfer for reception
	SPI1_CR2_FRXTH = 1UL<<12, // FIFO reception threshold
	SPI1_CR2_DS = ((1UL<<4)-1) << 8, // Data size
	SPI1_CR2_TXEIE = 1UL<<7, // Tx buffer empty interrupt enable
	SPI1_CR2_RXNEIE = 1UL<<6, // RX buffer not empty interrupt enable
	SPI1_CR2_ERRIE = 1UL<<5, // Error interrupt enable
	SPI1_CR2_FRF = 1UL<<4, // Frame format
	SPI1_CR2_NSSP = 1UL<<3, // NSS pulse management
	SPI1_CR2_SSOE = 1UL<<2, // SS output enable
	SPI1_CR2_TXDMAEN = 1UL<<1, // Tx buffer DMA enable
	SPI1_CR2_RXDMAEN = 1UL<<0, // Rx buffer DMA enable		
};
inline void spi1_cr2_set_ds(struct SPI1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_DS) | ((val<<8) & SPI1_CR2_DS); }
inline uint32_t spi1_cr2_get_ds(struct SPI1_Type* p) { return (p->CR2 & SPI1_CR2_DS) >> 8 ; }

// SPI1->SR status register
enum {
	SPI1_SR_FTLVL = ((1UL<<2)-1) << 11, // FIFO transmission level
	SPI1_SR_FRLVL = ((1UL<<2)-1) << 9, // FIFO reception level
	SPI1_SR_TIFRFE = 1UL<<8, // TI frame format error
	SPI1_SR_BSY = 1UL<<7, // Busy flag
	SPI1_SR_OVR = 1UL<<6, // Overrun flag
	SPI1_SR_MODF = 1UL<<5, // Mode fault
	SPI1_SR_CRCERR = 1UL<<4, // CRC error flag
	SPI1_SR_UDR = 1UL<<3, // Underrun flag
	SPI1_SR_CHSIDE = 1UL<<2, // Channel side
	SPI1_SR_TXE = 1UL<<1, // Transmit buffer empty
	SPI1_SR_RXNE = 1UL<<0, // Receive buffer not empty		
};
inline void spi1_sr_set_ftlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FTLVL) | ((val<<11) & SPI1_SR_FTLVL); }
inline void spi1_sr_set_frlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FRLVL) | ((val<<9) & SPI1_SR_FRLVL); }
inline uint32_t spi1_sr_get_ftlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FTLVL) >> 11 ; }
inline uint32_t spi1_sr_get_frlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FRLVL) >> 9 ; }

// SPI1->I2SCFGR configuration register
enum {
	SPI1_I2SCFGR_I2SMOD = 1UL<<11, // I2S mode selection
	SPI1_I2SCFGR_SE2 = 1UL<<10, // I2S enable
	SPI1_I2SCFGR_I2SCFG = ((1UL<<2)-1) << 8, // I2S configuration mode
	SPI1_I2SCFGR_PCMSYNC = 1UL<<7, // PCM frame synchronization
	SPI1_I2SCFGR_I2SSTD = ((1UL<<2)-1) << 4, // standard selection
	SPI1_I2SCFGR_CKPOL = 1UL<<3, // Inactive state clock polarity
	SPI1_I2SCFGR_DATLEN = ((1UL<<2)-1) << 1, // Data length to be transferred
	SPI1_I2SCFGR_CHLEN = 1UL<<0, // Channel length (number of bits per audio channel)		
};
inline void spi1_i2scfgr_set_i2scfg(struct SPI1_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SCFG) | ((val<<8) & SPI1_I2SCFGR_I2SCFG); }
inline void spi1_i2scfgr_set_i2sstd(struct SPI1_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SSTD) | ((val<<4) & SPI1_I2SCFGR_I2SSTD); }
inline void spi1_i2scfgr_set_datlen(struct SPI1_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_DATLEN) | ((val<<1) & SPI1_I2SCFGR_DATLEN); }
inline uint32_t spi1_i2scfgr_get_i2scfg(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SCFG) >> 8 ; }
inline uint32_t spi1_i2scfgr_get_i2sstd(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SSTD) >> 4 ; }
inline uint32_t spi1_i2scfgr_get_datlen(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_DATLEN) >> 1 ; }

// SPI1->I2SPR prescaler register
enum {
	SPI1_I2SPR_MCKOE = 1UL<<9, // Master clock output enable
	SPI1_I2SPR_ODD = 1UL<<8, // Odd factor for the prescaler
	SPI1_I2SPR_I2SDIV = ((1UL<<8)-1) << 0, // linear prescaler		
};
inline void spi1_i2spr_set_i2sdiv(struct SPI1_Type* p, uint32_t val) { p->I2SPR = (p->I2SPR & ~SPI1_I2SPR_I2SDIV) | ((val<<0) & SPI1_I2SPR_I2SDIV); }
inline uint32_t spi1_i2spr_get_i2sdiv(struct SPI1_Type* p) { return (p->I2SPR & SPI1_I2SPR_I2SDIV) >> 0 ; }


/* SysTick timer */
struct STK_Type {
	__IO uint32_t CSR; // @0 SysTick control and status register
	__IO uint32_t RVR; // @4 SysTick reload value register
	__IO uint32_t CVR; // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};

// STK->CSR SysTick control and status register
enum {
	STK_CSR_COUNTFLAG = 1UL<<16, // COUNTFLAG
	STK_CSR_CLKSOURCE = 1UL<<2, // Clock source selection
	STK_CSR_TICKINT = 1UL<<1, // SysTick exception request enable
	STK_CSR_ENABLE = 1UL<<0, // Counter enable		
};

// STK->RVR SysTick reload value register
enum {
	STK_RVR_RELOAD = ((1UL<<24)-1) << 0, // RELOAD value		
};
inline void stk_rvr_set_reload(struct STK_Type* p, uint32_t val) { p->RVR = (p->RVR & ~STK_RVR_RELOAD) | ((val<<0) & STK_RVR_RELOAD); }
inline uint32_t stk_rvr_get_reload(struct STK_Type* p) { return (p->RVR & STK_RVR_RELOAD) >> 0 ; }

// STK->CVR SysTick current value register
enum {
	STK_CVR_CURRENT = ((1UL<<24)-1) << 0, // Current counter value		
};
inline void stk_cvr_set_current(struct STK_Type* p, uint32_t val) { p->CVR = (p->CVR & ~STK_CVR_CURRENT) | ((val<<0) & STK_CVR_CURRENT); }
inline uint32_t stk_cvr_get_current(struct STK_Type* p) { return (p->CVR & STK_CVR_CURRENT) >> 0 ; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL<<31, // NOREF flag. Reads as zero
	STK_CALIB_SKEW = 1UL<<30, // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL<<24)-1) << 0, // Calibration value		
};
inline void stk_calib_set_tenms(struct STK_Type* p, uint32_t val) { p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val<<0) & STK_CALIB_TENMS); }
inline uint32_t stk_calib_get_tenms(struct STK_Type* p) { return (p->CALIB & STK_CALIB_TENMS) >> 0 ; }

/* System configuration controller */
struct SYSCFG_Type {
	__IO uint32_t CFGR1; // @0 SYSCFG configuration register 1
	 uint8_t RESERVED0[20]; // @4 
	__IO uint32_t CFGR2; // @24 SYSCFG configuration register 1
};

// SYSCFG->CFGR1 SYSCFG configuration register 1
enum {
	SYSCFG_CFGR1_I2C_PAX_FMP = ((1UL<<2)-1) << 22, // Fast Mode Plus (FM+) driving capability activation bits
	SYSCFG_CFGR1_I2C2_FMP = 1UL<<21, // FM+ driving capability activation for I2C2
	SYSCFG_CFGR1_I2C1_FMP = 1UL<<20, // FM+ driving capability activation for I2C1
	SYSCFG_CFGR1_I2C_PBX_FMP = ((1UL<<4)-1) << 16, // Fast Mode Plus (FM+) driving capability activation bits
	SYSCFG_CFGR1_BOOSTEN = 1UL<<8, // I/O analog switch voltage booster enable
	SYSCFG_CFGR1_IR_MOD = ((1UL<<2)-1) << 6, // IR Modulation Envelope signal selection.
	SYSCFG_CFGR1_IR_POL = 1UL<<5, // IR output polarity selection
	SYSCFG_CFGR1_PA11_PA12_RMP = 1UL<<4, // PA11 and PA12 remapping bit.
	SYSCFG_CFGR1_MEM_MODE = ((1UL<<2)-1) << 0, // Memory mapping selection bits		
};
inline void syscfg_cfgr1_set_i2c_pax_fmp(struct SYSCFG_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_I2C_PAX_FMP) | ((val<<22) & SYSCFG_CFGR1_I2C_PAX_FMP); }
inline void syscfg_cfgr1_set_i2c_pbx_fmp(struct SYSCFG_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_I2C_PBX_FMP) | ((val<<16) & SYSCFG_CFGR1_I2C_PBX_FMP); }
inline void syscfg_cfgr1_set_ir_mod(struct SYSCFG_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_IR_MOD) | ((val<<6) & SYSCFG_CFGR1_IR_MOD); }
inline void syscfg_cfgr1_set_mem_mode(struct SYSCFG_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_MEM_MODE) | ((val<<0) & SYSCFG_CFGR1_MEM_MODE); }
inline uint32_t syscfg_cfgr1_get_i2c_pax_fmp(struct SYSCFG_Type* p) { return (p->CFGR1 & SYSCFG_CFGR1_I2C_PAX_FMP) >> 22 ; }
inline uint32_t syscfg_cfgr1_get_i2c_pbx_fmp(struct SYSCFG_Type* p) { return (p->CFGR1 & SYSCFG_CFGR1_I2C_PBX_FMP) >> 16 ; }
inline uint32_t syscfg_cfgr1_get_ir_mod(struct SYSCFG_Type* p) { return (p->CFGR1 & SYSCFG_CFGR1_IR_MOD) >> 6 ; }
inline uint32_t syscfg_cfgr1_get_mem_mode(struct SYSCFG_Type* p) { return (p->CFGR1 & SYSCFG_CFGR1_MEM_MODE) >> 0 ; }

// SYSCFG->CFGR2 SYSCFG configuration register 1
enum {
	SYSCFG_CFGR2_PB2_CDEN = 1UL<<23, // PB2_CDEN
	SYSCFG_CFGR2_PB1_CDEN = 1UL<<22, // PB1_CDEN
	SYSCFG_CFGR2_PB0_CDEN = 1UL<<21, // PB0_CDEN
	SYSCFG_CFGR2_PA13_CDEN = 1UL<<20, // PA13_CDEN
	SYSCFG_CFGR2_PA6_CDEN = 1UL<<19, // PA6_CDEN
	SYSCFG_CFGR2_PA5_CDEN = 1UL<<18, // PA5_CDEN
	SYSCFG_CFGR2_PA3_CDEN = 1UL<<17, // PA3_CDEN
	SYSCFG_CFGR2_PA1_CDEN = 1UL<<16, // PA1_CDEN
	SYSCFG_CFGR2_SRAM_PEF = 1UL<<8, // SRAM parity error flag
	SYSCFG_CFGR2_ECC_LOCK = 1UL<<3, // ECC error lock bit
	SYSCFG_CFGR2_PVD_LOCK = 1UL<<2, // PVD lock enable bit
	SYSCFG_CFGR2_SRAM_PARITY_LOCK = 1UL<<1, // SRAM parity lock bit
	SYSCFG_CFGR2_LOCKUP_LOCK = 1UL<<0, // Cortex-M0+ LOCKUP bit enable bit		
};

/* System configuration controller */
struct SYSCFG_ITLINE_Type {
	 uint8_t RESERVED0[128]; // @0 
	__I uint8_t ITLINE0; // @128 interrupt line 0 status register
	 uint8_t RESERVED1[3]; // @129 
	__I uint8_t ITLINE1; // @132 interrupt line 1 status register
	 uint8_t RESERVED2[3]; // @133 
	__I uint8_t ITLINE2; // @136 interrupt line 2 status register
	 uint8_t RESERVED3[3]; // @137 
	__I uint8_t ITLINE3; // @140 interrupt line 3 status register
	 uint8_t RESERVED4[3]; // @141 
	__I uint8_t ITLINE4; // @144 interrupt line 4 status register
	 uint8_t RESERVED5[3]; // @145 
	__I uint8_t ITLINE5; // @148 interrupt line 5 status register
	 uint8_t RESERVED6[3]; // @149 
	__I uint8_t ITLINE6; // @152 interrupt line 6 status register
	 uint8_t RESERVED7[3]; // @153 
	__I uint16_t ITLINE7; // @156 interrupt line 7 status register
	 uint8_t RESERVED8[6]; // @158 
	__I uint8_t ITLINE9; // @164 interrupt line 9 status register
	 uint8_t RESERVED9[3]; // @165 
	__I uint8_t ITLINE10; // @168 interrupt line 10 status register
	 uint8_t RESERVED10[3]; // @169 
	__I uint8_t ITLINE11; // @172 interrupt line 11 status register
	 uint8_t RESERVED11[3]; // @173 
	__I uint8_t ITLINE12; // @176 interrupt line 12 status register
	 uint8_t RESERVED12[3]; // @177 
	__I uint8_t ITLINE13; // @180 interrupt line 13 status register
	 uint8_t RESERVED13[3]; // @181 
	__I uint8_t ITLINE14; // @184 interrupt line 14 status register
	 uint8_t RESERVED14[3]; // @185 
	__I uint8_t ITLINE15; // @188 interrupt line 15 status register
	 uint8_t RESERVED15[3]; // @189 
	__I uint8_t ITLINE16; // @192 interrupt line 16 status register
	 uint8_t RESERVED16[3]; // @193 
	__I uint8_t ITLINE17; // @196 interrupt line 17 status register
	 uint8_t RESERVED17[3]; // @197 
	__I uint8_t ITLINE18; // @200 interrupt line 18 status register
	 uint8_t RESERVED18[3]; // @201 
	__I uint8_t ITLINE19; // @204 interrupt line 19 status register
	 uint8_t RESERVED19[7]; // @205 
	__I uint8_t ITLINE21; // @212 interrupt line 21 status register
	 uint8_t RESERVED20[3]; // @213 
	__I uint8_t ITLINE22; // @216 interrupt line 22 status register
	 uint8_t RESERVED21[3]; // @217 
	__I uint8_t ITLINE23; // @220 interrupt line 23 status register
	 uint8_t RESERVED22[3]; // @221 
	__I uint8_t ITLINE24; // @224 interrupt line 24 status register
	 uint8_t RESERVED23[3]; // @225 
	__I uint8_t ITLINE25; // @228 interrupt line 25 status register
	 uint8_t RESERVED24[3]; // @229 
	__I uint8_t ITLINE26; // @232 interrupt line 26 status register
	 uint8_t RESERVED25[3]; // @233 
	__I uint8_t ITLINE27; // @236 interrupt line 27 status register
	 uint8_t RESERVED26[3]; // @237 
	__I uint8_t ITLINE28; // @240 interrupt line 28 status register
	 uint8_t RESERVED27[3]; // @241 
	__I uint8_t ITLINE29; // @244 interrupt line 29 status register
};

// SYSCFG_ITLINE->ITLINE0 interrupt line 0 status register
enum {
	SYSCFG_ITLINE_ITLINE0_WWDG = 1UL<<0, // Window watchdog interrupt pending flag		
};

// SYSCFG_ITLINE->ITLINE1 interrupt line 1 status register
enum {
	SYSCFG_ITLINE_ITLINE1_PVDOUT = 1UL<<0, // PVD supply monitoring interrupt request pending (EXTI line 16).		
};

// SYSCFG_ITLINE->ITLINE2 interrupt line 2 status register
enum {
	SYSCFG_ITLINE_ITLINE2_RTC = 1UL<<1, // RTC
	SYSCFG_ITLINE_ITLINE2_TAMP = 1UL<<0, // TAMP		
};

// SYSCFG_ITLINE->ITLINE3 interrupt line 3 status register
enum {
	SYSCFG_ITLINE_ITLINE3_FLASH_ECC = 1UL<<1, // FLASH_ECC
	SYSCFG_ITLINE_ITLINE3_FLASH_ITF = 1UL<<0, // FLASH_ITF		
};

// SYSCFG_ITLINE->ITLINE4 interrupt line 4 status register
enum {
	SYSCFG_ITLINE_ITLINE4_RCC = 1UL<<0, // RCC		
};

// SYSCFG_ITLINE->ITLINE5 interrupt line 5 status register
enum {
	SYSCFG_ITLINE_ITLINE5_EXTIX  = ((1UL<<2)-1) << 0, // Merged EXTI1		
};
inline uint32_t syscfg_itline_itline5_get_extix (struct SYSCFG_ITLINE_Type* p) { return (p->ITLINE5 & SYSCFG_ITLINE_ITLINE5_EXTIX ) >> 0 ; }

// SYSCFG_ITLINE->ITLINE6 interrupt line 6 status register
enum {
	SYSCFG_ITLINE_ITLINE6_EXTIX  = ((1UL<<2)-1) << 0, // Merged EXTI3		
};
inline uint32_t syscfg_itline_itline6_get_extix (struct SYSCFG_ITLINE_Type* p) { return (p->ITLINE6 & SYSCFG_ITLINE_ITLINE6_EXTIX ) >> 0 ; }

// SYSCFG_ITLINE->ITLINE7 interrupt line 7 status register
enum {
	SYSCFG_ITLINE_ITLINE7_EXTIX  = ((1UL<<12)-1) << 0, // Merged EXTI15		
};
inline uint32_t syscfg_itline_itline7_get_extix (struct SYSCFG_ITLINE_Type* p) { return (p->ITLINE7 & SYSCFG_ITLINE_ITLINE7_EXTIX ) >> 0 ; }

// SYSCFG_ITLINE->ITLINE9 interrupt line 9 status register
enum {
	SYSCFG_ITLINE_ITLINE9_DMA1_CH1 = 1UL<<0, // DMA1_CH1		
};

// SYSCFG_ITLINE->ITLINE10 interrupt line 10 status register
enum {
	SYSCFG_ITLINE_ITLINE10_DMAX_CHX  = ((1UL<<2)-1) << 0, // Merged DMA1_CH3		
};
inline uint32_t syscfg_itline_itline10_get_dmax_chx (struct SYSCFG_ITLINE_Type* p) { return (p->ITLINE10 & SYSCFG_ITLINE_ITLINE10_DMAX_CHX ) >> 0 ; }

// SYSCFG_ITLINE->ITLINE11 interrupt line 11 status register
enum {
	SYSCFG_ITLINE_ITLINE11_DMA1_CH5 = 1UL<<2, // DMA1_CH5
	SYSCFG_ITLINE_ITLINE11_DMA1_CH4 = 1UL<<1, // DMA1_CH4
	SYSCFG_ITLINE_ITLINE11_DMAMUX = 1UL<<0, // DMAMUX		
};

// SYSCFG_ITLINE->ITLINE12 interrupt line 12 status register
enum {
	SYSCFG_ITLINE_ITLINE12_ADC = 1UL<<0, // ADC		
};

// SYSCFG_ITLINE->ITLINE13 interrupt line 13 status register
enum {
	SYSCFG_ITLINE_ITLINE13_TIM1_BRK = 1UL<<3, // TIM1_BRK
	SYSCFG_ITLINE_ITLINE13_TIM1_UPD = 1UL<<2, // TIM1_UPD
	SYSCFG_ITLINE_ITLINE13_TIM1_TRG = 1UL<<1, // TIM1_TRG
	SYSCFG_ITLINE_ITLINE13_TIM1_CCU = 1UL<<0, // TIM1_CCU		
};

// SYSCFG_ITLINE->ITLINE14 interrupt line 14 status register
enum {
	SYSCFG_ITLINE_ITLINE14_TIM1_CC = 1UL<<0, // TIM1_CC		
};

// SYSCFG_ITLINE->ITLINE15 interrupt line 15 status register
enum {
	SYSCFG_ITLINE_ITLINE15_TIM2 = 1UL<<0, // TIM2		
};

// SYSCFG_ITLINE->ITLINE16 interrupt line 16 status register
enum {
	SYSCFG_ITLINE_ITLINE16_TIM3 = 1UL<<0, // TIM3		
};

// SYSCFG_ITLINE->ITLINE17 interrupt line 17 status register
enum {
	SYSCFG_ITLINE_ITLINE17_LPTIM1 = 1UL<<2, // LPTIM1		
};

// SYSCFG_ITLINE->ITLINE18 interrupt line 18 status register
enum {
	SYSCFG_ITLINE_ITLINE18_LPTIM2 = 1UL<<1, // LPTIM2		
};

// SYSCFG_ITLINE->ITLINE19 interrupt line 19 status register
enum {
	SYSCFG_ITLINE_ITLINE19_TIM14 = 1UL<<0, // TIM14		
};

// SYSCFG_ITLINE->ITLINE21 interrupt line 21 status register
enum {
	SYSCFG_ITLINE_ITLINE21_TIM16 = 1UL<<0, // TIM16		
};

// SYSCFG_ITLINE->ITLINE22 interrupt line 22 status register
enum {
	SYSCFG_ITLINE_ITLINE22_TIM17 = 1UL<<0, // TIM17		
};

// SYSCFG_ITLINE->ITLINE23 interrupt line 23 status register
enum {
	SYSCFG_ITLINE_ITLINE23_I2C1 = 1UL<<0, // I2C1		
};

// SYSCFG_ITLINE->ITLINE24 interrupt line 24 status register
enum {
	SYSCFG_ITLINE_ITLINE24_I2C2 = 1UL<<0, // I2C2		
};

// SYSCFG_ITLINE->ITLINE25 interrupt line 25 status register
enum {
	SYSCFG_ITLINE_ITLINE25_SPI1 = 1UL<<0, // SPI1		
};

// SYSCFG_ITLINE->ITLINE26 interrupt line 26 status register
enum {
	SYSCFG_ITLINE_ITLINE26_SPI2 = 1UL<<0, // SPI2		
};

// SYSCFG_ITLINE->ITLINE27 interrupt line 27 status register
enum {
	SYSCFG_ITLINE_ITLINE27_USART1 = 1UL<<0, // USART1		
};

// SYSCFG_ITLINE->ITLINE28 interrupt line 28 status register
enum {
	SYSCFG_ITLINE_ITLINE28_USART2 = 1UL<<0, // USART2		
};

// SYSCFG_ITLINE->ITLINE29 interrupt line 29 status register
enum {
	SYSCFG_ITLINE_ITLINE29_USART5 = 1UL<<2, // USART5		
};

/* Tamper and backup registers */
struct TAMP_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	 uint8_t RESERVED0[4]; // @8 
	__IO uint8_t FLTCR; // @12 TAMP filter control register
	 uint8_t RESERVED1[31]; // @13 
	__IO uint32_t IER; // @44 TAMP interrupt enable register
	__I uint32_t SR; // @48 TAMP status register
	__I uint32_t MISR; // @52 TAMP masked interrupt status register
	 uint8_t RESERVED2[4]; // @56 
	__O uint32_t SCR; // @60 TAMP status clear register
	 uint8_t RESERVED3[192]; // @64 
	__IO uint32_t BKP0R; // @256 TAMP backup register
	__IO uint32_t BKP1R; // @260 TAMP backup register
	__IO uint32_t BKP2R; // @264 TAMP backup register
	__IO uint32_t BKP3R; // @268 TAMP backup register
	__IO uint32_t BKP4R; // @272 TAMP backup register
};

// TAMP->CR1 control register 1
enum {
	TAMP_CR1_ITAMP6E = 1UL<<21, // ITAMP6E
	TAMP_CR1_ITAMP5E = 1UL<<20, // ITAMP5E
	TAMP_CR1_ITAMP4E = 1UL<<19, // ITAMP4E
	TAMP_CR1_ITAMP3E = 1UL<<18, // ITAMP3E
	TAMP_CR1_ITAMP1E = 1UL<<16, // ITAMP1E
	TAMP_CR1_TAMP2E = 1UL<<1, // TAMP2E
	TAMP_CR1_TAMP1E = 1UL<<0, // TAMP1E		
};

// TAMP->CR2 control register 2
enum {
	TAMP_CR2_TAMP2TRG = 1UL<<25, // TAMP2TRG
	TAMP_CR2_TAMP1TRG = 1UL<<24, // TAMP1TRG
	TAMP_CR2_TAMP2MSK = 1UL<<17, // TAMP2MSK
	TAMP_CR2_TAMP1MSK = 1UL<<16, // TAMP1MSK
	TAMP_CR2_TAMP2NOER = 1UL<<1, // TAMP2NOER
	TAMP_CR2_TAMP1NOER = 1UL<<0, // TAMP1NOER		
};

// TAMP->FLTCR TAMP filter control register
enum {
	TAMP_FLTCR_TAMPPUDIS = 1UL<<7, // TAMPPUDIS
	TAMP_FLTCR_TAMPPRCH = ((1UL<<2)-1) << 5, // TAMPPRCH
	TAMP_FLTCR_TAMPFLT = ((1UL<<2)-1) << 3, // TAMPFLT
	TAMP_FLTCR_TAMPFREQ = ((1UL<<3)-1) << 0, // TAMPFREQ		
};
inline void tamp_fltcr_set_tampprch(struct TAMP_Type* p, uint32_t val) { p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPPRCH) | ((val<<5) & TAMP_FLTCR_TAMPPRCH); }
inline void tamp_fltcr_set_tampflt(struct TAMP_Type* p, uint32_t val) { p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPFLT) | ((val<<3) & TAMP_FLTCR_TAMPFLT); }
inline void tamp_fltcr_set_tampfreq(struct TAMP_Type* p, uint32_t val) { p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPFREQ) | ((val<<0) & TAMP_FLTCR_TAMPFREQ); }
inline uint32_t tamp_fltcr_get_tampprch(struct TAMP_Type* p) { return (p->FLTCR & TAMP_FLTCR_TAMPPRCH) >> 5 ; }
inline uint32_t tamp_fltcr_get_tampflt(struct TAMP_Type* p) { return (p->FLTCR & TAMP_FLTCR_TAMPFLT) >> 3 ; }
inline uint32_t tamp_fltcr_get_tampfreq(struct TAMP_Type* p) { return (p->FLTCR & TAMP_FLTCR_TAMPFREQ) >> 0 ; }

// TAMP->IER TAMP interrupt enable register
enum {
	TAMP_IER_ITAMP6IE = 1UL<<21, // ITAMP6IE
	TAMP_IER_ITAMP5IE = 1UL<<20, // ITAMP5IE
	TAMP_IER_ITAMP4IE = 1UL<<19, // ITAMP4IE
	TAMP_IER_ITAMP3IE = 1UL<<18, // ITAMP3IE
	TAMP_IER_ITAMP1IE = 1UL<<16, // ITAMP1IE
	TAMP_IER_TAMP2IE = 1UL<<1, // TAMP2IE
	TAMP_IER_TAMP1IE = 1UL<<0, // TAMP1IE		
};

// TAMP->SR TAMP status register
enum {
	TAMP_SR_ITAMP7F = 1UL<<22, // ITAMP7F
	TAMP_SR_ITAMP6F = 1UL<<21, // ITAMP6F
	TAMP_SR_ITAMP5F = 1UL<<20, // ITAMP5F
	TAMP_SR_ITAMP4F = 1UL<<19, // ITAMP4F
	TAMP_SR_ITAMP3F = 1UL<<18, // ITAMP3F
	TAMP_SR_ITAMP1F = 1UL<<16, // ITAMP1F
	TAMP_SR_TAMP2F = 1UL<<1, // TAMP2F
	TAMP_SR_TAMP1F = 1UL<<0, // TAMP1F		
};

// TAMP->MISR TAMP masked interrupt status register
enum {
	TAMP_MISR_ITAMP6MF = 1UL<<21, // ITAMP6MF
	TAMP_MISR_ITAMP5MF = 1UL<<20, // ITAMP5MF
	TAMP_MISR_ITAMP4MF = 1UL<<19, // ITAMP4MF
	TAMP_MISR_ITAMP3MF = 1UL<<18, // ITAMP3MF
	TAMP_MISR_ITAMP1MF = 1UL<<16, // ITAMP1MF
	TAMP_MISR_TAMP2MF = 1UL<<1, // TAMP2MF
	TAMP_MISR_TAMP1MF = 1UL<<0, // TAMP1MF:		
};

// TAMP->SCR TAMP status clear register
enum {
	TAMP_SCR_CITAMP7F = 1UL<<22, // CITAMP7F
	TAMP_SCR_CITAMP6F = 1UL<<21, // CITAMP6F
	TAMP_SCR_CITAMP5F = 1UL<<20, // CITAMP5F
	TAMP_SCR_CITAMP4F = 1UL<<19, // CITAMP4F
	TAMP_SCR_CITAMP3F = 1UL<<18, // CITAMP3F
	TAMP_SCR_CITAMP1F = 1UL<<16, // CITAMP1F
	TAMP_SCR_CTAMP2F = 1UL<<1, // CTAMP2F
	TAMP_SCR_CTAMP1F = 1UL<<0, // CTAMP1F		
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CR2; // @4 control register 2
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t SR; // @16 status register
	__O uint16_t EGR; // @20 event generation register
	 uint8_t RESERVED2[2]; // @22 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (output mode)
	};
	union {  // @28
		__IO uint32_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (output mode)
	};
	__IO uint32_t CCER; // @32 capture/compare enable register
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED3[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED4[2]; // @46 
	__IO uint16_t RCR; // @48 repetition counter register
	 uint8_t RESERVED5[2]; // @50 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED6[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED7[2]; // @58 
	__IO uint16_t CCR3; // @60 capture/compare register 3
	 uint8_t RESERVED8[2]; // @62 
	__IO uint16_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED9[2]; // @66 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED11[2]; // @78 
	__IO uint8_t OR1; // @80 option register 1
	 uint8_t RESERVED12[3]; // @81 
	__IO uint32_t CCMR3_Output; // @84 capture/compare mode register 2 (output mode)
	__IO uint32_t CCR5; // @88 capture/compare register 4
	__IO uint16_t CCR6; // @92 capture/compare register 4
	 uint8_t RESERVED13[2]; // @94 
	__IO uint32_t AF1; // @96 DMA address for full transfer
	__IO uint16_t AF2; // @100 DMA address for full transfer
	 uint8_t RESERVED14[2]; // @102 
	__IO uint32_t TISEL; // @104 TIM1 timer input selection register
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM1_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM1_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR = 1UL<<4, // Direction
	TIM1_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM1_CR1_URS = 1UL<<2, // Update request source
	TIM1_CR1_UDIS = 1UL<<1, // Update disable
	TIM1_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val<<8) & TIM1_CR1_CKD); }
inline void tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val<<5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8 ; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5 ; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_MMS2 = ((1UL<<4)-1) << 20, // Master mode selection 2
	TIM1_CR2_OIS6 = 1UL<<18, // Output Idle state 6 (OC6 output)
	TIM1_CR2_OIS5 = 1UL<<16, // Output Idle state 5 (OC5 output)
	TIM1_CR2_OIS4 = 1UL<<14, // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL<<13, // Output Idle state 3
	TIM1_CR2_OIS3 = 1UL<<12, // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL<<11, // Output Idle state 2
	TIM1_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM1_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM1_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM1_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM1_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM1_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM1_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
inline void tim1_cr2_set_mms2(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS2) | ((val<<20) & TIM1_CR2_MMS2); }
inline void tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val<<4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms2(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS2) >> 20 ; }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4 ; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_TS = ((1UL<<2)-1) << 20, // Trigger selection
	TIM1_SMCR_SMS_3 = 1UL<<16, // Slave mode selection - bit 3
	TIM1_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM1_SMCR_ECE = 1UL<<14, // External clock enable
	TIM1_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM1_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM1_SMCR_TS_4 = ((1UL<<3)-1) << 4, // Trigger selection
	TIM1_SMCR_OCCS = 1UL<<3, // OCREF clear selection
	TIM1_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val<<20) & TIM1_SMCR_TS); }
inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val<<12) & TIM1_SMCR_ETPS); }
inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val<<8) & TIM1_SMCR_ETF); }
inline void tim1_smcr_set_ts_4(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS_4) | ((val<<4) & TIM1_SMCR_TS_4); }
inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val<<0) & TIM1_SMCR_SMS); }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 20 ; }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12 ; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8 ; }
inline uint32_t tim1_smcr_get_ts_4(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS_4) >> 4 ; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0 ; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM1_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM1_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM1->SR status register
enum {
	TIM1_SR_CC6IF = 1UL<<17, // Compare 6 interrupt flag
	TIM1_SR_CC5IF = 1UL<<16, // Compare 5 interrupt flag
	TIM1_SR_SBIF = 1UL<<13, // System Break interrupt flag
	TIM1_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM1_SR_B2IF = 1UL<<8, // Break 2 interrupt flag
	TIM1_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM1_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM1_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM1_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_B2G = 1UL<<8, // Break 2 generation
	TIM1_EGR_BG = 1UL<<7, // Break generation
	TIM1_EGR_TG = 1UL<<6, // Trigger generation
	TIM1_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM1_EGR_UG = 1UL<<0, // Update generation		
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM1_CCMR1_OUTPUT_OC2M); }
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM1_CCMR1_OUTPUT_CC2S); }
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM1_CCMR1_OUTPUT_OC1M); }
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM1_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4M_3 = 1UL<<24, // Output Compare 4 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC3M_3 = 1UL<<16, // Output Compare 3 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM1_CCMR2_OUTPUT_OC4M); }
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM1_CCMR2_OUTPUT_CC4S); }
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM1_CCMR2_OUTPUT_OC3M); }
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM1_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC6P = 1UL<<21, // Capture/Compare 6 output polarity
	TIM1_CCER_CC6E = 1UL<<20, // Capture/Compare 6 output enable
	TIM1_CCER_CC5P = 1UL<<17, // Capture/Compare 5 output polarity
	TIM1_CCER_CC5E = 1UL<<16, // Capture/Compare 5 output enable
	TIM1_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 complementary output polarity
	TIM1_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL<<10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL<<6, // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM1->CNT counter
enum {
	TIM1_CNT_UIFCPY = 1UL<<31, // UIF copy
	TIM1_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim1_cnt_set_cnt(struct TIM1_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM1_CNT_CNT) | ((val<<0) & TIM1_CNT_CNT); }
inline uint32_t tim1_cnt_get_cnt(struct TIM1_Type* p) { return (p->CNT & TIM1_CNT_CNT) >> 0 ; }

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_BK2ID = 1UL<<29, // Break2 bidirectional
	TIM1_BDTR_BKBID = 1UL<<28, // Break Bidirectional
	TIM1_BDTR_BK2DSRM = 1UL<<27, // Break2 Disarm
	TIM1_BDTR_BKDSRM = 1UL<<26, // Break Disarm
	TIM1_BDTR_BK2P = 1UL<<25, // Break 2 polarity
	TIM1_BDTR_BK2E = 1UL<<24, // Break 2 enable
	TIM1_BDTR_BK2F = ((1UL<<4)-1) << 20, // Break 2 filter
	TIM1_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM1_BDTR_MOE = 1UL<<15, // Main output enable
	TIM1_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM1_BDTR_BKP = 1UL<<13, // Break polarity
	TIM1_BDTR_BKE = 1UL<<12, // Break enable
	TIM1_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM1_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim1_bdtr_set_bk2f(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BK2F) | ((val<<20) & TIM1_BDTR_BK2F); }
inline void tim1_bdtr_set_bkf(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BKF) | ((val<<16) & TIM1_BDTR_BKF); }
inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val<<8) & TIM1_BDTR_LOCK); }
inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val<<0) & TIM1_BDTR_DTG); }
inline uint32_t tim1_bdtr_get_bk2f(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BK2F) >> 20 ; }
inline uint32_t tim1_bdtr_get_bkf(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BKF) >> 16 ; }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8 ; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0 ; }

// TIM1->DCR DMA control register
enum {
	TIM1_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val<<8) & TIM1_DCR_DBL); }
inline void tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val<<0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8 ; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0 ; }

// TIM1->OR1 option register 1
enum {
	TIM1_OR1_OCREF_CLR = 1UL<<0, // Ocref_clr source selection		
};

// TIM1->CCMR3_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M_BIT3 = 1UL<<24, // Output Compare 6 mode bit 3
	TIM1_CCMR3_OUTPUT_OC5M_BIT3 = 1UL<<16, // Output Compare 5 mode bit 3
	TIM1_CCMR3_OUTPUT_OC6CE = 1UL<<15, // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M = ((1UL<<3)-1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE = 1UL<<11, // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE = 1UL<<10, // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE = 1UL<<7, // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M = ((1UL<<3)-1) << 4, // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE = 1UL<<3, // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE = 1UL<<2, // Output compare 5 fast enable		
};
inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val<<12) & TIM1_CCMR3_OUTPUT_OC6M); }
inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val<<4) & TIM1_CCMR3_OUTPUT_OC5M); }
inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12 ; }
inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4 ; }

// TIM1->CCR5 capture/compare register 4
enum {
	TIM1_CCR5_GC5C3 = 1UL<<31, // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL<<30, // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL<<29, // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
inline void tim1_ccr5_set_ccr5(struct TIM1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val<<0) & TIM1_CCR5_CCR5); }
inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type* p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0 ; }

// TIM1->AF1 DMA address for full transfer
enum {
	TIM1_AF1_ETRSEL = ((1UL<<3)-1) << 14, // ETR source selection
	TIM1_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM1_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM1_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM1_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM1_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM1_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};
inline void tim1_af1_set_etrsel(struct TIM1_Type* p, uint32_t val) { p->AF1 = (p->AF1 & ~TIM1_AF1_ETRSEL) | ((val<<14) & TIM1_AF1_ETRSEL); }
inline uint32_t tim1_af1_get_etrsel(struct TIM1_Type* p) { return (p->AF1 & TIM1_AF1_ETRSEL) >> 14 ; }

// TIM1->AF2 DMA address for full transfer
enum {
	TIM1_AF2_BK2CMP2P = 1UL<<11, // BRK2 COMP2 input polarity
	TIM1_AF2_BK2CMP1P = 1UL<<10, // BRK2 COMP1 input polarity
	TIM1_AF2_BK2INP = 1UL<<9, // BRK2 BKIN input polarity
	TIM1_AF2_BK2DFBK0E = 1UL<<8, // BRK2 DFSDM_BREAK0 enable
	TIM1_AF2_BK2CMP2E = 1UL<<2, // BRK2 COMP2 enable
	TIM1_AF2_BK2CMP1E = 1UL<<1, // BRK2 COMP1 enable
	TIM1_AF2_BK2INE = 1UL<<0, // BRK2 BKIN input enable		
};

// TIM1->TISEL TIM1 timer input selection register
enum {
	TIM1_TISEL_TI4SEL3_0 = ((1UL<<4)-1) << 24, // selects TI4[0] to TI4[15] input
	TIM1_TISEL_TI3SEL3_0 = ((1UL<<4)-1) << 16, // selects TI3[0] to TI3[15] input
	TIM1_TISEL_TI2SEL3_0 = ((1UL<<4)-1) << 8, // selects TI2[0] to TI2[15] input
	TIM1_TISEL_TI1SEL3_0 = ((1UL<<4)-1) << 0, // selects TI1[0] to TI1[15] input		
};
inline void tim1_tisel_set_ti4sel3_0(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI4SEL3_0) | ((val<<24) & TIM1_TISEL_TI4SEL3_0); }
inline void tim1_tisel_set_ti3sel3_0(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI3SEL3_0) | ((val<<16) & TIM1_TISEL_TI3SEL3_0); }
inline void tim1_tisel_set_ti2sel3_0(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI2SEL3_0) | ((val<<8) & TIM1_TISEL_TI2SEL3_0); }
inline void tim1_tisel_set_ti1sel3_0(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI1SEL3_0) | ((val<<0) & TIM1_TISEL_TI1SEL3_0); }
inline uint32_t tim1_tisel_get_ti4sel3_0(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI4SEL3_0) >> 24 ; }
inline uint32_t tim1_tisel_get_ti3sel3_0(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI3SEL3_0) >> 16 ; }
inline uint32_t tim1_tisel_get_ti2sel3_0(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI2SEL3_0) >> 8 ; }
inline uint32_t tim1_tisel_get_ti1sel3_0(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI1SEL3_0) >> 0 ; }

/* General purpose timers */
struct TIM14_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[10]; // @2 
	__IO uint8_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED2[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED3[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED4[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED5[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED7[6]; // @46 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED8[50]; // @54 
	__IO uint8_t TISEL; // @104 TIM timer input selection register
};

// TIM14->CR1 control register 1
enum {
	TIM14_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM14_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM14_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM14_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM14_CR1_URS = 1UL<<2, // Update request source
	TIM14_CR1_UDIS = 1UL<<1, // Update disable
	TIM14_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim14_cr1_set_ckd(struct TIM14_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM14_CR1_CKD) | ((val<<8) & TIM14_CR1_CKD); }
inline uint32_t tim14_cr1_get_ckd(struct TIM14_Type* p) { return (p->CR1 & TIM14_CR1_CKD) >> 8 ; }

// TIM14->DIER DMA/Interrupt enable register
enum {
	TIM14_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM14_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM14->SR status register
enum {
	TIM14_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM14_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM14_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM14->EGR event generation register
enum {
	TIM14_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM14_EGR_UG = 1UL<<0, // Update generation		
};

// TIM14->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM14_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM14_CCMR1_OUTPUT_OC1CE = 1UL<<7, // OC1CE
	TIM14_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // OC1M
	TIM14_CCMR1_OUTPUT_OC1PE = 1UL<<3, // OC1PE
	TIM14_CCMR1_OUTPUT_OC1FE = 1UL<<2, // OC1FE
	TIM14_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // CC1S		
};
inline void tim14_ccmr1_output_set_oc1m(struct TIM14_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM14_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM14_CCMR1_OUTPUT_OC1M); }
inline void tim14_ccmr1_output_set_cc1s(struct TIM14_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM14_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM14_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim14_ccmr1_output_get_oc1m(struct TIM14_Type* p) { return (p->CCMR1_Output & TIM14_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim14_ccmr1_output_get_cc1s(struct TIM14_Type* p) { return (p->CCMR1_Output & TIM14_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM14->CCER capture/compare enable register
enum {
	TIM14_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM14_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM14_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM14->CNT counter
enum {
	TIM14_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM14_CNT_CNT = ((1UL<<16)-1) << 0, // low counter value		
};
inline void tim14_cnt_set_cnt(struct TIM14_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM14_CNT_CNT) | ((val<<0) & TIM14_CNT_CNT); }
inline uint32_t tim14_cnt_get_cnt(struct TIM14_Type* p) { return (p->CNT & TIM14_CNT_CNT) >> 0 ; }

// TIM14->TISEL TIM timer input selection register
enum {
	TIM14_TISEL_TISEL = ((1UL<<4)-1) << 0, // TI1[0] to TI1[15] input selection		
};
inline void tim14_tisel_set_tisel(struct TIM14_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM14_TISEL_TISEL) | ((val<<0) & TIM14_TISEL_TISEL); }
inline uint32_t tim14_tisel_get_tisel(struct TIM14_Type* p) { return (p->TISEL & TIM14_TISEL_TISEL) >> 0 ; }

/* General purpose timers */
struct TIM16_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED12[18]; // @78 
	__IO uint16_t AF1; // @96 TIM17 option register 1
	 uint8_t RESERVED13[6]; // @98 
	__IO uint8_t TISEL; // @104 input selection register
};

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM16_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM16_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM16_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM16_CR1_URS = 1UL<<2, // Update request source
	TIM16_CR1_UDIS = 1UL<<1, // Update disable
	TIM16_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim16_cr1_set_ckd(struct TIM16_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM16_CR1_CKD) | ((val<<8) & TIM16_CR1_CKD); }
inline uint32_t tim16_cr1_get_ckd(struct TIM16_Type* p) { return (p->CR1 & TIM16_CR1_CKD) >> 8 ; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM16_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM16_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM16_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM16_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM16_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM16_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM16_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM16_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM16_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM16_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG = 1UL<<7, // Break generation
	TIM16_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM16_EGR_UG = 1UL<<0, // Update generation		
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_2 = 1UL<<16, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim16_ccmr1_output_set_oc1m(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM16_CCMR1_OUTPUT_OC1M); }
inline void tim16_ccmr1_output_set_cc1s(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM16_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim16_ccmr1_output_get_oc1m(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim16_ccmr1_output_get_cc1s(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM16_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim16_cnt_set_cnt(struct TIM16_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM16_CNT_CNT) | ((val<<0) & TIM16_CNT_CNT); }
inline uint32_t tim16_cnt_get_cnt(struct TIM16_Type* p) { return (p->CNT & TIM16_CNT_CNT) >> 0 ; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKBID = 1UL<<28, // Break Bidirectional
	TIM16_BDTR_BKDSRM = 1UL<<26, // Break Disarm
	TIM16_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM16_BDTR_MOE = 1UL<<15, // Main output enable
	TIM16_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM16_BDTR_BKP = 1UL<<13, // Break polarity
	TIM16_BDTR_BKE = 1UL<<12, // Break enable
	TIM16_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM16_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM16_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM16_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim16_bdtr_set_bkf(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_BKF) | ((val<<16) & TIM16_BDTR_BKF); }
inline void tim16_bdtr_set_lock(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_LOCK) | ((val<<8) & TIM16_BDTR_LOCK); }
inline void tim16_bdtr_set_dtg(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_DTG) | ((val<<0) & TIM16_BDTR_DTG); }
inline uint32_t tim16_bdtr_get_bkf(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_BKF) >> 16 ; }
inline uint32_t tim16_bdtr_get_lock(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_LOCK) >> 8 ; }
inline uint32_t tim16_bdtr_get_dtg(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_DTG) >> 0 ; }

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM16_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim16_dcr_set_dbl(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBL) | ((val<<8) & TIM16_DCR_DBL); }
inline void tim16_dcr_set_dba(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBA) | ((val<<0) & TIM16_DCR_DBA); }
inline uint32_t tim16_dcr_get_dbl(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBL) >> 8 ; }
inline uint32_t tim16_dcr_get_dba(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBA) >> 0 ; }

// TIM16->AF1 TIM17 option register 1
enum {
	TIM16_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarit
	TIM16_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM16_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM16_AF1_BKDFBK1E = 1UL<<8, // BRK DFSDM_BREAK1 enable
	TIM16_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM16_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM16_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM16->TISEL input selection register
enum {
	TIM16_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // selects input		
};
inline void tim16_tisel_set_ti1sel(struct TIM16_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM16_TISEL_TI1SEL) | ((val<<0) & TIM16_TISEL_TI1SEL); }
inline uint32_t tim16_tisel_get_ti1sel(struct TIM16_Type* p) { return (p->TISEL & TIM16_TISEL_TI1SEL) >> 0 ; }


/* General-purpose-timers */
struct TIM2_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	union {  // @28
		__IO uint32_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED5[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED6[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED7[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED8[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED9[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED10[2]; // @78 
	__IO uint8_t OR1; // @80 TIM option register
	 uint8_t RESERVED11[15]; // @81 
	__IO uint32_t AF1; // @96 TIM alternate function option register 1
	 uint8_t RESERVED12[4]; // @100 
	__IO uint16_t TISEL; // @104 TIM alternate function option register 1
};

// TIM2->CR1 control register 1
enum {
	TIM2_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM2_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM2_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM2_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM2_CR1_DIR = 1UL<<4, // Direction
	TIM2_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM2_CR1_URS = 1UL<<2, // Update request source
	TIM2_CR1_UDIS = 1UL<<1, // Update disable
	TIM2_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim2_cr1_set_ckd(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CKD) | ((val<<8) & TIM2_CR1_CKD); }
inline void tim2_cr1_set_cms(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CMS) | ((val<<5) & TIM2_CR1_CMS); }
inline uint32_t tim2_cr1_get_ckd(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CKD) >> 8 ; }
inline uint32_t tim2_cr1_get_cms(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CMS) >> 5 ; }

// TIM2->CR2 control register 2
enum {
	TIM2_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM2_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM2_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
inline void tim2_cr2_set_mms(struct TIM2_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM2_CR2_MMS) | ((val<<4) & TIM2_CR2_MMS); }
inline uint32_t tim2_cr2_get_mms(struct TIM2_Type* p) { return (p->CR2 & TIM2_CR2_MMS) >> 4 ; }

// TIM2->SMCR slave mode control register
enum {
	TIM2_SMCR_TS_4_3 = ((1UL<<2)-1) << 20, // Trigger selection
	TIM2_SMCR_SMS_3 = 1UL<<16, // Slave mode selection - bit 3
	TIM2_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM2_SMCR_ECE = 1UL<<14, // External clock enable
	TIM2_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM2_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM2_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM2_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM2_SMCR_OCCS = 1UL<<3, // OCREF clear selection
	TIM2_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim2_smcr_set_ts_4_3(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS_4_3) | ((val<<20) & TIM2_SMCR_TS_4_3); }
inline void tim2_smcr_set_etps(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETPS) | ((val<<12) & TIM2_SMCR_ETPS); }
inline void tim2_smcr_set_etf(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETF) | ((val<<8) & TIM2_SMCR_ETF); }
inline void tim2_smcr_set_ts(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS) | ((val<<4) & TIM2_SMCR_TS); }
inline void tim2_smcr_set_sms(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_SMS) | ((val<<0) & TIM2_SMCR_SMS); }
inline uint32_t tim2_smcr_get_ts_4_3(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS_4_3) >> 20 ; }
inline uint32_t tim2_smcr_get_etps(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETPS) >> 12 ; }
inline uint32_t tim2_smcr_get_etf(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETF) >> 8 ; }
inline uint32_t tim2_smcr_get_ts(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS) >> 4 ; }
inline uint32_t tim2_smcr_get_sms(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_SMS) >> 0 ; }

// TIM2->DIER DMA/Interrupt enable register
enum {
	TIM2_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM2_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM2_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM2_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM2_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM2_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM2_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM2_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM2_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM2_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM2_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM2_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM2->SR status register
enum {
	TIM2_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM2_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM2_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM2_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM2_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM2_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM2_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM2_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM2_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM2_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM2->EGR event generation register
enum {
	TIM2_EGR_TG = 1UL<<6, // Trigger generation
	TIM2_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM2_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM2_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM2_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM2_EGR_UG = 1UL<<0, // Update generation		
};

// TIM2->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM2_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM2_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM2_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output compare 2 clear enable
	TIM2_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output compare 2 mode
	TIM2_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output compare 2 preload enable
	TIM2_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output compare 2 fast enable
	TIM2_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM2_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output compare 1 clear enable
	TIM2_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output compare 1 mode
	TIM2_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output compare 1 preload enable
	TIM2_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output compare 1 fast enable
	TIM2_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim2_ccmr1_output_set_oc2m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM2_CCMR1_OUTPUT_OC2M); }
inline void tim2_ccmr1_output_set_cc2s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM2_CCMR1_OUTPUT_CC2S); }
inline void tim2_ccmr1_output_set_oc1m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM2_CCMR1_OUTPUT_OC1M); }
inline void tim2_ccmr1_output_set_cc1s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM2_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim2_ccmr1_output_get_oc2m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim2_ccmr1_output_get_cc2s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim2_ccmr1_output_get_oc1m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim2_ccmr1_output_get_cc1s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM2->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM2_CCMR2_OUTPUT_OC4M_3 = 1UL<<24, // Output Compare 4 mode - bit 3
	TIM2_CCMR2_OUTPUT_OC3M_3 = 1UL<<16, // Output Compare 3 mode - bit 3
	TIM2_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM2_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM2_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM2_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM2_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM2_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM2_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM2_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM2_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM2_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
inline void tim2_ccmr2_output_set_oc4m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM2_CCMR2_OUTPUT_OC4M); }
inline void tim2_ccmr2_output_set_cc4s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM2_CCMR2_OUTPUT_CC4S); }
inline void tim2_ccmr2_output_set_oc3m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM2_CCMR2_OUTPUT_OC3M); }
inline void tim2_ccmr2_output_set_cc3s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM2_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim2_ccmr2_output_get_oc4m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim2_ccmr2_output_get_cc4s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim2_ccmr2_output_get_oc3m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim2_ccmr2_output_get_cc3s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM2->CCER capture/compare enable register
enum {
	TIM2_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM2_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM2_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM2_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM2_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM2->CNT counter
enum {
	TIM2_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value (TIM2 only)
	TIM2_CNT_CNT_L = ((1UL<<16)-1) << 0, // Low counter value		
};
inline void tim2_cnt_set_cnt_h(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_H) | ((val<<16) & TIM2_CNT_CNT_H); }
inline void tim2_cnt_set_cnt_l(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_L) | ((val<<0) & TIM2_CNT_CNT_L); }
inline uint32_t tim2_cnt_get_cnt_h(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_H) >> 16 ; }
inline uint32_t tim2_cnt_get_cnt_l(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_L) >> 0 ; }

// TIM2->ARR auto-reload register
enum {
	TIM2_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value (TIM2 only)
	TIM2_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
inline void tim2_arr_set_arr_h(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_H) | ((val<<16) & TIM2_ARR_ARR_H); }
inline void tim2_arr_set_arr_l(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_L) | ((val<<0) & TIM2_ARR_ARR_L); }
inline uint32_t tim2_arr_get_arr_h(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_H) >> 16 ; }
inline uint32_t tim2_arr_get_arr_l(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_L) >> 0 ; }

// TIM2->CCR1 capture/compare register 1
enum {
	TIM2_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value (TIM2 only)
	TIM2_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
inline void tim2_ccr1_set_ccr1_h(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_H) | ((val<<16) & TIM2_CCR1_CCR1_H); }
inline void tim2_ccr1_set_ccr1_l(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_L) | ((val<<0) & TIM2_CCR1_CCR1_L); }
inline uint32_t tim2_ccr1_get_ccr1_h(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_H) >> 16 ; }
inline uint32_t tim2_ccr1_get_ccr1_l(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_L) >> 0 ; }

// TIM2->CCR2 capture/compare register 2
enum {
	TIM2_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value (TIM2 only)
	TIM2_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
inline void tim2_ccr2_set_ccr2_h(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_H) | ((val<<16) & TIM2_CCR2_CCR2_H); }
inline void tim2_ccr2_set_ccr2_l(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_L) | ((val<<0) & TIM2_CCR2_CCR2_L); }
inline uint32_t tim2_ccr2_get_ccr2_h(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_H) >> 16 ; }
inline uint32_t tim2_ccr2_get_ccr2_l(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_L) >> 0 ; }

// TIM2->CCR3 capture/compare register 3
enum {
	TIM2_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value (TIM2 only)
	TIM2_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr3_set_ccr3_h(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_H) | ((val<<16) & TIM2_CCR3_CCR3_H); }
inline void tim2_ccr3_set_ccr3_l(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_L) | ((val<<0) & TIM2_CCR3_CCR3_L); }
inline uint32_t tim2_ccr3_get_ccr3_h(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_H) >> 16 ; }
inline uint32_t tim2_ccr3_get_ccr3_l(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_L) >> 0 ; }

// TIM2->CCR4 capture/compare register 4
enum {
	TIM2_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value (TIM2 only)
	TIM2_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr4_set_ccr4_h(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_H) | ((val<<16) & TIM2_CCR4_CCR4_H); }
inline void tim2_ccr4_set_ccr4_l(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_L) | ((val<<0) & TIM2_CCR4_CCR4_L); }
inline uint32_t tim2_ccr4_get_ccr4_h(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_H) >> 16 ; }
inline uint32_t tim2_ccr4_get_ccr4_l(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_L) >> 0 ; }

// TIM2->DCR DMA control register
enum {
	TIM2_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM2_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim2_dcr_set_dbl(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBL) | ((val<<8) & TIM2_DCR_DBL); }
inline void tim2_dcr_set_dba(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBA) | ((val<<0) & TIM2_DCR_DBA); }
inline uint32_t tim2_dcr_get_dbl(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBL) >> 8 ; }
inline uint32_t tim2_dcr_get_dba(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBA) >> 0 ; }

// TIM2->OR1 TIM option register
enum {
	TIM2_OR1_IOCREF_CLR = 1UL<<0, // IOCREF_CLR		
};

// TIM2->AF1 TIM alternate function option register 1
enum {
	TIM2_AF1_ETRSEL = ((1UL<<4)-1) << 14, // External trigger source selection		
};
inline void tim2_af1_set_etrsel(struct TIM2_Type* p, uint32_t val) { p->AF1 = (p->AF1 & ~TIM2_AF1_ETRSEL) | ((val<<14) & TIM2_AF1_ETRSEL); }
inline uint32_t tim2_af1_get_etrsel(struct TIM2_Type* p) { return (p->AF1 & TIM2_AF1_ETRSEL) >> 14 ; }

// TIM2->TISEL TIM alternate function option register 1
enum {
	TIM2_TISEL_TI2SEL = ((1UL<<4)-1) << 8, // TI2SEL
	TIM2_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // TI1SEL		
};
inline void tim2_tisel_set_ti2sel(struct TIM2_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM2_TISEL_TI2SEL) | ((val<<8) & TIM2_TISEL_TI2SEL); }
inline void tim2_tisel_set_ti1sel(struct TIM2_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM2_TISEL_TI1SEL) | ((val<<0) & TIM2_TISEL_TI1SEL); }
inline uint32_t tim2_tisel_get_ti2sel(struct TIM2_Type* p) { return (p->TISEL & TIM2_TISEL_TI2SEL) >> 8 ; }
inline uint32_t tim2_tisel_get_ti1sel(struct TIM2_Type* p) { return (p->TISEL & TIM2_TISEL_TI1SEL) >> 0 ; }


/* Universal synchronous asynchronous receiver transmitter */
struct USART1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint16_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint16_t GTPR; // @16 Guard time and prescaler register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED2[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED3[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
	 uint8_t RESERVED4[2]; // @42 
	__IO uint8_t PRESC; // @44 Prescaler register
};

// USART1->CR1 Control register 1
enum {
	USART1_CR1_RXFFIE = 1UL<<31, // RXFIFO Full interrupt enable
	USART1_CR1_TXFEIE = 1UL<<30, // TXFIFO empty interrupt enable
	USART1_CR1_FIFOEN = 1UL<<29, // FIFO mode enable
	USART1_CR1_M1 = 1UL<<28, // Word length
	USART1_CR1_EOBIE = 1UL<<27, // End of Block interrupt enable
	USART1_CR1_RTOIE = 1UL<<26, // Receiver timeout interrupt enable
	USART1_CR1_DEAT = ((1UL<<5)-1) << 21, // DEAT
	USART1_CR1_DEDT = ((1UL<<5)-1) << 16, // DEDT
	USART1_CR1_OVER8 = 1UL<<15, // Oversampling mode
	USART1_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	USART1_CR1_MME = 1UL<<13, // Mute mode enable
	USART1_CR1_M0 = 1UL<<12, // Word length
	USART1_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	USART1_CR1_PCE = 1UL<<10, // Parity control enable
	USART1_CR1_PS = 1UL<<9, // Parity selection
	USART1_CR1_PEIE = 1UL<<8, // PE interrupt enable
	USART1_CR1_TXEIE = 1UL<<7, // interrupt enable
	USART1_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	USART1_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	USART1_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	USART1_CR1_TE = 1UL<<3, // Transmitter enable
	USART1_CR1_RE = 1UL<<2, // Receiver enable
	USART1_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	USART1_CR1_UE = 1UL<<0, // USART enable		
};
inline void usart1_cr1_set_deat(struct USART1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~USART1_CR1_DEAT) | ((val<<21) & USART1_CR1_DEAT); }
inline void usart1_cr1_set_dedt(struct USART1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~USART1_CR1_DEDT) | ((val<<16) & USART1_CR1_DEDT); }
inline uint32_t usart1_cr1_get_deat(struct USART1_Type* p) { return (p->CR1 & USART1_CR1_DEAT) >> 21 ; }
inline uint32_t usart1_cr1_get_dedt(struct USART1_Type* p) { return (p->CR1 & USART1_CR1_DEDT) >> 16 ; }

// USART1->CR2 Control register 2
enum {
	USART1_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	USART1_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	USART1_CR2_RTOEN = 1UL<<23, // Receiver timeout enable
	USART1_CR2_ABRMOD = ((1UL<<2)-1) << 21, // Auto baud rate mode
	USART1_CR2_ABREN = 1UL<<20, // Auto baud rate enable
	USART1_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	USART1_CR2_TAINV = 1UL<<18, // Binary data inversion
	USART1_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	USART1_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	USART1_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	USART1_CR2_LINEN = 1UL<<14, // LIN mode enable
	USART1_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	USART1_CR2_CLKEN = 1UL<<11, // Clock enable
	USART1_CR2_CPOL = 1UL<<10, // Clock polarity
	USART1_CR2_CPHA = 1UL<<9, // Clock phase
	USART1_CR2_LBCL = 1UL<<8, // Last bit clock pulse
	USART1_CR2_LBDIE = 1UL<<6, // LIN break detection interrupt enable
	USART1_CR2_LBDL = 1UL<<5, // LIN break detection length
	USART1_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection
	USART1_CR2_DIS_NSS = 1UL<<3, // When the DSI_NSS bit is set, the NSS pin input will be ignored
	USART1_CR2_SLVEN = 1UL<<0, // Synchronous Slave mode enable		
};
inline void usart1_cr2_set_add4_7(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD4_7) | ((val<<28) & USART1_CR2_ADD4_7); }
inline void usart1_cr2_set_add0_3(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD0_3) | ((val<<24) & USART1_CR2_ADD0_3); }
inline void usart1_cr2_set_abrmod(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ABRMOD) | ((val<<21) & USART1_CR2_ABRMOD); }
inline void usart1_cr2_set_stop(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_STOP) | ((val<<12) & USART1_CR2_STOP); }
inline uint32_t usart1_cr2_get_add4_7(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD4_7) >> 28 ; }
inline uint32_t usart1_cr2_get_add0_3(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD0_3) >> 24 ; }
inline uint32_t usart1_cr2_get_abrmod(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ABRMOD) >> 21 ; }
inline uint32_t usart1_cr2_get_stop(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_STOP) >> 12 ; }

// USART1->CR3 Control register 3
enum {
	USART1_CR3_TXFTCFG = ((1UL<<3)-1) << 29, // TXFIFO threshold configuration
	USART1_CR3_RXFTIE = 1UL<<28, // RXFIFO threshold interrupt enable
	USART1_CR3_RXFTCFG = ((1UL<<3)-1) << 25, // Receive FIFO threshold configuration
	USART1_CR3_TCBGTIE = 1UL<<24, // Tr Complete before guard time, interrupt enable
	USART1_CR3_TXFTIE = 1UL<<23, // threshold interrupt enable
	USART1_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	USART1_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	USART1_CR3_SCARCNT = ((1UL<<3)-1) << 17, // Smartcard auto-retry count
	USART1_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	USART1_CR3_DEM = 1UL<<14, // Driver enable mode
	USART1_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	USART1_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	USART1_CR3_ONEBIT = 1UL<<11, // One sample bit method enable
	USART1_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	USART1_CR3_CTSE = 1UL<<9, // CTS enable
	USART1_CR3_RTSE = 1UL<<8, // RTS enable
	USART1_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	USART1_CR3_DMAR = 1UL<<6, // DMA enable receiver
	USART1_CR3_SCEN = 1UL<<5, // Smartcard mode enable
	USART1_CR3_NACK = 1UL<<4, // Smartcard NACK enable
	USART1_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	USART1_CR3_IRLP = 1UL<<2, // Ir low-power
	USART1_CR3_IREN = 1UL<<1, // Ir mode enable
	USART1_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void usart1_cr3_set_txftcfg(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_TXFTCFG) | ((val<<29) & USART1_CR3_TXFTCFG); }
inline void usart1_cr3_set_rxftcfg(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_RXFTCFG) | ((val<<25) & USART1_CR3_RXFTCFG); }
inline void usart1_cr3_set_wus(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_WUS) | ((val<<20) & USART1_CR3_WUS); }
inline void usart1_cr3_set_scarcnt(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_SCARCNT) | ((val<<17) & USART1_CR3_SCARCNT); }
inline uint32_t usart1_cr3_get_txftcfg(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_TXFTCFG) >> 29 ; }
inline uint32_t usart1_cr3_get_rxftcfg(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_RXFTCFG) >> 25 ; }
inline uint32_t usart1_cr3_get_wus(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_WUS) >> 20 ; }
inline uint32_t usart1_cr3_get_scarcnt(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_SCARCNT) >> 17 ; }

// USART1->BRR Baud rate register
enum {
	USART1_BRR_BRR_4_15 = ((1UL<<12)-1) << 4, // BRR_4_15
	USART1_BRR_BRR_0_3 = ((1UL<<4)-1) << 0, // BRR_0_3		
};
inline void usart1_brr_set_brr_4_15(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_BRR_4_15) | ((val<<4) & USART1_BRR_BRR_4_15); }
inline void usart1_brr_set_brr_0_3(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_BRR_0_3) | ((val<<0) & USART1_BRR_BRR_0_3); }
inline uint32_t usart1_brr_get_brr_4_15(struct USART1_Type* p) { return (p->BRR & USART1_BRR_BRR_4_15) >> 4 ; }
inline uint32_t usart1_brr_get_brr_0_3(struct USART1_Type* p) { return (p->BRR & USART1_BRR_BRR_0_3) >> 0 ; }

// USART1->GTPR Guard time and prescaler register
enum {
	USART1_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	USART1_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
inline void usart1_gtpr_set_gt(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_GT) | ((val<<8) & USART1_GTPR_GT); }
inline void usart1_gtpr_set_psc(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_PSC) | ((val<<0) & USART1_GTPR_PSC); }
inline uint32_t usart1_gtpr_get_gt(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_GT) >> 8 ; }
inline uint32_t usart1_gtpr_get_psc(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_PSC) >> 0 ; }

// USART1->RTOR Receiver timeout register
enum {
	USART1_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	USART1_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
inline void usart1_rtor_set_blen(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_BLEN) | ((val<<24) & USART1_RTOR_BLEN); }
inline void usart1_rtor_set_rto(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_RTO) | ((val<<0) & USART1_RTOR_RTO); }
inline uint32_t usart1_rtor_get_blen(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_BLEN) >> 24 ; }
inline uint32_t usart1_rtor_get_rto(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_RTO) >> 0 ; }

// USART1->RQR Request register
enum {
	USART1_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	USART1_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	USART1_RQR_MMRQ = 1UL<<2, // Mute mode request
	USART1_RQR_SBKRQ = 1UL<<1, // Send break request
	USART1_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// USART1->ISR Interrupt & status register
enum {
	USART1_ISR_TXFT = 1UL<<27, // TXFIFO threshold flag
	USART1_ISR_RXFT = 1UL<<26, // RXFIFO threshold flag
	USART1_ISR_TCBGT = 1UL<<25, // Transmission complete before guard time flag
	USART1_ISR_RXFF = 1UL<<24, // RXFIFO Full
	USART1_ISR_TXFE = 1UL<<23, // TXFIFO Empty
	USART1_ISR_REACK = 1UL<<22, // REACK
	USART1_ISR_TEACK = 1UL<<21, // TEACK
	USART1_ISR_WUF = 1UL<<20, // WUF
	USART1_ISR_RWU = 1UL<<19, // RWU
	USART1_ISR_SBKF = 1UL<<18, // SBKF
	USART1_ISR_CMF = 1UL<<17, // CMF
	USART1_ISR_BUSY = 1UL<<16, // BUSY
	USART1_ISR_ABRF = 1UL<<15, // ABRF
	USART1_ISR_ABRE = 1UL<<14, // ABRE
	USART1_ISR_UDR = 1UL<<13, // SPI slave underrun error flag
	USART1_ISR_EOBF = 1UL<<12, // EOBF
	USART1_ISR_RTOF = 1UL<<11, // RTOF
	USART1_ISR_CTS = 1UL<<10, // CTS
	USART1_ISR_CTSIF = 1UL<<9, // CTSIF
	USART1_ISR_LBDF = 1UL<<8, // LBDF
	USART1_ISR_TXE = 1UL<<7, // TXE
	USART1_ISR_TC = 1UL<<6, // TC
	USART1_ISR_RXNE = 1UL<<5, // RXNE
	USART1_ISR_IDLE = 1UL<<4, // IDLE
	USART1_ISR_ORE = 1UL<<3, // ORE
	USART1_ISR_NF = 1UL<<2, // NF
	USART1_ISR_FE = 1UL<<1, // FE
	USART1_ISR_PE = 1UL<<0, // PE		
};

// USART1->ICR Interrupt flag clear register
enum {
	USART1_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	USART1_ICR_CMCF = 1UL<<17, // Character match clear flag
	USART1_ICR_UDRCF = 1UL<<13, // SPI slave underrun clear flag
	USART1_ICR_EOBCF = 1UL<<12, // End of block clear flag
	USART1_ICR_RTOCF = 1UL<<11, // Receiver timeout clear flag
	USART1_ICR_CTSCF = 1UL<<9, // CTS clear flag
	USART1_ICR_LBDCF = 1UL<<8, // LIN break detection clear flag
	USART1_ICR_TCBGTCF = 1UL<<7, // Transmission complete before Guard time clear flag
	USART1_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	USART1_ICR_TXFECF = 1UL<<5, // TXFIFO empty clear flag
	USART1_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	USART1_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	USART1_ICR_NCF = 1UL<<2, // Noise detected clear flag
	USART1_ICR_FECF = 1UL<<1, // Framing error clear flag
	USART1_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// USART1->RDR Receive data register
enum {
	USART1_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t usart1_rdr_get_rdr(struct USART1_Type* p) { return (p->RDR & USART1_RDR_RDR) >> 0 ; }

// USART1->TDR Transmit data register
enum {
	USART1_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void usart1_tdr_set_tdr(struct USART1_Type* p, uint32_t val) { p->TDR = (p->TDR & ~USART1_TDR_TDR) | ((val<<0) & USART1_TDR_TDR); }
inline uint32_t usart1_tdr_get_tdr(struct USART1_Type* p) { return (p->TDR & USART1_TDR_TDR) >> 0 ; }

// USART1->PRESC Prescaler register
enum {
	USART1_PRESC_PRESCALER = ((1UL<<4)-1) << 0, // Clock prescaler		
};
inline void usart1_presc_set_prescaler(struct USART1_Type* p, uint32_t val) { p->PRESC = (p->PRESC & ~USART1_PRESC_PRESCALER) | ((val<<0) & USART1_PRESC_PRESCALER); }
inline uint32_t usart1_presc_get_prescaler(struct USART1_Type* p) { return (p->PRESC & USART1_PRESC_PRESCALER) >> 0 ; }


/* System configuration controller */
struct VREFBUF_Type {
	__IO uint8_t CSR; // @0 VREFBUF control and status register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CCR; // @4 VREFBUF calibration control register
};

// VREFBUF->CSR VREFBUF control and status register
enum {
	VREFBUF_CSR_VRS = ((1UL<<3)-1) << 4, // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
	VREFBUF_CSR_VRR = 1UL<<3, // Voltage reference buffer ready
	VREFBUF_CSR_HIZ = 1UL<<1, // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
	VREFBUF_CSR_ENVR = 1UL<<0, // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.		
};
inline void vrefbuf_csr_set_vrs(struct VREFBUF_Type* p, uint32_t val) { p->CSR = (p->CSR & ~VREFBUF_CSR_VRS) | ((val<<4) & VREFBUF_CSR_VRS); }
inline uint32_t vrefbuf_csr_get_vrs(struct VREFBUF_Type* p) { return (p->CSR & VREFBUF_CSR_VRS) >> 4 ; }

// VREFBUF->CCR VREFBUF calibration control register
enum {
	VREFBUF_CCR_TRIM = ((1UL<<6)-1) << 0, // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.		
};
inline void vrefbuf_ccr_set_trim(struct VREFBUF_Type* p, uint32_t val) { p->CCR = (p->CCR & ~VREFBUF_CCR_TRIM) | ((val<<0) & VREFBUF_CCR_TRIM); }
inline uint32_t vrefbuf_ccr_get_trim(struct VREFBUF_Type* p) { return (p->CCR & VREFBUF_CCR_TRIM) >> 0 ; }

/* System window watchdog */
struct WWDG_Type {
	__IO uint8_t CR; // @0 Control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CFR; // @4 Configuration register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint8_t SR; // @8 Status register
};

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL<<7, // Activation bit
	WWDG_CR_T = ((1UL<<7)-1) << 0, // 7-bit counter (MSB to LSB)		
};
inline void wwdg_cr_set_t(struct WWDG_Type* p, uint32_t val) { p->CR = (p->CR & ~WWDG_CR_T) | ((val<<0) & WWDG_CR_T); }
inline uint32_t wwdg_cr_get_t(struct WWDG_Type* p) { return (p->CR & WWDG_CR_T) >> 0 ; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_WDGTB = ((1UL<<3)-1) << 11, // Timer base
	WWDG_CFR_EWI = 1UL<<9, // Early wakeup interrupt
	WWDG_CFR_W = ((1UL<<7)-1) << 0, // 7-bit window value		
};
inline void wwdg_cfr_set_wdgtb(struct WWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_WDGTB) | ((val<<11) & WWDG_CFR_WDGTB); }
inline void wwdg_cfr_set_w(struct WWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_W) | ((val<<0) & WWDG_CFR_W); }
inline uint32_t wwdg_cfr_get_wdgtb(struct WWDG_Type* p) { return (p->CFR & WWDG_CFR_WDGTB) >> 11 ; }
inline uint32_t wwdg_cfr_get_w(struct WWDG_Type* p) { return (p->CFR & WWDG_CFR_W) >> 0 ; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL<<0, // Early wakeup interrupt flag		
};


#undef __I
#undef __O
#undef __IO


struct ADC_Type	ADC;	// @0x40012400 
struct CRC_Type	CRC;	// @0x40023000 
struct DBG_Type	DBG;	// @0x40015800 
struct DMA_Type	DMA;	// @0x40020000 
struct DMAMUX_Type	DMAMUX;	// @0x40020800 
struct EXTI_Type	EXTI;	// @0x40021800 
struct FLASH_Type	FLASH;	// @0x40022000 
struct FPU_Type	FPU;	// @0xE000EF34 
struct FPU_CPACR_Type	FPU_CPACR;	// @0xE000ED88 
struct GPIOA_Type	GPIOA;	// @0x50000000 
struct GPIOA_Type 	GPIOB;	// @0x50000400
struct GPIOA_Type 	GPIOC;	// @0x50000800
struct GPIOA_Type 	GPIOD;	// @0x50000C00
struct GPIOA_Type 	GPIOF;	// @0x50001400
struct I2C1_Type	I2C1;	// @0x40005400 
struct I2C1_Type 	I2C2;	// @0x40005800
struct IWDG_Type	IWDG;	// @0x40003000 
struct LPTIM1_Type	LPTIM1;	// @0x40007C00 
struct LPTIM1_Type 	LPTIM2;	// @0x40009400
struct LPUART_Type	LPUART;	// @0x40008000 
struct MPU_Type	MPU;	// @0xE000ED90 
struct NVIC_Type	NVIC;	// @0xE000E100 
struct NVIC_STIR_Type	NVIC_STIR;	// @0xE000EF00 
struct PWR_Type	PWR;	// @0x40007000 
struct RCC_Type	RCC;	// @0x40021000 
struct RTC_Type	RTC;	// @0x40002800 
struct SCB_Type	SCB;	// @0xE000ED00 
struct SCB_ACTRL_Type	SCB_ACTRL;	// @0xE000E008 
struct SPI1_Type	SPI1;	// @0x40013000 
struct SPI1_Type 	SPI2;	// @0x40003800
struct STK_Type	STK;	// @0xE000E010 
struct SYSCFG_Type	SYSCFG;	// @0x40010000 
struct SYSCFG_ITLINE_Type	SYSCFG_ITLINE;	// @0x40010080 
struct TAMP_Type	TAMP;	// @0x4000B000 
struct TIM1_Type	TIM1;	// @0x40012C00 
struct TIM14_Type	TIM14;	// @0x40002000 
struct TIM16_Type	TIM16;	// @0x40014400 
struct TIM16_Type 	TIM17;	// @0x40014800
struct TIM2_Type	TIM2;	// @0x40000000 
struct TIM2_Type 	TIM3;	// @0x40000400
struct USART1_Type	USART1;	// @0x40013800 
struct USART1_Type 	USART2;	// @0x40004400
struct VREFBUF_Type	VREFBUF;	// @0x40010030 
struct WWDG_Type	WWDG;	// @0x40002C00 

