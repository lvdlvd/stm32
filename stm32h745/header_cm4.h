#pragma once

// Generated enums and structures for device STM32H7x5_CM4 version 1.1
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ           

	//  Cortex-CM4 Processor Exceptions Numbers 
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt                           
	Reserved_3_IRQn       = -13,
	MemoryManagement_IRQn = -12, // 4 Memory Management Interrupt            
	BusFault_IRQn         = -11, // 5 Bus Fault Interrupt                    
	UsageFault_IRQn       = -10, // 6 Usage Fault Interrupt                  
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 SV Call Interrupt                     
	DebugMonitor_IRQn     = -4, // 12 Debug Monitor Interrupt               
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Pend SV Interrupt                     
	SysTick_IRQn          = -1, // 15 System Tick Interrupt                 

	//  Device specific Interrupt Numbers
	WWDG2_IRQn = 0, // Window Watchdog interrupt
	PVD_PVM_IRQn = 1, // PVD through EXTI line
	RTC_TAMP_STAMP_CSS_LSE_IRQn = 2, // RTC tamper, timestamp
	RTC_WKUP_IRQn = 3, // RTC Wakeup interrupt
	FLASH_IRQn = 4, // Flash memory
	RCC_IRQn = 5, // RCC global interrupt
	EXTI0_IRQn = 6, // EXTI Line 0 interrupt
	EXTI1_IRQn = 7, // EXTI Line 1 interrupt
	EXTI2_IRQn = 8, // EXTI Line 2 interrupt
	EXTI3_IRQn = 9, // EXTI Line 3interrupt
	EXTI4_IRQn = 10, // EXTI Line 4interrupt
	DMA_STR0_IRQn = 11, // DMA1 Stream0
	DMA_STR1_IRQn = 12, // DMA1 Stream1
	DMA_STR2_IRQn = 13, // DMA1 Stream2
	DMA_STR3_IRQn = 14, // DMA1 Stream3
	DMA_STR4_IRQn = 15, // DMA1 Stream4
	DMA_STR5_IRQn = 16, // DMA1 Stream5
	DMA_STR6_IRQn = 17, // DMA1 Stream6
	ADC1_2_IRQn = 18, // ADC1 and ADC2
	FDCAN1_IT0_IRQn = 19, // FDCAN1 Interrupt 0
	FDCAN2_IT0_IRQn = 20, // FDCAN2 Interrupt 0
	FDCAN1_IT1_IRQn = 21, // FDCAN1 Interrupt 1
	FDCAN2_IT1_IRQn = 22, // FDCAN2 Interrupt 1
	EXTI9_5_IRQn = 23, // EXTI Line[9:5] interrupts
	TIM1_BRK_IRQn = 24, // TIM1 break interrupt
	TIM1_UP_IRQn = 25, // TIM1 update interrupt
	TIM1_TRG_COM_IRQn = 26, // TIM1 trigger and commutation
	TIM_CC_IRQn = 27, // TIM1 capture / compare
	TIM2_IRQn = 28, // TIM2 global interrupt
	TIM3_IRQn = 29, // TIM3 global interrupt
	TIM4_IRQn = 30, // TIM4 global interrupt
	I2C1_EV_IRQn = 31, // I2C1 event interrupt
	I2C1_ER_IRQn = 32, // I2C1 error interrupt
	I2C2_EV_IRQn = 33, // I2C2 event interrupt
	I2C2_ER_IRQn = 34, // I2C2 error interrupt
	SPI1_IRQn = 35, // SPI1 global interrupt
	SPI2_IRQn = 36, // SPI2 global interrupt
	USART1_IRQn = 37, // USART1 global interrupt
	USART2_IRQn = 38, // USART2 global interrupt
	USART3_IRQn = 39, // USART3 global interrupt
	EXTI15_10_IRQn = 40, // EXTI Line[15:10] interrupts
	RTC_ALARM_IRQn = 41, // RTC alarms (A and B)
	TIM8_BRK_TIM12_IRQn = 43, // TIM8 and 12 break global
	TIM8_UP_TIM13_IRQn = 44, // TIM8 and 13 update global
	TIM8_TRG_COM_TIM14_IRQn = 45, // TIM8 and 14 trigger /commutation and global
	TIM8_CC_IRQn = 46, // TIM8 capture / compare
	DMA1_STR7_IRQn = 47, // DMA1 Stream7
	FMC_IRQn = 48, // FMC global interrupt
	SDMMC1_IRQn = 49, // SDMMC global interrupt
	TIM5_IRQn = 50, // TIM5 global interrupt
	SPI3_IRQn = 51, // SPI3 global interrupt
	UART4_IRQn = 52, // UART4 global interrupt
	UART5_IRQn = 53, // UART5 global interrupt
	TIM6_DAC_IRQn = 54, // TIM6 global interrupt
	TIM7_IRQn = 55, // TIM7 global interrupt
	DMA2_STR0_IRQn = 56, // DMA2 Stream0 interrupt
	DMA2_STR1_IRQn = 57, // DMA2 Stream1 interrupt
	DMA2_STR2_IRQn = 58, // DMA2 Stream2 interrupt
	DMA2_STR3_IRQn = 59, // DMA2 Stream3 interrupt
	DMA2_STR4_IRQn = 60, // DMA2 Stream4 interrupt
	ETH_IRQn = 61, // Ethernet global interrupt
	ETH_WKUP_IRQn = 62, // Ethernet wakeup through EXTI
	FDCAN_CAL_IRQn = 63, // CAN2TX interrupts
	cm7_sev_it_IRQn = 64, // ArmÃ‚Â® CortexÃ‚Â®-M7 Send
	DMA2_STR5_IRQn = 68, // DMA2 Stream5 interrupt
	DMA2_STR6_IRQn = 69, // DMA2 Stream6 interrupt
	DMA2_STR7_IRQn = 70, // DMA2 Stream7 interrupt
	USART6_IRQn = 71, // USART6 global interrupt
	I2C3_EV_IRQn = 72, // I2C3 event interrupt
	I2C3_ER_IRQn = 73, // I2C3 error interrupt
	OTG_HS_EP1_OUT_IRQn = 74, // OTG_HS out global interrupt
	OTG_HS_EP1_IN_IRQn = 75, // OTG_HS in global interrupt
	OTG_HS_WKUP_IRQn = 76, // OTG_HS wakeup interrupt
	OTG_HS_IRQn = 77, // OTG_HS global interrupt
	DCMI_IRQn = 78, // DCMI global interrupt
	CRYP_IRQn = 79, // CRYP global interrupt
	HASH_RNG_IRQn = 80, // HASH and RNG
	FPU_IRQn = 81, // Floating point unit interrupt
	UART7_IRQn = 82, // UART7 global interrupt
	UART8_IRQn = 83, // UART8 global interrupt
	SPI4_IRQn = 84, // SPI4 global interrupt
	SPI5_IRQn = 85, // SPI5 global interrupt
	SPI6_IRQn = 86, // SPI6 global interrupt
	SAI1_IRQn = 87, // SAI1 global interrupt
	LTDC_IRQn = 88, // LCD-TFT global interrupt
	LTDC_ER_IRQn = 89, // LCD-TFT error interrupt
	DMA2D_IRQn = 90, // DMA2D global interrupt
	SAI2_IRQn = 91, // SAI2 global interrupt
	QUADSPI_IRQn = 92, // QuadSPI global interrupt
	LPTIM1_IRQn = 93, // LPTIM1 global interrupt
	CEC_IRQn = 94, // HDMI-CEC global interrupt
	I2C4_EV_IRQn = 95, // I2C4 event interrupt
	I2C4_ER_IRQn = 96, // I2C4 error interrupt
	SPDIF_IRQn = 97, // SPDIFRX global interrupt
	OTG_FS_EP1_OUT_IRQn = 98, // OTG_FS out global interrupt
	OTG_FS_EP1_IN_IRQn = 99, // OTG_FS in global interrupt
	OTG_FS_WKUP_IRQn = 100, // OTG_FS wakeup
	OTG_FS_IRQn = 101, // OTG_FS global interrupt
	DMAMUX1_OV_IRQn = 102, // DMAMUX1 overrun interrupt
	HRTIM1_MST_IRQn = 103, // HRTIM1 master timer interrupt
	HRTIM1_TIMA_IRQn = 104, // HRTIM1 timer A interrupt
	HRTIM_TIMB_IRQn = 105, // HRTIM1 timer B interrupt
	HRTIM1_TIMC_IRQn = 106, // HRTIM1 timer C interrupt
	HRTIM1_TIMD_IRQn = 107, // HRTIM1 timer D interrupt
	HRTIM_TIME_IRQn = 108, // HRTIM1 timer E interrupt
	HRTIM1_FLT_IRQn = 109, // HRTIM1 fault interrupt
	DFSDM1_FLT0_IRQn = 110, // DFSDM1 filter 0 interrupt
	DFSDM1_FLT1_IRQn = 111, // DFSDM1 filter 1 interrupt
	DFSDM1_FLT2_IRQn = 112, // DFSDM1 filter 2 interrupt
	DFSDM1_FLT3_IRQn = 113, // DFSDM1 filter 3 interrupt
	SAI3_IRQn = 114, // SAI3 global interrupt
	SWPMI1_IRQn = 115, // SWPMI global interrupt
	TIM15_IRQn = 116, // TIM15 global interrupt
	TIM16_IRQn = 117, // TIM16 global interrupt
	TIM17_IRQn = 118, // TIM17 global interrupt
	MDIOS_WKUP_IRQn = 119, // MDIOS wakeup
	MDIOS_IRQn = 120, // MDIOS global interrupt
	JPEG_IRQn = 121, // JPEG global interrupt
	MDMA_IRQn = 122, // MDMA
	SDMMC_IRQn = 124, // SDMMC global interrupt
	HSEM0_IRQn = 125, // HSEM global interrupt 1
	ADC3_IRQn = 127, // ADC3 global interrupt
	DMAMUX2_OVR_IRQn = 128, // DMAMUX2 overrun interrupt
	BDMA_CH1_IRQn = 129, // BDMA channel 1 interrupt
	BDMA_CH2_IRQn = 130, // BDMA channel 2 interrupt
	BDMA_CH3_IRQn = 131, // BDMA channel 3 interrupt
	BDMA_CH4_IRQn = 132, // BDMA channel 4 interrupt
	BDMA_CH5_IRQn = 133, // BDMA channel 5 interrupt
	BDMA_CH6_IRQn = 134, // BDMA channel 6 interrupt
	BDMA_CH7_IRQn = 135, // BDMA channel 7 interrupt
	BDMA_CH8_IRQn = 136, // BDMA channel 8 interrupt
	COMP_IRQn = 137, // COMP1 and COMP2
	LPTIM2_IRQn = 138, // LPTIM2 timer interrupt
	LPTIM3_IRQn = 139, // LPTIM2 timer interrupt
	LPTIM4_IRQn = 140, // LPTIM2 timer interrupt
	LPTIM5_IRQn = 141, // LPTIM2 timer interrupt
	LPUART_IRQn = 142, // LPUART global interrupt
	WWDG1_RST_IRQn = 143, // Window Watchdog interrupt
	CRS_IRQn = 144, // Clock Recovery System globa
	SAI4_IRQn = 146, // SAI4 global interrupt
	HOLD_CORE_IRQn = 148, // CPU2 hold
	WKUP_IRQn = 149, // WKUP1 to WKUP6 pins
};


#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions


/* Access control */
struct AC_Type {
	__IO uint8_t ITCMCR; // @0 Instruction and Data Tightly-Coupled Memory Control Registers
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t DTCMCR; // @4 Instruction and Data Tightly-Coupled Memory Control Registers
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t AHBPCR; // @8 AHBP Control register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint8_t CACR; // @12 Auxiliary Cache Control register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t AHBSCR; // @16 AHB Slave Control register
	 uint8_t RESERVED4[6]; // @18 
	__IO uint16_t ABFSR; // @24 Auxiliary Bus Fault Status register
};

// AC->ITCMCR Instruction and Data Tightly-Coupled Memory Control Registers
enum {
	AC_ITCMCR_SZ = ((1UL<<4)-1) << 3, // SZ
	AC_ITCMCR_RETEN = 1UL<<2, // RETEN
	AC_ITCMCR_RMW = 1UL<<1, // RMW
	AC_ITCMCR_EN = 1UL<<0, // EN		
};
inline void ac_itcmcr_set_sz(struct AC_Type* p, uint32_t val) { p->ITCMCR = (p->ITCMCR & ~AC_ITCMCR_SZ) | ((val<<3) & AC_ITCMCR_SZ); }
inline uint32_t ac_itcmcr_get_sz(struct AC_Type* p) { return (p->ITCMCR & AC_ITCMCR_SZ) >> 3 ; }

// AC->DTCMCR Instruction and Data Tightly-Coupled Memory Control Registers
enum {
	AC_DTCMCR_SZ = ((1UL<<4)-1) << 3, // SZ
	AC_DTCMCR_RETEN = 1UL<<2, // RETEN
	AC_DTCMCR_RMW = 1UL<<1, // RMW
	AC_DTCMCR_EN = 1UL<<0, // EN		
};
inline void ac_dtcmcr_set_sz(struct AC_Type* p, uint32_t val) { p->DTCMCR = (p->DTCMCR & ~AC_DTCMCR_SZ) | ((val<<3) & AC_DTCMCR_SZ); }
inline uint32_t ac_dtcmcr_get_sz(struct AC_Type* p) { return (p->DTCMCR & AC_DTCMCR_SZ) >> 3 ; }

// AC->AHBPCR AHBP Control register
enum {
	AC_AHBPCR_SZ = ((1UL<<3)-1) << 1, // SZ
	AC_AHBPCR_EN = 1UL<<0, // EN		
};
inline void ac_ahbpcr_set_sz(struct AC_Type* p, uint32_t val) { p->AHBPCR = (p->AHBPCR & ~AC_AHBPCR_SZ) | ((val<<1) & AC_AHBPCR_SZ); }
inline uint32_t ac_ahbpcr_get_sz(struct AC_Type* p) { return (p->AHBPCR & AC_AHBPCR_SZ) >> 1 ; }

// AC->CACR Auxiliary Cache Control register
enum {
	AC_CACR_FORCEWT = 1UL<<2, // FORCEWT
	AC_CACR_ECCEN = 1UL<<1, // ECCEN
	AC_CACR_SIWT = 1UL<<0, // SIWT		
};

// AC->AHBSCR AHB Slave Control register
enum {
	AC_AHBSCR_INITCOUNT = ((1UL<<5)-1) << 11, // INITCOUNT
	AC_AHBSCR_TPRI = ((1UL<<9)-1) << 2, // TPRI
	AC_AHBSCR_CTL = ((1UL<<2)-1) << 0, // CTL		
};
inline void ac_ahbscr_set_initcount(struct AC_Type* p, uint32_t val) { p->AHBSCR = (p->AHBSCR & ~AC_AHBSCR_INITCOUNT) | ((val<<11) & AC_AHBSCR_INITCOUNT); }
inline void ac_ahbscr_set_tpri(struct AC_Type* p, uint32_t val) { p->AHBSCR = (p->AHBSCR & ~AC_AHBSCR_TPRI) | ((val<<2) & AC_AHBSCR_TPRI); }
inline void ac_ahbscr_set_ctl(struct AC_Type* p, uint32_t val) { p->AHBSCR = (p->AHBSCR & ~AC_AHBSCR_CTL) | ((val<<0) & AC_AHBSCR_CTL); }
inline uint32_t ac_ahbscr_get_initcount(struct AC_Type* p) { return (p->AHBSCR & AC_AHBSCR_INITCOUNT) >> 11 ; }
inline uint32_t ac_ahbscr_get_tpri(struct AC_Type* p) { return (p->AHBSCR & AC_AHBSCR_TPRI) >> 2 ; }
inline uint32_t ac_ahbscr_get_ctl(struct AC_Type* p) { return (p->AHBSCR & AC_AHBSCR_CTL) >> 0 ; }

// AC->ABFSR Auxiliary Bus Fault Status register
enum {
	AC_ABFSR_AXIMTYPE = ((1UL<<2)-1) << 8, // AXIMTYPE
	AC_ABFSR_EPPB = 1UL<<4, // EPPB
	AC_ABFSR_AXIM = 1UL<<3, // AXIM
	AC_ABFSR_AHBP = 1UL<<2, // AHBP
	AC_ABFSR_DTCM = 1UL<<1, // DTCM
	AC_ABFSR_ITCM = 1UL<<0, // ITCM		
};
inline void ac_abfsr_set_aximtype(struct AC_Type* p, uint32_t val) { p->ABFSR = (p->ABFSR & ~AC_ABFSR_AXIMTYPE) | ((val<<8) & AC_ABFSR_AXIMTYPE); }
inline uint32_t ac_abfsr_get_aximtype(struct AC_Type* p) { return (p->ABFSR & AC_ABFSR_AXIMTYPE) >> 8 ; }




/* Analog to Digital Converter */
struct ADC3_Type {
	__IO uint16_t ISR; // @0 ADC interrupt and status register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t IER; // @4 ADC interrupt enable register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t CR; // @8 ADC control register
	__IO uint32_t CFGR; // @12 ADC configuration register 1
	__IO uint32_t CFGR2; // @16 ADC configuration register 2
	__IO uint32_t SMPR1; // @20 ADC sampling time register 1
	__IO uint32_t SMPR2; // @24 ADC sampling time register 2
	__IO uint32_t PCSEL; // @28 ADC pre channel selection register
	__IO uint32_t LTR1; // @32 ADC analog watchdog 1 threshold register
	__IO uint32_t LHTR1; // @36 ADC analog watchdog 2 threshold register
	 uint8_t RESERVED2[8]; // @40 
	__IO uint32_t SQR1; // @48 ADC group regular sequencer ranks register 1
	__IO uint32_t SQR2; // @52 ADC group regular sequencer ranks register 2
	__IO uint32_t SQR3; // @56 ADC group regular sequencer ranks register 3
	__IO uint16_t SQR4; // @60 ADC group regular sequencer ranks register 4
	 uint8_t RESERVED3[2]; // @62 
	__I uint16_t DR; // @64 ADC group regular conversion data register
	 uint8_t RESERVED4[10]; // @66 
	__IO uint32_t JSQR; // @76 ADC group injected sequencer register
	 uint8_t RESERVED5[16]; // @80 
	__IO uint32_t OFR1; // @96 ADC offset number 1 register
	__IO uint32_t OFR2; // @100 ADC offset number 2 register
	__IO uint32_t OFR3; // @104 ADC offset number 3 register
	__IO uint32_t OFR4; // @108 ADC offset number 4 register
	 uint8_t RESERVED6[16]; // @112 
	__I uint32_t JDR1; // @128 ADC group injected sequencer rank 1 register
	__I uint32_t JDR2; // @132 ADC group injected sequencer rank 2 register
	__I uint32_t JDR3; // @136 ADC group injected sequencer rank 3 register
	__I uint32_t JDR4; // @140 ADC group injected sequencer rank 4 register
	 uint8_t RESERVED7[16]; // @144 
	__IO uint32_t AWD2CR; // @160 ADC analog watchdog 2 configuration register
	__IO uint32_t AWD3CR; // @164 ADC analog watchdog 3 configuration register
	 uint8_t RESERVED8[8]; // @168 
	__IO uint32_t LTR2; // @176 ADC watchdog lower threshold register 2
	__IO uint32_t HTR2; // @180 ADC watchdog higher threshold register 2
	__IO uint32_t LTR3; // @184 ADC watchdog lower threshold register 3
	__IO uint32_t HTR3; // @188 ADC watchdog higher threshold register 3
	__IO uint32_t DIFSEL; // @192 ADC channel differential or single-ended mode selection register
	__IO uint32_t CALFACT; // @196 ADC calibration factors register
	__IO uint32_t CALFACT2; // @200 ADC Calibration Factor register 2
};

// ADC3->ISR ADC interrupt and status register
enum {
	ADC3_ISR_JQOVF = 1UL<<10, // ADC group injected contexts queue overflow flag
	ADC3_ISR_AWD3 = 1UL<<9, // ADC analog watchdog 3 flag
	ADC3_ISR_AWD2 = 1UL<<8, // ADC analog watchdog 2 flag
	ADC3_ISR_AWD1 = 1UL<<7, // ADC analog watchdog 1 flag
	ADC3_ISR_JEOS = 1UL<<6, // ADC group injected end of sequence conversions flag
	ADC3_ISR_JEOC = 1UL<<5, // ADC group injected end of unitary conversion flag
	ADC3_ISR_OVR = 1UL<<4, // ADC group regular overrun flag
	ADC3_ISR_EOS = 1UL<<3, // ADC group regular end of sequence conversions flag
	ADC3_ISR_EOC = 1UL<<2, // ADC group regular end of unitary conversion flag
	ADC3_ISR_EOSMP = 1UL<<1, // ADC group regular end of sampling flag
	ADC3_ISR_ADRDY = 1UL<<0, // ADC ready flag		
};

// ADC3->IER ADC interrupt enable register
enum {
	ADC3_IER_JQOVFIE = 1UL<<10, // ADC group injected contexts queue overflow interrupt
	ADC3_IER_AWD3IE = 1UL<<9, // ADC analog watchdog 3 interrupt
	ADC3_IER_AWD2IE = 1UL<<8, // ADC analog watchdog 2 interrupt
	ADC3_IER_AWD1IE = 1UL<<7, // ADC analog watchdog 1 interrupt
	ADC3_IER_JEOSIE = 1UL<<6, // ADC group injected end of sequence conversions interrupt
	ADC3_IER_JEOCIE = 1UL<<5, // ADC group injected end of unitary conversion interrupt
	ADC3_IER_OVRIE = 1UL<<4, // ADC group regular overrun interrupt
	ADC3_IER_EOSIE = 1UL<<3, // ADC group regular end of sequence conversions interrupt
	ADC3_IER_EOCIE = 1UL<<2, // ADC group regular end of unitary conversion interrupt
	ADC3_IER_EOSMPIE = 1UL<<1, // ADC group regular end of sampling interrupt
	ADC3_IER_ADRDYIE = 1UL<<0, // ADC ready interrupt		
};

// ADC3->CR ADC control register
enum {
	ADC3_CR_ADCAL = 1UL<<31, // ADC calibration
	ADC3_CR_ADCALDIF = 1UL<<30, // ADC differential mode for calibration
	ADC3_CR_DEEPPWD = 1UL<<29, // ADC deep power down enable
	ADC3_CR_ADVREGEN = 1UL<<28, // ADC voltage regulator enable
	ADC3_CR_LINCALRDYW6 = 1UL<<27, // Linearity calibration ready Word 6
	ADC3_CR_LINCALRDYW5 = 1UL<<26, // Linearity calibration ready Word 5
	ADC3_CR_LINCALRDYW4 = 1UL<<25, // Linearity calibration ready Word 4
	ADC3_CR_LINCALRDYW3 = 1UL<<24, // Linearity calibration ready Word 3
	ADC3_CR_LINCALRDYW2 = 1UL<<23, // Linearity calibration ready Word 2
	ADC3_CR_LINCALRDYW1 = 1UL<<22, // Linearity calibration ready Word 1
	ADC3_CR_ADCALLIN = 1UL<<16, // Linearity calibration
	ADC3_CR_BOOST = ((1UL<<2)-1) << 8, // Boost mode control
	ADC3_CR_JADSTP = 1UL<<5, // ADC group injected conversion stop
	ADC3_CR_ADSTP = 1UL<<4, // ADC group regular conversion stop
	ADC3_CR_JADSTART = 1UL<<3, // ADC group injected conversion start
	ADC3_CR_ADSTART = 1UL<<2, // ADC group regular conversion start
	ADC3_CR_ADDIS = 1UL<<1, // ADC disable
	ADC3_CR_ADEN = 1UL<<0, // ADC enable		
};
inline void adc3_cr_set_boost(struct ADC3_Type* p, uint32_t val) { p->CR = (p->CR & ~ADC3_CR_BOOST) | ((val<<8) & ADC3_CR_BOOST); }
inline uint32_t adc3_cr_get_boost(struct ADC3_Type* p) { return (p->CR & ADC3_CR_BOOST) >> 8 ; }

// ADC3->CFGR ADC configuration register 1
enum {
	ADC3_CFGR_JQDIS = 1UL<<31, // ADC group injected contexts queue disable
	ADC3_CFGR_AWDCH1CH = ((1UL<<5)-1) << 26, // ADC analog watchdog 1 monitored channel selection
	ADC3_CFGR_JAUTO = 1UL<<25, // ADC group injected automatic trigger mode
	ADC3_CFGR_JAWD1EN = 1UL<<24, // ADC analog watchdog 1 enable on scope ADC group injected
	ADC3_CFGR_AWD1EN = 1UL<<23, // ADC analog watchdog 1 enable on scope ADC group regular
	ADC3_CFGR_AWD1SGL = 1UL<<22, // ADC analog watchdog 1 monitoring a single channel or all channels
	ADC3_CFGR_JQM = 1UL<<21, // ADC group injected contexts queue mode
	ADC3_CFGR_JDISCEN = 1UL<<20, // ADC group injected sequencer discontinuous mode
	ADC3_CFGR_DISCNUM = ((1UL<<3)-1) << 17, // ADC group regular sequencer discontinuous number of ranks
	ADC3_CFGR_DISCEN = 1UL<<16, // ADC group regular sequencer discontinuous mode
	ADC3_CFGR_AUTDLY = 1UL<<14, // ADC low power auto wait
	ADC3_CFGR_CONT = 1UL<<13, // ADC group regular continuous conversion mode
	ADC3_CFGR_OVRMOD = 1UL<<12, // ADC group regular overrun configuration
	ADC3_CFGR_EXTEN = ((1UL<<2)-1) << 10, // ADC group regular external trigger polarity
	ADC3_CFGR_EXTSEL = ((1UL<<5)-1) << 5, // ADC group regular external trigger source
	ADC3_CFGR_RES = ((1UL<<3)-1) << 2, // ADC data resolution
	ADC3_CFGR_DMNGT = ((1UL<<2)-1) << 0, // ADC DMA transfer enable		
};
inline void adc3_cfgr_set_awdch1ch(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_AWDCH1CH) | ((val<<26) & ADC3_CFGR_AWDCH1CH); }
inline void adc3_cfgr_set_discnum(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_DISCNUM) | ((val<<17) & ADC3_CFGR_DISCNUM); }
inline void adc3_cfgr_set_exten(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_EXTEN) | ((val<<10) & ADC3_CFGR_EXTEN); }
inline void adc3_cfgr_set_extsel(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_EXTSEL) | ((val<<5) & ADC3_CFGR_EXTSEL); }
inline void adc3_cfgr_set_res(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_RES) | ((val<<2) & ADC3_CFGR_RES); }
inline void adc3_cfgr_set_dmngt(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_DMNGT) | ((val<<0) & ADC3_CFGR_DMNGT); }
inline uint32_t adc3_cfgr_get_awdch1ch(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_AWDCH1CH) >> 26 ; }
inline uint32_t adc3_cfgr_get_discnum(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_DISCNUM) >> 17 ; }
inline uint32_t adc3_cfgr_get_exten(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_EXTEN) >> 10 ; }
inline uint32_t adc3_cfgr_get_extsel(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_EXTSEL) >> 5 ; }
inline uint32_t adc3_cfgr_get_res(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_RES) >> 2 ; }
inline uint32_t adc3_cfgr_get_dmngt(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_DMNGT) >> 0 ; }

// ADC3->CFGR2 ADC configuration register 2
enum {
	ADC3_CFGR2_LSHIFT = ((1UL<<4)-1) << 28, // Left shift factor
	ADC3_CFGR2_OSR = ((1UL<<10)-1) << 16, // Oversampling ratio
	ADC3_CFGR2_RSHIFT4 = 1UL<<14, // Right-shift data after Offset 4 correction
	ADC3_CFGR2_RSHIFT3 = 1UL<<13, // Right-shift data after Offset 3 correction
	ADC3_CFGR2_RSHIFT2 = 1UL<<12, // Right-shift data after Offset 2 correction
	ADC3_CFGR2_RSHIFT1 = 1UL<<11, // Right-shift data after Offset 1 correction
	ADC3_CFGR2_ROVSM = 1UL<<10, // Regular Oversampling mode
	ADC3_CFGR2_TROVS = 1UL<<9, // ADC oversampling discontinuous mode (triggered mode) for ADC group regular
	ADC3_CFGR2_OVSS = ((1UL<<4)-1) << 5, // ADC oversampling shift
	ADC3_CFGR2_JOVSE = 1UL<<1, // ADC oversampler enable on scope ADC group injected
	ADC3_CFGR2_ROVSE = 1UL<<0, // ADC oversampler enable on scope ADC group regular		
};
inline void adc3_cfgr2_set_lshift(struct ADC3_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_LSHIFT) | ((val<<28) & ADC3_CFGR2_LSHIFT); }
inline void adc3_cfgr2_set_osr(struct ADC3_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_OSR) | ((val<<16) & ADC3_CFGR2_OSR); }
inline void adc3_cfgr2_set_ovss(struct ADC3_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_OVSS) | ((val<<5) & ADC3_CFGR2_OVSS); }
inline uint32_t adc3_cfgr2_get_lshift(struct ADC3_Type* p) { return (p->CFGR2 & ADC3_CFGR2_LSHIFT) >> 28 ; }
inline uint32_t adc3_cfgr2_get_osr(struct ADC3_Type* p) { return (p->CFGR2 & ADC3_CFGR2_OSR) >> 16 ; }
inline uint32_t adc3_cfgr2_get_ovss(struct ADC3_Type* p) { return (p->CFGR2 & ADC3_CFGR2_OVSS) >> 5 ; }

// ADC3->SMPR1 ADC sampling time register 1
enum {
	ADC3_SMPR1_SMP9 = ((1UL<<3)-1) << 27, // ADC channel 9 sampling time selection
	ADC3_SMPR1_SMP8 = ((1UL<<3)-1) << 24, // ADC channel 8 sampling time selection
	ADC3_SMPR1_SMP7 = ((1UL<<3)-1) << 21, // ADC channel 7 sampling time selection
	ADC3_SMPR1_SMP6 = ((1UL<<3)-1) << 18, // ADC channel 6 sampling time selection
	ADC3_SMPR1_SMP5 = ((1UL<<3)-1) << 15, // ADC channel 5 sampling time selection
	ADC3_SMPR1_SMP4 = ((1UL<<3)-1) << 12, // ADC channel 4 sampling time selection
	ADC3_SMPR1_SMP3 = ((1UL<<3)-1) << 9, // ADC channel 3 sampling time selection
	ADC3_SMPR1_SMP2 = ((1UL<<3)-1) << 6, // ADC channel 2 sampling time selection
	ADC3_SMPR1_SMP1 = ((1UL<<3)-1) << 3, // ADC channel 1 sampling time selection		
};
inline void adc3_smpr1_set_smp9(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP9) | ((val<<27) & ADC3_SMPR1_SMP9); }
inline void adc3_smpr1_set_smp8(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP8) | ((val<<24) & ADC3_SMPR1_SMP8); }
inline void adc3_smpr1_set_smp7(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP7) | ((val<<21) & ADC3_SMPR1_SMP7); }
inline void adc3_smpr1_set_smp6(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP6) | ((val<<18) & ADC3_SMPR1_SMP6); }
inline void adc3_smpr1_set_smp5(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP5) | ((val<<15) & ADC3_SMPR1_SMP5); }
inline void adc3_smpr1_set_smp4(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP4) | ((val<<12) & ADC3_SMPR1_SMP4); }
inline void adc3_smpr1_set_smp3(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP3) | ((val<<9) & ADC3_SMPR1_SMP3); }
inline void adc3_smpr1_set_smp2(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP2) | ((val<<6) & ADC3_SMPR1_SMP2); }
inline void adc3_smpr1_set_smp1(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP1) | ((val<<3) & ADC3_SMPR1_SMP1); }
inline uint32_t adc3_smpr1_get_smp9(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP9) >> 27 ; }
inline uint32_t adc3_smpr1_get_smp8(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP8) >> 24 ; }
inline uint32_t adc3_smpr1_get_smp7(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP7) >> 21 ; }
inline uint32_t adc3_smpr1_get_smp6(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP6) >> 18 ; }
inline uint32_t adc3_smpr1_get_smp5(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP5) >> 15 ; }
inline uint32_t adc3_smpr1_get_smp4(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP4) >> 12 ; }
inline uint32_t adc3_smpr1_get_smp3(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP3) >> 9 ; }
inline uint32_t adc3_smpr1_get_smp2(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP2) >> 6 ; }
inline uint32_t adc3_smpr1_get_smp1(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP1) >> 3 ; }

// ADC3->SMPR2 ADC sampling time register 2
enum {
	ADC3_SMPR2_SMP19 = ((1UL<<3)-1) << 27, // ADC channel 18 sampling time selection
	ADC3_SMPR2_SMP18 = ((1UL<<3)-1) << 24, // ADC channel 18 sampling time selection
	ADC3_SMPR2_SMP17 = ((1UL<<3)-1) << 21, // ADC channel 17 sampling time selection
	ADC3_SMPR2_SMP16 = ((1UL<<3)-1) << 18, // ADC channel 16 sampling time selection
	ADC3_SMPR2_SMP15 = ((1UL<<3)-1) << 15, // ADC channel 15 sampling time selection
	ADC3_SMPR2_SMP14 = ((1UL<<3)-1) << 12, // ADC channel 14 sampling time selection
	ADC3_SMPR2_SMP13 = ((1UL<<3)-1) << 9, // ADC channel 13 sampling time selection
	ADC3_SMPR2_SMP12 = ((1UL<<3)-1) << 6, // ADC channel 12 sampling time selection
	ADC3_SMPR2_SMP11 = ((1UL<<3)-1) << 3, // ADC channel 11 sampling time selection
	ADC3_SMPR2_SMP10 = ((1UL<<3)-1) << 0, // ADC channel 10 sampling time selection		
};
inline void adc3_smpr2_set_smp19(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP19) | ((val<<27) & ADC3_SMPR2_SMP19); }
inline void adc3_smpr2_set_smp18(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP18) | ((val<<24) & ADC3_SMPR2_SMP18); }
inline void adc3_smpr2_set_smp17(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP17) | ((val<<21) & ADC3_SMPR2_SMP17); }
inline void adc3_smpr2_set_smp16(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP16) | ((val<<18) & ADC3_SMPR2_SMP16); }
inline void adc3_smpr2_set_smp15(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP15) | ((val<<15) & ADC3_SMPR2_SMP15); }
inline void adc3_smpr2_set_smp14(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP14) | ((val<<12) & ADC3_SMPR2_SMP14); }
inline void adc3_smpr2_set_smp13(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP13) | ((val<<9) & ADC3_SMPR2_SMP13); }
inline void adc3_smpr2_set_smp12(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP12) | ((val<<6) & ADC3_SMPR2_SMP12); }
inline void adc3_smpr2_set_smp11(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP11) | ((val<<3) & ADC3_SMPR2_SMP11); }
inline void adc3_smpr2_set_smp10(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP10) | ((val<<0) & ADC3_SMPR2_SMP10); }
inline uint32_t adc3_smpr2_get_smp19(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP19) >> 27 ; }
inline uint32_t adc3_smpr2_get_smp18(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP18) >> 24 ; }
inline uint32_t adc3_smpr2_get_smp17(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP17) >> 21 ; }
inline uint32_t adc3_smpr2_get_smp16(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP16) >> 18 ; }
inline uint32_t adc3_smpr2_get_smp15(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP15) >> 15 ; }
inline uint32_t adc3_smpr2_get_smp14(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP14) >> 12 ; }
inline uint32_t adc3_smpr2_get_smp13(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP13) >> 9 ; }
inline uint32_t adc3_smpr2_get_smp12(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP12) >> 6 ; }
inline uint32_t adc3_smpr2_get_smp11(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP11) >> 3 ; }
inline uint32_t adc3_smpr2_get_smp10(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP10) >> 0 ; }

// ADC3->PCSEL ADC pre channel selection register
enum {
	ADC3_PCSEL_PCSEL = ((1UL<<20)-1) << 0, // Channel x (VINP[i]) pre selection		
};
inline void adc3_pcsel_set_pcsel(struct ADC3_Type* p, uint32_t val) { p->PCSEL = (p->PCSEL & ~ADC3_PCSEL_PCSEL) | ((val<<0) & ADC3_PCSEL_PCSEL); }
inline uint32_t adc3_pcsel_get_pcsel(struct ADC3_Type* p) { return (p->PCSEL & ADC3_PCSEL_PCSEL) >> 0 ; }

// ADC3->LTR1 ADC analog watchdog 1 threshold register
enum {
	ADC3_LTR1_LTR1 = ((1UL<<26)-1) << 0, // ADC analog watchdog 1 threshold low		
};
inline void adc3_ltr1_set_ltr1(struct ADC3_Type* p, uint32_t val) { p->LTR1 = (p->LTR1 & ~ADC3_LTR1_LTR1) | ((val<<0) & ADC3_LTR1_LTR1); }
inline uint32_t adc3_ltr1_get_ltr1(struct ADC3_Type* p) { return (p->LTR1 & ADC3_LTR1_LTR1) >> 0 ; }

// ADC3->LHTR1 ADC analog watchdog 2 threshold register
enum {
	ADC3_LHTR1_LHTR1 = ((1UL<<26)-1) << 0, // ADC analog watchdog 2 threshold low		
};
inline void adc3_lhtr1_set_lhtr1(struct ADC3_Type* p, uint32_t val) { p->LHTR1 = (p->LHTR1 & ~ADC3_LHTR1_LHTR1) | ((val<<0) & ADC3_LHTR1_LHTR1); }
inline uint32_t adc3_lhtr1_get_lhtr1(struct ADC3_Type* p) { return (p->LHTR1 & ADC3_LHTR1_LHTR1) >> 0 ; }

// ADC3->SQR1 ADC group regular sequencer ranks register 1
enum {
	ADC3_SQR1_SQ4 = ((1UL<<5)-1) << 24, // ADC group regular sequencer rank 4
	ADC3_SQR1_SQ3 = ((1UL<<5)-1) << 18, // ADC group regular sequencer rank 3
	ADC3_SQR1_SQ2 = ((1UL<<5)-1) << 12, // ADC group regular sequencer rank 2
	ADC3_SQR1_SQ1 = ((1UL<<5)-1) << 6, // ADC group regular sequencer rank 1
	ADC3_SQR1_L3 = ((1UL<<4)-1) << 0, // L3		
};
inline void adc3_sqr1_set_sq4(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ4) | ((val<<24) & ADC3_SQR1_SQ4); }
inline void adc3_sqr1_set_sq3(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ3) | ((val<<18) & ADC3_SQR1_SQ3); }
inline void adc3_sqr1_set_sq2(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ2) | ((val<<12) & ADC3_SQR1_SQ2); }
inline void adc3_sqr1_set_sq1(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ1) | ((val<<6) & ADC3_SQR1_SQ1); }
inline void adc3_sqr1_set_l3(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_L3) | ((val<<0) & ADC3_SQR1_L3); }
inline uint32_t adc3_sqr1_get_sq4(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ4) >> 24 ; }
inline uint32_t adc3_sqr1_get_sq3(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ3) >> 18 ; }
inline uint32_t adc3_sqr1_get_sq2(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ2) >> 12 ; }
inline uint32_t adc3_sqr1_get_sq1(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ1) >> 6 ; }
inline uint32_t adc3_sqr1_get_l3(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_L3) >> 0 ; }

// ADC3->SQR2 ADC group regular sequencer ranks register 2
enum {
	ADC3_SQR2_SQ9 = ((1UL<<5)-1) << 24, // ADC group regular sequencer rank 9
	ADC3_SQR2_SQ8 = ((1UL<<5)-1) << 18, // ADC group regular sequencer rank 8
	ADC3_SQR2_SQ7 = ((1UL<<5)-1) << 12, // ADC group regular sequencer rank 7
	ADC3_SQR2_SQ6 = ((1UL<<5)-1) << 6, // ADC group regular sequencer rank 6
	ADC3_SQR2_SQ5 = ((1UL<<5)-1) << 0, // ADC group regular sequencer rank 5		
};
inline void adc3_sqr2_set_sq9(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ9) | ((val<<24) & ADC3_SQR2_SQ9); }
inline void adc3_sqr2_set_sq8(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ8) | ((val<<18) & ADC3_SQR2_SQ8); }
inline void adc3_sqr2_set_sq7(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ7) | ((val<<12) & ADC3_SQR2_SQ7); }
inline void adc3_sqr2_set_sq6(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ6) | ((val<<6) & ADC3_SQR2_SQ6); }
inline void adc3_sqr2_set_sq5(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ5) | ((val<<0) & ADC3_SQR2_SQ5); }
inline uint32_t adc3_sqr2_get_sq9(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ9) >> 24 ; }
inline uint32_t adc3_sqr2_get_sq8(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ8) >> 18 ; }
inline uint32_t adc3_sqr2_get_sq7(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ7) >> 12 ; }
inline uint32_t adc3_sqr2_get_sq6(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ6) >> 6 ; }
inline uint32_t adc3_sqr2_get_sq5(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ5) >> 0 ; }

// ADC3->SQR3 ADC group regular sequencer ranks register 3
enum {
	ADC3_SQR3_SQ14 = ((1UL<<5)-1) << 24, // ADC group regular sequencer rank 14
	ADC3_SQR3_SQ13 = ((1UL<<5)-1) << 18, // ADC group regular sequencer rank 13
	ADC3_SQR3_SQ12 = ((1UL<<5)-1) << 12, // ADC group regular sequencer rank 12
	ADC3_SQR3_SQ11 = ((1UL<<5)-1) << 6, // ADC group regular sequencer rank 11
	ADC3_SQR3_SQ10 = ((1UL<<5)-1) << 0, // ADC group regular sequencer rank 10		
};
inline void adc3_sqr3_set_sq14(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ14) | ((val<<24) & ADC3_SQR3_SQ14); }
inline void adc3_sqr3_set_sq13(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ13) | ((val<<18) & ADC3_SQR3_SQ13); }
inline void adc3_sqr3_set_sq12(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ12) | ((val<<12) & ADC3_SQR3_SQ12); }
inline void adc3_sqr3_set_sq11(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ11) | ((val<<6) & ADC3_SQR3_SQ11); }
inline void adc3_sqr3_set_sq10(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ10) | ((val<<0) & ADC3_SQR3_SQ10); }
inline uint32_t adc3_sqr3_get_sq14(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ14) >> 24 ; }
inline uint32_t adc3_sqr3_get_sq13(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ13) >> 18 ; }
inline uint32_t adc3_sqr3_get_sq12(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ12) >> 12 ; }
inline uint32_t adc3_sqr3_get_sq11(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ11) >> 6 ; }
inline uint32_t adc3_sqr3_get_sq10(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ10) >> 0 ; }

// ADC3->SQR4 ADC group regular sequencer ranks register 4
enum {
	ADC3_SQR4_SQ16 = ((1UL<<5)-1) << 6, // ADC group regular sequencer rank 16
	ADC3_SQR4_SQ15 = ((1UL<<5)-1) << 0, // ADC group regular sequencer rank 15		
};
inline void adc3_sqr4_set_sq16(struct ADC3_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC3_SQR4_SQ16) | ((val<<6) & ADC3_SQR4_SQ16); }
inline void adc3_sqr4_set_sq15(struct ADC3_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC3_SQR4_SQ15) | ((val<<0) & ADC3_SQR4_SQ15); }
inline uint32_t adc3_sqr4_get_sq16(struct ADC3_Type* p) { return (p->SQR4 & ADC3_SQR4_SQ16) >> 6 ; }
inline uint32_t adc3_sqr4_get_sq15(struct ADC3_Type* p) { return (p->SQR4 & ADC3_SQR4_SQ15) >> 0 ; }

// ADC3->JSQR ADC group injected sequencer register
enum {
	ADC3_JSQR_JSQ4 = ((1UL<<5)-1) << 27, // ADC group injected sequencer rank 4
	ADC3_JSQR_JSQ3 = ((1UL<<5)-1) << 21, // ADC group injected sequencer rank 3
	ADC3_JSQR_JSQ2 = ((1UL<<5)-1) << 15, // ADC group injected sequencer rank 2
	ADC3_JSQR_JSQ1 = ((1UL<<5)-1) << 9, // ADC group injected sequencer rank 1
	ADC3_JSQR_JEXTEN = ((1UL<<2)-1) << 7, // ADC group injected external trigger polarity
	ADC3_JSQR_JEXTSEL = ((1UL<<5)-1) << 2, // ADC group injected external trigger source
	ADC3_JSQR_JL = ((1UL<<2)-1) << 0, // ADC group injected sequencer scan length		
};
inline void adc3_jsqr_set_jsq4(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ4) | ((val<<27) & ADC3_JSQR_JSQ4); }
inline void adc3_jsqr_set_jsq3(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ3) | ((val<<21) & ADC3_JSQR_JSQ3); }
inline void adc3_jsqr_set_jsq2(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ2) | ((val<<15) & ADC3_JSQR_JSQ2); }
inline void adc3_jsqr_set_jsq1(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ1) | ((val<<9) & ADC3_JSQR_JSQ1); }
inline void adc3_jsqr_set_jexten(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JEXTEN) | ((val<<7) & ADC3_JSQR_JEXTEN); }
inline void adc3_jsqr_set_jextsel(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JEXTSEL) | ((val<<2) & ADC3_JSQR_JEXTSEL); }
inline void adc3_jsqr_set_jl(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JL) | ((val<<0) & ADC3_JSQR_JL); }
inline uint32_t adc3_jsqr_get_jsq4(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ4) >> 27 ; }
inline uint32_t adc3_jsqr_get_jsq3(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ3) >> 21 ; }
inline uint32_t adc3_jsqr_get_jsq2(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ2) >> 15 ; }
inline uint32_t adc3_jsqr_get_jsq1(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ1) >> 9 ; }
inline uint32_t adc3_jsqr_get_jexten(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JEXTEN) >> 7 ; }
inline uint32_t adc3_jsqr_get_jextsel(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JEXTSEL) >> 2 ; }
inline uint32_t adc3_jsqr_get_jl(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JL) >> 0 ; }

// ADC3->OFR1 ADC offset number 1 register
enum {
	ADC3_OFR1_SSATE = 1UL<<31, // ADC offset number 1 enable
	ADC3_OFR1_OFFSET1_CH = ((1UL<<5)-1) << 26, // ADC offset number 1 channel selection
	ADC3_OFR1_OFFSET1 = ((1UL<<26)-1) << 0, // ADC offset number 1 offset level		
};
inline void adc3_ofr1_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC3_OFR1_OFFSET1_CH) | ((val<<26) & ADC3_OFR1_OFFSET1_CH); }
inline void adc3_ofr1_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC3_OFR1_OFFSET1) | ((val<<0) & ADC3_OFR1_OFFSET1); }
inline uint32_t adc3_ofr1_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR1 & ADC3_OFR1_OFFSET1_CH) >> 26 ; }
inline uint32_t adc3_ofr1_get_offset1(struct ADC3_Type* p) { return (p->OFR1 & ADC3_OFR1_OFFSET1) >> 0 ; }

// ADC3->OFR2 ADC offset number 2 register
enum {
	ADC3_OFR2_SSATE = 1UL<<31, // ADC offset number 1 enable
	ADC3_OFR2_OFFSET1_CH = ((1UL<<5)-1) << 26, // ADC offset number 1 channel selection
	ADC3_OFR2_OFFSET1 = ((1UL<<26)-1) << 0, // ADC offset number 1 offset level		
};
inline void adc3_ofr2_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC3_OFR2_OFFSET1_CH) | ((val<<26) & ADC3_OFR2_OFFSET1_CH); }
inline void adc3_ofr2_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC3_OFR2_OFFSET1) | ((val<<0) & ADC3_OFR2_OFFSET1); }
inline uint32_t adc3_ofr2_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR2 & ADC3_OFR2_OFFSET1_CH) >> 26 ; }
inline uint32_t adc3_ofr2_get_offset1(struct ADC3_Type* p) { return (p->OFR2 & ADC3_OFR2_OFFSET1) >> 0 ; }

// ADC3->OFR3 ADC offset number 3 register
enum {
	ADC3_OFR3_SSATE = 1UL<<31, // ADC offset number 1 enable
	ADC3_OFR3_OFFSET1_CH = ((1UL<<5)-1) << 26, // ADC offset number 1 channel selection
	ADC3_OFR3_OFFSET1 = ((1UL<<26)-1) << 0, // ADC offset number 1 offset level		
};
inline void adc3_ofr3_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC3_OFR3_OFFSET1_CH) | ((val<<26) & ADC3_OFR3_OFFSET1_CH); }
inline void adc3_ofr3_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC3_OFR3_OFFSET1) | ((val<<0) & ADC3_OFR3_OFFSET1); }
inline uint32_t adc3_ofr3_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR3 & ADC3_OFR3_OFFSET1_CH) >> 26 ; }
inline uint32_t adc3_ofr3_get_offset1(struct ADC3_Type* p) { return (p->OFR3 & ADC3_OFR3_OFFSET1) >> 0 ; }

// ADC3->OFR4 ADC offset number 4 register
enum {
	ADC3_OFR4_SSATE = 1UL<<31, // ADC offset number 1 enable
	ADC3_OFR4_OFFSET1_CH = ((1UL<<5)-1) << 26, // ADC offset number 1 channel selection
	ADC3_OFR4_OFFSET1 = ((1UL<<26)-1) << 0, // ADC offset number 1 offset level		
};
inline void adc3_ofr4_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC3_OFR4_OFFSET1_CH) | ((val<<26) & ADC3_OFR4_OFFSET1_CH); }
inline void adc3_ofr4_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC3_OFR4_OFFSET1) | ((val<<0) & ADC3_OFR4_OFFSET1); }
inline uint32_t adc3_ofr4_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR4 & ADC3_OFR4_OFFSET1_CH) >> 26 ; }
inline uint32_t adc3_ofr4_get_offset1(struct ADC3_Type* p) { return (p->OFR4 & ADC3_OFR4_OFFSET1) >> 0 ; }

// ADC3->AWD2CR ADC analog watchdog 2 configuration register
enum {
	ADC3_AWD2CR_AWD2CH = ((1UL<<20)-1) << 0, // ADC analog watchdog 2 monitored channel selection		
};
inline void adc3_awd2cr_set_awd2ch(struct ADC3_Type* p, uint32_t val) { p->AWD2CR = (p->AWD2CR & ~ADC3_AWD2CR_AWD2CH) | ((val<<0) & ADC3_AWD2CR_AWD2CH); }
inline uint32_t adc3_awd2cr_get_awd2ch(struct ADC3_Type* p) { return (p->AWD2CR & ADC3_AWD2CR_AWD2CH) >> 0 ; }

// ADC3->AWD3CR ADC analog watchdog 3 configuration register
enum {
	ADC3_AWD3CR_AWD3CH = ((1UL<<20)-1) << 1, // ADC analog watchdog 3 monitored channel selection		
};
inline void adc3_awd3cr_set_awd3ch(struct ADC3_Type* p, uint32_t val) { p->AWD3CR = (p->AWD3CR & ~ADC3_AWD3CR_AWD3CH) | ((val<<1) & ADC3_AWD3CR_AWD3CH); }
inline uint32_t adc3_awd3cr_get_awd3ch(struct ADC3_Type* p) { return (p->AWD3CR & ADC3_AWD3CR_AWD3CH) >> 1 ; }

// ADC3->LTR2 ADC watchdog lower threshold register 2
enum {
	ADC3_LTR2_LTR2 = ((1UL<<26)-1) << 0, // Analog watchdog 2 lower threshold		
};
inline void adc3_ltr2_set_ltr2(struct ADC3_Type* p, uint32_t val) { p->LTR2 = (p->LTR2 & ~ADC3_LTR2_LTR2) | ((val<<0) & ADC3_LTR2_LTR2); }
inline uint32_t adc3_ltr2_get_ltr2(struct ADC3_Type* p) { return (p->LTR2 & ADC3_LTR2_LTR2) >> 0 ; }

// ADC3->HTR2 ADC watchdog higher threshold register 2
enum {
	ADC3_HTR2_HTR2 = ((1UL<<26)-1) << 0, // Analog watchdog 2 higher threshold		
};
inline void adc3_htr2_set_htr2(struct ADC3_Type* p, uint32_t val) { p->HTR2 = (p->HTR2 & ~ADC3_HTR2_HTR2) | ((val<<0) & ADC3_HTR2_HTR2); }
inline uint32_t adc3_htr2_get_htr2(struct ADC3_Type* p) { return (p->HTR2 & ADC3_HTR2_HTR2) >> 0 ; }

// ADC3->LTR3 ADC watchdog lower threshold register 3
enum {
	ADC3_LTR3_LTR3 = ((1UL<<26)-1) << 0, // Analog watchdog 3 lower threshold		
};
inline void adc3_ltr3_set_ltr3(struct ADC3_Type* p, uint32_t val) { p->LTR3 = (p->LTR3 & ~ADC3_LTR3_LTR3) | ((val<<0) & ADC3_LTR3_LTR3); }
inline uint32_t adc3_ltr3_get_ltr3(struct ADC3_Type* p) { return (p->LTR3 & ADC3_LTR3_LTR3) >> 0 ; }

// ADC3->HTR3 ADC watchdog higher threshold register 3
enum {
	ADC3_HTR3_HTR3 = ((1UL<<26)-1) << 0, // Analog watchdog 3 higher threshold		
};
inline void adc3_htr3_set_htr3(struct ADC3_Type* p, uint32_t val) { p->HTR3 = (p->HTR3 & ~ADC3_HTR3_HTR3) | ((val<<0) & ADC3_HTR3_HTR3); }
inline uint32_t adc3_htr3_get_htr3(struct ADC3_Type* p) { return (p->HTR3 & ADC3_HTR3_HTR3) >> 0 ; }

// ADC3->DIFSEL ADC channel differential or single-ended mode selection register
enum {
	ADC3_DIFSEL_DIFSEL = ((1UL<<20)-1) << 0, // ADC channel differential or single-ended mode for channel		
};
inline void adc3_difsel_set_difsel(struct ADC3_Type* p, uint32_t val) { p->DIFSEL = (p->DIFSEL & ~ADC3_DIFSEL_DIFSEL) | ((val<<0) & ADC3_DIFSEL_DIFSEL); }
inline uint32_t adc3_difsel_get_difsel(struct ADC3_Type* p) { return (p->DIFSEL & ADC3_DIFSEL_DIFSEL) >> 0 ; }

// ADC3->CALFACT ADC calibration factors register
enum {
	ADC3_CALFACT_CALFACT_D = ((1UL<<11)-1) << 16, // ADC calibration factor in differential mode
	ADC3_CALFACT_CALFACT_S = ((1UL<<11)-1) << 0, // ADC calibration factor in single-ended mode		
};
inline void adc3_calfact_set_calfact_d(struct ADC3_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC3_CALFACT_CALFACT_D) | ((val<<16) & ADC3_CALFACT_CALFACT_D); }
inline void adc3_calfact_set_calfact_s(struct ADC3_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC3_CALFACT_CALFACT_S) | ((val<<0) & ADC3_CALFACT_CALFACT_S); }
inline uint32_t adc3_calfact_get_calfact_d(struct ADC3_Type* p) { return (p->CALFACT & ADC3_CALFACT_CALFACT_D) >> 16 ; }
inline uint32_t adc3_calfact_get_calfact_s(struct ADC3_Type* p) { return (p->CALFACT & ADC3_CALFACT_CALFACT_S) >> 0 ; }

// ADC3->CALFACT2 ADC Calibration Factor register 2
enum {
	ADC3_CALFACT2_LINCALFACT = ((1UL<<30)-1) << 0, // Linearity Calibration Factor		
};
inline void adc3_calfact2_set_lincalfact(struct ADC3_Type* p, uint32_t val) { p->CALFACT2 = (p->CALFACT2 & ~ADC3_CALFACT2_LINCALFACT) | ((val<<0) & ADC3_CALFACT2_LINCALFACT); }
inline uint32_t adc3_calfact2_get_lincalfact(struct ADC3_Type* p) { return (p->CALFACT2 & ADC3_CALFACT2_LINCALFACT) >> 0 ; }

/* Analog-to-Digital Converter */
struct ADC3_Common_Type {
	__I uint32_t CSR; // @0 ADC Common status register
	 uint8_t RESERVED0[4]; // @4 
	__IO uint32_t CCR; // @8 ADC common control register
	__I uint32_t CDR; // @12 ADC common regular data register for dual and triple modes
	__I uint32_t CDR2; // @16 ADC x common regular data register for 32-bit dual mode
};

// ADC3_Common->CSR ADC Common status register
enum {
	ADC3_COMMON_CSR_JQOVF_SLV = 1UL<<26, // Injected Context Queue Overflow flag of the slave ADC
	ADC3_COMMON_CSR_AWD3_SLV = 1UL<<25, // Analog watchdog 3 flag of the slave ADC
	ADC3_COMMON_CSR_AWD2_SLV = 1UL<<24, // Analog watchdog 2 flag of the slave ADC
	ADC3_COMMON_CSR_AWD1_SLV = 1UL<<23, // Analog watchdog 1 flag of the slave ADC
	ADC3_COMMON_CSR_JEOS_SLV = 1UL<<22, // End of injected sequence flag of the slave ADC
	ADC3_COMMON_CSR_JEOC_SLV = 1UL<<21, // End of injected conversion flag of the slave ADC
	ADC3_COMMON_CSR_OVR_SLV = 1UL<<20, // Overrun flag of the slave ADC
	ADC3_COMMON_CSR_EOS_SLV = 1UL<<19, // End of regular sequence flag of the slave ADC
	ADC3_COMMON_CSR_EOC_SLV = 1UL<<18, // End of regular conversion of the slave ADC
	ADC3_COMMON_CSR_EOSMP_SLV = 1UL<<17, // End of Sampling phase flag of the slave ADC
	ADC3_COMMON_CSR_ADRDY_SLV = 1UL<<16, // Slave ADC ready
	ADC3_COMMON_CSR_JQOVF_MST = 1UL<<10, // Injected Context Queue Overflow flag of the master ADC
	ADC3_COMMON_CSR_AWD3_MST = 1UL<<9, // Analog watchdog 3 flag of the master ADC
	ADC3_COMMON_CSR_AWD2_MST = 1UL<<8, // Analog watchdog 2 flag of the master ADC
	ADC3_COMMON_CSR_AWD1_MST = 1UL<<7, // Analog watchdog 1 flag of the master ADC
	ADC3_COMMON_CSR_JEOS_MST = 1UL<<6, // End of injected sequence flag of the master ADC
	ADC3_COMMON_CSR_JEOC_MST = 1UL<<5, // End of injected conversion flag of the master ADC
	ADC3_COMMON_CSR_OVR_MST = 1UL<<4, // Overrun flag of the master ADC
	ADC3_COMMON_CSR_EOS_MST = 1UL<<3, // End of regular sequence flag of the master ADC
	ADC3_COMMON_CSR_EOC_MST = 1UL<<2, // End of regular conversion of the master ADC
	ADC3_COMMON_CSR_EOSMP_MST = 1UL<<1, // End of Sampling phase flag of the master ADC
	ADC3_COMMON_CSR_ADRDY_MST = 1UL<<0, // Master ADC ready		
};

// ADC3_Common->CCR ADC common control register
enum {
	ADC3_COMMON_CCR_VBATEN = 1UL<<24, // VBAT enable
	ADC3_COMMON_CCR_TSEN = 1UL<<23, // Temperature sensor enable
	ADC3_COMMON_CCR_VREFEN = 1UL<<22, // VREFINT enable
	ADC3_COMMON_CCR_PRESC = ((1UL<<4)-1) << 18, // ADC prescaler
	ADC3_COMMON_CCR_CKMODE = ((1UL<<2)-1) << 16, // ADC clock mode
	ADC3_COMMON_CCR_DAMDF = ((1UL<<2)-1) << 14, // Dual ADC Mode Data Format
	ADC3_COMMON_CCR_DELAY = ((1UL<<4)-1) << 8, // Delay between 2 sampling phases
	ADC3_COMMON_CCR_DUAL = ((1UL<<5)-1) << 0, // Dual ADC mode selection		
};
inline void adc3_common_ccr_set_presc(struct ADC3_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC3_COMMON_CCR_PRESC) | ((val<<18) & ADC3_COMMON_CCR_PRESC); }
inline void adc3_common_ccr_set_ckmode(struct ADC3_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC3_COMMON_CCR_CKMODE) | ((val<<16) & ADC3_COMMON_CCR_CKMODE); }
inline void adc3_common_ccr_set_damdf(struct ADC3_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC3_COMMON_CCR_DAMDF) | ((val<<14) & ADC3_COMMON_CCR_DAMDF); }
inline void adc3_common_ccr_set_delay(struct ADC3_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC3_COMMON_CCR_DELAY) | ((val<<8) & ADC3_COMMON_CCR_DELAY); }
inline void adc3_common_ccr_set_dual(struct ADC3_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC3_COMMON_CCR_DUAL) | ((val<<0) & ADC3_COMMON_CCR_DUAL); }
inline uint32_t adc3_common_ccr_get_presc(struct ADC3_Common_Type* p) { return (p->CCR & ADC3_COMMON_CCR_PRESC) >> 18 ; }
inline uint32_t adc3_common_ccr_get_ckmode(struct ADC3_Common_Type* p) { return (p->CCR & ADC3_COMMON_CCR_CKMODE) >> 16 ; }
inline uint32_t adc3_common_ccr_get_damdf(struct ADC3_Common_Type* p) { return (p->CCR & ADC3_COMMON_CCR_DAMDF) >> 14 ; }
inline uint32_t adc3_common_ccr_get_delay(struct ADC3_Common_Type* p) { return (p->CCR & ADC3_COMMON_CCR_DELAY) >> 8 ; }
inline uint32_t adc3_common_ccr_get_dual(struct ADC3_Common_Type* p) { return (p->CCR & ADC3_COMMON_CCR_DUAL) >> 0 ; }

// ADC3_Common->CDR ADC common regular data register for dual and triple modes
enum {
	ADC3_COMMON_CDR_RDATA_SLV = ((1UL<<16)-1) << 16, // Regular data of the slave ADC
	ADC3_COMMON_CDR_RDATA_MST = ((1UL<<16)-1) << 0, // Regular data of the master ADC		
};
inline uint32_t adc3_common_cdr_get_rdata_slv(struct ADC3_Common_Type* p) { return (p->CDR & ADC3_COMMON_CDR_RDATA_SLV) >> 16 ; }
inline uint32_t adc3_common_cdr_get_rdata_mst(struct ADC3_Common_Type* p) { return (p->CDR & ADC3_COMMON_CDR_RDATA_MST) >> 0 ; }

/* accelerator - control register (ART_CTR) */
struct ART_Type {
	__IO uint32_t CTR; // @0 control register
};

// ART->CTR control register
enum {
	ART_CTR_PCACHEADDR = ((1UL<<12)-1) << 8, // Cacheable page index
	ART_CTR_EN = 1UL<<0, // Cache enable		
};
inline void art_ctr_set_pcacheaddr(struct ART_Type* p, uint32_t val) { p->CTR = (p->CTR & ~ART_CTR_PCACHEADDR) | ((val<<8) & ART_CTR_PCACHEADDR); }
inline uint32_t art_ctr_get_pcacheaddr(struct ART_Type* p) { return (p->CTR & ART_CTR_PCACHEADDR) >> 8 ; }

/* AXI interconnect registers */
struct AXI_Type {
	 uint8_t RESERVED0[8144]; // @0 
	__I uint8_t AXI_PERIPH_ID_4; // @8144 AXI interconnect - peripheral ID4 register
	 uint8_t RESERVED1[15]; // @8145 
	__I uint8_t AXI_PERIPH_ID_0; // @8160 AXI interconnect - peripheral ID0 register
	 uint8_t RESERVED2[3]; // @8161 
	__I uint8_t AXI_PERIPH_ID_1; // @8164 AXI interconnect - peripheral ID1 register
	 uint8_t RESERVED3[3]; // @8165 
	__I uint8_t AXI_PERIPH_ID_2; // @8168 AXI interconnect - peripheral ID2 register
	 uint8_t RESERVED4[3]; // @8169 
	__I uint8_t AXI_PERIPH_ID_3; // @8172 AXI interconnect - peripheral ID3 register
	 uint8_t RESERVED5[3]; // @8173 
	__I uint8_t AXI_COMP_ID_0; // @8176 AXI interconnect - component ID0 register
	 uint8_t RESERVED6[3]; // @8177 
	__I uint8_t AXI_COMP_ID_1; // @8180 AXI interconnect - component ID1 register
	 uint8_t RESERVED7[3]; // @8181 
	__I uint8_t AXI_COMP_ID_2; // @8184 AXI interconnect - component ID2 register
	 uint8_t RESERVED8[3]; // @8185 
	__I uint8_t AXI_COMP_ID_3; // @8188 AXI interconnect - component ID3 register
	 uint8_t RESERVED9[11]; // @8189 
	__IO uint8_t AXI_TARG1_FN_MOD_ISS_BM; // @8200 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED10[27]; // @8201 
	__IO uint8_t AXI_TARG1_FN_MOD2; // @8228 AXI interconnect - TARG x bus matrix functionality 2 register
	 uint8_t RESERVED11[7]; // @8229 
	__IO uint8_t AXI_TARG1_FN_MOD_LB; // @8236 AXI interconnect - TARG x long burst functionality modification
	 uint8_t RESERVED12[219]; // @8237 
	__IO uint8_t AXI_TARG1_FN_MOD; // @8456 AXI interconnect - TARG x long burst functionality modification
	 uint8_t RESERVED13[3839]; // @8457 
	__IO uint8_t AXI_TARG2_FN_MOD_ISS_BM; // @12296 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED14[27]; // @12297 
	__IO uint8_t AXI_TARG2_FN_MOD2; // @12324 AXI interconnect - TARG x bus matrix functionality 2 register
	 uint8_t RESERVED15[7]; // @12325 
	__IO uint8_t AXI_TARG2_FN_MOD_LB; // @12332 AXI interconnect - TARG x long burst functionality modification
	 uint8_t RESERVED16[219]; // @12333 
	__IO uint8_t AXI_TARG2_FN_MOD; // @12552 AXI interconnect - TARG x long burst functionality modification
	 uint8_t RESERVED17[3839]; // @12553 
	__IO uint8_t AXI_TARG3_FN_MOD_ISS_BM; // @16392 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED18[4095]; // @16393 
	__IO uint8_t AXI_TARG4_FN_MOD_ISS_BM; // @20488 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED19[4095]; // @20489 
	__IO uint8_t AXI_TARG5_FN_MOD_ISS_BM; // @24584 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED20[4095]; // @24585 
	__IO uint8_t AXI_TARG6_FN_MOD_ISS_BM; // @28680 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED21[4099]; // @28681 
	__IO uint8_t AXI_TARG7_FN_MOD_ISS_BM; // @32780 AXI interconnect - TARG x bus matrix issuing functionality register
	 uint8_t RESERVED22[23]; // @32781 
	__IO uint8_t AXI_TARG7_FN_MOD2; // @32804 AXI interconnect - TARG x bus matrix functionality 2 register
	 uint8_t RESERVED23[227]; // @32805 
	__IO uint8_t AXI_TARG7_FN_MOD; // @33032 AXI interconnect - TARG x long burst functionality modification
	 uint8_t RESERVED24[237339]; // @33033 
	__IO uint8_t AXI_INI1_FN_MOD2; // @270372 AXI interconnect - INI x functionality modification 2 register
	 uint8_t RESERVED25[3]; // @270373 
	__IO uint8_t AXI_INI1_FN_MOD_AHB; // @270376 AXI interconnect - INI x AHB functionality modification register
	 uint8_t RESERVED26[215]; // @270377 
	__IO uint8_t AXI_INI1_READ_QOS; // @270592 AXI interconnect - INI x read QoS register
	 uint8_t RESERVED27[3]; // @270593 
	__IO uint8_t AXI_INI1_WRITE_QOS; // @270596 AXI interconnect - INI x write QoS register
	 uint8_t RESERVED28[3]; // @270597 
	__IO uint8_t AXI_INI1_FN_MOD; // @270600 AXI interconnect - INI x issuing functionality modification register
	 uint8_t RESERVED29[4087]; // @270601 
	__IO uint8_t AXI_INI2_READ_QOS; // @274688 AXI interconnect - INI x read QoS register
	 uint8_t RESERVED30[3]; // @274689 
	__IO uint8_t AXI_INI2_WRITE_QOS; // @274692 AXI interconnect - INI x write QoS register
	 uint8_t RESERVED31[3]; // @274693 
	__IO uint8_t AXI_INI2_FN_MOD; // @274696 AXI interconnect - INI x issuing functionality modification register
	 uint8_t RESERVED32[3867]; // @274697 
	__IO uint8_t AXI_INI3_FN_MOD2; // @278564 AXI interconnect - INI x functionality modification 2 register
	 uint8_t RESERVED33[3]; // @278565 
	__IO uint8_t AXI_INI3_FN_MOD_AHB; // @278568 AXI interconnect - INI x AHB functionality modification register
	 uint8_t RESERVED34[215]; // @278569 
	__IO uint8_t AXI_INI3_READ_QOS; // @278784 AXI interconnect - INI x read QoS register
	 uint8_t RESERVED35[3]; // @278785 
	__IO uint8_t AXI_INI3_WRITE_QOS; // @278788 AXI interconnect - INI x write QoS register
	 uint8_t RESERVED36[3]; // @278789 
	__IO uint8_t AXI_INI3_FN_MOD; // @278792 AXI interconnect - INI x issuing functionality modification register
	 uint8_t RESERVED37[4087]; // @278793 
	__IO uint8_t AXI_INI4_READ_QOS; // @282880 AXI interconnect - INI x read QoS register
	 uint8_t RESERVED38[3]; // @282881 
	__IO uint8_t AXI_INI4_WRITE_QOS; // @282884 AXI interconnect - INI x write QoS register
	 uint8_t RESERVED39[3]; // @282885 
	__IO uint8_t AXI_INI4_FN_MOD; // @282888 AXI interconnect - INI x issuing functionality modification register
	 uint8_t RESERVED40[4087]; // @282889 
	__IO uint8_t AXI_INI5_READ_QOS; // @286976 AXI interconnect - INI x read QoS register
	 uint8_t RESERVED41[3]; // @286977 
	__IO uint8_t AXI_INI5_WRITE_QOS; // @286980 AXI interconnect - INI x write QoS register
	 uint8_t RESERVED42[3]; // @286981 
	__IO uint8_t AXI_INI5_FN_MOD; // @286984 AXI interconnect - INI x issuing functionality modification register
	 uint8_t RESERVED43[4087]; // @286985 
	__IO uint8_t AXI_INI6_READ_QOS; // @291072 AXI interconnect - INI x read QoS register
	 uint8_t RESERVED44[3]; // @291073 
	__IO uint8_t AXI_INI6_WRITE_QOS; // @291076 AXI interconnect - INI x write QoS register
	 uint8_t RESERVED45[3]; // @291077 
	__IO uint8_t AXI_INI6_FN_MOD; // @291080 AXI interconnect - INI x issuing functionality modification register
};

// AXI->AXI_PERIPH_ID_4 AXI interconnect - peripheral ID4 register
enum {
	AXI_AXI_PERIPH_ID_4_KCOUNT4 = ((1UL<<4)-1) << 4, // Register file size
	AXI_AXI_PERIPH_ID_4_JEP106CON = ((1UL<<4)-1) << 0, // JEP106 continuation code		
};
inline uint32_t axi_axi_periph_id_4_get_kcount4(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_4 & AXI_AXI_PERIPH_ID_4_KCOUNT4) >> 4 ; }
inline uint32_t axi_axi_periph_id_4_get_jep106con(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_4 & AXI_AXI_PERIPH_ID_4_JEP106CON) >> 0 ; }

// AXI->AXI_PERIPH_ID_1 AXI interconnect - peripheral ID1 register
enum {
	AXI_AXI_PERIPH_ID_1_JEP106I = ((1UL<<4)-1) << 4, // JEP106 identity bits 0 to 3
	AXI_AXI_PERIPH_ID_1_PARTNUM = ((1UL<<4)-1) << 0, // Peripheral part number bits 8 to 11		
};
inline uint32_t axi_axi_periph_id_1_get_jep106i(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_1 & AXI_AXI_PERIPH_ID_1_JEP106I) >> 4 ; }
inline uint32_t axi_axi_periph_id_1_get_partnum(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_1 & AXI_AXI_PERIPH_ID_1_PARTNUM) >> 0 ; }

// AXI->AXI_PERIPH_ID_2 AXI interconnect - peripheral ID2 register
enum {
	AXI_AXI_PERIPH_ID_2_REVISION = ((1UL<<4)-1) << 4, // Peripheral revision number
	AXI_AXI_PERIPH_ID_2_JEDEC = 1UL<<3, // JEP106 code flag
	AXI_AXI_PERIPH_ID_2_JEP106ID = ((1UL<<3)-1) << 0, // JEP106 Identity bits 4 to 6		
};
inline uint32_t axi_axi_periph_id_2_get_revision(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_2 & AXI_AXI_PERIPH_ID_2_REVISION) >> 4 ; }
inline uint32_t axi_axi_periph_id_2_get_jep106id(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_2 & AXI_AXI_PERIPH_ID_2_JEP106ID) >> 0 ; }

// AXI->AXI_PERIPH_ID_3 AXI interconnect - peripheral ID3 register
enum {
	AXI_AXI_PERIPH_ID_3_REV_AND = ((1UL<<4)-1) << 4, // Customer version
	AXI_AXI_PERIPH_ID_3_CUST_MOD_NUM = ((1UL<<4)-1) << 0, // Customer modification		
};
inline uint32_t axi_axi_periph_id_3_get_rev_and(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_3 & AXI_AXI_PERIPH_ID_3_REV_AND) >> 4 ; }
inline uint32_t axi_axi_periph_id_3_get_cust_mod_num(struct AXI_Type* p) { return (p->AXI_PERIPH_ID_3 & AXI_AXI_PERIPH_ID_3_CUST_MOD_NUM) >> 0 ; }

// AXI->AXI_COMP_ID_1 AXI interconnect - component ID1 register
enum {
	AXI_AXI_COMP_ID_1_CLASS = ((1UL<<4)-1) << 4, // Component class
	AXI_AXI_COMP_ID_1_PREAMBLE = ((1UL<<4)-1) << 0, // Preamble bits 8 to 11		
};
inline uint32_t axi_axi_comp_id_1_get_class(struct AXI_Type* p) { return (p->AXI_COMP_ID_1 & AXI_AXI_COMP_ID_1_CLASS) >> 4 ; }
inline uint32_t axi_axi_comp_id_1_get_preamble(struct AXI_Type* p) { return (p->AXI_COMP_ID_1 & AXI_AXI_COMP_ID_1_PREAMBLE) >> 0 ; }

// AXI->AXI_TARG1_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG1_FN_MOD2 AXI interconnect - TARG x bus matrix functionality 2 register
enum {
	AXI_AXI_TARG1_FN_MOD2_BYPASS_MERGE = 1UL<<0, // Disable packing of beats to match the output data width		
};

// AXI->AXI_TARG1_FN_MOD_LB AXI interconnect - TARG x long burst functionality modification
enum {
	AXI_AXI_TARG1_FN_MOD_LB_FN_MOD_LB = 1UL<<0, // Controls burst breaking of long bursts		
};

// AXI->AXI_TARG1_FN_MOD AXI interconnect - TARG x long burst functionality modification
enum {
	AXI_AXI_TARG1_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override AMIB write issuing capability
	AXI_AXI_TARG1_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override AMIB read issuing capability		
};

// AXI->AXI_TARG2_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG2_FN_MOD2 AXI interconnect - TARG x bus matrix functionality 2 register
enum {
	AXI_AXI_TARG2_FN_MOD2_BYPASS_MERGE = 1UL<<0, // Disable packing of beats to match the output data width		
};

// AXI->AXI_TARG2_FN_MOD_LB AXI interconnect - TARG x long burst functionality modification
enum {
	AXI_AXI_TARG2_FN_MOD_LB_FN_MOD_LB = 1UL<<0, // Controls burst breaking of long bursts		
};

// AXI->AXI_TARG2_FN_MOD AXI interconnect - TARG x long burst functionality modification
enum {
	AXI_AXI_TARG2_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override AMIB write issuing capability
	AXI_AXI_TARG2_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override AMIB read issuing capability		
};

// AXI->AXI_TARG3_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG4_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG5_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG6_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG7_FN_MOD_ISS_BM AXI interconnect - TARG x bus matrix issuing functionality register
enum {
	AXI_AXI_TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1UL<<1, // Switch matrix write issuing override for target
	AXI_AXI_TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1UL<<0, // READ_ISS_OVERRIDE		
};

// AXI->AXI_TARG7_FN_MOD2 AXI interconnect - TARG x bus matrix functionality 2 register
enum {
	AXI_AXI_TARG7_FN_MOD2_BYPASS_MERGE = 1UL<<0, // Disable packing of beats to match the output data width		
};

// AXI->AXI_TARG7_FN_MOD AXI interconnect - TARG x long burst functionality modification
enum {
	AXI_AXI_TARG7_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override AMIB write issuing capability
	AXI_AXI_TARG7_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override AMIB read issuing capability		
};

// AXI->AXI_INI1_FN_MOD2 AXI interconnect - INI x functionality modification 2 register
enum {
	AXI_AXI_INI1_FN_MOD2_BYPASS_MERGE = 1UL<<0, // Disables alteration of transactions by the up-sizer unless required by the protocol		
};

// AXI->AXI_INI1_FN_MOD_AHB AXI interconnect - INI x AHB functionality modification register
enum {
	AXI_AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE = 1UL<<1, // Converts all AHB-Lite read transactions to a series of single beat AXI
	AXI_AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE = 1UL<<0, // Converts all AHB-Lite write transactions to a series of single beat AXI		
};

// AXI->AXI_INI1_READ_QOS AXI interconnect - INI x read QoS register
enum {
	AXI_AXI_INI1_READ_QOS_AR_QOS = ((1UL<<4)-1) << 0, // Read channel QoS setting		
};
inline void axi_axi_ini1_read_qos_set_ar_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI1_READ_QOS = (p->AXI_INI1_READ_QOS & ~AXI_AXI_INI1_READ_QOS_AR_QOS) | ((val<<0) & AXI_AXI_INI1_READ_QOS_AR_QOS); }
inline uint32_t axi_axi_ini1_read_qos_get_ar_qos(struct AXI_Type* p) { return (p->AXI_INI1_READ_QOS & AXI_AXI_INI1_READ_QOS_AR_QOS) >> 0 ; }

// AXI->AXI_INI1_WRITE_QOS AXI interconnect - INI x write QoS register
enum {
	AXI_AXI_INI1_WRITE_QOS_AW_QOS = ((1UL<<4)-1) << 0, // Write channel QoS setting		
};
inline void axi_axi_ini1_write_qos_set_aw_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI1_WRITE_QOS = (p->AXI_INI1_WRITE_QOS & ~AXI_AXI_INI1_WRITE_QOS_AW_QOS) | ((val<<0) & AXI_AXI_INI1_WRITE_QOS_AW_QOS); }
inline uint32_t axi_axi_ini1_write_qos_get_aw_qos(struct AXI_Type* p) { return (p->AXI_INI1_WRITE_QOS & AXI_AXI_INI1_WRITE_QOS_AW_QOS) >> 0 ; }

// AXI->AXI_INI1_FN_MOD AXI interconnect - INI x issuing functionality modification register
enum {
	AXI_AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override ASIB write issuing capability
	AXI_AXI_INI1_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override ASIB read issuing capability		
};

// AXI->AXI_INI2_READ_QOS AXI interconnect - INI x read QoS register
enum {
	AXI_AXI_INI2_READ_QOS_AR_QOS = ((1UL<<4)-1) << 0, // Read channel QoS setting		
};
inline void axi_axi_ini2_read_qos_set_ar_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI2_READ_QOS = (p->AXI_INI2_READ_QOS & ~AXI_AXI_INI2_READ_QOS_AR_QOS) | ((val<<0) & AXI_AXI_INI2_READ_QOS_AR_QOS); }
inline uint32_t axi_axi_ini2_read_qos_get_ar_qos(struct AXI_Type* p) { return (p->AXI_INI2_READ_QOS & AXI_AXI_INI2_READ_QOS_AR_QOS) >> 0 ; }

// AXI->AXI_INI2_WRITE_QOS AXI interconnect - INI x write QoS register
enum {
	AXI_AXI_INI2_WRITE_QOS_AW_QOS = ((1UL<<4)-1) << 0, // Write channel QoS setting		
};
inline void axi_axi_ini2_write_qos_set_aw_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI2_WRITE_QOS = (p->AXI_INI2_WRITE_QOS & ~AXI_AXI_INI2_WRITE_QOS_AW_QOS) | ((val<<0) & AXI_AXI_INI2_WRITE_QOS_AW_QOS); }
inline uint32_t axi_axi_ini2_write_qos_get_aw_qos(struct AXI_Type* p) { return (p->AXI_INI2_WRITE_QOS & AXI_AXI_INI2_WRITE_QOS_AW_QOS) >> 0 ; }

// AXI->AXI_INI2_FN_MOD AXI interconnect - INI x issuing functionality modification register
enum {
	AXI_AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override ASIB write issuing capability
	AXI_AXI_INI2_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override ASIB read issuing capability		
};

// AXI->AXI_INI3_FN_MOD2 AXI interconnect - INI x functionality modification 2 register
enum {
	AXI_AXI_INI3_FN_MOD2_BYPASS_MERGE = 1UL<<0, // Disables alteration of transactions by the up-sizer unless required by the protocol		
};

// AXI->AXI_INI3_FN_MOD_AHB AXI interconnect - INI x AHB functionality modification register
enum {
	AXI_AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE = 1UL<<1, // Converts all AHB-Lite read transactions to a series of single beat AXI
	AXI_AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE = 1UL<<0, // Converts all AHB-Lite write transactions to a series of single beat AXI		
};

// AXI->AXI_INI3_READ_QOS AXI interconnect - INI x read QoS register
enum {
	AXI_AXI_INI3_READ_QOS_AR_QOS = ((1UL<<4)-1) << 0, // Read channel QoS setting		
};
inline void axi_axi_ini3_read_qos_set_ar_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI3_READ_QOS = (p->AXI_INI3_READ_QOS & ~AXI_AXI_INI3_READ_QOS_AR_QOS) | ((val<<0) & AXI_AXI_INI3_READ_QOS_AR_QOS); }
inline uint32_t axi_axi_ini3_read_qos_get_ar_qos(struct AXI_Type* p) { return (p->AXI_INI3_READ_QOS & AXI_AXI_INI3_READ_QOS_AR_QOS) >> 0 ; }

// AXI->AXI_INI3_WRITE_QOS AXI interconnect - INI x write QoS register
enum {
	AXI_AXI_INI3_WRITE_QOS_AW_QOS = ((1UL<<4)-1) << 0, // Write channel QoS setting		
};
inline void axi_axi_ini3_write_qos_set_aw_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI3_WRITE_QOS = (p->AXI_INI3_WRITE_QOS & ~AXI_AXI_INI3_WRITE_QOS_AW_QOS) | ((val<<0) & AXI_AXI_INI3_WRITE_QOS_AW_QOS); }
inline uint32_t axi_axi_ini3_write_qos_get_aw_qos(struct AXI_Type* p) { return (p->AXI_INI3_WRITE_QOS & AXI_AXI_INI3_WRITE_QOS_AW_QOS) >> 0 ; }

// AXI->AXI_INI3_FN_MOD AXI interconnect - INI x issuing functionality modification register
enum {
	AXI_AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override ASIB write issuing capability
	AXI_AXI_INI3_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override ASIB read issuing capability		
};

// AXI->AXI_INI4_READ_QOS AXI interconnect - INI x read QoS register
enum {
	AXI_AXI_INI4_READ_QOS_AR_QOS = ((1UL<<4)-1) << 0, // Read channel QoS setting		
};
inline void axi_axi_ini4_read_qos_set_ar_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI4_READ_QOS = (p->AXI_INI4_READ_QOS & ~AXI_AXI_INI4_READ_QOS_AR_QOS) | ((val<<0) & AXI_AXI_INI4_READ_QOS_AR_QOS); }
inline uint32_t axi_axi_ini4_read_qos_get_ar_qos(struct AXI_Type* p) { return (p->AXI_INI4_READ_QOS & AXI_AXI_INI4_READ_QOS_AR_QOS) >> 0 ; }

// AXI->AXI_INI4_WRITE_QOS AXI interconnect - INI x write QoS register
enum {
	AXI_AXI_INI4_WRITE_QOS_AW_QOS = ((1UL<<4)-1) << 0, // Write channel QoS setting		
};
inline void axi_axi_ini4_write_qos_set_aw_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI4_WRITE_QOS = (p->AXI_INI4_WRITE_QOS & ~AXI_AXI_INI4_WRITE_QOS_AW_QOS) | ((val<<0) & AXI_AXI_INI4_WRITE_QOS_AW_QOS); }
inline uint32_t axi_axi_ini4_write_qos_get_aw_qos(struct AXI_Type* p) { return (p->AXI_INI4_WRITE_QOS & AXI_AXI_INI4_WRITE_QOS_AW_QOS) >> 0 ; }

// AXI->AXI_INI4_FN_MOD AXI interconnect - INI x issuing functionality modification register
enum {
	AXI_AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override ASIB write issuing capability
	AXI_AXI_INI4_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override ASIB read issuing capability		
};

// AXI->AXI_INI5_READ_QOS AXI interconnect - INI x read QoS register
enum {
	AXI_AXI_INI5_READ_QOS_AR_QOS = ((1UL<<4)-1) << 0, // Read channel QoS setting		
};
inline void axi_axi_ini5_read_qos_set_ar_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI5_READ_QOS = (p->AXI_INI5_READ_QOS & ~AXI_AXI_INI5_READ_QOS_AR_QOS) | ((val<<0) & AXI_AXI_INI5_READ_QOS_AR_QOS); }
inline uint32_t axi_axi_ini5_read_qos_get_ar_qos(struct AXI_Type* p) { return (p->AXI_INI5_READ_QOS & AXI_AXI_INI5_READ_QOS_AR_QOS) >> 0 ; }

// AXI->AXI_INI5_WRITE_QOS AXI interconnect - INI x write QoS register
enum {
	AXI_AXI_INI5_WRITE_QOS_AW_QOS = ((1UL<<4)-1) << 0, // Write channel QoS setting		
};
inline void axi_axi_ini5_write_qos_set_aw_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI5_WRITE_QOS = (p->AXI_INI5_WRITE_QOS & ~AXI_AXI_INI5_WRITE_QOS_AW_QOS) | ((val<<0) & AXI_AXI_INI5_WRITE_QOS_AW_QOS); }
inline uint32_t axi_axi_ini5_write_qos_get_aw_qos(struct AXI_Type* p) { return (p->AXI_INI5_WRITE_QOS & AXI_AXI_INI5_WRITE_QOS_AW_QOS) >> 0 ; }

// AXI->AXI_INI5_FN_MOD AXI interconnect - INI x issuing functionality modification register
enum {
	AXI_AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override ASIB write issuing capability
	AXI_AXI_INI5_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override ASIB read issuing capability		
};

// AXI->AXI_INI6_READ_QOS AXI interconnect - INI x read QoS register
enum {
	AXI_AXI_INI6_READ_QOS_AR_QOS = ((1UL<<4)-1) << 0, // Read channel QoS setting		
};
inline void axi_axi_ini6_read_qos_set_ar_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI6_READ_QOS = (p->AXI_INI6_READ_QOS & ~AXI_AXI_INI6_READ_QOS_AR_QOS) | ((val<<0) & AXI_AXI_INI6_READ_QOS_AR_QOS); }
inline uint32_t axi_axi_ini6_read_qos_get_ar_qos(struct AXI_Type* p) { return (p->AXI_INI6_READ_QOS & AXI_AXI_INI6_READ_QOS_AR_QOS) >> 0 ; }

// AXI->AXI_INI6_WRITE_QOS AXI interconnect - INI x write QoS register
enum {
	AXI_AXI_INI6_WRITE_QOS_AW_QOS = ((1UL<<4)-1) << 0, // Write channel QoS setting		
};
inline void axi_axi_ini6_write_qos_set_aw_qos(struct AXI_Type* p, uint32_t val) { p->AXI_INI6_WRITE_QOS = (p->AXI_INI6_WRITE_QOS & ~AXI_AXI_INI6_WRITE_QOS_AW_QOS) | ((val<<0) & AXI_AXI_INI6_WRITE_QOS_AW_QOS); }
inline uint32_t axi_axi_ini6_write_qos_get_aw_qos(struct AXI_Type* p) { return (p->AXI_INI6_WRITE_QOS & AXI_AXI_INI6_WRITE_QOS_AW_QOS) >> 0 ; }

// AXI->AXI_INI6_FN_MOD AXI interconnect - INI x issuing functionality modification register
enum {
	AXI_AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE = 1UL<<1, // Override ASIB write issuing capability
	AXI_AXI_INI6_FN_MOD_READ_ISS_OVERRIDE = 1UL<<0, // Override ASIB read issuing capability		
};

/* BDMA */
struct BDMA_Type {
	__I uint32_t ISR; // @0 DMA interrupt status register
	__O uint32_t IFCR; // @4 DMA interrupt flag clear register
	__IO uint16_t CCR1; // @8 DMA channel x configuration register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t CNDTR1; // @12 DMA channel x number of data register
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t CPAR1; // @16 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR1; // @20 This register must not be written when the channel is enabled.
	 uint8_t RESERVED2[4]; // @24 
	__IO uint16_t CCR2; // @28 DMA channel x configuration register
	 uint8_t RESERVED3[2]; // @30 
	__IO uint16_t CNDTR2; // @32 DMA channel x number of data register
	 uint8_t RESERVED4[2]; // @34 
	__IO uint32_t CPAR2; // @36 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR2; // @40 This register must not be written when the channel is enabled.
	 uint8_t RESERVED5[4]; // @44 
	__IO uint16_t CCR3; // @48 DMA channel x configuration register
	 uint8_t RESERVED6[2]; // @50 
	__IO uint16_t CNDTR3; // @52 DMA channel x number of data register
	 uint8_t RESERVED7[2]; // @54 
	__IO uint32_t CPAR3; // @56 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR3; // @60 This register must not be written when the channel is enabled.
	 uint8_t RESERVED8[4]; // @64 
	__IO uint16_t CCR4; // @68 DMA channel x configuration register
	 uint8_t RESERVED9[2]; // @70 
	__IO uint16_t CNDTR4; // @72 DMA channel x number of data register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint32_t CPAR4; // @76 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR4; // @80 This register must not be written when the channel is enabled.
	 uint8_t RESERVED11[4]; // @84 
	__IO uint16_t CCR5; // @88 DMA channel x configuration register
	 uint8_t RESERVED12[2]; // @90 
	__IO uint16_t CNDTR5; // @92 DMA channel x number of data register
	 uint8_t RESERVED13[2]; // @94 
	__IO uint32_t CPAR5; // @96 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR5; // @100 This register must not be written when the channel is enabled.
	 uint8_t RESERVED14[4]; // @104 
	__IO uint16_t CCR6; // @108 DMA channel x configuration register
	 uint8_t RESERVED15[2]; // @110 
	__IO uint16_t CNDTR6; // @112 DMA channel x number of data register
	 uint8_t RESERVED16[2]; // @114 
	__IO uint32_t CPAR6; // @116 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR6; // @120 This register must not be written when the channel is enabled.
	 uint8_t RESERVED17[4]; // @124 
	__IO uint16_t CCR7; // @128 DMA channel x configuration register
	 uint8_t RESERVED18[2]; // @130 
	__IO uint16_t CNDTR7; // @132 DMA channel x number of data register
	 uint8_t RESERVED19[2]; // @134 
	__IO uint32_t CPAR7; // @136 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR7; // @140 This register must not be written when the channel is enabled.
	 uint8_t RESERVED20[4]; // @144 
	__IO uint16_t CCR8; // @148 DMA channel x configuration register
	 uint8_t RESERVED21[2]; // @150 
	__IO uint16_t CNDTR8; // @152 DMA channel x number of data register
	 uint8_t RESERVED22[2]; // @154 
	__IO uint32_t CPAR8; // @156 This register must not be written when the channel is enabled.
	__IO uint32_t CMAR8; // @160 This register must not be written when the channel is enabled.
};

// BDMA->ISR DMA interrupt status register
enum {
	BDMA_ISR_TEIF8 = 1UL<<31, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF8 = 1UL<<30, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF8 = 1UL<<29, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF8 = 1UL<<28, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF7 = 1UL<<27, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF7 = 1UL<<26, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF7 = 1UL<<25, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF7 = 1UL<<24, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF6 = 1UL<<23, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF6 = 1UL<<22, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF6 = 1UL<<21, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF6 = 1UL<<20, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF5 = 1UL<<19, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF5 = 1UL<<18, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF5 = 1UL<<17, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF5 = 1UL<<16, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF4 = 1UL<<15, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF4 = 1UL<<14, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF4 = 1UL<<13, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF4 = 1UL<<12, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF3 = 1UL<<11, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF3 = 1UL<<10, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF3 = 1UL<<9, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF3 = 1UL<<8, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF2 = 1UL<<7, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF2 = 1UL<<6, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF2 = 1UL<<5, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF2 = 1UL<<4, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TEIF1 = 1UL<<3, // Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_HTIF1 = 1UL<<2, // Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_TCIF1 = 1UL<<1, // Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
	BDMA_ISR_GIF1 = 1UL<<0, // Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.		
};

// BDMA->IFCR DMA interrupt flag clear register
enum {
	BDMA_IFCR_CTEIF8 = 1UL<<31, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF8 = 1UL<<30, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF8 = 1UL<<29, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF8 = 1UL<<28, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF7 = 1UL<<27, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF7 = 1UL<<26, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF7 = 1UL<<25, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF7 = 1UL<<24, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF6 = 1UL<<23, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF6 = 1UL<<22, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF6 = 1UL<<21, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF6 = 1UL<<20, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF5 = 1UL<<19, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF5 = 1UL<<18, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF5 = 1UL<<17, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF5 = 1UL<<16, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF4 = 1UL<<15, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF4 = 1UL<<14, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF4 = 1UL<<13, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF4 = 1UL<<12, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF3 = 1UL<<11, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF3 = 1UL<<10, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF3 = 1UL<<9, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF3 = 1UL<<8, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF2 = 1UL<<7, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF2 = 1UL<<6, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF2 = 1UL<<5, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF2 = 1UL<<4, // Channel x global interrupt clear This bit is set and cleared by software.
	BDMA_IFCR_CTEIF1 = 1UL<<3, // Channel x transfer error clear This bit is set and cleared by software.
	BDMA_IFCR_CHTIF1 = 1UL<<2, // Channel x half transfer clear This bit is set and cleared by software.
	BDMA_IFCR_CTCIF1 = 1UL<<1, // Channel x transfer complete clear This bit is set and cleared by software.
	BDMA_IFCR_CGIF1 = 1UL<<0, // Channel x global interrupt clear This bit is set and cleared by software.		
};

// BDMA->CCR1 DMA channel x configuration register
enum {
	BDMA_CCR1_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR1_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR1_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR1_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR1_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR1_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR1_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR1_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR1_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR1_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR1_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR1_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr1_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~BDMA_CCR1_PL) | ((val<<12) & BDMA_CCR1_PL); }
inline void bdma_ccr1_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~BDMA_CCR1_MSIZE) | ((val<<10) & BDMA_CCR1_MSIZE); }
inline void bdma_ccr1_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~BDMA_CCR1_PSIZE) | ((val<<8) & BDMA_CCR1_PSIZE); }
inline uint32_t bdma_ccr1_get_pl(struct BDMA_Type* p) { return (p->CCR1 & BDMA_CCR1_PL) >> 12 ; }
inline uint32_t bdma_ccr1_get_msize(struct BDMA_Type* p) { return (p->CCR1 & BDMA_CCR1_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr1_get_psize(struct BDMA_Type* p) { return (p->CCR1 & BDMA_CCR1_PSIZE) >> 8 ; }

// BDMA->CCR2 DMA channel x configuration register
enum {
	BDMA_CCR2_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR2_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR2_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR2_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR2_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR2_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR2_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR2_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR2_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR2_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR2_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR2_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr2_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~BDMA_CCR2_PL) | ((val<<12) & BDMA_CCR2_PL); }
inline void bdma_ccr2_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~BDMA_CCR2_MSIZE) | ((val<<10) & BDMA_CCR2_MSIZE); }
inline void bdma_ccr2_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~BDMA_CCR2_PSIZE) | ((val<<8) & BDMA_CCR2_PSIZE); }
inline uint32_t bdma_ccr2_get_pl(struct BDMA_Type* p) { return (p->CCR2 & BDMA_CCR2_PL) >> 12 ; }
inline uint32_t bdma_ccr2_get_msize(struct BDMA_Type* p) { return (p->CCR2 & BDMA_CCR2_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr2_get_psize(struct BDMA_Type* p) { return (p->CCR2 & BDMA_CCR2_PSIZE) >> 8 ; }

// BDMA->CCR3 DMA channel x configuration register
enum {
	BDMA_CCR3_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR3_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR3_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR3_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR3_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR3_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR3_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR3_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR3_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR3_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR3_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR3_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr3_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~BDMA_CCR3_PL) | ((val<<12) & BDMA_CCR3_PL); }
inline void bdma_ccr3_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~BDMA_CCR3_MSIZE) | ((val<<10) & BDMA_CCR3_MSIZE); }
inline void bdma_ccr3_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~BDMA_CCR3_PSIZE) | ((val<<8) & BDMA_CCR3_PSIZE); }
inline uint32_t bdma_ccr3_get_pl(struct BDMA_Type* p) { return (p->CCR3 & BDMA_CCR3_PL) >> 12 ; }
inline uint32_t bdma_ccr3_get_msize(struct BDMA_Type* p) { return (p->CCR3 & BDMA_CCR3_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr3_get_psize(struct BDMA_Type* p) { return (p->CCR3 & BDMA_CCR3_PSIZE) >> 8 ; }

// BDMA->CCR4 DMA channel x configuration register
enum {
	BDMA_CCR4_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR4_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR4_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR4_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR4_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR4_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR4_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR4_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR4_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR4_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR4_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR4_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr4_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~BDMA_CCR4_PL) | ((val<<12) & BDMA_CCR4_PL); }
inline void bdma_ccr4_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~BDMA_CCR4_MSIZE) | ((val<<10) & BDMA_CCR4_MSIZE); }
inline void bdma_ccr4_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~BDMA_CCR4_PSIZE) | ((val<<8) & BDMA_CCR4_PSIZE); }
inline uint32_t bdma_ccr4_get_pl(struct BDMA_Type* p) { return (p->CCR4 & BDMA_CCR4_PL) >> 12 ; }
inline uint32_t bdma_ccr4_get_msize(struct BDMA_Type* p) { return (p->CCR4 & BDMA_CCR4_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr4_get_psize(struct BDMA_Type* p) { return (p->CCR4 & BDMA_CCR4_PSIZE) >> 8 ; }

// BDMA->CCR5 DMA channel x configuration register
enum {
	BDMA_CCR5_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR5_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR5_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR5_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR5_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR5_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR5_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR5_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR5_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR5_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR5_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR5_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr5_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~BDMA_CCR5_PL) | ((val<<12) & BDMA_CCR5_PL); }
inline void bdma_ccr5_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~BDMA_CCR5_MSIZE) | ((val<<10) & BDMA_CCR5_MSIZE); }
inline void bdma_ccr5_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~BDMA_CCR5_PSIZE) | ((val<<8) & BDMA_CCR5_PSIZE); }
inline uint32_t bdma_ccr5_get_pl(struct BDMA_Type* p) { return (p->CCR5 & BDMA_CCR5_PL) >> 12 ; }
inline uint32_t bdma_ccr5_get_msize(struct BDMA_Type* p) { return (p->CCR5 & BDMA_CCR5_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr5_get_psize(struct BDMA_Type* p) { return (p->CCR5 & BDMA_CCR5_PSIZE) >> 8 ; }

// BDMA->CCR6 DMA channel x configuration register
enum {
	BDMA_CCR6_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR6_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR6_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR6_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR6_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR6_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR6_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR6_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR6_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR6_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR6_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR6_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr6_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~BDMA_CCR6_PL) | ((val<<12) & BDMA_CCR6_PL); }
inline void bdma_ccr6_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~BDMA_CCR6_MSIZE) | ((val<<10) & BDMA_CCR6_MSIZE); }
inline void bdma_ccr6_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~BDMA_CCR6_PSIZE) | ((val<<8) & BDMA_CCR6_PSIZE); }
inline uint32_t bdma_ccr6_get_pl(struct BDMA_Type* p) { return (p->CCR6 & BDMA_CCR6_PL) >> 12 ; }
inline uint32_t bdma_ccr6_get_msize(struct BDMA_Type* p) { return (p->CCR6 & BDMA_CCR6_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr6_get_psize(struct BDMA_Type* p) { return (p->CCR6 & BDMA_CCR6_PSIZE) >> 8 ; }

// BDMA->CCR7 DMA channel x configuration register
enum {
	BDMA_CCR7_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR7_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR7_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR7_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR7_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR7_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR7_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR7_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR7_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR7_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR7_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR7_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr7_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~BDMA_CCR7_PL) | ((val<<12) & BDMA_CCR7_PL); }
inline void bdma_ccr7_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~BDMA_CCR7_MSIZE) | ((val<<10) & BDMA_CCR7_MSIZE); }
inline void bdma_ccr7_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~BDMA_CCR7_PSIZE) | ((val<<8) & BDMA_CCR7_PSIZE); }
inline uint32_t bdma_ccr7_get_pl(struct BDMA_Type* p) { return (p->CCR7 & BDMA_CCR7_PL) >> 12 ; }
inline uint32_t bdma_ccr7_get_msize(struct BDMA_Type* p) { return (p->CCR7 & BDMA_CCR7_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr7_get_psize(struct BDMA_Type* p) { return (p->CCR7 & BDMA_CCR7_PSIZE) >> 8 ; }

// BDMA->CCR8 DMA channel x configuration register
enum {
	BDMA_CCR8_MEM2MEM = 1UL<<14, // Memory to memory mode This bit is set and cleared by software.
	BDMA_CCR8_PL = ((1UL<<2)-1) << 12, // Channel priority level These bits are set and cleared by software.
	BDMA_CCR8_MSIZE = ((1UL<<2)-1) << 10, // Memory size These bits are set and cleared by software.
	BDMA_CCR8_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size These bits are set and cleared by software.
	BDMA_CCR8_MINC = 1UL<<7, // Memory increment mode This bit is set and cleared by software.
	BDMA_CCR8_PINC = 1UL<<6, // Peripheral increment mode This bit is set and cleared by software.
	BDMA_CCR8_CIRC = 1UL<<5, // Circular mode This bit is set and cleared by software.
	BDMA_CCR8_DIR = 1UL<<4, // Data transfer direction This bit is set and cleared by software.
	BDMA_CCR8_TEIE = 1UL<<3, // Transfer error interrupt enable This bit is set and cleared by software.
	BDMA_CCR8_HTIE = 1UL<<2, // Half transfer interrupt enable This bit is set and cleared by software.
	BDMA_CCR8_TCIE = 1UL<<1, // Transfer complete interrupt enable This bit is set and cleared by software.
	BDMA_CCR8_EN = 1UL<<0, // Channel enable This bit is set and cleared by software.		
};
inline void bdma_ccr8_set_pl(struct BDMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~BDMA_CCR8_PL) | ((val<<12) & BDMA_CCR8_PL); }
inline void bdma_ccr8_set_msize(struct BDMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~BDMA_CCR8_MSIZE) | ((val<<10) & BDMA_CCR8_MSIZE); }
inline void bdma_ccr8_set_psize(struct BDMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~BDMA_CCR8_PSIZE) | ((val<<8) & BDMA_CCR8_PSIZE); }
inline uint32_t bdma_ccr8_get_pl(struct BDMA_Type* p) { return (p->CCR8 & BDMA_CCR8_PL) >> 12 ; }
inline uint32_t bdma_ccr8_get_msize(struct BDMA_Type* p) { return (p->CCR8 & BDMA_CCR8_MSIZE) >> 10 ; }
inline uint32_t bdma_ccr8_get_psize(struct BDMA_Type* p) { return (p->CCR8 & BDMA_CCR8_PSIZE) >> 8 ; }

/* CCU registers */
struct CAN_CCU_Type {
	__IO uint32_t CREL; // @0 Clock Calibration Unit Core Release Register
	__IO uint32_t CCFG; // @4 Calibration Configuration Register
	__IO uint32_t CSTAT; // @8 Calibration Status Register
	__IO uint32_t CWD; // @12 Calibration Watchdog Register
	__IO uint8_t IR; // @16 Clock Calibration Unit Interrupt Register
	 uint8_t RESERVED0[3]; // @17 
	__IO uint8_t IE; // @20 Clock Calibration Unit Interrupt Enable Register
};

// CAN_CCU->CREL Clock Calibration Unit Core Release Register
enum {
	CAN_CCU_CREL_REL = ((1UL<<4)-1) << 28, // Core Release
	CAN_CCU_CREL_STEP = ((1UL<<4)-1) << 24, // Step of Core Release
	CAN_CCU_CREL_SUBSTEP = ((1UL<<4)-1) << 20, // Sub-step of Core Release
	CAN_CCU_CREL_YEAR = ((1UL<<4)-1) << 16, // Time Stamp Year
	CAN_CCU_CREL_MON = ((1UL<<8)-1) << 8, // Time Stamp Month
	CAN_CCU_CREL_DAY = ((1UL<<8)-1) << 0, // Time Stamp Day		
};
inline void can_ccu_crel_set_rel(struct CAN_CCU_Type* p, uint32_t val) { p->CREL = (p->CREL & ~CAN_CCU_CREL_REL) | ((val<<28) & CAN_CCU_CREL_REL); }
inline void can_ccu_crel_set_step(struct CAN_CCU_Type* p, uint32_t val) { p->CREL = (p->CREL & ~CAN_CCU_CREL_STEP) | ((val<<24) & CAN_CCU_CREL_STEP); }
inline void can_ccu_crel_set_substep(struct CAN_CCU_Type* p, uint32_t val) { p->CREL = (p->CREL & ~CAN_CCU_CREL_SUBSTEP) | ((val<<20) & CAN_CCU_CREL_SUBSTEP); }
inline void can_ccu_crel_set_year(struct CAN_CCU_Type* p, uint32_t val) { p->CREL = (p->CREL & ~CAN_CCU_CREL_YEAR) | ((val<<16) & CAN_CCU_CREL_YEAR); }
inline void can_ccu_crel_set_mon(struct CAN_CCU_Type* p, uint32_t val) { p->CREL = (p->CREL & ~CAN_CCU_CREL_MON) | ((val<<8) & CAN_CCU_CREL_MON); }
inline void can_ccu_crel_set_day(struct CAN_CCU_Type* p, uint32_t val) { p->CREL = (p->CREL & ~CAN_CCU_CREL_DAY) | ((val<<0) & CAN_CCU_CREL_DAY); }
inline uint32_t can_ccu_crel_get_rel(struct CAN_CCU_Type* p) { return (p->CREL & CAN_CCU_CREL_REL) >> 28 ; }
inline uint32_t can_ccu_crel_get_step(struct CAN_CCU_Type* p) { return (p->CREL & CAN_CCU_CREL_STEP) >> 24 ; }
inline uint32_t can_ccu_crel_get_substep(struct CAN_CCU_Type* p) { return (p->CREL & CAN_CCU_CREL_SUBSTEP) >> 20 ; }
inline uint32_t can_ccu_crel_get_year(struct CAN_CCU_Type* p) { return (p->CREL & CAN_CCU_CREL_YEAR) >> 16 ; }
inline uint32_t can_ccu_crel_get_mon(struct CAN_CCU_Type* p) { return (p->CREL & CAN_CCU_CREL_MON) >> 8 ; }
inline uint32_t can_ccu_crel_get_day(struct CAN_CCU_Type* p) { return (p->CREL & CAN_CCU_CREL_DAY) >> 0 ; }

// CAN_CCU->CCFG Calibration Configuration Register
enum {
	CAN_CCU_CCFG_SWR = 1UL<<31, // Software Reset
	CAN_CCU_CCFG_CDIV = ((1UL<<4)-1) << 16, // Clock Divider
	CAN_CCU_CCFG_OCPM = ((1UL<<8)-1) << 8, // Oscillator Clock Periods Minimum
	CAN_CCU_CCFG_CFL = 1UL<<7, // Calibration Field Length
	CAN_CCU_CCFG_BCC = 1UL<<6, // Bypass Clock Calibration
	CAN_CCU_CCFG_TQBT = ((1UL<<5)-1) << 0, // Time Quanta per Bit Time		
};
inline void can_ccu_ccfg_set_cdiv(struct CAN_CCU_Type* p, uint32_t val) { p->CCFG = (p->CCFG & ~CAN_CCU_CCFG_CDIV) | ((val<<16) & CAN_CCU_CCFG_CDIV); }
inline void can_ccu_ccfg_set_ocpm(struct CAN_CCU_Type* p, uint32_t val) { p->CCFG = (p->CCFG & ~CAN_CCU_CCFG_OCPM) | ((val<<8) & CAN_CCU_CCFG_OCPM); }
inline void can_ccu_ccfg_set_tqbt(struct CAN_CCU_Type* p, uint32_t val) { p->CCFG = (p->CCFG & ~CAN_CCU_CCFG_TQBT) | ((val<<0) & CAN_CCU_CCFG_TQBT); }
inline uint32_t can_ccu_ccfg_get_cdiv(struct CAN_CCU_Type* p) { return (p->CCFG & CAN_CCU_CCFG_CDIV) >> 16 ; }
inline uint32_t can_ccu_ccfg_get_ocpm(struct CAN_CCU_Type* p) { return (p->CCFG & CAN_CCU_CCFG_OCPM) >> 8 ; }
inline uint32_t can_ccu_ccfg_get_tqbt(struct CAN_CCU_Type* p) { return (p->CCFG & CAN_CCU_CCFG_TQBT) >> 0 ; }

// CAN_CCU->CSTAT Calibration Status Register
enum {
	CAN_CCU_CSTAT_CALS = ((1UL<<2)-1) << 30, // Calibration State
	CAN_CCU_CSTAT_TQC = ((1UL<<11)-1) << 18, // Time Quanta Counter
	CAN_CCU_CSTAT_OCPC = ((1UL<<18)-1) << 0, // Oscillator Clock Period Counter		
};
inline void can_ccu_cstat_set_cals(struct CAN_CCU_Type* p, uint32_t val) { p->CSTAT = (p->CSTAT & ~CAN_CCU_CSTAT_CALS) | ((val<<30) & CAN_CCU_CSTAT_CALS); }
inline void can_ccu_cstat_set_tqc(struct CAN_CCU_Type* p, uint32_t val) { p->CSTAT = (p->CSTAT & ~CAN_CCU_CSTAT_TQC) | ((val<<18) & CAN_CCU_CSTAT_TQC); }
inline void can_ccu_cstat_set_ocpc(struct CAN_CCU_Type* p, uint32_t val) { p->CSTAT = (p->CSTAT & ~CAN_CCU_CSTAT_OCPC) | ((val<<0) & CAN_CCU_CSTAT_OCPC); }
inline uint32_t can_ccu_cstat_get_cals(struct CAN_CCU_Type* p) { return (p->CSTAT & CAN_CCU_CSTAT_CALS) >> 30 ; }
inline uint32_t can_ccu_cstat_get_tqc(struct CAN_CCU_Type* p) { return (p->CSTAT & CAN_CCU_CSTAT_TQC) >> 18 ; }
inline uint32_t can_ccu_cstat_get_ocpc(struct CAN_CCU_Type* p) { return (p->CSTAT & CAN_CCU_CSTAT_OCPC) >> 0 ; }

// CAN_CCU->CWD Calibration Watchdog Register
enum {
	CAN_CCU_CWD_WDV = ((1UL<<16)-1) << 16, // WDV
	CAN_CCU_CWD_WDC = ((1UL<<16)-1) << 0, // WDC		
};
inline void can_ccu_cwd_set_wdv(struct CAN_CCU_Type* p, uint32_t val) { p->CWD = (p->CWD & ~CAN_CCU_CWD_WDV) | ((val<<16) & CAN_CCU_CWD_WDV); }
inline void can_ccu_cwd_set_wdc(struct CAN_CCU_Type* p, uint32_t val) { p->CWD = (p->CWD & ~CAN_CCU_CWD_WDC) | ((val<<0) & CAN_CCU_CWD_WDC); }
inline uint32_t can_ccu_cwd_get_wdv(struct CAN_CCU_Type* p) { return (p->CWD & CAN_CCU_CWD_WDV) >> 16 ; }
inline uint32_t can_ccu_cwd_get_wdc(struct CAN_CCU_Type* p) { return (p->CWD & CAN_CCU_CWD_WDC) >> 0 ; }

// CAN_CCU->IR Clock Calibration Unit Interrupt Register
enum {
	CAN_CCU_IR_CSC = 1UL<<1, // Calibration State Changed
	CAN_CCU_IR_CWE = 1UL<<0, // Calibration Watchdog Event		
};

// CAN_CCU->IE Clock Calibration Unit Interrupt Enable Register
enum {
	CAN_CCU_IE_CSCE = 1UL<<1, // Calibration State Changed Enable
	CAN_CCU_IE_CWEE = 1UL<<0, // Calibration Watchdog Event Enable		
};

/* CEC */
struct CEC_Type {
	__IO uint8_t CR; // @0 CEC control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CFGR; // @4 This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
	__O uint8_t TXDR; // @8 CEC Tx data register
	 uint8_t RESERVED1[3]; // @9 
	__I uint8_t RXDR; // @12 CEC Rx Data Register
	 uint8_t RESERVED2[3]; // @13 
	__IO uint16_t ISR; // @16 CEC Interrupt and Status Register
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t IER; // @20 CEC interrupt enable register
};

// CEC->CR CEC control register
enum {
	CEC_CR_TXEOM = 1UL<<2, // Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
	CEC_CR_TXSOM = 1UL<<1, // Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
	CEC_CR_CECEN = 1UL<<0, // CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.		
};

// CEC->CFGR This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
enum {
	CEC_CFGR_LSTN = 1UL<<31, // Listen mode LSTN bit is set and cleared by software.
	CEC_CFGR_OAR = ((1UL<<15)-1) << 16, // Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
	CEC_CFGR_SFTOPT = 1UL<<8, // SFT Option Bit The SFTOPT bit is set and cleared by software.
	CEC_CFGR_BRDNOGEN = 1UL<<7, // Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
	CEC_CFGR_LBPEGEN = 1UL<<6, // Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
	CEC_CFGR_BREGEN = 1UL<<5, // Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
	CEC_CFGR_BRESTP = 1UL<<4, // Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
	CEC_CFGR_RXTOL = 1UL<<3, // Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
	CEC_CFGR_SFT = ((1UL<<3)-1) << 0, // Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods		
};
inline void cec_cfgr_set_oar(struct CEC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CEC_CFGR_OAR) | ((val<<16) & CEC_CFGR_OAR); }
inline void cec_cfgr_set_sft(struct CEC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CEC_CFGR_SFT) | ((val<<0) & CEC_CFGR_SFT); }
inline uint32_t cec_cfgr_get_oar(struct CEC_Type* p) { return (p->CFGR & CEC_CFGR_OAR) >> 16 ; }
inline uint32_t cec_cfgr_get_sft(struct CEC_Type* p) { return (p->CFGR & CEC_CFGR_SFT) >> 0 ; }

// CEC->ISR CEC Interrupt and Status Register
enum {
	CEC_ISR_TXACKE = 1UL<<12, // Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
	CEC_ISR_TXERR = 1UL<<11, // Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
	CEC_ISR_TXUDR = 1UL<<10, // Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
	CEC_ISR_TXEND = 1UL<<9, // End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
	CEC_ISR_TXBR = 1UL<<8, // Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
	CEC_ISR_ARBLST = 1UL<<7, // Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
	CEC_ISR_RXACKE = 1UL<<6, // Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
	CEC_ISR_LBPE = 1UL<<5, // Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
	CEC_ISR_SBPE = 1UL<<4, // Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
	CEC_ISR_BRE = 1UL<<3, // Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
	CEC_ISR_RXOVR = 1UL<<2, // Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
	CEC_ISR_RXEND = 1UL<<1, // End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
	CEC_ISR_RXBR = 1UL<<0, // Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.		
};

// CEC->IER CEC interrupt enable register
enum {
	CEC_IER_TXACKIE = 1UL<<12, // Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
	CEC_IER_TXERRIE = 1UL<<11, // Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
	CEC_IER_TXUDRIE = 1UL<<10, // Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
	CEC_IER_TXENDIE = 1UL<<9, // Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
	CEC_IER_TXBRIE = 1UL<<8, // Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
	CEC_IER_ARBLSTIE = 1UL<<7, // Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
	CEC_IER_RXACKIE = 1UL<<6, // Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
	CEC_IER_LBPEIE = 1UL<<5, // Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
	CEC_IER_SBPEIE = 1UL<<4, // Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
	CEC_IER_BREIE = 1UL<<3, // Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
	CEC_IER_RXOVRIE = 1UL<<2, // Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
	CEC_IER_RXENDIE = 1UL<<1, // End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
	CEC_IER_RXBRIE = 1UL<<0, // Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.		
};

/* COMP1 */
struct COMP1_Type {
	__I uint32_t SR; // @0 Comparator status register
	__O uint32_t ICFR; // @4 Comparator interrupt clear flag register
	__IO uint32_t OR; // @8 Comparator option register
	__IO uint32_t CFGR1; // @12 Comparator configuration register 1
	__IO uint32_t CFGR2; // @16 Comparator configuration register 2
};

// COMP1->SR Comparator status register
enum {
	COMP1_SR_C2IF = 1UL<<17, // COMP channel 2 Interrupt Flag
	COMP1_SR_C1IF = 1UL<<16, // COMP channel 1 Interrupt Flag
	COMP1_SR_C2VAL = 1UL<<1, // COMP channel 2 output status bit
	COMP1_SR_C1VAL = 1UL<<0, // COMP channel 1 output status bit		
};

// COMP1->ICFR Comparator interrupt clear flag register
enum {
	COMP1_ICFR_CC2IF = 1UL<<17, // Clear COMP channel 2 Interrupt Flag
	COMP1_ICFR_CC1IF = 1UL<<16, // Clear COMP channel 1 Interrupt Flag		
};

// COMP1->OR Comparator option register
enum {
	COMP1_OR_OR = ((1UL<<21)-1) << 11, // Option Register
	COMP1_OR_AFOP = ((1UL<<11)-1) << 0, // Selection of source for alternate function of output ports		
};
inline void comp1_or_set_or(struct COMP1_Type* p, uint32_t val) { p->OR = (p->OR & ~COMP1_OR_OR) | ((val<<11) & COMP1_OR_OR); }
inline void comp1_or_set_afop(struct COMP1_Type* p, uint32_t val) { p->OR = (p->OR & ~COMP1_OR_AFOP) | ((val<<0) & COMP1_OR_AFOP); }
inline uint32_t comp1_or_get_or(struct COMP1_Type* p) { return (p->OR & COMP1_OR_OR) >> 11 ; }
inline uint32_t comp1_or_get_afop(struct COMP1_Type* p) { return (p->OR & COMP1_OR_AFOP) >> 0 ; }

// COMP1->CFGR1 Comparator configuration register 1
enum {
	COMP1_CFGR1_LOCK = 1UL<<31, // Lock bit
	COMP1_CFGR1_BLANKING = ((1UL<<4)-1) << 24, // COMP channel 1 blanking source selection bits
	COMP1_CFGR1_INPSEL = 1UL<<20, // COMP channel 1 non-inverting input selection bit
	COMP1_CFGR1_INMSEL = ((1UL<<3)-1) << 16, // COMP channel 1 inverting input selection field
	COMP1_CFGR1_PWRMODE = ((1UL<<2)-1) << 12, // Power Mode of the COMP channel 1
	COMP1_CFGR1_HYST = ((1UL<<2)-1) << 8, // COMP channel 1 hysteresis selection bits
	COMP1_CFGR1_ITEN = 1UL<<6, // COMP channel 1 interrupt enable
	COMP1_CFGR1_POLARITY = 1UL<<3, // COMP channel 1 polarity selection bit
	COMP1_CFGR1_SCALEN = 1UL<<2, // Voltage scaler enable bit
	COMP1_CFGR1_BRGEN = 1UL<<1, // Scaler bridge enable
	COMP1_CFGR1_EN = 1UL<<0, // COMP channel 1 enable bit		
};
inline void comp1_cfgr1_set_blanking(struct COMP1_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~COMP1_CFGR1_BLANKING) | ((val<<24) & COMP1_CFGR1_BLANKING); }
inline void comp1_cfgr1_set_inmsel(struct COMP1_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~COMP1_CFGR1_INMSEL) | ((val<<16) & COMP1_CFGR1_INMSEL); }
inline void comp1_cfgr1_set_pwrmode(struct COMP1_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~COMP1_CFGR1_PWRMODE) | ((val<<12) & COMP1_CFGR1_PWRMODE); }
inline void comp1_cfgr1_set_hyst(struct COMP1_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~COMP1_CFGR1_HYST) | ((val<<8) & COMP1_CFGR1_HYST); }
inline uint32_t comp1_cfgr1_get_blanking(struct COMP1_Type* p) { return (p->CFGR1 & COMP1_CFGR1_BLANKING) >> 24 ; }
inline uint32_t comp1_cfgr1_get_inmsel(struct COMP1_Type* p) { return (p->CFGR1 & COMP1_CFGR1_INMSEL) >> 16 ; }
inline uint32_t comp1_cfgr1_get_pwrmode(struct COMP1_Type* p) { return (p->CFGR1 & COMP1_CFGR1_PWRMODE) >> 12 ; }
inline uint32_t comp1_cfgr1_get_hyst(struct COMP1_Type* p) { return (p->CFGR1 & COMP1_CFGR1_HYST) >> 8 ; }

// COMP1->CFGR2 Comparator configuration register 2
enum {
	COMP1_CFGR2_LOCK = 1UL<<31, // Lock bit
	COMP1_CFGR2_BLANKING = ((1UL<<4)-1) << 24, // COMP channel 1 blanking source selection bits
	COMP1_CFGR2_INPSEL = 1UL<<20, // COMP channel 1 non-inverting input selection bit
	COMP1_CFGR2_INMSEL = ((1UL<<3)-1) << 16, // COMP channel 1 inverting input selection field
	COMP1_CFGR2_PWRMODE = ((1UL<<2)-1) << 12, // Power Mode of the COMP channel 1
	COMP1_CFGR2_HYST = ((1UL<<2)-1) << 8, // COMP channel 1 hysteresis selection bits
	COMP1_CFGR2_ITEN = 1UL<<6, // COMP channel 1 interrupt enable
	COMP1_CFGR2_WINMODE = 1UL<<4, // Window comparator mode selection bit
	COMP1_CFGR2_POLARITY = 1UL<<3, // COMP channel 1 polarity selection bit
	COMP1_CFGR2_SCALEN = 1UL<<2, // Voltage scaler enable bit
	COMP1_CFGR2_BRGEN = 1UL<<1, // Scaler bridge enable
	COMP1_CFGR2_EN = 1UL<<0, // COMP channel 1 enable bit		
};
inline void comp1_cfgr2_set_blanking(struct COMP1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~COMP1_CFGR2_BLANKING) | ((val<<24) & COMP1_CFGR2_BLANKING); }
inline void comp1_cfgr2_set_inmsel(struct COMP1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~COMP1_CFGR2_INMSEL) | ((val<<16) & COMP1_CFGR2_INMSEL); }
inline void comp1_cfgr2_set_pwrmode(struct COMP1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~COMP1_CFGR2_PWRMODE) | ((val<<12) & COMP1_CFGR2_PWRMODE); }
inline void comp1_cfgr2_set_hyst(struct COMP1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~COMP1_CFGR2_HYST) | ((val<<8) & COMP1_CFGR2_HYST); }
inline uint32_t comp1_cfgr2_get_blanking(struct COMP1_Type* p) { return (p->CFGR2 & COMP1_CFGR2_BLANKING) >> 24 ; }
inline uint32_t comp1_cfgr2_get_inmsel(struct COMP1_Type* p) { return (p->CFGR2 & COMP1_CFGR2_INMSEL) >> 16 ; }
inline uint32_t comp1_cfgr2_get_pwrmode(struct COMP1_Type* p) { return (p->CFGR2 & COMP1_CFGR2_PWRMODE) >> 12 ; }
inline uint32_t comp1_cfgr2_get_hyst(struct COMP1_Type* p) { return (p->CFGR2 & COMP1_CFGR2_HYST) >> 8 ; }

/* Cryptographic processor */
struct CRC_Type {
	__IO uint32_t DR; // @0 Data register
	__IO uint32_t IDR; // @4 Independent Data register
	__IO uint8_t CR; // @8 Control register
	 uint8_t RESERVED0[3]; // @9 
	__IO uint32_t INIT; // @12 Initial CRC value
	__IO uint32_t POL; // @16 CRC polynomial
};

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT = 1UL<<7, // Reverse output data
	CRC_CR_REV_IN = ((1UL<<2)-1) << 5, // Reverse input data
	CRC_CR_POLYSIZE = ((1UL<<2)-1) << 3, // Polynomial size
	CRC_CR_RESET = 1UL<<0, // RESET bit		
};
inline void crc_cr_set_rev_in(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_REV_IN) | ((val<<5) & CRC_CR_REV_IN); }
inline void crc_cr_set_polysize(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_POLYSIZE) | ((val<<3) & CRC_CR_POLYSIZE); }
inline uint32_t crc_cr_get_rev_in(struct CRC_Type* p) { return (p->CR & CRC_CR_REV_IN) >> 5 ; }
inline uint32_t crc_cr_get_polysize(struct CRC_Type* p) { return (p->CR & CRC_CR_POLYSIZE) >> 3 ; }

/* CRS */
struct CRS_Type {
	__IO uint16_t CR; // @0 CRS control register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CFGR; // @4 This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
	__I uint32_t ISR; // @8 CRS interrupt and status register
	__IO uint8_t ICR; // @12 CRS interrupt flag clear register
};

// CRS->CR CRS control register
enum {
	CRS_CR_TRIM = ((1UL<<6)-1) << 8, // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
	CRS_CR_SWSYNC = 1UL<<7, // Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
	CRS_CR_AUTOTRIMEN = 1UL<<6, // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
	CRS_CR_CEN = 1UL<<5, // Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
	CRS_CR_ESYNCIE = 1UL<<3, // Expected SYNC interrupt enable
	CRS_CR_ERRIE = 1UL<<2, // Synchronization or trimming error interrupt enable
	CRS_CR_SYNCWARNIE = 1UL<<1, // SYNC warning interrupt enable
	CRS_CR_SYNCOKIE = 1UL<<0, // SYNC event OK interrupt enable		
};
inline void crs_cr_set_trim(struct CRS_Type* p, uint32_t val) { p->CR = (p->CR & ~CRS_CR_TRIM) | ((val<<8) & CRS_CR_TRIM); }
inline uint32_t crs_cr_get_trim(struct CRS_Type* p) { return (p->CR & CRS_CR_TRIM) >> 8 ; }

// CRS->CFGR This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
enum {
	CRS_CFGR_SYNCPOL = 1UL<<31, // SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
	CRS_CFGR_SYNCSRC = ((1UL<<2)-1) << 28, // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
	CRS_CFGR_SYNCDIV = ((1UL<<3)-1) << 24, // SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
	CRS_CFGR_FELIM = ((1UL<<8)-1) << 16, // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
	CRS_CFGR_RELOAD = ((1UL<<16)-1) << 0, // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.		
};
inline void crs_cfgr_set_syncsrc(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCSRC) | ((val<<28) & CRS_CFGR_SYNCSRC); }
inline void crs_cfgr_set_syncdiv(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCDIV) | ((val<<24) & CRS_CFGR_SYNCDIV); }
inline void crs_cfgr_set_felim(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_FELIM) | ((val<<16) & CRS_CFGR_FELIM); }
inline void crs_cfgr_set_reload(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_RELOAD) | ((val<<0) & CRS_CFGR_RELOAD); }
inline uint32_t crs_cfgr_get_syncsrc(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_SYNCSRC) >> 28 ; }
inline uint32_t crs_cfgr_get_syncdiv(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_SYNCDIV) >> 24 ; }
inline uint32_t crs_cfgr_get_felim(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_FELIM) >> 16 ; }
inline uint32_t crs_cfgr_get_reload(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_RELOAD) >> 0 ; }

// CRS->ISR CRS interrupt and status register
enum {
	CRS_ISR_FECAP = ((1UL<<16)-1) << 16, // Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
	CRS_ISR_FEDIR = 1UL<<15, // Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
	CRS_ISR_TRIMOVF = 1UL<<10, // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCMISS = 1UL<<9, // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCERR = 1UL<<8, // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_ESYNCF = 1UL<<3, // Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
	CRS_ISR_ERRF = 1UL<<2, // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
	CRS_ISR_SYNCWARNF = 1UL<<1, // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
	CRS_ISR_SYNCOKF = 1UL<<0, // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.		
};
inline uint32_t crs_isr_get_fecap(struct CRS_Type* p) { return (p->ISR & CRS_ISR_FECAP) >> 16 ; }

// CRS->ICR CRS interrupt flag clear register
enum {
	CRS_ICR_ESYNCC = 1UL<<3, // Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
	CRS_ICR_ERRC = 1UL<<2, // Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
	CRS_ICR_SYNCWARNC = 1UL<<1, // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
	CRS_ICR_SYNCOKC = 1UL<<0, // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.		
};

/* Cryptographic processor */
struct CRYP_Type {
	__IO uint32_t CR; // @0 control register
	__I uint8_t SR; // @4 status register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint32_t DIN; // @8 data input register
	__I uint32_t DOUT; // @12 data output register
	__IO uint8_t DMACR; // @16 DMA control register
	 uint8_t RESERVED1[3]; // @17 
	__IO uint8_t IMSCR; // @20 interrupt mask set/clear register
	 uint8_t RESERVED2[3]; // @21 
	__I uint8_t RISR; // @24 raw interrupt status register
	 uint8_t RESERVED3[3]; // @25 
	__I uint8_t MISR; // @28 masked interrupt status register
	 uint8_t RESERVED4[3]; // @29 
	__O uint32_t K0LR; // @32 key registers
	__O uint32_t K0RR; // @36 key registers
	__O uint32_t K1LR; // @40 key registers
	__O uint32_t K1RR; // @44 key registers
	__O uint32_t K2LR; // @48 key registers
	__O uint32_t K2RR; // @52 key registers
	__O uint32_t K3LR; // @56 key registers
	__O uint32_t K3RR; // @60 key registers
	__IO uint32_t IV0LR; // @64 initialization vector registers
	__IO uint32_t IV0RR; // @68 initialization vector registers
	__IO uint32_t IV1LR; // @72 initialization vector registers
	__IO uint32_t IV1RR; // @76 initialization vector registers
	__IO uint32_t CSGCMCCM0R; // @80 context swap register
	__IO uint32_t CSGCMCCM1R; // @84 context swap register
	__IO uint32_t CSGCMCCM2R; // @88 context swap register
	__IO uint32_t CSGCMCCM3R; // @92 context swap register
	__IO uint32_t CSGCMCCM4R; // @96 context swap register
	__IO uint32_t CSGCMCCM5R; // @100 context swap register
	__IO uint32_t CSGCMCCM6R; // @104 context swap register
	__IO uint32_t CSGCMCCM7R; // @108 context swap register
	__IO uint32_t CSGCM0R; // @112 context swap register
	__IO uint32_t CSGCM1R; // @116 context swap register
	__IO uint32_t CSGCM2R; // @120 context swap register
	__IO uint32_t CSGCM3R; // @124 context swap register
	__IO uint32_t CSGCM4R; // @128 context swap register
	__IO uint32_t CSGCM5R; // @132 context swap register
	__IO uint32_t CSGCM6R; // @136 context swap register
	__IO uint32_t CSGCM7R; // @140 context swap register
};

// CRYP->CR control register
enum {
	CRYP_CR_ALGOMODE3 = 1UL<<19, // ALGOMODE
	CRYP_CR_GCM_CCMPH = ((1UL<<2)-1) << 16, // GCM_CCMPH
	CRYP_CR_CRYPEN = 1UL<<15, // Cryptographic processor enable
	CRYP_CR_FFLUSH = 1UL<<14, // FIFO flush
	CRYP_CR_KEYSIZE = ((1UL<<2)-1) << 8, // Key size selection (AES mode only)
	CRYP_CR_DATATYPE = ((1UL<<2)-1) << 6, // Data type selection
	CRYP_CR_ALGOMODE0 = ((1UL<<3)-1) << 3, // Algorithm mode
	CRYP_CR_ALGODIR = 1UL<<2, // Algorithm direction		
};
inline void cryp_cr_set_gcm_ccmph(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_GCM_CCMPH) | ((val<<16) & CRYP_CR_GCM_CCMPH); }
inline void cryp_cr_set_keysize(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_KEYSIZE) | ((val<<8) & CRYP_CR_KEYSIZE); }
inline void cryp_cr_set_datatype(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_DATATYPE) | ((val<<6) & CRYP_CR_DATATYPE); }
inline void cryp_cr_set_algomode0(struct CRYP_Type* p, uint32_t val) { p->CR = (p->CR & ~CRYP_CR_ALGOMODE0) | ((val<<3) & CRYP_CR_ALGOMODE0); }
inline uint32_t cryp_cr_get_gcm_ccmph(struct CRYP_Type* p) { return (p->CR & CRYP_CR_GCM_CCMPH) >> 16 ; }
inline uint32_t cryp_cr_get_keysize(struct CRYP_Type* p) { return (p->CR & CRYP_CR_KEYSIZE) >> 8 ; }
inline uint32_t cryp_cr_get_datatype(struct CRYP_Type* p) { return (p->CR & CRYP_CR_DATATYPE) >> 6 ; }
inline uint32_t cryp_cr_get_algomode0(struct CRYP_Type* p) { return (p->CR & CRYP_CR_ALGOMODE0) >> 3 ; }

// CRYP->SR status register
enum {
	CRYP_SR_BUSY = 1UL<<4, // Busy bit
	CRYP_SR_OFFU = 1UL<<3, // Output FIFO full
	CRYP_SR_OFNE = 1UL<<2, // Output FIFO not empty
	CRYP_SR_IFNF = 1UL<<1, // Input FIFO not full
	CRYP_SR_IFEM = 1UL<<0, // Input FIFO empty		
};

// CRYP->DMACR DMA control register
enum {
	CRYP_DMACR_DOEN = 1UL<<1, // DMA output enable
	CRYP_DMACR_DIEN = 1UL<<0, // DMA input enable		
};

// CRYP->IMSCR interrupt mask set/clear register
enum {
	CRYP_IMSCR_OUTIM = 1UL<<1, // Output FIFO service interrupt mask
	CRYP_IMSCR_INIM = 1UL<<0, // Input FIFO service interrupt mask		
};

// CRYP->RISR raw interrupt status register
enum {
	CRYP_RISR_OUTRIS = 1UL<<1, // Output FIFO service raw interrupt status
	CRYP_RISR_INRIS = 1UL<<0, // Input FIFO service raw interrupt status		
};

// CRYP->MISR masked interrupt status register
enum {
	CRYP_MISR_OUTMIS = 1UL<<1, // Output FIFO service masked interrupt status
	CRYP_MISR_INMIS = 1UL<<0, // Input FIFO service masked interrupt status		
};

/* DAC */
struct DAC_Type {
	__IO uint32_t CR; // @0 DAC control register
	__O uint8_t SWTRGR; // @4 DAC software trigger register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint16_t DHR12R1; // @8 DAC channel1 12-bit right-aligned data holding register
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t DHR12L1; // @12 DAC channel1 12-bit left aligned data holding register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t DHR8R1; // @16 DAC channel1 8-bit right aligned data holding register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t DHR12R2; // @20 DAC channel2 12-bit right aligned data holding register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t DHR12L2; // @24 DAC channel2 12-bit left aligned data holding register
	 uint8_t RESERVED5[2]; // @26 
	__IO uint8_t DHR8R2; // @28 DAC channel2 8-bit right-aligned data holding register
	 uint8_t RESERVED6[3]; // @29 
	__IO uint32_t DHR12RD; // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DHR12LD; // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint16_t DHR8RD; // @40 DUAL DAC 8-bit right aligned data holding register
	 uint8_t RESERVED7[2]; // @42 
	__I uint16_t DOR1; // @44 DAC channel1 data output register
	 uint8_t RESERVED8[2]; // @46 
	__I uint16_t DOR2; // @48 DAC channel2 data output register
	 uint8_t RESERVED9[2]; // @50 
	__IO uint32_t SR; // @52 DAC status register
	__IO uint32_t CCR; // @56 DAC calibration control register
	__IO uint32_t MCR; // @60 DAC mode control register
	__IO uint16_t SHSR1; // @64 DAC Sample and Hold sample time register 1
	 uint8_t RESERVED10[2]; // @66 
	__IO uint16_t SHSR2; // @68 DAC Sample and Hold sample time register 2
	 uint8_t RESERVED11[2]; // @70 
	__IO uint32_t SHHR; // @72 DAC Sample and Hold hold time register
	__IO uint32_t SHRR; // @76 DAC Sample and Hold refresh time register
};

// DAC->CR DAC control register
enum {
	DAC_CR_CEN2 = 1UL<<30, // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC_CR_DMAUDRIE2 = 1UL<<29, // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
	DAC_CR_DMAEN2 = 1UL<<28, // DAC channel2 DMA enable This bit is set and cleared by software.
	DAC_CR_MAMP2 = ((1UL<<4)-1) << 24, // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC_CR_WAVE2 = ((1UL<<2)-1) << 22, // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
	DAC_CR_TSEL2 = ((1UL<<3)-1) << 18, // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
	DAC_CR_TEN2 = 1UL<<17, // DAC channel2 trigger enable
	DAC_CR_EN2 = 1UL<<16, // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
	DAC_CR_CEN1 = 1UL<<14, // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC_CR_DMAUDRIE1 = 1UL<<13, // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
	DAC_CR_DMAEN1 = 1UL<<12, // DAC channel1 DMA enable This bit is set and cleared by software.
	DAC_CR_MAMP1 = ((1UL<<4)-1) << 8, // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC_CR_WAVE1 = ((1UL<<2)-1) << 6, // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC_CR_TSEL1 = ((1UL<<3)-1) << 2, // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC_CR_TEN1 = 1UL<<1, // DAC channel1 trigger enable
	DAC_CR_EN1 = 1UL<<0, // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.		
};
inline void dac_cr_set_mamp2(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_MAMP2) | ((val<<24) & DAC_CR_MAMP2); }
inline void dac_cr_set_wave2(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_WAVE2) | ((val<<22) & DAC_CR_WAVE2); }
inline void dac_cr_set_tsel2(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_TSEL2) | ((val<<18) & DAC_CR_TSEL2); }
inline void dac_cr_set_mamp1(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_MAMP1) | ((val<<8) & DAC_CR_MAMP1); }
inline void dac_cr_set_wave1(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_WAVE1) | ((val<<6) & DAC_CR_WAVE1); }
inline void dac_cr_set_tsel1(struct DAC_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC_CR_TSEL1) | ((val<<2) & DAC_CR_TSEL1); }
inline uint32_t dac_cr_get_mamp2(struct DAC_Type* p) { return (p->CR & DAC_CR_MAMP2) >> 24 ; }
inline uint32_t dac_cr_get_wave2(struct DAC_Type* p) { return (p->CR & DAC_CR_WAVE2) >> 22 ; }
inline uint32_t dac_cr_get_tsel2(struct DAC_Type* p) { return (p->CR & DAC_CR_TSEL2) >> 18 ; }
inline uint32_t dac_cr_get_mamp1(struct DAC_Type* p) { return (p->CR & DAC_CR_MAMP1) >> 8 ; }
inline uint32_t dac_cr_get_wave1(struct DAC_Type* p) { return (p->CR & DAC_CR_WAVE1) >> 6 ; }
inline uint32_t dac_cr_get_tsel1(struct DAC_Type* p) { return (p->CR & DAC_CR_TSEL1) >> 2 ; }

// DAC->SWTRGR DAC software trigger register
enum {
	DAC_SWTRGR_SWTRIGX  = ((1UL<<2)-1) << 0, // Merged DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.		
};
inline void dac_swtrgr_set_swtrigx (struct DAC_Type* p, uint32_t val) { p->SWTRGR = (p->SWTRGR & ~DAC_SWTRGR_SWTRIGX ) | ((val<<0) & DAC_SWTRGR_SWTRIGX ); }
inline uint32_t dac_swtrgr_get_swtrigx (struct DAC_Type* p) { return (p->SWTRGR & DAC_SWTRGR_SWTRIGX ) >> 0 ; }

// DAC->DHR12R1 DAC channel1 12-bit right-aligned data holding register
enum {
	DAC_DHR12R1_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
inline void dac_dhr12r1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12R1 = (p->DHR12R1 & ~DAC_DHR12R1_DACC1DHR) | ((val<<0) & DAC_DHR12R1_DACC1DHR); }
inline uint32_t dac_dhr12r1_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12R1 & DAC_DHR12R1_DACC1DHR) >> 0 ; }

// DAC->DHR12L1 DAC channel1 12-bit left aligned data holding register
enum {
	DAC_DHR12L1_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
inline void dac_dhr12l1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12L1 = (p->DHR12L1 & ~DAC_DHR12L1_DACC1DHR) | ((val<<4) & DAC_DHR12L1_DACC1DHR); }
inline uint32_t dac_dhr12l1_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12L1 & DAC_DHR12L1_DACC1DHR) >> 4 ; }

// DAC->DHR12R2 DAC channel2 12-bit right aligned data holding register
enum {
	DAC_DHR12R2_DACC2DHR = ((1UL<<12)-1) << 0, // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.		
};
inline void dac_dhr12r2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12R2 = (p->DHR12R2 & ~DAC_DHR12R2_DACC2DHR) | ((val<<0) & DAC_DHR12R2_DACC2DHR); }
inline uint32_t dac_dhr12r2_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12R2 & DAC_DHR12R2_DACC2DHR) >> 0 ; }

// DAC->DHR12L2 DAC channel2 12-bit left aligned data holding register
enum {
	DAC_DHR12L2_DACC2DHR = ((1UL<<12)-1) << 4, // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.		
};
inline void dac_dhr12l2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12L2 = (p->DHR12L2 & ~DAC_DHR12L2_DACC2DHR) | ((val<<4) & DAC_DHR12L2_DACC2DHR); }
inline uint32_t dac_dhr12l2_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12L2 & DAC_DHR12L2_DACC2DHR) >> 4 ; }

// DAC->DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC_DHR12RD_DACC2DHR = ((1UL<<12)-1) << 16, // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
	DAC_DHR12RD_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
inline void dac_dhr12rd_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12RD = (p->DHR12RD & ~DAC_DHR12RD_DACC2DHR) | ((val<<16) & DAC_DHR12RD_DACC2DHR); }
inline void dac_dhr12rd_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12RD = (p->DHR12RD & ~DAC_DHR12RD_DACC1DHR) | ((val<<0) & DAC_DHR12RD_DACC1DHR); }
inline uint32_t dac_dhr12rd_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12RD & DAC_DHR12RD_DACC2DHR) >> 16 ; }
inline uint32_t dac_dhr12rd_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12RD & DAC_DHR12RD_DACC1DHR) >> 0 ; }

// DAC->DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC_DHR12LD_DACC2DHR = ((1UL<<12)-1) << 20, // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
	DAC_DHR12LD_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
inline void dac_dhr12ld_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR12LD = (p->DHR12LD & ~DAC_DHR12LD_DACC2DHR) | ((val<<20) & DAC_DHR12LD_DACC2DHR); }
inline void dac_dhr12ld_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR12LD = (p->DHR12LD & ~DAC_DHR12LD_DACC1DHR) | ((val<<4) & DAC_DHR12LD_DACC1DHR); }
inline uint32_t dac_dhr12ld_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR12LD & DAC_DHR12LD_DACC2DHR) >> 20 ; }
inline uint32_t dac_dhr12ld_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR12LD & DAC_DHR12LD_DACC1DHR) >> 4 ; }

// DAC->DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC_DHR8RD_DACC2DHR = ((1UL<<8)-1) << 8, // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
	DAC_DHR8RD_DACC1DHR = ((1UL<<8)-1) << 0, // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.		
};
inline void dac_dhr8rd_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DHR8RD = (p->DHR8RD & ~DAC_DHR8RD_DACC2DHR) | ((val<<8) & DAC_DHR8RD_DACC2DHR); }
inline void dac_dhr8rd_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DHR8RD = (p->DHR8RD & ~DAC_DHR8RD_DACC1DHR) | ((val<<0) & DAC_DHR8RD_DACC1DHR); }
inline uint32_t dac_dhr8rd_get_dacc2dhr(struct DAC_Type* p) { return (p->DHR8RD & DAC_DHR8RD_DACC2DHR) >> 8 ; }
inline uint32_t dac_dhr8rd_get_dacc1dhr(struct DAC_Type* p) { return (p->DHR8RD & DAC_DHR8RD_DACC1DHR) >> 0 ; }

// DAC->DOR1 DAC channel1 data output register
enum {
	DAC_DOR1_DACC1DOR = ((1UL<<12)-1) << 0, // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.		
};
inline uint32_t dac_dor1_get_dacc1dor(struct DAC_Type* p) { return (p->DOR1 & DAC_DOR1_DACC1DOR) >> 0 ; }

// DAC->DOR2 DAC channel2 data output register
enum {
	DAC_DOR2_DACC2DOR = ((1UL<<12)-1) << 0, // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.		
};
inline uint32_t dac_dor2_get_dacc2dor(struct DAC_Type* p) { return (p->DOR2 & DAC_DOR2_DACC2DOR) >> 0 ; }

// DAC->SR DAC status register
enum {
	DAC_SR_BWST2 = 1UL<<31, // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
	DAC_SR_CAL_FLAG2 = 1UL<<30, // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
	DAC_SR_DMAUDR2 = 1UL<<29, // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC_SR_BWST1 = 1UL<<15, // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
	DAC_SR_CAL_FLAG1 = 1UL<<14, // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
	DAC_SR_DMAUDR1 = 1UL<<13, // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).		
};

// DAC->CCR DAC calibration control register
enum {
	DAC_CCR_OTRIM2 = ((1UL<<5)-1) << 16, // DAC Channel 2 offset trimming value
	DAC_CCR_OTRIM1 = ((1UL<<5)-1) << 0, // DAC Channel 1 offset trimming value		
};
inline void dac_ccr_set_otrim2(struct DAC_Type* p, uint32_t val) { p->CCR = (p->CCR & ~DAC_CCR_OTRIM2) | ((val<<16) & DAC_CCR_OTRIM2); }
inline void dac_ccr_set_otrim1(struct DAC_Type* p, uint32_t val) { p->CCR = (p->CCR & ~DAC_CCR_OTRIM1) | ((val<<0) & DAC_CCR_OTRIM1); }
inline uint32_t dac_ccr_get_otrim2(struct DAC_Type* p) { return (p->CCR & DAC_CCR_OTRIM2) >> 16 ; }
inline uint32_t dac_ccr_get_otrim1(struct DAC_Type* p) { return (p->CCR & DAC_CCR_OTRIM1) >> 0 ; }

// DAC->MCR DAC mode control register
enum {
	DAC_MCR_MODE2 = ((1UL<<3)-1) << 16, // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
	DAC_MCR_MODE1 = ((1UL<<3)-1) << 0, // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode		
};
inline void dac_mcr_set_mode2(struct DAC_Type* p, uint32_t val) { p->MCR = (p->MCR & ~DAC_MCR_MODE2) | ((val<<16) & DAC_MCR_MODE2); }
inline void dac_mcr_set_mode1(struct DAC_Type* p, uint32_t val) { p->MCR = (p->MCR & ~DAC_MCR_MODE1) | ((val<<0) & DAC_MCR_MODE1); }
inline uint32_t dac_mcr_get_mode2(struct DAC_Type* p) { return (p->MCR & DAC_MCR_MODE2) >> 16 ; }
inline uint32_t dac_mcr_get_mode1(struct DAC_Type* p) { return (p->MCR & DAC_MCR_MODE1) >> 0 ; }

// DAC->SHSR1 DAC Sample and Hold sample time register 1
enum {
	DAC_SHSR1_TSAMPLE1 = ((1UL<<10)-1) << 0, // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.		
};
inline void dac_shsr1_set_tsample1(struct DAC_Type* p, uint32_t val) { p->SHSR1 = (p->SHSR1 & ~DAC_SHSR1_TSAMPLE1) | ((val<<0) & DAC_SHSR1_TSAMPLE1); }
inline uint32_t dac_shsr1_get_tsample1(struct DAC_Type* p) { return (p->SHSR1 & DAC_SHSR1_TSAMPLE1) >> 0 ; }

// DAC->SHSR2 DAC Sample and Hold sample time register 2
enum {
	DAC_SHSR2_TSAMPLE2 = ((1UL<<10)-1) << 0, // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.		
};
inline void dac_shsr2_set_tsample2(struct DAC_Type* p, uint32_t val) { p->SHSR2 = (p->SHSR2 & ~DAC_SHSR2_TSAMPLE2) | ((val<<0) & DAC_SHSR2_TSAMPLE2); }
inline uint32_t dac_shsr2_get_tsample2(struct DAC_Type* p) { return (p->SHSR2 & DAC_SHSR2_TSAMPLE2) >> 0 ; }

// DAC->SHHR DAC Sample and Hold hold time register
enum {
	DAC_SHHR_THOLD2 = ((1UL<<10)-1) << 16, // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
	DAC_SHHR_THOLD1 = ((1UL<<10)-1) << 0, // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI		
};
inline void dac_shhr_set_thold2(struct DAC_Type* p, uint32_t val) { p->SHHR = (p->SHHR & ~DAC_SHHR_THOLD2) | ((val<<16) & DAC_SHHR_THOLD2); }
inline void dac_shhr_set_thold1(struct DAC_Type* p, uint32_t val) { p->SHHR = (p->SHHR & ~DAC_SHHR_THOLD1) | ((val<<0) & DAC_SHHR_THOLD1); }
inline uint32_t dac_shhr_get_thold2(struct DAC_Type* p) { return (p->SHHR & DAC_SHHR_THOLD2) >> 16 ; }
inline uint32_t dac_shhr_get_thold1(struct DAC_Type* p) { return (p->SHHR & DAC_SHHR_THOLD1) >> 0 ; }

// DAC->SHRR DAC Sample and Hold refresh time register
enum {
	DAC_SHRR_TREFRESH2 = ((1UL<<8)-1) << 16, // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
	DAC_SHRR_TREFRESH1 = ((1UL<<8)-1) << 0, // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI		
};
inline void dac_shrr_set_trefresh2(struct DAC_Type* p, uint32_t val) { p->SHRR = (p->SHRR & ~DAC_SHRR_TREFRESH2) | ((val<<16) & DAC_SHRR_TREFRESH2); }
inline void dac_shrr_set_trefresh1(struct DAC_Type* p, uint32_t val) { p->SHRR = (p->SHRR & ~DAC_SHRR_TREFRESH1) | ((val<<0) & DAC_SHRR_TREFRESH1); }
inline uint32_t dac_shrr_get_trefresh2(struct DAC_Type* p) { return (p->SHRR & DAC_SHRR_TREFRESH2) >> 16 ; }
inline uint32_t dac_shrr_get_trefresh1(struct DAC_Type* p) { return (p->SHRR & DAC_SHRR_TREFRESH1) >> 0 ; }

/* Digital camera interface */
struct DCMI_Type {
	__IO uint32_t CR; // @0 control register 1
	__I uint8_t SR; // @4 status register
	 uint8_t RESERVED0[3]; // @5 
	__I uint8_t RIS; // @8 raw interrupt status register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint8_t IER; // @12 interrupt enable register
	 uint8_t RESERVED2[3]; // @13 
	__I uint8_t MIS; // @16 masked interrupt status register
	 uint8_t RESERVED3[3]; // @17 
	__O uint8_t ICR; // @20 interrupt clear register
	 uint8_t RESERVED4[3]; // @21 
	__IO uint32_t ESCR; // @24 embedded synchronization code register
	__IO uint32_t ESUR; // @28 embedded synchronization unmask register
	__IO uint32_t CWSTRT; // @32 crop window start
	__IO uint32_t CWSIZE; // @36 crop window size
	__I uint32_t DR; // @40 data register
};

// DCMI->CR control register 1
enum {
	DCMI_CR_OELS = 1UL<<20, // Odd/Even Line Select (Line Select Start)
	DCMI_CR_LSM = 1UL<<19, // Line Select mode
	DCMI_CR_OEBS = 1UL<<18, // Odd/Even Byte Select (Byte Select Start)
	DCMI_CR_BSM = ((1UL<<2)-1) << 16, // Byte Select mode
	DCMI_CR_ENABLE = 1UL<<14, // DCMI enable
	DCMI_CR_EDM = ((1UL<<2)-1) << 10, // Extended data mode
	DCMI_CR_FCRC = ((1UL<<2)-1) << 8, // Frame capture rate control
	DCMI_CR_VSPOL = 1UL<<7, // Vertical synchronization polarity
	DCMI_CR_HSPOL = 1UL<<6, // Horizontal synchronization polarity
	DCMI_CR_PCKPOL = 1UL<<5, // Pixel clock polarity
	DCMI_CR_ESS = 1UL<<4, // Embedded synchronization select
	DCMI_CR_JPEG = 1UL<<3, // JPEG format
	DCMI_CR_CROP = 1UL<<2, // Crop feature
	DCMI_CR_CM = 1UL<<1, // Capture mode
	DCMI_CR_CAPTURE = 1UL<<0, // Capture enable		
};
inline void dcmi_cr_set_bsm(struct DCMI_Type* p, uint32_t val) { p->CR = (p->CR & ~DCMI_CR_BSM) | ((val<<16) & DCMI_CR_BSM); }
inline void dcmi_cr_set_edm(struct DCMI_Type* p, uint32_t val) { p->CR = (p->CR & ~DCMI_CR_EDM) | ((val<<10) & DCMI_CR_EDM); }
inline void dcmi_cr_set_fcrc(struct DCMI_Type* p, uint32_t val) { p->CR = (p->CR & ~DCMI_CR_FCRC) | ((val<<8) & DCMI_CR_FCRC); }
inline uint32_t dcmi_cr_get_bsm(struct DCMI_Type* p) { return (p->CR & DCMI_CR_BSM) >> 16 ; }
inline uint32_t dcmi_cr_get_edm(struct DCMI_Type* p) { return (p->CR & DCMI_CR_EDM) >> 10 ; }
inline uint32_t dcmi_cr_get_fcrc(struct DCMI_Type* p) { return (p->CR & DCMI_CR_FCRC) >> 8 ; }

// DCMI->SR status register
enum {
	DCMI_SR_FNE = 1UL<<2, // FIFO not empty
	DCMI_SR_VSYNC = 1UL<<1, // VSYNC
	DCMI_SR_HSYNC = 1UL<<0, // HSYNC		
};

// DCMI->RIS raw interrupt status register
enum {
	DCMI_RIS_LINE_RIS = 1UL<<4, // Line raw interrupt status
	DCMI_RIS_VSYNC_RIS = 1UL<<3, // VSYNC raw interrupt status
	DCMI_RIS_ERR_RIS = 1UL<<2, // Synchronization error raw interrupt status
	DCMI_RIS_OVR_RIS = 1UL<<1, // Overrun raw interrupt status
	DCMI_RIS_FRAME_RIS = 1UL<<0, // Capture complete raw interrupt status		
};

// DCMI->IER interrupt enable register
enum {
	DCMI_IER_LINE_IE = 1UL<<4, // Line interrupt enable
	DCMI_IER_VSYNC_IE = 1UL<<3, // VSYNC interrupt enable
	DCMI_IER_ERR_IE = 1UL<<2, // Synchronization error interrupt enable
	DCMI_IER_OVR_IE = 1UL<<1, // Overrun interrupt enable
	DCMI_IER_FRAME_IE = 1UL<<0, // Capture complete interrupt enable		
};

// DCMI->MIS masked interrupt status register
enum {
	DCMI_MIS_LINE_MIS = 1UL<<4, // Line masked interrupt status
	DCMI_MIS_VSYNC_MIS = 1UL<<3, // VSYNC masked interrupt status
	DCMI_MIS_ERR_MIS = 1UL<<2, // Synchronization error masked interrupt status
	DCMI_MIS_OVR_MIS = 1UL<<1, // Overrun masked interrupt status
	DCMI_MIS_FRAME_MIS = 1UL<<0, // Capture complete masked interrupt status		
};

// DCMI->ICR interrupt clear register
enum {
	DCMI_ICR_LINE_ISC = 1UL<<4, // line interrupt status clear
	DCMI_ICR_VSYNC_ISC = 1UL<<3, // Vertical synch interrupt status clear
	DCMI_ICR_ERR_ISC = 1UL<<2, // Synchronization error interrupt status clear
	DCMI_ICR_OVR_ISC = 1UL<<1, // Overrun interrupt status clear
	DCMI_ICR_FRAME_ISC = 1UL<<0, // Capture complete interrupt status clear		
};

// DCMI->ESCR embedded synchronization code register
enum {
	DCMI_ESCR_FEC = ((1UL<<8)-1) << 24, // Frame end delimiter code
	DCMI_ESCR_LEC = ((1UL<<8)-1) << 16, // Line end delimiter code
	DCMI_ESCR_LSC = ((1UL<<8)-1) << 8, // Line start delimiter code
	DCMI_ESCR_FSC = ((1UL<<8)-1) << 0, // Frame start delimiter code		
};
inline void dcmi_escr_set_fec(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_FEC) | ((val<<24) & DCMI_ESCR_FEC); }
inline void dcmi_escr_set_lec(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_LEC) | ((val<<16) & DCMI_ESCR_LEC); }
inline void dcmi_escr_set_lsc(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_LSC) | ((val<<8) & DCMI_ESCR_LSC); }
inline void dcmi_escr_set_fsc(struct DCMI_Type* p, uint32_t val) { p->ESCR = (p->ESCR & ~DCMI_ESCR_FSC) | ((val<<0) & DCMI_ESCR_FSC); }
inline uint32_t dcmi_escr_get_fec(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_FEC) >> 24 ; }
inline uint32_t dcmi_escr_get_lec(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_LEC) >> 16 ; }
inline uint32_t dcmi_escr_get_lsc(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_LSC) >> 8 ; }
inline uint32_t dcmi_escr_get_fsc(struct DCMI_Type* p) { return (p->ESCR & DCMI_ESCR_FSC) >> 0 ; }

// DCMI->ESUR embedded synchronization unmask register
enum {
	DCMI_ESUR_FEU = ((1UL<<8)-1) << 24, // Frame end delimiter unmask
	DCMI_ESUR_LEU = ((1UL<<8)-1) << 16, // Line end delimiter unmask
	DCMI_ESUR_LSU = ((1UL<<8)-1) << 8, // Line start delimiter unmask
	DCMI_ESUR_FSU = ((1UL<<8)-1) << 0, // Frame start delimiter unmask		
};
inline void dcmi_esur_set_feu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_FEU) | ((val<<24) & DCMI_ESUR_FEU); }
inline void dcmi_esur_set_leu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_LEU) | ((val<<16) & DCMI_ESUR_LEU); }
inline void dcmi_esur_set_lsu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_LSU) | ((val<<8) & DCMI_ESUR_LSU); }
inline void dcmi_esur_set_fsu(struct DCMI_Type* p, uint32_t val) { p->ESUR = (p->ESUR & ~DCMI_ESUR_FSU) | ((val<<0) & DCMI_ESUR_FSU); }
inline uint32_t dcmi_esur_get_feu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_FEU) >> 24 ; }
inline uint32_t dcmi_esur_get_leu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_LEU) >> 16 ; }
inline uint32_t dcmi_esur_get_lsu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_LSU) >> 8 ; }
inline uint32_t dcmi_esur_get_fsu(struct DCMI_Type* p) { return (p->ESUR & DCMI_ESUR_FSU) >> 0 ; }

// DCMI->CWSTRT crop window start
enum {
	DCMI_CWSTRT_VST = ((1UL<<13)-1) << 16, // Vertical start line count
	DCMI_CWSTRT_HOFFCNT = ((1UL<<14)-1) << 0, // Horizontal offset count		
};
inline void dcmi_cwstrt_set_vst(struct DCMI_Type* p, uint32_t val) { p->CWSTRT = (p->CWSTRT & ~DCMI_CWSTRT_VST) | ((val<<16) & DCMI_CWSTRT_VST); }
inline void dcmi_cwstrt_set_hoffcnt(struct DCMI_Type* p, uint32_t val) { p->CWSTRT = (p->CWSTRT & ~DCMI_CWSTRT_HOFFCNT) | ((val<<0) & DCMI_CWSTRT_HOFFCNT); }
inline uint32_t dcmi_cwstrt_get_vst(struct DCMI_Type* p) { return (p->CWSTRT & DCMI_CWSTRT_VST) >> 16 ; }
inline uint32_t dcmi_cwstrt_get_hoffcnt(struct DCMI_Type* p) { return (p->CWSTRT & DCMI_CWSTRT_HOFFCNT) >> 0 ; }

// DCMI->CWSIZE crop window size
enum {
	DCMI_CWSIZE_VLINE = ((1UL<<14)-1) << 16, // Vertical line count
	DCMI_CWSIZE_CAPCNT = ((1UL<<14)-1) << 0, // Capture count		
};
inline void dcmi_cwsize_set_vline(struct DCMI_Type* p, uint32_t val) { p->CWSIZE = (p->CWSIZE & ~DCMI_CWSIZE_VLINE) | ((val<<16) & DCMI_CWSIZE_VLINE); }
inline void dcmi_cwsize_set_capcnt(struct DCMI_Type* p, uint32_t val) { p->CWSIZE = (p->CWSIZE & ~DCMI_CWSIZE_CAPCNT) | ((val<<0) & DCMI_CWSIZE_CAPCNT); }
inline uint32_t dcmi_cwsize_get_vline(struct DCMI_Type* p) { return (p->CWSIZE & DCMI_CWSIZE_VLINE) >> 16 ; }
inline uint32_t dcmi_cwsize_get_capcnt(struct DCMI_Type* p) { return (p->CWSIZE & DCMI_CWSIZE_CAPCNT) >> 0 ; }

// DCMI->DR data register
enum {
	DCMI_DR_BYTE3 = ((1UL<<8)-1) << 24, // Data byte 3
	DCMI_DR_BYTE2 = ((1UL<<8)-1) << 16, // Data byte 2
	DCMI_DR_BYTE1 = ((1UL<<8)-1) << 8, // Data byte 1
	DCMI_DR_BYTE0 = ((1UL<<8)-1) << 0, // Data byte 0		
};
inline uint32_t dcmi_dr_get_byte3(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE3) >> 24 ; }
inline uint32_t dcmi_dr_get_byte2(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE2) >> 16 ; }
inline uint32_t dcmi_dr_get_byte1(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE1) >> 8 ; }
inline uint32_t dcmi_dr_get_byte0(struct DCMI_Type* p) { return (p->DR & DCMI_DR_BYTE0) >> 0 ; }


/* DELAY_Block_SDMMC1 */
struct DELAY_Block_SDMMC1_Type {
	__IO uint8_t CR; // @0 DLYB control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CFGR; // @4 DLYB configuration register
};

// DELAY_Block_SDMMC1->CR DLYB control register
enum {
	DELAY_BLOCK_SDMMC1_CR_SEN = 1UL<<1, // Sampler length enable bit
	DELAY_BLOCK_SDMMC1_CR_DEN = 1UL<<0, // Delay block enable bit		
};

// DELAY_Block_SDMMC1->CFGR DLYB configuration register
enum {
	DELAY_BLOCK_SDMMC1_CFGR_LNGF = 1UL<<31, // Length valid flag
	DELAY_BLOCK_SDMMC1_CFGR_LNG = ((1UL<<12)-1) << 16, // Delay line length value
	DELAY_BLOCK_SDMMC1_CFGR_UNIT = ((1UL<<7)-1) << 8, // Delay Defines the delay of a Unit delay cell
	DELAY_BLOCK_SDMMC1_CFGR_SEL = ((1UL<<4)-1) << 0, // Select the phase for the Output clock		
};
inline void delay_block_sdmmc1_cfgr_set_lng(struct DELAY_Block_SDMMC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~DELAY_BLOCK_SDMMC1_CFGR_LNG) | ((val<<16) & DELAY_BLOCK_SDMMC1_CFGR_LNG); }
inline void delay_block_sdmmc1_cfgr_set_unit(struct DELAY_Block_SDMMC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~DELAY_BLOCK_SDMMC1_CFGR_UNIT) | ((val<<8) & DELAY_BLOCK_SDMMC1_CFGR_UNIT); }
inline void delay_block_sdmmc1_cfgr_set_sel(struct DELAY_Block_SDMMC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~DELAY_BLOCK_SDMMC1_CFGR_SEL) | ((val<<0) & DELAY_BLOCK_SDMMC1_CFGR_SEL); }
inline uint32_t delay_block_sdmmc1_cfgr_get_lng(struct DELAY_Block_SDMMC1_Type* p) { return (p->CFGR & DELAY_BLOCK_SDMMC1_CFGR_LNG) >> 16 ; }
inline uint32_t delay_block_sdmmc1_cfgr_get_unit(struct DELAY_Block_SDMMC1_Type* p) { return (p->CFGR & DELAY_BLOCK_SDMMC1_CFGR_UNIT) >> 8 ; }
inline uint32_t delay_block_sdmmc1_cfgr_get_sel(struct DELAY_Block_SDMMC1_Type* p) { return (p->CFGR & DELAY_BLOCK_SDMMC1_CFGR_SEL) >> 0 ; }


/* Digital filter for sigma delta modulators */
struct DFSDM_Type {
	__IO uint32_t DFSDM_CHCFG0R1; // @0 DFSDM channel configuration 0 register 1
	__IO uint32_t DFSDM_CHCFG1R1; // @4 DFSDM channel configuration 1 register 1
	__IO uint32_t DFSDM_CHCFG2R1; // @8 DFSDM channel configuration 2 register 1
	__IO uint32_t DFSDM_CHCFG3R1; // @12 DFSDM channel configuration 3 register 1
	__IO uint32_t DFSDM_CHCFG4R1; // @16 DFSDM channel configuration 4 register 1
	__IO uint32_t DFSDM_CHCFG5R1; // @20 DFSDM channel configuration 5 register 1
	__IO uint32_t DFSDM_CHCFG6R1; // @24 DFSDM channel configuration 6 register 1
	__IO uint32_t DFSDM_CHCFG7R1; // @28 DFSDM channel configuration 7 register 1
	__IO uint32_t DFSDM_CHCFG0R2; // @32 DFSDM channel configuration 0 register 2
	__IO uint32_t DFSDM_CHCFG1R2; // @36 DFSDM channel configuration 1 register 2
	__IO uint32_t DFSDM_CHCFG2R2; // @40 DFSDM channel configuration 2 register 2
	__IO uint32_t DFSDM_CHCFG3R2; // @44 DFSDM channel configuration 3 register 2
	__IO uint32_t DFSDM_CHCFG4R2; // @48 DFSDM channel configuration 4 register 2
	__IO uint32_t DFSDM_CHCFG5R2; // @52 DFSDM channel configuration 5 register 2
	__IO uint32_t DFSDM_CHCFG6R2; // @56 DFSDM channel configuration 6 register 2
	__IO uint32_t DFSDM_CHCFG7R2; // @60 DFSDM channel configuration 7 register 2
	__IO uint32_t DFSDM_AWSCD0R; // @64 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD1R; // @68 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD2R; // @72 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD3R; // @76 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD4R; // @80 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD5R; // @84 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD6R; // @88 DFSDM analog watchdog and short-circuit detector register
	__IO uint32_t DFSDM_AWSCD7R; // @92 DFSDM analog watchdog and short-circuit detector register
	__I uint16_t DFSDM_CHWDAT0R; // @96 DFSDM channel watchdog filter data register
	 uint8_t RESERVED0[2]; // @98 
	__I uint16_t DFSDM_CHWDAT1R; // @100 DFSDM channel watchdog filter data register
	 uint8_t RESERVED1[2]; // @102 
	__I uint16_t DFSDM_CHWDAT2R; // @104 DFSDM channel watchdog filter data register
	 uint8_t RESERVED2[2]; // @106 
	__I uint16_t DFSDM_CHWDAT3R; // @108 DFSDM channel watchdog filter data register
	 uint8_t RESERVED3[2]; // @110 
	__I uint16_t DFSDM_CHWDAT4R; // @112 DFSDM channel watchdog filter data register
	 uint8_t RESERVED4[2]; // @114 
	__I uint16_t DFSDM_CHWDAT5R; // @116 DFSDM channel watchdog filter data register
	 uint8_t RESERVED5[2]; // @118 
	__I uint16_t DFSDM_CHWDAT6R; // @120 DFSDM channel watchdog filter data register
	 uint8_t RESERVED6[2]; // @122 
	__I uint16_t DFSDM_CHWDAT7R; // @124 DFSDM channel watchdog filter data register
	 uint8_t RESERVED7[2]; // @126 
	__IO uint32_t DFSDM_CHDATIN0R; // @128 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN1R; // @132 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN2R; // @136 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN3R; // @140 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN4R; // @144 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN5R; // @148 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN6R; // @152 DFSDM channel data input register
	__IO uint32_t DFSDM_CHDATIN7R; // @156 DFSDM channel data input register
	__IO uint32_t DFSDM0_CR1; // @160 DFSDM control register 1
	__IO uint32_t DFSDM1_CR1; // @164 DFSDM control register 1
	__IO uint32_t DFSDM2_CR1; // @168 DFSDM control register 1
	__IO uint32_t DFSDM3_CR1; // @172 DFSDM control register 1
	__IO uint32_t DFSDM0_CR2; // @176 DFSDM control register 2
	__IO uint32_t DFSDM1_CR2; // @180 DFSDM control register 2
	__IO uint32_t DFSDM2_CR2; // @184 DFSDM control register 2
	__IO uint32_t DFSDM3_CR2; // @188 DFSDM control register 2
	__I uint32_t DFSDM0_ISR; // @192 DFSDM interrupt and status register
	__I uint32_t DFSDM1_ISR; // @196 DFSDM interrupt and status register
	__I uint32_t DFSDM2_ISR; // @200 DFSDM interrupt and status register
	__I uint32_t DFSDM3_ISR; // @204 DFSDM interrupt and status register
	__IO uint32_t DFSDM0_ICR; // @208 DFSDM interrupt flag clear register
	__IO uint32_t DFSDM1_ICR; // @212 DFSDM interrupt flag clear register
	__IO uint32_t DFSDM2_ICR; // @216 DFSDM interrupt flag clear register
	__IO uint32_t DFSDM3_ICR; // @220 DFSDM interrupt flag clear register
	__IO uint8_t DFSDM0_JCHGR; // @224 DFSDM injected channel group selection register
	 uint8_t RESERVED8[3]; // @225 
	__IO uint8_t DFSDM1_JCHGR; // @228 DFSDM injected channel group selection register
	 uint8_t RESERVED9[3]; // @229 
	__IO uint8_t DFSDM2_JCHGR; // @232 DFSDM injected channel group selection register
	 uint8_t RESERVED10[3]; // @233 
	__IO uint8_t DFSDM3_JCHGR; // @236 DFSDM injected channel group selection register
	 uint8_t RESERVED11[3]; // @237 
	__IO uint32_t DFSDM0_FCR; // @240 DFSDM filter control register
	__IO uint32_t DFSDM1_FCR; // @244 DFSDM filter control register
	__IO uint32_t DFSDM2_FCR; // @248 DFSDM filter control register
	__IO uint32_t DFSDM3_FCR; // @252 DFSDM filter control register
	__I uint32_t DFSDM0_JDATAR; // @256 DFSDM data register for injected group
	__I uint32_t DFSDM1_JDATAR; // @260 DFSDM data register for injected group
	__I uint32_t DFSDM2_JDATAR; // @264 DFSDM data register for injected group
	__I uint32_t DFSDM3_JDATAR; // @268 DFSDM data register for injected group
	__I uint32_t DFSDM0_RDATAR; // @272 DFSDM data register for the regular channel
	__I uint32_t DFSDM1_RDATAR; // @276 DFSDM data register for the regular channel
	__I uint32_t DFSDM2_RDATAR; // @280 DFSDM data register for the regular channel
	__I uint32_t DFSDM3_RDATAR; // @284 DFSDM data register for the regular channel
	__IO uint32_t DFSDM0_AWHTR; // @288 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM1_AWHTR; // @292 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM2_AWHTR; // @296 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM3_AWHTR; // @300 DFSDM analog watchdog high threshold register
	__IO uint32_t DFSDM0_AWLTR; // @304 DFSDM analog watchdog low threshold register
	__IO uint32_t DFSDM1_AWLTR; // @308 DFSDM analog watchdog low threshold register
	__IO uint32_t DFSDM2_AWLTR; // @312 DFSDM analog watchdog low threshold register
	__IO uint32_t DFSDM3_AWLTR; // @316 DFSDM analog watchdog low threshold register
	__I uint16_t DFSDM0_AWSR; // @320 DFSDM analog watchdog status register
	 uint8_t RESERVED12[2]; // @322 
	__I uint16_t DFSDM1_AWSR; // @324 DFSDM analog watchdog status register
	 uint8_t RESERVED13[2]; // @326 
	__I uint16_t DFSDM2_AWSR; // @328 DFSDM analog watchdog status register
	 uint8_t RESERVED14[2]; // @330 
	__I uint16_t DFSDM3_AWSR; // @332 DFSDM analog watchdog status register
	 uint8_t RESERVED15[2]; // @334 
	__IO uint16_t DFSDM0_AWCFR; // @336 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED16[2]; // @338 
	__IO uint16_t DFSDM1_AWCFR; // @340 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED17[2]; // @342 
	__IO uint16_t DFSDM2_AWCFR; // @344 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED18[2]; // @346 
	__IO uint16_t DFSDM3_AWCFR; // @348 DFSDM analog watchdog clear flag register
	 uint8_t RESERVED19[2]; // @350 
	__I uint32_t DFSDM0_EXMAX; // @352 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM1_EXMAX; // @356 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM2_EXMAX; // @360 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM3_EXMAX; // @364 DFSDM Extremes detector maximum register
	__I uint32_t DFSDM0_EXMIN; // @368 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM1_EXMIN; // @372 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM2_EXMIN; // @376 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM3_EXMIN; // @380 DFSDM Extremes detector minimum register
	__I uint32_t DFSDM0_CNVTIMR; // @384 DFSDM conversion timer register
	__I uint32_t DFSDM1_CNVTIMR; // @388 DFSDM conversion timer register
	__I uint32_t DFSDM2_CNVTIMR; // @392 DFSDM conversion timer register
	__I uint32_t DFSDM3_CNVTIMR; // @396 DFSDM conversion timer register
};

// DFSDM->DFSDM_CHCFG0R1 DFSDM channel configuration 0 register 1
enum {
	DFSDM_DFSDM_CHCFG0R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG0R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG0R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG0R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG0R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 0
	DFSDM_DFSDM_CHCFG0R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG0R1_CHEN = 1UL<<7, // Channel 0 enable
	DFSDM_DFSDM_CHCFG0R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 0
	DFSDM_DFSDM_CHCFG0R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 0
	DFSDM_DFSDM_CHCFG0R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 0
	DFSDM_DFSDM_CHCFG0R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 0		
};
inline void dfsdm_dfsdm_chcfg0r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R1 = (p->DFSDM_CHCFG0R1 & ~DFSDM_DFSDM_CHCFG0R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG0R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg0r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R1 = (p->DFSDM_CHCFG0R1 & ~DFSDM_DFSDM_CHCFG0R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG0R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg0r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R1 = (p->DFSDM_CHCFG0R1 & ~DFSDM_DFSDM_CHCFG0R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG0R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg0r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R1 = (p->DFSDM_CHCFG0R1 & ~DFSDM_DFSDM_CHCFG0R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG0R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg0r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R1 = (p->DFSDM_CHCFG0R1 & ~DFSDM_DFSDM_CHCFG0R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG0R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg0r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R1 & DFSDM_DFSDM_CHCFG0R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg0r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R1 & DFSDM_DFSDM_CHCFG0R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg0r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R1 & DFSDM_DFSDM_CHCFG0R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg0r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R1 & DFSDM_DFSDM_CHCFG0R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg0r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R1 & DFSDM_DFSDM_CHCFG0R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG1R1 DFSDM channel configuration 1 register 1
enum {
	DFSDM_DFSDM_CHCFG1R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG1R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG1R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG1R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG1R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 1
	DFSDM_DFSDM_CHCFG1R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG1R1_CHEN = 1UL<<7, // Channel 1 enable
	DFSDM_DFSDM_CHCFG1R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 1
	DFSDM_DFSDM_CHCFG1R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 1
	DFSDM_DFSDM_CHCFG1R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 1
	DFSDM_DFSDM_CHCFG1R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 1		
};
inline void dfsdm_dfsdm_chcfg1r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R1 = (p->DFSDM_CHCFG1R1 & ~DFSDM_DFSDM_CHCFG1R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG1R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg1r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R1 = (p->DFSDM_CHCFG1R1 & ~DFSDM_DFSDM_CHCFG1R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG1R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg1r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R1 = (p->DFSDM_CHCFG1R1 & ~DFSDM_DFSDM_CHCFG1R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG1R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg1r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R1 = (p->DFSDM_CHCFG1R1 & ~DFSDM_DFSDM_CHCFG1R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG1R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg1r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R1 = (p->DFSDM_CHCFG1R1 & ~DFSDM_DFSDM_CHCFG1R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG1R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg1r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R1 & DFSDM_DFSDM_CHCFG1R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg1r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R1 & DFSDM_DFSDM_CHCFG1R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg1r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R1 & DFSDM_DFSDM_CHCFG1R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg1r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R1 & DFSDM_DFSDM_CHCFG1R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg1r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R1 & DFSDM_DFSDM_CHCFG1R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG2R1 DFSDM channel configuration 2 register 1
enum {
	DFSDM_DFSDM_CHCFG2R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG2R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG2R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG2R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG2R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 2
	DFSDM_DFSDM_CHCFG2R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG2R1_CHEN = 1UL<<7, // Channel 2 enable
	DFSDM_DFSDM_CHCFG2R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 2
	DFSDM_DFSDM_CHCFG2R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 2
	DFSDM_DFSDM_CHCFG2R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 2
	DFSDM_DFSDM_CHCFG2R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 2		
};
inline void dfsdm_dfsdm_chcfg2r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R1 = (p->DFSDM_CHCFG2R1 & ~DFSDM_DFSDM_CHCFG2R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG2R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg2r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R1 = (p->DFSDM_CHCFG2R1 & ~DFSDM_DFSDM_CHCFG2R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG2R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg2r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R1 = (p->DFSDM_CHCFG2R1 & ~DFSDM_DFSDM_CHCFG2R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG2R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg2r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R1 = (p->DFSDM_CHCFG2R1 & ~DFSDM_DFSDM_CHCFG2R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG2R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg2r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R1 = (p->DFSDM_CHCFG2R1 & ~DFSDM_DFSDM_CHCFG2R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG2R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg2r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R1 & DFSDM_DFSDM_CHCFG2R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg2r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R1 & DFSDM_DFSDM_CHCFG2R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg2r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R1 & DFSDM_DFSDM_CHCFG2R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg2r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R1 & DFSDM_DFSDM_CHCFG2R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg2r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R1 & DFSDM_DFSDM_CHCFG2R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG3R1 DFSDM channel configuration 3 register 1
enum {
	DFSDM_DFSDM_CHCFG3R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG3R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG3R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG3R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG3R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 3
	DFSDM_DFSDM_CHCFG3R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG3R1_CHEN = 1UL<<7, // Channel 3 enable
	DFSDM_DFSDM_CHCFG3R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 3
	DFSDM_DFSDM_CHCFG3R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 3
	DFSDM_DFSDM_CHCFG3R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 3
	DFSDM_DFSDM_CHCFG3R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 3		
};
inline void dfsdm_dfsdm_chcfg3r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R1 = (p->DFSDM_CHCFG3R1 & ~DFSDM_DFSDM_CHCFG3R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG3R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg3r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R1 = (p->DFSDM_CHCFG3R1 & ~DFSDM_DFSDM_CHCFG3R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG3R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg3r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R1 = (p->DFSDM_CHCFG3R1 & ~DFSDM_DFSDM_CHCFG3R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG3R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg3r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R1 = (p->DFSDM_CHCFG3R1 & ~DFSDM_DFSDM_CHCFG3R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG3R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg3r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R1 = (p->DFSDM_CHCFG3R1 & ~DFSDM_DFSDM_CHCFG3R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG3R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg3r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R1 & DFSDM_DFSDM_CHCFG3R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg3r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R1 & DFSDM_DFSDM_CHCFG3R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg3r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R1 & DFSDM_DFSDM_CHCFG3R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg3r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R1 & DFSDM_DFSDM_CHCFG3R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg3r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R1 & DFSDM_DFSDM_CHCFG3R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG4R1 DFSDM channel configuration 4 register 1
enum {
	DFSDM_DFSDM_CHCFG4R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG4R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG4R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG4R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG4R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 4
	DFSDM_DFSDM_CHCFG4R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG4R1_CHEN = 1UL<<7, // Channel 4 enable
	DFSDM_DFSDM_CHCFG4R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 4
	DFSDM_DFSDM_CHCFG4R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 4
	DFSDM_DFSDM_CHCFG4R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 4
	DFSDM_DFSDM_CHCFG4R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 4		
};
inline void dfsdm_dfsdm_chcfg4r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R1 = (p->DFSDM_CHCFG4R1 & ~DFSDM_DFSDM_CHCFG4R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG4R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg4r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R1 = (p->DFSDM_CHCFG4R1 & ~DFSDM_DFSDM_CHCFG4R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG4R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg4r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R1 = (p->DFSDM_CHCFG4R1 & ~DFSDM_DFSDM_CHCFG4R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG4R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg4r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R1 = (p->DFSDM_CHCFG4R1 & ~DFSDM_DFSDM_CHCFG4R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG4R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg4r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R1 = (p->DFSDM_CHCFG4R1 & ~DFSDM_DFSDM_CHCFG4R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG4R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg4r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R1 & DFSDM_DFSDM_CHCFG4R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg4r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R1 & DFSDM_DFSDM_CHCFG4R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg4r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R1 & DFSDM_DFSDM_CHCFG4R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg4r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R1 & DFSDM_DFSDM_CHCFG4R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg4r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R1 & DFSDM_DFSDM_CHCFG4R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG5R1 DFSDM channel configuration 5 register 1
enum {
	DFSDM_DFSDM_CHCFG5R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG5R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG5R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG5R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG5R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 5
	DFSDM_DFSDM_CHCFG5R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG5R1_CHEN = 1UL<<7, // Channel 5 enable
	DFSDM_DFSDM_CHCFG5R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 5
	DFSDM_DFSDM_CHCFG5R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 5
	DFSDM_DFSDM_CHCFG5R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 5
	DFSDM_DFSDM_CHCFG5R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 5		
};
inline void dfsdm_dfsdm_chcfg5r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R1 = (p->DFSDM_CHCFG5R1 & ~DFSDM_DFSDM_CHCFG5R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG5R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg5r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R1 = (p->DFSDM_CHCFG5R1 & ~DFSDM_DFSDM_CHCFG5R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG5R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg5r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R1 = (p->DFSDM_CHCFG5R1 & ~DFSDM_DFSDM_CHCFG5R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG5R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg5r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R1 = (p->DFSDM_CHCFG5R1 & ~DFSDM_DFSDM_CHCFG5R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG5R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg5r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R1 = (p->DFSDM_CHCFG5R1 & ~DFSDM_DFSDM_CHCFG5R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG5R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg5r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R1 & DFSDM_DFSDM_CHCFG5R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg5r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R1 & DFSDM_DFSDM_CHCFG5R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg5r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R1 & DFSDM_DFSDM_CHCFG5R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg5r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R1 & DFSDM_DFSDM_CHCFG5R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg5r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R1 & DFSDM_DFSDM_CHCFG5R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG6R1 DFSDM channel configuration 6 register 1
enum {
	DFSDM_DFSDM_CHCFG6R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG6R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG6R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG6R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG6R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 6
	DFSDM_DFSDM_CHCFG6R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG6R1_CHEN = 1UL<<7, // Channel 6 enable
	DFSDM_DFSDM_CHCFG6R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 6
	DFSDM_DFSDM_CHCFG6R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 6
	DFSDM_DFSDM_CHCFG6R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 6
	DFSDM_DFSDM_CHCFG6R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 6		
};
inline void dfsdm_dfsdm_chcfg6r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R1 = (p->DFSDM_CHCFG6R1 & ~DFSDM_DFSDM_CHCFG6R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG6R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg6r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R1 = (p->DFSDM_CHCFG6R1 & ~DFSDM_DFSDM_CHCFG6R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG6R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg6r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R1 = (p->DFSDM_CHCFG6R1 & ~DFSDM_DFSDM_CHCFG6R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG6R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg6r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R1 = (p->DFSDM_CHCFG6R1 & ~DFSDM_DFSDM_CHCFG6R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG6R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg6r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R1 = (p->DFSDM_CHCFG6R1 & ~DFSDM_DFSDM_CHCFG6R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG6R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg6r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R1 & DFSDM_DFSDM_CHCFG6R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg6r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R1 & DFSDM_DFSDM_CHCFG6R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg6r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R1 & DFSDM_DFSDM_CHCFG6R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg6r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R1 & DFSDM_DFSDM_CHCFG6R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg6r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R1 & DFSDM_DFSDM_CHCFG6R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG7R1 DFSDM channel configuration 7 register 1
enum {
	DFSDM_DFSDM_CHCFG7R1_DFSDMEN = 1UL<<31, // Global enable for DFSDM interface
	DFSDM_DFSDM_CHCFG7R1_CKOUTSRC = 1UL<<30, // Output serial clock source selection
	DFSDM_DFSDM_CHCFG7R1_CKOUTDIV = ((1UL<<8)-1) << 16, // Output serial clock divider
	DFSDM_DFSDM_CHCFG7R1_DATPACK = ((1UL<<2)-1) << 14, // Data packing mode in DFSDM_CHDATINyR register
	DFSDM_DFSDM_CHCFG7R1_DATMPX = ((1UL<<2)-1) << 12, // Input data multiplexer for channel 7
	DFSDM_DFSDM_CHCFG7R1_CHINSEL = 1UL<<8, // Channel inputs selection
	DFSDM_DFSDM_CHCFG7R1_CHEN = 1UL<<7, // Channel 7 enable
	DFSDM_DFSDM_CHCFG7R1_CKABEN = 1UL<<6, // Clock absence detector enable on channel 7
	DFSDM_DFSDM_CHCFG7R1_SCDEN = 1UL<<5, // Short-circuit detector enable on channel 7
	DFSDM_DFSDM_CHCFG7R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPI clock select for channel 7
	DFSDM_DFSDM_CHCFG7R1_SITP = ((1UL<<2)-1) << 0, // Serial interface type for channel 7		
};
inline void dfsdm_dfsdm_chcfg7r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R1 = (p->DFSDM_CHCFG7R1 & ~DFSDM_DFSDM_CHCFG7R1_CKOUTDIV) | ((val<<16) & DFSDM_DFSDM_CHCFG7R1_CKOUTDIV); }
inline void dfsdm_dfsdm_chcfg7r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R1 = (p->DFSDM_CHCFG7R1 & ~DFSDM_DFSDM_CHCFG7R1_DATPACK) | ((val<<14) & DFSDM_DFSDM_CHCFG7R1_DATPACK); }
inline void dfsdm_dfsdm_chcfg7r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R1 = (p->DFSDM_CHCFG7R1 & ~DFSDM_DFSDM_CHCFG7R1_DATMPX) | ((val<<12) & DFSDM_DFSDM_CHCFG7R1_DATMPX); }
inline void dfsdm_dfsdm_chcfg7r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R1 = (p->DFSDM_CHCFG7R1 & ~DFSDM_DFSDM_CHCFG7R1_SPICKSEL) | ((val<<2) & DFSDM_DFSDM_CHCFG7R1_SPICKSEL); }
inline void dfsdm_dfsdm_chcfg7r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R1 = (p->DFSDM_CHCFG7R1 & ~DFSDM_DFSDM_CHCFG7R1_SITP) | ((val<<0) & DFSDM_DFSDM_CHCFG7R1_SITP); }
inline uint32_t dfsdm_dfsdm_chcfg7r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R1 & DFSDM_DFSDM_CHCFG7R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chcfg7r1_get_datpack(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R1 & DFSDM_DFSDM_CHCFG7R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_dfsdm_chcfg7r1_get_datmpx(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R1 & DFSDM_DFSDM_CHCFG7R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_dfsdm_chcfg7r1_get_spicksel(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R1 & DFSDM_DFSDM_CHCFG7R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_dfsdm_chcfg7r1_get_sitp(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R1 & DFSDM_DFSDM_CHCFG7R1_SITP) >> 0 ; }

// DFSDM->DFSDM_CHCFG0R2 DFSDM channel configuration 0 register 2
enum {
	DFSDM_DFSDM_CHCFG0R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 0
	DFSDM_DFSDM_CHCFG0R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 0		
};
inline void dfsdm_dfsdm_chcfg0r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R2 = (p->DFSDM_CHCFG0R2 & ~DFSDM_DFSDM_CHCFG0R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG0R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg0r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG0R2 = (p->DFSDM_CHCFG0R2 & ~DFSDM_DFSDM_CHCFG0R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG0R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg0r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R2 & DFSDM_DFSDM_CHCFG0R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg0r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG0R2 & DFSDM_DFSDM_CHCFG0R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG1R2 DFSDM channel configuration 1 register 2
enum {
	DFSDM_DFSDM_CHCFG1R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 1
	DFSDM_DFSDM_CHCFG1R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 1		
};
inline void dfsdm_dfsdm_chcfg1r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R2 = (p->DFSDM_CHCFG1R2 & ~DFSDM_DFSDM_CHCFG1R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG1R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg1r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG1R2 = (p->DFSDM_CHCFG1R2 & ~DFSDM_DFSDM_CHCFG1R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG1R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg1r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R2 & DFSDM_DFSDM_CHCFG1R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg1r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG1R2 & DFSDM_DFSDM_CHCFG1R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG2R2 DFSDM channel configuration 2 register 2
enum {
	DFSDM_DFSDM_CHCFG2R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 2
	DFSDM_DFSDM_CHCFG2R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 2		
};
inline void dfsdm_dfsdm_chcfg2r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R2 = (p->DFSDM_CHCFG2R2 & ~DFSDM_DFSDM_CHCFG2R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG2R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg2r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG2R2 = (p->DFSDM_CHCFG2R2 & ~DFSDM_DFSDM_CHCFG2R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG2R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg2r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R2 & DFSDM_DFSDM_CHCFG2R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg2r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG2R2 & DFSDM_DFSDM_CHCFG2R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG3R2 DFSDM channel configuration 3 register 2
enum {
	DFSDM_DFSDM_CHCFG3R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 3
	DFSDM_DFSDM_CHCFG3R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 3		
};
inline void dfsdm_dfsdm_chcfg3r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R2 = (p->DFSDM_CHCFG3R2 & ~DFSDM_DFSDM_CHCFG3R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG3R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg3r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG3R2 = (p->DFSDM_CHCFG3R2 & ~DFSDM_DFSDM_CHCFG3R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG3R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg3r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R2 & DFSDM_DFSDM_CHCFG3R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg3r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG3R2 & DFSDM_DFSDM_CHCFG3R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG4R2 DFSDM channel configuration 4 register 2
enum {
	DFSDM_DFSDM_CHCFG4R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 4
	DFSDM_DFSDM_CHCFG4R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 4		
};
inline void dfsdm_dfsdm_chcfg4r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R2 = (p->DFSDM_CHCFG4R2 & ~DFSDM_DFSDM_CHCFG4R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG4R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg4r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG4R2 = (p->DFSDM_CHCFG4R2 & ~DFSDM_DFSDM_CHCFG4R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG4R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg4r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R2 & DFSDM_DFSDM_CHCFG4R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg4r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG4R2 & DFSDM_DFSDM_CHCFG4R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG5R2 DFSDM channel configuration 5 register 2
enum {
	DFSDM_DFSDM_CHCFG5R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 5
	DFSDM_DFSDM_CHCFG5R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 5		
};
inline void dfsdm_dfsdm_chcfg5r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R2 = (p->DFSDM_CHCFG5R2 & ~DFSDM_DFSDM_CHCFG5R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG5R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg5r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG5R2 = (p->DFSDM_CHCFG5R2 & ~DFSDM_DFSDM_CHCFG5R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG5R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg5r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R2 & DFSDM_DFSDM_CHCFG5R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg5r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG5R2 & DFSDM_DFSDM_CHCFG5R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG6R2 DFSDM channel configuration 6 register 2
enum {
	DFSDM_DFSDM_CHCFG6R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 6
	DFSDM_DFSDM_CHCFG6R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 6		
};
inline void dfsdm_dfsdm_chcfg6r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R2 = (p->DFSDM_CHCFG6R2 & ~DFSDM_DFSDM_CHCFG6R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG6R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg6r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG6R2 = (p->DFSDM_CHCFG6R2 & ~DFSDM_DFSDM_CHCFG6R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG6R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg6r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R2 & DFSDM_DFSDM_CHCFG6R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg6r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG6R2 & DFSDM_DFSDM_CHCFG6R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_CHCFG7R2 DFSDM channel configuration 7 register 2
enum {
	DFSDM_DFSDM_CHCFG7R2_OFFSET = ((1UL<<24)-1) << 8, // 24-bit calibration offset for channel 7
	DFSDM_DFSDM_CHCFG7R2_DTRBS = ((1UL<<5)-1) << 3, // Data right bit-shift for channel 7		
};
inline void dfsdm_dfsdm_chcfg7r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R2 = (p->DFSDM_CHCFG7R2 & ~DFSDM_DFSDM_CHCFG7R2_OFFSET) | ((val<<8) & DFSDM_DFSDM_CHCFG7R2_OFFSET); }
inline void dfsdm_dfsdm_chcfg7r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHCFG7R2 = (p->DFSDM_CHCFG7R2 & ~DFSDM_DFSDM_CHCFG7R2_DTRBS) | ((val<<3) & DFSDM_DFSDM_CHCFG7R2_DTRBS); }
inline uint32_t dfsdm_dfsdm_chcfg7r2_get_offset(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R2 & DFSDM_DFSDM_CHCFG7R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_dfsdm_chcfg7r2_get_dtrbs(struct DFSDM_Type* p) { return (p->DFSDM_CHCFG7R2 & DFSDM_DFSDM_CHCFG7R2_DTRBS) >> 3 ; }

// DFSDM->DFSDM_AWSCD0R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD0R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 0
	DFSDM_DFSDM_AWSCD0R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 0
	DFSDM_DFSDM_AWSCD0R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 0
	DFSDM_DFSDM_AWSCD0R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 0		
};
inline void dfsdm_dfsdm_awscd0r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD0R = (p->DFSDM_AWSCD0R & ~DFSDM_DFSDM_AWSCD0R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD0R_AWFORD); }
inline void dfsdm_dfsdm_awscd0r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD0R = (p->DFSDM_AWSCD0R & ~DFSDM_DFSDM_AWSCD0R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD0R_AWFOSR); }
inline void dfsdm_dfsdm_awscd0r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD0R = (p->DFSDM_AWSCD0R & ~DFSDM_DFSDM_AWSCD0R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD0R_BKSCD); }
inline void dfsdm_dfsdm_awscd0r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD0R = (p->DFSDM_AWSCD0R & ~DFSDM_DFSDM_AWSCD0R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD0R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd0r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD0R & DFSDM_DFSDM_AWSCD0R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd0r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD0R & DFSDM_DFSDM_AWSCD0R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd0r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD0R & DFSDM_DFSDM_AWSCD0R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd0r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD0R & DFSDM_DFSDM_AWSCD0R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD1R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD1R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 1
	DFSDM_DFSDM_AWSCD1R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 1
	DFSDM_DFSDM_AWSCD1R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 1
	DFSDM_DFSDM_AWSCD1R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 1		
};
inline void dfsdm_dfsdm_awscd1r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD1R = (p->DFSDM_AWSCD1R & ~DFSDM_DFSDM_AWSCD1R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD1R_AWFORD); }
inline void dfsdm_dfsdm_awscd1r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD1R = (p->DFSDM_AWSCD1R & ~DFSDM_DFSDM_AWSCD1R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD1R_AWFOSR); }
inline void dfsdm_dfsdm_awscd1r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD1R = (p->DFSDM_AWSCD1R & ~DFSDM_DFSDM_AWSCD1R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD1R_BKSCD); }
inline void dfsdm_dfsdm_awscd1r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD1R = (p->DFSDM_AWSCD1R & ~DFSDM_DFSDM_AWSCD1R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD1R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd1r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD1R & DFSDM_DFSDM_AWSCD1R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd1r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD1R & DFSDM_DFSDM_AWSCD1R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd1r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD1R & DFSDM_DFSDM_AWSCD1R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd1r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD1R & DFSDM_DFSDM_AWSCD1R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD2R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD2R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 2
	DFSDM_DFSDM_AWSCD2R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 2
	DFSDM_DFSDM_AWSCD2R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 2
	DFSDM_DFSDM_AWSCD2R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 2		
};
inline void dfsdm_dfsdm_awscd2r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD2R = (p->DFSDM_AWSCD2R & ~DFSDM_DFSDM_AWSCD2R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD2R_AWFORD); }
inline void dfsdm_dfsdm_awscd2r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD2R = (p->DFSDM_AWSCD2R & ~DFSDM_DFSDM_AWSCD2R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD2R_AWFOSR); }
inline void dfsdm_dfsdm_awscd2r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD2R = (p->DFSDM_AWSCD2R & ~DFSDM_DFSDM_AWSCD2R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD2R_BKSCD); }
inline void dfsdm_dfsdm_awscd2r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD2R = (p->DFSDM_AWSCD2R & ~DFSDM_DFSDM_AWSCD2R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD2R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd2r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD2R & DFSDM_DFSDM_AWSCD2R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd2r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD2R & DFSDM_DFSDM_AWSCD2R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd2r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD2R & DFSDM_DFSDM_AWSCD2R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd2r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD2R & DFSDM_DFSDM_AWSCD2R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD3R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD3R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 3
	DFSDM_DFSDM_AWSCD3R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 3
	DFSDM_DFSDM_AWSCD3R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 3
	DFSDM_DFSDM_AWSCD3R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 3		
};
inline void dfsdm_dfsdm_awscd3r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD3R = (p->DFSDM_AWSCD3R & ~DFSDM_DFSDM_AWSCD3R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD3R_AWFORD); }
inline void dfsdm_dfsdm_awscd3r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD3R = (p->DFSDM_AWSCD3R & ~DFSDM_DFSDM_AWSCD3R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD3R_AWFOSR); }
inline void dfsdm_dfsdm_awscd3r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD3R = (p->DFSDM_AWSCD3R & ~DFSDM_DFSDM_AWSCD3R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD3R_BKSCD); }
inline void dfsdm_dfsdm_awscd3r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD3R = (p->DFSDM_AWSCD3R & ~DFSDM_DFSDM_AWSCD3R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD3R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd3r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD3R & DFSDM_DFSDM_AWSCD3R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd3r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD3R & DFSDM_DFSDM_AWSCD3R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd3r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD3R & DFSDM_DFSDM_AWSCD3R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd3r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD3R & DFSDM_DFSDM_AWSCD3R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD4R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD4R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 4
	DFSDM_DFSDM_AWSCD4R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 4
	DFSDM_DFSDM_AWSCD4R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 4
	DFSDM_DFSDM_AWSCD4R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 4		
};
inline void dfsdm_dfsdm_awscd4r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD4R = (p->DFSDM_AWSCD4R & ~DFSDM_DFSDM_AWSCD4R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD4R_AWFORD); }
inline void dfsdm_dfsdm_awscd4r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD4R = (p->DFSDM_AWSCD4R & ~DFSDM_DFSDM_AWSCD4R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD4R_AWFOSR); }
inline void dfsdm_dfsdm_awscd4r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD4R = (p->DFSDM_AWSCD4R & ~DFSDM_DFSDM_AWSCD4R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD4R_BKSCD); }
inline void dfsdm_dfsdm_awscd4r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD4R = (p->DFSDM_AWSCD4R & ~DFSDM_DFSDM_AWSCD4R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD4R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd4r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD4R & DFSDM_DFSDM_AWSCD4R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd4r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD4R & DFSDM_DFSDM_AWSCD4R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd4r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD4R & DFSDM_DFSDM_AWSCD4R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd4r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD4R & DFSDM_DFSDM_AWSCD4R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD5R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD5R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 5
	DFSDM_DFSDM_AWSCD5R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 5
	DFSDM_DFSDM_AWSCD5R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 5
	DFSDM_DFSDM_AWSCD5R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 5		
};
inline void dfsdm_dfsdm_awscd5r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD5R = (p->DFSDM_AWSCD5R & ~DFSDM_DFSDM_AWSCD5R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD5R_AWFORD); }
inline void dfsdm_dfsdm_awscd5r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD5R = (p->DFSDM_AWSCD5R & ~DFSDM_DFSDM_AWSCD5R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD5R_AWFOSR); }
inline void dfsdm_dfsdm_awscd5r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD5R = (p->DFSDM_AWSCD5R & ~DFSDM_DFSDM_AWSCD5R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD5R_BKSCD); }
inline void dfsdm_dfsdm_awscd5r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD5R = (p->DFSDM_AWSCD5R & ~DFSDM_DFSDM_AWSCD5R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD5R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd5r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD5R & DFSDM_DFSDM_AWSCD5R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd5r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD5R & DFSDM_DFSDM_AWSCD5R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd5r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD5R & DFSDM_DFSDM_AWSCD5R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd5r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD5R & DFSDM_DFSDM_AWSCD5R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD6R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD6R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 6
	DFSDM_DFSDM_AWSCD6R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 6
	DFSDM_DFSDM_AWSCD6R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 6
	DFSDM_DFSDM_AWSCD6R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 6		
};
inline void dfsdm_dfsdm_awscd6r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD6R = (p->DFSDM_AWSCD6R & ~DFSDM_DFSDM_AWSCD6R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD6R_AWFORD); }
inline void dfsdm_dfsdm_awscd6r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD6R = (p->DFSDM_AWSCD6R & ~DFSDM_DFSDM_AWSCD6R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD6R_AWFOSR); }
inline void dfsdm_dfsdm_awscd6r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD6R = (p->DFSDM_AWSCD6R & ~DFSDM_DFSDM_AWSCD6R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD6R_BKSCD); }
inline void dfsdm_dfsdm_awscd6r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD6R = (p->DFSDM_AWSCD6R & ~DFSDM_DFSDM_AWSCD6R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD6R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd6r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD6R & DFSDM_DFSDM_AWSCD6R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd6r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD6R & DFSDM_DFSDM_AWSCD6R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd6r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD6R & DFSDM_DFSDM_AWSCD6R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd6r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD6R & DFSDM_DFSDM_AWSCD6R_SCDT) >> 0 ; }

// DFSDM->DFSDM_AWSCD7R DFSDM analog watchdog and short-circuit detector register
enum {
	DFSDM_DFSDM_AWSCD7R_AWFORD = ((1UL<<2)-1) << 22, // Analog watchdog Sinc filter order on channel 7
	DFSDM_DFSDM_AWSCD7R_AWFOSR = ((1UL<<5)-1) << 16, // Analog watchdog filter oversampling ratio (decimation rate) on channel 7
	DFSDM_DFSDM_AWSCD7R_BKSCD = ((1UL<<4)-1) << 12, // Break signal assignment for short-circuit detector on channel 7
	DFSDM_DFSDM_AWSCD7R_SCDT = ((1UL<<8)-1) << 0, // short-circuit detector threshold for channel 7		
};
inline void dfsdm_dfsdm_awscd7r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD7R = (p->DFSDM_AWSCD7R & ~DFSDM_DFSDM_AWSCD7R_AWFORD) | ((val<<22) & DFSDM_DFSDM_AWSCD7R_AWFORD); }
inline void dfsdm_dfsdm_awscd7r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD7R = (p->DFSDM_AWSCD7R & ~DFSDM_DFSDM_AWSCD7R_AWFOSR) | ((val<<16) & DFSDM_DFSDM_AWSCD7R_AWFOSR); }
inline void dfsdm_dfsdm_awscd7r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD7R = (p->DFSDM_AWSCD7R & ~DFSDM_DFSDM_AWSCD7R_BKSCD) | ((val<<12) & DFSDM_DFSDM_AWSCD7R_BKSCD); }
inline void dfsdm_dfsdm_awscd7r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_AWSCD7R = (p->DFSDM_AWSCD7R & ~DFSDM_DFSDM_AWSCD7R_SCDT) | ((val<<0) & DFSDM_DFSDM_AWSCD7R_SCDT); }
inline uint32_t dfsdm_dfsdm_awscd7r_get_awford(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD7R & DFSDM_DFSDM_AWSCD7R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_dfsdm_awscd7r_get_awfosr(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD7R & DFSDM_DFSDM_AWSCD7R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm_awscd7r_get_bkscd(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD7R & DFSDM_DFSDM_AWSCD7R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_dfsdm_awscd7r_get_scdt(struct DFSDM_Type* p) { return (p->DFSDM_AWSCD7R & DFSDM_DFSDM_AWSCD7R_SCDT) >> 0 ; }

// DFSDM->DFSDM_CHDATIN0R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN0R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 1
	DFSDM_DFSDM_CHDATIN0R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 0		
};
inline void dfsdm_dfsdm_chdatin0r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN0R = (p->DFSDM_CHDATIN0R & ~DFSDM_DFSDM_CHDATIN0R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN0R_INDAT1); }
inline void dfsdm_dfsdm_chdatin0r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN0R = (p->DFSDM_CHDATIN0R & ~DFSDM_DFSDM_CHDATIN0R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN0R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin0r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN0R & DFSDM_DFSDM_CHDATIN0R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin0r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN0R & DFSDM_DFSDM_CHDATIN0R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN1R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN1R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 2
	DFSDM_DFSDM_CHDATIN1R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 1		
};
inline void dfsdm_dfsdm_chdatin1r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN1R = (p->DFSDM_CHDATIN1R & ~DFSDM_DFSDM_CHDATIN1R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN1R_INDAT1); }
inline void dfsdm_dfsdm_chdatin1r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN1R = (p->DFSDM_CHDATIN1R & ~DFSDM_DFSDM_CHDATIN1R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN1R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin1r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN1R & DFSDM_DFSDM_CHDATIN1R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin1r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN1R & DFSDM_DFSDM_CHDATIN1R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN2R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN2R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 3
	DFSDM_DFSDM_CHDATIN2R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 2		
};
inline void dfsdm_dfsdm_chdatin2r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN2R = (p->DFSDM_CHDATIN2R & ~DFSDM_DFSDM_CHDATIN2R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN2R_INDAT1); }
inline void dfsdm_dfsdm_chdatin2r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN2R = (p->DFSDM_CHDATIN2R & ~DFSDM_DFSDM_CHDATIN2R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN2R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin2r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN2R & DFSDM_DFSDM_CHDATIN2R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin2r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN2R & DFSDM_DFSDM_CHDATIN2R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN3R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN3R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 4
	DFSDM_DFSDM_CHDATIN3R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 3		
};
inline void dfsdm_dfsdm_chdatin3r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN3R = (p->DFSDM_CHDATIN3R & ~DFSDM_DFSDM_CHDATIN3R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN3R_INDAT1); }
inline void dfsdm_dfsdm_chdatin3r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN3R = (p->DFSDM_CHDATIN3R & ~DFSDM_DFSDM_CHDATIN3R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN3R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin3r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN3R & DFSDM_DFSDM_CHDATIN3R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin3r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN3R & DFSDM_DFSDM_CHDATIN3R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN4R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN4R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 5
	DFSDM_DFSDM_CHDATIN4R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 4		
};
inline void dfsdm_dfsdm_chdatin4r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN4R = (p->DFSDM_CHDATIN4R & ~DFSDM_DFSDM_CHDATIN4R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN4R_INDAT1); }
inline void dfsdm_dfsdm_chdatin4r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN4R = (p->DFSDM_CHDATIN4R & ~DFSDM_DFSDM_CHDATIN4R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN4R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin4r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN4R & DFSDM_DFSDM_CHDATIN4R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin4r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN4R & DFSDM_DFSDM_CHDATIN4R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN5R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN5R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 6
	DFSDM_DFSDM_CHDATIN5R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 5		
};
inline void dfsdm_dfsdm_chdatin5r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN5R = (p->DFSDM_CHDATIN5R & ~DFSDM_DFSDM_CHDATIN5R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN5R_INDAT1); }
inline void dfsdm_dfsdm_chdatin5r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN5R = (p->DFSDM_CHDATIN5R & ~DFSDM_DFSDM_CHDATIN5R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN5R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin5r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN5R & DFSDM_DFSDM_CHDATIN5R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin5r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN5R & DFSDM_DFSDM_CHDATIN5R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN6R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN6R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 7
	DFSDM_DFSDM_CHDATIN6R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 6		
};
inline void dfsdm_dfsdm_chdatin6r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN6R = (p->DFSDM_CHDATIN6R & ~DFSDM_DFSDM_CHDATIN6R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN6R_INDAT1); }
inline void dfsdm_dfsdm_chdatin6r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN6R = (p->DFSDM_CHDATIN6R & ~DFSDM_DFSDM_CHDATIN6R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN6R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin6r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN6R & DFSDM_DFSDM_CHDATIN6R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin6r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN6R & DFSDM_DFSDM_CHDATIN6R_INDAT0) >> 0 ; }

// DFSDM->DFSDM_CHDATIN7R DFSDM channel data input register
enum {
	DFSDM_DFSDM_CHDATIN7R_INDAT1 = ((1UL<<16)-1) << 16, // Input data for channel 8
	DFSDM_DFSDM_CHDATIN7R_INDAT0 = ((1UL<<16)-1) << 0, // Input data for channel 7		
};
inline void dfsdm_dfsdm_chdatin7r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN7R = (p->DFSDM_CHDATIN7R & ~DFSDM_DFSDM_CHDATIN7R_INDAT1) | ((val<<16) & DFSDM_DFSDM_CHDATIN7R_INDAT1); }
inline void dfsdm_dfsdm_chdatin7r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->DFSDM_CHDATIN7R = (p->DFSDM_CHDATIN7R & ~DFSDM_DFSDM_CHDATIN7R_INDAT0) | ((val<<0) & DFSDM_DFSDM_CHDATIN7R_INDAT0); }
inline uint32_t dfsdm_dfsdm_chdatin7r_get_indat1(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN7R & DFSDM_DFSDM_CHDATIN7R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_dfsdm_chdatin7r_get_indat0(struct DFSDM_Type* p) { return (p->DFSDM_CHDATIN7R & DFSDM_DFSDM_CHDATIN7R_INDAT0) >> 0 ; }

// DFSDM->DFSDM0_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM0_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM0_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM0_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM0_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM0_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM0_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM0_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM0_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM0_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM0_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM0_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM0_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM0_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM0_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm0_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_RCH) | ((val<<24) & DFSDM_DFSDM0_CR1_RCH); }
inline void dfsdm_dfsdm0_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM0_CR1_JEXTEN); }
inline void dfsdm_dfsdm0_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM0_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm0_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm0_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM1_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM1_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM1_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM1_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM1_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM1_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM1_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM1_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM1_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM1_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM1_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM1_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM1_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM1_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM1_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm1_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_RCH) | ((val<<24) & DFSDM_DFSDM1_CR1_RCH); }
inline void dfsdm_dfsdm1_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM1_CR1_JEXTEN); }
inline void dfsdm_dfsdm1_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM1_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm1_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm1_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM2_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM2_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM2_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM2_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM2_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM2_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM2_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM2_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM2_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM2_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM2_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM2_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM2_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM2_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM2_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm2_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_RCH) | ((val<<24) & DFSDM_DFSDM2_CR1_RCH); }
inline void dfsdm_dfsdm2_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM2_CR1_JEXTEN); }
inline void dfsdm_dfsdm2_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM2_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm2_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm2_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM3_CR1 DFSDM control register 1
enum {
	DFSDM_DFSDM3_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM3_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM3_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM3_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM3_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM3_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM3_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM3_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM3_CR1_JEXTSEL = ((1UL<<5)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM3_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM3_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM3_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM3_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM3_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm3_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_RCH) | ((val<<24) & DFSDM_DFSDM3_CR1_RCH); }
inline void dfsdm_dfsdm3_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM3_CR1_JEXTEN); }
inline void dfsdm_dfsdm3_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM3_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm3_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm3_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM0_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM0_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM0_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM0_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM0_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM0_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM0_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM0_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM0_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM0_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm0_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR2 = (p->DFSDM0_CR2 & ~DFSDM_DFSDM0_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM0_CR2_AWDCH); }
inline void dfsdm_dfsdm0_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR2 = (p->DFSDM0_CR2 & ~DFSDM_DFSDM0_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM0_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm0_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM0_CR2 & DFSDM_DFSDM0_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm0_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM0_CR2 & DFSDM_DFSDM0_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM1_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM1_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM1_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM1_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM1_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM1_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM1_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM1_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM1_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM1_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm1_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR2 = (p->DFSDM1_CR2 & ~DFSDM_DFSDM1_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM1_CR2_AWDCH); }
inline void dfsdm_dfsdm1_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR2 = (p->DFSDM1_CR2 & ~DFSDM_DFSDM1_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM1_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm1_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM1_CR2 & DFSDM_DFSDM1_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm1_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM1_CR2 & DFSDM_DFSDM1_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM2_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM2_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM2_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM2_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM2_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM2_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM2_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM2_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM2_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM2_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm2_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR2 = (p->DFSDM2_CR2 & ~DFSDM_DFSDM2_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM2_CR2_AWDCH); }
inline void dfsdm_dfsdm2_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR2 = (p->DFSDM2_CR2 & ~DFSDM_DFSDM2_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM2_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm2_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM2_CR2 & DFSDM_DFSDM2_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm2_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM2_CR2 & DFSDM_DFSDM2_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM3_CR2 DFSDM control register 2
enum {
	DFSDM_DFSDM3_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM3_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM3_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM3_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM3_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM3_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM3_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM3_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM3_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm3_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR2 = (p->DFSDM3_CR2 & ~DFSDM_DFSDM3_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM3_CR2_AWDCH); }
inline void dfsdm_dfsdm3_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR2 = (p->DFSDM3_CR2 & ~DFSDM_DFSDM3_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM3_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm3_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM3_CR2 & DFSDM_DFSDM3_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm3_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM3_CR2 & DFSDM_DFSDM3_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM0_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM0_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM0_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM0_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM0_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM0_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM0_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM0_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM0_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM0_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm0_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM0_ISR & DFSDM_DFSDM0_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM0_ISR & DFSDM_DFSDM0_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM1_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM1_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM1_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM1_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM1_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM1_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM1_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM1_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM1_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM1_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm1_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM1_ISR & DFSDM_DFSDM1_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM1_ISR & DFSDM_DFSDM1_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM2_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM2_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM2_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM2_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM2_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM2_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM2_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM2_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM2_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM2_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm2_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM2_ISR & DFSDM_DFSDM2_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM2_ISR & DFSDM_DFSDM2_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM3_ISR DFSDM interrupt and status register
enum {
	DFSDM_DFSDM3_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM3_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM3_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM3_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM3_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM3_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM3_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM3_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM3_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm3_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM3_ISR & DFSDM_DFSDM3_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM3_ISR & DFSDM_DFSDM3_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM0_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM0_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM0_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM0_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM0_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm0_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_ICR = (p->DFSDM0_ICR & ~DFSDM_DFSDM0_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM0_ICR_CLRSCDF); }
inline void dfsdm_dfsdm0_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_ICR = (p->DFSDM0_ICR & ~DFSDM_DFSDM0_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM0_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm0_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM0_ICR & DFSDM_DFSDM0_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM0_ICR & DFSDM_DFSDM0_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM1_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM1_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM1_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM1_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM1_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm1_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_ICR = (p->DFSDM1_ICR & ~DFSDM_DFSDM1_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM1_ICR_CLRSCDF); }
inline void dfsdm_dfsdm1_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_ICR = (p->DFSDM1_ICR & ~DFSDM_DFSDM1_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM1_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm1_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM1_ICR & DFSDM_DFSDM1_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM1_ICR & DFSDM_DFSDM1_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM2_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM2_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM2_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM2_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM2_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm2_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_ICR = (p->DFSDM2_ICR & ~DFSDM_DFSDM2_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM2_ICR_CLRSCDF); }
inline void dfsdm_dfsdm2_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_ICR = (p->DFSDM2_ICR & ~DFSDM_DFSDM2_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM2_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm2_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM2_ICR & DFSDM_DFSDM2_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM2_ICR & DFSDM_DFSDM2_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM3_ICR DFSDM interrupt flag clear register
enum {
	DFSDM_DFSDM3_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM3_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM3_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM3_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm3_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_ICR = (p->DFSDM3_ICR & ~DFSDM_DFSDM3_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM3_ICR_CLRSCDF); }
inline void dfsdm_dfsdm3_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_ICR = (p->DFSDM3_ICR & ~DFSDM_DFSDM3_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM3_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm3_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM3_ICR & DFSDM_DFSDM3_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM3_ICR & DFSDM_DFSDM3_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM0_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM0_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM0_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM0_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm0_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_FORD) | ((val<<29) & DFSDM_DFSDM0_FCR_FORD); }
inline void dfsdm_dfsdm0_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM0_FCR_FOSR); }
inline void dfsdm_dfsdm0_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM0_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm0_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm0_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm0_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM1_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM1_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM1_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM1_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm1_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_FORD) | ((val<<29) & DFSDM_DFSDM1_FCR_FORD); }
inline void dfsdm_dfsdm1_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM1_FCR_FOSR); }
inline void dfsdm_dfsdm1_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM1_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm1_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm1_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm1_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM2_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM2_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM2_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM2_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm2_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_FORD) | ((val<<29) & DFSDM_DFSDM2_FCR_FORD); }
inline void dfsdm_dfsdm2_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM2_FCR_FOSR); }
inline void dfsdm_dfsdm2_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM2_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm2_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm2_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm2_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM3_FCR DFSDM filter control register
enum {
	DFSDM_DFSDM3_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM3_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM3_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm3_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_FORD) | ((val<<29) & DFSDM_DFSDM3_FCR_FORD); }
inline void dfsdm_dfsdm3_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM3_FCR_FOSR); }
inline void dfsdm_dfsdm3_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM3_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm3_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm3_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm3_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM0_JDATAR DFSDM data register for injected group
enum {
	DFSDM_DFSDM0_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM0_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm0_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM0_JDATAR & DFSDM_DFSDM0_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM0_JDATAR & DFSDM_DFSDM0_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM1_JDATAR DFSDM data register for injected group
enum {
	DFSDM_DFSDM1_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM1_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm1_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM1_JDATAR & DFSDM_DFSDM1_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM1_JDATAR & DFSDM_DFSDM1_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM2_JDATAR DFSDM data register for injected group
enum {
	DFSDM_DFSDM2_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM2_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm2_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM2_JDATAR & DFSDM_DFSDM2_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM2_JDATAR & DFSDM_DFSDM2_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM3_JDATAR DFSDM data register for injected group
enum {
	DFSDM_DFSDM3_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM3_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm3_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM3_JDATAR & DFSDM_DFSDM3_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM3_JDATAR & DFSDM_DFSDM3_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM0_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM0_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM0_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM0_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm0_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM0_RDATAR & DFSDM_DFSDM0_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM0_RDATAR & DFSDM_DFSDM0_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM1_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM1_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM1_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM1_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm1_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM1_RDATAR & DFSDM_DFSDM1_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM1_RDATAR & DFSDM_DFSDM1_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM2_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM2_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM2_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM2_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm2_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM2_RDATAR & DFSDM_DFSDM2_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM2_RDATAR & DFSDM_DFSDM2_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM3_RDATAR DFSDM data register for the regular channel
enum {
	DFSDM_DFSDM3_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM3_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM3_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm3_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM3_RDATAR & DFSDM_DFSDM3_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM3_RDATAR & DFSDM_DFSDM3_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM0_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM0_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM0_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm0_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWHTR = (p->DFSDM0_AWHTR & ~DFSDM_DFSDM0_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM0_AWHTR_AWHT); }
inline void dfsdm_dfsdm0_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWHTR = (p->DFSDM0_AWHTR & ~DFSDM_DFSDM0_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM0_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm0_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM0_AWHTR & DFSDM_DFSDM0_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM0_AWHTR & DFSDM_DFSDM0_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM1_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM1_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM1_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm1_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWHTR = (p->DFSDM1_AWHTR & ~DFSDM_DFSDM1_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM1_AWHTR_AWHT); }
inline void dfsdm_dfsdm1_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWHTR = (p->DFSDM1_AWHTR & ~DFSDM_DFSDM1_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM1_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm1_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM1_AWHTR & DFSDM_DFSDM1_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM1_AWHTR & DFSDM_DFSDM1_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM2_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM2_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM2_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm2_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWHTR = (p->DFSDM2_AWHTR & ~DFSDM_DFSDM2_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM2_AWHTR_AWHT); }
inline void dfsdm_dfsdm2_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWHTR = (p->DFSDM2_AWHTR & ~DFSDM_DFSDM2_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM2_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm2_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM2_AWHTR & DFSDM_DFSDM2_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM2_AWHTR & DFSDM_DFSDM2_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM3_AWHTR DFSDM analog watchdog high threshold register
enum {
	DFSDM_DFSDM3_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM3_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm3_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWHTR = (p->DFSDM3_AWHTR & ~DFSDM_DFSDM3_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM3_AWHTR_AWHT); }
inline void dfsdm_dfsdm3_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWHTR = (p->DFSDM3_AWHTR & ~DFSDM_DFSDM3_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM3_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm3_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM3_AWHTR & DFSDM_DFSDM3_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM3_AWHTR & DFSDM_DFSDM3_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM0_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM0_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM0_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm0_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWLTR = (p->DFSDM0_AWLTR & ~DFSDM_DFSDM0_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM0_AWLTR_AWLT); }
inline void dfsdm_dfsdm0_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWLTR = (p->DFSDM0_AWLTR & ~DFSDM_DFSDM0_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM0_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm0_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM0_AWLTR & DFSDM_DFSDM0_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM0_AWLTR & DFSDM_DFSDM0_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM1_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM1_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM1_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm1_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWLTR = (p->DFSDM1_AWLTR & ~DFSDM_DFSDM1_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM1_AWLTR_AWLT); }
inline void dfsdm_dfsdm1_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWLTR = (p->DFSDM1_AWLTR & ~DFSDM_DFSDM1_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM1_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm1_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM1_AWLTR & DFSDM_DFSDM1_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM1_AWLTR & DFSDM_DFSDM1_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM2_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM2_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM2_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm2_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWLTR = (p->DFSDM2_AWLTR & ~DFSDM_DFSDM2_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM2_AWLTR_AWLT); }
inline void dfsdm_dfsdm2_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWLTR = (p->DFSDM2_AWLTR & ~DFSDM_DFSDM2_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM2_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm2_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM2_AWLTR & DFSDM_DFSDM2_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM2_AWLTR & DFSDM_DFSDM2_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM3_AWLTR DFSDM analog watchdog low threshold register
enum {
	DFSDM_DFSDM3_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM3_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm3_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWLTR = (p->DFSDM3_AWLTR & ~DFSDM_DFSDM3_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM3_AWLTR_AWLT); }
inline void dfsdm_dfsdm3_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWLTR = (p->DFSDM3_AWLTR & ~DFSDM_DFSDM3_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM3_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm3_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM3_AWLTR & DFSDM_DFSDM3_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM3_AWLTR & DFSDM_DFSDM3_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM0_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM0_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM0_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm0_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM0_AWSR & DFSDM_DFSDM0_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM0_AWSR & DFSDM_DFSDM0_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM1_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM1_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM1_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm1_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM1_AWSR & DFSDM_DFSDM1_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM1_AWSR & DFSDM_DFSDM1_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM2_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM2_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM2_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm2_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM2_AWSR & DFSDM_DFSDM2_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM2_AWSR & DFSDM_DFSDM2_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM3_AWSR DFSDM analog watchdog status register
enum {
	DFSDM_DFSDM3_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM3_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm3_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM3_AWSR & DFSDM_DFSDM3_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM3_AWSR & DFSDM_DFSDM3_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM0_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM0_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM0_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm0_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWCFR = (p->DFSDM0_AWCFR & ~DFSDM_DFSDM0_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM0_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm0_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWCFR = (p->DFSDM0_AWCFR & ~DFSDM_DFSDM0_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM0_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm0_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM0_AWCFR & DFSDM_DFSDM0_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM0_AWCFR & DFSDM_DFSDM0_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM1_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM1_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM1_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm1_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWCFR = (p->DFSDM1_AWCFR & ~DFSDM_DFSDM1_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM1_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm1_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWCFR = (p->DFSDM1_AWCFR & ~DFSDM_DFSDM1_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM1_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm1_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM1_AWCFR & DFSDM_DFSDM1_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM1_AWCFR & DFSDM_DFSDM1_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM2_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM2_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM2_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm2_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWCFR = (p->DFSDM2_AWCFR & ~DFSDM_DFSDM2_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM2_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm2_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWCFR = (p->DFSDM2_AWCFR & ~DFSDM_DFSDM2_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM2_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm2_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM2_AWCFR & DFSDM_DFSDM2_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM2_AWCFR & DFSDM_DFSDM2_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM3_AWCFR DFSDM analog watchdog clear flag register
enum {
	DFSDM_DFSDM3_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM3_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm3_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWCFR = (p->DFSDM3_AWCFR & ~DFSDM_DFSDM3_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM3_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm3_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWCFR = (p->DFSDM3_AWCFR & ~DFSDM_DFSDM3_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM3_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm3_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM3_AWCFR & DFSDM_DFSDM3_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM3_AWCFR & DFSDM_DFSDM3_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM0_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM0_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM0_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm0_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM0_EXMAX & DFSDM_DFSDM0_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM0_EXMAX & DFSDM_DFSDM0_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM1_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM1_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM1_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm1_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM1_EXMAX & DFSDM_DFSDM1_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM1_EXMAX & DFSDM_DFSDM1_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM2_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM2_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM2_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm2_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM2_EXMAX & DFSDM_DFSDM2_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM2_EXMAX & DFSDM_DFSDM2_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM3_EXMAX DFSDM Extremes detector maximum register
enum {
	DFSDM_DFSDM3_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM3_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm3_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM3_EXMAX & DFSDM_DFSDM3_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM3_EXMAX & DFSDM_DFSDM3_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM0_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM0_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM0_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm0_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM0_EXMIN & DFSDM_DFSDM0_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM0_EXMIN & DFSDM_DFSDM0_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM1_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM1_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM1_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm1_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM1_EXMIN & DFSDM_DFSDM1_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM1_EXMIN & DFSDM_DFSDM1_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM2_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM2_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM2_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm2_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM2_EXMIN & DFSDM_DFSDM2_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM2_EXMIN & DFSDM_DFSDM2_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM3_EXMIN DFSDM Extremes detector minimum register
enum {
	DFSDM_DFSDM3_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // Extremes detector minimum value
	DFSDM_DFSDM3_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm3_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM3_EXMIN & DFSDM_DFSDM3_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM3_EXMIN & DFSDM_DFSDM3_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM0_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM0_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm0_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM0_CNVTIMR & DFSDM_DFSDM0_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM1_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM1_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm1_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM1_CNVTIMR & DFSDM_DFSDM1_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM2_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM2_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm2_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM2_CNVTIMR & DFSDM_DFSDM2_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM3_CNVTIMR DFSDM conversion timer register
enum {
	DFSDM_DFSDM3_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time		
};
inline uint32_t dfsdm_dfsdm3_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM3_CNVTIMR & DFSDM_DFSDM3_CNVTIMR_CNVCNT) >> 4 ; }

/* DMA controller */
struct DMA1_Type {
	__I uint32_t LISR; // @0 low interrupt status register
	__I uint32_t HISR; // @4 high interrupt status register
	__IO uint32_t LIFCR; // @8 low interrupt flag clear register
	__IO uint32_t HIFCR; // @12 high interrupt flag clear register
	__IO uint32_t S0CR; // @16 stream x configuration register
	__IO uint16_t S0NDTR; // @20 stream x number of data register
	 uint8_t RESERVED0[2]; // @22 
	__IO uint32_t S0PAR; // @24 stream x peripheral address register
	__IO uint32_t S0M0AR; // @28 stream x memory 0 address register
	__IO uint32_t S0M1AR; // @32 stream x memory 1 address register
	__IO uint8_t S0FCR; // @36 stream x FIFO control register
	 uint8_t RESERVED1[3]; // @37 
	__IO uint32_t S1CR; // @40 stream x configuration register
	__IO uint16_t S1NDTR; // @44 stream x number of data register
	 uint8_t RESERVED2[2]; // @46 
	__IO uint32_t S1PAR; // @48 stream x peripheral address register
	__IO uint32_t S1M0AR; // @52 stream x memory 0 address register
	__IO uint32_t S1M1AR; // @56 stream x memory 1 address register
	__IO uint8_t S1FCR; // @60 stream x FIFO control register
	 uint8_t RESERVED3[3]; // @61 
	__IO uint32_t S2CR; // @64 stream x configuration register
	__IO uint16_t S2NDTR; // @68 stream x number of data register
	 uint8_t RESERVED4[2]; // @70 
	__IO uint32_t S2PAR; // @72 stream x peripheral address register
	__IO uint32_t S2M0AR; // @76 stream x memory 0 address register
	__IO uint32_t S2M1AR; // @80 stream x memory 1 address register
	__IO uint8_t S2FCR; // @84 stream x FIFO control register
	 uint8_t RESERVED5[3]; // @85 
	__IO uint32_t S3CR; // @88 stream x configuration register
	__IO uint16_t S3NDTR; // @92 stream x number of data register
	 uint8_t RESERVED6[2]; // @94 
	__IO uint32_t S3PAR; // @96 stream x peripheral address register
	__IO uint32_t S3M0AR; // @100 stream x memory 0 address register
	__IO uint32_t S3M1AR; // @104 stream x memory 1 address register
	__IO uint8_t S3FCR; // @108 stream x FIFO control register
	 uint8_t RESERVED7[3]; // @109 
	__IO uint32_t S4CR; // @112 stream x configuration register
	__IO uint16_t S4NDTR; // @116 stream x number of data register
	 uint8_t RESERVED8[2]; // @118 
	__IO uint32_t S4PAR; // @120 stream x peripheral address register
	__IO uint32_t S4M0AR; // @124 stream x memory 0 address register
	__IO uint32_t S4M1AR; // @128 stream x memory 1 address register
	__IO uint8_t S4FCR; // @132 stream x FIFO control register
	 uint8_t RESERVED9[3]; // @133 
	__IO uint32_t S5CR; // @136 stream x configuration register
	__IO uint16_t S5NDTR; // @140 stream x number of data register
	 uint8_t RESERVED10[2]; // @142 
	__IO uint32_t S5PAR; // @144 stream x peripheral address register
	__IO uint32_t S5M0AR; // @148 stream x memory 0 address register
	__IO uint32_t S5M1AR; // @152 stream x memory 1 address register
	__IO uint8_t S5FCR; // @156 stream x FIFO control register
	 uint8_t RESERVED11[3]; // @157 
	__IO uint32_t S6CR; // @160 stream x configuration register
	__IO uint16_t S6NDTR; // @164 stream x number of data register
	 uint8_t RESERVED12[2]; // @166 
	__IO uint32_t S6PAR; // @168 stream x peripheral address register
	__IO uint32_t S6M0AR; // @172 stream x memory 0 address register
	__IO uint32_t S6M1AR; // @176 stream x memory 1 address register
	__IO uint8_t S6FCR; // @180 stream x FIFO control register
	 uint8_t RESERVED13[3]; // @181 
	__IO uint32_t S7CR; // @184 stream x configuration register
	__IO uint16_t S7NDTR; // @188 stream x number of data register
	 uint8_t RESERVED14[2]; // @190 
	__IO uint32_t S7PAR; // @192 stream x peripheral address register
	__IO uint32_t S7M0AR; // @196 stream x memory 0 address register
	__IO uint32_t S7M1AR; // @200 stream x memory 1 address register
	__IO uint8_t S7FCR; // @204 stream x FIFO control register
};

// DMA1->LISR low interrupt status register
enum {
	DMA1_LISR_TCIF3 = 1UL<<27, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA1_LISR_HTIF3 = 1UL<<26, // Stream x half transfer interrupt flag (x=3..0)
	DMA1_LISR_TEIF3 = 1UL<<25, // Stream x transfer error interrupt flag (x=3..0)
	DMA1_LISR_DMEIF3 = 1UL<<24, // Stream x direct mode error interrupt flag (x=3..0)
	DMA1_LISR_FEIF3 = 1UL<<22, // Stream x FIFO error interrupt flag (x=3..0)
	DMA1_LISR_TCIF2 = 1UL<<21, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA1_LISR_HTIF2 = 1UL<<20, // Stream x half transfer interrupt flag (x=3..0)
	DMA1_LISR_TEIF2 = 1UL<<19, // Stream x transfer error interrupt flag (x=3..0)
	DMA1_LISR_DMEIF2 = 1UL<<18, // Stream x direct mode error interrupt flag (x=3..0)
	DMA1_LISR_FEIF2 = 1UL<<16, // Stream x FIFO error interrupt flag (x=3..0)
	DMA1_LISR_TCIF1 = 1UL<<11, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA1_LISR_HTIF1 = 1UL<<10, // Stream x half transfer interrupt flag (x=3..0)
	DMA1_LISR_TEIF1 = 1UL<<9, // Stream x transfer error interrupt flag (x=3..0)
	DMA1_LISR_DMEIF1 = 1UL<<8, // Stream x direct mode error interrupt flag (x=3..0)
	DMA1_LISR_FEIF1 = 1UL<<6, // Stream x FIFO error interrupt flag (x=3..0)
	DMA1_LISR_TCIF0 = 1UL<<5, // Stream x transfer complete interrupt flag (x = 3..0)
	DMA1_LISR_HTIF0 = 1UL<<4, // Stream x half transfer interrupt flag (x=3..0)
	DMA1_LISR_TEIF0 = 1UL<<3, // Stream x transfer error interrupt flag (x=3..0)
	DMA1_LISR_DMEIF0 = 1UL<<2, // Stream x direct mode error interrupt flag (x=3..0)
	DMA1_LISR_FEIF0 = 1UL<<0, // Stream x FIFO error interrupt flag (x=3..0)		
};

// DMA1->HISR high interrupt status register
enum {
	DMA1_HISR_TCIF7 = 1UL<<27, // Stream x transfer complete interrupt flag (x=7..4)
	DMA1_HISR_HTIF7 = 1UL<<26, // Stream x half transfer interrupt flag (x=7..4)
	DMA1_HISR_TEIF7 = 1UL<<25, // Stream x transfer error interrupt flag (x=7..4)
	DMA1_HISR_DMEIF7 = 1UL<<24, // Stream x direct mode error interrupt flag (x=7..4)
	DMA1_HISR_FEIF7 = 1UL<<22, // Stream x FIFO error interrupt flag (x=7..4)
	DMA1_HISR_TCIF6 = 1UL<<21, // Stream x transfer complete interrupt flag (x=7..4)
	DMA1_HISR_HTIF6 = 1UL<<20, // Stream x half transfer interrupt flag (x=7..4)
	DMA1_HISR_TEIF6 = 1UL<<19, // Stream x transfer error interrupt flag (x=7..4)
	DMA1_HISR_DMEIF6 = 1UL<<18, // Stream x direct mode error interrupt flag (x=7..4)
	DMA1_HISR_FEIF6 = 1UL<<16, // Stream x FIFO error interrupt flag (x=7..4)
	DMA1_HISR_TCIF5 = 1UL<<11, // Stream x transfer complete interrupt flag (x=7..4)
	DMA1_HISR_HTIF5 = 1UL<<10, // Stream x half transfer interrupt flag (x=7..4)
	DMA1_HISR_TEIF5 = 1UL<<9, // Stream x transfer error interrupt flag (x=7..4)
	DMA1_HISR_DMEIF5 = 1UL<<8, // Stream x direct mode error interrupt flag (x=7..4)
	DMA1_HISR_FEIF5 = 1UL<<6, // Stream x FIFO error interrupt flag (x=7..4)
	DMA1_HISR_TCIF4 = 1UL<<5, // Stream x transfer complete interrupt flag (x=7..4)
	DMA1_HISR_HTIF4 = 1UL<<4, // Stream x half transfer interrupt flag (x=7..4)
	DMA1_HISR_TEIF4 = 1UL<<3, // Stream x transfer error interrupt flag (x=7..4)
	DMA1_HISR_DMEIF4 = 1UL<<2, // Stream x direct mode error interrupt flag (x=7..4)
	DMA1_HISR_FEIF4 = 1UL<<0, // Stream x FIFO error interrupt flag (x=7..4)		
};

// DMA1->LIFCR low interrupt flag clear register
enum {
	DMA1_LIFCR_CTCIF3 = 1UL<<27, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA1_LIFCR_CHTIF3 = 1UL<<26, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA1_LIFCR_CTEIF3 = 1UL<<25, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA1_LIFCR_CDMEIF3 = 1UL<<24, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA1_LIFCR_CFEIF3 = 1UL<<22, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA1_LIFCR_CTCIF2 = 1UL<<21, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA1_LIFCR_CHTIF2 = 1UL<<20, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA1_LIFCR_CTEIF2 = 1UL<<19, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA1_LIFCR_CDMEIF2 = 1UL<<18, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA1_LIFCR_CFEIF2 = 1UL<<16, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA1_LIFCR_CTCIF1 = 1UL<<11, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA1_LIFCR_CHTIF1 = 1UL<<10, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA1_LIFCR_CTEIF1 = 1UL<<9, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA1_LIFCR_CDMEIF1 = 1UL<<8, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA1_LIFCR_CFEIF1 = 1UL<<6, // Stream x clear FIFO error interrupt flag (x = 3..0)
	DMA1_LIFCR_CTCIF0 = 1UL<<5, // Stream x clear transfer complete interrupt flag (x = 3..0)
	DMA1_LIFCR_CHTIF0 = 1UL<<4, // Stream x clear half transfer interrupt flag (x = 3..0)
	DMA1_LIFCR_CTEIF0 = 1UL<<3, // Stream x clear transfer error interrupt flag (x = 3..0)
	DMA1_LIFCR_CDMEIF0 = 1UL<<2, // Stream x clear direct mode error interrupt flag (x = 3..0)
	DMA1_LIFCR_CFEIF0 = 1UL<<0, // Stream x clear FIFO error interrupt flag (x = 3..0)		
};

// DMA1->HIFCR high interrupt flag clear register
enum {
	DMA1_HIFCR_CTCIF7 = 1UL<<27, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA1_HIFCR_CHTIF7 = 1UL<<26, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA1_HIFCR_CTEIF7 = 1UL<<25, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA1_HIFCR_CDMEIF7 = 1UL<<24, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA1_HIFCR_CFEIF7 = 1UL<<22, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA1_HIFCR_CTCIF6 = 1UL<<21, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA1_HIFCR_CHTIF6 = 1UL<<20, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA1_HIFCR_CTEIF6 = 1UL<<19, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA1_HIFCR_CDMEIF6 = 1UL<<18, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA1_HIFCR_CFEIF6 = 1UL<<16, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA1_HIFCR_CTCIF5 = 1UL<<11, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA1_HIFCR_CHTIF5 = 1UL<<10, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA1_HIFCR_CTEIF5 = 1UL<<9, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA1_HIFCR_CDMEIF5 = 1UL<<8, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA1_HIFCR_CFEIF5 = 1UL<<6, // Stream x clear FIFO error interrupt flag (x = 7..4)
	DMA1_HIFCR_CTCIF4 = 1UL<<5, // Stream x clear transfer complete interrupt flag (x = 7..4)
	DMA1_HIFCR_CHTIF4 = 1UL<<4, // Stream x clear half transfer interrupt flag (x = 7..4)
	DMA1_HIFCR_CTEIF4 = 1UL<<3, // Stream x clear transfer error interrupt flag (x = 7..4)
	DMA1_HIFCR_CDMEIF4 = 1UL<<2, // Stream x clear direct mode error interrupt flag (x = 7..4)
	DMA1_HIFCR_CFEIF4 = 1UL<<0, // Stream x clear FIFO error interrupt flag (x = 7..4)		
};

// DMA1->S0CR stream x configuration register
enum {
	DMA1_S0CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S0CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S0CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S0CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S0CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S0CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S0CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S0CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S0CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S0CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S0CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S0CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S0CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S0CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S0CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S0CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S0CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S0CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s0cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA1_S0CR_MBURST) | ((val<<23) & DMA1_S0CR_MBURST); }
inline void dma1_s0cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA1_S0CR_PBURST) | ((val<<21) & DMA1_S0CR_PBURST); }
inline void dma1_s0cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA1_S0CR_PL) | ((val<<16) & DMA1_S0CR_PL); }
inline void dma1_s0cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA1_S0CR_MSIZE) | ((val<<13) & DMA1_S0CR_MSIZE); }
inline void dma1_s0cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA1_S0CR_PSIZE) | ((val<<11) & DMA1_S0CR_PSIZE); }
inline void dma1_s0cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S0CR = (p->S0CR & ~DMA1_S0CR_DIR) | ((val<<6) & DMA1_S0CR_DIR); }
inline uint32_t dma1_s0cr_get_mburst(struct DMA1_Type* p) { return (p->S0CR & DMA1_S0CR_MBURST) >> 23 ; }
inline uint32_t dma1_s0cr_get_pburst(struct DMA1_Type* p) { return (p->S0CR & DMA1_S0CR_PBURST) >> 21 ; }
inline uint32_t dma1_s0cr_get_pl(struct DMA1_Type* p) { return (p->S0CR & DMA1_S0CR_PL) >> 16 ; }
inline uint32_t dma1_s0cr_get_msize(struct DMA1_Type* p) { return (p->S0CR & DMA1_S0CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s0cr_get_psize(struct DMA1_Type* p) { return (p->S0CR & DMA1_S0CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s0cr_get_dir(struct DMA1_Type* p) { return (p->S0CR & DMA1_S0CR_DIR) >> 6 ; }

// DMA1->S0FCR stream x FIFO control register
enum {
	DMA1_S0FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S0FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S0FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S0FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s0fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S0FCR = (p->S0FCR & ~DMA1_S0FCR_FS) | ((val<<3) & DMA1_S0FCR_FS); }
inline void dma1_s0fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S0FCR = (p->S0FCR & ~DMA1_S0FCR_FTH) | ((val<<0) & DMA1_S0FCR_FTH); }
inline uint32_t dma1_s0fcr_get_fs(struct DMA1_Type* p) { return (p->S0FCR & DMA1_S0FCR_FS) >> 3 ; }
inline uint32_t dma1_s0fcr_get_fth(struct DMA1_Type* p) { return (p->S0FCR & DMA1_S0FCR_FTH) >> 0 ; }

// DMA1->S1CR stream x configuration register
enum {
	DMA1_S1CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S1CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S1CR_ACK = 1UL<<20, // ACK
	DMA1_S1CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S1CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S1CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S1CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S1CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S1CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S1CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S1CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S1CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S1CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S1CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S1CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S1CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S1CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S1CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S1CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s1cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA1_S1CR_MBURST) | ((val<<23) & DMA1_S1CR_MBURST); }
inline void dma1_s1cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA1_S1CR_PBURST) | ((val<<21) & DMA1_S1CR_PBURST); }
inline void dma1_s1cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA1_S1CR_PL) | ((val<<16) & DMA1_S1CR_PL); }
inline void dma1_s1cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA1_S1CR_MSIZE) | ((val<<13) & DMA1_S1CR_MSIZE); }
inline void dma1_s1cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA1_S1CR_PSIZE) | ((val<<11) & DMA1_S1CR_PSIZE); }
inline void dma1_s1cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S1CR = (p->S1CR & ~DMA1_S1CR_DIR) | ((val<<6) & DMA1_S1CR_DIR); }
inline uint32_t dma1_s1cr_get_mburst(struct DMA1_Type* p) { return (p->S1CR & DMA1_S1CR_MBURST) >> 23 ; }
inline uint32_t dma1_s1cr_get_pburst(struct DMA1_Type* p) { return (p->S1CR & DMA1_S1CR_PBURST) >> 21 ; }
inline uint32_t dma1_s1cr_get_pl(struct DMA1_Type* p) { return (p->S1CR & DMA1_S1CR_PL) >> 16 ; }
inline uint32_t dma1_s1cr_get_msize(struct DMA1_Type* p) { return (p->S1CR & DMA1_S1CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s1cr_get_psize(struct DMA1_Type* p) { return (p->S1CR & DMA1_S1CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s1cr_get_dir(struct DMA1_Type* p) { return (p->S1CR & DMA1_S1CR_DIR) >> 6 ; }

// DMA1->S1FCR stream x FIFO control register
enum {
	DMA1_S1FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S1FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S1FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S1FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s1fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S1FCR = (p->S1FCR & ~DMA1_S1FCR_FS) | ((val<<3) & DMA1_S1FCR_FS); }
inline void dma1_s1fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S1FCR = (p->S1FCR & ~DMA1_S1FCR_FTH) | ((val<<0) & DMA1_S1FCR_FTH); }
inline uint32_t dma1_s1fcr_get_fs(struct DMA1_Type* p) { return (p->S1FCR & DMA1_S1FCR_FS) >> 3 ; }
inline uint32_t dma1_s1fcr_get_fth(struct DMA1_Type* p) { return (p->S1FCR & DMA1_S1FCR_FTH) >> 0 ; }

// DMA1->S2CR stream x configuration register
enum {
	DMA1_S2CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S2CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S2CR_ACK = 1UL<<20, // ACK
	DMA1_S2CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S2CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S2CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S2CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S2CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S2CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S2CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S2CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S2CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S2CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S2CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S2CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S2CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S2CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S2CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S2CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s2cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA1_S2CR_MBURST) | ((val<<23) & DMA1_S2CR_MBURST); }
inline void dma1_s2cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA1_S2CR_PBURST) | ((val<<21) & DMA1_S2CR_PBURST); }
inline void dma1_s2cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA1_S2CR_PL) | ((val<<16) & DMA1_S2CR_PL); }
inline void dma1_s2cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA1_S2CR_MSIZE) | ((val<<13) & DMA1_S2CR_MSIZE); }
inline void dma1_s2cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA1_S2CR_PSIZE) | ((val<<11) & DMA1_S2CR_PSIZE); }
inline void dma1_s2cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S2CR = (p->S2CR & ~DMA1_S2CR_DIR) | ((val<<6) & DMA1_S2CR_DIR); }
inline uint32_t dma1_s2cr_get_mburst(struct DMA1_Type* p) { return (p->S2CR & DMA1_S2CR_MBURST) >> 23 ; }
inline uint32_t dma1_s2cr_get_pburst(struct DMA1_Type* p) { return (p->S2CR & DMA1_S2CR_PBURST) >> 21 ; }
inline uint32_t dma1_s2cr_get_pl(struct DMA1_Type* p) { return (p->S2CR & DMA1_S2CR_PL) >> 16 ; }
inline uint32_t dma1_s2cr_get_msize(struct DMA1_Type* p) { return (p->S2CR & DMA1_S2CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s2cr_get_psize(struct DMA1_Type* p) { return (p->S2CR & DMA1_S2CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s2cr_get_dir(struct DMA1_Type* p) { return (p->S2CR & DMA1_S2CR_DIR) >> 6 ; }

// DMA1->S2FCR stream x FIFO control register
enum {
	DMA1_S2FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S2FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S2FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S2FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s2fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S2FCR = (p->S2FCR & ~DMA1_S2FCR_FS) | ((val<<3) & DMA1_S2FCR_FS); }
inline void dma1_s2fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S2FCR = (p->S2FCR & ~DMA1_S2FCR_FTH) | ((val<<0) & DMA1_S2FCR_FTH); }
inline uint32_t dma1_s2fcr_get_fs(struct DMA1_Type* p) { return (p->S2FCR & DMA1_S2FCR_FS) >> 3 ; }
inline uint32_t dma1_s2fcr_get_fth(struct DMA1_Type* p) { return (p->S2FCR & DMA1_S2FCR_FTH) >> 0 ; }

// DMA1->S3CR stream x configuration register
enum {
	DMA1_S3CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S3CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S3CR_ACK = 1UL<<20, // ACK
	DMA1_S3CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S3CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S3CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S3CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S3CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S3CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S3CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S3CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S3CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S3CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S3CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S3CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S3CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S3CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S3CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S3CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s3cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA1_S3CR_MBURST) | ((val<<23) & DMA1_S3CR_MBURST); }
inline void dma1_s3cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA1_S3CR_PBURST) | ((val<<21) & DMA1_S3CR_PBURST); }
inline void dma1_s3cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA1_S3CR_PL) | ((val<<16) & DMA1_S3CR_PL); }
inline void dma1_s3cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA1_S3CR_MSIZE) | ((val<<13) & DMA1_S3CR_MSIZE); }
inline void dma1_s3cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA1_S3CR_PSIZE) | ((val<<11) & DMA1_S3CR_PSIZE); }
inline void dma1_s3cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S3CR = (p->S3CR & ~DMA1_S3CR_DIR) | ((val<<6) & DMA1_S3CR_DIR); }
inline uint32_t dma1_s3cr_get_mburst(struct DMA1_Type* p) { return (p->S3CR & DMA1_S3CR_MBURST) >> 23 ; }
inline uint32_t dma1_s3cr_get_pburst(struct DMA1_Type* p) { return (p->S3CR & DMA1_S3CR_PBURST) >> 21 ; }
inline uint32_t dma1_s3cr_get_pl(struct DMA1_Type* p) { return (p->S3CR & DMA1_S3CR_PL) >> 16 ; }
inline uint32_t dma1_s3cr_get_msize(struct DMA1_Type* p) { return (p->S3CR & DMA1_S3CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s3cr_get_psize(struct DMA1_Type* p) { return (p->S3CR & DMA1_S3CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s3cr_get_dir(struct DMA1_Type* p) { return (p->S3CR & DMA1_S3CR_DIR) >> 6 ; }

// DMA1->S3FCR stream x FIFO control register
enum {
	DMA1_S3FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S3FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S3FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S3FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s3fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S3FCR = (p->S3FCR & ~DMA1_S3FCR_FS) | ((val<<3) & DMA1_S3FCR_FS); }
inline void dma1_s3fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S3FCR = (p->S3FCR & ~DMA1_S3FCR_FTH) | ((val<<0) & DMA1_S3FCR_FTH); }
inline uint32_t dma1_s3fcr_get_fs(struct DMA1_Type* p) { return (p->S3FCR & DMA1_S3FCR_FS) >> 3 ; }
inline uint32_t dma1_s3fcr_get_fth(struct DMA1_Type* p) { return (p->S3FCR & DMA1_S3FCR_FTH) >> 0 ; }

// DMA1->S4CR stream x configuration register
enum {
	DMA1_S4CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S4CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S4CR_ACK = 1UL<<20, // ACK
	DMA1_S4CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S4CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S4CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S4CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S4CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S4CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S4CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S4CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S4CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S4CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S4CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S4CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S4CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S4CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S4CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S4CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s4cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA1_S4CR_MBURST) | ((val<<23) & DMA1_S4CR_MBURST); }
inline void dma1_s4cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA1_S4CR_PBURST) | ((val<<21) & DMA1_S4CR_PBURST); }
inline void dma1_s4cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA1_S4CR_PL) | ((val<<16) & DMA1_S4CR_PL); }
inline void dma1_s4cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA1_S4CR_MSIZE) | ((val<<13) & DMA1_S4CR_MSIZE); }
inline void dma1_s4cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA1_S4CR_PSIZE) | ((val<<11) & DMA1_S4CR_PSIZE); }
inline void dma1_s4cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S4CR = (p->S4CR & ~DMA1_S4CR_DIR) | ((val<<6) & DMA1_S4CR_DIR); }
inline uint32_t dma1_s4cr_get_mburst(struct DMA1_Type* p) { return (p->S4CR & DMA1_S4CR_MBURST) >> 23 ; }
inline uint32_t dma1_s4cr_get_pburst(struct DMA1_Type* p) { return (p->S4CR & DMA1_S4CR_PBURST) >> 21 ; }
inline uint32_t dma1_s4cr_get_pl(struct DMA1_Type* p) { return (p->S4CR & DMA1_S4CR_PL) >> 16 ; }
inline uint32_t dma1_s4cr_get_msize(struct DMA1_Type* p) { return (p->S4CR & DMA1_S4CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s4cr_get_psize(struct DMA1_Type* p) { return (p->S4CR & DMA1_S4CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s4cr_get_dir(struct DMA1_Type* p) { return (p->S4CR & DMA1_S4CR_DIR) >> 6 ; }

// DMA1->S4FCR stream x FIFO control register
enum {
	DMA1_S4FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S4FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S4FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S4FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s4fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S4FCR = (p->S4FCR & ~DMA1_S4FCR_FS) | ((val<<3) & DMA1_S4FCR_FS); }
inline void dma1_s4fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S4FCR = (p->S4FCR & ~DMA1_S4FCR_FTH) | ((val<<0) & DMA1_S4FCR_FTH); }
inline uint32_t dma1_s4fcr_get_fs(struct DMA1_Type* p) { return (p->S4FCR & DMA1_S4FCR_FS) >> 3 ; }
inline uint32_t dma1_s4fcr_get_fth(struct DMA1_Type* p) { return (p->S4FCR & DMA1_S4FCR_FTH) >> 0 ; }

// DMA1->S5CR stream x configuration register
enum {
	DMA1_S5CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S5CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S5CR_ACK = 1UL<<20, // ACK
	DMA1_S5CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S5CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S5CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S5CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S5CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S5CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S5CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S5CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S5CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S5CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S5CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S5CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S5CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S5CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S5CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S5CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s5cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA1_S5CR_MBURST) | ((val<<23) & DMA1_S5CR_MBURST); }
inline void dma1_s5cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA1_S5CR_PBURST) | ((val<<21) & DMA1_S5CR_PBURST); }
inline void dma1_s5cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA1_S5CR_PL) | ((val<<16) & DMA1_S5CR_PL); }
inline void dma1_s5cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA1_S5CR_MSIZE) | ((val<<13) & DMA1_S5CR_MSIZE); }
inline void dma1_s5cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA1_S5CR_PSIZE) | ((val<<11) & DMA1_S5CR_PSIZE); }
inline void dma1_s5cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S5CR = (p->S5CR & ~DMA1_S5CR_DIR) | ((val<<6) & DMA1_S5CR_DIR); }
inline uint32_t dma1_s5cr_get_mburst(struct DMA1_Type* p) { return (p->S5CR & DMA1_S5CR_MBURST) >> 23 ; }
inline uint32_t dma1_s5cr_get_pburst(struct DMA1_Type* p) { return (p->S5CR & DMA1_S5CR_PBURST) >> 21 ; }
inline uint32_t dma1_s5cr_get_pl(struct DMA1_Type* p) { return (p->S5CR & DMA1_S5CR_PL) >> 16 ; }
inline uint32_t dma1_s5cr_get_msize(struct DMA1_Type* p) { return (p->S5CR & DMA1_S5CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s5cr_get_psize(struct DMA1_Type* p) { return (p->S5CR & DMA1_S5CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s5cr_get_dir(struct DMA1_Type* p) { return (p->S5CR & DMA1_S5CR_DIR) >> 6 ; }

// DMA1->S5FCR stream x FIFO control register
enum {
	DMA1_S5FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S5FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S5FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S5FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s5fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S5FCR = (p->S5FCR & ~DMA1_S5FCR_FS) | ((val<<3) & DMA1_S5FCR_FS); }
inline void dma1_s5fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S5FCR = (p->S5FCR & ~DMA1_S5FCR_FTH) | ((val<<0) & DMA1_S5FCR_FTH); }
inline uint32_t dma1_s5fcr_get_fs(struct DMA1_Type* p) { return (p->S5FCR & DMA1_S5FCR_FS) >> 3 ; }
inline uint32_t dma1_s5fcr_get_fth(struct DMA1_Type* p) { return (p->S5FCR & DMA1_S5FCR_FTH) >> 0 ; }

// DMA1->S6CR stream x configuration register
enum {
	DMA1_S6CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S6CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S6CR_ACK = 1UL<<20, // ACK
	DMA1_S6CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S6CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S6CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S6CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S6CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S6CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S6CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S6CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S6CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S6CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S6CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S6CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S6CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S6CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S6CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S6CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s6cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA1_S6CR_MBURST) | ((val<<23) & DMA1_S6CR_MBURST); }
inline void dma1_s6cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA1_S6CR_PBURST) | ((val<<21) & DMA1_S6CR_PBURST); }
inline void dma1_s6cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA1_S6CR_PL) | ((val<<16) & DMA1_S6CR_PL); }
inline void dma1_s6cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA1_S6CR_MSIZE) | ((val<<13) & DMA1_S6CR_MSIZE); }
inline void dma1_s6cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA1_S6CR_PSIZE) | ((val<<11) & DMA1_S6CR_PSIZE); }
inline void dma1_s6cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S6CR = (p->S6CR & ~DMA1_S6CR_DIR) | ((val<<6) & DMA1_S6CR_DIR); }
inline uint32_t dma1_s6cr_get_mburst(struct DMA1_Type* p) { return (p->S6CR & DMA1_S6CR_MBURST) >> 23 ; }
inline uint32_t dma1_s6cr_get_pburst(struct DMA1_Type* p) { return (p->S6CR & DMA1_S6CR_PBURST) >> 21 ; }
inline uint32_t dma1_s6cr_get_pl(struct DMA1_Type* p) { return (p->S6CR & DMA1_S6CR_PL) >> 16 ; }
inline uint32_t dma1_s6cr_get_msize(struct DMA1_Type* p) { return (p->S6CR & DMA1_S6CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s6cr_get_psize(struct DMA1_Type* p) { return (p->S6CR & DMA1_S6CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s6cr_get_dir(struct DMA1_Type* p) { return (p->S6CR & DMA1_S6CR_DIR) >> 6 ; }

// DMA1->S6FCR stream x FIFO control register
enum {
	DMA1_S6FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S6FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S6FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S6FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s6fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S6FCR = (p->S6FCR & ~DMA1_S6FCR_FS) | ((val<<3) & DMA1_S6FCR_FS); }
inline void dma1_s6fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S6FCR = (p->S6FCR & ~DMA1_S6FCR_FTH) | ((val<<0) & DMA1_S6FCR_FTH); }
inline uint32_t dma1_s6fcr_get_fs(struct DMA1_Type* p) { return (p->S6FCR & DMA1_S6FCR_FS) >> 3 ; }
inline uint32_t dma1_s6fcr_get_fth(struct DMA1_Type* p) { return (p->S6FCR & DMA1_S6FCR_FTH) >> 0 ; }

// DMA1->S7CR stream x configuration register
enum {
	DMA1_S7CR_MBURST = ((1UL<<2)-1) << 23, // Memory burst transfer configuration
	DMA1_S7CR_PBURST = ((1UL<<2)-1) << 21, // Peripheral burst transfer configuration
	DMA1_S7CR_ACK = 1UL<<20, // ACK
	DMA1_S7CR_CT = 1UL<<19, // Current target (only in double buffer mode)
	DMA1_S7CR_DBM = 1UL<<18, // Double buffer mode
	DMA1_S7CR_PL = ((1UL<<2)-1) << 16, // Priority level
	DMA1_S7CR_PINCOS = 1UL<<15, // Peripheral increment offset size
	DMA1_S7CR_MSIZE = ((1UL<<2)-1) << 13, // Memory data size
	DMA1_S7CR_PSIZE = ((1UL<<2)-1) << 11, // Peripheral data size
	DMA1_S7CR_MINC = 1UL<<10, // Memory increment mode
	DMA1_S7CR_PINC = 1UL<<9, // Peripheral increment mode
	DMA1_S7CR_CIRC = 1UL<<8, // Circular mode
	DMA1_S7CR_DIR = ((1UL<<2)-1) << 6, // Data transfer direction
	DMA1_S7CR_PFCTRL = 1UL<<5, // Peripheral flow controller
	DMA1_S7CR_TCIE = 1UL<<4, // Transfer complete interrupt enable
	DMA1_S7CR_HTIE = 1UL<<3, // Half transfer interrupt enable
	DMA1_S7CR_TEIE = 1UL<<2, // Transfer error interrupt enable
	DMA1_S7CR_DMEIE = 1UL<<1, // Direct mode error interrupt enable
	DMA1_S7CR_EN = 1UL<<0, // Stream enable / flag stream ready when read low		
};
inline void dma1_s7cr_set_mburst(struct DMA1_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA1_S7CR_MBURST) | ((val<<23) & DMA1_S7CR_MBURST); }
inline void dma1_s7cr_set_pburst(struct DMA1_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA1_S7CR_PBURST) | ((val<<21) & DMA1_S7CR_PBURST); }
inline void dma1_s7cr_set_pl(struct DMA1_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA1_S7CR_PL) | ((val<<16) & DMA1_S7CR_PL); }
inline void dma1_s7cr_set_msize(struct DMA1_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA1_S7CR_MSIZE) | ((val<<13) & DMA1_S7CR_MSIZE); }
inline void dma1_s7cr_set_psize(struct DMA1_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA1_S7CR_PSIZE) | ((val<<11) & DMA1_S7CR_PSIZE); }
inline void dma1_s7cr_set_dir(struct DMA1_Type* p, uint32_t val) { p->S7CR = (p->S7CR & ~DMA1_S7CR_DIR) | ((val<<6) & DMA1_S7CR_DIR); }
inline uint32_t dma1_s7cr_get_mburst(struct DMA1_Type* p) { return (p->S7CR & DMA1_S7CR_MBURST) >> 23 ; }
inline uint32_t dma1_s7cr_get_pburst(struct DMA1_Type* p) { return (p->S7CR & DMA1_S7CR_PBURST) >> 21 ; }
inline uint32_t dma1_s7cr_get_pl(struct DMA1_Type* p) { return (p->S7CR & DMA1_S7CR_PL) >> 16 ; }
inline uint32_t dma1_s7cr_get_msize(struct DMA1_Type* p) { return (p->S7CR & DMA1_S7CR_MSIZE) >> 13 ; }
inline uint32_t dma1_s7cr_get_psize(struct DMA1_Type* p) { return (p->S7CR & DMA1_S7CR_PSIZE) >> 11 ; }
inline uint32_t dma1_s7cr_get_dir(struct DMA1_Type* p) { return (p->S7CR & DMA1_S7CR_DIR) >> 6 ; }

// DMA1->S7FCR stream x FIFO control register
enum {
	DMA1_S7FCR_FEIE = 1UL<<7, // FIFO error interrupt enable
	DMA1_S7FCR_FS = ((1UL<<3)-1) << 3, // FIFO status
	DMA1_S7FCR_DMDIS = 1UL<<2, // Direct mode disable
	DMA1_S7FCR_FTH = ((1UL<<2)-1) << 0, // FIFO threshold selection		
};
inline void dma1_s7fcr_set_fs(struct DMA1_Type* p, uint32_t val) { p->S7FCR = (p->S7FCR & ~DMA1_S7FCR_FS) | ((val<<3) & DMA1_S7FCR_FS); }
inline void dma1_s7fcr_set_fth(struct DMA1_Type* p, uint32_t val) { p->S7FCR = (p->S7FCR & ~DMA1_S7FCR_FTH) | ((val<<0) & DMA1_S7FCR_FTH); }
inline uint32_t dma1_s7fcr_get_fs(struct DMA1_Type* p) { return (p->S7FCR & DMA1_S7FCR_FS) >> 3 ; }
inline uint32_t dma1_s7fcr_get_fth(struct DMA1_Type* p) { return (p->S7FCR & DMA1_S7FCR_FTH) >> 0 ; }


/* DMA2D */
struct DMA2D_Type {
	__IO uint32_t CR; // @0 DMA2D control register
	__I uint8_t ISR; // @4 DMA2D Interrupt Status Register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t IFCR; // @8 DMA2D interrupt flag clear register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t FGMAR; // @12 DMA2D foreground memory address register
	__IO uint16_t FGOR; // @16 DMA2D foreground offset register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint32_t BGMAR; // @20 DMA2D background memory address register
	__IO uint16_t BGOR; // @24 DMA2D background offset register
	 uint8_t RESERVED3[2]; // @26 
	__IO uint32_t FGPFCCR; // @28 DMA2D foreground PFC control register
	__IO uint32_t FGCOLR; // @32 DMA2D foreground color register
	__IO uint32_t BGPFCCR; // @36 DMA2D background PFC control register
	__IO uint32_t BGCOLR; // @40 DMA2D background color register
	__IO uint32_t FGCMAR; // @44 DMA2D foreground CLUT memory address register
	__IO uint32_t BGCMAR; // @48 DMA2D background CLUT memory address register
	__IO uint32_t OPFCCR; // @52 DMA2D output PFC control register
	__IO uint32_t OCOLR; // @56 DMA2D output color register
	__IO uint32_t OMAR; // @60 DMA2D output memory address register
	__IO uint16_t OOR; // @64 DMA2D output offset register
	 uint8_t RESERVED4[2]; // @66 
	__IO uint32_t NLR; // @68 DMA2D number of line register
	__IO uint16_t LWR; // @72 DMA2D line watermark register
	 uint8_t RESERVED5[2]; // @74 
	__IO uint16_t AMTCR; // @76 DMA2D AXI master timer configuration register
};

// DMA2D->CR DMA2D control register
enum {
	DMA2D_CR_MODE = ((1UL<<2)-1) << 16, // DMA2D mode This bit is set and cleared by software. It cannot be modified while a transfer is ongoing.
	DMA2D_CR_CEIE = 1UL<<13, // Configuration Error Interrupt Enable This bit is set and cleared by software.
	DMA2D_CR_CTCIE = 1UL<<12, // CLUT transfer complete interrupt enable This bit is set and cleared by software.
	DMA2D_CR_CAEIE = 1UL<<11, // CLUT access error interrupt enable This bit is set and cleared by software.
	DMA2D_CR_TWIE = 1UL<<10, // Transfer watermark interrupt enable This bit is set and cleared by software.
	DMA2D_CR_TCIE = 1UL<<9, // Transfer complete interrupt enable This bit is set and cleared by software.
	DMA2D_CR_TEIE = 1UL<<8, // Transfer error interrupt enable This bit is set and cleared by software.
	DMA2D_CR_ABORT = 1UL<<2, // Abort This bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset.
	DMA2D_CR_SUSP = 1UL<<1, // Suspend This bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset.
	DMA2D_CR_START = 1UL<<0, // Start This bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers		
};
inline void dma2d_cr_set_mode(struct DMA2D_Type* p, uint32_t val) { p->CR = (p->CR & ~DMA2D_CR_MODE) | ((val<<16) & DMA2D_CR_MODE); }
inline uint32_t dma2d_cr_get_mode(struct DMA2D_Type* p) { return (p->CR & DMA2D_CR_MODE) >> 16 ; }

// DMA2D->ISR DMA2D Interrupt Status Register
enum {
	DMA2D_ISR_CEIF = 1UL<<5, // Configuration error interrupt flag This bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed.
	DMA2D_ISR_CTCIF = 1UL<<4, // CLUT transfer complete interrupt flag This bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete.
	DMA2D_ISR_CAEIF = 1UL<<3, // CLUT access error interrupt flag This bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D.
	DMA2D_ISR_TWIF = 1UL<<2, // Transfer watermark interrupt flag This bit is set when the last pixel of the watermarked line has been transferred.
	DMA2D_ISR_TCIF = 1UL<<1, // Transfer complete interrupt flag This bit is set when a DMA2D transfer operation is complete (data transfer only).
	DMA2D_ISR_TEIF = 1UL<<0, // Transfer error interrupt flag This bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading).		
};

// DMA2D->IFCR DMA2D interrupt flag clear register
enum {
	DMA2D_IFCR_CCEIF = 1UL<<5, // Clear configuration error interrupt flag Programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register
	DMA2D_IFCR_CCTCIF = 1UL<<4, // Clear CLUT transfer complete interrupt flag Programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register
	DMA2D_IFCR_CAECIF = 1UL<<3, // Clear CLUT access error interrupt flag Programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register
	DMA2D_IFCR_CTWIF = 1UL<<2, // Clear transfer watermark interrupt flag Programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register
	DMA2D_IFCR_CTCIF = 1UL<<1, // Clear transfer complete interrupt flag Programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register
	DMA2D_IFCR_CTEIF = 1UL<<0, // Clear Transfer error interrupt flag Programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register		
};

// DMA2D->FGOR DMA2D foreground offset register
enum {
	DMA2D_FGOR_LO = ((1UL<<14)-1) << 0, // Line offset Line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.		
};
inline void dma2d_fgor_set_lo(struct DMA2D_Type* p, uint32_t val) { p->FGOR = (p->FGOR & ~DMA2D_FGOR_LO) | ((val<<0) & DMA2D_FGOR_LO); }
inline uint32_t dma2d_fgor_get_lo(struct DMA2D_Type* p) { return (p->FGOR & DMA2D_FGOR_LO) >> 0 ; }

// DMA2D->BGOR DMA2D background offset register
enum {
	DMA2D_BGOR_LO = ((1UL<<14)-1) << 0, // Line offset Line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.		
};
inline void dma2d_bgor_set_lo(struct DMA2D_Type* p, uint32_t val) { p->BGOR = (p->BGOR & ~DMA2D_BGOR_LO) | ((val<<0) & DMA2D_BGOR_LO); }
inline uint32_t dma2d_bgor_get_lo(struct DMA2D_Type* p) { return (p->BGOR & DMA2D_BGOR_LO) >> 0 ; }

// DMA2D->FGPFCCR DMA2D foreground PFC control register
enum {
	DMA2D_FGPFCCR_ALPHA = ((1UL<<8)-1) << 24, // Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only.
	DMA2D_FGPFCCR_RBS = 1UL<<21, // Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
	DMA2D_FGPFCCR_AI = 1UL<<20, // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
	DMA2D_FGPFCCR_CSS = ((1UL<<2)-1) << 18, // Chroma Sub-Sampling These bits define the chroma sub-sampling mode for YCbCr color mode. Once the transfer has started, these bits are read-only. others: meaningless
	DMA2D_FGPFCCR_AM = ((1UL<<2)-1) << 16, // Alpha mode These bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. other configurations are meaningless
	DMA2D_FGPFCCR_CS = ((1UL<<8)-1) << 8, // CLUT size These bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
	DMA2D_FGPFCCR_START = 1UL<<5, // Start This bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer).
	DMA2D_FGPFCCR_CCM = 1UL<<4, // CLUT color mode This bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
	DMA2D_FGPFCCR_CM = ((1UL<<4)-1) << 0, // Color mode These bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless		
};
inline void dma2d_fgpfccr_set_alpha(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_ALPHA) | ((val<<24) & DMA2D_FGPFCCR_ALPHA); }
inline void dma2d_fgpfccr_set_css(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_CSS) | ((val<<18) & DMA2D_FGPFCCR_CSS); }
inline void dma2d_fgpfccr_set_am(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_AM) | ((val<<16) & DMA2D_FGPFCCR_AM); }
inline void dma2d_fgpfccr_set_cs(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_CS) | ((val<<8) & DMA2D_FGPFCCR_CS); }
inline void dma2d_fgpfccr_set_cm(struct DMA2D_Type* p, uint32_t val) { p->FGPFCCR = (p->FGPFCCR & ~DMA2D_FGPFCCR_CM) | ((val<<0) & DMA2D_FGPFCCR_CM); }
inline uint32_t dma2d_fgpfccr_get_alpha(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_ALPHA) >> 24 ; }
inline uint32_t dma2d_fgpfccr_get_css(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_CSS) >> 18 ; }
inline uint32_t dma2d_fgpfccr_get_am(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_AM) >> 16 ; }
inline uint32_t dma2d_fgpfccr_get_cs(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_CS) >> 8 ; }
inline uint32_t dma2d_fgpfccr_get_cm(struct DMA2D_Type* p) { return (p->FGPFCCR & DMA2D_FGPFCCR_CM) >> 0 ; }

// DMA2D->FGCOLR DMA2D foreground color register
enum {
	DMA2D_FGCOLR_RED = ((1UL<<8)-1) << 16, // Red Value These bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_FGCOLR_GREEN = ((1UL<<8)-1) << 8, // Green Value These bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
	DMA2D_FGCOLR_BLUE = ((1UL<<8)-1) << 0, // Blue Value These bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.		
};
inline void dma2d_fgcolr_set_red(struct DMA2D_Type* p, uint32_t val) { p->FGCOLR = (p->FGCOLR & ~DMA2D_FGCOLR_RED) | ((val<<16) & DMA2D_FGCOLR_RED); }
inline void dma2d_fgcolr_set_green(struct DMA2D_Type* p, uint32_t val) { p->FGCOLR = (p->FGCOLR & ~DMA2D_FGCOLR_GREEN) | ((val<<8) & DMA2D_FGCOLR_GREEN); }
inline void dma2d_fgcolr_set_blue(struct DMA2D_Type* p, uint32_t val) { p->FGCOLR = (p->FGCOLR & ~DMA2D_FGCOLR_BLUE) | ((val<<0) & DMA2D_FGCOLR_BLUE); }
inline uint32_t dma2d_fgcolr_get_red(struct DMA2D_Type* p) { return (p->FGCOLR & DMA2D_FGCOLR_RED) >> 16 ; }
inline uint32_t dma2d_fgcolr_get_green(struct DMA2D_Type* p) { return (p->FGCOLR & DMA2D_FGCOLR_GREEN) >> 8 ; }
inline uint32_t dma2d_fgcolr_get_blue(struct DMA2D_Type* p) { return (p->FGCOLR & DMA2D_FGCOLR_BLUE) >> 0 ; }

// DMA2D->BGPFCCR DMA2D background PFC control register
enum {
	DMA2D_BGPFCCR_ALPHA = ((1UL<<8)-1) << 24, // Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_BGPFCCR_RBS = 1UL<<21, // Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
	DMA2D_BGPFCCR_AI = 1UL<<20, // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
	DMA2D_BGPFCCR_AM = ((1UL<<2)-1) << 16, // Alpha mode These bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
	DMA2D_BGPFCCR_CS = ((1UL<<8)-1) << 8, // CLUT size These bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
	DMA2D_BGPFCCR_START = 1UL<<5, // Start This bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic BackGround CLUT transfer).
	DMA2D_BGPFCCR_CCM = 1UL<<4, // CLUT Color mode These bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
	DMA2D_BGPFCCR_CM = ((1UL<<4)-1) << 0, // Color mode These bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless		
};
inline void dma2d_bgpfccr_set_alpha(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_ALPHA) | ((val<<24) & DMA2D_BGPFCCR_ALPHA); }
inline void dma2d_bgpfccr_set_am(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_AM) | ((val<<16) & DMA2D_BGPFCCR_AM); }
inline void dma2d_bgpfccr_set_cs(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_CS) | ((val<<8) & DMA2D_BGPFCCR_CS); }
inline void dma2d_bgpfccr_set_cm(struct DMA2D_Type* p, uint32_t val) { p->BGPFCCR = (p->BGPFCCR & ~DMA2D_BGPFCCR_CM) | ((val<<0) & DMA2D_BGPFCCR_CM); }
inline uint32_t dma2d_bgpfccr_get_alpha(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_ALPHA) >> 24 ; }
inline uint32_t dma2d_bgpfccr_get_am(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_AM) >> 16 ; }
inline uint32_t dma2d_bgpfccr_get_cs(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_CS) >> 8 ; }
inline uint32_t dma2d_bgpfccr_get_cm(struct DMA2D_Type* p) { return (p->BGPFCCR & DMA2D_BGPFCCR_CM) >> 0 ; }

// DMA2D->BGCOLR DMA2D background color register
enum {
	DMA2D_BGCOLR_RED = ((1UL<<8)-1) << 16, // Red Value These bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_BGCOLR_GREEN = ((1UL<<8)-1) << 8, // Green Value These bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_BGCOLR_BLUE = ((1UL<<8)-1) << 0, // Blue Value These bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.		
};
inline void dma2d_bgcolr_set_red(struct DMA2D_Type* p, uint32_t val) { p->BGCOLR = (p->BGCOLR & ~DMA2D_BGCOLR_RED) | ((val<<16) & DMA2D_BGCOLR_RED); }
inline void dma2d_bgcolr_set_green(struct DMA2D_Type* p, uint32_t val) { p->BGCOLR = (p->BGCOLR & ~DMA2D_BGCOLR_GREEN) | ((val<<8) & DMA2D_BGCOLR_GREEN); }
inline void dma2d_bgcolr_set_blue(struct DMA2D_Type* p, uint32_t val) { p->BGCOLR = (p->BGCOLR & ~DMA2D_BGCOLR_BLUE) | ((val<<0) & DMA2D_BGCOLR_BLUE); }
inline uint32_t dma2d_bgcolr_get_red(struct DMA2D_Type* p) { return (p->BGCOLR & DMA2D_BGCOLR_RED) >> 16 ; }
inline uint32_t dma2d_bgcolr_get_green(struct DMA2D_Type* p) { return (p->BGCOLR & DMA2D_BGCOLR_GREEN) >> 8 ; }
inline uint32_t dma2d_bgcolr_get_blue(struct DMA2D_Type* p) { return (p->BGCOLR & DMA2D_BGCOLR_BLUE) >> 0 ; }

// DMA2D->OPFCCR DMA2D output PFC control register
enum {
	DMA2D_OPFCCR_RBS = 1UL<<21, // Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
	DMA2D_OPFCCR_AI = 1UL<<20, // Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
	DMA2D_OPFCCR_CM = ((1UL<<3)-1) << 0, // Color mode These bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless		
};
inline void dma2d_opfccr_set_cm(struct DMA2D_Type* p, uint32_t val) { p->OPFCCR = (p->OPFCCR & ~DMA2D_OPFCCR_CM) | ((val<<0) & DMA2D_OPFCCR_CM); }
inline uint32_t dma2d_opfccr_get_cm(struct DMA2D_Type* p) { return (p->OPFCCR & DMA2D_OPFCCR_CM) >> 0 ; }

// DMA2D->OCOLR DMA2D output color register
enum {
	DMA2D_OCOLR_ALPHA = ((1UL<<8)-1) << 24, // Alpha Channel Value These bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_OCOLR_RED = ((1UL<<8)-1) << 16, // Red Value These bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_OCOLR_GREEN = ((1UL<<8)-1) << 8, // Green Value These bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
	DMA2D_OCOLR_BLUE = ((1UL<<8)-1) << 0, // Blue Value These bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.		
};
inline void dma2d_ocolr_set_alpha(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_ALPHA) | ((val<<24) & DMA2D_OCOLR_ALPHA); }
inline void dma2d_ocolr_set_red(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_RED) | ((val<<16) & DMA2D_OCOLR_RED); }
inline void dma2d_ocolr_set_green(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_GREEN) | ((val<<8) & DMA2D_OCOLR_GREEN); }
inline void dma2d_ocolr_set_blue(struct DMA2D_Type* p, uint32_t val) { p->OCOLR = (p->OCOLR & ~DMA2D_OCOLR_BLUE) | ((val<<0) & DMA2D_OCOLR_BLUE); }
inline uint32_t dma2d_ocolr_get_alpha(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_ALPHA) >> 24 ; }
inline uint32_t dma2d_ocolr_get_red(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_RED) >> 16 ; }
inline uint32_t dma2d_ocolr_get_green(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_GREEN) >> 8 ; }
inline uint32_t dma2d_ocolr_get_blue(struct DMA2D_Type* p) { return (p->OCOLR & DMA2D_OCOLR_BLUE) >> 0 ; }

// DMA2D->OOR DMA2D output offset register
enum {
	DMA2D_OOR_LO = ((1UL<<14)-1) << 0, // Line Offset Line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.		
};
inline void dma2d_oor_set_lo(struct DMA2D_Type* p, uint32_t val) { p->OOR = (p->OOR & ~DMA2D_OOR_LO) | ((val<<0) & DMA2D_OOR_LO); }
inline uint32_t dma2d_oor_get_lo(struct DMA2D_Type* p) { return (p->OOR & DMA2D_OOR_LO) >> 0 ; }

// DMA2D->NLR DMA2D number of line register
enum {
	DMA2D_NLR_PL = ((1UL<<14)-1) << 16, // Pixel per lines Number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even.
	DMA2D_NLR_NL = ((1UL<<16)-1) << 0, // Number of lines Number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.		
};
inline void dma2d_nlr_set_pl(struct DMA2D_Type* p, uint32_t val) { p->NLR = (p->NLR & ~DMA2D_NLR_PL) | ((val<<16) & DMA2D_NLR_PL); }
inline void dma2d_nlr_set_nl(struct DMA2D_Type* p, uint32_t val) { p->NLR = (p->NLR & ~DMA2D_NLR_NL) | ((val<<0) & DMA2D_NLR_NL); }
inline uint32_t dma2d_nlr_get_pl(struct DMA2D_Type* p) { return (p->NLR & DMA2D_NLR_PL) >> 16 ; }
inline uint32_t dma2d_nlr_get_nl(struct DMA2D_Type* p) { return (p->NLR & DMA2D_NLR_NL) >> 0 ; }

// DMA2D->AMTCR DMA2D AXI master timer configuration register
enum {
	DMA2D_AMTCR_DT = ((1UL<<8)-1) << 8, // Dead Time Dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses.
	DMA2D_AMTCR_EN = 1UL<<0, // Enable Enables the dead time functionality.		
};
inline void dma2d_amtcr_set_dt(struct DMA2D_Type* p, uint32_t val) { p->AMTCR = (p->AMTCR & ~DMA2D_AMTCR_DT) | ((val<<8) & DMA2D_AMTCR_DT); }
inline uint32_t dma2d_amtcr_get_dt(struct DMA2D_Type* p) { return (p->AMTCR & DMA2D_AMTCR_DT) >> 8 ; }

/* DMAMUX */
struct DMAMUX1_Type {
	__IO uint32_t C0CR; // @0 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C1CR; // @4 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C2CR; // @8 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C3CR; // @12 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C4CR; // @16 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C5CR; // @20 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C6CR; // @24 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C7CR; // @28 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C8CR; // @32 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C9CR; // @36 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C10CR; // @40 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C11CR; // @44 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C12CR; // @48 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C13CR; // @52 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C14CR; // @56 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C15CR; // @60 DMAMux - DMA request line multiplexer channel x control register
	 uint8_t RESERVED0[64]; // @64 
	__I uint16_t CSR; // @128 DMAMUX request line multiplexer interrupt channel status register
	 uint8_t RESERVED1[2]; // @130 
	__O uint16_t CFR; // @132 DMAMUX request line multiplexer interrupt clear flag register
	 uint8_t RESERVED2[122]; // @134 
	__IO uint32_t RG0CR; // @256 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG1CR; // @260 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG2CR; // @264 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG3CR; // @268 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG4CR; // @272 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG5CR; // @276 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG6CR; // @280 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG7CR; // @284 DMAMux - DMA request generator channel x control register
	 uint8_t RESERVED3[32]; // @288 
	__I uint8_t RGSR; // @320 DMAMux - DMA request generator status register
	 uint8_t RESERVED4[3]; // @321 
	__O uint8_t RGCFR; // @324 DMAMux - DMA request generator clear flag register
};

// DMAMUX1->C0CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C0CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C0CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C0CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C0CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C0CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C0CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C0CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c0cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX1_C0CR_SYNC_ID) | ((val<<24) & DMAMUX1_C0CR_SYNC_ID); }
inline void dmamux1_c0cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX1_C0CR_NBREQ) | ((val<<19) & DMAMUX1_C0CR_NBREQ); }
inline void dmamux1_c0cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX1_C0CR_SPOL) | ((val<<17) & DMAMUX1_C0CR_SPOL); }
inline void dmamux1_c0cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX1_C0CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C0CR_DMAREQ_ID); }
inline uint32_t dmamux1_c0cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C0CR & DMAMUX1_C0CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c0cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C0CR & DMAMUX1_C0CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c0cr_get_spol(struct DMAMUX1_Type* p) { return (p->C0CR & DMAMUX1_C0CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c0cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C0CR & DMAMUX1_C0CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C1CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C1CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C1CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C1CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C1CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C1CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C1CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C1CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c1cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX1_C1CR_SYNC_ID) | ((val<<24) & DMAMUX1_C1CR_SYNC_ID); }
inline void dmamux1_c1cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX1_C1CR_NBREQ) | ((val<<19) & DMAMUX1_C1CR_NBREQ); }
inline void dmamux1_c1cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX1_C1CR_SPOL) | ((val<<17) & DMAMUX1_C1CR_SPOL); }
inline void dmamux1_c1cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX1_C1CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C1CR_DMAREQ_ID); }
inline uint32_t dmamux1_c1cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C1CR & DMAMUX1_C1CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c1cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C1CR & DMAMUX1_C1CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c1cr_get_spol(struct DMAMUX1_Type* p) { return (p->C1CR & DMAMUX1_C1CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c1cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C1CR & DMAMUX1_C1CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C2CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C2CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C2CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C2CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C2CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C2CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C2CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C2CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c2cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX1_C2CR_SYNC_ID) | ((val<<24) & DMAMUX1_C2CR_SYNC_ID); }
inline void dmamux1_c2cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX1_C2CR_NBREQ) | ((val<<19) & DMAMUX1_C2CR_NBREQ); }
inline void dmamux1_c2cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX1_C2CR_SPOL) | ((val<<17) & DMAMUX1_C2CR_SPOL); }
inline void dmamux1_c2cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX1_C2CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C2CR_DMAREQ_ID); }
inline uint32_t dmamux1_c2cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C2CR & DMAMUX1_C2CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c2cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C2CR & DMAMUX1_C2CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c2cr_get_spol(struct DMAMUX1_Type* p) { return (p->C2CR & DMAMUX1_C2CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c2cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C2CR & DMAMUX1_C2CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C3CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C3CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C3CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C3CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C3CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C3CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C3CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C3CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c3cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX1_C3CR_SYNC_ID) | ((val<<24) & DMAMUX1_C3CR_SYNC_ID); }
inline void dmamux1_c3cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX1_C3CR_NBREQ) | ((val<<19) & DMAMUX1_C3CR_NBREQ); }
inline void dmamux1_c3cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX1_C3CR_SPOL) | ((val<<17) & DMAMUX1_C3CR_SPOL); }
inline void dmamux1_c3cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX1_C3CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C3CR_DMAREQ_ID); }
inline uint32_t dmamux1_c3cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C3CR & DMAMUX1_C3CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c3cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C3CR & DMAMUX1_C3CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c3cr_get_spol(struct DMAMUX1_Type* p) { return (p->C3CR & DMAMUX1_C3CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c3cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C3CR & DMAMUX1_C3CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C4CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C4CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C4CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C4CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C4CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C4CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C4CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C4CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c4cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX1_C4CR_SYNC_ID) | ((val<<24) & DMAMUX1_C4CR_SYNC_ID); }
inline void dmamux1_c4cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX1_C4CR_NBREQ) | ((val<<19) & DMAMUX1_C4CR_NBREQ); }
inline void dmamux1_c4cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX1_C4CR_SPOL) | ((val<<17) & DMAMUX1_C4CR_SPOL); }
inline void dmamux1_c4cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX1_C4CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C4CR_DMAREQ_ID); }
inline uint32_t dmamux1_c4cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C4CR & DMAMUX1_C4CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c4cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C4CR & DMAMUX1_C4CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c4cr_get_spol(struct DMAMUX1_Type* p) { return (p->C4CR & DMAMUX1_C4CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c4cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C4CR & DMAMUX1_C4CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C5CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C5CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C5CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C5CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C5CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C5CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C5CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C5CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c5cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX1_C5CR_SYNC_ID) | ((val<<24) & DMAMUX1_C5CR_SYNC_ID); }
inline void dmamux1_c5cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX1_C5CR_NBREQ) | ((val<<19) & DMAMUX1_C5CR_NBREQ); }
inline void dmamux1_c5cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX1_C5CR_SPOL) | ((val<<17) & DMAMUX1_C5CR_SPOL); }
inline void dmamux1_c5cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX1_C5CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C5CR_DMAREQ_ID); }
inline uint32_t dmamux1_c5cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C5CR & DMAMUX1_C5CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c5cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C5CR & DMAMUX1_C5CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c5cr_get_spol(struct DMAMUX1_Type* p) { return (p->C5CR & DMAMUX1_C5CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c5cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C5CR & DMAMUX1_C5CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C6CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C6CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C6CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C6CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C6CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C6CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C6CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C6CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c6cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX1_C6CR_SYNC_ID) | ((val<<24) & DMAMUX1_C6CR_SYNC_ID); }
inline void dmamux1_c6cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX1_C6CR_NBREQ) | ((val<<19) & DMAMUX1_C6CR_NBREQ); }
inline void dmamux1_c6cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX1_C6CR_SPOL) | ((val<<17) & DMAMUX1_C6CR_SPOL); }
inline void dmamux1_c6cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX1_C6CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C6CR_DMAREQ_ID); }
inline uint32_t dmamux1_c6cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C6CR & DMAMUX1_C6CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c6cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C6CR & DMAMUX1_C6CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c6cr_get_spol(struct DMAMUX1_Type* p) { return (p->C6CR & DMAMUX1_C6CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c6cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C6CR & DMAMUX1_C6CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C7CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C7CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C7CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C7CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C7CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C7CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C7CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C7CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c7cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX1_C7CR_SYNC_ID) | ((val<<24) & DMAMUX1_C7CR_SYNC_ID); }
inline void dmamux1_c7cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX1_C7CR_NBREQ) | ((val<<19) & DMAMUX1_C7CR_NBREQ); }
inline void dmamux1_c7cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX1_C7CR_SPOL) | ((val<<17) & DMAMUX1_C7CR_SPOL); }
inline void dmamux1_c7cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX1_C7CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C7CR_DMAREQ_ID); }
inline uint32_t dmamux1_c7cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C7CR & DMAMUX1_C7CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c7cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C7CR & DMAMUX1_C7CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c7cr_get_spol(struct DMAMUX1_Type* p) { return (p->C7CR & DMAMUX1_C7CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c7cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C7CR & DMAMUX1_C7CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C8CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C8CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C8CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C8CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C8CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C8CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C8CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C8CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c8cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C8CR = (p->C8CR & ~DMAMUX1_C8CR_SYNC_ID) | ((val<<24) & DMAMUX1_C8CR_SYNC_ID); }
inline void dmamux1_c8cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C8CR = (p->C8CR & ~DMAMUX1_C8CR_NBREQ) | ((val<<19) & DMAMUX1_C8CR_NBREQ); }
inline void dmamux1_c8cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C8CR = (p->C8CR & ~DMAMUX1_C8CR_SPOL) | ((val<<17) & DMAMUX1_C8CR_SPOL); }
inline void dmamux1_c8cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C8CR = (p->C8CR & ~DMAMUX1_C8CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C8CR_DMAREQ_ID); }
inline uint32_t dmamux1_c8cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C8CR & DMAMUX1_C8CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c8cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C8CR & DMAMUX1_C8CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c8cr_get_spol(struct DMAMUX1_Type* p) { return (p->C8CR & DMAMUX1_C8CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c8cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C8CR & DMAMUX1_C8CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C9CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C9CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C9CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C9CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C9CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C9CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C9CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C9CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c9cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C9CR = (p->C9CR & ~DMAMUX1_C9CR_SYNC_ID) | ((val<<24) & DMAMUX1_C9CR_SYNC_ID); }
inline void dmamux1_c9cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C9CR = (p->C9CR & ~DMAMUX1_C9CR_NBREQ) | ((val<<19) & DMAMUX1_C9CR_NBREQ); }
inline void dmamux1_c9cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C9CR = (p->C9CR & ~DMAMUX1_C9CR_SPOL) | ((val<<17) & DMAMUX1_C9CR_SPOL); }
inline void dmamux1_c9cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C9CR = (p->C9CR & ~DMAMUX1_C9CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C9CR_DMAREQ_ID); }
inline uint32_t dmamux1_c9cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C9CR & DMAMUX1_C9CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c9cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C9CR & DMAMUX1_C9CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c9cr_get_spol(struct DMAMUX1_Type* p) { return (p->C9CR & DMAMUX1_C9CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c9cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C9CR & DMAMUX1_C9CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C10CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C10CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C10CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C10CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C10CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C10CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C10CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C10CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c10cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C10CR = (p->C10CR & ~DMAMUX1_C10CR_SYNC_ID) | ((val<<24) & DMAMUX1_C10CR_SYNC_ID); }
inline void dmamux1_c10cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C10CR = (p->C10CR & ~DMAMUX1_C10CR_NBREQ) | ((val<<19) & DMAMUX1_C10CR_NBREQ); }
inline void dmamux1_c10cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C10CR = (p->C10CR & ~DMAMUX1_C10CR_SPOL) | ((val<<17) & DMAMUX1_C10CR_SPOL); }
inline void dmamux1_c10cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C10CR = (p->C10CR & ~DMAMUX1_C10CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C10CR_DMAREQ_ID); }
inline uint32_t dmamux1_c10cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C10CR & DMAMUX1_C10CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c10cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C10CR & DMAMUX1_C10CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c10cr_get_spol(struct DMAMUX1_Type* p) { return (p->C10CR & DMAMUX1_C10CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c10cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C10CR & DMAMUX1_C10CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C11CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C11CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C11CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C11CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C11CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C11CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C11CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C11CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c11cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C11CR = (p->C11CR & ~DMAMUX1_C11CR_SYNC_ID) | ((val<<24) & DMAMUX1_C11CR_SYNC_ID); }
inline void dmamux1_c11cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C11CR = (p->C11CR & ~DMAMUX1_C11CR_NBREQ) | ((val<<19) & DMAMUX1_C11CR_NBREQ); }
inline void dmamux1_c11cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C11CR = (p->C11CR & ~DMAMUX1_C11CR_SPOL) | ((val<<17) & DMAMUX1_C11CR_SPOL); }
inline void dmamux1_c11cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C11CR = (p->C11CR & ~DMAMUX1_C11CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C11CR_DMAREQ_ID); }
inline uint32_t dmamux1_c11cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C11CR & DMAMUX1_C11CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c11cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C11CR & DMAMUX1_C11CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c11cr_get_spol(struct DMAMUX1_Type* p) { return (p->C11CR & DMAMUX1_C11CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c11cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C11CR & DMAMUX1_C11CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C12CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C12CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C12CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C12CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C12CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C12CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C12CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C12CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c12cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C12CR = (p->C12CR & ~DMAMUX1_C12CR_SYNC_ID) | ((val<<24) & DMAMUX1_C12CR_SYNC_ID); }
inline void dmamux1_c12cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C12CR = (p->C12CR & ~DMAMUX1_C12CR_NBREQ) | ((val<<19) & DMAMUX1_C12CR_NBREQ); }
inline void dmamux1_c12cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C12CR = (p->C12CR & ~DMAMUX1_C12CR_SPOL) | ((val<<17) & DMAMUX1_C12CR_SPOL); }
inline void dmamux1_c12cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C12CR = (p->C12CR & ~DMAMUX1_C12CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C12CR_DMAREQ_ID); }
inline uint32_t dmamux1_c12cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C12CR & DMAMUX1_C12CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c12cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C12CR & DMAMUX1_C12CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c12cr_get_spol(struct DMAMUX1_Type* p) { return (p->C12CR & DMAMUX1_C12CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c12cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C12CR & DMAMUX1_C12CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C13CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C13CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C13CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C13CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C13CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C13CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C13CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C13CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c13cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C13CR = (p->C13CR & ~DMAMUX1_C13CR_SYNC_ID) | ((val<<24) & DMAMUX1_C13CR_SYNC_ID); }
inline void dmamux1_c13cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C13CR = (p->C13CR & ~DMAMUX1_C13CR_NBREQ) | ((val<<19) & DMAMUX1_C13CR_NBREQ); }
inline void dmamux1_c13cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C13CR = (p->C13CR & ~DMAMUX1_C13CR_SPOL) | ((val<<17) & DMAMUX1_C13CR_SPOL); }
inline void dmamux1_c13cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C13CR = (p->C13CR & ~DMAMUX1_C13CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C13CR_DMAREQ_ID); }
inline uint32_t dmamux1_c13cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C13CR & DMAMUX1_C13CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c13cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C13CR & DMAMUX1_C13CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c13cr_get_spol(struct DMAMUX1_Type* p) { return (p->C13CR & DMAMUX1_C13CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c13cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C13CR & DMAMUX1_C13CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C14CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C14CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C14CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C14CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C14CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C14CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C14CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C14CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c14cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C14CR = (p->C14CR & ~DMAMUX1_C14CR_SYNC_ID) | ((val<<24) & DMAMUX1_C14CR_SYNC_ID); }
inline void dmamux1_c14cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C14CR = (p->C14CR & ~DMAMUX1_C14CR_NBREQ) | ((val<<19) & DMAMUX1_C14CR_NBREQ); }
inline void dmamux1_c14cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C14CR = (p->C14CR & ~DMAMUX1_C14CR_SPOL) | ((val<<17) & DMAMUX1_C14CR_SPOL); }
inline void dmamux1_c14cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C14CR = (p->C14CR & ~DMAMUX1_C14CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C14CR_DMAREQ_ID); }
inline uint32_t dmamux1_c14cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C14CR & DMAMUX1_C14CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c14cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C14CR & DMAMUX1_C14CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c14cr_get_spol(struct DMAMUX1_Type* p) { return (p->C14CR & DMAMUX1_C14CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c14cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C14CR & DMAMUX1_C14CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->C15CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX1_C15CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX1_C15CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX1_C15CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX1_C15CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX1_C15CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX1_C15CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX1_C15CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux1_c15cr_set_sync_id(struct DMAMUX1_Type* p, uint32_t val) { p->C15CR = (p->C15CR & ~DMAMUX1_C15CR_SYNC_ID) | ((val<<24) & DMAMUX1_C15CR_SYNC_ID); }
inline void dmamux1_c15cr_set_nbreq(struct DMAMUX1_Type* p, uint32_t val) { p->C15CR = (p->C15CR & ~DMAMUX1_C15CR_NBREQ) | ((val<<19) & DMAMUX1_C15CR_NBREQ); }
inline void dmamux1_c15cr_set_spol(struct DMAMUX1_Type* p, uint32_t val) { p->C15CR = (p->C15CR & ~DMAMUX1_C15CR_SPOL) | ((val<<17) & DMAMUX1_C15CR_SPOL); }
inline void dmamux1_c15cr_set_dmareq_id(struct DMAMUX1_Type* p, uint32_t val) { p->C15CR = (p->C15CR & ~DMAMUX1_C15CR_DMAREQ_ID) | ((val<<0) & DMAMUX1_C15CR_DMAREQ_ID); }
inline uint32_t dmamux1_c15cr_get_sync_id(struct DMAMUX1_Type* p) { return (p->C15CR & DMAMUX1_C15CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux1_c15cr_get_nbreq(struct DMAMUX1_Type* p) { return (p->C15CR & DMAMUX1_C15CR_NBREQ) >> 19 ; }
inline uint32_t dmamux1_c15cr_get_spol(struct DMAMUX1_Type* p) { return (p->C15CR & DMAMUX1_C15CR_SPOL) >> 17 ; }
inline uint32_t dmamux1_c15cr_get_dmareq_id(struct DMAMUX1_Type* p) { return (p->C15CR & DMAMUX1_C15CR_DMAREQ_ID) >> 0 ; }

// DMAMUX1->RG0CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG0CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG0CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG0CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG0CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG0CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg0cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX1_RG0CR_GNBREQ) | ((val<<19) & DMAMUX1_RG0CR_GNBREQ); }
inline void dmamux1_rg0cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX1_RG0CR_GPOL) | ((val<<17) & DMAMUX1_RG0CR_GPOL); }
inline void dmamux1_rg0cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX1_RG0CR_SIG_ID) | ((val<<0) & DMAMUX1_RG0CR_SIG_ID); }
inline uint32_t dmamux1_rg0cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG0CR & DMAMUX1_RG0CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg0cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG0CR & DMAMUX1_RG0CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg0cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG0CR & DMAMUX1_RG0CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG1CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG1CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG1CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG1CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG1CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG1CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg1cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX1_RG1CR_GNBREQ) | ((val<<19) & DMAMUX1_RG1CR_GNBREQ); }
inline void dmamux1_rg1cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX1_RG1CR_GPOL) | ((val<<17) & DMAMUX1_RG1CR_GPOL); }
inline void dmamux1_rg1cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX1_RG1CR_SIG_ID) | ((val<<0) & DMAMUX1_RG1CR_SIG_ID); }
inline uint32_t dmamux1_rg1cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG1CR & DMAMUX1_RG1CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg1cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG1CR & DMAMUX1_RG1CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg1cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG1CR & DMAMUX1_RG1CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG2CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG2CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG2CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG2CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG2CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG2CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg2cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX1_RG2CR_GNBREQ) | ((val<<19) & DMAMUX1_RG2CR_GNBREQ); }
inline void dmamux1_rg2cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX1_RG2CR_GPOL) | ((val<<17) & DMAMUX1_RG2CR_GPOL); }
inline void dmamux1_rg2cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX1_RG2CR_SIG_ID) | ((val<<0) & DMAMUX1_RG2CR_SIG_ID); }
inline uint32_t dmamux1_rg2cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG2CR & DMAMUX1_RG2CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg2cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG2CR & DMAMUX1_RG2CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg2cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG2CR & DMAMUX1_RG2CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG3CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG3CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG3CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG3CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG3CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG3CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg3cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX1_RG3CR_GNBREQ) | ((val<<19) & DMAMUX1_RG3CR_GNBREQ); }
inline void dmamux1_rg3cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX1_RG3CR_GPOL) | ((val<<17) & DMAMUX1_RG3CR_GPOL); }
inline void dmamux1_rg3cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX1_RG3CR_SIG_ID) | ((val<<0) & DMAMUX1_RG3CR_SIG_ID); }
inline uint32_t dmamux1_rg3cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG3CR & DMAMUX1_RG3CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg3cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG3CR & DMAMUX1_RG3CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg3cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG3CR & DMAMUX1_RG3CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG4CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG4CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG4CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG4CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG4CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG4CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg4cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG4CR = (p->RG4CR & ~DMAMUX1_RG4CR_GNBREQ) | ((val<<19) & DMAMUX1_RG4CR_GNBREQ); }
inline void dmamux1_rg4cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG4CR = (p->RG4CR & ~DMAMUX1_RG4CR_GPOL) | ((val<<17) & DMAMUX1_RG4CR_GPOL); }
inline void dmamux1_rg4cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG4CR = (p->RG4CR & ~DMAMUX1_RG4CR_SIG_ID) | ((val<<0) & DMAMUX1_RG4CR_SIG_ID); }
inline uint32_t dmamux1_rg4cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG4CR & DMAMUX1_RG4CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg4cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG4CR & DMAMUX1_RG4CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg4cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG4CR & DMAMUX1_RG4CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG5CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG5CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG5CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG5CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG5CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG5CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg5cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG5CR = (p->RG5CR & ~DMAMUX1_RG5CR_GNBREQ) | ((val<<19) & DMAMUX1_RG5CR_GNBREQ); }
inline void dmamux1_rg5cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG5CR = (p->RG5CR & ~DMAMUX1_RG5CR_GPOL) | ((val<<17) & DMAMUX1_RG5CR_GPOL); }
inline void dmamux1_rg5cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG5CR = (p->RG5CR & ~DMAMUX1_RG5CR_SIG_ID) | ((val<<0) & DMAMUX1_RG5CR_SIG_ID); }
inline uint32_t dmamux1_rg5cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG5CR & DMAMUX1_RG5CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg5cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG5CR & DMAMUX1_RG5CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg5cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG5CR & DMAMUX1_RG5CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG6CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG6CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG6CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG6CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG6CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG6CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg6cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG6CR = (p->RG6CR & ~DMAMUX1_RG6CR_GNBREQ) | ((val<<19) & DMAMUX1_RG6CR_GNBREQ); }
inline void dmamux1_rg6cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG6CR = (p->RG6CR & ~DMAMUX1_RG6CR_GPOL) | ((val<<17) & DMAMUX1_RG6CR_GPOL); }
inline void dmamux1_rg6cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG6CR = (p->RG6CR & ~DMAMUX1_RG6CR_SIG_ID) | ((val<<0) & DMAMUX1_RG6CR_SIG_ID); }
inline uint32_t dmamux1_rg6cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG6CR & DMAMUX1_RG6CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg6cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG6CR & DMAMUX1_RG6CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg6cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG6CR & DMAMUX1_RG6CR_SIG_ID) >> 0 ; }

// DMAMUX1->RG7CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX1_RG7CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX1_RG7CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX1_RG7CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX1_RG7CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX1_RG7CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux1_rg7cr_set_gnbreq(struct DMAMUX1_Type* p, uint32_t val) { p->RG7CR = (p->RG7CR & ~DMAMUX1_RG7CR_GNBREQ) | ((val<<19) & DMAMUX1_RG7CR_GNBREQ); }
inline void dmamux1_rg7cr_set_gpol(struct DMAMUX1_Type* p, uint32_t val) { p->RG7CR = (p->RG7CR & ~DMAMUX1_RG7CR_GPOL) | ((val<<17) & DMAMUX1_RG7CR_GPOL); }
inline void dmamux1_rg7cr_set_sig_id(struct DMAMUX1_Type* p, uint32_t val) { p->RG7CR = (p->RG7CR & ~DMAMUX1_RG7CR_SIG_ID) | ((val<<0) & DMAMUX1_RG7CR_SIG_ID); }
inline uint32_t dmamux1_rg7cr_get_gnbreq(struct DMAMUX1_Type* p) { return (p->RG7CR & DMAMUX1_RG7CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux1_rg7cr_get_gpol(struct DMAMUX1_Type* p) { return (p->RG7CR & DMAMUX1_RG7CR_GPOL) >> 17 ; }
inline uint32_t dmamux1_rg7cr_get_sig_id(struct DMAMUX1_Type* p) { return (p->RG7CR & DMAMUX1_RG7CR_SIG_ID) >> 0 ; }

// Valid Casts:
 
inline struct DMAMUX2_Type* DMAMUX1_as_DMAMUX2_Type(struct DMAMUX1_Type* p) { return (struct DMAMUX2_Type*)p; }


/* DMAMUX */
struct DMAMUX2_Type {
	__IO uint32_t C0CR; // @0 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C1CR; // @4 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C2CR; // @8 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C3CR; // @12 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C4CR; // @16 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C5CR; // @20 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C6CR; // @24 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C7CR; // @28 DMAMux - DMA request line multiplexer channel x control register
	 uint8_t RESERVED0[96]; // @32 
	__I uint16_t CSR; // @128 DMAMUX request line multiplexer interrupt channel status register
	 uint8_t RESERVED1[2]; // @130 
	__O uint16_t CFR; // @132 DMAMUX request line multiplexer interrupt clear flag register
	 uint8_t RESERVED2[122]; // @134 
	__IO uint32_t RG0CR; // @256 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG1CR; // @260 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG2CR; // @264 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG3CR; // @268 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG4CR; // @272 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG5CR; // @276 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG6CR; // @280 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG7CR; // @284 DMAMux - DMA request generator channel x control register
	 uint8_t RESERVED3[32]; // @288 
	__I uint8_t RGSR; // @320 DMAMux - DMA request generator status register
	 uint8_t RESERVED4[3]; // @321 
	__O uint8_t RGCFR; // @324 DMAMux - DMA request generator clear flag register
};

// DMAMUX2->C0CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C0CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C0CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C0CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C0CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C0CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C0CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C0CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c0cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX2_C0CR_SYNC_ID) | ((val<<24) & DMAMUX2_C0CR_SYNC_ID); }
inline void dmamux2_c0cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX2_C0CR_NBREQ) | ((val<<19) & DMAMUX2_C0CR_NBREQ); }
inline void dmamux2_c0cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX2_C0CR_SPOL) | ((val<<17) & DMAMUX2_C0CR_SPOL); }
inline void dmamux2_c0cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C0CR = (p->C0CR & ~DMAMUX2_C0CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C0CR_DMAREQ_ID); }
inline uint32_t dmamux2_c0cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C0CR & DMAMUX2_C0CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c0cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C0CR & DMAMUX2_C0CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c0cr_get_spol(struct DMAMUX2_Type* p) { return (p->C0CR & DMAMUX2_C0CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c0cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C0CR & DMAMUX2_C0CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C1CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C1CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C1CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C1CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C1CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C1CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C1CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C1CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c1cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX2_C1CR_SYNC_ID) | ((val<<24) & DMAMUX2_C1CR_SYNC_ID); }
inline void dmamux2_c1cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX2_C1CR_NBREQ) | ((val<<19) & DMAMUX2_C1CR_NBREQ); }
inline void dmamux2_c1cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX2_C1CR_SPOL) | ((val<<17) & DMAMUX2_C1CR_SPOL); }
inline void dmamux2_c1cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C1CR = (p->C1CR & ~DMAMUX2_C1CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C1CR_DMAREQ_ID); }
inline uint32_t dmamux2_c1cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C1CR & DMAMUX2_C1CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c1cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C1CR & DMAMUX2_C1CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c1cr_get_spol(struct DMAMUX2_Type* p) { return (p->C1CR & DMAMUX2_C1CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c1cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C1CR & DMAMUX2_C1CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C2CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C2CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C2CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C2CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C2CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C2CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C2CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C2CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c2cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX2_C2CR_SYNC_ID) | ((val<<24) & DMAMUX2_C2CR_SYNC_ID); }
inline void dmamux2_c2cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX2_C2CR_NBREQ) | ((val<<19) & DMAMUX2_C2CR_NBREQ); }
inline void dmamux2_c2cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX2_C2CR_SPOL) | ((val<<17) & DMAMUX2_C2CR_SPOL); }
inline void dmamux2_c2cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C2CR = (p->C2CR & ~DMAMUX2_C2CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C2CR_DMAREQ_ID); }
inline uint32_t dmamux2_c2cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C2CR & DMAMUX2_C2CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c2cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C2CR & DMAMUX2_C2CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c2cr_get_spol(struct DMAMUX2_Type* p) { return (p->C2CR & DMAMUX2_C2CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c2cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C2CR & DMAMUX2_C2CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C3CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C3CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C3CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C3CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C3CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C3CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C3CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C3CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c3cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX2_C3CR_SYNC_ID) | ((val<<24) & DMAMUX2_C3CR_SYNC_ID); }
inline void dmamux2_c3cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX2_C3CR_NBREQ) | ((val<<19) & DMAMUX2_C3CR_NBREQ); }
inline void dmamux2_c3cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX2_C3CR_SPOL) | ((val<<17) & DMAMUX2_C3CR_SPOL); }
inline void dmamux2_c3cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C3CR = (p->C3CR & ~DMAMUX2_C3CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C3CR_DMAREQ_ID); }
inline uint32_t dmamux2_c3cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C3CR & DMAMUX2_C3CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c3cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C3CR & DMAMUX2_C3CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c3cr_get_spol(struct DMAMUX2_Type* p) { return (p->C3CR & DMAMUX2_C3CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c3cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C3CR & DMAMUX2_C3CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C4CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C4CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C4CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C4CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C4CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C4CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C4CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C4CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c4cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX2_C4CR_SYNC_ID) | ((val<<24) & DMAMUX2_C4CR_SYNC_ID); }
inline void dmamux2_c4cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX2_C4CR_NBREQ) | ((val<<19) & DMAMUX2_C4CR_NBREQ); }
inline void dmamux2_c4cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX2_C4CR_SPOL) | ((val<<17) & DMAMUX2_C4CR_SPOL); }
inline void dmamux2_c4cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C4CR = (p->C4CR & ~DMAMUX2_C4CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C4CR_DMAREQ_ID); }
inline uint32_t dmamux2_c4cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C4CR & DMAMUX2_C4CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c4cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C4CR & DMAMUX2_C4CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c4cr_get_spol(struct DMAMUX2_Type* p) { return (p->C4CR & DMAMUX2_C4CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c4cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C4CR & DMAMUX2_C4CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C5CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C5CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C5CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C5CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C5CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C5CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C5CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C5CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c5cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX2_C5CR_SYNC_ID) | ((val<<24) & DMAMUX2_C5CR_SYNC_ID); }
inline void dmamux2_c5cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX2_C5CR_NBREQ) | ((val<<19) & DMAMUX2_C5CR_NBREQ); }
inline void dmamux2_c5cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX2_C5CR_SPOL) | ((val<<17) & DMAMUX2_C5CR_SPOL); }
inline void dmamux2_c5cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C5CR = (p->C5CR & ~DMAMUX2_C5CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C5CR_DMAREQ_ID); }
inline uint32_t dmamux2_c5cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C5CR & DMAMUX2_C5CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c5cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C5CR & DMAMUX2_C5CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c5cr_get_spol(struct DMAMUX2_Type* p) { return (p->C5CR & DMAMUX2_C5CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c5cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C5CR & DMAMUX2_C5CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C6CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C6CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C6CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C6CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C6CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C6CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C6CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C6CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c6cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX2_C6CR_SYNC_ID) | ((val<<24) & DMAMUX2_C6CR_SYNC_ID); }
inline void dmamux2_c6cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX2_C6CR_NBREQ) | ((val<<19) & DMAMUX2_C6CR_NBREQ); }
inline void dmamux2_c6cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX2_C6CR_SPOL) | ((val<<17) & DMAMUX2_C6CR_SPOL); }
inline void dmamux2_c6cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C6CR = (p->C6CR & ~DMAMUX2_C6CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C6CR_DMAREQ_ID); }
inline uint32_t dmamux2_c6cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C6CR & DMAMUX2_C6CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c6cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C6CR & DMAMUX2_C6CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c6cr_get_spol(struct DMAMUX2_Type* p) { return (p->C6CR & DMAMUX2_C6CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c6cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C6CR & DMAMUX2_C6CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->C7CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX2_C7CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX2_C7CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX2_C7CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX2_C7CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX2_C7CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX2_C7CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX2_C7CR_DMAREQ_ID = ((1UL<<8)-1) << 0, // Input DMA request line selected		
};
inline void dmamux2_c7cr_set_sync_id(struct DMAMUX2_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX2_C7CR_SYNC_ID) | ((val<<24) & DMAMUX2_C7CR_SYNC_ID); }
inline void dmamux2_c7cr_set_nbreq(struct DMAMUX2_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX2_C7CR_NBREQ) | ((val<<19) & DMAMUX2_C7CR_NBREQ); }
inline void dmamux2_c7cr_set_spol(struct DMAMUX2_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX2_C7CR_SPOL) | ((val<<17) & DMAMUX2_C7CR_SPOL); }
inline void dmamux2_c7cr_set_dmareq_id(struct DMAMUX2_Type* p, uint32_t val) { p->C7CR = (p->C7CR & ~DMAMUX2_C7CR_DMAREQ_ID) | ((val<<0) & DMAMUX2_C7CR_DMAREQ_ID); }
inline uint32_t dmamux2_c7cr_get_sync_id(struct DMAMUX2_Type* p) { return (p->C7CR & DMAMUX2_C7CR_SYNC_ID) >> 24 ; }
inline uint32_t dmamux2_c7cr_get_nbreq(struct DMAMUX2_Type* p) { return (p->C7CR & DMAMUX2_C7CR_NBREQ) >> 19 ; }
inline uint32_t dmamux2_c7cr_get_spol(struct DMAMUX2_Type* p) { return (p->C7CR & DMAMUX2_C7CR_SPOL) >> 17 ; }
inline uint32_t dmamux2_c7cr_get_dmareq_id(struct DMAMUX2_Type* p) { return (p->C7CR & DMAMUX2_C7CR_DMAREQ_ID) >> 0 ; }

// DMAMUX2->RG0CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG0CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG0CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG0CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG0CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG0CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg0cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX2_RG0CR_GNBREQ) | ((val<<19) & DMAMUX2_RG0CR_GNBREQ); }
inline void dmamux2_rg0cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX2_RG0CR_GPOL) | ((val<<17) & DMAMUX2_RG0CR_GPOL); }
inline void dmamux2_rg0cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG0CR = (p->RG0CR & ~DMAMUX2_RG0CR_SIG_ID) | ((val<<0) & DMAMUX2_RG0CR_SIG_ID); }
inline uint32_t dmamux2_rg0cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG0CR & DMAMUX2_RG0CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg0cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG0CR & DMAMUX2_RG0CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg0cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG0CR & DMAMUX2_RG0CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG1CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG1CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG1CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG1CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG1CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG1CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg1cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX2_RG1CR_GNBREQ) | ((val<<19) & DMAMUX2_RG1CR_GNBREQ); }
inline void dmamux2_rg1cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX2_RG1CR_GPOL) | ((val<<17) & DMAMUX2_RG1CR_GPOL); }
inline void dmamux2_rg1cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG1CR = (p->RG1CR & ~DMAMUX2_RG1CR_SIG_ID) | ((val<<0) & DMAMUX2_RG1CR_SIG_ID); }
inline uint32_t dmamux2_rg1cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG1CR & DMAMUX2_RG1CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg1cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG1CR & DMAMUX2_RG1CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg1cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG1CR & DMAMUX2_RG1CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG2CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG2CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG2CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG2CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG2CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG2CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg2cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX2_RG2CR_GNBREQ) | ((val<<19) & DMAMUX2_RG2CR_GNBREQ); }
inline void dmamux2_rg2cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX2_RG2CR_GPOL) | ((val<<17) & DMAMUX2_RG2CR_GPOL); }
inline void dmamux2_rg2cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG2CR = (p->RG2CR & ~DMAMUX2_RG2CR_SIG_ID) | ((val<<0) & DMAMUX2_RG2CR_SIG_ID); }
inline uint32_t dmamux2_rg2cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG2CR & DMAMUX2_RG2CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg2cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG2CR & DMAMUX2_RG2CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg2cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG2CR & DMAMUX2_RG2CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG3CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG3CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG3CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG3CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG3CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG3CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg3cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX2_RG3CR_GNBREQ) | ((val<<19) & DMAMUX2_RG3CR_GNBREQ); }
inline void dmamux2_rg3cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX2_RG3CR_GPOL) | ((val<<17) & DMAMUX2_RG3CR_GPOL); }
inline void dmamux2_rg3cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG3CR = (p->RG3CR & ~DMAMUX2_RG3CR_SIG_ID) | ((val<<0) & DMAMUX2_RG3CR_SIG_ID); }
inline uint32_t dmamux2_rg3cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG3CR & DMAMUX2_RG3CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg3cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG3CR & DMAMUX2_RG3CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg3cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG3CR & DMAMUX2_RG3CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG4CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG4CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG4CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG4CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG4CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG4CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg4cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG4CR = (p->RG4CR & ~DMAMUX2_RG4CR_GNBREQ) | ((val<<19) & DMAMUX2_RG4CR_GNBREQ); }
inline void dmamux2_rg4cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG4CR = (p->RG4CR & ~DMAMUX2_RG4CR_GPOL) | ((val<<17) & DMAMUX2_RG4CR_GPOL); }
inline void dmamux2_rg4cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG4CR = (p->RG4CR & ~DMAMUX2_RG4CR_SIG_ID) | ((val<<0) & DMAMUX2_RG4CR_SIG_ID); }
inline uint32_t dmamux2_rg4cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG4CR & DMAMUX2_RG4CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg4cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG4CR & DMAMUX2_RG4CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg4cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG4CR & DMAMUX2_RG4CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG5CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG5CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG5CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG5CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG5CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG5CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg5cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG5CR = (p->RG5CR & ~DMAMUX2_RG5CR_GNBREQ) | ((val<<19) & DMAMUX2_RG5CR_GNBREQ); }
inline void dmamux2_rg5cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG5CR = (p->RG5CR & ~DMAMUX2_RG5CR_GPOL) | ((val<<17) & DMAMUX2_RG5CR_GPOL); }
inline void dmamux2_rg5cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG5CR = (p->RG5CR & ~DMAMUX2_RG5CR_SIG_ID) | ((val<<0) & DMAMUX2_RG5CR_SIG_ID); }
inline uint32_t dmamux2_rg5cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG5CR & DMAMUX2_RG5CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg5cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG5CR & DMAMUX2_RG5CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg5cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG5CR & DMAMUX2_RG5CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG6CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG6CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG6CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG6CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG6CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG6CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg6cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG6CR = (p->RG6CR & ~DMAMUX2_RG6CR_GNBREQ) | ((val<<19) & DMAMUX2_RG6CR_GNBREQ); }
inline void dmamux2_rg6cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG6CR = (p->RG6CR & ~DMAMUX2_RG6CR_GPOL) | ((val<<17) & DMAMUX2_RG6CR_GPOL); }
inline void dmamux2_rg6cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG6CR = (p->RG6CR & ~DMAMUX2_RG6CR_SIG_ID) | ((val<<0) & DMAMUX2_RG6CR_SIG_ID); }
inline uint32_t dmamux2_rg6cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG6CR & DMAMUX2_RG6CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg6cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG6CR & DMAMUX2_RG6CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg6cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG6CR & DMAMUX2_RG6CR_SIG_ID) >> 0 ; }

// DMAMUX2->RG7CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX2_RG7CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX2_RG7CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX2_RG7CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX2_RG7CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX2_RG7CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
inline void dmamux2_rg7cr_set_gnbreq(struct DMAMUX2_Type* p, uint32_t val) { p->RG7CR = (p->RG7CR & ~DMAMUX2_RG7CR_GNBREQ) | ((val<<19) & DMAMUX2_RG7CR_GNBREQ); }
inline void dmamux2_rg7cr_set_gpol(struct DMAMUX2_Type* p, uint32_t val) { p->RG7CR = (p->RG7CR & ~DMAMUX2_RG7CR_GPOL) | ((val<<17) & DMAMUX2_RG7CR_GPOL); }
inline void dmamux2_rg7cr_set_sig_id(struct DMAMUX2_Type* p, uint32_t val) { p->RG7CR = (p->RG7CR & ~DMAMUX2_RG7CR_SIG_ID) | ((val<<0) & DMAMUX2_RG7CR_SIG_ID); }
inline uint32_t dmamux2_rg7cr_get_gnbreq(struct DMAMUX2_Type* p) { return (p->RG7CR & DMAMUX2_RG7CR_GNBREQ) >> 19 ; }
inline uint32_t dmamux2_rg7cr_get_gpol(struct DMAMUX2_Type* p) { return (p->RG7CR & DMAMUX2_RG7CR_GPOL) >> 17 ; }
inline uint32_t dmamux2_rg7cr_get_sig_id(struct DMAMUX2_Type* p) { return (p->RG7CR & DMAMUX2_RG7CR_SIG_ID) >> 0 ; }

/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t RTSR1; // @0 EXTI rising trigger selection register
	__IO uint32_t FTSR1; // @4 EXTI falling trigger selection register
	__IO uint32_t SWIER1; // @8 EXTI software interrupt event register
	__IO uint32_t D3PMR1; // @12 EXTI D3 pending mask register
	__IO uint32_t D3PCR1L; // @16 EXTI D3 pending clear selection register low
	__IO uint32_t D3PCR1H; // @20 EXTI D3 pending clear selection register high
	 uint8_t RESERVED0[8]; // @24 
	__IO uint32_t RTSR2; // @32 EXTI rising trigger selection register
	__IO uint32_t FTSR2; // @36 EXTI falling trigger selection register
	__IO uint32_t SWIER2; // @40 EXTI software interrupt event register
	__IO uint32_t D3PMR2; // @44 EXTI D3 pending mask register
	__IO uint32_t D3PCR2L; // @48 EXTI D3 pending clear selection register low
	__IO uint16_t D3PCR2H; // @52 EXTI D3 pending clear selection register high
	 uint8_t RESERVED1[10]; // @54 
	__IO uint32_t RTSR3; // @64 EXTI rising trigger selection register
	__IO uint32_t FTSR3; // @68 EXTI falling trigger selection register
	__IO uint32_t SWIER3; // @72 EXTI software interrupt event register
	__IO uint32_t D3PMR3; // @76 EXTI D3 pending mask register
	 uint8_t RESERVED2[4]; // @80 
	__IO uint32_t D3PCR3H; // @84 EXTI D3 pending clear selection register high
	 uint8_t RESERVED3[40]; // @88 
	__IO uint32_t CPUIMR1; // @128 EXTI interrupt mask register
	__IO uint32_t CPUEMR1; // @132 EXTI event mask register
	__IO uint32_t CPUPR1; // @136 EXTI pending register
	 uint8_t RESERVED4[4]; // @140 
	__IO uint32_t CPUIMR2; // @144 EXTI interrupt mask register
	__IO uint32_t CPUEMR2; // @148 EXTI event mask register
	__I uint32_t CPUPR2; // @152 EXTI pending register
	 uint8_t RESERVED5[4]; // @156 
	__I uint32_t CPUIMR3; // @160 EXTI interrupt mask register
	__I uint32_t CPUEMR3; // @164 EXTI event mask register
	__I uint32_t CPUPR3; // @168 EXTI pending register
};

// EXTI->RTSR1 EXTI rising trigger selection register
enum {
	EXTI_RTSR1_TRX  = ((1UL<<22)-1) << 0, // Merged Rising trigger event configuration bit of Configurable Event input		
};
inline void exti_rtsr1_set_trx (struct EXTI_Type* p, uint32_t val) { p->RTSR1 = (p->RTSR1 & ~EXTI_RTSR1_TRX ) | ((val<<0) & EXTI_RTSR1_TRX ); }
inline uint32_t exti_rtsr1_get_trx (struct EXTI_Type* p) { return (p->RTSR1 & EXTI_RTSR1_TRX ) >> 0 ; }

// EXTI->FTSR1 EXTI falling trigger selection register
enum {
	EXTI_FTSR1_TRX  = ((1UL<<22)-1) << 0, // Merged Rising trigger event configuration bit of Configurable Event input		
};
inline void exti_ftsr1_set_trx (struct EXTI_Type* p, uint32_t val) { p->FTSR1 = (p->FTSR1 & ~EXTI_FTSR1_TRX ) | ((val<<0) & EXTI_FTSR1_TRX ); }
inline uint32_t exti_ftsr1_get_trx (struct EXTI_Type* p) { return (p->FTSR1 & EXTI_FTSR1_TRX ) >> 0 ; }

// EXTI->SWIER1 EXTI software interrupt event register
enum {
	EXTI_SWIER1_SWIERX  = ((1UL<<22)-1) << 0, // Merged Rising trigger event configuration bit of Configurable Event input		
};
inline void exti_swier1_set_swierx (struct EXTI_Type* p, uint32_t val) { p->SWIER1 = (p->SWIER1 & ~EXTI_SWIER1_SWIERX ) | ((val<<0) & EXTI_SWIER1_SWIERX ); }
inline uint32_t exti_swier1_get_swierx (struct EXTI_Type* p) { return (p->SWIER1 & EXTI_SWIER1_SWIERX ) >> 0 ; }

// EXTI->D3PMR1 EXTI D3 pending mask register
enum {
	EXTI_D3PMR1_MR25 = 1UL<<25, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR21 = 1UL<<21, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR20 = 1UL<<20, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR19 = 1UL<<19, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR15 = 1UL<<15, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR14 = 1UL<<14, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR13 = 1UL<<13, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR12 = 1UL<<12, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR11 = 1UL<<11, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR10 = 1UL<<10, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR9 = 1UL<<9, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR8 = 1UL<<8, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR7 = 1UL<<7, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR6 = 1UL<<6, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR5 = 1UL<<5, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR4 = 1UL<<4, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR3 = 1UL<<3, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR2 = 1UL<<2, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR1 = 1UL<<1, // Rising trigger event configuration bit of Configurable Event input
	EXTI_D3PMR1_MR0 = 1UL<<0, // Rising trigger event configuration bit of Configurable Event input		
};

// EXTI->D3PCR1L EXTI D3 pending clear selection register low
enum {
	EXTI_D3PCR1L_PCS15 = ((1UL<<2)-1) << 30, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS14 = ((1UL<<2)-1) << 28, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS13 = ((1UL<<2)-1) << 26, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS12 = ((1UL<<2)-1) << 24, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS11 = ((1UL<<2)-1) << 22, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS10 = ((1UL<<2)-1) << 20, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS9 = ((1UL<<2)-1) << 18, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS8 = ((1UL<<2)-1) << 16, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS7 = ((1UL<<2)-1) << 14, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS6 = ((1UL<<2)-1) << 12, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS5 = ((1UL<<2)-1) << 10, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS4 = ((1UL<<2)-1) << 8, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS3 = ((1UL<<2)-1) << 6, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS2 = ((1UL<<2)-1) << 4, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS1 = ((1UL<<2)-1) << 2, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)
	EXTI_D3PCR1L_PCS0 = ((1UL<<2)-1) << 0, // D3 Pending request clear input signal selection on Event input x = truncate (n/2)		
};
inline void exti_d3pcr1l_set_pcs15(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS15) | ((val<<30) & EXTI_D3PCR1L_PCS15); }
inline void exti_d3pcr1l_set_pcs14(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS14) | ((val<<28) & EXTI_D3PCR1L_PCS14); }
inline void exti_d3pcr1l_set_pcs13(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS13) | ((val<<26) & EXTI_D3PCR1L_PCS13); }
inline void exti_d3pcr1l_set_pcs12(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS12) | ((val<<24) & EXTI_D3PCR1L_PCS12); }
inline void exti_d3pcr1l_set_pcs11(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS11) | ((val<<22) & EXTI_D3PCR1L_PCS11); }
inline void exti_d3pcr1l_set_pcs10(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS10) | ((val<<20) & EXTI_D3PCR1L_PCS10); }
inline void exti_d3pcr1l_set_pcs9(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS9) | ((val<<18) & EXTI_D3PCR1L_PCS9); }
inline void exti_d3pcr1l_set_pcs8(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS8) | ((val<<16) & EXTI_D3PCR1L_PCS8); }
inline void exti_d3pcr1l_set_pcs7(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS7) | ((val<<14) & EXTI_D3PCR1L_PCS7); }
inline void exti_d3pcr1l_set_pcs6(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS6) | ((val<<12) & EXTI_D3PCR1L_PCS6); }
inline void exti_d3pcr1l_set_pcs5(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS5) | ((val<<10) & EXTI_D3PCR1L_PCS5); }
inline void exti_d3pcr1l_set_pcs4(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS4) | ((val<<8) & EXTI_D3PCR1L_PCS4); }
inline void exti_d3pcr1l_set_pcs3(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS3) | ((val<<6) & EXTI_D3PCR1L_PCS3); }
inline void exti_d3pcr1l_set_pcs2(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS2) | ((val<<4) & EXTI_D3PCR1L_PCS2); }
inline void exti_d3pcr1l_set_pcs1(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS1) | ((val<<2) & EXTI_D3PCR1L_PCS1); }
inline void exti_d3pcr1l_set_pcs0(struct EXTI_Type* p, uint32_t val) { p->D3PCR1L = (p->D3PCR1L & ~EXTI_D3PCR1L_PCS0) | ((val<<0) & EXTI_D3PCR1L_PCS0); }
inline uint32_t exti_d3pcr1l_get_pcs15(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS15) >> 30 ; }
inline uint32_t exti_d3pcr1l_get_pcs14(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS14) >> 28 ; }
inline uint32_t exti_d3pcr1l_get_pcs13(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS13) >> 26 ; }
inline uint32_t exti_d3pcr1l_get_pcs12(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS12) >> 24 ; }
inline uint32_t exti_d3pcr1l_get_pcs11(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS11) >> 22 ; }
inline uint32_t exti_d3pcr1l_get_pcs10(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS10) >> 20 ; }
inline uint32_t exti_d3pcr1l_get_pcs9(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS9) >> 18 ; }
inline uint32_t exti_d3pcr1l_get_pcs8(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS8) >> 16 ; }
inline uint32_t exti_d3pcr1l_get_pcs7(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS7) >> 14 ; }
inline uint32_t exti_d3pcr1l_get_pcs6(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS6) >> 12 ; }
inline uint32_t exti_d3pcr1l_get_pcs5(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS5) >> 10 ; }
inline uint32_t exti_d3pcr1l_get_pcs4(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS4) >> 8 ; }
inline uint32_t exti_d3pcr1l_get_pcs3(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS3) >> 6 ; }
inline uint32_t exti_d3pcr1l_get_pcs2(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS2) >> 4 ; }
inline uint32_t exti_d3pcr1l_get_pcs1(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS1) >> 2 ; }
inline uint32_t exti_d3pcr1l_get_pcs0(struct EXTI_Type* p) { return (p->D3PCR1L & EXTI_D3PCR1L_PCS0) >> 0 ; }

// EXTI->D3PCR1H EXTI D3 pending clear selection register high
enum {
	EXTI_D3PCR1H_PCS25 = ((1UL<<2)-1) << 18, // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
	EXTI_D3PCR1H_PCS21 = ((1UL<<2)-1) << 10, // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
	EXTI_D3PCR1H_PCS20 = ((1UL<<2)-1) << 8, // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
	EXTI_D3PCR1H_PCS19 = ((1UL<<2)-1) << 6, // D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)		
};
inline void exti_d3pcr1h_set_pcs25(struct EXTI_Type* p, uint32_t val) { p->D3PCR1H = (p->D3PCR1H & ~EXTI_D3PCR1H_PCS25) | ((val<<18) & EXTI_D3PCR1H_PCS25); }
inline void exti_d3pcr1h_set_pcs21(struct EXTI_Type* p, uint32_t val) { p->D3PCR1H = (p->D3PCR1H & ~EXTI_D3PCR1H_PCS21) | ((val<<10) & EXTI_D3PCR1H_PCS21); }
inline void exti_d3pcr1h_set_pcs20(struct EXTI_Type* p, uint32_t val) { p->D3PCR1H = (p->D3PCR1H & ~EXTI_D3PCR1H_PCS20) | ((val<<8) & EXTI_D3PCR1H_PCS20); }
inline void exti_d3pcr1h_set_pcs19(struct EXTI_Type* p, uint32_t val) { p->D3PCR1H = (p->D3PCR1H & ~EXTI_D3PCR1H_PCS19) | ((val<<6) & EXTI_D3PCR1H_PCS19); }
inline uint32_t exti_d3pcr1h_get_pcs25(struct EXTI_Type* p) { return (p->D3PCR1H & EXTI_D3PCR1H_PCS25) >> 18 ; }
inline uint32_t exti_d3pcr1h_get_pcs21(struct EXTI_Type* p) { return (p->D3PCR1H & EXTI_D3PCR1H_PCS21) >> 10 ; }
inline uint32_t exti_d3pcr1h_get_pcs20(struct EXTI_Type* p) { return (p->D3PCR1H & EXTI_D3PCR1H_PCS20) >> 8 ; }
inline uint32_t exti_d3pcr1h_get_pcs19(struct EXTI_Type* p) { return (p->D3PCR1H & EXTI_D3PCR1H_PCS19) >> 6 ; }

// EXTI->RTSR2 EXTI rising trigger selection register
enum {
	EXTI_RTSR2_TR51 = 1UL<<19, // Rising trigger event configuration bit of Configurable Event input x+32
	EXTI_RTSR2_TR49 = 1UL<<17, // Rising trigger event configuration bit of Configurable Event input x+32		
};

// EXTI->FTSR2 EXTI falling trigger selection register
enum {
	EXTI_FTSR2_TR51 = 1UL<<19, // Falling trigger event configuration bit of Configurable Event input x+32
	EXTI_FTSR2_TR49 = 1UL<<17, // Falling trigger event configuration bit of Configurable Event input x+32		
};

// EXTI->SWIER2 EXTI software interrupt event register
enum {
	EXTI_SWIER2_SWIER51 = 1UL<<19, // Software interrupt on line x+32
	EXTI_SWIER2_SWIER49 = 1UL<<17, // Software interrupt on line x+32		
};

// EXTI->D3PMR2 EXTI D3 pending mask register
enum {
	EXTI_D3PMR2_MR53 = 1UL<<21, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR52 = 1UL<<20, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR51 = 1UL<<19, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR50 = 1UL<<18, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR49 = 1UL<<17, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR48 = 1UL<<16, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR41 = 1UL<<9, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR35 = 1UL<<3, // D3 Pending Mask on Event input x+32
	EXTI_D3PMR2_MR34 = 1UL<<2, // D3 Pending Mask on Event input x+32		
};

// EXTI->D3PCR2L EXTI D3 pending clear selection register low
enum {
	EXTI_D3PCR2L_PCS41 = ((1UL<<2)-1) << 18, // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
	EXTI_D3PCR2L_PCS35 = ((1UL<<2)-1) << 6, // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
	EXTI_D3PCR2L_PCS34 = ((1UL<<2)-1) << 4, // D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)		
};
inline void exti_d3pcr2l_set_pcs41(struct EXTI_Type* p, uint32_t val) { p->D3PCR2L = (p->D3PCR2L & ~EXTI_D3PCR2L_PCS41) | ((val<<18) & EXTI_D3PCR2L_PCS41); }
inline void exti_d3pcr2l_set_pcs35(struct EXTI_Type* p, uint32_t val) { p->D3PCR2L = (p->D3PCR2L & ~EXTI_D3PCR2L_PCS35) | ((val<<6) & EXTI_D3PCR2L_PCS35); }
inline void exti_d3pcr2l_set_pcs34(struct EXTI_Type* p, uint32_t val) { p->D3PCR2L = (p->D3PCR2L & ~EXTI_D3PCR2L_PCS34) | ((val<<4) & EXTI_D3PCR2L_PCS34); }
inline uint32_t exti_d3pcr2l_get_pcs41(struct EXTI_Type* p) { return (p->D3PCR2L & EXTI_D3PCR2L_PCS41) >> 18 ; }
inline uint32_t exti_d3pcr2l_get_pcs35(struct EXTI_Type* p) { return (p->D3PCR2L & EXTI_D3PCR2L_PCS35) >> 6 ; }
inline uint32_t exti_d3pcr2l_get_pcs34(struct EXTI_Type* p) { return (p->D3PCR2L & EXTI_D3PCR2L_PCS34) >> 4 ; }

// EXTI->D3PCR2H EXTI D3 pending clear selection register high
enum {
	EXTI_D3PCR2H_PCS53 = ((1UL<<2)-1) << 10, // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
	EXTI_D3PCR2H_PCS52 = ((1UL<<2)-1) << 8, // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
	EXTI_D3PCR2H_PCS51 = ((1UL<<2)-1) << 6, // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
	EXTI_D3PCR2H_PCS50 = ((1UL<<2)-1) << 4, // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
	EXTI_D3PCR2H_PCS49 = ((1UL<<2)-1) << 2, // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
	EXTI_D3PCR2H_PCS48 = ((1UL<<2)-1) << 0, // Pending request clear input signal selection on Event input x= truncate ((n+96)/2)		
};
inline void exti_d3pcr2h_set_pcs53(struct EXTI_Type* p, uint32_t val) { p->D3PCR2H = (p->D3PCR2H & ~EXTI_D3PCR2H_PCS53) | ((val<<10) & EXTI_D3PCR2H_PCS53); }
inline void exti_d3pcr2h_set_pcs52(struct EXTI_Type* p, uint32_t val) { p->D3PCR2H = (p->D3PCR2H & ~EXTI_D3PCR2H_PCS52) | ((val<<8) & EXTI_D3PCR2H_PCS52); }
inline void exti_d3pcr2h_set_pcs51(struct EXTI_Type* p, uint32_t val) { p->D3PCR2H = (p->D3PCR2H & ~EXTI_D3PCR2H_PCS51) | ((val<<6) & EXTI_D3PCR2H_PCS51); }
inline void exti_d3pcr2h_set_pcs50(struct EXTI_Type* p, uint32_t val) { p->D3PCR2H = (p->D3PCR2H & ~EXTI_D3PCR2H_PCS50) | ((val<<4) & EXTI_D3PCR2H_PCS50); }
inline void exti_d3pcr2h_set_pcs49(struct EXTI_Type* p, uint32_t val) { p->D3PCR2H = (p->D3PCR2H & ~EXTI_D3PCR2H_PCS49) | ((val<<2) & EXTI_D3PCR2H_PCS49); }
inline void exti_d3pcr2h_set_pcs48(struct EXTI_Type* p, uint32_t val) { p->D3PCR2H = (p->D3PCR2H & ~EXTI_D3PCR2H_PCS48) | ((val<<0) & EXTI_D3PCR2H_PCS48); }
inline uint32_t exti_d3pcr2h_get_pcs53(struct EXTI_Type* p) { return (p->D3PCR2H & EXTI_D3PCR2H_PCS53) >> 10 ; }
inline uint32_t exti_d3pcr2h_get_pcs52(struct EXTI_Type* p) { return (p->D3PCR2H & EXTI_D3PCR2H_PCS52) >> 8 ; }
inline uint32_t exti_d3pcr2h_get_pcs51(struct EXTI_Type* p) { return (p->D3PCR2H & EXTI_D3PCR2H_PCS51) >> 6 ; }
inline uint32_t exti_d3pcr2h_get_pcs50(struct EXTI_Type* p) { return (p->D3PCR2H & EXTI_D3PCR2H_PCS50) >> 4 ; }
inline uint32_t exti_d3pcr2h_get_pcs49(struct EXTI_Type* p) { return (p->D3PCR2H & EXTI_D3PCR2H_PCS49) >> 2 ; }
inline uint32_t exti_d3pcr2h_get_pcs48(struct EXTI_Type* p) { return (p->D3PCR2H & EXTI_D3PCR2H_PCS48) >> 0 ; }

// EXTI->RTSR3 EXTI rising trigger selection register
enum {
	EXTI_RTSR3_TR86 = 1UL<<22, // Rising trigger event configuration bit of Configurable Event input x+64
	EXTI_RTSR3_TR85 = 1UL<<21, // Rising trigger event configuration bit of Configurable Event input x+64
	EXTI_RTSR3_TR84 = 1UL<<20, // Rising trigger event configuration bit of Configurable Event input x+64
	EXTI_RTSR3_TR82 = 1UL<<18, // Rising trigger event configuration bit of Configurable Event input x+64		
};

// EXTI->FTSR3 EXTI falling trigger selection register
enum {
	EXTI_FTSR3_TR86 = 1UL<<22, // Falling trigger event configuration bit of Configurable Event input x+64
	EXTI_FTSR3_TR85 = 1UL<<21, // Falling trigger event configuration bit of Configurable Event input x+64
	EXTI_FTSR3_TR84 = 1UL<<20, // Falling trigger event configuration bit of Configurable Event input x+64
	EXTI_FTSR3_TR82 = 1UL<<18, // Falling trigger event configuration bit of Configurable Event input x+64		
};

// EXTI->SWIER3 EXTI software interrupt event register
enum {
	EXTI_SWIER3_SWIER86 = 1UL<<22, // Software interrupt on line x+64
	EXTI_SWIER3_SWIER85 = 1UL<<21, // Software interrupt on line x+64
	EXTI_SWIER3_SWIER84 = 1UL<<20, // Software interrupt on line x+64
	EXTI_SWIER3_SWIER82 = 1UL<<18, // Software interrupt on line x+64		
};

// EXTI->D3PMR3 EXTI D3 pending mask register
enum {
	EXTI_D3PMR3_MR88 = 1UL<<24, // D3 Pending Mask on Event input x+64		
};

// EXTI->D3PCR3H EXTI D3 pending clear selection register high
enum {
	EXTI_D3PCR3H_PCS88 = ((1UL<<2)-1) << 18, // D3 Pending request clear input signal selection on Event input x= truncate N+160/2		
};
inline void exti_d3pcr3h_set_pcs88(struct EXTI_Type* p, uint32_t val) { p->D3PCR3H = (p->D3PCR3H & ~EXTI_D3PCR3H_PCS88) | ((val<<18) & EXTI_D3PCR3H_PCS88); }
inline uint32_t exti_d3pcr3h_get_pcs88(struct EXTI_Type* p) { return (p->D3PCR3H & EXTI_D3PCR3H_PCS88) >> 18 ; }

// EXTI->CPUPR1 EXTI pending register
enum {
	EXTI_CPUPR1_PRX  = ((1UL<<22)-1) << 0, // Merged CPU Event mask on Event input x		
};
inline void exti_cpupr1_set_prx (struct EXTI_Type* p, uint32_t val) { p->CPUPR1 = (p->CPUPR1 & ~EXTI_CPUPR1_PRX ) | ((val<<0) & EXTI_CPUPR1_PRX ); }
inline uint32_t exti_cpupr1_get_prx (struct EXTI_Type* p) { return (p->CPUPR1 & EXTI_CPUPR1_PRX ) >> 0 ; }

// EXTI->CPUIMR2 EXTI interrupt mask register
enum {
	EXTI_CPUIMR2_MR31 = 1UL<<31, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR30 = 1UL<<30, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR29 = 1UL<<29, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR28 = 1UL<<28, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR27 = 1UL<<27, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR26 = 1UL<<26, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR25 = 1UL<<25, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR24 = 1UL<<24, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR23 = 1UL<<23, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR22 = 1UL<<22, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR21 = 1UL<<21, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR20 = 1UL<<20, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR19 = 1UL<<19, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR18 = 1UL<<18, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR17 = 1UL<<17, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR16 = 1UL<<16, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR15 = 1UL<<15, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR14 = 1UL<<14, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR12 = 1UL<<12, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR11 = 1UL<<11, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR10 = 1UL<<10, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR9 = 1UL<<9, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR8 = 1UL<<8, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR7 = 1UL<<7, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR6 = 1UL<<6, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR5 = 1UL<<5, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR4 = 1UL<<4, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR3 = 1UL<<3, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR2 = 1UL<<2, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR1 = 1UL<<1, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUIMR2_MR0 = 1UL<<0, // CPU Interrupt Mask on Direct Event input x+32		
};

// EXTI->CPUEMR2 EXTI event mask register
enum {
	EXTI_CPUEMR2_MR63 = 1UL<<31, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR62 = 1UL<<30, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR61 = 1UL<<29, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR60 = 1UL<<28, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR59 = 1UL<<27, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR58 = 1UL<<26, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR57 = 1UL<<25, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR56 = 1UL<<24, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR55 = 1UL<<23, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR54 = 1UL<<22, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR53 = 1UL<<21, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR52 = 1UL<<20, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR51 = 1UL<<19, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR50 = 1UL<<18, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR49 = 1UL<<17, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR48 = 1UL<<16, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR47 = 1UL<<15, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR46 = 1UL<<14, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR44 = 1UL<<12, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR43 = 1UL<<11, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR42 = 1UL<<10, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR41 = 1UL<<9, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR40 = 1UL<<8, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR39 = 1UL<<7, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR38 = 1UL<<6, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR37 = 1UL<<5, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR36 = 1UL<<4, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR35 = 1UL<<3, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR34 = 1UL<<2, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR33 = 1UL<<1, // CPU Interrupt Mask on Direct Event input x+32
	EXTI_CPUEMR2_MR32 = 1UL<<0, // CPU Interrupt Mask on Direct Event input x+32		
};

// EXTI->CPUPR2 EXTI pending register
enum {
	EXTI_CPUPR2_PR51 = 1UL<<19, // Configurable event inputs x+32 Pending bit
	EXTI_CPUPR2_PR49 = 1UL<<17, // Configurable event inputs x+32 Pending bit		
};

// EXTI->CPUIMR3 EXTI interrupt mask register
enum {
	EXTI_CPUIMR3_MR88 = 1UL<<24, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR87 = 1UL<<23, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR86 = 1UL<<22, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR85 = 1UL<<21, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR84 = 1UL<<20, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR82 = 1UL<<18, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR80 = 1UL<<16, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR79 = 1UL<<15, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR78 = 1UL<<14, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR77 = 1UL<<13, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR76 = 1UL<<12, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR75 = 1UL<<11, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR74 = 1UL<<10, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR73 = 1UL<<9, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR72 = 1UL<<8, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR71 = 1UL<<7, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR70 = 1UL<<6, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR69 = 1UL<<5, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR68 = 1UL<<4, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR67 = 1UL<<3, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR66 = 1UL<<2, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR65 = 1UL<<1, // CPU Interrupt Mask on Direct Event input x+64
	EXTI_CPUIMR3_MR64 = 1UL<<0, // CPU Interrupt Mask on Direct Event input x+64		
};

// EXTI->CPUEMR3 EXTI event mask register
enum {
	EXTI_CPUEMR3_MR88 = 1UL<<24, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR87 = 1UL<<23, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR86 = 1UL<<22, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR85 = 1UL<<21, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR84 = 1UL<<20, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR82 = 1UL<<18, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR80 = 1UL<<16, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR79 = 1UL<<15, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR78 = 1UL<<14, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR77 = 1UL<<13, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR76 = 1UL<<12, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR75 = 1UL<<11, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR74 = 1UL<<10, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR73 = 1UL<<9, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR72 = 1UL<<8, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR71 = 1UL<<7, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR70 = 1UL<<6, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR69 = 1UL<<5, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR68 = 1UL<<4, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR67 = 1UL<<3, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR66 = 1UL<<2, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR65 = 1UL<<1, // CPU Event mask on Event input x+64
	EXTI_CPUEMR3_MR64 = 1UL<<0, // CPU Event mask on Event input x+64		
};

// EXTI->CPUPR3 EXTI pending register
enum {
	EXTI_CPUPR3_PR86 = 1UL<<22, // Configurable event inputs x+64 Pending bit
	EXTI_CPUPR3_PR85 = 1UL<<21, // Configurable event inputs x+64 Pending bit
	EXTI_CPUPR3_PR84 = 1UL<<20, // Configurable event inputs x+64 Pending bit
	EXTI_CPUPR3_PR82 = 1UL<<18, // Configurable event inputs x+64 Pending bit		
};

/* Ethernet: media access control (MAC) */
struct Ethernet_MAC_Type {
	__IO uint32_t MACCR; // @0 Operating mode configuration register
	__IO uint32_t MACECR; // @4 Extended operating mode configuration register
	__IO uint32_t MACPFR; // @8 Packet filtering control register
	__IO uint16_t MACWTR; // @12 Watchdog timeout register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint32_t MACHT0R; // @16 Hash Table 0 register
	__IO uint32_t MACHT1R; // @20 Hash Table 1 register
	 uint8_t RESERVED1[56]; // @24 
	__IO uint32_t MACVTR; // @80 VLAN tag register
	 uint8_t RESERVED2[4]; // @84 
	__IO uint16_t MACVHTR; // @88 VLAN Hash table register
	 uint8_t RESERVED3[6]; // @90 
	__IO uint32_t MACVIR; // @96 VLAN inclusion register
	__IO uint32_t MACIVIR; // @100 Inner VLAN inclusion register
	 uint8_t RESERVED4[8]; // @104 
	__IO uint32_t MACQTxFCR; // @112 Tx Queue flow control register
	 uint8_t RESERVED5[28]; // @116 
	__IO uint8_t MACRxFCR; // @144 Rx flow control register
	 uint8_t RESERVED6[31]; // @145 
	__I uint16_t MACISR; // @176 Interrupt status register
	 uint8_t RESERVED7[2]; // @178 
	__IO uint16_t MACIER; // @180 Interrupt enable register
	 uint8_t RESERVED8[2]; // @182 
	__I uint16_t MACRxTxSR; // @184 Rx Tx status register
	 uint8_t RESERVED9[6]; // @186 
	__IO uint32_t MACPCSR; // @192 PMT control status register
	__IO uint32_t MACRWKPFR; // @196 Remove wakeup packet filter register
	 uint8_t RESERVED10[8]; // @200 
	__IO uint32_t MACLCSR; // @208 LPI control status register
	__IO uint32_t MACLTCR; // @212 LPI timers control register
	__IO uint32_t MACLETR; // @216 LPI entry timer register
	__IO uint16_t MAC1USTCR; // @220 1-microsecond-tick counter register
	 uint8_t RESERVED11[50]; // @222 
	__I uint16_t MACVR; // @272 Version register
	 uint8_t RESERVED12[2]; // @274 
	__I uint32_t MACDR; // @276 Debug register
	 uint8_t RESERVED13[8]; // @280 
	__I uint32_t MACHWF1R; // @288 HW feature 1 register
	__I uint32_t MACHWF2R; // @292 HW feature 2 register
	 uint8_t RESERVED14[216]; // @296 
	__IO uint32_t MACMDIOAR; // @512 MDIO address register
	__IO uint32_t MACMDIODR; // @516 MDIO data register
	 uint8_t RESERVED15[248]; // @520 
	__IO uint32_t MACA0HR; // @768 Address 0 high register
	__IO uint32_t MACA0LR; // @772 Address 0 low register
	__IO uint32_t MACA1HR; // @776 Address 1 high register
	__IO uint32_t MACA1LR; // @780 Address 1 low register
	__IO uint32_t MACA2HR; // @784 Address 2 high register
	__IO uint32_t MACA2LR; // @788 Address 2 low register
	__IO uint32_t MACA3HR; // @792 Address 3 high register
	__IO uint32_t MACA3LR; // @796 Address 3 low register
	 uint8_t RESERVED16[992]; // @800 
	__IO uint16_t MMC_CONTROL; // @1792 MMC control register
	 uint8_t RESERVED17[2]; // @1794 
	__I uint32_t MMC_RX_INTERRUPT; // @1796 MMC Rx interrupt register
	__I uint32_t MMC_TX_INTERRUPT; // @1800 MMC Tx interrupt register
	__IO uint32_t MMC_RX_INTERRUPT_MASK; // @1804 MMC Rx interrupt mask register
	__IO uint32_t MMC_TX_INTERRUPT_MASK; // @1808 MMC Tx interrupt mask register
	 uint8_t RESERVED18[56]; // @1812 
	__I uint32_t TX_SINGLE_COLLISION_GOOD_PACKETS; // @1868 Tx single collision good packets register
	__I uint32_t TX_MULTIPLE_COLLISION_GOOD_PACKETS; // @1872 Tx multiple collision good packets register
	 uint8_t RESERVED19[20]; // @1876 
	__I uint32_t TX_PACKET_COUNT_GOOD; // @1896 Tx packet count good register
	 uint8_t RESERVED20[40]; // @1900 
	__I uint32_t RX_CRC_ERROR_PACKETS; // @1940 Rx CRC error packets register
	__I uint32_t RX_ALIGNMENT_ERROR_PACKETS; // @1944 Rx alignment error packets register
	 uint8_t RESERVED21[40]; // @1948 
	__I uint32_t RX_UNICAST_PACKETS_GOOD; // @1988 Rx unicast packets good register
	 uint8_t RESERVED22[36]; // @1992 
	__I uint32_t TX_LPI_USEC_CNTR; // @2028 Tx LPI microsecond timer register
	__I uint32_t TX_LPI_TRAN_CNTR; // @2032 Tx LPI transition counter register
	__I uint32_t RX_LPI_USEC_CNTR; // @2036 Rx LPI microsecond counter register
	__I uint32_t RX_LPI_TRAN_CNTR; // @2040 Rx LPI transition counter register
	 uint8_t RESERVED23[260]; // @2044 
	__IO uint32_t MACL3L4C0R; // @2304 L3 and L4 control 0 register
	__IO uint32_t MACL4A0R; // @2308 Layer4 address filter 0 register
	 uint8_t RESERVED24[8]; // @2312 
	__IO uint32_t MACL3A00R; // @2320 MACL3A00R
	__IO uint32_t MACL3A10R; // @2324 Layer3 address 1 filter 0 register
	__IO uint32_t MACL3A20; // @2328 Layer3 Address 2 filter 0 register
	__IO uint32_t MACL3A30; // @2332 Layer3 Address 3 filter 0 register
	 uint8_t RESERVED25[16]; // @2336 
	__IO uint32_t MACL3L4C1R; // @2352 L3 and L4 control 1 register
	__IO uint32_t MACL4A1R; // @2356 Layer 4 address filter 1 register
	 uint8_t RESERVED26[8]; // @2360 
	__IO uint32_t MACL3A01R; // @2368 Layer3 address 0 filter 1 Register
	__IO uint32_t MACL3A11R; // @2372 Layer3 address 1 filter 1 register
	__IO uint32_t MACL3A21R; // @2376 Layer3 address 2 filter 1 Register
	__IO uint32_t MACL3A31R; // @2380 Layer3 address 3 filter 1 register
	 uint8_t RESERVED27[400]; // @2384 
	__IO uint32_t MACARPAR; // @2784 ARP address register
	 uint8_t RESERVED28[28]; // @2788 
	__IO uint32_t MACTSCR; // @2816 Timestamp control Register
	__IO uint32_t MACSSIR; // @2820 Sub-second increment register
	__I uint32_t MACSTSR; // @2824 System time seconds register
	__I uint32_t MACSTNR; // @2828 System time nanoseconds register
	__IO uint32_t MACSTSUR; // @2832 System time seconds update register
	__IO uint32_t MACSTNUR; // @2836 System time nanoseconds update register
	__IO uint32_t MACTSAR; // @2840 Timestamp addend register
	 uint8_t RESERVED29[4]; // @2844 
	__I uint32_t MACTSSR; // @2848 Timestamp status register
	 uint8_t RESERVED30[12]; // @2852 
	__I uint32_t MACTxTSSNR; // @2864 Tx timestamp status nanoseconds register
	__I uint32_t MACTxTSSSR; // @2868 Tx timestamp status seconds register
	 uint8_t RESERVED31[8]; // @2872 
	__IO uint8_t MACACR; // @2880 Auxiliary control register
	 uint8_t RESERVED32[7]; // @2881 
	__I uint32_t MACATSNR; // @2888 Auxiliary timestamp nanoseconds register
	__I uint32_t MACATSSR; // @2892 Auxiliary timestamp seconds register
	__IO uint32_t MACTSIACR; // @2896 Timestamp Ingress asymmetric correction register
	__IO uint32_t MACTSEACR; // @2900 Timestamp Egress asymmetric correction register
	__IO uint32_t MACTSICNR; // @2904 Timestamp Ingress correction nanosecond register
	__IO uint32_t MACTSECNR; // @2908 Timestamp Egress correction nanosecond register
	 uint8_t RESERVED33[16]; // @2912 
	__IO uint8_t MACPPSCR; // @2928 PPS control register
	 uint8_t RESERVED34[15]; // @2929 
	__IO uint32_t MACPPSTTSR; // @2944 PPS target time seconds register
	__IO uint32_t MACPPSTTNR; // @2948 PPS target time nanoseconds register
	__IO uint32_t MACPPSIR; // @2952 PPS interval register
	__IO uint32_t MACPPSWR; // @2956 PPS width register
	 uint8_t RESERVED35[48]; // @2960 
	__IO uint16_t MACPOCR; // @3008 PTP Offload control register
	 uint8_t RESERVED36[2]; // @3010 
	__IO uint32_t MACSPI0R; // @3012 PTP Source Port Identity 0 Register
	__IO uint32_t MACSPI1R; // @3016 PTP Source port identity 1 register
	__IO uint16_t MACSPI2R; // @3020 PTP Source port identity 2 register
	 uint8_t RESERVED37[2]; // @3022 
	__IO uint32_t MACLMIR; // @3024 Log message interval register
	 uint8_t RESERVED38[44]; // @3028 
	__IO uint16_t MTLOMR; // @3072 Operating mode Register
	 uint8_t RESERVED39[30]; // @3074 
	__I uint8_t MTLISR; // @3104 Interrupt status Register
	 uint8_t RESERVED40[223]; // @3105 
	__IO uint32_t MTLTxQOMR; // @3328 Tx queue operating mode Register
	__I uint16_t MTLTxQUR; // @3332 Tx queue underflow register
	 uint8_t RESERVED41[2]; // @3334 
	__I uint32_t MTLTxQDR; // @3336 Tx queue debug Register
	 uint8_t RESERVED42[32]; // @3340 
	__IO uint32_t MTLQICSR; // @3372 Queue interrupt control status Register
	__IO uint32_t MTLRxQOMR; // @3376 Rx queue operating mode register
	__I uint32_t MTLRxQMPOCR; // @3380 Rx queue missed packet and overflow counter register
	__I uint32_t MTLRxQDR; // @3384 Rx queue debug register
	 uint8_t RESERVED43[708]; // @3388 
	__IO uint32_t DMAMR; // @4096 DMA mode register
	__IO uint16_t DMASBMR; // @4100 System bus mode register
	 uint8_t RESERVED44[2]; // @4102 
	__I uint32_t DMAISR; // @4104 Interrupt status register
	__I uint16_t DMADSR; // @4108 Debug status register
	 uint8_t RESERVED45[242]; // @4110 
	__IO uint32_t DMACCR; // @4352 Channel control register
	__IO uint32_t DMACTxCR; // @4356 Channel transmit control register
	__IO uint32_t DMACRxCR; // @4360 Channel receive control register
	 uint8_t RESERVED46[8]; // @4364 
	__IO uint32_t DMACTxDLAR; // @4372 Channel Tx descriptor list address register
	 uint8_t RESERVED47[4]; // @4376 
	__IO uint32_t DMACRxDLAR; // @4380 Channel Rx descriptor list address register
	__IO uint32_t DMACTxDTPR; // @4384 Channel Tx descriptor tail pointer register
	 uint8_t RESERVED48[4]; // @4388 
	__IO uint32_t DMACRxDTPR; // @4392 Channel Rx descriptor tail pointer register
	__IO uint16_t DMACTxRLR; // @4396 Channel Tx descriptor ring length register
	 uint8_t RESERVED49[2]; // @4398 
	__IO uint16_t DMACRxRLR; // @4400 Channel Rx descriptor ring length register
	 uint8_t RESERVED50[2]; // @4402 
	__IO uint16_t DMACIER; // @4404 Channel interrupt enable register
	 uint8_t RESERVED51[2]; // @4406 
	__IO uint8_t DMACRxIWTR; // @4408 Channel Rx interrupt watchdog timer register
	 uint8_t RESERVED52[11]; // @4409 
	__I uint32_t DMACCATxDR; // @4420 Channel current application transmit descriptor register
	 uint8_t RESERVED53[4]; // @4424 
	__I uint32_t DMACCARxDR; // @4428 Channel current application receive descriptor register
	 uint8_t RESERVED54[4]; // @4432 
	__I uint32_t DMACCATxBR; // @4436 Channel current application transmit buffer register
	 uint8_t RESERVED55[4]; // @4440 
	__I uint32_t DMACCARxBR; // @4444 Channel current application receive buffer register
	__IO uint32_t DMACSR; // @4448 Channel status register
	 uint8_t RESERVED56[8]; // @4452 
	__I uint16_t DMACMFCR; // @4460 Channel missed frame count register
};

// Ethernet_MAC->MACCR Operating mode configuration register
enum {
	ETHERNET_MAC_MACCR_ARPEN = 1UL<<31, // ARPEN
	ETHERNET_MAC_MACCR_SARC = ((1UL<<3)-1) << 28, // SARC
	ETHERNET_MAC_MACCR_IPC = 1UL<<27, // IPC
	ETHERNET_MAC_MACCR_IPG = ((1UL<<3)-1) << 24, // IPG
	ETHERNET_MAC_MACCR_GPSLCE = 1UL<<23, // GPSLCE
	ETHERNET_MAC_MACCR_S2KP = 1UL<<22, // S2KP
	ETHERNET_MAC_MACCR_CST = 1UL<<21, // CST
	ETHERNET_MAC_MACCR_ACS = 1UL<<20, // ACS
	ETHERNET_MAC_MACCR_WD = 1UL<<19, // WD
	ETHERNET_MAC_MACCR_JD = 1UL<<17, // JD
	ETHERNET_MAC_MACCR_JE = 1UL<<16, // JE
	ETHERNET_MAC_MACCR_FES = 1UL<<14, // FES
	ETHERNET_MAC_MACCR_DM = 1UL<<13, // DM
	ETHERNET_MAC_MACCR_LM = 1UL<<12, // LM
	ETHERNET_MAC_MACCR_ECRSFD = 1UL<<11, // ECRSFD
	ETHERNET_MAC_MACCR_DO = 1UL<<10, // DO
	ETHERNET_MAC_MACCR_DCRS = 1UL<<9, // DCRS
	ETHERNET_MAC_MACCR_DR = 1UL<<8, // DR
	ETHERNET_MAC_MACCR_BL = ((1UL<<2)-1) << 5, // BL
	ETHERNET_MAC_MACCR_DC = 1UL<<4, // DC
	ETHERNET_MAC_MACCR_PRELEN = ((1UL<<2)-1) << 2, // PRELEN
	ETHERNET_MAC_MACCR_TE = 1UL<<1, // TE
	ETHERNET_MAC_MACCR_RE = 1UL<<0, // Receiver Enable		
};
inline void ethernet_mac_maccr_set_sarc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACCR = (p->MACCR & ~ETHERNET_MAC_MACCR_SARC) | ((val<<28) & ETHERNET_MAC_MACCR_SARC); }
inline void ethernet_mac_maccr_set_ipg(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACCR = (p->MACCR & ~ETHERNET_MAC_MACCR_IPG) | ((val<<24) & ETHERNET_MAC_MACCR_IPG); }
inline void ethernet_mac_maccr_set_bl(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACCR = (p->MACCR & ~ETHERNET_MAC_MACCR_BL) | ((val<<5) & ETHERNET_MAC_MACCR_BL); }
inline void ethernet_mac_maccr_set_prelen(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACCR = (p->MACCR & ~ETHERNET_MAC_MACCR_PRELEN) | ((val<<2) & ETHERNET_MAC_MACCR_PRELEN); }
inline uint32_t ethernet_mac_maccr_get_sarc(struct Ethernet_MAC_Type* p) { return (p->MACCR & ETHERNET_MAC_MACCR_SARC) >> 28 ; }
inline uint32_t ethernet_mac_maccr_get_ipg(struct Ethernet_MAC_Type* p) { return (p->MACCR & ETHERNET_MAC_MACCR_IPG) >> 24 ; }
inline uint32_t ethernet_mac_maccr_get_bl(struct Ethernet_MAC_Type* p) { return (p->MACCR & ETHERNET_MAC_MACCR_BL) >> 5 ; }
inline uint32_t ethernet_mac_maccr_get_prelen(struct Ethernet_MAC_Type* p) { return (p->MACCR & ETHERNET_MAC_MACCR_PRELEN) >> 2 ; }

// Ethernet_MAC->MACECR Extended operating mode configuration register
enum {
	ETHERNET_MAC_MACECR_EIPG = ((1UL<<5)-1) << 25, // EIPG
	ETHERNET_MAC_MACECR_EIPGEN = 1UL<<24, // EIPGEN
	ETHERNET_MAC_MACECR_USP = 1UL<<18, // USP
	ETHERNET_MAC_MACECR_SPEN = 1UL<<17, // SPEN
	ETHERNET_MAC_MACECR_DCRCC = 1UL<<16, // DCRCC
	ETHERNET_MAC_MACECR_GPSL = ((1UL<<14)-1) << 0, // GPSL		
};
inline void ethernet_mac_macecr_set_eipg(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACECR = (p->MACECR & ~ETHERNET_MAC_MACECR_EIPG) | ((val<<25) & ETHERNET_MAC_MACECR_EIPG); }
inline void ethernet_mac_macecr_set_gpsl(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACECR = (p->MACECR & ~ETHERNET_MAC_MACECR_GPSL) | ((val<<0) & ETHERNET_MAC_MACECR_GPSL); }
inline uint32_t ethernet_mac_macecr_get_eipg(struct Ethernet_MAC_Type* p) { return (p->MACECR & ETHERNET_MAC_MACECR_EIPG) >> 25 ; }
inline uint32_t ethernet_mac_macecr_get_gpsl(struct Ethernet_MAC_Type* p) { return (p->MACECR & ETHERNET_MAC_MACECR_GPSL) >> 0 ; }

// Ethernet_MAC->MACPFR Packet filtering control register
enum {
	ETHERNET_MAC_MACPFR_RA = 1UL<<31, // RA
	ETHERNET_MAC_MACPFR_DNTU = 1UL<<21, // DNTU
	ETHERNET_MAC_MACPFR_IPFE = 1UL<<20, // IPFE
	ETHERNET_MAC_MACPFR_VTFE = 1UL<<16, // VTFE
	ETHERNET_MAC_MACPFR_HPF = 1UL<<10, // HPF
	ETHERNET_MAC_MACPFR_SAF = 1UL<<9, // SAF
	ETHERNET_MAC_MACPFR_SAIF = 1UL<<8, // SAIF
	ETHERNET_MAC_MACPFR_PCF = ((1UL<<2)-1) << 6, // PCF
	ETHERNET_MAC_MACPFR_DBF = 1UL<<5, // DBF
	ETHERNET_MAC_MACPFR_PM = 1UL<<4, // PM
	ETHERNET_MAC_MACPFR_DAIF = 1UL<<3, // DAIF
	ETHERNET_MAC_MACPFR_HMC = 1UL<<2, // HMC
	ETHERNET_MAC_MACPFR_HUC = 1UL<<1, // HUC
	ETHERNET_MAC_MACPFR_PR = 1UL<<0, // PR		
};
inline void ethernet_mac_macpfr_set_pcf(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPFR = (p->MACPFR & ~ETHERNET_MAC_MACPFR_PCF) | ((val<<6) & ETHERNET_MAC_MACPFR_PCF); }
inline uint32_t ethernet_mac_macpfr_get_pcf(struct Ethernet_MAC_Type* p) { return (p->MACPFR & ETHERNET_MAC_MACPFR_PCF) >> 6 ; }

// Ethernet_MAC->MACWTR Watchdog timeout register
enum {
	ETHERNET_MAC_MACWTR_PWE = 1UL<<8, // PWE
	ETHERNET_MAC_MACWTR_WTO = ((1UL<<4)-1) << 0, // WTO		
};
inline void ethernet_mac_macwtr_set_wto(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACWTR = (p->MACWTR & ~ETHERNET_MAC_MACWTR_WTO) | ((val<<0) & ETHERNET_MAC_MACWTR_WTO); }
inline uint32_t ethernet_mac_macwtr_get_wto(struct Ethernet_MAC_Type* p) { return (p->MACWTR & ETHERNET_MAC_MACWTR_WTO) >> 0 ; }

// Ethernet_MAC->MACVTR VLAN tag register
enum {
	ETHERNET_MAC_MACVTR_EIVLRXS = 1UL<<31, // EIVLRXS
	ETHERNET_MAC_MACVTR_EIVLS = ((1UL<<2)-1) << 28, // EIVLS
	ETHERNET_MAC_MACVTR_ERIVLT = 1UL<<27, // ERIVLT
	ETHERNET_MAC_MACVTR_EDVLP = 1UL<<26, // EDVLP
	ETHERNET_MAC_MACVTR_VTHM = 1UL<<25, // VTHM
	ETHERNET_MAC_MACVTR_EVLRXS = 1UL<<24, // EVLRXS
	ETHERNET_MAC_MACVTR_EVLS = ((1UL<<2)-1) << 21, // EVLS
	ETHERNET_MAC_MACVTR_DOVLTC = 1UL<<20, // DOVLTC
	ETHERNET_MAC_MACVTR_ERSVLM = 1UL<<19, // ERSVLM
	ETHERNET_MAC_MACVTR_ESVL = 1UL<<18, // ESVL
	ETHERNET_MAC_MACVTR_VTIM = 1UL<<17, // VTIM
	ETHERNET_MAC_MACVTR_ETV = 1UL<<16, // ETV
	ETHERNET_MAC_MACVTR_VL = ((1UL<<16)-1) << 0, // VL		
};
inline void ethernet_mac_macvtr_set_eivls(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACVTR = (p->MACVTR & ~ETHERNET_MAC_MACVTR_EIVLS) | ((val<<28) & ETHERNET_MAC_MACVTR_EIVLS); }
inline void ethernet_mac_macvtr_set_evls(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACVTR = (p->MACVTR & ~ETHERNET_MAC_MACVTR_EVLS) | ((val<<21) & ETHERNET_MAC_MACVTR_EVLS); }
inline void ethernet_mac_macvtr_set_vl(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACVTR = (p->MACVTR & ~ETHERNET_MAC_MACVTR_VL) | ((val<<0) & ETHERNET_MAC_MACVTR_VL); }
inline uint32_t ethernet_mac_macvtr_get_eivls(struct Ethernet_MAC_Type* p) { return (p->MACVTR & ETHERNET_MAC_MACVTR_EIVLS) >> 28 ; }
inline uint32_t ethernet_mac_macvtr_get_evls(struct Ethernet_MAC_Type* p) { return (p->MACVTR & ETHERNET_MAC_MACVTR_EVLS) >> 21 ; }
inline uint32_t ethernet_mac_macvtr_get_vl(struct Ethernet_MAC_Type* p) { return (p->MACVTR & ETHERNET_MAC_MACVTR_VL) >> 0 ; }

// Ethernet_MAC->MACVIR VLAN inclusion register
enum {
	ETHERNET_MAC_MACVIR_VLTI = 1UL<<20, // VLTI
	ETHERNET_MAC_MACVIR_CSVL = 1UL<<19, // CSVL
	ETHERNET_MAC_MACVIR_VLP = 1UL<<18, // VLP
	ETHERNET_MAC_MACVIR_VLC = ((1UL<<2)-1) << 16, // VLC
	ETHERNET_MAC_MACVIR_VLT = ((1UL<<16)-1) << 0, // VLT		
};
inline void ethernet_mac_macvir_set_vlc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACVIR = (p->MACVIR & ~ETHERNET_MAC_MACVIR_VLC) | ((val<<16) & ETHERNET_MAC_MACVIR_VLC); }
inline void ethernet_mac_macvir_set_vlt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACVIR = (p->MACVIR & ~ETHERNET_MAC_MACVIR_VLT) | ((val<<0) & ETHERNET_MAC_MACVIR_VLT); }
inline uint32_t ethernet_mac_macvir_get_vlc(struct Ethernet_MAC_Type* p) { return (p->MACVIR & ETHERNET_MAC_MACVIR_VLC) >> 16 ; }
inline uint32_t ethernet_mac_macvir_get_vlt(struct Ethernet_MAC_Type* p) { return (p->MACVIR & ETHERNET_MAC_MACVIR_VLT) >> 0 ; }

// Ethernet_MAC->MACIVIR Inner VLAN inclusion register
enum {
	ETHERNET_MAC_MACIVIR_VLTI = 1UL<<20, // VLTI
	ETHERNET_MAC_MACIVIR_CSVL = 1UL<<19, // CSVL
	ETHERNET_MAC_MACIVIR_VLP = 1UL<<18, // VLP
	ETHERNET_MAC_MACIVIR_VLC = ((1UL<<2)-1) << 16, // VLC
	ETHERNET_MAC_MACIVIR_VLT = ((1UL<<16)-1) << 0, // VLT		
};
inline void ethernet_mac_macivir_set_vlc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACIVIR = (p->MACIVIR & ~ETHERNET_MAC_MACIVIR_VLC) | ((val<<16) & ETHERNET_MAC_MACIVIR_VLC); }
inline void ethernet_mac_macivir_set_vlt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACIVIR = (p->MACIVIR & ~ETHERNET_MAC_MACIVIR_VLT) | ((val<<0) & ETHERNET_MAC_MACIVIR_VLT); }
inline uint32_t ethernet_mac_macivir_get_vlc(struct Ethernet_MAC_Type* p) { return (p->MACIVIR & ETHERNET_MAC_MACIVIR_VLC) >> 16 ; }
inline uint32_t ethernet_mac_macivir_get_vlt(struct Ethernet_MAC_Type* p) { return (p->MACIVIR & ETHERNET_MAC_MACIVIR_VLT) >> 0 ; }

// Ethernet_MAC->MACQTxFCR Tx Queue flow control register
enum {
	ETHERNET_MAC_MACQTXFCR_PT = ((1UL<<16)-1) << 16, // PT
	ETHERNET_MAC_MACQTXFCR_DZPQ = 1UL<<7, // DZPQ
	ETHERNET_MAC_MACQTXFCR_PLT = ((1UL<<3)-1) << 4, // PLT
	ETHERNET_MAC_MACQTXFCR_TFE = 1UL<<1, // TFE
	ETHERNET_MAC_MACQTXFCR_FCB_BPA = 1UL<<0, // FCB_BPA		
};
inline void ethernet_mac_macqtxfcr_set_pt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACQTxFCR = (p->MACQTxFCR & ~ETHERNET_MAC_MACQTXFCR_PT) | ((val<<16) & ETHERNET_MAC_MACQTXFCR_PT); }
inline void ethernet_mac_macqtxfcr_set_plt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACQTxFCR = (p->MACQTxFCR & ~ETHERNET_MAC_MACQTXFCR_PLT) | ((val<<4) & ETHERNET_MAC_MACQTXFCR_PLT); }
inline uint32_t ethernet_mac_macqtxfcr_get_pt(struct Ethernet_MAC_Type* p) { return (p->MACQTxFCR & ETHERNET_MAC_MACQTXFCR_PT) >> 16 ; }
inline uint32_t ethernet_mac_macqtxfcr_get_plt(struct Ethernet_MAC_Type* p) { return (p->MACQTxFCR & ETHERNET_MAC_MACQTXFCR_PLT) >> 4 ; }

// Ethernet_MAC->MACRxFCR Rx flow control register
enum {
	ETHERNET_MAC_MACRXFCR_UP = 1UL<<1, // UP
	ETHERNET_MAC_MACRXFCR_RFE = 1UL<<0, // RFE		
};

// Ethernet_MAC->MACISR Interrupt status register
enum {
	ETHERNET_MAC_MACISR_RXSTSIS = 1UL<<14, // RXSTSIS
	ETHERNET_MAC_MACISR_TXSTSIS = 1UL<<13, // TXSTSIS
	ETHERNET_MAC_MACISR_TSIS = 1UL<<12, // TSIS
	ETHERNET_MAC_MACISR_MMCTXIS = 1UL<<10, // MMCTXIS
	ETHERNET_MAC_MACISR_MMCRXIS = 1UL<<9, // MMCRXIS
	ETHERNET_MAC_MACISR_MMCIS = 1UL<<8, // MMCIS
	ETHERNET_MAC_MACISR_LPIIS = 1UL<<5, // LPIIS
	ETHERNET_MAC_MACISR_PMTIS = 1UL<<4, // PMTIS
	ETHERNET_MAC_MACISR_PHYIS = 1UL<<3, // PHYIS		
};

// Ethernet_MAC->MACIER Interrupt enable register
enum {
	ETHERNET_MAC_MACIER_RXSTSIE = 1UL<<14, // RXSTSIE
	ETHERNET_MAC_MACIER_TXSTSIE = 1UL<<13, // TXSTSIE
	ETHERNET_MAC_MACIER_TSIE = 1UL<<12, // TSIE
	ETHERNET_MAC_MACIER_LPIIE = 1UL<<5, // LPIIE
	ETHERNET_MAC_MACIER_PMTIE = 1UL<<4, // PMTIE
	ETHERNET_MAC_MACIER_PHYIE = 1UL<<3, // PHYIE		
};

// Ethernet_MAC->MACRxTxSR Rx Tx status register
enum {
	ETHERNET_MAC_MACRXTXSR_RWT = 1UL<<8, // RWT
	ETHERNET_MAC_MACRXTXSR_EXCOL = 1UL<<5, // LCOL
	ETHERNET_MAC_MACRXTXSR_LCOL = 1UL<<4, // LCOL
	ETHERNET_MAC_MACRXTXSR_EXDEF = 1UL<<3, // EXDEF
	ETHERNET_MAC_MACRXTXSR_LCARR = 1UL<<2, // LCARR
	ETHERNET_MAC_MACRXTXSR_NCARR = 1UL<<1, // NCARR
	ETHERNET_MAC_MACRXTXSR_TJT = 1UL<<0, // TJT		
};

// Ethernet_MAC->MACPCSR PMT control status register
enum {
	ETHERNET_MAC_MACPCSR_RWKFILTRST = 1UL<<31, // RWKFILTRST
	ETHERNET_MAC_MACPCSR_RWKPTR = ((1UL<<5)-1) << 24, // RWKPTR
	ETHERNET_MAC_MACPCSR_RWKPFE = 1UL<<10, // RWKPFE
	ETHERNET_MAC_MACPCSR_GLBLUCAST = 1UL<<9, // GLBLUCAST
	ETHERNET_MAC_MACPCSR_RWKPRCVD = 1UL<<6, // RWKPRCVD
	ETHERNET_MAC_MACPCSR_MGKPRCVD = 1UL<<5, // MGKPRCVD
	ETHERNET_MAC_MACPCSR_RWKPKTEN = 1UL<<2, // RWKPKTEN
	ETHERNET_MAC_MACPCSR_MGKPKTEN = 1UL<<1, // MGKPKTEN
	ETHERNET_MAC_MACPCSR_PWRDWN = 1UL<<0, // PWRDWN		
};
inline void ethernet_mac_macpcsr_set_rwkptr(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPCSR = (p->MACPCSR & ~ETHERNET_MAC_MACPCSR_RWKPTR) | ((val<<24) & ETHERNET_MAC_MACPCSR_RWKPTR); }
inline uint32_t ethernet_mac_macpcsr_get_rwkptr(struct Ethernet_MAC_Type* p) { return (p->MACPCSR & ETHERNET_MAC_MACPCSR_RWKPTR) >> 24 ; }

// Ethernet_MAC->MACLCSR LPI control status register
enum {
	ETHERNET_MAC_MACLCSR_LPITCSE = 1UL<<21, // LPITCSE
	ETHERNET_MAC_MACLCSR_LPITE = 1UL<<20, // LPITE
	ETHERNET_MAC_MACLCSR_LPITXA = 1UL<<19, // LPITXA
	ETHERNET_MAC_MACLCSR_PLSEN = 1UL<<18, // PLSEN
	ETHERNET_MAC_MACLCSR_PLS = 1UL<<17, // PLS
	ETHERNET_MAC_MACLCSR_LPIEN = 1UL<<16, // LPIEN
	ETHERNET_MAC_MACLCSR_RLPIST = 1UL<<9, // RLPIST
	ETHERNET_MAC_MACLCSR_TLPIST = 1UL<<8, // TLPIST
	ETHERNET_MAC_MACLCSR_RLPIEX = 1UL<<3, // RLPIEX
	ETHERNET_MAC_MACLCSR_RLPIEN = 1UL<<2, // RLPIEN
	ETHERNET_MAC_MACLCSR_TLPIEX = 1UL<<1, // TLPIEX
	ETHERNET_MAC_MACLCSR_TLPIEN = 1UL<<0, // TLPIEN		
};

// Ethernet_MAC->MACLTCR LPI timers control register
enum {
	ETHERNET_MAC_MACLTCR_LST = ((1UL<<10)-1) << 16, // LST
	ETHERNET_MAC_MACLTCR_TWT = ((1UL<<16)-1) << 0, // TWT		
};
inline void ethernet_mac_macltcr_set_lst(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACLTCR = (p->MACLTCR & ~ETHERNET_MAC_MACLTCR_LST) | ((val<<16) & ETHERNET_MAC_MACLTCR_LST); }
inline void ethernet_mac_macltcr_set_twt(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACLTCR = (p->MACLTCR & ~ETHERNET_MAC_MACLTCR_TWT) | ((val<<0) & ETHERNET_MAC_MACLTCR_TWT); }
inline uint32_t ethernet_mac_macltcr_get_lst(struct Ethernet_MAC_Type* p) { return (p->MACLTCR & ETHERNET_MAC_MACLTCR_LST) >> 16 ; }
inline uint32_t ethernet_mac_macltcr_get_twt(struct Ethernet_MAC_Type* p) { return (p->MACLTCR & ETHERNET_MAC_MACLTCR_TWT) >> 0 ; }

// Ethernet_MAC->MACLETR LPI entry timer register
enum {
	ETHERNET_MAC_MACLETR_LPIET = ((1UL<<17)-1) << 0, // LPIET		
};
inline void ethernet_mac_macletr_set_lpiet(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACLETR = (p->MACLETR & ~ETHERNET_MAC_MACLETR_LPIET) | ((val<<0) & ETHERNET_MAC_MACLETR_LPIET); }
inline uint32_t ethernet_mac_macletr_get_lpiet(struct Ethernet_MAC_Type* p) { return (p->MACLETR & ETHERNET_MAC_MACLETR_LPIET) >> 0 ; }

// Ethernet_MAC->MAC1USTCR 1-microsecond-tick counter register
enum {
	ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR = ((1UL<<12)-1) << 0, // TIC_1US_CNTR		
};
inline void ethernet_mac_mac1ustcr_set_tic_1us_cntr(struct Ethernet_MAC_Type* p, uint32_t val) { p->MAC1USTCR = (p->MAC1USTCR & ~ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR) | ((val<<0) & ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR); }
inline uint32_t ethernet_mac_mac1ustcr_get_tic_1us_cntr(struct Ethernet_MAC_Type* p) { return (p->MAC1USTCR & ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR) >> 0 ; }

// Ethernet_MAC->MACVR Version register
enum {
	ETHERNET_MAC_MACVR_USERVER = ((1UL<<8)-1) << 8, // USERVER
	ETHERNET_MAC_MACVR_SNPSVER = ((1UL<<8)-1) << 0, // SNPSVER		
};
inline uint32_t ethernet_mac_macvr_get_userver(struct Ethernet_MAC_Type* p) { return (p->MACVR & ETHERNET_MAC_MACVR_USERVER) >> 8 ; }
inline uint32_t ethernet_mac_macvr_get_snpsver(struct Ethernet_MAC_Type* p) { return (p->MACVR & ETHERNET_MAC_MACVR_SNPSVER) >> 0 ; }

// Ethernet_MAC->MACDR Debug register
enum {
	ETHERNET_MAC_MACDR_TFCSTS = ((1UL<<2)-1) << 17, // TFCSTS
	ETHERNET_MAC_MACDR_TPESTS = 1UL<<16, // TPESTS
	ETHERNET_MAC_MACDR_RFCFCSTS = ((1UL<<2)-1) << 1, // RFCFCSTS
	ETHERNET_MAC_MACDR_RPESTS = 1UL<<0, // RPESTS		
};
inline uint32_t ethernet_mac_macdr_get_tfcsts(struct Ethernet_MAC_Type* p) { return (p->MACDR & ETHERNET_MAC_MACDR_TFCSTS) >> 17 ; }
inline uint32_t ethernet_mac_macdr_get_rfcfcsts(struct Ethernet_MAC_Type* p) { return (p->MACDR & ETHERNET_MAC_MACDR_RFCFCSTS) >> 1 ; }

// Ethernet_MAC->MACHWF1R HW feature 1 register
enum {
	ETHERNET_MAC_MACHWF1R_L3L4FNUM = ((1UL<<4)-1) << 27, // L3L4FNUM
	ETHERNET_MAC_MACHWF1R_HASHTBLSZ = ((1UL<<2)-1) << 24, // HASHTBLSZ
	ETHERNET_MAC_MACHWF1R_AVSEL = 1UL<<20, // AVSEL
	ETHERNET_MAC_MACHWF1R_DBGMEMA = 1UL<<19, // DBGMEMA
	ETHERNET_MAC_MACHWF1R_TSOEN = 1UL<<18, // TSOEN
	ETHERNET_MAC_MACHWF1R_SPHEN = 1UL<<17, // SPHEN
	ETHERNET_MAC_MACHWF1R_DCBEN = 1UL<<16, // DCBEN
	ETHERNET_MAC_MACHWF1R_ADVTHWORD = 1UL<<13, // ADVTHWORD
	ETHERNET_MAC_MACHWF1R_PTOEN = 1UL<<12, // PTOEN
	ETHERNET_MAC_MACHWF1R_OSTEN = 1UL<<11, // OSTEN
	ETHERNET_MAC_MACHWF1R_TXFIFOSIZE = ((1UL<<5)-1) << 6, // TXFIFOSIZE
	ETHERNET_MAC_MACHWF1R_RXFIFOSIZE = ((1UL<<5)-1) << 0, // RXFIFOSIZE		
};
inline uint32_t ethernet_mac_machwf1r_get_l3l4fnum(struct Ethernet_MAC_Type* p) { return (p->MACHWF1R & ETHERNET_MAC_MACHWF1R_L3L4FNUM) >> 27 ; }
inline uint32_t ethernet_mac_machwf1r_get_hashtblsz(struct Ethernet_MAC_Type* p) { return (p->MACHWF1R & ETHERNET_MAC_MACHWF1R_HASHTBLSZ) >> 24 ; }
inline uint32_t ethernet_mac_machwf1r_get_txfifosize(struct Ethernet_MAC_Type* p) { return (p->MACHWF1R & ETHERNET_MAC_MACHWF1R_TXFIFOSIZE) >> 6 ; }
inline uint32_t ethernet_mac_machwf1r_get_rxfifosize(struct Ethernet_MAC_Type* p) { return (p->MACHWF1R & ETHERNET_MAC_MACHWF1R_RXFIFOSIZE) >> 0 ; }

// Ethernet_MAC->MACHWF2R HW feature 2 register
enum {
	ETHERNET_MAC_MACHWF2R_AUXSNAPNUM = ((1UL<<3)-1) << 28, // AUXSNAPNUM
	ETHERNET_MAC_MACHWF2R_PPSOUTNUM = ((1UL<<3)-1) << 24, // PPSOUTNUM
	ETHERNET_MAC_MACHWF2R_TXCHCNT = ((1UL<<4)-1) << 18, // TXCHCNT
	ETHERNET_MAC_MACHWF2R_RXCHCNT = ((1UL<<4)-1) << 12, // RXCHCNT
	ETHERNET_MAC_MACHWF2R_TXQCNT = ((1UL<<4)-1) << 6, // TXQCNT
	ETHERNET_MAC_MACHWF2R_RXQCNT = ((1UL<<4)-1) << 0, // RXQCNT		
};
inline uint32_t ethernet_mac_machwf2r_get_auxsnapnum(struct Ethernet_MAC_Type* p) { return (p->MACHWF2R & ETHERNET_MAC_MACHWF2R_AUXSNAPNUM) >> 28 ; }
inline uint32_t ethernet_mac_machwf2r_get_ppsoutnum(struct Ethernet_MAC_Type* p) { return (p->MACHWF2R & ETHERNET_MAC_MACHWF2R_PPSOUTNUM) >> 24 ; }
inline uint32_t ethernet_mac_machwf2r_get_txchcnt(struct Ethernet_MAC_Type* p) { return (p->MACHWF2R & ETHERNET_MAC_MACHWF2R_TXCHCNT) >> 18 ; }
inline uint32_t ethernet_mac_machwf2r_get_rxchcnt(struct Ethernet_MAC_Type* p) { return (p->MACHWF2R & ETHERNET_MAC_MACHWF2R_RXCHCNT) >> 12 ; }
inline uint32_t ethernet_mac_machwf2r_get_txqcnt(struct Ethernet_MAC_Type* p) { return (p->MACHWF2R & ETHERNET_MAC_MACHWF2R_TXQCNT) >> 6 ; }
inline uint32_t ethernet_mac_machwf2r_get_rxqcnt(struct Ethernet_MAC_Type* p) { return (p->MACHWF2R & ETHERNET_MAC_MACHWF2R_RXQCNT) >> 0 ; }

// Ethernet_MAC->MACMDIOAR MDIO address register
enum {
	ETHERNET_MAC_MACMDIOAR_PSE = 1UL<<27, // PSE
	ETHERNET_MAC_MACMDIOAR_BTB = 1UL<<26, // BTB
	ETHERNET_MAC_MACMDIOAR_PA = ((1UL<<5)-1) << 21, // PA
	ETHERNET_MAC_MACMDIOAR_RDA = ((1UL<<5)-1) << 16, // RDA
	ETHERNET_MAC_MACMDIOAR_NTC = ((1UL<<3)-1) << 12, // NTC
	ETHERNET_MAC_MACMDIOAR_CR = ((1UL<<4)-1) << 8, // CR
	ETHERNET_MAC_MACMDIOAR_SKAP = 1UL<<4, // SKAP
	ETHERNET_MAC_MACMDIOAR_GOC = ((1UL<<2)-1) << 2, // GOC
	ETHERNET_MAC_MACMDIOAR_C45E = 1UL<<1, // C45E
	ETHERNET_MAC_MACMDIOAR_MB = 1UL<<0, // MB		
};
inline void ethernet_mac_macmdioar_set_pa(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIOAR = (p->MACMDIOAR & ~ETHERNET_MAC_MACMDIOAR_PA) | ((val<<21) & ETHERNET_MAC_MACMDIOAR_PA); }
inline void ethernet_mac_macmdioar_set_rda(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIOAR = (p->MACMDIOAR & ~ETHERNET_MAC_MACMDIOAR_RDA) | ((val<<16) & ETHERNET_MAC_MACMDIOAR_RDA); }
inline void ethernet_mac_macmdioar_set_ntc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIOAR = (p->MACMDIOAR & ~ETHERNET_MAC_MACMDIOAR_NTC) | ((val<<12) & ETHERNET_MAC_MACMDIOAR_NTC); }
inline void ethernet_mac_macmdioar_set_cr(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIOAR = (p->MACMDIOAR & ~ETHERNET_MAC_MACMDIOAR_CR) | ((val<<8) & ETHERNET_MAC_MACMDIOAR_CR); }
inline void ethernet_mac_macmdioar_set_goc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIOAR = (p->MACMDIOAR & ~ETHERNET_MAC_MACMDIOAR_GOC) | ((val<<2) & ETHERNET_MAC_MACMDIOAR_GOC); }
inline uint32_t ethernet_mac_macmdioar_get_pa(struct Ethernet_MAC_Type* p) { return (p->MACMDIOAR & ETHERNET_MAC_MACMDIOAR_PA) >> 21 ; }
inline uint32_t ethernet_mac_macmdioar_get_rda(struct Ethernet_MAC_Type* p) { return (p->MACMDIOAR & ETHERNET_MAC_MACMDIOAR_RDA) >> 16 ; }
inline uint32_t ethernet_mac_macmdioar_get_ntc(struct Ethernet_MAC_Type* p) { return (p->MACMDIOAR & ETHERNET_MAC_MACMDIOAR_NTC) >> 12 ; }
inline uint32_t ethernet_mac_macmdioar_get_cr(struct Ethernet_MAC_Type* p) { return (p->MACMDIOAR & ETHERNET_MAC_MACMDIOAR_CR) >> 8 ; }
inline uint32_t ethernet_mac_macmdioar_get_goc(struct Ethernet_MAC_Type* p) { return (p->MACMDIOAR & ETHERNET_MAC_MACMDIOAR_GOC) >> 2 ; }

// Ethernet_MAC->MACMDIODR MDIO data register
enum {
	ETHERNET_MAC_MACMDIODR_RA = ((1UL<<16)-1) << 16, // RA
	ETHERNET_MAC_MACMDIODR_MD = ((1UL<<16)-1) << 0, // MD		
};
inline void ethernet_mac_macmdiodr_set_ra(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIODR = (p->MACMDIODR & ~ETHERNET_MAC_MACMDIODR_RA) | ((val<<16) & ETHERNET_MAC_MACMDIODR_RA); }
inline void ethernet_mac_macmdiodr_set_md(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACMDIODR = (p->MACMDIODR & ~ETHERNET_MAC_MACMDIODR_MD) | ((val<<0) & ETHERNET_MAC_MACMDIODR_MD); }
inline uint32_t ethernet_mac_macmdiodr_get_ra(struct Ethernet_MAC_Type* p) { return (p->MACMDIODR & ETHERNET_MAC_MACMDIODR_RA) >> 16 ; }
inline uint32_t ethernet_mac_macmdiodr_get_md(struct Ethernet_MAC_Type* p) { return (p->MACMDIODR & ETHERNET_MAC_MACMDIODR_MD) >> 0 ; }

// Ethernet_MAC->MACA0HR Address 0 high register
enum {
	ETHERNET_MAC_MACA0HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA0HR_ADDRHI = ((1UL<<16)-1) << 0, // ADDRHI		
};
inline void ethernet_mac_maca0hr_set_addrhi(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA0HR = (p->MACA0HR & ~ETHERNET_MAC_MACA0HR_ADDRHI) | ((val<<0) & ETHERNET_MAC_MACA0HR_ADDRHI); }
inline uint32_t ethernet_mac_maca0hr_get_addrhi(struct Ethernet_MAC_Type* p) { return (p->MACA0HR & ETHERNET_MAC_MACA0HR_ADDRHI) >> 0 ; }

// Ethernet_MAC->MACA1HR Address 1 high register
enum {
	ETHERNET_MAC_MACA1HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA1HR_SA = 1UL<<30, // SA
	ETHERNET_MAC_MACA1HR_MBC = ((1UL<<6)-1) << 24, // MBC
	ETHERNET_MAC_MACA1HR_ADDRHI = ((1UL<<16)-1) << 0, // ADDRHI		
};
inline void ethernet_mac_maca1hr_set_mbc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA1HR = (p->MACA1HR & ~ETHERNET_MAC_MACA1HR_MBC) | ((val<<24) & ETHERNET_MAC_MACA1HR_MBC); }
inline void ethernet_mac_maca1hr_set_addrhi(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA1HR = (p->MACA1HR & ~ETHERNET_MAC_MACA1HR_ADDRHI) | ((val<<0) & ETHERNET_MAC_MACA1HR_ADDRHI); }
inline uint32_t ethernet_mac_maca1hr_get_mbc(struct Ethernet_MAC_Type* p) { return (p->MACA1HR & ETHERNET_MAC_MACA1HR_MBC) >> 24 ; }
inline uint32_t ethernet_mac_maca1hr_get_addrhi(struct Ethernet_MAC_Type* p) { return (p->MACA1HR & ETHERNET_MAC_MACA1HR_ADDRHI) >> 0 ; }

// Ethernet_MAC->MACA2HR Address 2 high register
enum {
	ETHERNET_MAC_MACA2HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA2HR_SA = 1UL<<30, // SA
	ETHERNET_MAC_MACA2HR_MBC = ((1UL<<6)-1) << 24, // MBC
	ETHERNET_MAC_MACA2HR_ADDRHI = ((1UL<<16)-1) << 0, // ADDRHI		
};
inline void ethernet_mac_maca2hr_set_mbc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA2HR = (p->MACA2HR & ~ETHERNET_MAC_MACA2HR_MBC) | ((val<<24) & ETHERNET_MAC_MACA2HR_MBC); }
inline void ethernet_mac_maca2hr_set_addrhi(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA2HR = (p->MACA2HR & ~ETHERNET_MAC_MACA2HR_ADDRHI) | ((val<<0) & ETHERNET_MAC_MACA2HR_ADDRHI); }
inline uint32_t ethernet_mac_maca2hr_get_mbc(struct Ethernet_MAC_Type* p) { return (p->MACA2HR & ETHERNET_MAC_MACA2HR_MBC) >> 24 ; }
inline uint32_t ethernet_mac_maca2hr_get_addrhi(struct Ethernet_MAC_Type* p) { return (p->MACA2HR & ETHERNET_MAC_MACA2HR_ADDRHI) >> 0 ; }

// Ethernet_MAC->MACA3HR Address 3 high register
enum {
	ETHERNET_MAC_MACA3HR_AE = 1UL<<31, // AE
	ETHERNET_MAC_MACA3HR_SA = 1UL<<30, // SA
	ETHERNET_MAC_MACA3HR_MBC = ((1UL<<6)-1) << 24, // MBC
	ETHERNET_MAC_MACA3HR_ADDRHI = ((1UL<<16)-1) << 0, // ADDRHI		
};
inline void ethernet_mac_maca3hr_set_mbc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA3HR = (p->MACA3HR & ~ETHERNET_MAC_MACA3HR_MBC) | ((val<<24) & ETHERNET_MAC_MACA3HR_MBC); }
inline void ethernet_mac_maca3hr_set_addrhi(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACA3HR = (p->MACA3HR & ~ETHERNET_MAC_MACA3HR_ADDRHI) | ((val<<0) & ETHERNET_MAC_MACA3HR_ADDRHI); }
inline uint32_t ethernet_mac_maca3hr_get_mbc(struct Ethernet_MAC_Type* p) { return (p->MACA3HR & ETHERNET_MAC_MACA3HR_MBC) >> 24 ; }
inline uint32_t ethernet_mac_maca3hr_get_addrhi(struct Ethernet_MAC_Type* p) { return (p->MACA3HR & ETHERNET_MAC_MACA3HR_ADDRHI) >> 0 ; }

// Ethernet_MAC->MMC_CONTROL MMC control register
enum {
	ETHERNET_MAC_MMC_CONTROL_UCDBC = 1UL<<8, // UCDBC
	ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL = 1UL<<5, // CNTPRSTLVL
	ETHERNET_MAC_MMC_CONTROL_CNTPRST = 1UL<<4, // CNTPRST
	ETHERNET_MAC_MMC_CONTROL_CNTFREEZ = 1UL<<3, // CNTFREEZ
	ETHERNET_MAC_MMC_CONTROL_RSTONRD = 1UL<<2, // RSTONRD
	ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO = 1UL<<1, // CNTSTOPRO
	ETHERNET_MAC_MMC_CONTROL_CNTRST = 1UL<<0, // CNTRST		
};

// Ethernet_MAC->MMC_RX_INTERRUPT MMC Rx interrupt register
enum {
	ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS = 1UL<<27, // RXLPITRCIS
	ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS = 1UL<<26, // RXLPIUSCIS
	ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS = 1UL<<17, // RXUCGPIS
	ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS = 1UL<<6, // RXALGNERPIS
	ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS = 1UL<<5, // RXCRCERPIS		
};

// Ethernet_MAC->MMC_TX_INTERRUPT MMC Tx interrupt register
enum {
	ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS = 1UL<<27, // TXLPITRCIS
	ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS = 1UL<<26, // TXLPIUSCIS
	ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS = 1UL<<21, // TXGPKTIS
	ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS = 1UL<<15, // TXMCOLGPIS
	ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS = 1UL<<14, // TXSCOLGPIS		
};

// Ethernet_MAC->MMC_RX_INTERRUPT_MASK MMC Rx interrupt mask register
enum {
	ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM = 1UL<<27, // RXLPITRCIM
	ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM = 1UL<<26, // RXLPIUSCIM
	ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM = 1UL<<17, // RXUCGPIM
	ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM = 1UL<<6, // RXALGNERPIM
	ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM = 1UL<<5, // RXCRCERPIM		
};

// Ethernet_MAC->MMC_TX_INTERRUPT_MASK MMC Tx interrupt mask register
enum {
	ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM = 1UL<<27, // TXLPITRCIM
	ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM = 1UL<<26, // TXLPIUSCIM
	ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM = 1UL<<21, // TXGPKTIM
	ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM = 1UL<<15, // TXMCOLGPIM
	ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM = 1UL<<14, // TXSCOLGPIM		
};

// Ethernet_MAC->MACL3L4C0R L3 and L4 control 0 register
enum {
	ETHERNET_MAC_MACL3L4C0R_L4DPIM0 = 1UL<<21, // L4DPIM0
	ETHERNET_MAC_MACL3L4C0R_L4DPM0 = 1UL<<20, // L4DPM0
	ETHERNET_MAC_MACL3L4C0R_L4SPIM0 = 1UL<<19, // L4SPIM0
	ETHERNET_MAC_MACL3L4C0R_L4SPM0 = 1UL<<18, // L4SPM0
	ETHERNET_MAC_MACL3L4C0R_L4PEN0 = 1UL<<16, // L4PEN0
	ETHERNET_MAC_MACL3L4C0R_L3HDBM0 = ((1UL<<5)-1) << 11, // L3HDBM0
	ETHERNET_MAC_MACL3L4C0R_L3HSBM0 = ((1UL<<5)-1) << 6, // L3HSBM0
	ETHERNET_MAC_MACL3L4C0R_L3DAIM0 = 1UL<<5, // L3DAIM0
	ETHERNET_MAC_MACL3L4C0R_L3DAM0 = 1UL<<4, // L3DAM0
	ETHERNET_MAC_MACL3L4C0R_L3SAIM0 = 1UL<<3, // L3SAIM0
	ETHERNET_MAC_MACL3L4C0R_L3SAM0 = 1UL<<2, // L3SAM0
	ETHERNET_MAC_MACL3L4C0R_L3PEN0 = 1UL<<0, // L3PEN0		
};
inline void ethernet_mac_macl3l4c0r_set_l3hdbm0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL3L4C0R = (p->MACL3L4C0R & ~ETHERNET_MAC_MACL3L4C0R_L3HDBM0) | ((val<<11) & ETHERNET_MAC_MACL3L4C0R_L3HDBM0); }
inline void ethernet_mac_macl3l4c0r_set_l3hsbm0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL3L4C0R = (p->MACL3L4C0R & ~ETHERNET_MAC_MACL3L4C0R_L3HSBM0) | ((val<<6) & ETHERNET_MAC_MACL3L4C0R_L3HSBM0); }
inline uint32_t ethernet_mac_macl3l4c0r_get_l3hdbm0(struct Ethernet_MAC_Type* p) { return (p->MACL3L4C0R & ETHERNET_MAC_MACL3L4C0R_L3HDBM0) >> 11 ; }
inline uint32_t ethernet_mac_macl3l4c0r_get_l3hsbm0(struct Ethernet_MAC_Type* p) { return (p->MACL3L4C0R & ETHERNET_MAC_MACL3L4C0R_L3HSBM0) >> 6 ; }

// Ethernet_MAC->MACL4A0R Layer4 address filter 0 register
enum {
	ETHERNET_MAC_MACL4A0R_L4DP0 = ((1UL<<16)-1) << 16, // L4DP0
	ETHERNET_MAC_MACL4A0R_L4SP0 = ((1UL<<16)-1) << 0, // L4SP0		
};
inline void ethernet_mac_macl4a0r_set_l4dp0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL4A0R = (p->MACL4A0R & ~ETHERNET_MAC_MACL4A0R_L4DP0) | ((val<<16) & ETHERNET_MAC_MACL4A0R_L4DP0); }
inline void ethernet_mac_macl4a0r_set_l4sp0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL4A0R = (p->MACL4A0R & ~ETHERNET_MAC_MACL4A0R_L4SP0) | ((val<<0) & ETHERNET_MAC_MACL4A0R_L4SP0); }
inline uint32_t ethernet_mac_macl4a0r_get_l4dp0(struct Ethernet_MAC_Type* p) { return (p->MACL4A0R & ETHERNET_MAC_MACL4A0R_L4DP0) >> 16 ; }
inline uint32_t ethernet_mac_macl4a0r_get_l4sp0(struct Ethernet_MAC_Type* p) { return (p->MACL4A0R & ETHERNET_MAC_MACL4A0R_L4SP0) >> 0 ; }

// Ethernet_MAC->MACL3L4C1R L3 and L4 control 1 register
enum {
	ETHERNET_MAC_MACL3L4C1R_L4DPIM1 = 1UL<<21, // L4DPIM1
	ETHERNET_MAC_MACL3L4C1R_L4DPM1 = 1UL<<20, // L4DPM1
	ETHERNET_MAC_MACL3L4C1R_L4SPIM1 = 1UL<<19, // L4SPIM1
	ETHERNET_MAC_MACL3L4C1R_L4SPM1 = 1UL<<18, // L4SPM1
	ETHERNET_MAC_MACL3L4C1R_L4PEN1 = 1UL<<16, // L4PEN1
	ETHERNET_MAC_MACL3L4C1R_L3HDBM1 = ((1UL<<5)-1) << 11, // L3HDBM1
	ETHERNET_MAC_MACL3L4C1R_L3HSBM1 = ((1UL<<5)-1) << 6, // L3HSBM1
	ETHERNET_MAC_MACL3L4C1R_L3DAIM1 = 1UL<<5, // L3DAIM1
	ETHERNET_MAC_MACL3L4C1R_L3DAM1 = 1UL<<4, // L3DAM1
	ETHERNET_MAC_MACL3L4C1R_L3SAIM1 = 1UL<<3, // L3SAIM1
	ETHERNET_MAC_MACL3L4C1R_L3SAM1 = 1UL<<2, // L3SAM1
	ETHERNET_MAC_MACL3L4C1R_L3PEN1 = 1UL<<0, // L3PEN1		
};
inline void ethernet_mac_macl3l4c1r_set_l3hdbm1(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL3L4C1R = (p->MACL3L4C1R & ~ETHERNET_MAC_MACL3L4C1R_L3HDBM1) | ((val<<11) & ETHERNET_MAC_MACL3L4C1R_L3HDBM1); }
inline void ethernet_mac_macl3l4c1r_set_l3hsbm1(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL3L4C1R = (p->MACL3L4C1R & ~ETHERNET_MAC_MACL3L4C1R_L3HSBM1) | ((val<<6) & ETHERNET_MAC_MACL3L4C1R_L3HSBM1); }
inline uint32_t ethernet_mac_macl3l4c1r_get_l3hdbm1(struct Ethernet_MAC_Type* p) { return (p->MACL3L4C1R & ETHERNET_MAC_MACL3L4C1R_L3HDBM1) >> 11 ; }
inline uint32_t ethernet_mac_macl3l4c1r_get_l3hsbm1(struct Ethernet_MAC_Type* p) { return (p->MACL3L4C1R & ETHERNET_MAC_MACL3L4C1R_L3HSBM1) >> 6 ; }

// Ethernet_MAC->MACL4A1R Layer 4 address filter 1 register
enum {
	ETHERNET_MAC_MACL4A1R_L4DP1 = ((1UL<<16)-1) << 16, // L4DP1
	ETHERNET_MAC_MACL4A1R_L4SP1 = ((1UL<<16)-1) << 0, // L4SP1		
};
inline void ethernet_mac_macl4a1r_set_l4dp1(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL4A1R = (p->MACL4A1R & ~ETHERNET_MAC_MACL4A1R_L4DP1) | ((val<<16) & ETHERNET_MAC_MACL4A1R_L4DP1); }
inline void ethernet_mac_macl4a1r_set_l4sp1(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACL4A1R = (p->MACL4A1R & ~ETHERNET_MAC_MACL4A1R_L4SP1) | ((val<<0) & ETHERNET_MAC_MACL4A1R_L4SP1); }
inline uint32_t ethernet_mac_macl4a1r_get_l4dp1(struct Ethernet_MAC_Type* p) { return (p->MACL4A1R & ETHERNET_MAC_MACL4A1R_L4DP1) >> 16 ; }
inline uint32_t ethernet_mac_macl4a1r_get_l4sp1(struct Ethernet_MAC_Type* p) { return (p->MACL4A1R & ETHERNET_MAC_MACL4A1R_L4SP1) >> 0 ; }

// Ethernet_MAC->MACTSCR Timestamp control Register
enum {
	ETHERNET_MAC_MACTSCR_TXTSSTSM = 1UL<<24, // TXTSSTSM
	ETHERNET_MAC_MACTSCR_CSC = 1UL<<19, // CSC
	ETHERNET_MAC_MACTSCR_TSENMACADDR = 1UL<<18, // TSENMACADDR
	ETHERNET_MAC_MACTSCR_SNAPTYPSEL = ((1UL<<2)-1) << 16, // SNAPTYPSEL
	ETHERNET_MAC_MACTSCR_TSMSTRENA = 1UL<<15, // TSMSTRENA
	ETHERNET_MAC_MACTSCR_TSEVNTENA = 1UL<<14, // TSEVNTENA
	ETHERNET_MAC_MACTSCR_TSIPV4ENA = 1UL<<13, // TSIPV4ENA
	ETHERNET_MAC_MACTSCR_TSIPV6ENA = 1UL<<12, // TSIPV6ENA
	ETHERNET_MAC_MACTSCR_TSIPENA = 1UL<<11, // TSIPENA
	ETHERNET_MAC_MACTSCR_TSVER2ENA = 1UL<<10, // TSVER2ENA
	ETHERNET_MAC_MACTSCR_TSCTRLSSR = 1UL<<9, // TSCTRLSSR
	ETHERNET_MAC_MACTSCR_TSENALL = 1UL<<8, // TSENALL
	ETHERNET_MAC_MACTSCR_TSADDREG = 1UL<<5, // TSADDREG
	ETHERNET_MAC_MACTSCR_TSUPDT = 1UL<<3, // TSUPDT
	ETHERNET_MAC_MACTSCR_TSINIT = 1UL<<2, // TSINIT
	ETHERNET_MAC_MACTSCR_TSCFUPDT = 1UL<<1, // TSCFUPDT
	ETHERNET_MAC_MACTSCR_TSENA = 1UL<<0, // TSENA		
};
inline void ethernet_mac_mactscr_set_snaptypsel(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACTSCR = (p->MACTSCR & ~ETHERNET_MAC_MACTSCR_SNAPTYPSEL) | ((val<<16) & ETHERNET_MAC_MACTSCR_SNAPTYPSEL); }
inline uint32_t ethernet_mac_mactscr_get_snaptypsel(struct Ethernet_MAC_Type* p) { return (p->MACTSCR & ETHERNET_MAC_MACTSCR_SNAPTYPSEL) >> 16 ; }

// Ethernet_MAC->MACSSIR Sub-second increment register
enum {
	ETHERNET_MAC_MACSSIR_SSINC = ((1UL<<8)-1) << 16, // SSINC
	ETHERNET_MAC_MACSSIR_SNSINC = ((1UL<<8)-1) << 8, // SNSINC		
};
inline void ethernet_mac_macssir_set_ssinc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACSSIR = (p->MACSSIR & ~ETHERNET_MAC_MACSSIR_SSINC) | ((val<<16) & ETHERNET_MAC_MACSSIR_SSINC); }
inline void ethernet_mac_macssir_set_snsinc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACSSIR = (p->MACSSIR & ~ETHERNET_MAC_MACSSIR_SNSINC) | ((val<<8) & ETHERNET_MAC_MACSSIR_SNSINC); }
inline uint32_t ethernet_mac_macssir_get_ssinc(struct Ethernet_MAC_Type* p) { return (p->MACSSIR & ETHERNET_MAC_MACSSIR_SSINC) >> 16 ; }
inline uint32_t ethernet_mac_macssir_get_snsinc(struct Ethernet_MAC_Type* p) { return (p->MACSSIR & ETHERNET_MAC_MACSSIR_SNSINC) >> 8 ; }

// Ethernet_MAC->MACSTNR System time nanoseconds register
enum {
	ETHERNET_MAC_MACSTNR_TSSS = ((1UL<<31)-1) << 0, // TSSS		
};
inline uint32_t ethernet_mac_macstnr_get_tsss(struct Ethernet_MAC_Type* p) { return (p->MACSTNR & ETHERNET_MAC_MACSTNR_TSSS) >> 0 ; }

// Ethernet_MAC->MACSTNUR System time nanoseconds update register
enum {
	ETHERNET_MAC_MACSTNUR_ADDSUB = 1UL<<31, // ADDSUB
	ETHERNET_MAC_MACSTNUR_TSSS = ((1UL<<31)-1) << 0, // TSSS		
};
inline void ethernet_mac_macstnur_set_tsss(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACSTNUR = (p->MACSTNUR & ~ETHERNET_MAC_MACSTNUR_TSSS) | ((val<<0) & ETHERNET_MAC_MACSTNUR_TSSS); }
inline uint32_t ethernet_mac_macstnur_get_tsss(struct Ethernet_MAC_Type* p) { return (p->MACSTNUR & ETHERNET_MAC_MACSTNUR_TSSS) >> 0 ; }

// Ethernet_MAC->MACTSSR Timestamp status register
enum {
	ETHERNET_MAC_MACTSSR_ATSNS = ((1UL<<5)-1) << 25, // ATSNS
	ETHERNET_MAC_MACTSSR_ATSSTM = 1UL<<24, // ATSSTM
	ETHERNET_MAC_MACTSSR_ATSSTN = ((1UL<<4)-1) << 16, // ATSSTN
	ETHERNET_MAC_MACTSSR_TXTSSIS = 1UL<<15, // TXTSSIS
	ETHERNET_MAC_MACTSSR_TSTRGTERR0 = 1UL<<3, // TSTRGTERR0
	ETHERNET_MAC_MACTSSR_AUXTSTRIG = 1UL<<2, // AUXTSTRIG
	ETHERNET_MAC_MACTSSR_TSTARGT0 = 1UL<<1, // TSTARGT0
	ETHERNET_MAC_MACTSSR_TSSOVF = 1UL<<0, // TSSOVF		
};
inline uint32_t ethernet_mac_mactssr_get_atsns(struct Ethernet_MAC_Type* p) { return (p->MACTSSR & ETHERNET_MAC_MACTSSR_ATSNS) >> 25 ; }
inline uint32_t ethernet_mac_mactssr_get_atsstn(struct Ethernet_MAC_Type* p) { return (p->MACTSSR & ETHERNET_MAC_MACTSSR_ATSSTN) >> 16 ; }

// Ethernet_MAC->MACTxTSSNR Tx timestamp status nanoseconds register
enum {
	ETHERNET_MAC_MACTXTSSNR_TXTSSMIS = 1UL<<31, // TXTSSMIS
	ETHERNET_MAC_MACTXTSSNR_TXTSSLO = ((1UL<<31)-1) << 0, // TXTSSLO		
};
inline uint32_t ethernet_mac_mactxtssnr_get_txtsslo(struct Ethernet_MAC_Type* p) { return (p->MACTxTSSNR & ETHERNET_MAC_MACTXTSSNR_TXTSSLO) >> 0 ; }

// Ethernet_MAC->MACACR Auxiliary control register
enum {
	ETHERNET_MAC_MACACR_ATSEN3 = 1UL<<7, // ATSEN3
	ETHERNET_MAC_MACACR_ATSEN2 = 1UL<<6, // ATSEN2
	ETHERNET_MAC_MACACR_ATSEN1 = 1UL<<5, // ATSEN1
	ETHERNET_MAC_MACACR_ATSEN0 = 1UL<<4, // ATSEN0
	ETHERNET_MAC_MACACR_ATSFC = 1UL<<0, // ATSFC		
};

// Ethernet_MAC->MACATSNR Auxiliary timestamp nanoseconds register
enum {
	ETHERNET_MAC_MACATSNR_AUXTSLO = ((1UL<<31)-1) << 0, // AUXTSLO		
};
inline uint32_t ethernet_mac_macatsnr_get_auxtslo(struct Ethernet_MAC_Type* p) { return (p->MACATSNR & ETHERNET_MAC_MACATSNR_AUXTSLO) >> 0 ; }

// Ethernet_MAC->MACPPSCR PPS control register
enum {
	ETHERNET_MAC_MACPPSCR_TRGTMODSEL0 = ((1UL<<2)-1) << 5, // TRGTMODSEL0
	ETHERNET_MAC_MACPPSCR_PPSEN0 = 1UL<<4, // PPSEN0
	ETHERNET_MAC_MACPPSCR_PPSCTRL = ((1UL<<4)-1) << 0, // PPSCTRL		
};
inline void ethernet_mac_macppscr_set_trgtmodsel0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPPSCR = (p->MACPPSCR & ~ETHERNET_MAC_MACPPSCR_TRGTMODSEL0) | ((val<<5) & ETHERNET_MAC_MACPPSCR_TRGTMODSEL0); }
inline void ethernet_mac_macppscr_set_ppsctrl(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPPSCR = (p->MACPPSCR & ~ETHERNET_MAC_MACPPSCR_PPSCTRL) | ((val<<0) & ETHERNET_MAC_MACPPSCR_PPSCTRL); }
inline uint32_t ethernet_mac_macppscr_get_trgtmodsel0(struct Ethernet_MAC_Type* p) { return (p->MACPPSCR & ETHERNET_MAC_MACPPSCR_TRGTMODSEL0) >> 5 ; }
inline uint32_t ethernet_mac_macppscr_get_ppsctrl(struct Ethernet_MAC_Type* p) { return (p->MACPPSCR & ETHERNET_MAC_MACPPSCR_PPSCTRL) >> 0 ; }

// Ethernet_MAC->MACPPSTTSR PPS target time seconds register
enum {
	ETHERNET_MAC_MACPPSTTSR_TSTRH0 = ((1UL<<31)-1) << 0, // TSTRH0		
};
inline void ethernet_mac_macppsttsr_set_tstrh0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPPSTTSR = (p->MACPPSTTSR & ~ETHERNET_MAC_MACPPSTTSR_TSTRH0) | ((val<<0) & ETHERNET_MAC_MACPPSTTSR_TSTRH0); }
inline uint32_t ethernet_mac_macppsttsr_get_tstrh0(struct Ethernet_MAC_Type* p) { return (p->MACPPSTTSR & ETHERNET_MAC_MACPPSTTSR_TSTRH0) >> 0 ; }

// Ethernet_MAC->MACPPSTTNR PPS target time nanoseconds register
enum {
	ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0 = 1UL<<31, // TRGTBUSY0
	ETHERNET_MAC_MACPPSTTNR_TTSL0 = ((1UL<<31)-1) << 0, // TTSL0		
};
inline void ethernet_mac_macppsttnr_set_ttsl0(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPPSTTNR = (p->MACPPSTTNR & ~ETHERNET_MAC_MACPPSTTNR_TTSL0) | ((val<<0) & ETHERNET_MAC_MACPPSTTNR_TTSL0); }
inline uint32_t ethernet_mac_macppsttnr_get_ttsl0(struct Ethernet_MAC_Type* p) { return (p->MACPPSTTNR & ETHERNET_MAC_MACPPSTTNR_TTSL0) >> 0 ; }

// Ethernet_MAC->MACPOCR PTP Offload control register
enum {
	ETHERNET_MAC_MACPOCR_DN = ((1UL<<8)-1) << 8, // DN
	ETHERNET_MAC_MACPOCR_DRRDIS = 1UL<<6, // DRRDIS
	ETHERNET_MAC_MACPOCR_APDREQTRIG = 1UL<<5, // APDREQTRIG
	ETHERNET_MAC_MACPOCR_ASYNCTRIG = 1UL<<4, // ASYNCTRIG
	ETHERNET_MAC_MACPOCR_APDREQEN = 1UL<<2, // APDREQEN
	ETHERNET_MAC_MACPOCR_ASYNCEN = 1UL<<1, // ASYNCEN
	ETHERNET_MAC_MACPOCR_PTOEN = 1UL<<0, // PTOEN		
};
inline void ethernet_mac_macpocr_set_dn(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACPOCR = (p->MACPOCR & ~ETHERNET_MAC_MACPOCR_DN) | ((val<<8) & ETHERNET_MAC_MACPOCR_DN); }
inline uint32_t ethernet_mac_macpocr_get_dn(struct Ethernet_MAC_Type* p) { return (p->MACPOCR & ETHERNET_MAC_MACPOCR_DN) >> 8 ; }

// Ethernet_MAC->MACLMIR Log message interval register
enum {
	ETHERNET_MAC_MACLMIR_LMPDRI = ((1UL<<8)-1) << 24, // LMPDRI
	ETHERNET_MAC_MACLMIR_DRSYNCR = ((1UL<<3)-1) << 8, // DRSYNCR
	ETHERNET_MAC_MACLMIR_LSI = ((1UL<<8)-1) << 0, // LSI		
};
inline void ethernet_mac_maclmir_set_lmpdri(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACLMIR = (p->MACLMIR & ~ETHERNET_MAC_MACLMIR_LMPDRI) | ((val<<24) & ETHERNET_MAC_MACLMIR_LMPDRI); }
inline void ethernet_mac_maclmir_set_drsyncr(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACLMIR = (p->MACLMIR & ~ETHERNET_MAC_MACLMIR_DRSYNCR) | ((val<<8) & ETHERNET_MAC_MACLMIR_DRSYNCR); }
inline void ethernet_mac_maclmir_set_lsi(struct Ethernet_MAC_Type* p, uint32_t val) { p->MACLMIR = (p->MACLMIR & ~ETHERNET_MAC_MACLMIR_LSI) | ((val<<0) & ETHERNET_MAC_MACLMIR_LSI); }
inline uint32_t ethernet_mac_maclmir_get_lmpdri(struct Ethernet_MAC_Type* p) { return (p->MACLMIR & ETHERNET_MAC_MACLMIR_LMPDRI) >> 24 ; }
inline uint32_t ethernet_mac_maclmir_get_drsyncr(struct Ethernet_MAC_Type* p) { return (p->MACLMIR & ETHERNET_MAC_MACLMIR_DRSYNCR) >> 8 ; }
inline uint32_t ethernet_mac_maclmir_get_lsi(struct Ethernet_MAC_Type* p) { return (p->MACLMIR & ETHERNET_MAC_MACLMIR_LSI) >> 0 ; }

// Ethernet_MAC->MTLOMR Operating mode Register
enum {
	ETHERNET_MAC_MTLOMR_CNTCLR = 1UL<<9, // CNTCLR
	ETHERNET_MAC_MTLOMR_CNTPRST = 1UL<<8, // CNTPRST
	ETHERNET_MAC_MTLOMR_DTXSTS = 1UL<<1, // DTXSTS		
};

// Ethernet_MAC->MTLISR Interrupt status Register
enum {
	ETHERNET_MAC_MTLISR_Q0IS = 1UL<<0, // Queue interrupt status		
};

// Ethernet_MAC->MTLTxQOMR Tx queue operating mode Register
enum {
	ETHERNET_MAC_MTLTXQOMR_TQS = ((1UL<<9)-1) << 16, // Transmit Queue Size
	ETHERNET_MAC_MTLTXQOMR_TTC = ((1UL<<3)-1) << 4, // Transmit Threshold Control
	ETHERNET_MAC_MTLTXQOMR_TXQEN = ((1UL<<2)-1) << 2, // Transmit Queue Enable
	ETHERNET_MAC_MTLTXQOMR_TSF = 1UL<<1, // Transmit Store and Forward
	ETHERNET_MAC_MTLTXQOMR_FTQ = 1UL<<0, // Flush Transmit Queue		
};
inline void ethernet_mac_mtltxqomr_set_tqs(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLTxQOMR = (p->MTLTxQOMR & ~ETHERNET_MAC_MTLTXQOMR_TQS) | ((val<<16) & ETHERNET_MAC_MTLTXQOMR_TQS); }
inline void ethernet_mac_mtltxqomr_set_ttc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLTxQOMR = (p->MTLTxQOMR & ~ETHERNET_MAC_MTLTXQOMR_TTC) | ((val<<4) & ETHERNET_MAC_MTLTXQOMR_TTC); }
inline void ethernet_mac_mtltxqomr_set_txqen(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLTxQOMR = (p->MTLTxQOMR & ~ETHERNET_MAC_MTLTXQOMR_TXQEN) | ((val<<2) & ETHERNET_MAC_MTLTXQOMR_TXQEN); }
inline uint32_t ethernet_mac_mtltxqomr_get_tqs(struct Ethernet_MAC_Type* p) { return (p->MTLTxQOMR & ETHERNET_MAC_MTLTXQOMR_TQS) >> 16 ; }
inline uint32_t ethernet_mac_mtltxqomr_get_ttc(struct Ethernet_MAC_Type* p) { return (p->MTLTxQOMR & ETHERNET_MAC_MTLTXQOMR_TTC) >> 4 ; }
inline uint32_t ethernet_mac_mtltxqomr_get_txqen(struct Ethernet_MAC_Type* p) { return (p->MTLTxQOMR & ETHERNET_MAC_MTLTXQOMR_TXQEN) >> 2 ; }

// Ethernet_MAC->MTLTxQUR Tx queue underflow register
enum {
	ETHERNET_MAC_MTLTXQUR_UFCNTOVF = 1UL<<11, // UFCNTOVF
	ETHERNET_MAC_MTLTXQUR_UFFRMCNT = ((1UL<<11)-1) << 0, // Underflow Packet Counter		
};
inline uint32_t ethernet_mac_mtltxqur_get_uffrmcnt(struct Ethernet_MAC_Type* p) { return (p->MTLTxQUR & ETHERNET_MAC_MTLTXQUR_UFFRMCNT) >> 0 ; }

// Ethernet_MAC->MTLTxQDR Tx queue debug Register
enum {
	ETHERNET_MAC_MTLTXQDR_STXSTSF = ((1UL<<3)-1) << 20, // STXSTSF
	ETHERNET_MAC_MTLTXQDR_PTXQ = ((1UL<<3)-1) << 16, // PTXQ
	ETHERNET_MAC_MTLTXQDR_TXSTSFSTS = 1UL<<5, // TXSTSFSTS
	ETHERNET_MAC_MTLTXQDR_TXQSTS = 1UL<<4, // TXQSTS
	ETHERNET_MAC_MTLTXQDR_TWCSTS = 1UL<<3, // TWCSTS
	ETHERNET_MAC_MTLTXQDR_TRCSTS = ((1UL<<2)-1) << 1, // TRCSTS
	ETHERNET_MAC_MTLTXQDR_TXQPAUSED = 1UL<<0, // TXQPAUSED		
};
inline uint32_t ethernet_mac_mtltxqdr_get_stxstsf(struct Ethernet_MAC_Type* p) { return (p->MTLTxQDR & ETHERNET_MAC_MTLTXQDR_STXSTSF) >> 20 ; }
inline uint32_t ethernet_mac_mtltxqdr_get_ptxq(struct Ethernet_MAC_Type* p) { return (p->MTLTxQDR & ETHERNET_MAC_MTLTXQDR_PTXQ) >> 16 ; }
inline uint32_t ethernet_mac_mtltxqdr_get_trcsts(struct Ethernet_MAC_Type* p) { return (p->MTLTxQDR & ETHERNET_MAC_MTLTXQDR_TRCSTS) >> 1 ; }

// Ethernet_MAC->MTLQICSR Queue interrupt control status Register
enum {
	ETHERNET_MAC_MTLQICSR_RXOIE = 1UL<<24, // RXOIE
	ETHERNET_MAC_MTLQICSR_RXOVFIS = 1UL<<16, // RXOVFIS
	ETHERNET_MAC_MTLQICSR_TXUIE = 1UL<<8, // TXUIE
	ETHERNET_MAC_MTLQICSR_TXUNFIS = 1UL<<0, // TXUNFIS		
};

// Ethernet_MAC->MTLRxQOMR Rx queue operating mode register
enum {
	ETHERNET_MAC_MTLRXQOMR_RQS = ((1UL<<3)-1) << 20, // RQS
	ETHERNET_MAC_MTLRXQOMR_RFD = ((1UL<<3)-1) << 14, // RFD
	ETHERNET_MAC_MTLRXQOMR_RFA = ((1UL<<3)-1) << 8, // RFA
	ETHERNET_MAC_MTLRXQOMR_EHFC = 1UL<<7, // EHFC
	ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF = 1UL<<6, // DIS_TCP_EF
	ETHERNET_MAC_MTLRXQOMR_RSF = 1UL<<5, // RSF
	ETHERNET_MAC_MTLRXQOMR_FEP = 1UL<<4, // FEP
	ETHERNET_MAC_MTLRXQOMR_FUP = 1UL<<3, // FUP
	ETHERNET_MAC_MTLRXQOMR_RTC = ((1UL<<2)-1) << 0, // RTC		
};
inline void ethernet_mac_mtlrxqomr_set_rqs(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLRxQOMR = (p->MTLRxQOMR & ~ETHERNET_MAC_MTLRXQOMR_RQS) | ((val<<20) & ETHERNET_MAC_MTLRXQOMR_RQS); }
inline void ethernet_mac_mtlrxqomr_set_rfd(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLRxQOMR = (p->MTLRxQOMR & ~ETHERNET_MAC_MTLRXQOMR_RFD) | ((val<<14) & ETHERNET_MAC_MTLRXQOMR_RFD); }
inline void ethernet_mac_mtlrxqomr_set_rfa(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLRxQOMR = (p->MTLRxQOMR & ~ETHERNET_MAC_MTLRXQOMR_RFA) | ((val<<8) & ETHERNET_MAC_MTLRXQOMR_RFA); }
inline void ethernet_mac_mtlrxqomr_set_rtc(struct Ethernet_MAC_Type* p, uint32_t val) { p->MTLRxQOMR = (p->MTLRxQOMR & ~ETHERNET_MAC_MTLRXQOMR_RTC) | ((val<<0) & ETHERNET_MAC_MTLRXQOMR_RTC); }
inline uint32_t ethernet_mac_mtlrxqomr_get_rqs(struct Ethernet_MAC_Type* p) { return (p->MTLRxQOMR & ETHERNET_MAC_MTLRXQOMR_RQS) >> 20 ; }
inline uint32_t ethernet_mac_mtlrxqomr_get_rfd(struct Ethernet_MAC_Type* p) { return (p->MTLRxQOMR & ETHERNET_MAC_MTLRXQOMR_RFD) >> 14 ; }
inline uint32_t ethernet_mac_mtlrxqomr_get_rfa(struct Ethernet_MAC_Type* p) { return (p->MTLRxQOMR & ETHERNET_MAC_MTLRXQOMR_RFA) >> 8 ; }
inline uint32_t ethernet_mac_mtlrxqomr_get_rtc(struct Ethernet_MAC_Type* p) { return (p->MTLRxQOMR & ETHERNET_MAC_MTLRXQOMR_RTC) >> 0 ; }

// Ethernet_MAC->MTLRxQMPOCR Rx queue missed packet and overflow counter register
enum {
	ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF = 1UL<<27, // MISCNTOVF
	ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT = ((1UL<<11)-1) << 16, // MISPKTCNT
	ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF = 1UL<<11, // OVFCNTOVF
	ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT = ((1UL<<11)-1) << 0, // OVFPKTCNT		
};
inline uint32_t ethernet_mac_mtlrxqmpocr_get_mispktcnt(struct Ethernet_MAC_Type* p) { return (p->MTLRxQMPOCR & ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT) >> 16 ; }
inline uint32_t ethernet_mac_mtlrxqmpocr_get_ovfpktcnt(struct Ethernet_MAC_Type* p) { return (p->MTLRxQMPOCR & ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT) >> 0 ; }

// Ethernet_MAC->MTLRxQDR Rx queue debug register
enum {
	ETHERNET_MAC_MTLRXQDR_PRXQ = ((1UL<<14)-1) << 16, // PRXQ
	ETHERNET_MAC_MTLRXQDR_RXQSTS = ((1UL<<2)-1) << 4, // RXQSTS
	ETHERNET_MAC_MTLRXQDR_RRCSTS = ((1UL<<2)-1) << 1, // RRCSTS
	ETHERNET_MAC_MTLRXQDR_RWCSTS = 1UL<<0, // RWCSTS		
};
inline uint32_t ethernet_mac_mtlrxqdr_get_prxq(struct Ethernet_MAC_Type* p) { return (p->MTLRxQDR & ETHERNET_MAC_MTLRXQDR_PRXQ) >> 16 ; }
inline uint32_t ethernet_mac_mtlrxqdr_get_rxqsts(struct Ethernet_MAC_Type* p) { return (p->MTLRxQDR & ETHERNET_MAC_MTLRXQDR_RXQSTS) >> 4 ; }
inline uint32_t ethernet_mac_mtlrxqdr_get_rrcsts(struct Ethernet_MAC_Type* p) { return (p->MTLRxQDR & ETHERNET_MAC_MTLRXQDR_RRCSTS) >> 1 ; }

// Ethernet_MAC->DMAMR DMA mode register
enum {
	ETHERNET_MAC_DMAMR_INTM = 1UL<<16, // Interrupt Mode
	ETHERNET_MAC_DMAMR_PR = ((1UL<<3)-1) << 12, // Priority ratio
	ETHERNET_MAC_DMAMR_TXPR = 1UL<<11, // Transmit priority
	ETHERNET_MAC_DMAMR_DA = 1UL<<1, // DMA Tx or Rx Arbitration Scheme
	ETHERNET_MAC_DMAMR_SWR = 1UL<<0, // Software Reset		
};
inline void ethernet_mac_dmamr_set_pr(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMAMR = (p->DMAMR & ~ETHERNET_MAC_DMAMR_PR) | ((val<<12) & ETHERNET_MAC_DMAMR_PR); }
inline uint32_t ethernet_mac_dmamr_get_pr(struct Ethernet_MAC_Type* p) { return (p->DMAMR & ETHERNET_MAC_DMAMR_PR) >> 12 ; }

// Ethernet_MAC->DMASBMR System bus mode register
enum {
	ETHERNET_MAC_DMASBMR_RB = 1UL<<15, // Rebuild INCRx Burst
	ETHERNET_MAC_DMASBMR_MB = 1UL<<14, // Mixed Burst
	ETHERNET_MAC_DMASBMR_AAL = 1UL<<12, // Address-Aligned Beats
	ETHERNET_MAC_DMASBMR_FB = 1UL<<0, // Fixed Burst Length		
};

// Ethernet_MAC->DMAISR Interrupt status register
enum {
	ETHERNET_MAC_DMAISR_MACIS = 1UL<<17, // MAC Interrupt Status
	ETHERNET_MAC_DMAISR_MTLIS = 1UL<<16, // MTL Interrupt Status
	ETHERNET_MAC_DMAISR_DC0IS = 1UL<<0, // DMA Channel Interrupt Status		
};

// Ethernet_MAC->DMADSR Debug status register
enum {
	ETHERNET_MAC_DMADSR_TPS0 = ((1UL<<4)-1) << 12, // DMA Channel Transmit Process State
	ETHERNET_MAC_DMADSR_RPS0 = ((1UL<<4)-1) << 8, // DMA Channel Receive Process State
	ETHERNET_MAC_DMADSR_AXWHSTS = 1UL<<0, // AHB Master Write Channel		
};
inline uint32_t ethernet_mac_dmadsr_get_tps0(struct Ethernet_MAC_Type* p) { return (p->DMADSR & ETHERNET_MAC_DMADSR_TPS0) >> 12 ; }
inline uint32_t ethernet_mac_dmadsr_get_rps0(struct Ethernet_MAC_Type* p) { return (p->DMADSR & ETHERNET_MAC_DMADSR_RPS0) >> 8 ; }

// Ethernet_MAC->DMACCR Channel control register
enum {
	ETHERNET_MAC_DMACCR_DSL = ((1UL<<3)-1) << 18, // Descriptor Skip Length
	ETHERNET_MAC_DMACCR_PBLX8 = 1UL<<16, // 8xPBL mode
	ETHERNET_MAC_DMACCR_MSS = ((1UL<<14)-1) << 0, // Maximum Segment Size		
};
inline void ethernet_mac_dmaccr_set_dsl(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACCR = (p->DMACCR & ~ETHERNET_MAC_DMACCR_DSL) | ((val<<18) & ETHERNET_MAC_DMACCR_DSL); }
inline void ethernet_mac_dmaccr_set_mss(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACCR = (p->DMACCR & ~ETHERNET_MAC_DMACCR_MSS) | ((val<<0) & ETHERNET_MAC_DMACCR_MSS); }
inline uint32_t ethernet_mac_dmaccr_get_dsl(struct Ethernet_MAC_Type* p) { return (p->DMACCR & ETHERNET_MAC_DMACCR_DSL) >> 18 ; }
inline uint32_t ethernet_mac_dmaccr_get_mss(struct Ethernet_MAC_Type* p) { return (p->DMACCR & ETHERNET_MAC_DMACCR_MSS) >> 0 ; }

// Ethernet_MAC->DMACTxCR Channel transmit control register
enum {
	ETHERNET_MAC_DMACTXCR_TXPBL = ((1UL<<6)-1) << 16, // Transmit Programmable Burst Length
	ETHERNET_MAC_DMACTXCR_TSE = 1UL<<12, // TCP Segmentation Enabled
	ETHERNET_MAC_DMACTXCR_OSF = 1UL<<4, // Operate on Second Packet
	ETHERNET_MAC_DMACTXCR_ST = 1UL<<0, // Start or Stop Transmission Command		
};
inline void ethernet_mac_dmactxcr_set_txpbl(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACTxCR = (p->DMACTxCR & ~ETHERNET_MAC_DMACTXCR_TXPBL) | ((val<<16) & ETHERNET_MAC_DMACTXCR_TXPBL); }
inline uint32_t ethernet_mac_dmactxcr_get_txpbl(struct Ethernet_MAC_Type* p) { return (p->DMACTxCR & ETHERNET_MAC_DMACTXCR_TXPBL) >> 16 ; }

// Ethernet_MAC->DMACRxCR Channel receive control register
enum {
	ETHERNET_MAC_DMACRXCR_RPF = 1UL<<31, // DMA Rx Channel Packet Flush
	ETHERNET_MAC_DMACRXCR_RXPBL = ((1UL<<6)-1) << 16, // RXPBL
	ETHERNET_MAC_DMACRXCR_RBSZ = ((1UL<<14)-1) << 1, // Receive Buffer size
	ETHERNET_MAC_DMACRXCR_SR = 1UL<<0, // Start or Stop Receive Command		
};
inline void ethernet_mac_dmacrxcr_set_rxpbl(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACRxCR = (p->DMACRxCR & ~ETHERNET_MAC_DMACRXCR_RXPBL) | ((val<<16) & ETHERNET_MAC_DMACRXCR_RXPBL); }
inline void ethernet_mac_dmacrxcr_set_rbsz(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACRxCR = (p->DMACRxCR & ~ETHERNET_MAC_DMACRXCR_RBSZ) | ((val<<1) & ETHERNET_MAC_DMACRXCR_RBSZ); }
inline uint32_t ethernet_mac_dmacrxcr_get_rxpbl(struct Ethernet_MAC_Type* p) { return (p->DMACRxCR & ETHERNET_MAC_DMACRXCR_RXPBL) >> 16 ; }
inline uint32_t ethernet_mac_dmacrxcr_get_rbsz(struct Ethernet_MAC_Type* p) { return (p->DMACRxCR & ETHERNET_MAC_DMACRXCR_RBSZ) >> 1 ; }

// Ethernet_MAC->DMACTxDLAR Channel Tx descriptor list address register
enum {
	ETHERNET_MAC_DMACTXDLAR_TDESLA = ((1UL<<30)-1) << 2, // Start of Transmit List		
};
inline void ethernet_mac_dmactxdlar_set_tdesla(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACTxDLAR = (p->DMACTxDLAR & ~ETHERNET_MAC_DMACTXDLAR_TDESLA) | ((val<<2) & ETHERNET_MAC_DMACTXDLAR_TDESLA); }
inline uint32_t ethernet_mac_dmactxdlar_get_tdesla(struct Ethernet_MAC_Type* p) { return (p->DMACTxDLAR & ETHERNET_MAC_DMACTXDLAR_TDESLA) >> 2 ; }

// Ethernet_MAC->DMACRxDLAR Channel Rx descriptor list address register
enum {
	ETHERNET_MAC_DMACRXDLAR_RDESLA = ((1UL<<30)-1) << 2, // Start of Receive List		
};
inline void ethernet_mac_dmacrxdlar_set_rdesla(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACRxDLAR = (p->DMACRxDLAR & ~ETHERNET_MAC_DMACRXDLAR_RDESLA) | ((val<<2) & ETHERNET_MAC_DMACRXDLAR_RDESLA); }
inline uint32_t ethernet_mac_dmacrxdlar_get_rdesla(struct Ethernet_MAC_Type* p) { return (p->DMACRxDLAR & ETHERNET_MAC_DMACRXDLAR_RDESLA) >> 2 ; }

// Ethernet_MAC->DMACTxDTPR Channel Tx descriptor tail pointer register
enum {
	ETHERNET_MAC_DMACTXDTPR_TDT = ((1UL<<30)-1) << 2, // Transmit Descriptor Tail Pointer		
};
inline void ethernet_mac_dmactxdtpr_set_tdt(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACTxDTPR = (p->DMACTxDTPR & ~ETHERNET_MAC_DMACTXDTPR_TDT) | ((val<<2) & ETHERNET_MAC_DMACTXDTPR_TDT); }
inline uint32_t ethernet_mac_dmactxdtpr_get_tdt(struct Ethernet_MAC_Type* p) { return (p->DMACTxDTPR & ETHERNET_MAC_DMACTXDTPR_TDT) >> 2 ; }

// Ethernet_MAC->DMACRxDTPR Channel Rx descriptor tail pointer register
enum {
	ETHERNET_MAC_DMACRXDTPR_RDT = ((1UL<<30)-1) << 2, // Receive Descriptor Tail Pointer		
};
inline void ethernet_mac_dmacrxdtpr_set_rdt(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACRxDTPR = (p->DMACRxDTPR & ~ETHERNET_MAC_DMACRXDTPR_RDT) | ((val<<2) & ETHERNET_MAC_DMACRXDTPR_RDT); }
inline uint32_t ethernet_mac_dmacrxdtpr_get_rdt(struct Ethernet_MAC_Type* p) { return (p->DMACRxDTPR & ETHERNET_MAC_DMACRXDTPR_RDT) >> 2 ; }

// Ethernet_MAC->DMACTxRLR Channel Tx descriptor ring length register
enum {
	ETHERNET_MAC_DMACTXRLR_TDRL = ((1UL<<10)-1) << 0, // Transmit Descriptor Ring Length		
};
inline void ethernet_mac_dmactxrlr_set_tdrl(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACTxRLR = (p->DMACTxRLR & ~ETHERNET_MAC_DMACTXRLR_TDRL) | ((val<<0) & ETHERNET_MAC_DMACTXRLR_TDRL); }
inline uint32_t ethernet_mac_dmactxrlr_get_tdrl(struct Ethernet_MAC_Type* p) { return (p->DMACTxRLR & ETHERNET_MAC_DMACTXRLR_TDRL) >> 0 ; }

// Ethernet_MAC->DMACRxRLR Channel Rx descriptor ring length register
enum {
	ETHERNET_MAC_DMACRXRLR_RDRL = ((1UL<<10)-1) << 0, // Receive Descriptor Ring Length		
};
inline void ethernet_mac_dmacrxrlr_set_rdrl(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACRxRLR = (p->DMACRxRLR & ~ETHERNET_MAC_DMACRXRLR_RDRL) | ((val<<0) & ETHERNET_MAC_DMACRXRLR_RDRL); }
inline uint32_t ethernet_mac_dmacrxrlr_get_rdrl(struct Ethernet_MAC_Type* p) { return (p->DMACRxRLR & ETHERNET_MAC_DMACRXRLR_RDRL) >> 0 ; }

// Ethernet_MAC->DMACIER Channel interrupt enable register
enum {
	ETHERNET_MAC_DMACIER_NIE = 1UL<<15, // Normal Interrupt Summary Enable
	ETHERNET_MAC_DMACIER_AIE = 1UL<<14, // Abnormal Interrupt Summary Enable
	ETHERNET_MAC_DMACIER_CDEE = 1UL<<13, // Context Descriptor Error Enable
	ETHERNET_MAC_DMACIER_FBEE = 1UL<<12, // Fatal Bus Error Enable
	ETHERNET_MAC_DMACIER_ERIE = 1UL<<11, // Early Receive Interrupt Enable
	ETHERNET_MAC_DMACIER_ETIE = 1UL<<10, // Early Transmit Interrupt Enable
	ETHERNET_MAC_DMACIER_RWTE = 1UL<<9, // Receive Watchdog Timeout Enable
	ETHERNET_MAC_DMACIER_RSE = 1UL<<8, // Receive Stopped Enable
	ETHERNET_MAC_DMACIER_RBUE = 1UL<<7, // Receive Buffer Unavailable Enable
	ETHERNET_MAC_DMACIER_RIE = 1UL<<6, // Receive Interrupt Enable
	ETHERNET_MAC_DMACIER_TBUE = 1UL<<2, // Transmit Buffer Unavailable Enable
	ETHERNET_MAC_DMACIER_TXSE = 1UL<<1, // Transmit Stopped Enable
	ETHERNET_MAC_DMACIER_TIE = 1UL<<0, // Transmit Interrupt Enable		
};

// Ethernet_MAC->DMACSR Channel status register
enum {
	ETHERNET_MAC_DMACSR_REB = ((1UL<<3)-1) << 19, // Rx DMA Error Bits
	ETHERNET_MAC_DMACSR_TEB = ((1UL<<3)-1) << 16, // Tx DMA Error Bits
	ETHERNET_MAC_DMACSR_NIS = 1UL<<15, // Normal Interrupt Summary
	ETHERNET_MAC_DMACSR_AIS = 1UL<<14, // Abnormal Interrupt Summary
	ETHERNET_MAC_DMACSR_CDE = 1UL<<13, // Context Descriptor Error
	ETHERNET_MAC_DMACSR_FBE = 1UL<<12, // Fatal Bus Error
	ETHERNET_MAC_DMACSR_ER = 1UL<<11, // Early Receive Interrupt
	ETHERNET_MAC_DMACSR_ET = 1UL<<10, // Early Transmit Interrupt
	ETHERNET_MAC_DMACSR_RWT = 1UL<<9, // Receive Watchdog Timeout
	ETHERNET_MAC_DMACSR_RPS = 1UL<<8, // Receive Process Stopped
	ETHERNET_MAC_DMACSR_RBU = 1UL<<7, // Receive Buffer Unavailable
	ETHERNET_MAC_DMACSR_RI = 1UL<<6, // Receive Interrupt
	ETHERNET_MAC_DMACSR_TBU = 1UL<<2, // Transmit Buffer Unavailable
	ETHERNET_MAC_DMACSR_TPS = 1UL<<1, // Transmit Process Stopped
	ETHERNET_MAC_DMACSR_TI = 1UL<<0, // Transmit Interrupt		
};
inline void ethernet_mac_dmacsr_set_reb(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACSR = (p->DMACSR & ~ETHERNET_MAC_DMACSR_REB) | ((val<<19) & ETHERNET_MAC_DMACSR_REB); }
inline void ethernet_mac_dmacsr_set_teb(struct Ethernet_MAC_Type* p, uint32_t val) { p->DMACSR = (p->DMACSR & ~ETHERNET_MAC_DMACSR_TEB) | ((val<<16) & ETHERNET_MAC_DMACSR_TEB); }
inline uint32_t ethernet_mac_dmacsr_get_reb(struct Ethernet_MAC_Type* p) { return (p->DMACSR & ETHERNET_MAC_DMACSR_REB) >> 19 ; }
inline uint32_t ethernet_mac_dmacsr_get_teb(struct Ethernet_MAC_Type* p) { return (p->DMACSR & ETHERNET_MAC_DMACSR_TEB) >> 16 ; }

// Ethernet_MAC->DMACMFCR Channel missed frame count register
enum {
	ETHERNET_MAC_DMACMFCR_MFCO = 1UL<<15, // Overflow status of the MFC Counter
	ETHERNET_MAC_DMACMFCR_MFC = ((1UL<<11)-1) << 0, // Dropped Packet Counters		
};
inline uint32_t ethernet_mac_dmacmfcr_get_mfc(struct Ethernet_MAC_Type* p) { return (p->DMACMFCR & ETHERNET_MAC_DMACMFCR_MFC) >> 0 ; }

/* FDCAN1 */
struct FDCAN1_Type {
	__I uint32_t FDCAN_CREL; // @0 FDCAN Core Release Register
	__I uint32_t FDCAN_ENDN; // @4 FDCAN Core Release Register
	 uint8_t RESERVED0[4]; // @8 
	__I uint32_t FDCAN_DBTP; // @12 FDCAN Data Bit Timing and Prescaler Register
	__I uint8_t FDCAN_TEST; // @16 FDCAN Test Register
	 uint8_t RESERVED1[3]; // @17 
	__I uint16_t FDCAN_RWD; // @20 FDCAN RAM Watchdog Register
	 uint8_t RESERVED2[2]; // @22 
	__IO uint16_t FDCAN_CCCR; // @24 FDCAN CC Control Register
	 uint8_t RESERVED3[2]; // @26 
	__IO uint32_t FDCAN_NBTP; // @28 FDCAN Nominal Bit Timing and Prescaler Register
	__IO uint32_t FDCAN_TSCC; // @32 FDCAN Timestamp Counter Configuration Register
	__IO uint16_t FDCAN_TSCV; // @36 FDCAN Timestamp Counter Value Register
	 uint8_t RESERVED4[2]; // @38 
	__IO uint32_t FDCAN_TOCC; // @40 FDCAN Timeout Counter Configuration Register
	__IO uint16_t FDCAN_TOCV; // @44 FDCAN Timeout Counter Value Register
	 uint8_t RESERVED5[18]; // @46 
	__IO uint32_t FDCAN_ECR; // @64 FDCAN Error Counter Register
	__IO uint32_t FDCAN_PSR; // @68 FDCAN Protocol Status Register
	__I uint16_t FDCAN_TDCR; // @72 FDCAN Transmitter Delay Compensation Register
	 uint8_t RESERVED6[6]; // @74 
	__I uint32_t FDCAN_IR; // @80 FDCAN Interrupt Register
	__I uint32_t FDCAN_IE; // @84 FDCAN Interrupt Enable Register
	__I uint32_t FDCAN_ILS; // @88 FDCAN Interrupt Line Select Register
	__IO uint8_t FDCAN_ILE; // @92 FDCAN Interrupt Line Enable Register
	 uint8_t RESERVED7[35]; // @93 
	__IO uint8_t FDCAN_GFC; // @128 FDCAN Global Filter Configuration Register
	 uint8_t RESERVED8[3]; // @129 
	__IO uint32_t FDCAN_SIDFC; // @132 FDCAN Standard ID Filter Configuration Register
	__IO uint32_t FDCAN_XIDFC; // @136 FDCAN Extended ID Filter Configuration Register
	 uint8_t RESERVED9[4]; // @140 
	__IO uint32_t FDCAN_XIDAM; // @144 FDCAN Extended ID and Mask Register
	__I uint16_t FDCAN_HPMS; // @148 FDCAN High Priority Message Status Register
	 uint8_t RESERVED10[2]; // @150 
	__I uint32_t FDCAN_NDAT1; // @152 FDCAN New Data 1 Register
	__I uint32_t FDCAN_NDAT2; // @156 FDCAN New Data 2 Register
	__IO uint32_t FDCAN_RXF0C; // @160 FDCAN Rx FIFO 0 Configuration Register
	__IO uint32_t FDCAN_RXF0S; // @164 FDCAN Rx FIFO 0 Status Register
	__IO uint8_t FDCAN_RXF0A; // @168 CAN Rx FIFO 0 Acknowledge Register
	 uint8_t RESERVED11[3]; // @169 
	__IO uint16_t FDCAN_RXBC; // @172 FDCAN Rx Buffer Configuration Register
	 uint8_t RESERVED12[2]; // @174 
	__IO uint32_t FDCAN_RXF1C; // @176 FDCAN Rx FIFO 1 Configuration Register
	__IO uint32_t FDCAN_RXF1S; // @180 FDCAN Rx FIFO 1 Status Register
	__IO uint8_t FDCAN_RXF1A; // @184 FDCAN Rx FIFO 1 Acknowledge Register
	 uint8_t RESERVED13[3]; // @185 
	__IO uint16_t FDCAN_RXESC; // @188 FDCAN Rx Buffer Element Size Configuration Register
	 uint8_t RESERVED14[2]; // @190 
	__IO uint32_t FDCAN_TXBC; // @192 FDCAN Tx Buffer Configuration Register
	__I uint32_t FDCAN_TXFQS; // @196 FDCAN Tx FIFO/Queue Status Register
	__IO uint8_t FDCAN_TXESC; // @200 FDCAN Tx Buffer Element Size Configuration Register
	 uint8_t RESERVED15[3]; // @201 
	__I uint32_t FDCAN_TXBRP; // @204 FDCAN Tx Buffer Request Pending Register
	__IO uint32_t FDCAN_TXBAR; // @208 FDCAN Tx Buffer Add Request Register
	__IO uint32_t FDCAN_TXBCR; // @212 FDCAN Tx Buffer Cancellation Request Register
	__IO uint32_t FDCAN_TXBTO; // @216 FDCAN Tx Buffer Transmission Occurred Register
	__I uint32_t FDCAN_TXBCF; // @220 FDCAN Tx Buffer Cancellation Finished Register
	__IO uint32_t FDCAN_TXBTIE; // @224 FDCAN Tx Buffer Transmission Interrupt Enable Register
	__IO uint32_t FDCAN_TXBCIE; // @228 FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
	 uint8_t RESERVED16[8]; // @232 
	__IO uint32_t FDCAN_TXEFC; // @240 FDCAN Tx Event FIFO Configuration Register
	__IO uint32_t FDCAN_TXEFS; // @244 FDCAN Tx Event FIFO Status Register
	__IO uint8_t FDCAN_TXEFA; // @248 FDCAN Tx Event FIFO Acknowledge Register
	 uint8_t RESERVED17[7]; // @249 
	__IO uint32_t FDCAN_TTTMC; // @256 FDCAN TT Trigger Memory Configuration Register
	__IO uint32_t FDCAN_TTRMC; // @260 FDCAN TT Reference Message Configuration Register
	__IO uint32_t FDCAN_TTOCF; // @264 FDCAN TT Operation Configuration Register
	__IO uint32_t FDCAN_TTMLM; // @268 FDCAN TT Matrix Limits Register
	__IO uint32_t FDCAN_TURCF; // @272 FDCAN TUR Configuration Register
	__IO uint16_t FDCAN_TTOCN; // @276 FDCAN TT Operation Control Register
	 uint8_t RESERVED18[2]; // @278 
	__IO uint32_t CAN_TTGTP; // @280 FDCAN TT Global Time Preset Register
	__IO uint32_t FDCAN_TTTMK; // @284 FDCAN TT Time Mark Register
	__IO uint32_t FDCAN_TTIR; // @288 FDCAN TT Interrupt Register
	__IO uint32_t FDCAN_TTIE; // @292 FDCAN TT Interrupt Enable Register
	__IO uint32_t FDCAN_TTILS; // @296 FDCAN TT Interrupt Line Select Register
	__IO uint32_t FDCAN_TTOST; // @300 FDCAN TT Operation Status Register
	__I uint32_t FDCAN_TURNA; // @304 FDCAN TUR Numerator Actual Register
	__I uint32_t FDCAN_TTLGT; // @308 FDCAN TT Local and Global Time Register
	__I uint32_t FDCAN_TTCTC; // @312 FDCAN TT Cycle Time and Count Register
	__I uint32_t FDCAN_TTCPT; // @316 FDCAN TT Capture Time Register
	__I uint16_t FDCAN_TTCSM; // @320 FDCAN TT Cycle Sync Mark Register
	 uint8_t RESERVED19[446]; // @322 
	__IO uint8_t FDCAN_TTTS; // @768 FDCAN TT Trigger Select Register
};

// FDCAN1->FDCAN_CREL FDCAN Core Release Register
enum {
	FDCAN1_FDCAN_CREL_REL = ((1UL<<4)-1) << 28, // Core release
	FDCAN1_FDCAN_CREL_STEP = ((1UL<<4)-1) << 24, // Step of Core release
	FDCAN1_FDCAN_CREL_SUBSTEP = ((1UL<<4)-1) << 20, // Sub-step of Core release
	FDCAN1_FDCAN_CREL_YEAR = ((1UL<<4)-1) << 16, // Timestamp Year
	FDCAN1_FDCAN_CREL_MON = ((1UL<<8)-1) << 8, // Timestamp Month
	FDCAN1_FDCAN_CREL_DAY = ((1UL<<8)-1) << 0, // Timestamp Day		
};
inline uint32_t fdcan1_fdcan_crel_get_rel(struct FDCAN1_Type* p) { return (p->FDCAN_CREL & FDCAN1_FDCAN_CREL_REL) >> 28 ; }
inline uint32_t fdcan1_fdcan_crel_get_step(struct FDCAN1_Type* p) { return (p->FDCAN_CREL & FDCAN1_FDCAN_CREL_STEP) >> 24 ; }
inline uint32_t fdcan1_fdcan_crel_get_substep(struct FDCAN1_Type* p) { return (p->FDCAN_CREL & FDCAN1_FDCAN_CREL_SUBSTEP) >> 20 ; }
inline uint32_t fdcan1_fdcan_crel_get_year(struct FDCAN1_Type* p) { return (p->FDCAN_CREL & FDCAN1_FDCAN_CREL_YEAR) >> 16 ; }
inline uint32_t fdcan1_fdcan_crel_get_mon(struct FDCAN1_Type* p) { return (p->FDCAN_CREL & FDCAN1_FDCAN_CREL_MON) >> 8 ; }
inline uint32_t fdcan1_fdcan_crel_get_day(struct FDCAN1_Type* p) { return (p->FDCAN_CREL & FDCAN1_FDCAN_CREL_DAY) >> 0 ; }

// FDCAN1->FDCAN_DBTP FDCAN Data Bit Timing and Prescaler Register
enum {
	FDCAN1_FDCAN_DBTP_TDC = 1UL<<23, // Transceiver Delay Compensation
	FDCAN1_FDCAN_DBTP_DBRP = ((1UL<<5)-1) << 16, // Data BIt Rate Prescaler
	FDCAN1_FDCAN_DBTP_DTSEG1 = ((1UL<<5)-1) << 8, // Data time segment after sample point
	FDCAN1_FDCAN_DBTP_DTSEG2 = ((1UL<<4)-1) << 4, // Data time segment after sample point
	FDCAN1_FDCAN_DBTP_DSJW = ((1UL<<4)-1) << 0, // Synchronization Jump Width		
};
inline uint32_t fdcan1_fdcan_dbtp_get_dbrp(struct FDCAN1_Type* p) { return (p->FDCAN_DBTP & FDCAN1_FDCAN_DBTP_DBRP) >> 16 ; }
inline uint32_t fdcan1_fdcan_dbtp_get_dtseg1(struct FDCAN1_Type* p) { return (p->FDCAN_DBTP & FDCAN1_FDCAN_DBTP_DTSEG1) >> 8 ; }
inline uint32_t fdcan1_fdcan_dbtp_get_dtseg2(struct FDCAN1_Type* p) { return (p->FDCAN_DBTP & FDCAN1_FDCAN_DBTP_DTSEG2) >> 4 ; }
inline uint32_t fdcan1_fdcan_dbtp_get_dsjw(struct FDCAN1_Type* p) { return (p->FDCAN_DBTP & FDCAN1_FDCAN_DBTP_DSJW) >> 0 ; }

// FDCAN1->FDCAN_TEST FDCAN Test Register
enum {
	FDCAN1_FDCAN_TEST_RX = 1UL<<7, // Control of Transmit Pin
	FDCAN1_FDCAN_TEST_TX = ((1UL<<2)-1) << 5, // Loop Back mode
	FDCAN1_FDCAN_TEST_LBCK = 1UL<<4, // Loop Back mode		
};
inline uint32_t fdcan1_fdcan_test_get_tx(struct FDCAN1_Type* p) { return (p->FDCAN_TEST & FDCAN1_FDCAN_TEST_TX) >> 5 ; }

// FDCAN1->FDCAN_RWD FDCAN RAM Watchdog Register
enum {
	FDCAN1_FDCAN_RWD_WDV = ((1UL<<8)-1) << 8, // Watchdog value
	FDCAN1_FDCAN_RWD_WDC = ((1UL<<8)-1) << 0, // Watchdog configuration		
};
inline uint32_t fdcan1_fdcan_rwd_get_wdv(struct FDCAN1_Type* p) { return (p->FDCAN_RWD & FDCAN1_FDCAN_RWD_WDV) >> 8 ; }
inline uint32_t fdcan1_fdcan_rwd_get_wdc(struct FDCAN1_Type* p) { return (p->FDCAN_RWD & FDCAN1_FDCAN_RWD_WDC) >> 0 ; }

// FDCAN1->FDCAN_CCCR FDCAN CC Control Register
enum {
	FDCAN1_FDCAN_CCCR_NISO = 1UL<<15, // Non ISO Operation
	FDCAN1_FDCAN_CCCR_TXP = 1UL<<14, // TXP
	FDCAN1_FDCAN_CCCR_EFBI = 1UL<<13, // Edge Filtering during Bus Integration
	FDCAN1_FDCAN_CCCR_PXHD = 1UL<<12, // Protocol Exception Handling Disable
	FDCAN1_FDCAN_CCCR_BSE = 1UL<<9, // FDCAN Bit Rate Switching
	FDCAN1_FDCAN_CCCR_FDOE = 1UL<<8, // FD Operation Enable
	FDCAN1_FDCAN_CCCR_TEST = 1UL<<7, // Test Mode Enable
	FDCAN1_FDCAN_CCCR_DAR = 1UL<<6, // Disable Automatic Retransmission
	FDCAN1_FDCAN_CCCR_MON = 1UL<<5, // Bus Monitoring Mode
	FDCAN1_FDCAN_CCCR_CSR = 1UL<<4, // Clock Stop Request
	FDCAN1_FDCAN_CCCR_CSA = 1UL<<3, // Clock Stop Acknowledge
	FDCAN1_FDCAN_CCCR_ASM = 1UL<<2, // ASM Restricted Operation Mode
	FDCAN1_FDCAN_CCCR_CCE = 1UL<<1, // Configuration Change Enable
	FDCAN1_FDCAN_CCCR_INIT = 1UL<<0, // Initialization		
};

// FDCAN1->FDCAN_NBTP FDCAN Nominal Bit Timing and Prescaler Register
enum {
	FDCAN1_FDCAN_NBTP_NSJW = ((1UL<<7)-1) << 25, // NSJW: Nominal (Re)Synchronization Jump Width
	FDCAN1_FDCAN_NBTP_NBRP = ((1UL<<9)-1) << 16, // Bit Rate Prescaler
	FDCAN1_FDCAN_NBTP_NTSEG1 = ((1UL<<8)-1) << 8, // Nominal Time segment before sample point
	FDCAN1_FDCAN_NBTP_TSEG2 = ((1UL<<7)-1) << 0, // Nominal Time segment after sample point		
};
inline void fdcan1_fdcan_nbtp_set_nsjw(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_NBTP = (p->FDCAN_NBTP & ~FDCAN1_FDCAN_NBTP_NSJW) | ((val<<25) & FDCAN1_FDCAN_NBTP_NSJW); }
inline void fdcan1_fdcan_nbtp_set_nbrp(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_NBTP = (p->FDCAN_NBTP & ~FDCAN1_FDCAN_NBTP_NBRP) | ((val<<16) & FDCAN1_FDCAN_NBTP_NBRP); }
inline void fdcan1_fdcan_nbtp_set_ntseg1(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_NBTP = (p->FDCAN_NBTP & ~FDCAN1_FDCAN_NBTP_NTSEG1) | ((val<<8) & FDCAN1_FDCAN_NBTP_NTSEG1); }
inline void fdcan1_fdcan_nbtp_set_tseg2(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_NBTP = (p->FDCAN_NBTP & ~FDCAN1_FDCAN_NBTP_TSEG2) | ((val<<0) & FDCAN1_FDCAN_NBTP_TSEG2); }
inline uint32_t fdcan1_fdcan_nbtp_get_nsjw(struct FDCAN1_Type* p) { return (p->FDCAN_NBTP & FDCAN1_FDCAN_NBTP_NSJW) >> 25 ; }
inline uint32_t fdcan1_fdcan_nbtp_get_nbrp(struct FDCAN1_Type* p) { return (p->FDCAN_NBTP & FDCAN1_FDCAN_NBTP_NBRP) >> 16 ; }
inline uint32_t fdcan1_fdcan_nbtp_get_ntseg1(struct FDCAN1_Type* p) { return (p->FDCAN_NBTP & FDCAN1_FDCAN_NBTP_NTSEG1) >> 8 ; }
inline uint32_t fdcan1_fdcan_nbtp_get_tseg2(struct FDCAN1_Type* p) { return (p->FDCAN_NBTP & FDCAN1_FDCAN_NBTP_TSEG2) >> 0 ; }

// FDCAN1->FDCAN_TSCC FDCAN Timestamp Counter Configuration Register
enum {
	FDCAN1_FDCAN_TSCC_TCP = ((1UL<<4)-1) << 16, // Timestamp Counter Prescaler
	FDCAN1_FDCAN_TSCC_TSS = ((1UL<<2)-1) << 0, // Timestamp Select		
};
inline void fdcan1_fdcan_tscc_set_tcp(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TSCC = (p->FDCAN_TSCC & ~FDCAN1_FDCAN_TSCC_TCP) | ((val<<16) & FDCAN1_FDCAN_TSCC_TCP); }
inline void fdcan1_fdcan_tscc_set_tss(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TSCC = (p->FDCAN_TSCC & ~FDCAN1_FDCAN_TSCC_TSS) | ((val<<0) & FDCAN1_FDCAN_TSCC_TSS); }
inline uint32_t fdcan1_fdcan_tscc_get_tcp(struct FDCAN1_Type* p) { return (p->FDCAN_TSCC & FDCAN1_FDCAN_TSCC_TCP) >> 16 ; }
inline uint32_t fdcan1_fdcan_tscc_get_tss(struct FDCAN1_Type* p) { return (p->FDCAN_TSCC & FDCAN1_FDCAN_TSCC_TSS) >> 0 ; }

// FDCAN1->FDCAN_TOCC FDCAN Timeout Counter Configuration Register
enum {
	FDCAN1_FDCAN_TOCC_TOP = ((1UL<<16)-1) << 16, // Timeout Period
	FDCAN1_FDCAN_TOCC_TOS = ((1UL<<2)-1) << 1, // Timeout Select
	FDCAN1_FDCAN_TOCC_ETOC = 1UL<<0, // Enable Timeout Counter		
};
inline void fdcan1_fdcan_tocc_set_top(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TOCC = (p->FDCAN_TOCC & ~FDCAN1_FDCAN_TOCC_TOP) | ((val<<16) & FDCAN1_FDCAN_TOCC_TOP); }
inline void fdcan1_fdcan_tocc_set_tos(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TOCC = (p->FDCAN_TOCC & ~FDCAN1_FDCAN_TOCC_TOS) | ((val<<1) & FDCAN1_FDCAN_TOCC_TOS); }
inline uint32_t fdcan1_fdcan_tocc_get_top(struct FDCAN1_Type* p) { return (p->FDCAN_TOCC & FDCAN1_FDCAN_TOCC_TOP) >> 16 ; }
inline uint32_t fdcan1_fdcan_tocc_get_tos(struct FDCAN1_Type* p) { return (p->FDCAN_TOCC & FDCAN1_FDCAN_TOCC_TOS) >> 1 ; }

// FDCAN1->FDCAN_ECR FDCAN Error Counter Register
enum {
	FDCAN1_FDCAN_ECR_CEL = ((1UL<<8)-1) << 16, // AN Error Logging
	FDCAN1_FDCAN_ECR_RP = 1UL<<15, // Receive Error Passive
	FDCAN1_FDCAN_ECR_TREC = ((1UL<<7)-1) << 8, // Receive Error Counter
	FDCAN1_FDCAN_ECR_TEC = ((1UL<<8)-1) << 0, // Transmit Error Counter		
};
inline void fdcan1_fdcan_ecr_set_cel(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_ECR = (p->FDCAN_ECR & ~FDCAN1_FDCAN_ECR_CEL) | ((val<<16) & FDCAN1_FDCAN_ECR_CEL); }
inline void fdcan1_fdcan_ecr_set_trec(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_ECR = (p->FDCAN_ECR & ~FDCAN1_FDCAN_ECR_TREC) | ((val<<8) & FDCAN1_FDCAN_ECR_TREC); }
inline void fdcan1_fdcan_ecr_set_tec(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_ECR = (p->FDCAN_ECR & ~FDCAN1_FDCAN_ECR_TEC) | ((val<<0) & FDCAN1_FDCAN_ECR_TEC); }
inline uint32_t fdcan1_fdcan_ecr_get_cel(struct FDCAN1_Type* p) { return (p->FDCAN_ECR & FDCAN1_FDCAN_ECR_CEL) >> 16 ; }
inline uint32_t fdcan1_fdcan_ecr_get_trec(struct FDCAN1_Type* p) { return (p->FDCAN_ECR & FDCAN1_FDCAN_ECR_TREC) >> 8 ; }
inline uint32_t fdcan1_fdcan_ecr_get_tec(struct FDCAN1_Type* p) { return (p->FDCAN_ECR & FDCAN1_FDCAN_ECR_TEC) >> 0 ; }

// FDCAN1->FDCAN_PSR FDCAN Protocol Status Register
enum {
	FDCAN1_FDCAN_PSR_TDCV = ((1UL<<7)-1) << 16, // Transmitter Delay Compensation Value
	FDCAN1_FDCAN_PSR_PXE = 1UL<<14, // Protocol Exception Event
	FDCAN1_FDCAN_PSR_REDL = 1UL<<13, // Received FDCAN Message
	FDCAN1_FDCAN_PSR_RBRS = 1UL<<12, // BRS flag of last received FDCAN Message
	FDCAN1_FDCAN_PSR_RESI = 1UL<<11, // ESI flag of last received FDCAN Message
	FDCAN1_FDCAN_PSR_DLEC = ((1UL<<3)-1) << 8, // Data Last Error Code
	FDCAN1_FDCAN_PSR_BO = 1UL<<7, // Bus_Off Status
	FDCAN1_FDCAN_PSR_EW = 1UL<<6, // Warning Status
	FDCAN1_FDCAN_PSR_EP = 1UL<<5, // Error Passive
	FDCAN1_FDCAN_PSR_ACT = ((1UL<<2)-1) << 3, // Activity
	FDCAN1_FDCAN_PSR_LEC = ((1UL<<3)-1) << 0, // Last Error Code		
};
inline void fdcan1_fdcan_psr_set_tdcv(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_PSR = (p->FDCAN_PSR & ~FDCAN1_FDCAN_PSR_TDCV) | ((val<<16) & FDCAN1_FDCAN_PSR_TDCV); }
inline void fdcan1_fdcan_psr_set_dlec(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_PSR = (p->FDCAN_PSR & ~FDCAN1_FDCAN_PSR_DLEC) | ((val<<8) & FDCAN1_FDCAN_PSR_DLEC); }
inline void fdcan1_fdcan_psr_set_act(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_PSR = (p->FDCAN_PSR & ~FDCAN1_FDCAN_PSR_ACT) | ((val<<3) & FDCAN1_FDCAN_PSR_ACT); }
inline void fdcan1_fdcan_psr_set_lec(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_PSR = (p->FDCAN_PSR & ~FDCAN1_FDCAN_PSR_LEC) | ((val<<0) & FDCAN1_FDCAN_PSR_LEC); }
inline uint32_t fdcan1_fdcan_psr_get_tdcv(struct FDCAN1_Type* p) { return (p->FDCAN_PSR & FDCAN1_FDCAN_PSR_TDCV) >> 16 ; }
inline uint32_t fdcan1_fdcan_psr_get_dlec(struct FDCAN1_Type* p) { return (p->FDCAN_PSR & FDCAN1_FDCAN_PSR_DLEC) >> 8 ; }
inline uint32_t fdcan1_fdcan_psr_get_act(struct FDCAN1_Type* p) { return (p->FDCAN_PSR & FDCAN1_FDCAN_PSR_ACT) >> 3 ; }
inline uint32_t fdcan1_fdcan_psr_get_lec(struct FDCAN1_Type* p) { return (p->FDCAN_PSR & FDCAN1_FDCAN_PSR_LEC) >> 0 ; }

// FDCAN1->FDCAN_TDCR FDCAN Transmitter Delay Compensation Register
enum {
	FDCAN1_FDCAN_TDCR_TDCO = ((1UL<<7)-1) << 8, // Transmitter Delay Compensation Offset
	FDCAN1_FDCAN_TDCR_TDCF = ((1UL<<7)-1) << 0, // Transmitter Delay Compensation Filter Window Length		
};
inline uint32_t fdcan1_fdcan_tdcr_get_tdco(struct FDCAN1_Type* p) { return (p->FDCAN_TDCR & FDCAN1_FDCAN_TDCR_TDCO) >> 8 ; }
inline uint32_t fdcan1_fdcan_tdcr_get_tdcf(struct FDCAN1_Type* p) { return (p->FDCAN_TDCR & FDCAN1_FDCAN_TDCR_TDCF) >> 0 ; }

// FDCAN1->FDCAN_IR FDCAN Interrupt Register
enum {
	FDCAN1_FDCAN_IR_ARA = 1UL<<29, // Access to Reserved Address
	FDCAN1_FDCAN_IR_PED = 1UL<<28, // Protocol Error in Data Phase (Data Bit Time is used)
	FDCAN1_FDCAN_IR_PEA = 1UL<<27, // Protocol Error in Arbitration Phase (Nominal Bit Time is used)
	FDCAN1_FDCAN_IR_WDI = 1UL<<26, // Watchdog Interrupt
	FDCAN1_FDCAN_IR_BO = 1UL<<25, // Bus_Off Status
	FDCAN1_FDCAN_IR_EW = 1UL<<24, // Warning Status
	FDCAN1_FDCAN_IR_EP = 1UL<<23, // Error Passive
	FDCAN1_FDCAN_IR_ELO = 1UL<<22, // Error Logging Overflow
	FDCAN1_FDCAN_IR_DRX = 1UL<<19, // Message stored to Dedicated Rx Buffer
	FDCAN1_FDCAN_IR_TOO = 1UL<<18, // Timeout Occurred
	FDCAN1_FDCAN_IR_MRAF = 1UL<<17, // Message RAM Access Failure
	FDCAN1_FDCAN_IR_TSW = 1UL<<16, // Timestamp Wraparound
	FDCAN1_FDCAN_IR_TEFL = 1UL<<15, // Tx Event FIFO Element Lost
	FDCAN1_FDCAN_IR_TEFF = 1UL<<14, // Tx Event FIFO Full
	FDCAN1_FDCAN_IR_TEFW = 1UL<<13, // Tx Event FIFO Watermark Reached
	FDCAN1_FDCAN_IR_TEFN = 1UL<<12, // Tx Event FIFO New Entry
	FDCAN1_FDCAN_IR_TEF = 1UL<<11, // Tx FIFO Empty
	FDCAN1_FDCAN_IR_TCF = 1UL<<10, // Transmission Cancellation Finished
	FDCAN1_FDCAN_IR_TC = 1UL<<9, // Transmission Completed
	FDCAN1_FDCAN_IR_HPM = 1UL<<8, // High Priority Message
	FDCAN1_FDCAN_IR_RF1L = 1UL<<7, // Rx FIFO 1 Message Lost
	FDCAN1_FDCAN_IR_RF1F = 1UL<<6, // Rx FIFO 1 Watermark Reached
	FDCAN1_FDCAN_IR_RF1W = 1UL<<5, // Rx FIFO 1 Watermark Reached
	FDCAN1_FDCAN_IR_RF1N = 1UL<<4, // Rx FIFO 1 New Message
	FDCAN1_FDCAN_IR_RF0L = 1UL<<3, // Rx FIFO 0 Message Lost
	FDCAN1_FDCAN_IR_RF0F = 1UL<<2, // Rx FIFO 0 Full
	FDCAN1_FDCAN_IR_RF0W = 1UL<<1, // Rx FIFO 0 Full
	FDCAN1_FDCAN_IR_RF0N = 1UL<<0, // Rx FIFO 0 New Message		
};

// FDCAN1->FDCAN_IE FDCAN Interrupt Enable Register
enum {
	FDCAN1_FDCAN_IE_ARAE = 1UL<<29, // Access to Reserved Address Enable
	FDCAN1_FDCAN_IE_PEDE = 1UL<<28, // Protocol Error in Data Phase Enable
	FDCAN1_FDCAN_IE_PEAE = 1UL<<27, // Protocol Error in Arbitration Phase Enable
	FDCAN1_FDCAN_IE_WDIE = 1UL<<26, // Watchdog Interrupt Enable
	FDCAN1_FDCAN_IE_BOE = 1UL<<25, // Bus_Off Status Enable
	FDCAN1_FDCAN_IE_EWE = 1UL<<24, // Warning Status Enable
	FDCAN1_FDCAN_IE_EPE = 1UL<<23, // Error Passive Enable
	FDCAN1_FDCAN_IE_ELOE = 1UL<<22, // Error Logging Overflow Enable
	FDCAN1_FDCAN_IE_BEUE = 1UL<<21, // Bit Error Uncorrected Interrupt Enable
	FDCAN1_FDCAN_IE_BECE = 1UL<<20, // Bit Error Corrected Interrupt Enable
	FDCAN1_FDCAN_IE_DRXE = 1UL<<19, // Message stored to Dedicated Rx Buffer Enable
	FDCAN1_FDCAN_IE_TOOE = 1UL<<18, // Timeout Occurred Enable
	FDCAN1_FDCAN_IE_MRAFE = 1UL<<17, // Message RAM Access Failure Enable
	FDCAN1_FDCAN_IE_TSWE = 1UL<<16, // Timestamp Wraparound Enable
	FDCAN1_FDCAN_IE_TEFLE = 1UL<<15, // Tx Event FIFO Element Lost Enable
	FDCAN1_FDCAN_IE_TEFFE = 1UL<<14, // Tx Event FIFO Full Enable
	FDCAN1_FDCAN_IE_TEFWE = 1UL<<13, // Tx Event FIFO Watermark Reached Enable
	FDCAN1_FDCAN_IE_TEFNE = 1UL<<12, // Tx Event FIFO New Entry Enable
	FDCAN1_FDCAN_IE_TEFE = 1UL<<11, // Tx FIFO Empty Enable
	FDCAN1_FDCAN_IE_TCFE = 1UL<<10, // Transmission Cancellation Finished Enable
	FDCAN1_FDCAN_IE_TCE = 1UL<<9, // Transmission Completed Enable
	FDCAN1_FDCAN_IE_HPME = 1UL<<8, // High Priority Message Enable
	FDCAN1_FDCAN_IE_RF1LE = 1UL<<7, // Rx FIFO 1 Message Lost Enable
	FDCAN1_FDCAN_IE_RF1FE = 1UL<<6, // Rx FIFO 1 Watermark Reached Enable
	FDCAN1_FDCAN_IE_RF1WE = 1UL<<5, // Rx FIFO 1 Watermark Reached Enable
	FDCAN1_FDCAN_IE_RF1NE = 1UL<<4, // Rx FIFO 1 New Message Enable
	FDCAN1_FDCAN_IE_RF0LE = 1UL<<3, // Rx FIFO 0 Message Lost Enable
	FDCAN1_FDCAN_IE_RF0FE = 1UL<<2, // Rx FIFO 0 Full Enable
	FDCAN1_FDCAN_IE_RF0WE = 1UL<<1, // Rx FIFO 0 Full Enable
	FDCAN1_FDCAN_IE_RF0NE = 1UL<<0, // Rx FIFO 0 New Message Enable		
};

// FDCAN1->FDCAN_ILS FDCAN Interrupt Line Select Register
enum {
	FDCAN1_FDCAN_ILS_ARAL = 1UL<<29, // Access to Reserved Address Line
	FDCAN1_FDCAN_ILS_PEDL = 1UL<<28, // Protocol Error in Data Phase Line
	FDCAN1_FDCAN_ILS_PEAL = 1UL<<27, // Protocol Error in Arbitration Phase Line
	FDCAN1_FDCAN_ILS_WDIL = 1UL<<26, // Watchdog Interrupt Line
	FDCAN1_FDCAN_ILS_BOL = 1UL<<25, // Bus_Off Status
	FDCAN1_FDCAN_ILS_EWL = 1UL<<24, // Warning Status Interrupt Line
	FDCAN1_FDCAN_ILS_EPL = 1UL<<23, // Error Passive Interrupt Line
	FDCAN1_FDCAN_ILS_ELOL = 1UL<<22, // Error Logging Overflow Interrupt Line
	FDCAN1_FDCAN_ILS_BEUL = 1UL<<21, // Bit Error Uncorrected Interrupt Line
	FDCAN1_FDCAN_ILS_BECL = 1UL<<20, // Bit Error Corrected Interrupt Line
	FDCAN1_FDCAN_ILS_DRXL = 1UL<<19, // Message stored to Dedicated Rx Buffer Interrupt Line
	FDCAN1_FDCAN_ILS_TOOL = 1UL<<18, // Timeout Occurred Interrupt Line
	FDCAN1_FDCAN_ILS_MRAFL = 1UL<<17, // Message RAM Access Failure Interrupt Line
	FDCAN1_FDCAN_ILS_TSWL = 1UL<<16, // Timestamp Wraparound Interrupt Line
	FDCAN1_FDCAN_ILS_TEFLL = 1UL<<15, // Tx Event FIFO Element Lost Interrupt Line
	FDCAN1_FDCAN_ILS_TEFFL = 1UL<<14, // Tx Event FIFO Full Interrupt Line
	FDCAN1_FDCAN_ILS_TEFWL = 1UL<<13, // Tx Event FIFO Watermark Reached Interrupt Line
	FDCAN1_FDCAN_ILS_TEFNL = 1UL<<12, // Tx Event FIFO New Entry Interrupt Line
	FDCAN1_FDCAN_ILS_TEFL = 1UL<<11, // Tx FIFO Empty Interrupt Line
	FDCAN1_FDCAN_ILS_TCFL = 1UL<<10, // Transmission Cancellation Finished Interrupt Line
	FDCAN1_FDCAN_ILS_TCL = 1UL<<9, // Transmission Completed Interrupt Line
	FDCAN1_FDCAN_ILS_HPML = 1UL<<8, // High Priority Message Interrupt Line
	FDCAN1_FDCAN_ILS_RF1LL = 1UL<<7, // Rx FIFO 1 Message Lost Interrupt Line
	FDCAN1_FDCAN_ILS_RF1FL = 1UL<<6, // Rx FIFO 1 Full Interrupt Line
	FDCAN1_FDCAN_ILS_RF1WL = 1UL<<5, // Rx FIFO 1 Watermark Reached Interrupt Line
	FDCAN1_FDCAN_ILS_RF1NL = 1UL<<4, // Rx FIFO 1 New Message Interrupt Line
	FDCAN1_FDCAN_ILS_RF0LL = 1UL<<3, // Rx FIFO 0 Message Lost Interrupt Line
	FDCAN1_FDCAN_ILS_RF0FL = 1UL<<2, // Rx FIFO 0 Full Interrupt Line
	FDCAN1_FDCAN_ILS_RF0WL = 1UL<<1, // Rx FIFO 0 Watermark Reached Interrupt Line
	FDCAN1_FDCAN_ILS_RF0NL = 1UL<<0, // Rx FIFO 0 New Message Interrupt Line		
};

// FDCAN1->FDCAN_ILE FDCAN Interrupt Line Enable Register
enum {
	FDCAN1_FDCAN_ILE_EINTX  = ((1UL<<2)-1) << 0, // Merged Enable Interrupt Line 1		
};
inline void fdcan1_fdcan_ile_set_eintx (struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_ILE = (p->FDCAN_ILE & ~FDCAN1_FDCAN_ILE_EINTX ) | ((val<<0) & FDCAN1_FDCAN_ILE_EINTX ); }
inline uint32_t fdcan1_fdcan_ile_get_eintx (struct FDCAN1_Type* p) { return (p->FDCAN_ILE & FDCAN1_FDCAN_ILE_EINTX ) >> 0 ; }

// FDCAN1->FDCAN_GFC FDCAN Global Filter Configuration Register
enum {
	FDCAN1_FDCAN_GFC_ANFS = ((1UL<<2)-1) << 4, // Accept Non-matching Frames Standard
	FDCAN1_FDCAN_GFC_ANFE = ((1UL<<2)-1) << 2, // Accept Non-matching Frames Extended
	FDCAN1_FDCAN_GFC_RRFS = 1UL<<1, // Reject Remote Frames Standard
	FDCAN1_FDCAN_GFC_RRFE = 1UL<<0, // Reject Remote Frames Extended		
};
inline void fdcan1_fdcan_gfc_set_anfs(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_GFC = (p->FDCAN_GFC & ~FDCAN1_FDCAN_GFC_ANFS) | ((val<<4) & FDCAN1_FDCAN_GFC_ANFS); }
inline void fdcan1_fdcan_gfc_set_anfe(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_GFC = (p->FDCAN_GFC & ~FDCAN1_FDCAN_GFC_ANFE) | ((val<<2) & FDCAN1_FDCAN_GFC_ANFE); }
inline uint32_t fdcan1_fdcan_gfc_get_anfs(struct FDCAN1_Type* p) { return (p->FDCAN_GFC & FDCAN1_FDCAN_GFC_ANFS) >> 4 ; }
inline uint32_t fdcan1_fdcan_gfc_get_anfe(struct FDCAN1_Type* p) { return (p->FDCAN_GFC & FDCAN1_FDCAN_GFC_ANFE) >> 2 ; }

// FDCAN1->FDCAN_SIDFC FDCAN Standard ID Filter Configuration Register
enum {
	FDCAN1_FDCAN_SIDFC_LSS = ((1UL<<8)-1) << 16, // List Size Standard
	FDCAN1_FDCAN_SIDFC_FLSSA = ((1UL<<14)-1) << 2, // Filter List Standard Start Address		
};
inline void fdcan1_fdcan_sidfc_set_lss(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_SIDFC = (p->FDCAN_SIDFC & ~FDCAN1_FDCAN_SIDFC_LSS) | ((val<<16) & FDCAN1_FDCAN_SIDFC_LSS); }
inline void fdcan1_fdcan_sidfc_set_flssa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_SIDFC = (p->FDCAN_SIDFC & ~FDCAN1_FDCAN_SIDFC_FLSSA) | ((val<<2) & FDCAN1_FDCAN_SIDFC_FLSSA); }
inline uint32_t fdcan1_fdcan_sidfc_get_lss(struct FDCAN1_Type* p) { return (p->FDCAN_SIDFC & FDCAN1_FDCAN_SIDFC_LSS) >> 16 ; }
inline uint32_t fdcan1_fdcan_sidfc_get_flssa(struct FDCAN1_Type* p) { return (p->FDCAN_SIDFC & FDCAN1_FDCAN_SIDFC_FLSSA) >> 2 ; }

// FDCAN1->FDCAN_XIDFC FDCAN Extended ID Filter Configuration Register
enum {
	FDCAN1_FDCAN_XIDFC_LSE = ((1UL<<8)-1) << 16, // List Size Extended
	FDCAN1_FDCAN_XIDFC_FLESA = ((1UL<<14)-1) << 2, // Filter List Standard Start Address		
};
inline void fdcan1_fdcan_xidfc_set_lse(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_XIDFC = (p->FDCAN_XIDFC & ~FDCAN1_FDCAN_XIDFC_LSE) | ((val<<16) & FDCAN1_FDCAN_XIDFC_LSE); }
inline void fdcan1_fdcan_xidfc_set_flesa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_XIDFC = (p->FDCAN_XIDFC & ~FDCAN1_FDCAN_XIDFC_FLESA) | ((val<<2) & FDCAN1_FDCAN_XIDFC_FLESA); }
inline uint32_t fdcan1_fdcan_xidfc_get_lse(struct FDCAN1_Type* p) { return (p->FDCAN_XIDFC & FDCAN1_FDCAN_XIDFC_LSE) >> 16 ; }
inline uint32_t fdcan1_fdcan_xidfc_get_flesa(struct FDCAN1_Type* p) { return (p->FDCAN_XIDFC & FDCAN1_FDCAN_XIDFC_FLESA) >> 2 ; }

// FDCAN1->FDCAN_XIDAM FDCAN Extended ID and Mask Register
enum {
	FDCAN1_FDCAN_XIDAM_EIDM = ((1UL<<29)-1) << 0, // Extended ID Mask		
};
inline void fdcan1_fdcan_xidam_set_eidm(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_XIDAM = (p->FDCAN_XIDAM & ~FDCAN1_FDCAN_XIDAM_EIDM) | ((val<<0) & FDCAN1_FDCAN_XIDAM_EIDM); }
inline uint32_t fdcan1_fdcan_xidam_get_eidm(struct FDCAN1_Type* p) { return (p->FDCAN_XIDAM & FDCAN1_FDCAN_XIDAM_EIDM) >> 0 ; }

// FDCAN1->FDCAN_HPMS FDCAN High Priority Message Status Register
enum {
	FDCAN1_FDCAN_HPMS_FLST = 1UL<<15, // Filter List
	FDCAN1_FDCAN_HPMS_FIDX = ((1UL<<7)-1) << 8, // Filter Index
	FDCAN1_FDCAN_HPMS_MSI = ((1UL<<2)-1) << 6, // Message Storage Indicator
	FDCAN1_FDCAN_HPMS_BIDX = ((1UL<<6)-1) << 0, // Buffer Index		
};
inline uint32_t fdcan1_fdcan_hpms_get_fidx(struct FDCAN1_Type* p) { return (p->FDCAN_HPMS & FDCAN1_FDCAN_HPMS_FIDX) >> 8 ; }
inline uint32_t fdcan1_fdcan_hpms_get_msi(struct FDCAN1_Type* p) { return (p->FDCAN_HPMS & FDCAN1_FDCAN_HPMS_MSI) >> 6 ; }
inline uint32_t fdcan1_fdcan_hpms_get_bidx(struct FDCAN1_Type* p) { return (p->FDCAN_HPMS & FDCAN1_FDCAN_HPMS_BIDX) >> 0 ; }

// FDCAN1->FDCAN_RXF0C FDCAN Rx FIFO 0 Configuration Register
enum {
	FDCAN1_FDCAN_RXF0C_F0WM = ((1UL<<8)-1) << 24, // FIFO 0 Watermark
	FDCAN1_FDCAN_RXF0C_F0S = ((1UL<<8)-1) << 16, // Rx FIFO 0 Size
	FDCAN1_FDCAN_RXF0C_F0SA = ((1UL<<14)-1) << 2, // Rx FIFO 0 Start Address		
};
inline void fdcan1_fdcan_rxf0c_set_f0wm(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0C = (p->FDCAN_RXF0C & ~FDCAN1_FDCAN_RXF0C_F0WM) | ((val<<24) & FDCAN1_FDCAN_RXF0C_F0WM); }
inline void fdcan1_fdcan_rxf0c_set_f0s(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0C = (p->FDCAN_RXF0C & ~FDCAN1_FDCAN_RXF0C_F0S) | ((val<<16) & FDCAN1_FDCAN_RXF0C_F0S); }
inline void fdcan1_fdcan_rxf0c_set_f0sa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0C = (p->FDCAN_RXF0C & ~FDCAN1_FDCAN_RXF0C_F0SA) | ((val<<2) & FDCAN1_FDCAN_RXF0C_F0SA); }
inline uint32_t fdcan1_fdcan_rxf0c_get_f0wm(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0C & FDCAN1_FDCAN_RXF0C_F0WM) >> 24 ; }
inline uint32_t fdcan1_fdcan_rxf0c_get_f0s(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0C & FDCAN1_FDCAN_RXF0C_F0S) >> 16 ; }
inline uint32_t fdcan1_fdcan_rxf0c_get_f0sa(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0C & FDCAN1_FDCAN_RXF0C_F0SA) >> 2 ; }

// FDCAN1->FDCAN_RXF0S FDCAN Rx FIFO 0 Status Register
enum {
	FDCAN1_FDCAN_RXF0S_RF0L = 1UL<<25, // Rx FIFO 0 Message Lost
	FDCAN1_FDCAN_RXF0S_F0F = 1UL<<24, // Rx FIFO 0 Full
	FDCAN1_FDCAN_RXF0S_F0P = ((1UL<<6)-1) << 16, // Rx FIFO 0 Put Index
	FDCAN1_FDCAN_RXF0S_F0G = ((1UL<<6)-1) << 8, // Rx FIFO 0 Get Index
	FDCAN1_FDCAN_RXF0S_F0FL = ((1UL<<7)-1) << 0, // Rx FIFO 0 Fill Level		
};
inline void fdcan1_fdcan_rxf0s_set_f0p(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0S = (p->FDCAN_RXF0S & ~FDCAN1_FDCAN_RXF0S_F0P) | ((val<<16) & FDCAN1_FDCAN_RXF0S_F0P); }
inline void fdcan1_fdcan_rxf0s_set_f0g(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0S = (p->FDCAN_RXF0S & ~FDCAN1_FDCAN_RXF0S_F0G) | ((val<<8) & FDCAN1_FDCAN_RXF0S_F0G); }
inline void fdcan1_fdcan_rxf0s_set_f0fl(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0S = (p->FDCAN_RXF0S & ~FDCAN1_FDCAN_RXF0S_F0FL) | ((val<<0) & FDCAN1_FDCAN_RXF0S_F0FL); }
inline uint32_t fdcan1_fdcan_rxf0s_get_f0p(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0S & FDCAN1_FDCAN_RXF0S_F0P) >> 16 ; }
inline uint32_t fdcan1_fdcan_rxf0s_get_f0g(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0S & FDCAN1_FDCAN_RXF0S_F0G) >> 8 ; }
inline uint32_t fdcan1_fdcan_rxf0s_get_f0fl(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0S & FDCAN1_FDCAN_RXF0S_F0FL) >> 0 ; }

// FDCAN1->FDCAN_RXF0A CAN Rx FIFO 0 Acknowledge Register
enum {
	FDCAN1_FDCAN_RXF0A_FA01 = ((1UL<<6)-1) << 0, // Rx FIFO 0 Acknowledge Index		
};
inline void fdcan1_fdcan_rxf0a_set_fa01(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF0A = (p->FDCAN_RXF0A & ~FDCAN1_FDCAN_RXF0A_FA01) | ((val<<0) & FDCAN1_FDCAN_RXF0A_FA01); }
inline uint32_t fdcan1_fdcan_rxf0a_get_fa01(struct FDCAN1_Type* p) { return (p->FDCAN_RXF0A & FDCAN1_FDCAN_RXF0A_FA01) >> 0 ; }

// FDCAN1->FDCAN_RXBC FDCAN Rx Buffer Configuration Register
enum {
	FDCAN1_FDCAN_RXBC_RBSA = ((1UL<<14)-1) << 2, // Rx Buffer Start Address		
};
inline void fdcan1_fdcan_rxbc_set_rbsa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXBC = (p->FDCAN_RXBC & ~FDCAN1_FDCAN_RXBC_RBSA) | ((val<<2) & FDCAN1_FDCAN_RXBC_RBSA); }
inline uint32_t fdcan1_fdcan_rxbc_get_rbsa(struct FDCAN1_Type* p) { return (p->FDCAN_RXBC & FDCAN1_FDCAN_RXBC_RBSA) >> 2 ; }

// FDCAN1->FDCAN_RXF1C FDCAN Rx FIFO 1 Configuration Register
enum {
	FDCAN1_FDCAN_RXF1C_F1WM = ((1UL<<7)-1) << 24, // Rx FIFO 1 Watermark
	FDCAN1_FDCAN_RXF1C_F1S = ((1UL<<7)-1) << 16, // Rx FIFO 1 Size
	FDCAN1_FDCAN_RXF1C_F1SA = ((1UL<<14)-1) << 2, // Rx FIFO 1 Start Address		
};
inline void fdcan1_fdcan_rxf1c_set_f1wm(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1C = (p->FDCAN_RXF1C & ~FDCAN1_FDCAN_RXF1C_F1WM) | ((val<<24) & FDCAN1_FDCAN_RXF1C_F1WM); }
inline void fdcan1_fdcan_rxf1c_set_f1s(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1C = (p->FDCAN_RXF1C & ~FDCAN1_FDCAN_RXF1C_F1S) | ((val<<16) & FDCAN1_FDCAN_RXF1C_F1S); }
inline void fdcan1_fdcan_rxf1c_set_f1sa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1C = (p->FDCAN_RXF1C & ~FDCAN1_FDCAN_RXF1C_F1SA) | ((val<<2) & FDCAN1_FDCAN_RXF1C_F1SA); }
inline uint32_t fdcan1_fdcan_rxf1c_get_f1wm(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1C & FDCAN1_FDCAN_RXF1C_F1WM) >> 24 ; }
inline uint32_t fdcan1_fdcan_rxf1c_get_f1s(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1C & FDCAN1_FDCAN_RXF1C_F1S) >> 16 ; }
inline uint32_t fdcan1_fdcan_rxf1c_get_f1sa(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1C & FDCAN1_FDCAN_RXF1C_F1SA) >> 2 ; }

// FDCAN1->FDCAN_RXF1S FDCAN Rx FIFO 1 Status Register
enum {
	FDCAN1_FDCAN_RXF1S_DMS = ((1UL<<2)-1) << 30, // Debug Message Status
	FDCAN1_FDCAN_RXF1S_RF1L = 1UL<<25, // Rx FIFO 1 Message Lost
	FDCAN1_FDCAN_RXF1S_F1F = 1UL<<24, // Rx FIFO 1 Full
	FDCAN1_FDCAN_RXF1S_F1PI = ((1UL<<7)-1) << 16, // Rx FIFO 1 Put Index
	FDCAN1_FDCAN_RXF1S_F1GI = ((1UL<<7)-1) << 8, // Rx FIFO 1 Get Index
	FDCAN1_FDCAN_RXF1S_F1FL = ((1UL<<7)-1) << 0, // Rx FIFO 1 Fill Level		
};
inline void fdcan1_fdcan_rxf1s_set_dms(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1S = (p->FDCAN_RXF1S & ~FDCAN1_FDCAN_RXF1S_DMS) | ((val<<30) & FDCAN1_FDCAN_RXF1S_DMS); }
inline void fdcan1_fdcan_rxf1s_set_f1pi(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1S = (p->FDCAN_RXF1S & ~FDCAN1_FDCAN_RXF1S_F1PI) | ((val<<16) & FDCAN1_FDCAN_RXF1S_F1PI); }
inline void fdcan1_fdcan_rxf1s_set_f1gi(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1S = (p->FDCAN_RXF1S & ~FDCAN1_FDCAN_RXF1S_F1GI) | ((val<<8) & FDCAN1_FDCAN_RXF1S_F1GI); }
inline void fdcan1_fdcan_rxf1s_set_f1fl(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1S = (p->FDCAN_RXF1S & ~FDCAN1_FDCAN_RXF1S_F1FL) | ((val<<0) & FDCAN1_FDCAN_RXF1S_F1FL); }
inline uint32_t fdcan1_fdcan_rxf1s_get_dms(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1S & FDCAN1_FDCAN_RXF1S_DMS) >> 30 ; }
inline uint32_t fdcan1_fdcan_rxf1s_get_f1pi(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1S & FDCAN1_FDCAN_RXF1S_F1PI) >> 16 ; }
inline uint32_t fdcan1_fdcan_rxf1s_get_f1gi(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1S & FDCAN1_FDCAN_RXF1S_F1GI) >> 8 ; }
inline uint32_t fdcan1_fdcan_rxf1s_get_f1fl(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1S & FDCAN1_FDCAN_RXF1S_F1FL) >> 0 ; }

// FDCAN1->FDCAN_RXF1A FDCAN Rx FIFO 1 Acknowledge Register
enum {
	FDCAN1_FDCAN_RXF1A_F1AI = ((1UL<<6)-1) << 0, // Rx FIFO 1 Acknowledge Index		
};
inline void fdcan1_fdcan_rxf1a_set_f1ai(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXF1A = (p->FDCAN_RXF1A & ~FDCAN1_FDCAN_RXF1A_F1AI) | ((val<<0) & FDCAN1_FDCAN_RXF1A_F1AI); }
inline uint32_t fdcan1_fdcan_rxf1a_get_f1ai(struct FDCAN1_Type* p) { return (p->FDCAN_RXF1A & FDCAN1_FDCAN_RXF1A_F1AI) >> 0 ; }

// FDCAN1->FDCAN_RXESC FDCAN Rx Buffer Element Size Configuration Register
enum {
	FDCAN1_FDCAN_RXESC_RBDS = ((1UL<<3)-1) << 8, // Rx Buffer Data Field Size:
	FDCAN1_FDCAN_RXESC_F1DS = ((1UL<<3)-1) << 4, // Rx FIFO 0 Data Field Size:
	FDCAN1_FDCAN_RXESC_F0DS = ((1UL<<3)-1) << 0, // Rx FIFO 1 Data Field Size:		
};
inline void fdcan1_fdcan_rxesc_set_rbds(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXESC = (p->FDCAN_RXESC & ~FDCAN1_FDCAN_RXESC_RBDS) | ((val<<8) & FDCAN1_FDCAN_RXESC_RBDS); }
inline void fdcan1_fdcan_rxesc_set_f1ds(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXESC = (p->FDCAN_RXESC & ~FDCAN1_FDCAN_RXESC_F1DS) | ((val<<4) & FDCAN1_FDCAN_RXESC_F1DS); }
inline void fdcan1_fdcan_rxesc_set_f0ds(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_RXESC = (p->FDCAN_RXESC & ~FDCAN1_FDCAN_RXESC_F0DS) | ((val<<0) & FDCAN1_FDCAN_RXESC_F0DS); }
inline uint32_t fdcan1_fdcan_rxesc_get_rbds(struct FDCAN1_Type* p) { return (p->FDCAN_RXESC & FDCAN1_FDCAN_RXESC_RBDS) >> 8 ; }
inline uint32_t fdcan1_fdcan_rxesc_get_f1ds(struct FDCAN1_Type* p) { return (p->FDCAN_RXESC & FDCAN1_FDCAN_RXESC_F1DS) >> 4 ; }
inline uint32_t fdcan1_fdcan_rxesc_get_f0ds(struct FDCAN1_Type* p) { return (p->FDCAN_RXESC & FDCAN1_FDCAN_RXESC_F0DS) >> 0 ; }

// FDCAN1->FDCAN_TXBC FDCAN Tx Buffer Configuration Register
enum {
	FDCAN1_FDCAN_TXBC_TFQM = 1UL<<30, // Tx FIFO/Queue Mode
	FDCAN1_FDCAN_TXBC_TFQS = ((1UL<<6)-1) << 24, // Transmit FIFO/Queue Size
	FDCAN1_FDCAN_TXBC_NDTB = ((1UL<<6)-1) << 16, // Number of Dedicated Transmit Buffers
	FDCAN1_FDCAN_TXBC_TBSA = ((1UL<<14)-1) << 2, // Tx Buffers Start Address		
};
inline void fdcan1_fdcan_txbc_set_tfqs(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXBC = (p->FDCAN_TXBC & ~FDCAN1_FDCAN_TXBC_TFQS) | ((val<<24) & FDCAN1_FDCAN_TXBC_TFQS); }
inline void fdcan1_fdcan_txbc_set_ndtb(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXBC = (p->FDCAN_TXBC & ~FDCAN1_FDCAN_TXBC_NDTB) | ((val<<16) & FDCAN1_FDCAN_TXBC_NDTB); }
inline void fdcan1_fdcan_txbc_set_tbsa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXBC = (p->FDCAN_TXBC & ~FDCAN1_FDCAN_TXBC_TBSA) | ((val<<2) & FDCAN1_FDCAN_TXBC_TBSA); }
inline uint32_t fdcan1_fdcan_txbc_get_tfqs(struct FDCAN1_Type* p) { return (p->FDCAN_TXBC & FDCAN1_FDCAN_TXBC_TFQS) >> 24 ; }
inline uint32_t fdcan1_fdcan_txbc_get_ndtb(struct FDCAN1_Type* p) { return (p->FDCAN_TXBC & FDCAN1_FDCAN_TXBC_NDTB) >> 16 ; }
inline uint32_t fdcan1_fdcan_txbc_get_tbsa(struct FDCAN1_Type* p) { return (p->FDCAN_TXBC & FDCAN1_FDCAN_TXBC_TBSA) >> 2 ; }

// FDCAN1->FDCAN_TXFQS FDCAN Tx FIFO/Queue Status Register
enum {
	FDCAN1_FDCAN_TXFQS_TFQF = 1UL<<21, // Tx FIFO/Queue Full
	FDCAN1_FDCAN_TXFQS_TFQPI = ((1UL<<5)-1) << 16, // Tx FIFO/Queue Put Index
	FDCAN1_FDCAN_TXFQS_TFGI = ((1UL<<5)-1) << 8, // TFGI
	FDCAN1_FDCAN_TXFQS_TFFL = ((1UL<<6)-1) << 0, // Tx FIFO Free Level		
};
inline uint32_t fdcan1_fdcan_txfqs_get_tfqpi(struct FDCAN1_Type* p) { return (p->FDCAN_TXFQS & FDCAN1_FDCAN_TXFQS_TFQPI) >> 16 ; }
inline uint32_t fdcan1_fdcan_txfqs_get_tfgi(struct FDCAN1_Type* p) { return (p->FDCAN_TXFQS & FDCAN1_FDCAN_TXFQS_TFGI) >> 8 ; }
inline uint32_t fdcan1_fdcan_txfqs_get_tffl(struct FDCAN1_Type* p) { return (p->FDCAN_TXFQS & FDCAN1_FDCAN_TXFQS_TFFL) >> 0 ; }

// FDCAN1->FDCAN_TXESC FDCAN Tx Buffer Element Size Configuration Register
enum {
	FDCAN1_FDCAN_TXESC_TBDS = ((1UL<<3)-1) << 0, // Tx Buffer Data Field Size:		
};
inline void fdcan1_fdcan_txesc_set_tbds(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXESC = (p->FDCAN_TXESC & ~FDCAN1_FDCAN_TXESC_TBDS) | ((val<<0) & FDCAN1_FDCAN_TXESC_TBDS); }
inline uint32_t fdcan1_fdcan_txesc_get_tbds(struct FDCAN1_Type* p) { return (p->FDCAN_TXESC & FDCAN1_FDCAN_TXESC_TBDS) >> 0 ; }

// FDCAN1->FDCAN_TXEFC FDCAN Tx Event FIFO Configuration Register
enum {
	FDCAN1_FDCAN_TXEFC_EFWM = ((1UL<<6)-1) << 24, // Event FIFO Watermark
	FDCAN1_FDCAN_TXEFC_EFS = ((1UL<<6)-1) << 16, // Event FIFO Size
	FDCAN1_FDCAN_TXEFC_EFSA = ((1UL<<14)-1) << 2, // Event FIFO Start Address		
};
inline void fdcan1_fdcan_txefc_set_efwm(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXEFC = (p->FDCAN_TXEFC & ~FDCAN1_FDCAN_TXEFC_EFWM) | ((val<<24) & FDCAN1_FDCAN_TXEFC_EFWM); }
inline void fdcan1_fdcan_txefc_set_efs(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXEFC = (p->FDCAN_TXEFC & ~FDCAN1_FDCAN_TXEFC_EFS) | ((val<<16) & FDCAN1_FDCAN_TXEFC_EFS); }
inline void fdcan1_fdcan_txefc_set_efsa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXEFC = (p->FDCAN_TXEFC & ~FDCAN1_FDCAN_TXEFC_EFSA) | ((val<<2) & FDCAN1_FDCAN_TXEFC_EFSA); }
inline uint32_t fdcan1_fdcan_txefc_get_efwm(struct FDCAN1_Type* p) { return (p->FDCAN_TXEFC & FDCAN1_FDCAN_TXEFC_EFWM) >> 24 ; }
inline uint32_t fdcan1_fdcan_txefc_get_efs(struct FDCAN1_Type* p) { return (p->FDCAN_TXEFC & FDCAN1_FDCAN_TXEFC_EFS) >> 16 ; }
inline uint32_t fdcan1_fdcan_txefc_get_efsa(struct FDCAN1_Type* p) { return (p->FDCAN_TXEFC & FDCAN1_FDCAN_TXEFC_EFSA) >> 2 ; }

// FDCAN1->FDCAN_TXEFS FDCAN Tx Event FIFO Status Register
enum {
	FDCAN1_FDCAN_TXEFS_TEFL = 1UL<<25, // Tx Event FIFO Element Lost.
	FDCAN1_FDCAN_TXEFS_EFF = 1UL<<24, // Event FIFO Full.
	FDCAN1_FDCAN_TXEFS_EFGI = ((1UL<<5)-1) << 8, // Event FIFO Get Index.
	FDCAN1_FDCAN_TXEFS_EFFL = ((1UL<<6)-1) << 0, // Event FIFO Fill Level		
};
inline void fdcan1_fdcan_txefs_set_efgi(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXEFS = (p->FDCAN_TXEFS & ~FDCAN1_FDCAN_TXEFS_EFGI) | ((val<<8) & FDCAN1_FDCAN_TXEFS_EFGI); }
inline void fdcan1_fdcan_txefs_set_effl(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXEFS = (p->FDCAN_TXEFS & ~FDCAN1_FDCAN_TXEFS_EFFL) | ((val<<0) & FDCAN1_FDCAN_TXEFS_EFFL); }
inline uint32_t fdcan1_fdcan_txefs_get_efgi(struct FDCAN1_Type* p) { return (p->FDCAN_TXEFS & FDCAN1_FDCAN_TXEFS_EFGI) >> 8 ; }
inline uint32_t fdcan1_fdcan_txefs_get_effl(struct FDCAN1_Type* p) { return (p->FDCAN_TXEFS & FDCAN1_FDCAN_TXEFS_EFFL) >> 0 ; }

// FDCAN1->FDCAN_TXEFA FDCAN Tx Event FIFO Acknowledge Register
enum {
	FDCAN1_FDCAN_TXEFA_EFAI = ((1UL<<5)-1) << 0, // Event FIFO Acknowledge Index		
};
inline void fdcan1_fdcan_txefa_set_efai(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TXEFA = (p->FDCAN_TXEFA & ~FDCAN1_FDCAN_TXEFA_EFAI) | ((val<<0) & FDCAN1_FDCAN_TXEFA_EFAI); }
inline uint32_t fdcan1_fdcan_txefa_get_efai(struct FDCAN1_Type* p) { return (p->FDCAN_TXEFA & FDCAN1_FDCAN_TXEFA_EFAI) >> 0 ; }

// FDCAN1->FDCAN_TTTMC FDCAN TT Trigger Memory Configuration Register
enum {
	FDCAN1_FDCAN_TTTMC_TME = ((1UL<<7)-1) << 16, // Trigger Memory Elements
	FDCAN1_FDCAN_TTTMC_TMSA = ((1UL<<14)-1) << 2, // Trigger Memory Start Address		
};
inline void fdcan1_fdcan_tttmc_set_tme(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTTMC = (p->FDCAN_TTTMC & ~FDCAN1_FDCAN_TTTMC_TME) | ((val<<16) & FDCAN1_FDCAN_TTTMC_TME); }
inline void fdcan1_fdcan_tttmc_set_tmsa(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTTMC = (p->FDCAN_TTTMC & ~FDCAN1_FDCAN_TTTMC_TMSA) | ((val<<2) & FDCAN1_FDCAN_TTTMC_TMSA); }
inline uint32_t fdcan1_fdcan_tttmc_get_tme(struct FDCAN1_Type* p) { return (p->FDCAN_TTTMC & FDCAN1_FDCAN_TTTMC_TME) >> 16 ; }
inline uint32_t fdcan1_fdcan_tttmc_get_tmsa(struct FDCAN1_Type* p) { return (p->FDCAN_TTTMC & FDCAN1_FDCAN_TTTMC_TMSA) >> 2 ; }

// FDCAN1->FDCAN_TTRMC FDCAN TT Reference Message Configuration Register
enum {
	FDCAN1_FDCAN_TTRMC_RMPS = 1UL<<31, // Reference Message Payload Select
	FDCAN1_FDCAN_TTRMC_XTD = 1UL<<30, // Extended Identifier
	FDCAN1_FDCAN_TTRMC_RID = ((1UL<<29)-1) << 0, // Reference Identifier.		
};
inline void fdcan1_fdcan_ttrmc_set_rid(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTRMC = (p->FDCAN_TTRMC & ~FDCAN1_FDCAN_TTRMC_RID) | ((val<<0) & FDCAN1_FDCAN_TTRMC_RID); }
inline uint32_t fdcan1_fdcan_ttrmc_get_rid(struct FDCAN1_Type* p) { return (p->FDCAN_TTRMC & FDCAN1_FDCAN_TTRMC_RID) >> 0 ; }

// FDCAN1->FDCAN_TTOCF FDCAN TT Operation Configuration Register
enum {
	FDCAN1_FDCAN_TTOCF_EVTP = 1UL<<26, // Event Trigger Polarity
	FDCAN1_FDCAN_TTOCF_ECC = 1UL<<25, // Enable Clock Calibration
	FDCAN1_FDCAN_TTOCF_EGTF = 1UL<<24, // Enable Global Time Filtering
	FDCAN1_FDCAN_TTOCF_AWL = ((1UL<<8)-1) << 16, // Application Watchdog Limit
	FDCAN1_FDCAN_TTOCF_EECS = 1UL<<15, // Enable External Clock Synchronization
	FDCAN1_FDCAN_TTOCF_IRTO = ((1UL<<7)-1) << 8, // Initial Reference Trigger Offset
	FDCAN1_FDCAN_TTOCF_LDSDL = ((1UL<<3)-1) << 5, // LD of Synchronization Deviation Limit
	FDCAN1_FDCAN_TTOCF_TM = 1UL<<4, // Time Master
	FDCAN1_FDCAN_TTOCF_GEN = 1UL<<3, // Gap Enable
	FDCAN1_FDCAN_TTOCF_OM = ((1UL<<2)-1) << 0, // Operation Mode		
};
inline void fdcan1_fdcan_ttocf_set_awl(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOCF = (p->FDCAN_TTOCF & ~FDCAN1_FDCAN_TTOCF_AWL) | ((val<<16) & FDCAN1_FDCAN_TTOCF_AWL); }
inline void fdcan1_fdcan_ttocf_set_irto(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOCF = (p->FDCAN_TTOCF & ~FDCAN1_FDCAN_TTOCF_IRTO) | ((val<<8) & FDCAN1_FDCAN_TTOCF_IRTO); }
inline void fdcan1_fdcan_ttocf_set_ldsdl(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOCF = (p->FDCAN_TTOCF & ~FDCAN1_FDCAN_TTOCF_LDSDL) | ((val<<5) & FDCAN1_FDCAN_TTOCF_LDSDL); }
inline void fdcan1_fdcan_ttocf_set_om(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOCF = (p->FDCAN_TTOCF & ~FDCAN1_FDCAN_TTOCF_OM) | ((val<<0) & FDCAN1_FDCAN_TTOCF_OM); }
inline uint32_t fdcan1_fdcan_ttocf_get_awl(struct FDCAN1_Type* p) { return (p->FDCAN_TTOCF & FDCAN1_FDCAN_TTOCF_AWL) >> 16 ; }
inline uint32_t fdcan1_fdcan_ttocf_get_irto(struct FDCAN1_Type* p) { return (p->FDCAN_TTOCF & FDCAN1_FDCAN_TTOCF_IRTO) >> 8 ; }
inline uint32_t fdcan1_fdcan_ttocf_get_ldsdl(struct FDCAN1_Type* p) { return (p->FDCAN_TTOCF & FDCAN1_FDCAN_TTOCF_LDSDL) >> 5 ; }
inline uint32_t fdcan1_fdcan_ttocf_get_om(struct FDCAN1_Type* p) { return (p->FDCAN_TTOCF & FDCAN1_FDCAN_TTOCF_OM) >> 0 ; }

// FDCAN1->FDCAN_TTMLM FDCAN TT Matrix Limits Register
enum {
	FDCAN1_FDCAN_TTMLM_ENTT = ((1UL<<12)-1) << 16, // Expected Number of Tx Triggers
	FDCAN1_FDCAN_TTMLM_TXEW = ((1UL<<4)-1) << 8, // Tx Enable Window
	FDCAN1_FDCAN_TTMLM_CSS = ((1UL<<2)-1) << 6, // Cycle Start Synchronization
	FDCAN1_FDCAN_TTMLM_CCM = ((1UL<<6)-1) << 0, // Cycle Count Max		
};
inline void fdcan1_fdcan_ttmlm_set_entt(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTMLM = (p->FDCAN_TTMLM & ~FDCAN1_FDCAN_TTMLM_ENTT) | ((val<<16) & FDCAN1_FDCAN_TTMLM_ENTT); }
inline void fdcan1_fdcan_ttmlm_set_txew(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTMLM = (p->FDCAN_TTMLM & ~FDCAN1_FDCAN_TTMLM_TXEW) | ((val<<8) & FDCAN1_FDCAN_TTMLM_TXEW); }
inline void fdcan1_fdcan_ttmlm_set_css(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTMLM = (p->FDCAN_TTMLM & ~FDCAN1_FDCAN_TTMLM_CSS) | ((val<<6) & FDCAN1_FDCAN_TTMLM_CSS); }
inline void fdcan1_fdcan_ttmlm_set_ccm(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTMLM = (p->FDCAN_TTMLM & ~FDCAN1_FDCAN_TTMLM_CCM) | ((val<<0) & FDCAN1_FDCAN_TTMLM_CCM); }
inline uint32_t fdcan1_fdcan_ttmlm_get_entt(struct FDCAN1_Type* p) { return (p->FDCAN_TTMLM & FDCAN1_FDCAN_TTMLM_ENTT) >> 16 ; }
inline uint32_t fdcan1_fdcan_ttmlm_get_txew(struct FDCAN1_Type* p) { return (p->FDCAN_TTMLM & FDCAN1_FDCAN_TTMLM_TXEW) >> 8 ; }
inline uint32_t fdcan1_fdcan_ttmlm_get_css(struct FDCAN1_Type* p) { return (p->FDCAN_TTMLM & FDCAN1_FDCAN_TTMLM_CSS) >> 6 ; }
inline uint32_t fdcan1_fdcan_ttmlm_get_ccm(struct FDCAN1_Type* p) { return (p->FDCAN_TTMLM & FDCAN1_FDCAN_TTMLM_CCM) >> 0 ; }

// FDCAN1->FDCAN_TURCF FDCAN TUR Configuration Register
enum {
	FDCAN1_FDCAN_TURCF_ELT = 1UL<<31, // Enable Local Time
	FDCAN1_FDCAN_TURCF_DC = ((1UL<<14)-1) << 16, // Denominator Configuration.
	FDCAN1_FDCAN_TURCF_NCL = ((1UL<<16)-1) << 0, // Numerator Configuration Low.		
};
inline void fdcan1_fdcan_turcf_set_dc(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TURCF = (p->FDCAN_TURCF & ~FDCAN1_FDCAN_TURCF_DC) | ((val<<16) & FDCAN1_FDCAN_TURCF_DC); }
inline void fdcan1_fdcan_turcf_set_ncl(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TURCF = (p->FDCAN_TURCF & ~FDCAN1_FDCAN_TURCF_NCL) | ((val<<0) & FDCAN1_FDCAN_TURCF_NCL); }
inline uint32_t fdcan1_fdcan_turcf_get_dc(struct FDCAN1_Type* p) { return (p->FDCAN_TURCF & FDCAN1_FDCAN_TURCF_DC) >> 16 ; }
inline uint32_t fdcan1_fdcan_turcf_get_ncl(struct FDCAN1_Type* p) { return (p->FDCAN_TURCF & FDCAN1_FDCAN_TURCF_NCL) >> 0 ; }

// FDCAN1->FDCAN_TTOCN FDCAN TT Operation Control Register
enum {
	FDCAN1_FDCAN_TTOCN_LCKC = 1UL<<15, // TT Operation Control Register Locked
	FDCAN1_FDCAN_TTOCN_ESCN = 1UL<<13, // External Synchronization Control
	FDCAN1_FDCAN_TTOCN_NIG = 1UL<<12, // Next is Gap
	FDCAN1_FDCAN_TTOCN_TMG = 1UL<<11, // Time Mark Gap
	FDCAN1_FDCAN_TTOCN_FGP = 1UL<<10, // Finish Gap.
	FDCAN1_FDCAN_TTOCN_GCS = 1UL<<9, // Gap Control Select
	FDCAN1_FDCAN_TTOCN_TTIE = 1UL<<8, // Trigger Time Mark Interrupt Pulse Enable
	FDCAN1_FDCAN_TTOCN_TMC = ((1UL<<2)-1) << 6, // Register Time Mark Compare
	FDCAN1_FDCAN_TTOCN_RTIE = 1UL<<5, // Register Time Mark Interrupt Pulse Enable
	FDCAN1_FDCAN_TTOCN_SWS = ((1UL<<2)-1) << 3, // Stop Watch Source.
	FDCAN1_FDCAN_TTOCN_SWP = 1UL<<2, // Stop Watch Polarity
	FDCAN1_FDCAN_TTOCN_ECS = 1UL<<1, // External Clock Synchronization
	FDCAN1_FDCAN_TTOCN_SGT = 1UL<<0, // Set Global time		
};
inline void fdcan1_fdcan_ttocn_set_tmc(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOCN = (p->FDCAN_TTOCN & ~FDCAN1_FDCAN_TTOCN_TMC) | ((val<<6) & FDCAN1_FDCAN_TTOCN_TMC); }
inline void fdcan1_fdcan_ttocn_set_sws(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOCN = (p->FDCAN_TTOCN & ~FDCAN1_FDCAN_TTOCN_SWS) | ((val<<3) & FDCAN1_FDCAN_TTOCN_SWS); }
inline uint32_t fdcan1_fdcan_ttocn_get_tmc(struct FDCAN1_Type* p) { return (p->FDCAN_TTOCN & FDCAN1_FDCAN_TTOCN_TMC) >> 6 ; }
inline uint32_t fdcan1_fdcan_ttocn_get_sws(struct FDCAN1_Type* p) { return (p->FDCAN_TTOCN & FDCAN1_FDCAN_TTOCN_SWS) >> 3 ; }

// FDCAN1->CAN_TTGTP FDCAN TT Global Time Preset Register
enum {
	FDCAN1_CAN_TTGTP_CTP = ((1UL<<16)-1) << 16, // Cycle Time Target Phase
	FDCAN1_CAN_TTGTP_NCL = ((1UL<<16)-1) << 0, // Time Preset		
};
inline void fdcan1_can_ttgtp_set_ctp(struct FDCAN1_Type* p, uint32_t val) { p->CAN_TTGTP = (p->CAN_TTGTP & ~FDCAN1_CAN_TTGTP_CTP) | ((val<<16) & FDCAN1_CAN_TTGTP_CTP); }
inline void fdcan1_can_ttgtp_set_ncl(struct FDCAN1_Type* p, uint32_t val) { p->CAN_TTGTP = (p->CAN_TTGTP & ~FDCAN1_CAN_TTGTP_NCL) | ((val<<0) & FDCAN1_CAN_TTGTP_NCL); }
inline uint32_t fdcan1_can_ttgtp_get_ctp(struct FDCAN1_Type* p) { return (p->CAN_TTGTP & FDCAN1_CAN_TTGTP_CTP) >> 16 ; }
inline uint32_t fdcan1_can_ttgtp_get_ncl(struct FDCAN1_Type* p) { return (p->CAN_TTGTP & FDCAN1_CAN_TTGTP_NCL) >> 0 ; }

// FDCAN1->FDCAN_TTTMK FDCAN TT Time Mark Register
enum {
	FDCAN1_FDCAN_TTTMK_LCKM = 1UL<<31, // TT Time Mark Register Locked
	FDCAN1_FDCAN_TTTMK_TICC = ((1UL<<7)-1) << 16, // Time Mark Cycle Code
	FDCAN1_FDCAN_TTTMK_TM = ((1UL<<16)-1) << 0, // Time Mark		
};
inline void fdcan1_fdcan_tttmk_set_ticc(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTTMK = (p->FDCAN_TTTMK & ~FDCAN1_FDCAN_TTTMK_TICC) | ((val<<16) & FDCAN1_FDCAN_TTTMK_TICC); }
inline void fdcan1_fdcan_tttmk_set_tm(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTTMK = (p->FDCAN_TTTMK & ~FDCAN1_FDCAN_TTTMK_TM) | ((val<<0) & FDCAN1_FDCAN_TTTMK_TM); }
inline uint32_t fdcan1_fdcan_tttmk_get_ticc(struct FDCAN1_Type* p) { return (p->FDCAN_TTTMK & FDCAN1_FDCAN_TTTMK_TICC) >> 16 ; }
inline uint32_t fdcan1_fdcan_tttmk_get_tm(struct FDCAN1_Type* p) { return (p->FDCAN_TTTMK & FDCAN1_FDCAN_TTTMK_TM) >> 0 ; }

// FDCAN1->FDCAN_TTIR FDCAN TT Interrupt Register
enum {
	FDCAN1_FDCAN_TTIR_CER = 1UL<<18, // Configuration Error
	FDCAN1_FDCAN_TTIR_AW = 1UL<<17, // Application Watchdog
	FDCAN1_FDCAN_TTIR_WT = 1UL<<16, // Watch Trigger
	FDCAN1_FDCAN_TTIR_IWTG = 1UL<<15, // Initialization Watch Trigger
	FDCAN1_FDCAN_TTIR_ELC = 1UL<<14, // Error Level Changed.
	FDCAN1_FDCAN_TTIR_SE2 = 1UL<<13, // Scheduling Error 2
	FDCAN1_FDCAN_TTIR_SE1 = 1UL<<12, // Scheduling Error 1
	FDCAN1_FDCAN_TTIR_TXO = 1UL<<11, // Tx Count Overflow
	FDCAN1_FDCAN_TTIR_TXU = 1UL<<10, // Tx Count Underflow
	FDCAN1_FDCAN_TTIR_GTE = 1UL<<9, // Global Time Error
	FDCAN1_FDCAN_TTIR_GTD = 1UL<<8, // Global Time Discontinuity
	FDCAN1_FDCAN_TTIR_GTW = 1UL<<7, // Global Time Wrap
	FDCAN1_FDCAN_TTIR_SWE = 1UL<<6, // Stop Watch Event
	FDCAN1_FDCAN_TTIR_TTMI = 1UL<<5, // Trigger Time Mark Event Internal
	FDCAN1_FDCAN_TTIR_RTMI = 1UL<<4, // Register Time Mark Interrupt.
	FDCAN1_FDCAN_TTIR_SOG = 1UL<<3, // Start of Gap
	FDCAN1_FDCAN_TTIR_CSM = 1UL<<2, // Change of Synchronization Mode
	FDCAN1_FDCAN_TTIR_SMC = 1UL<<1, // Start of Matrix Cycle
	FDCAN1_FDCAN_TTIR_SBC = 1UL<<0, // Start of Basic Cycle		
};

// FDCAN1->FDCAN_TTIE FDCAN TT Interrupt Enable Register
enum {
	FDCAN1_FDCAN_TTIE_CERE = 1UL<<18, // Configuration Error Interrupt Enable
	FDCAN1_FDCAN_TTIE_AWE = 1UL<<17, // Application Watchdog Interrupt Enable
	FDCAN1_FDCAN_TTIE_WTE = 1UL<<16, // Watch Trigger Interrupt Enable
	FDCAN1_FDCAN_TTIE_IWTGE = 1UL<<15, // Initialization Watch Trigger Interrupt Enable
	FDCAN1_FDCAN_TTIE_ELCE = 1UL<<14, // Change Error Level Interrupt Enable
	FDCAN1_FDCAN_TTIE_SE2E = 1UL<<13, // Scheduling Error 2 Interrupt Enable
	FDCAN1_FDCAN_TTIE_SE1E = 1UL<<12, // Scheduling Error 1 Interrupt Enable
	FDCAN1_FDCAN_TTIE_TXOE = 1UL<<11, // Tx Count Overflow Interrupt Enable
	FDCAN1_FDCAN_TTIE_TXUE = 1UL<<10, // Tx Count Underflow Interrupt Enable
	FDCAN1_FDCAN_TTIE_GTEE = 1UL<<9, // Global Time Error Interrupt Enable
	FDCAN1_FDCAN_TTIE_GTDE = 1UL<<8, // Global Time Discontinuity Interrupt Enable
	FDCAN1_FDCAN_TTIE_GTWE = 1UL<<7, // Global Time Wrap Interrupt Enable
	FDCAN1_FDCAN_TTIE_SWEE = 1UL<<6, // Stop Watch Event Interrupt Enable
	FDCAN1_FDCAN_TTIE_TTMIE = 1UL<<5, // Trigger Time Mark Event Internal Interrupt Enable
	FDCAN1_FDCAN_TTIE_RTMIE = 1UL<<4, // Register Time Mark Interrupt Enable
	FDCAN1_FDCAN_TTIE_SOGE = 1UL<<3, // Start of Gap Interrupt Enable
	FDCAN1_FDCAN_TTIE_CSME = 1UL<<2, // Change of Synchronization Mode Interrupt Enable
	FDCAN1_FDCAN_TTIE_SMCE = 1UL<<1, // Start of Matrix Cycle Interrupt Enable
	FDCAN1_FDCAN_TTIE_SBCE = 1UL<<0, // Start of Basic Cycle Interrupt Enable		
};

// FDCAN1->FDCAN_TTILS FDCAN TT Interrupt Line Select Register
enum {
	FDCAN1_FDCAN_TTILS_CERL = 1UL<<18, // Configuration Error Interrupt Line
	FDCAN1_FDCAN_TTILS_AWL = 1UL<<17, // Application Watchdog Interrupt Line
	FDCAN1_FDCAN_TTILS_WTL = 1UL<<16, // Watch Trigger Interrupt Line
	FDCAN1_FDCAN_TTILS_IWTGL = 1UL<<15, // Initialization Watch Trigger Interrupt Line
	FDCAN1_FDCAN_TTILS_ELCL = 1UL<<14, // Change Error Level Interrupt Line
	FDCAN1_FDCAN_TTILS_SE2L = 1UL<<13, // Scheduling Error 2 Interrupt Line
	FDCAN1_FDCAN_TTILS_SE1L = 1UL<<12, // Scheduling Error 1 Interrupt Line
	FDCAN1_FDCAN_TTILS_TXOL = 1UL<<11, // Tx Count Overflow Interrupt Line
	FDCAN1_FDCAN_TTILS_TXUL = 1UL<<10, // Tx Count Underflow Interrupt Line
	FDCAN1_FDCAN_TTILS_GTEL = 1UL<<9, // Global Time Error Interrupt Line
	FDCAN1_FDCAN_TTILS_GTDL = 1UL<<8, // Global Time Discontinuity Interrupt Line
	FDCAN1_FDCAN_TTILS_GTWL = 1UL<<7, // Global Time Wrap Interrupt Line
	FDCAN1_FDCAN_TTILS_SWEL = 1UL<<6, // Stop Watch Event Interrupt Line
	FDCAN1_FDCAN_TTILS_TTMIL = 1UL<<5, // Trigger Time Mark Event Internal Interrupt Line
	FDCAN1_FDCAN_TTILS_RTMIL = 1UL<<4, // Register Time Mark Interrupt Line
	FDCAN1_FDCAN_TTILS_SOGL = 1UL<<3, // Start of Gap Interrupt Line
	FDCAN1_FDCAN_TTILS_CSML = 1UL<<2, // Change of Synchronization Mode Interrupt Line
	FDCAN1_FDCAN_TTILS_SMCL = 1UL<<1, // Start of Matrix Cycle Interrupt Line
	FDCAN1_FDCAN_TTILS_SBCL = 1UL<<0, // Start of Basic Cycle Interrupt Line		
};

// FDCAN1->FDCAN_TTOST FDCAN TT Operation Status Register
enum {
	FDCAN1_FDCAN_TTOST_SPL = 1UL<<31, // Schedule Phase Lock
	FDCAN1_FDCAN_TTOST_WECS = 1UL<<30, // Wait for External Clock Synchronization
	FDCAN1_FDCAN_TTOST_AWE = 1UL<<29, // Application Watchdog Event
	FDCAN1_FDCAN_TTOST_WFE = 1UL<<28, // Wait for Event
	FDCAN1_FDCAN_TTOST_GSI = 1UL<<27, // Gap Started Indicator.
	FDCAN1_FDCAN_TTOST_TMP = ((1UL<<3)-1) << 24, // Time Master Priority
	FDCAN1_FDCAN_TTOST_GFI = 1UL<<23, // Gap Finished Indicator.
	FDCAN1_FDCAN_TTOST_WGTD = 1UL<<22, // Wait for Global Time Discontinuity
	FDCAN1_FDCAN_TTOST_RTO = ((1UL<<8)-1) << 8, // Reference Trigger Offset
	FDCAN1_FDCAN_TTOST_QCS = 1UL<<7, // Quality of Clock Speed
	FDCAN1_FDCAN_TTOST_GTP = 1UL<<6, // Quality of Global Time Phase
	FDCAN1_FDCAN_TTOST_SYS = ((1UL<<2)-1) << 4, // Synchronization State
	FDCAN1_FDCAN_TTOST_MS = ((1UL<<2)-1) << 2, // Master State.
	FDCAN1_FDCAN_TTOST_EL = ((1UL<<2)-1) << 0, // Error Level		
};
inline void fdcan1_fdcan_ttost_set_tmp(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOST = (p->FDCAN_TTOST & ~FDCAN1_FDCAN_TTOST_TMP) | ((val<<24) & FDCAN1_FDCAN_TTOST_TMP); }
inline void fdcan1_fdcan_ttost_set_rto(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOST = (p->FDCAN_TTOST & ~FDCAN1_FDCAN_TTOST_RTO) | ((val<<8) & FDCAN1_FDCAN_TTOST_RTO); }
inline void fdcan1_fdcan_ttost_set_sys(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOST = (p->FDCAN_TTOST & ~FDCAN1_FDCAN_TTOST_SYS) | ((val<<4) & FDCAN1_FDCAN_TTOST_SYS); }
inline void fdcan1_fdcan_ttost_set_ms(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOST = (p->FDCAN_TTOST & ~FDCAN1_FDCAN_TTOST_MS) | ((val<<2) & FDCAN1_FDCAN_TTOST_MS); }
inline void fdcan1_fdcan_ttost_set_el(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTOST = (p->FDCAN_TTOST & ~FDCAN1_FDCAN_TTOST_EL) | ((val<<0) & FDCAN1_FDCAN_TTOST_EL); }
inline uint32_t fdcan1_fdcan_ttost_get_tmp(struct FDCAN1_Type* p) { return (p->FDCAN_TTOST & FDCAN1_FDCAN_TTOST_TMP) >> 24 ; }
inline uint32_t fdcan1_fdcan_ttost_get_rto(struct FDCAN1_Type* p) { return (p->FDCAN_TTOST & FDCAN1_FDCAN_TTOST_RTO) >> 8 ; }
inline uint32_t fdcan1_fdcan_ttost_get_sys(struct FDCAN1_Type* p) { return (p->FDCAN_TTOST & FDCAN1_FDCAN_TTOST_SYS) >> 4 ; }
inline uint32_t fdcan1_fdcan_ttost_get_ms(struct FDCAN1_Type* p) { return (p->FDCAN_TTOST & FDCAN1_FDCAN_TTOST_MS) >> 2 ; }
inline uint32_t fdcan1_fdcan_ttost_get_el(struct FDCAN1_Type* p) { return (p->FDCAN_TTOST & FDCAN1_FDCAN_TTOST_EL) >> 0 ; }

// FDCAN1->FDCAN_TURNA FDCAN TUR Numerator Actual Register
enum {
	FDCAN1_FDCAN_TURNA_NAV = ((1UL<<18)-1) << 0, // Numerator Actual Value		
};
inline uint32_t fdcan1_fdcan_turna_get_nav(struct FDCAN1_Type* p) { return (p->FDCAN_TURNA & FDCAN1_FDCAN_TURNA_NAV) >> 0 ; }

// FDCAN1->FDCAN_TTLGT FDCAN TT Local and Global Time Register
enum {
	FDCAN1_FDCAN_TTLGT_GT = ((1UL<<16)-1) << 16, // Global Time
	FDCAN1_FDCAN_TTLGT_LT = ((1UL<<16)-1) << 0, // Local Time		
};
inline uint32_t fdcan1_fdcan_ttlgt_get_gt(struct FDCAN1_Type* p) { return (p->FDCAN_TTLGT & FDCAN1_FDCAN_TTLGT_GT) >> 16 ; }
inline uint32_t fdcan1_fdcan_ttlgt_get_lt(struct FDCAN1_Type* p) { return (p->FDCAN_TTLGT & FDCAN1_FDCAN_TTLGT_LT) >> 0 ; }

// FDCAN1->FDCAN_TTCTC FDCAN TT Cycle Time and Count Register
enum {
	FDCAN1_FDCAN_TTCTC_CC = ((1UL<<6)-1) << 16, // Cycle Count
	FDCAN1_FDCAN_TTCTC_CT = ((1UL<<16)-1) << 0, // Cycle Time		
};
inline uint32_t fdcan1_fdcan_ttctc_get_cc(struct FDCAN1_Type* p) { return (p->FDCAN_TTCTC & FDCAN1_FDCAN_TTCTC_CC) >> 16 ; }
inline uint32_t fdcan1_fdcan_ttctc_get_ct(struct FDCAN1_Type* p) { return (p->FDCAN_TTCTC & FDCAN1_FDCAN_TTCTC_CT) >> 0 ; }

// FDCAN1->FDCAN_TTCPT FDCAN TT Capture Time Register
enum {
	FDCAN1_FDCAN_TTCPT_SWV = ((1UL<<16)-1) << 16, // Stop Watch Value
	FDCAN1_FDCAN_TTCPT_CT = ((1UL<<6)-1) << 0, // Cycle Count Value		
};
inline uint32_t fdcan1_fdcan_ttcpt_get_swv(struct FDCAN1_Type* p) { return (p->FDCAN_TTCPT & FDCAN1_FDCAN_TTCPT_SWV) >> 16 ; }
inline uint32_t fdcan1_fdcan_ttcpt_get_ct(struct FDCAN1_Type* p) { return (p->FDCAN_TTCPT & FDCAN1_FDCAN_TTCPT_CT) >> 0 ; }

// FDCAN1->FDCAN_TTTS FDCAN TT Trigger Select Register
enum {
	FDCAN1_FDCAN_TTTS_EVTSEL = ((1UL<<2)-1) << 4, // Event trigger input selection
	FDCAN1_FDCAN_TTTS_SWTDEL = ((1UL<<2)-1) << 0, // Stop watch trigger input selection		
};
inline void fdcan1_fdcan_ttts_set_evtsel(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTTS = (p->FDCAN_TTTS & ~FDCAN1_FDCAN_TTTS_EVTSEL) | ((val<<4) & FDCAN1_FDCAN_TTTS_EVTSEL); }
inline void fdcan1_fdcan_ttts_set_swtdel(struct FDCAN1_Type* p, uint32_t val) { p->FDCAN_TTTS = (p->FDCAN_TTTS & ~FDCAN1_FDCAN_TTTS_SWTDEL) | ((val<<0) & FDCAN1_FDCAN_TTTS_SWTDEL); }
inline uint32_t fdcan1_fdcan_ttts_get_evtsel(struct FDCAN1_Type* p) { return (p->FDCAN_TTTS & FDCAN1_FDCAN_TTTS_EVTSEL) >> 4 ; }
inline uint32_t fdcan1_fdcan_ttts_get_swtdel(struct FDCAN1_Type* p) { return (p->FDCAN_TTTS & FDCAN1_FDCAN_TTTS_SWTDEL) >> 0 ; }


/* FMC */
struct FMC_Type {
	__IO uint32_t BCR1; // @0 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	__IO uint32_t BTR1; // @4 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	__IO uint32_t BCR2; // @8 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	__IO uint32_t BTR2; // @12 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	__IO uint32_t BCR3; // @16 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	__IO uint32_t BTR3; // @20 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	__IO uint32_t BCR4; // @24 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
	__IO uint32_t BTR4; // @28 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
	 uint8_t RESERVED0[96]; // @32 
	__IO uint32_t PCR; // @128 NAND Flash control registers
	__IO uint8_t SR; // @132 This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
	 uint8_t RESERVED1[3]; // @133 
	__IO uint32_t PMEM; // @136 The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
	__IO uint32_t PATT; // @140 The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
	 uint8_t RESERVED2[4]; // @144 
	__I uint32_t ECCR; // @148 This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
	 uint8_t RESERVED3[108]; // @152 
	__IO uint32_t BWTR1; // @260 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	 uint8_t RESERVED4[4]; // @264 
	__IO uint32_t BWTR2; // @268 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	 uint8_t RESERVED5[4]; // @272 
	__IO uint32_t BWTR3; // @276 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	 uint8_t RESERVED6[4]; // @280 
	__IO uint32_t BWTR4; // @284 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
	 uint8_t RESERVED7[32]; // @288 
	__IO uint16_t SDCR1; // @320 This register contains the control parameters for each SDRAM memory bank
	 uint8_t RESERVED8[2]; // @322 
	__IO uint16_t SDCR2; // @324 This register contains the control parameters for each SDRAM memory bank
	 uint8_t RESERVED9[2]; // @326 
	__IO uint32_t SDTR1; // @328 This register contains the timing parameters of each SDRAM bank
	__IO uint32_t SDTR2; // @332 This register contains the timing parameters of each SDRAM bank
	__IO uint32_t SDCMR; // @336 This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
	__IO uint16_t SDRTR; // @340 This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
	 uint8_t RESERVED10[2]; // @342 
	__I uint8_t SDSR; // @344 SDRAM Status register
};

// FMC->BCR1 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
enum {
	FMC_BCR1_FMCEN = 1UL<<31, // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR1_BMAP = ((1UL<<2)-1) << 24, // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR1_WFDIS = 1UL<<21, // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR1_CCLKEN = 1UL<<20, // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
	FMC_BCR1_CBURSTRW = 1UL<<19, // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
	FMC_BCR1_CPSIZE = ((1UL<<3)-1) << 16, // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
	FMC_BCR1_ASYNCWAIT = 1UL<<15, // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
	FMC_BCR1_EXTMOD = 1UL<<14, // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
	FMC_BCR1_WAITEN = 1UL<<13, // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
	FMC_BCR1_WREN = 1UL<<12, // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
	FMC_BCR1_WAITCFG = 1UL<<11, // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
	FMC_BCR1_WAITPOL = 1UL<<9, // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
	FMC_BCR1_BURSTEN = 1UL<<8, // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
	FMC_BCR1_FACCEN = 1UL<<6, // Flash access enable This bit enables NOR Flash memory access operations.
	FMC_BCR1_MWID = ((1UL<<2)-1) << 4, // Memory data bus width Defines the external memory device width, valid for all type of memories.
	FMC_BCR1_MTYP = ((1UL<<2)-1) << 2, // Memory type These bits define the type of external memory attached to the corresponding memory bank:
	FMC_BCR1_MUXEN = 1UL<<1, // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
	FMC_BCR1_MBKEN = 1UL<<0, // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.		
};
inline void fmc_bcr1_set_bmap(struct FMC_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~FMC_BCR1_BMAP) | ((val<<24) & FMC_BCR1_BMAP); }
inline void fmc_bcr1_set_cpsize(struct FMC_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~FMC_BCR1_CPSIZE) | ((val<<16) & FMC_BCR1_CPSIZE); }
inline void fmc_bcr1_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~FMC_BCR1_MWID) | ((val<<4) & FMC_BCR1_MWID); }
inline void fmc_bcr1_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~FMC_BCR1_MTYP) | ((val<<2) & FMC_BCR1_MTYP); }
inline uint32_t fmc_bcr1_get_bmap(struct FMC_Type* p) { return (p->BCR1 & FMC_BCR1_BMAP) >> 24 ; }
inline uint32_t fmc_bcr1_get_cpsize(struct FMC_Type* p) { return (p->BCR1 & FMC_BCR1_CPSIZE) >> 16 ; }
inline uint32_t fmc_bcr1_get_mwid(struct FMC_Type* p) { return (p->BCR1 & FMC_BCR1_MWID) >> 4 ; }
inline uint32_t fmc_bcr1_get_mtyp(struct FMC_Type* p) { return (p->BCR1 & FMC_BCR1_MTYP) >> 2 ; }

// FMC->BTR1 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
enum {
	FMC_BTR1_ACCMOD = ((1UL<<2)-1) << 28, // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BTR1_DATLAT = ((1UL<<4)-1) << 24, // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
	FMC_BTR1_CLKDIV = ((1UL<<4)-1) << 20, // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
	FMC_BTR1_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
	FMC_BTR1_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
	FMC_BTR1_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
	FMC_BTR1_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.		
};
inline void fmc_btr1_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_ACCMOD) | ((val<<28) & FMC_BTR1_ACCMOD); }
inline void fmc_btr1_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATLAT) | ((val<<24) & FMC_BTR1_DATLAT); }
inline void fmc_btr1_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_CLKDIV) | ((val<<20) & FMC_BTR1_CLKDIV); }
inline void fmc_btr1_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_BUSTURN) | ((val<<16) & FMC_BTR1_BUSTURN); }
inline void fmc_btr1_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATAST) | ((val<<8) & FMC_BTR1_DATAST); }
inline void fmc_btr1_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_ADDHLD) | ((val<<4) & FMC_BTR1_ADDHLD); }
inline void fmc_btr1_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR1 = (p->BTR1 & ~FMC_BTR1_ADDSET) | ((val<<0) & FMC_BTR1_ADDSET); }
inline uint32_t fmc_btr1_get_accmod(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr1_get_datlat(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_DATLAT) >> 24 ; }
inline uint32_t fmc_btr1_get_clkdiv(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr1_get_busturn(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr1_get_datast(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_DATAST) >> 8 ; }
inline uint32_t fmc_btr1_get_addhld(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr1_get_addset(struct FMC_Type* p) { return (p->BTR1 & FMC_BTR1_ADDSET) >> 0 ; }

// FMC->BCR2 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
enum {
	FMC_BCR2_FMCEN = 1UL<<31, // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR2_BMAP = ((1UL<<2)-1) << 24, // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR2_WFDIS = 1UL<<21, // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR2_CCLKEN = 1UL<<20, // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
	FMC_BCR2_CBURSTRW = 1UL<<19, // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
	FMC_BCR2_CPSIZE = ((1UL<<3)-1) << 16, // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
	FMC_BCR2_ASYNCWAIT = 1UL<<15, // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
	FMC_BCR2_EXTMOD = 1UL<<14, // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
	FMC_BCR2_WAITEN = 1UL<<13, // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
	FMC_BCR2_WREN = 1UL<<12, // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
	FMC_BCR2_WAITCFG = 1UL<<11, // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
	FMC_BCR2_WAITPOL = 1UL<<9, // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
	FMC_BCR2_BURSTEN = 1UL<<8, // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
	FMC_BCR2_FACCEN = 1UL<<6, // Flash access enable This bit enables NOR Flash memory access operations.
	FMC_BCR2_MWID = ((1UL<<2)-1) << 4, // Memory data bus width Defines the external memory device width, valid for all type of memories.
	FMC_BCR2_MTYP = ((1UL<<2)-1) << 2, // Memory type These bits define the type of external memory attached to the corresponding memory bank:
	FMC_BCR2_MUXEN = 1UL<<1, // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
	FMC_BCR2_MBKEN = 1UL<<0, // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.		
};
inline void fmc_bcr2_set_bmap(struct FMC_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~FMC_BCR2_BMAP) | ((val<<24) & FMC_BCR2_BMAP); }
inline void fmc_bcr2_set_cpsize(struct FMC_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~FMC_BCR2_CPSIZE) | ((val<<16) & FMC_BCR2_CPSIZE); }
inline void fmc_bcr2_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~FMC_BCR2_MWID) | ((val<<4) & FMC_BCR2_MWID); }
inline void fmc_bcr2_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~FMC_BCR2_MTYP) | ((val<<2) & FMC_BCR2_MTYP); }
inline uint32_t fmc_bcr2_get_bmap(struct FMC_Type* p) { return (p->BCR2 & FMC_BCR2_BMAP) >> 24 ; }
inline uint32_t fmc_bcr2_get_cpsize(struct FMC_Type* p) { return (p->BCR2 & FMC_BCR2_CPSIZE) >> 16 ; }
inline uint32_t fmc_bcr2_get_mwid(struct FMC_Type* p) { return (p->BCR2 & FMC_BCR2_MWID) >> 4 ; }
inline uint32_t fmc_bcr2_get_mtyp(struct FMC_Type* p) { return (p->BCR2 & FMC_BCR2_MTYP) >> 2 ; }

// FMC->BTR2 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
enum {
	FMC_BTR2_ACCMOD = ((1UL<<2)-1) << 28, // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BTR2_DATLAT = ((1UL<<4)-1) << 24, // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
	FMC_BTR2_CLKDIV = ((1UL<<4)-1) << 20, // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
	FMC_BTR2_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1. ...
	FMC_BTR2_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
	FMC_BTR2_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
	FMC_BTR2_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.		
};
inline void fmc_btr2_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_ACCMOD) | ((val<<28) & FMC_BTR2_ACCMOD); }
inline void fmc_btr2_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATLAT) | ((val<<24) & FMC_BTR2_DATLAT); }
inline void fmc_btr2_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_CLKDIV) | ((val<<20) & FMC_BTR2_CLKDIV); }
inline void fmc_btr2_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_BUSTURN) | ((val<<16) & FMC_BTR2_BUSTURN); }
inline void fmc_btr2_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATAST) | ((val<<8) & FMC_BTR2_DATAST); }
inline void fmc_btr2_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_ADDHLD) | ((val<<4) & FMC_BTR2_ADDHLD); }
inline void fmc_btr2_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR2 = (p->BTR2 & ~FMC_BTR2_ADDSET) | ((val<<0) & FMC_BTR2_ADDSET); }
inline uint32_t fmc_btr2_get_accmod(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr2_get_datlat(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_DATLAT) >> 24 ; }
inline uint32_t fmc_btr2_get_clkdiv(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr2_get_busturn(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr2_get_datast(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_DATAST) >> 8 ; }
inline uint32_t fmc_btr2_get_addhld(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr2_get_addset(struct FMC_Type* p) { return (p->BTR2 & FMC_BTR2_ADDSET) >> 0 ; }

// FMC->BCR3 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
enum {
	FMC_BCR3_FMCEN = 1UL<<31, // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR3_BMAP = ((1UL<<2)-1) << 24, // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR3_WFDIS = 1UL<<21, // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR3_CCLKEN = 1UL<<20, // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
	FMC_BCR3_CBURSTRW = 1UL<<19, // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
	FMC_BCR3_CPSIZE = ((1UL<<3)-1) << 16, // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
	FMC_BCR3_ASYNCWAIT = 1UL<<15, // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
	FMC_BCR3_EXTMOD = 1UL<<14, // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
	FMC_BCR3_WAITEN = 1UL<<13, // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
	FMC_BCR3_WREN = 1UL<<12, // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
	FMC_BCR3_WAITCFG = 1UL<<11, // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
	FMC_BCR3_WAITPOL = 1UL<<9, // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
	FMC_BCR3_BURSTEN = 1UL<<8, // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
	FMC_BCR3_FACCEN = 1UL<<6, // Flash access enable This bit enables NOR Flash memory access operations.
	FMC_BCR3_MWID = ((1UL<<2)-1) << 4, // Memory data bus width Defines the external memory device width, valid for all type of memories.
	FMC_BCR3_MTYP = ((1UL<<2)-1) << 2, // Memory type These bits define the type of external memory attached to the corresponding memory bank:
	FMC_BCR3_MUXEN = 1UL<<1, // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
	FMC_BCR3_MBKEN = 1UL<<0, // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.		
};
inline void fmc_bcr3_set_bmap(struct FMC_Type* p, uint32_t val) { p->BCR3 = (p->BCR3 & ~FMC_BCR3_BMAP) | ((val<<24) & FMC_BCR3_BMAP); }
inline void fmc_bcr3_set_cpsize(struct FMC_Type* p, uint32_t val) { p->BCR3 = (p->BCR3 & ~FMC_BCR3_CPSIZE) | ((val<<16) & FMC_BCR3_CPSIZE); }
inline void fmc_bcr3_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR3 = (p->BCR3 & ~FMC_BCR3_MWID) | ((val<<4) & FMC_BCR3_MWID); }
inline void fmc_bcr3_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR3 = (p->BCR3 & ~FMC_BCR3_MTYP) | ((val<<2) & FMC_BCR3_MTYP); }
inline uint32_t fmc_bcr3_get_bmap(struct FMC_Type* p) { return (p->BCR3 & FMC_BCR3_BMAP) >> 24 ; }
inline uint32_t fmc_bcr3_get_cpsize(struct FMC_Type* p) { return (p->BCR3 & FMC_BCR3_CPSIZE) >> 16 ; }
inline uint32_t fmc_bcr3_get_mwid(struct FMC_Type* p) { return (p->BCR3 & FMC_BCR3_MWID) >> 4 ; }
inline uint32_t fmc_bcr3_get_mtyp(struct FMC_Type* p) { return (p->BCR3 & FMC_BCR3_MTYP) >> 2 ; }

// FMC->BTR3 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
enum {
	FMC_BTR3_ACCMOD = ((1UL<<2)-1) << 28, // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BTR3_DATLAT = ((1UL<<4)-1) << 24, // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
	FMC_BTR3_CLKDIV = ((1UL<<4)-1) << 20, // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
	FMC_BTR3_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
	FMC_BTR3_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
	FMC_BTR3_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
	FMC_BTR3_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.		
};
inline void fmc_btr3_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_ACCMOD) | ((val<<28) & FMC_BTR3_ACCMOD); }
inline void fmc_btr3_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATLAT) | ((val<<24) & FMC_BTR3_DATLAT); }
inline void fmc_btr3_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_CLKDIV) | ((val<<20) & FMC_BTR3_CLKDIV); }
inline void fmc_btr3_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_BUSTURN) | ((val<<16) & FMC_BTR3_BUSTURN); }
inline void fmc_btr3_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATAST) | ((val<<8) & FMC_BTR3_DATAST); }
inline void fmc_btr3_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_ADDHLD) | ((val<<4) & FMC_BTR3_ADDHLD); }
inline void fmc_btr3_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR3 = (p->BTR3 & ~FMC_BTR3_ADDSET) | ((val<<0) & FMC_BTR3_ADDSET); }
inline uint32_t fmc_btr3_get_accmod(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr3_get_datlat(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_DATLAT) >> 24 ; }
inline uint32_t fmc_btr3_get_clkdiv(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr3_get_busturn(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr3_get_datast(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_DATAST) >> 8 ; }
inline uint32_t fmc_btr3_get_addhld(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr3_get_addset(struct FMC_Type* p) { return (p->BTR3 & FMC_BTR3_ADDSET) >> 0 ; }

// FMC->BCR4 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
enum {
	FMC_BCR4_FMCEN = 1UL<<31, // FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR4_BMAP = ((1UL<<2)-1) << 24, // FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR4_WFDIS = 1UL<<21, // Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
	FMC_BCR4_CCLKEN = 1UL<<20, // Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
	FMC_BCR4_CBURSTRW = 1UL<<19, // Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
	FMC_BCR4_CPSIZE = ((1UL<<3)-1) << 16, // CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
	FMC_BCR4_ASYNCWAIT = 1UL<<15, // Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
	FMC_BCR4_EXTMOD = 1UL<<14, // Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
	FMC_BCR4_WAITEN = 1UL<<13, // Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
	FMC_BCR4_WREN = 1UL<<12, // Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
	FMC_BCR4_WAITCFG = 1UL<<11, // Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
	FMC_BCR4_WAITPOL = 1UL<<9, // Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
	FMC_BCR4_BURSTEN = 1UL<<8, // Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
	FMC_BCR4_FACCEN = 1UL<<6, // Flash access enable This bit enables NOR Flash memory access operations.
	FMC_BCR4_MWID = ((1UL<<2)-1) << 4, // Memory data bus width Defines the external memory device width, valid for all type of memories.
	FMC_BCR4_MTYP = ((1UL<<2)-1) << 2, // Memory type These bits define the type of external memory attached to the corresponding memory bank:
	FMC_BCR4_MUXEN = 1UL<<1, // Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
	FMC_BCR4_MBKEN = 1UL<<0, // Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.		
};
inline void fmc_bcr4_set_bmap(struct FMC_Type* p, uint32_t val) { p->BCR4 = (p->BCR4 & ~FMC_BCR4_BMAP) | ((val<<24) & FMC_BCR4_BMAP); }
inline void fmc_bcr4_set_cpsize(struct FMC_Type* p, uint32_t val) { p->BCR4 = (p->BCR4 & ~FMC_BCR4_CPSIZE) | ((val<<16) & FMC_BCR4_CPSIZE); }
inline void fmc_bcr4_set_mwid(struct FMC_Type* p, uint32_t val) { p->BCR4 = (p->BCR4 & ~FMC_BCR4_MWID) | ((val<<4) & FMC_BCR4_MWID); }
inline void fmc_bcr4_set_mtyp(struct FMC_Type* p, uint32_t val) { p->BCR4 = (p->BCR4 & ~FMC_BCR4_MTYP) | ((val<<2) & FMC_BCR4_MTYP); }
inline uint32_t fmc_bcr4_get_bmap(struct FMC_Type* p) { return (p->BCR4 & FMC_BCR4_BMAP) >> 24 ; }
inline uint32_t fmc_bcr4_get_cpsize(struct FMC_Type* p) { return (p->BCR4 & FMC_BCR4_CPSIZE) >> 16 ; }
inline uint32_t fmc_bcr4_get_mwid(struct FMC_Type* p) { return (p->BCR4 & FMC_BCR4_MWID) >> 4 ; }
inline uint32_t fmc_bcr4_get_mtyp(struct FMC_Type* p) { return (p->BCR4 & FMC_BCR4_MTYP) >> 2 ; }

// FMC->BTR4 This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
enum {
	FMC_BTR4_ACCMOD = ((1UL<<2)-1) << 28, // Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BTR4_DATLAT = ((1UL<<4)-1) << 24, // Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
	FMC_BTR4_CLKDIV = ((1UL<<4)-1) << 20, // Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
	FMC_BTR4_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
	FMC_BTR4_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
	FMC_BTR4_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
	FMC_BTR4_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.		
};
inline void fmc_btr4_set_accmod(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_ACCMOD) | ((val<<28) & FMC_BTR4_ACCMOD); }
inline void fmc_btr4_set_datlat(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATLAT) | ((val<<24) & FMC_BTR4_DATLAT); }
inline void fmc_btr4_set_clkdiv(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_CLKDIV) | ((val<<20) & FMC_BTR4_CLKDIV); }
inline void fmc_btr4_set_busturn(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_BUSTURN) | ((val<<16) & FMC_BTR4_BUSTURN); }
inline void fmc_btr4_set_datast(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATAST) | ((val<<8) & FMC_BTR4_DATAST); }
inline void fmc_btr4_set_addhld(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_ADDHLD) | ((val<<4) & FMC_BTR4_ADDHLD); }
inline void fmc_btr4_set_addset(struct FMC_Type* p, uint32_t val) { p->BTR4 = (p->BTR4 & ~FMC_BTR4_ADDSET) | ((val<<0) & FMC_BTR4_ADDSET); }
inline uint32_t fmc_btr4_get_accmod(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_ACCMOD) >> 28 ; }
inline uint32_t fmc_btr4_get_datlat(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_DATLAT) >> 24 ; }
inline uint32_t fmc_btr4_get_clkdiv(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_CLKDIV) >> 20 ; }
inline uint32_t fmc_btr4_get_busturn(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_BUSTURN) >> 16 ; }
inline uint32_t fmc_btr4_get_datast(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_DATAST) >> 8 ; }
inline uint32_t fmc_btr4_get_addhld(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_ADDHLD) >> 4 ; }
inline uint32_t fmc_btr4_get_addset(struct FMC_Type* p) { return (p->BTR4 & FMC_BTR4_ADDSET) >> 0 ; }

// FMC->PCR NAND Flash control registers
enum {
	FMC_PCR_ECCPS = ((1UL<<3)-1) << 17, // ECC page size. These bits define the page size for the extended ECC:
	FMC_PCR_TAR = ((1UL<<4)-1) << 13, // ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
	FMC_PCR_TCLR = ((1UL<<4)-1) << 9, // CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
	FMC_PCR_ECCEN = 1UL<<6, // ECC computation logic enable bit
	FMC_PCR_PWID = ((1UL<<2)-1) << 4, // Data bus width. These bits define the external memory device width.
	FMC_PCR_PBKEN = 1UL<<2, // NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
	FMC_PCR_PWAITEN = 1UL<<1, // Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:		
};
inline void fmc_pcr_set_eccps(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_ECCPS) | ((val<<17) & FMC_PCR_ECCPS); }
inline void fmc_pcr_set_tar(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_TAR) | ((val<<13) & FMC_PCR_TAR); }
inline void fmc_pcr_set_tclr(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_TCLR) | ((val<<9) & FMC_PCR_TCLR); }
inline void fmc_pcr_set_pwid(struct FMC_Type* p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_PWID) | ((val<<4) & FMC_PCR_PWID); }
inline uint32_t fmc_pcr_get_eccps(struct FMC_Type* p) { return (p->PCR & FMC_PCR_ECCPS) >> 17 ; }
inline uint32_t fmc_pcr_get_tar(struct FMC_Type* p) { return (p->PCR & FMC_PCR_TAR) >> 13 ; }
inline uint32_t fmc_pcr_get_tclr(struct FMC_Type* p) { return (p->PCR & FMC_PCR_TCLR) >> 9 ; }
inline uint32_t fmc_pcr_get_pwid(struct FMC_Type* p) { return (p->PCR & FMC_PCR_PWID) >> 4 ; }

// FMC->SR This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
enum {
	FMC_SR_FEMPT = 1UL<<6, // FIFO empty. Read-only bit that provides the status of the FIFO
	FMC_SR_IFEN = 1UL<<5, // Interrupt falling edge detection enable bit
	FMC_SR_ILEN = 1UL<<4, // Interrupt high-level detection enable bit
	FMC_SR_IREN = 1UL<<3, // Interrupt rising edge detection enable bit
	FMC_SR_IFS = 1UL<<2, // Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
	FMC_SR_ILS = 1UL<<1, // Interrupt high-level status The flag is set by hardware and reset by software.
	FMC_SR_IRS = 1UL<<0, // Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.		
};

// FMC->PMEM The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
enum {
	FMC_PMEM_MEMHIZ = ((1UL<<8)-1) << 24, // Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
	FMC_PMEM_MEMHOLD = ((1UL<<8)-1) << 16, // Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
	FMC_PMEM_MEMWAIT = ((1UL<<8)-1) << 8, // Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
	FMC_PMEM_MEMSET = ((1UL<<8)-1) << 0, // Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:		
};
inline void fmc_pmem_set_memhiz(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMHIZ) | ((val<<24) & FMC_PMEM_MEMHIZ); }
inline void fmc_pmem_set_memhold(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMHOLD) | ((val<<16) & FMC_PMEM_MEMHOLD); }
inline void fmc_pmem_set_memwait(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMWAIT) | ((val<<8) & FMC_PMEM_MEMWAIT); }
inline void fmc_pmem_set_memset(struct FMC_Type* p, uint32_t val) { p->PMEM = (p->PMEM & ~FMC_PMEM_MEMSET) | ((val<<0) & FMC_PMEM_MEMSET); }
inline uint32_t fmc_pmem_get_memhiz(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMHIZ) >> 24 ; }
inline uint32_t fmc_pmem_get_memhold(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMHOLD) >> 16 ; }
inline uint32_t fmc_pmem_get_memwait(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMWAIT) >> 8 ; }
inline uint32_t fmc_pmem_get_memset(struct FMC_Type* p) { return (p->PMEM & FMC_PMEM_MEMSET) >> 0 ; }

// FMC->PATT The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
enum {
	FMC_PATT_ATTHIZ = ((1UL<<8)-1) << 24, // Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
	FMC_PATT_ATTHOLD = ((1UL<<8)-1) << 16, // Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
	FMC_PATT_ATTWAIT = ((1UL<<8)-1) << 8, // Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
	FMC_PATT_ATTSET = ((1UL<<8)-1) << 0, // Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:		
};
inline void fmc_patt_set_atthiz(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTHIZ) | ((val<<24) & FMC_PATT_ATTHIZ); }
inline void fmc_patt_set_atthold(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTHOLD) | ((val<<16) & FMC_PATT_ATTHOLD); }
inline void fmc_patt_set_attwait(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTWAIT) | ((val<<8) & FMC_PATT_ATTWAIT); }
inline void fmc_patt_set_attset(struct FMC_Type* p, uint32_t val) { p->PATT = (p->PATT & ~FMC_PATT_ATTSET) | ((val<<0) & FMC_PATT_ATTSET); }
inline uint32_t fmc_patt_get_atthiz(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTHIZ) >> 24 ; }
inline uint32_t fmc_patt_get_atthold(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTHOLD) >> 16 ; }
inline uint32_t fmc_patt_get_attwait(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTWAIT) >> 8 ; }
inline uint32_t fmc_patt_get_attset(struct FMC_Type* p) { return (p->PATT & FMC_PATT_ATTSET) >> 0 ; }

// FMC->BWTR1 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
enum {
	FMC_BWTR1_ACCMOD = ((1UL<<2)-1) << 28, // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BWTR1_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
	FMC_BWTR1_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
	FMC_BWTR1_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
	FMC_BWTR1_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.		
};
inline void fmc_bwtr1_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ACCMOD) | ((val<<28) & FMC_BWTR1_ACCMOD); }
inline void fmc_bwtr1_set_busturn(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_BUSTURN) | ((val<<16) & FMC_BWTR1_BUSTURN); }
inline void fmc_bwtr1_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_DATAST) | ((val<<8) & FMC_BWTR1_DATAST); }
inline void fmc_bwtr1_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ADDHLD) | ((val<<4) & FMC_BWTR1_ADDHLD); }
inline void fmc_bwtr1_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ADDSET) | ((val<<0) & FMC_BWTR1_ADDSET); }
inline uint32_t fmc_bwtr1_get_accmod(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr1_get_busturn(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_BUSTURN) >> 16 ; }
inline uint32_t fmc_bwtr1_get_datast(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr1_get_addhld(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr1_get_addset(struct FMC_Type* p) { return (p->BWTR1 & FMC_BWTR1_ADDSET) >> 0 ; }

// FMC->BWTR2 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
enum {
	FMC_BWTR2_ACCMOD = ((1UL<<2)-1) << 28, // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BWTR2_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
	FMC_BWTR2_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
	FMC_BWTR2_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
	FMC_BWTR2_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.		
};
inline void fmc_bwtr2_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ACCMOD) | ((val<<28) & FMC_BWTR2_ACCMOD); }
inline void fmc_bwtr2_set_busturn(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_BUSTURN) | ((val<<16) & FMC_BWTR2_BUSTURN); }
inline void fmc_bwtr2_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_DATAST) | ((val<<8) & FMC_BWTR2_DATAST); }
inline void fmc_bwtr2_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ADDHLD) | ((val<<4) & FMC_BWTR2_ADDHLD); }
inline void fmc_bwtr2_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ADDSET) | ((val<<0) & FMC_BWTR2_ADDSET); }
inline uint32_t fmc_bwtr2_get_accmod(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr2_get_busturn(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_BUSTURN) >> 16 ; }
inline uint32_t fmc_bwtr2_get_datast(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr2_get_addhld(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr2_get_addset(struct FMC_Type* p) { return (p->BWTR2 & FMC_BWTR2_ADDSET) >> 0 ; }

// FMC->BWTR3 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
enum {
	FMC_BWTR3_ACCMOD = ((1UL<<2)-1) << 28, // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BWTR3_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
	FMC_BWTR3_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
	FMC_BWTR3_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
	FMC_BWTR3_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.		
};
inline void fmc_bwtr3_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ACCMOD) | ((val<<28) & FMC_BWTR3_ACCMOD); }
inline void fmc_bwtr3_set_busturn(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_BUSTURN) | ((val<<16) & FMC_BWTR3_BUSTURN); }
inline void fmc_bwtr3_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_DATAST) | ((val<<8) & FMC_BWTR3_DATAST); }
inline void fmc_bwtr3_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ADDHLD) | ((val<<4) & FMC_BWTR3_ADDHLD); }
inline void fmc_bwtr3_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ADDSET) | ((val<<0) & FMC_BWTR3_ADDSET); }
inline uint32_t fmc_bwtr3_get_accmod(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr3_get_busturn(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_BUSTURN) >> 16 ; }
inline uint32_t fmc_bwtr3_get_datast(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr3_get_addhld(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr3_get_addset(struct FMC_Type* p) { return (p->BWTR3 & FMC_BWTR3_ADDSET) >> 0 ; }

// FMC->BWTR4 This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
enum {
	FMC_BWTR4_ACCMOD = ((1UL<<2)-1) << 28, // Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
	FMC_BWTR4_BUSTURN = ((1UL<<4)-1) << 16, // Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
	FMC_BWTR4_DATAST = ((1UL<<8)-1) << 8, // Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
	FMC_BWTR4_ADDHLD = ((1UL<<4)-1) << 4, // Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
	FMC_BWTR4_ADDSET = ((1UL<<4)-1) << 0, // Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.		
};
inline void fmc_bwtr4_set_accmod(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ACCMOD) | ((val<<28) & FMC_BWTR4_ACCMOD); }
inline void fmc_bwtr4_set_busturn(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_BUSTURN) | ((val<<16) & FMC_BWTR4_BUSTURN); }
inline void fmc_bwtr4_set_datast(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_DATAST) | ((val<<8) & FMC_BWTR4_DATAST); }
inline void fmc_bwtr4_set_addhld(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ADDHLD) | ((val<<4) & FMC_BWTR4_ADDHLD); }
inline void fmc_bwtr4_set_addset(struct FMC_Type* p, uint32_t val) { p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ADDSET) | ((val<<0) & FMC_BWTR4_ADDSET); }
inline uint32_t fmc_bwtr4_get_accmod(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_ACCMOD) >> 28 ; }
inline uint32_t fmc_bwtr4_get_busturn(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_BUSTURN) >> 16 ; }
inline uint32_t fmc_bwtr4_get_datast(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_DATAST) >> 8 ; }
inline uint32_t fmc_bwtr4_get_addhld(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_ADDHLD) >> 4 ; }
inline uint32_t fmc_bwtr4_get_addset(struct FMC_Type* p) { return (p->BWTR4 & FMC_BWTR4_ADDSET) >> 0 ; }

// FMC->SDCR1 This register contains the control parameters for each SDRAM memory bank
enum {
	FMC_SDCR1_RPIPE = ((1UL<<2)-1) << 13, // Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
	FMC_SDCR1_RBURST = 1UL<<12, // Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
	FMC_SDCR1_SDCLK = ((1UL<<2)-1) << 10, // SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
	FMC_SDCR1_WP = 1UL<<9, // Write protection This bit enables write mode access to the SDRAM bank.
	FMC_SDCR1_CAS = ((1UL<<2)-1) << 7, // CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
	FMC_SDCR1_NB = 1UL<<6, // Number of internal banks This bit sets the number of internal banks.
	FMC_SDCR1_MWID = ((1UL<<2)-1) << 4, // Memory data bus width. These bits define the memory device width.
	FMC_SDCR1_NR = ((1UL<<2)-1) << 2, // Number of row address bits These bits define the number of bits of a row address.
	FMC_SDCR1_NC = ((1UL<<2)-1) << 0, // Number of column address bits These bits define the number of bits of a column address.		
};
inline void fmc_sdcr1_set_rpipe(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_RPIPE) | ((val<<13) & FMC_SDCR1_RPIPE); }
inline void fmc_sdcr1_set_sdclk(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_SDCLK) | ((val<<10) & FMC_SDCR1_SDCLK); }
inline void fmc_sdcr1_set_cas(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_CAS) | ((val<<7) & FMC_SDCR1_CAS); }
inline void fmc_sdcr1_set_mwid(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_MWID) | ((val<<4) & FMC_SDCR1_MWID); }
inline void fmc_sdcr1_set_nr(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_NR) | ((val<<2) & FMC_SDCR1_NR); }
inline void fmc_sdcr1_set_nc(struct FMC_Type* p, uint32_t val) { p->SDCR1 = (p->SDCR1 & ~FMC_SDCR1_NC) | ((val<<0) & FMC_SDCR1_NC); }
inline uint32_t fmc_sdcr1_get_rpipe(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_RPIPE) >> 13 ; }
inline uint32_t fmc_sdcr1_get_sdclk(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_SDCLK) >> 10 ; }
inline uint32_t fmc_sdcr1_get_cas(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_CAS) >> 7 ; }
inline uint32_t fmc_sdcr1_get_mwid(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_MWID) >> 4 ; }
inline uint32_t fmc_sdcr1_get_nr(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_NR) >> 2 ; }
inline uint32_t fmc_sdcr1_get_nc(struct FMC_Type* p) { return (p->SDCR1 & FMC_SDCR1_NC) >> 0 ; }

// FMC->SDCR2 This register contains the control parameters for each SDRAM memory bank
enum {
	FMC_SDCR2_RPIPE = ((1UL<<2)-1) << 13, // Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
	FMC_SDCR2_RBURST = 1UL<<12, // Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
	FMC_SDCR2_SDCLK = ((1UL<<2)-1) << 10, // SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
	FMC_SDCR2_WP = 1UL<<9, // Write protection This bit enables write mode access to the SDRAM bank.
	FMC_SDCR2_CAS = ((1UL<<2)-1) << 7, // CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
	FMC_SDCR2_NB = 1UL<<6, // Number of internal banks This bit sets the number of internal banks.
	FMC_SDCR2_MWID = ((1UL<<2)-1) << 4, // Memory data bus width. These bits define the memory device width.
	FMC_SDCR2_NR = ((1UL<<2)-1) << 2, // Number of row address bits These bits define the number of bits of a row address.
	FMC_SDCR2_NC = ((1UL<<2)-1) << 0, // Number of column address bits These bits define the number of bits of a column address.		
};
inline void fmc_sdcr2_set_rpipe(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_RPIPE) | ((val<<13) & FMC_SDCR2_RPIPE); }
inline void fmc_sdcr2_set_sdclk(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_SDCLK) | ((val<<10) & FMC_SDCR2_SDCLK); }
inline void fmc_sdcr2_set_cas(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_CAS) | ((val<<7) & FMC_SDCR2_CAS); }
inline void fmc_sdcr2_set_mwid(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_MWID) | ((val<<4) & FMC_SDCR2_MWID); }
inline void fmc_sdcr2_set_nr(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_NR) | ((val<<2) & FMC_SDCR2_NR); }
inline void fmc_sdcr2_set_nc(struct FMC_Type* p, uint32_t val) { p->SDCR2 = (p->SDCR2 & ~FMC_SDCR2_NC) | ((val<<0) & FMC_SDCR2_NC); }
inline uint32_t fmc_sdcr2_get_rpipe(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_RPIPE) >> 13 ; }
inline uint32_t fmc_sdcr2_get_sdclk(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_SDCLK) >> 10 ; }
inline uint32_t fmc_sdcr2_get_cas(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_CAS) >> 7 ; }
inline uint32_t fmc_sdcr2_get_mwid(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_MWID) >> 4 ; }
inline uint32_t fmc_sdcr2_get_nr(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_NR) >> 2 ; }
inline uint32_t fmc_sdcr2_get_nc(struct FMC_Type* p) { return (p->SDCR2 & FMC_SDCR2_NC) >> 0 ; }

// FMC->SDTR1 This register contains the timing parameters of each SDRAM bank
enum {
	FMC_SDTR1_TRCD = ((1UL<<4)-1) << 24, // Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
	FMC_SDTR1_TRP = ((1UL<<4)-1) << 20, // Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
	FMC_SDTR1_TWR = ((1UL<<4)-1) << 16, // Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
	FMC_SDTR1_TRC = ((1UL<<4)-1) << 12, // Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
	FMC_SDTR1_TRAS = ((1UL<<4)-1) << 8, // Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
	FMC_SDTR1_TXSR = ((1UL<<4)-1) << 4, // Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
	FMC_SDTR1_TMRD = ((1UL<<4)-1) << 0, // Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....		
};
inline void fmc_sdtr1_set_trcd(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRCD) | ((val<<24) & FMC_SDTR1_TRCD); }
inline void fmc_sdtr1_set_trp(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRP) | ((val<<20) & FMC_SDTR1_TRP); }
inline void fmc_sdtr1_set_twr(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TWR) | ((val<<16) & FMC_SDTR1_TWR); }
inline void fmc_sdtr1_set_trc(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRC) | ((val<<12) & FMC_SDTR1_TRC); }
inline void fmc_sdtr1_set_tras(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TRAS) | ((val<<8) & FMC_SDTR1_TRAS); }
inline void fmc_sdtr1_set_txsr(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TXSR) | ((val<<4) & FMC_SDTR1_TXSR); }
inline void fmc_sdtr1_set_tmrd(struct FMC_Type* p, uint32_t val) { p->SDTR1 = (p->SDTR1 & ~FMC_SDTR1_TMRD) | ((val<<0) & FMC_SDTR1_TMRD); }
inline uint32_t fmc_sdtr1_get_trcd(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRCD) >> 24 ; }
inline uint32_t fmc_sdtr1_get_trp(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRP) >> 20 ; }
inline uint32_t fmc_sdtr1_get_twr(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TWR) >> 16 ; }
inline uint32_t fmc_sdtr1_get_trc(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRC) >> 12 ; }
inline uint32_t fmc_sdtr1_get_tras(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TRAS) >> 8 ; }
inline uint32_t fmc_sdtr1_get_txsr(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TXSR) >> 4 ; }
inline uint32_t fmc_sdtr1_get_tmrd(struct FMC_Type* p) { return (p->SDTR1 & FMC_SDTR1_TMRD) >> 0 ; }

// FMC->SDTR2 This register contains the timing parameters of each SDRAM bank
enum {
	FMC_SDTR2_TRCD = ((1UL<<4)-1) << 24, // Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
	FMC_SDTR2_TRP = ((1UL<<4)-1) << 20, // Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
	FMC_SDTR2_TWR = ((1UL<<4)-1) << 16, // Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
	FMC_SDTR2_TRC = ((1UL<<4)-1) << 12, // Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
	FMC_SDTR2_TRAS = ((1UL<<4)-1) << 8, // Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
	FMC_SDTR2_TXSR = ((1UL<<4)-1) << 4, // Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
	FMC_SDTR2_TMRD = ((1UL<<4)-1) << 0, // Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....		
};
inline void fmc_sdtr2_set_trcd(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRCD) | ((val<<24) & FMC_SDTR2_TRCD); }
inline void fmc_sdtr2_set_trp(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRP) | ((val<<20) & FMC_SDTR2_TRP); }
inline void fmc_sdtr2_set_twr(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TWR) | ((val<<16) & FMC_SDTR2_TWR); }
inline void fmc_sdtr2_set_trc(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRC) | ((val<<12) & FMC_SDTR2_TRC); }
inline void fmc_sdtr2_set_tras(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TRAS) | ((val<<8) & FMC_SDTR2_TRAS); }
inline void fmc_sdtr2_set_txsr(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TXSR) | ((val<<4) & FMC_SDTR2_TXSR); }
inline void fmc_sdtr2_set_tmrd(struct FMC_Type* p, uint32_t val) { p->SDTR2 = (p->SDTR2 & ~FMC_SDTR2_TMRD) | ((val<<0) & FMC_SDTR2_TMRD); }
inline uint32_t fmc_sdtr2_get_trcd(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRCD) >> 24 ; }
inline uint32_t fmc_sdtr2_get_trp(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRP) >> 20 ; }
inline uint32_t fmc_sdtr2_get_twr(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TWR) >> 16 ; }
inline uint32_t fmc_sdtr2_get_trc(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRC) >> 12 ; }
inline uint32_t fmc_sdtr2_get_tras(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TRAS) >> 8 ; }
inline uint32_t fmc_sdtr2_get_txsr(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TXSR) >> 4 ; }
inline uint32_t fmc_sdtr2_get_tmrd(struct FMC_Type* p) { return (p->SDTR2 & FMC_SDTR2_TMRD) >> 0 ; }

// FMC->SDCMR This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
enum {
	FMC_SDCMR_MRD = ((1UL<<14)-1) << 9, // Mode Register definition This 14-bit field defines the SDRAM Mode Register content. The Mode Register is programmed using the Load Mode Register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM.
	FMC_SDCMR_NRFS = ((1UL<<4)-1) << 5, // Number of Auto-refresh These bits define the number of consecutive Auto-refresh commands issued when MODE = 011. ....
	FMC_SDCMR_CTB1 = 1UL<<4, // Command Target Bank 1 This bit indicates whether the command will be issued to SDRAM Bank 1 or not.
	FMC_SDCMR_CTB2 = 1UL<<3, // Command Target Bank 2 This bit indicates whether the command will be issued to SDRAM Bank 2 or not.
	FMC_SDCMR_MODE = ((1UL<<3)-1) << 0, // Command mode These bits define the command issued to the SDRAM device. Note: When a command is issued, at least one Command Target Bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: If two SDRAM banks are used, the Auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: If only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0.		
};
inline void fmc_sdcmr_set_mrd(struct FMC_Type* p, uint32_t val) { p->SDCMR = (p->SDCMR & ~FMC_SDCMR_MRD) | ((val<<9) & FMC_SDCMR_MRD); }
inline void fmc_sdcmr_set_nrfs(struct FMC_Type* p, uint32_t val) { p->SDCMR = (p->SDCMR & ~FMC_SDCMR_NRFS) | ((val<<5) & FMC_SDCMR_NRFS); }
inline void fmc_sdcmr_set_mode(struct FMC_Type* p, uint32_t val) { p->SDCMR = (p->SDCMR & ~FMC_SDCMR_MODE) | ((val<<0) & FMC_SDCMR_MODE); }
inline uint32_t fmc_sdcmr_get_mrd(struct FMC_Type* p) { return (p->SDCMR & FMC_SDCMR_MRD) >> 9 ; }
inline uint32_t fmc_sdcmr_get_nrfs(struct FMC_Type* p) { return (p->SDCMR & FMC_SDCMR_NRFS) >> 5 ; }
inline uint32_t fmc_sdcmr_get_mode(struct FMC_Type* p) { return (p->SDCMR & FMC_SDCMR_MODE) >> 0 ; }

// FMC->SDRTR This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
enum {
	FMC_SDRTR_REIE = 1UL<<14, // RES Interrupt Enable
	FMC_SDRTR_COUNT = ((1UL<<13)-1) << 1, // Refresh Timer Count This 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / Number of rows) - 20
	FMC_SDRTR_CRE = 1UL<<0, // Clear Refresh error flag This bit is used to clear the Refresh Error Flag (RE) in the Status Register.		
};
inline void fmc_sdrtr_set_count(struct FMC_Type* p, uint32_t val) { p->SDRTR = (p->SDRTR & ~FMC_SDRTR_COUNT) | ((val<<1) & FMC_SDRTR_COUNT); }
inline uint32_t fmc_sdrtr_get_count(struct FMC_Type* p) { return (p->SDRTR & FMC_SDRTR_COUNT) >> 1 ; }

// FMC->SDSR SDRAM Status register
enum {
	FMC_SDSR_MODES2 = ((1UL<<2)-1) << 3, // Status Mode for Bank 2 These bits define the Status Mode of SDRAM Bank 2.
	FMC_SDSR_MODES1 = ((1UL<<2)-1) << 1, // Status Mode for Bank 1 These bits define the Status Mode of SDRAM Bank 1.
	FMC_SDSR_RE = 1UL<<0, // Refresh error flag An interrupt is generated if REIE = 1 and RE = 1		
};
inline uint32_t fmc_sdsr_get_modes2(struct FMC_Type* p) { return (p->SDSR & FMC_SDSR_MODES2) >> 3 ; }
inline uint32_t fmc_sdsr_get_modes1(struct FMC_Type* p) { return (p->SDSR & FMC_SDSR_MODES1) >> 1 ; }

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN = 1UL<<31, // ASPEN
	FPU_FPCCR_LSPEN = 1UL<<30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL<<8, // MONRDY
	FPU_FPCCR_BFRDY = 1UL<<6, // BFRDY
	FPU_FPCCR_MMRDY = 1UL<<5, // MMRDY
	FPU_FPCCR_HFRDY = 1UL<<4, // HFRDY
	FPU_FPCCR_THREAD = 1UL<<3, // THREAD
	FPU_FPCCR_USER = 1UL<<1, // USER
	FPU_FPCCR_LSPACT = 1UL<<0, // LSPACT		
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL<<29)-1) << 3, // Location of unpopulated floating-point		
};
inline void fpu_fpcar_set_address(struct FPU_Type* p, uint32_t val) { p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val<<3) & FPU_FPCAR_ADDRESS); }
inline uint32_t fpu_fpcar_get_address(struct FPU_Type* p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3 ; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N = 1UL<<31, // Negative condition code flag
	FPU_FPSCR_Z = 1UL<<30, // Zero condition code flag
	FPU_FPSCR_C = 1UL<<29, // Carry condition code flag
	FPU_FPSCR_V = 1UL<<28, // Overflow condition code flag
	FPU_FPSCR_AHP = 1UL<<26, // Alternative half-precision control bit
	FPU_FPSCR_DN = 1UL<<25, // Default NaN mode control bit
	FPU_FPSCR_FZ = 1UL<<24, // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL<<2)-1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC = 1UL<<7, // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC = 1UL<<4, // Inexact cumulative exception bit
	FPU_FPSCR_UFC = 1UL<<3, // Underflow cumulative exception bit
	FPU_FPSCR_OFC = 1UL<<2, // Overflow cumulative exception bit
	FPU_FPSCR_DZC = 1UL<<1, // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC = 1UL<<0, // Invalid operation cumulative exception bit		
};
inline void fpu_fpscr_set_rmode(struct FPU_Type* p, uint32_t val) { p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val<<22) & FPU_FPSCR_RMODE); }
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type* p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22 ; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL<<4)-1) << 20, // CP		
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type* p, uint32_t val) { p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val<<20) & FPU_CPACR_CPACR_CP); }
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type* p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20 ; }

/* Flash */
struct Flash_Type {
	__IO uint8_t ACR; // @0 Access control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t KEYR1; // @4 FLASH key register for bank 1
	__IO uint32_t OPTKEYR; // @8 FLASH option key register
	__IO uint32_t CR1; // @12 FLASH control register for bank 1
	__IO uint32_t SR1; // @16 FLASH status register for bank 1
	__IO uint32_t CCR1; // @20 FLASH clear control register for bank 1
	__IO uint32_t OPTCR; // @24 FLASH option control register
	__IO uint32_t OPTSR_CUR; // @28 FLASH option status register
	__IO uint32_t OPTSR_PRG; // @32 FLASH option status register
	__O uint32_t OPTCCR; // @36 FLASH option clear control register
	__I uint32_t PRAR_CUR1; // @40 FLASH protection address for bank 1
	union {  // @44
		__IO uint32_t PRAR_PRG2; // FLASH protection address for bank 2
		__IO uint32_t PRAR_PRG1; // FLASH protection address for bank 1
	};
	__IO uint32_t SCAR_CUR1; // @48 FLASH secure address for bank 1
	__IO uint32_t SCAR_PRG1; // @52 FLASH secure address for bank 1
	__I uint8_t WPSN_CUR1R; // @56 FLASH write sector protection for bank 1
	 uint8_t RESERVED1[3]; // @57 
	__IO uint8_t WPSN_PRG1R; // @60 FLASH write sector protection for bank 1
	 uint8_t RESERVED2[3]; // @61 
	__I uint32_t BOOT_CURR; // @64 FLASH register with boot address
	__I uint32_t BOOT_PRGR; // @68 FLASH register with boot address
	 uint8_t RESERVED3[8]; // @72 
	__IO uint32_t CRCCR1; // @80 FLASH CRC control register for bank 1
	__IO uint32_t CRCSADD1R; // @84 FLASH CRC start address register for bank 1
	__IO uint32_t CRCEADD1R; // @88 FLASH CRC end address register for bank 1
	__IO uint32_t CRCDATAR; // @92 FLASH CRC data register
	__I uint16_t ECC_FA1R; // @96 FLASH ECC fail address for bank 1
	 uint8_t RESERVED4[158]; // @98 
	__IO uint8_t ACR_; // @256 Access control register
	 uint8_t RESERVED5[3]; // @257 
	__I uint32_t KEYR2; // @260 FLASH key register for bank 2
	__IO uint32_t OPTKEYR_; // @264 FLASH option key register
	__IO uint32_t CR2; // @268 FLASH control register for bank 2
	__IO uint32_t SR2; // @272 FLASH status register for bank 2
	__IO uint32_t CCR2; // @276 FLASH clear control register for bank 2
	__IO uint32_t OPTCR_; // @280 FLASH option control register
	__IO uint32_t OPTSR_CUR_; // @284 FLASH option status register
	__IO uint32_t OPTSR_PRG_; // @288 FLASH option status register
	__O uint32_t OPTCCR_; // @292 FLASH option clear control register
	__I uint32_t PRAR_CUR2; // @296 FLASH protection address for bank 1
	 uint8_t RESERVED6[4]; // @300 
	__IO uint32_t SCAR_CUR2; // @304 FLASH secure address for bank 2
	__IO uint32_t SCAR_PRG2; // @308 FLASH secure address for bank 2
	__I uint8_t WPSN_CUR2R; // @312 FLASH write sector protection for bank 2
	 uint8_t RESERVED7[3]; // @313 
	__IO uint8_t WPSN_PRG2R; // @316 FLASH write sector protection for bank 2
	 uint8_t RESERVED8[19]; // @317 
	__IO uint32_t CRCCR2; // @336 FLASH CRC control register for bank 1
	__IO uint32_t CRCSADD2R; // @340 FLASH CRC start address register for bank 2
	__IO uint32_t CRCEADD2R; // @344 FLASH CRC end address register for bank 2
	 uint8_t RESERVED9[4]; // @348 
	__I uint16_t ECC_FA2R; // @352 FLASH ECC fail address for bank 2
};

// Flash->ACR Access control register
enum {
	FLASH_ACR_WRHIGHFREQ = ((1UL<<2)-1) << 4, // Flash signal delay
	FLASH_ACR_LATENCY = ((1UL<<3)-1) << 0, // Read latency		
};
inline void flash_acr_set_wrhighfreq(struct Flash_Type* p, uint32_t val) { p->ACR = (p->ACR & ~FLASH_ACR_WRHIGHFREQ) | ((val<<4) & FLASH_ACR_WRHIGHFREQ); }
inline void flash_acr_set_latency(struct Flash_Type* p, uint32_t val) { p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val<<0) & FLASH_ACR_LATENCY); }
inline uint32_t flash_acr_get_wrhighfreq(struct Flash_Type* p) { return (p->ACR & FLASH_ACR_WRHIGHFREQ) >> 4 ; }
inline uint32_t flash_acr_get_latency(struct Flash_Type* p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0 ; }

// Flash->CR1 FLASH control register for bank 1
enum {
	FLASH_CR1_CRCENDIE1 = 1UL<<27, // Bank 1 end of CRC calculation interrupt enable bit
	FLASH_CR1_DBECCERRIE1 = 1UL<<26, // Bank 1 ECC double detection error interrupt enable bit
	FLASH_CR1_SNECCERRIE1 = 1UL<<25, // Bank 1 ECC single correction error interrupt enable bit
	FLASH_CR1_RDSERRIE1 = 1UL<<24, // Bank 1 secure error interrupt enable bit
	FLASH_CR1_RDPERRIE1 = 1UL<<23, // Bank 1 read protection error interrupt enable bit
	FLASH_CR1_OPERRIE1 = 1UL<<22, // Bank 1 write/erase error interrupt enable bit
	FLASH_CR1_INCERRIE1 = 1UL<<21, // Bank 1 inconsistency error interrupt enable bit
	FLASH_CR1_STRBERRIE1 = 1UL<<19, // Bank 1 strobe error interrupt enable bit
	FLASH_CR1_PGSERRIE1 = 1UL<<18, // Bank 1 programming sequence error interrupt enable bit
	FLASH_CR1_WRPERRIE1 = 1UL<<17, // Bank 1 write protection error interrupt enable bit
	FLASH_CR1_EOPIE1 = 1UL<<16, // Bank 1 end-of-program interrupt control bit
	FLASH_CR1_CRC_EN = 1UL<<15, // Bank 1 CRC control bit
	FLASH_CR1_SNB1 = ((1UL<<3)-1) << 8, // Bank 1 sector erase selection number
	FLASH_CR1_START1 = 1UL<<7, // Bank 1 bank or sector erase start control bit
	FLASH_CR1_FW1 = 1UL<<6, // Bank 1 write forcing control bit
	FLASH_CR1_PSIZE1 = ((1UL<<2)-1) << 4, // Bank 1 program size
	FLASH_CR1_BER1 = 1UL<<3, // Bank 1 erase request
	FLASH_CR1_SER1 = 1UL<<2, // Bank 1 sector erase request
	FLASH_CR1_PG1 = 1UL<<1, // Bank 1 program enable bit
	FLASH_CR1_LOCK1 = 1UL<<0, // Bank 1 configuration lock bit		
};
inline void flash_cr1_set_snb1(struct Flash_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~FLASH_CR1_SNB1) | ((val<<8) & FLASH_CR1_SNB1); }
inline void flash_cr1_set_psize1(struct Flash_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~FLASH_CR1_PSIZE1) | ((val<<4) & FLASH_CR1_PSIZE1); }
inline uint32_t flash_cr1_get_snb1(struct Flash_Type* p) { return (p->CR1 & FLASH_CR1_SNB1) >> 8 ; }
inline uint32_t flash_cr1_get_psize1(struct Flash_Type* p) { return (p->CR1 & FLASH_CR1_PSIZE1) >> 4 ; }

// Flash->SR1 FLASH status register for bank 1
enum {
	FLASH_SR1_CRCEND1 = 1UL<<27, // Bank 1 CRC-complete flag
	FLASH_SR1_DBECCERR1 = 1UL<<26, // Bank 1 ECC double detection error flag
	FLASH_SR1_SNECCERR11 = 1UL<<25, // Bank 1 single correction error flag
	FLASH_SR1_RDSERR1 = 1UL<<24, // Bank 1 secure error flag
	FLASH_SR1_RDPERR1 = 1UL<<23, // Bank 1 read protection error flag
	FLASH_SR1_OPERR1 = 1UL<<22, // Bank 1 write/erase error flag
	FLASH_SR1_INCERR1 = 1UL<<21, // Bank 1 inconsistency error flag
	FLASH_SR1_STRBERR1 = 1UL<<19, // Bank 1 strobe error flag
	FLASH_SR1_PGSERR1 = 1UL<<18, // Bank 1 programming sequence error flag
	FLASH_SR1_WRPERR1 = 1UL<<17, // Bank 1 write protection error flag
	FLASH_SR1_EOP1 = 1UL<<16, // Bank 1 end-of-program flag
	FLASH_SR1_CRC_BUSY1 = 1UL<<3, // Bank 1 CRC busy flag
	FLASH_SR1_QW1 = 1UL<<2, // Bank 1 wait queue flag
	FLASH_SR1_WBNE1 = 1UL<<1, // Bank 1 write buffer not empty flag
	FLASH_SR1_BSY1 = 1UL<<0, // Bank 1 ongoing program flag		
};

// Flash->CCR1 FLASH clear control register for bank 1
enum {
	FLASH_CCR1_CLR_CRCEND1 = 1UL<<27, // Bank 1 CRCEND1 flag clear bit
	FLASH_CCR1_CLR_DBECCERR1 = 1UL<<26, // Bank 1 DBECCERR1 flag clear bit
	FLASH_CCR1_CLR_SNECCERR1 = 1UL<<25, // Bank 1 SNECCERR1 flag clear bit
	FLASH_CCR1_CLR_RDSERR1 = 1UL<<24, // Bank 1 RDSERR1 flag clear bit
	FLASH_CCR1_CLR_RDPERR1 = 1UL<<23, // Bank 1 RDPERR1 flag clear bit
	FLASH_CCR1_CLR_OPERR1 = 1UL<<22, // Bank 1 OPERR1 flag clear bit
	FLASH_CCR1_CLR_INCERR1 = 1UL<<21, // Bank 1 INCERR1 flag clear bit
	FLASH_CCR1_CLR_STRBERR1 = 1UL<<19, // Bank 1 STRBERR1 flag clear bit
	FLASH_CCR1_CLR_PGSERR1 = 1UL<<18, // Bank 1 PGSERR1 flag clear bi
	FLASH_CCR1_CLR_WRPERR1 = 1UL<<17, // Bank 1 WRPERR1 flag clear bit
	FLASH_CCR1_CLR_EOP1 = 1UL<<16, // Bank 1 EOP1 flag clear bit		
};

// Flash->OPTCR FLASH option control register
enum {
	FLASH_OPTCR_SWAP_BANK = 1UL<<31, // Bank swapping configuration bit
	FLASH_OPTCR_OPTCHANGEERRIE = 1UL<<30, // Option byte change error interrupt enable bit
	FLASH_OPTCR_MER = 1UL<<4, // Flash mass erase enable bit
	FLASH_OPTCR_OPTSTART = 1UL<<1, // Option byte start change option configuration bit
	FLASH_OPTCR_OPTLOCK = 1UL<<0, // FLASH_OPTCR lock option configuration bit		
};

// Flash->OPTSR_CUR FLASH option status register
enum {
	FLASH_OPTSR_CUR_SWAP_BANK_OPT = 1UL<<31, // Bank swapping option status bit
	FLASH_OPTSR_CUR_OPTCHANGEERR = 1UL<<30, // Option byte change error flag
	FLASH_OPTSR_CUR_IO_HSLV = 1UL<<29, // I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
	FLASH_OPTSR_CUR_PERSO_OK = 1UL<<28, // Device personalization status bit
	FLASH_OPTSR_CUR_RSS1 = 1UL<<26, // User option bit 1
	FLASH_OPTSR_CUR_SECURITY = 1UL<<21, // Security enable option status bit
	FLASH_OPTSR_CUR_ST_RAM_SIZE = ((1UL<<2)-1) << 19, // DTCM RAM size option status
	FLASH_OPTSR_CUR_FZ_IWDG_SDBY = 1UL<<18, // IWDG Standby mode freeze option status bit
	FLASH_OPTSR_CUR_FZ_IWDG_STOP = 1UL<<17, // IWDG Stop mode freeze option status bit
	FLASH_OPTSR_CUR_RDP = ((1UL<<8)-1) << 8, // Readout protection level option status byte
	FLASH_OPTSR_CUR_NRST_STBY_D1 = 1UL<<7, // D1 DStandby entry reset option status bit
	FLASH_OPTSR_CUR_NRST_STOP_D1 = 1UL<<6, // D1 DStop entry reset option status bit
	FLASH_OPTSR_CUR_IWDG1_HW = 1UL<<4, // IWDG1 control option status bit
	FLASH_OPTSR_CUR_BOR_LEV = ((1UL<<2)-1) << 2, // Brownout level option status bit
	FLASH_OPTSR_CUR_OPT_BUSY = 1UL<<0, // Option byte change ongoing flag		
};
inline void flash_optsr_cur_set_st_ram_size(struct Flash_Type* p, uint32_t val) { p->OPTSR_CUR = (p->OPTSR_CUR & ~FLASH_OPTSR_CUR_ST_RAM_SIZE) | ((val<<19) & FLASH_OPTSR_CUR_ST_RAM_SIZE); }
inline void flash_optsr_cur_set_rdp(struct Flash_Type* p, uint32_t val) { p->OPTSR_CUR = (p->OPTSR_CUR & ~FLASH_OPTSR_CUR_RDP) | ((val<<8) & FLASH_OPTSR_CUR_RDP); }
inline void flash_optsr_cur_set_bor_lev(struct Flash_Type* p, uint32_t val) { p->OPTSR_CUR = (p->OPTSR_CUR & ~FLASH_OPTSR_CUR_BOR_LEV) | ((val<<2) & FLASH_OPTSR_CUR_BOR_LEV); }
inline uint32_t flash_optsr_cur_get_st_ram_size(struct Flash_Type* p) { return (p->OPTSR_CUR & FLASH_OPTSR_CUR_ST_RAM_SIZE) >> 19 ; }
inline uint32_t flash_optsr_cur_get_rdp(struct Flash_Type* p) { return (p->OPTSR_CUR & FLASH_OPTSR_CUR_RDP) >> 8 ; }
inline uint32_t flash_optsr_cur_get_bor_lev(struct Flash_Type* p) { return (p->OPTSR_CUR & FLASH_OPTSR_CUR_BOR_LEV) >> 2 ; }

// Flash->OPTSR_PRG FLASH option status register
enum {
	FLASH_OPTSR_PRG_SWAP_BANK_OPT = 1UL<<31, // Bank swapping option configuration bit
	FLASH_OPTSR_PRG_IO_HSLV = 1UL<<29, // I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
	FLASH_OPTSR_PRG_RSS2 = 1UL<<27, // User option configuration bit 2
	FLASH_OPTSR_PRG_RSS1 = 1UL<<26, // User option configuration bit 1
	FLASH_OPTSR_PRG_SECURITY = 1UL<<21, // Security option configuration bit
	FLASH_OPTSR_PRG_ST_RAM_SIZE = ((1UL<<2)-1) << 19, // DTCM size select option configuration bits
	FLASH_OPTSR_PRG_FZ_IWDG_SDBY = 1UL<<18, // IWDG Standby mode freeze option configuration bit
	FLASH_OPTSR_PRG_FZ_IWDG_STOP = 1UL<<17, // IWDG Stop mode freeze option configuration bit
	FLASH_OPTSR_PRG_RDP = ((1UL<<8)-1) << 8, // Readout protection level option configuration byte
	FLASH_OPTSR_PRG_NRST_STBY_D1 = 1UL<<7, // Option byte erase after D1 DStandby option configuration bit
	FLASH_OPTSR_PRG_NRST_STOP_D1 = 1UL<<6, // Option byte erase after D1 DStop option configuration bit
	FLASH_OPTSR_PRG_IWDG1_HW = 1UL<<4, // IWDG1 option configuration bit
	FLASH_OPTSR_PRG_BOR_LEV = ((1UL<<2)-1) << 2, // BOR reset level option configuration bits		
};
inline void flash_optsr_prg_set_st_ram_size(struct Flash_Type* p, uint32_t val) { p->OPTSR_PRG = (p->OPTSR_PRG & ~FLASH_OPTSR_PRG_ST_RAM_SIZE) | ((val<<19) & FLASH_OPTSR_PRG_ST_RAM_SIZE); }
inline void flash_optsr_prg_set_rdp(struct Flash_Type* p, uint32_t val) { p->OPTSR_PRG = (p->OPTSR_PRG & ~FLASH_OPTSR_PRG_RDP) | ((val<<8) & FLASH_OPTSR_PRG_RDP); }
inline void flash_optsr_prg_set_bor_lev(struct Flash_Type* p, uint32_t val) { p->OPTSR_PRG = (p->OPTSR_PRG & ~FLASH_OPTSR_PRG_BOR_LEV) | ((val<<2) & FLASH_OPTSR_PRG_BOR_LEV); }
inline uint32_t flash_optsr_prg_get_st_ram_size(struct Flash_Type* p) { return (p->OPTSR_PRG & FLASH_OPTSR_PRG_ST_RAM_SIZE) >> 19 ; }
inline uint32_t flash_optsr_prg_get_rdp(struct Flash_Type* p) { return (p->OPTSR_PRG & FLASH_OPTSR_PRG_RDP) >> 8 ; }
inline uint32_t flash_optsr_prg_get_bor_lev(struct Flash_Type* p) { return (p->OPTSR_PRG & FLASH_OPTSR_PRG_BOR_LEV) >> 2 ; }

// Flash->OPTCCR FLASH option clear control register
enum {
	FLASH_OPTCCR_CLR_OPTCHANGEERR = 1UL<<30, // OPTCHANGEERR reset bit		
};

// Flash->PRAR_CUR1 FLASH protection address for bank 1
enum {
	FLASH_PRAR_CUR1_DMEP1 = 1UL<<31, // Bank 1 PCROP protected erase enable option status bit
	FLASH_PRAR_CUR1_PROT_AREA_END1 = ((1UL<<12)-1) << 16, // Bank 1 highest PCROP protected address
	FLASH_PRAR_CUR1_PROT_AREA_START1 = ((1UL<<12)-1) << 0, // Bank 1 lowest PCROP protected address		
};
inline uint32_t flash_prar_cur1_get_prot_area_end1(struct Flash_Type* p) { return (p->PRAR_CUR1 & FLASH_PRAR_CUR1_PROT_AREA_END1) >> 16 ; }
inline uint32_t flash_prar_cur1_get_prot_area_start1(struct Flash_Type* p) { return (p->PRAR_CUR1 & FLASH_PRAR_CUR1_PROT_AREA_START1) >> 0 ; }

// Flash->PRAR_PRG2 FLASH protection address for bank 2
enum {
	FLASH_PRAR_PRG2_DMEP2 = 1UL<<31, // Bank 2 PCROP protected erase enable option configuration bit
	FLASH_PRAR_PRG2_PROT_AREA_END2 = ((1UL<<12)-1) << 16, // Bank 2 highest PCROP protected address configuration
	FLASH_PRAR_PRG2_PROT_AREA_START2 = ((1UL<<12)-1) << 0, // Bank 2 lowest PCROP protected address configuration		
};
inline void flash_prar_prg2_set_prot_area_end2(struct Flash_Type* p, uint32_t val) { p->PRAR_PRG2 = (p->PRAR_PRG2 & ~FLASH_PRAR_PRG2_PROT_AREA_END2) | ((val<<16) & FLASH_PRAR_PRG2_PROT_AREA_END2); }
inline void flash_prar_prg2_set_prot_area_start2(struct Flash_Type* p, uint32_t val) { p->PRAR_PRG2 = (p->PRAR_PRG2 & ~FLASH_PRAR_PRG2_PROT_AREA_START2) | ((val<<0) & FLASH_PRAR_PRG2_PROT_AREA_START2); }
inline uint32_t flash_prar_prg2_get_prot_area_end2(struct Flash_Type* p) { return (p->PRAR_PRG2 & FLASH_PRAR_PRG2_PROT_AREA_END2) >> 16 ; }
inline uint32_t flash_prar_prg2_get_prot_area_start2(struct Flash_Type* p) { return (p->PRAR_PRG2 & FLASH_PRAR_PRG2_PROT_AREA_START2) >> 0 ; }

// Flash->SCAR_CUR1 FLASH secure address for bank 1
enum {
	FLASH_SCAR_CUR1_DMES1 = 1UL<<31, // Bank 1 secure protected erase enable option status bit
	FLASH_SCAR_CUR1_SEC_AREA_END1 = ((1UL<<12)-1) << 16, // Bank 1 highest secure protected address
	FLASH_SCAR_CUR1_SEC_AREA_START1 = ((1UL<<12)-1) << 0, // Bank 1 lowest secure protected address		
};
inline void flash_scar_cur1_set_sec_area_end1(struct Flash_Type* p, uint32_t val) { p->SCAR_CUR1 = (p->SCAR_CUR1 & ~FLASH_SCAR_CUR1_SEC_AREA_END1) | ((val<<16) & FLASH_SCAR_CUR1_SEC_AREA_END1); }
inline void flash_scar_cur1_set_sec_area_start1(struct Flash_Type* p, uint32_t val) { p->SCAR_CUR1 = (p->SCAR_CUR1 & ~FLASH_SCAR_CUR1_SEC_AREA_START1) | ((val<<0) & FLASH_SCAR_CUR1_SEC_AREA_START1); }
inline uint32_t flash_scar_cur1_get_sec_area_end1(struct Flash_Type* p) { return (p->SCAR_CUR1 & FLASH_SCAR_CUR1_SEC_AREA_END1) >> 16 ; }
inline uint32_t flash_scar_cur1_get_sec_area_start1(struct Flash_Type* p) { return (p->SCAR_CUR1 & FLASH_SCAR_CUR1_SEC_AREA_START1) >> 0 ; }

// Flash->SCAR_PRG1 FLASH secure address for bank 1
enum {
	FLASH_SCAR_PRG1_DMES1 = 1UL<<31, // Bank 1 secure protected erase enable option configuration bit
	FLASH_SCAR_PRG1_SEC_AREA_END1 = ((1UL<<12)-1) << 16, // Bank 1 highest secure protected address configuration
	FLASH_SCAR_PRG1_SEC_AREA_START1 = ((1UL<<12)-1) << 0, // Bank 1 lowest secure protected address configuration		
};
inline void flash_scar_prg1_set_sec_area_end1(struct Flash_Type* p, uint32_t val) { p->SCAR_PRG1 = (p->SCAR_PRG1 & ~FLASH_SCAR_PRG1_SEC_AREA_END1) | ((val<<16) & FLASH_SCAR_PRG1_SEC_AREA_END1); }
inline void flash_scar_prg1_set_sec_area_start1(struct Flash_Type* p, uint32_t val) { p->SCAR_PRG1 = (p->SCAR_PRG1 & ~FLASH_SCAR_PRG1_SEC_AREA_START1) | ((val<<0) & FLASH_SCAR_PRG1_SEC_AREA_START1); }
inline uint32_t flash_scar_prg1_get_sec_area_end1(struct Flash_Type* p) { return (p->SCAR_PRG1 & FLASH_SCAR_PRG1_SEC_AREA_END1) >> 16 ; }
inline uint32_t flash_scar_prg1_get_sec_area_start1(struct Flash_Type* p) { return (p->SCAR_PRG1 & FLASH_SCAR_PRG1_SEC_AREA_START1) >> 0 ; }

// Flash->BOOT_CURR FLASH register with boot address
enum {
	FLASH_BOOT_CURR_BOOT_ADD1 = ((1UL<<16)-1) << 16, // Boot address 1
	FLASH_BOOT_CURR_BOOT_ADD0 = ((1UL<<16)-1) << 0, // Boot address 0		
};
inline uint32_t flash_boot_curr_get_boot_add1(struct Flash_Type* p) { return (p->BOOT_CURR & FLASH_BOOT_CURR_BOOT_ADD1) >> 16 ; }
inline uint32_t flash_boot_curr_get_boot_add0(struct Flash_Type* p) { return (p->BOOT_CURR & FLASH_BOOT_CURR_BOOT_ADD0) >> 0 ; }

// Flash->BOOT_PRGR FLASH register with boot address
enum {
	FLASH_BOOT_PRGR_BOOT_ADD1 = ((1UL<<16)-1) << 16, // Boot address 1
	FLASH_BOOT_PRGR_BOOT_ADD0 = ((1UL<<16)-1) << 0, // Boot address 0		
};
inline uint32_t flash_boot_prgr_get_boot_add1(struct Flash_Type* p) { return (p->BOOT_PRGR & FLASH_BOOT_PRGR_BOOT_ADD1) >> 16 ; }
inline uint32_t flash_boot_prgr_get_boot_add0(struct Flash_Type* p) { return (p->BOOT_PRGR & FLASH_BOOT_PRGR_BOOT_ADD0) >> 0 ; }

// Flash->CRCCR1 FLASH CRC control register for bank 1
enum {
	FLASH_CRCCR1_CRC_BURST = ((1UL<<2)-1) << 20, // Bank 1 CRC burst size
	FLASH_CRCCR1_CLEAN_CRC = 1UL<<17, // Bank 1 CRC clear bit
	FLASH_CRCCR1_START_CRC = 1UL<<16, // Bank 1 CRC start bit
	FLASH_CRCCR1_CLEAN_SECT = 1UL<<10, // Bank 1 CRC sector list clear bit
	FLASH_CRCCR1_ADD_SECT = 1UL<<9, // Bank 1 CRC sector select bit
	FLASH_CRCCR1_CRC_BY_SECT = 1UL<<8, // Bank 1 CRC sector mode select bit
	FLASH_CRCCR1_ALL_BANK = 1UL<<7, // Bank 1 CRC select bit
	FLASH_CRCCR1_CRC_SECT = ((1UL<<3)-1) << 0, // Bank 1 CRC sector number		
};
inline void flash_crccr1_set_crc_burst(struct Flash_Type* p, uint32_t val) { p->CRCCR1 = (p->CRCCR1 & ~FLASH_CRCCR1_CRC_BURST) | ((val<<20) & FLASH_CRCCR1_CRC_BURST); }
inline void flash_crccr1_set_crc_sect(struct Flash_Type* p, uint32_t val) { p->CRCCR1 = (p->CRCCR1 & ~FLASH_CRCCR1_CRC_SECT) | ((val<<0) & FLASH_CRCCR1_CRC_SECT); }
inline uint32_t flash_crccr1_get_crc_burst(struct Flash_Type* p) { return (p->CRCCR1 & FLASH_CRCCR1_CRC_BURST) >> 20 ; }
inline uint32_t flash_crccr1_get_crc_sect(struct Flash_Type* p) { return (p->CRCCR1 & FLASH_CRCCR1_CRC_SECT) >> 0 ; }

// Flash->ECC_FA1R FLASH ECC fail address for bank 1
enum {
	FLASH_ECC_FA1R_FAIL_ECC_ADDR1 = ((1UL<<15)-1) << 0, // Bank 1 ECC error address		
};
inline uint32_t flash_ecc_fa1r_get_fail_ecc_addr1(struct Flash_Type* p) { return (p->ECC_FA1R & FLASH_ECC_FA1R_FAIL_ECC_ADDR1) >> 0 ; }

// Flash->ACR_ Access control register
enum {
	FLASH_ACR__WRHIGHFREQ = ((1UL<<2)-1) << 4, // Flash signal delay
	FLASH_ACR__LATENCY = ((1UL<<3)-1) << 0, // Read latency		
};
inline void flash_acr__set_wrhighfreq(struct Flash_Type* p, uint32_t val) { p->ACR_ = (p->ACR_ & ~FLASH_ACR__WRHIGHFREQ) | ((val<<4) & FLASH_ACR__WRHIGHFREQ); }
inline void flash_acr__set_latency(struct Flash_Type* p, uint32_t val) { p->ACR_ = (p->ACR_ & ~FLASH_ACR__LATENCY) | ((val<<0) & FLASH_ACR__LATENCY); }
inline uint32_t flash_acr__get_wrhighfreq(struct Flash_Type* p) { return (p->ACR_ & FLASH_ACR__WRHIGHFREQ) >> 4 ; }
inline uint32_t flash_acr__get_latency(struct Flash_Type* p) { return (p->ACR_ & FLASH_ACR__LATENCY) >> 0 ; }

// Flash->CR2 FLASH control register for bank 2
enum {
	FLASH_CR2_CRCENDIE2 = 1UL<<27, // Bank 2 end of CRC calculation interrupt enable bit
	FLASH_CR2_DBECCERRIE2 = 1UL<<26, // Bank 2 ECC double detection error interrupt enable bit
	FLASH_CR2_SNECCERRIE2 = 1UL<<25, // Bank 2 ECC single correction error interrupt enable bit
	FLASH_CR2_RDSERRIE2 = 1UL<<24, // Bank 2 secure error interrupt enable bit
	FLASH_CR2_RDPERRIE2 = 1UL<<23, // Bank 2 read protection error interrupt enable bit
	FLASH_CR2_OPERRIE2 = 1UL<<22, // Bank 2 write/erase error interrupt enable bit
	FLASH_CR2_INCERRIE2 = 1UL<<21, // Bank 2 inconsistency error interrupt enable bit
	FLASH_CR2_STRBERRIE2 = 1UL<<19, // Bank 2 strobe error interrupt enable bit
	FLASH_CR2_PGSERRIE2 = 1UL<<18, // Bank 2 programming sequence error interrupt enable bit
	FLASH_CR2_WRPERRIE2 = 1UL<<17, // Bank 2 write protection error interrupt enable bit
	FLASH_CR2_EOPIE2 = 1UL<<16, // Bank 2 end-of-program interrupt control bit
	FLASH_CR2_CRC_EN = 1UL<<15, // Bank 2 CRC control bit
	FLASH_CR2_SNB2 = ((1UL<<3)-1) << 8, // Bank 2 sector erase selection number
	FLASH_CR2_START2 = 1UL<<7, // Bank 2 bank or sector erase start control bit
	FLASH_CR2_FW2 = 1UL<<6, // Bank 2 write forcing control bit
	FLASH_CR2_PSIZE2 = ((1UL<<2)-1) << 4, // Bank 2 program size
	FLASH_CR2_BER2 = 1UL<<3, // Bank 2 erase request
	FLASH_CR2_SER2 = 1UL<<2, // Bank 2 sector erase request
	FLASH_CR2_PG2 = 1UL<<1, // Bank 2 program enable bit
	FLASH_CR2_LOCK2 = 1UL<<0, // Bank 2 configuration lock bit		
};
inline void flash_cr2_set_snb2(struct Flash_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~FLASH_CR2_SNB2) | ((val<<8) & FLASH_CR2_SNB2); }
inline void flash_cr2_set_psize2(struct Flash_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~FLASH_CR2_PSIZE2) | ((val<<4) & FLASH_CR2_PSIZE2); }
inline uint32_t flash_cr2_get_snb2(struct Flash_Type* p) { return (p->CR2 & FLASH_CR2_SNB2) >> 8 ; }
inline uint32_t flash_cr2_get_psize2(struct Flash_Type* p) { return (p->CR2 & FLASH_CR2_PSIZE2) >> 4 ; }

// Flash->SR2 FLASH status register for bank 2
enum {
	FLASH_SR2_CRCEND2 = 1UL<<27, // Bank 2 CRC-complete flag
	FLASH_SR2_DBECCERR2 = 1UL<<26, // Bank 2 ECC double detection error flag
	FLASH_SR2_SNECCERR2 = 1UL<<25, // Bank 2 single correction error flag
	FLASH_SR2_RDSERR2 = 1UL<<24, // Bank 2 secure error flag
	FLASH_SR2_RDPERR2 = 1UL<<23, // Bank 2 read protection error flag
	FLASH_SR2_OPERR2 = 1UL<<22, // Bank 2 write/erase error flag
	FLASH_SR2_INCERR2 = 1UL<<21, // Bank 2 inconsistency error flag
	FLASH_SR2_STRBERR2 = 1UL<<19, // Bank 2 strobe error flag
	FLASH_SR2_PGSERR2 = 1UL<<18, // Bank 2 programming sequence error flag
	FLASH_SR2_WRPERR2 = 1UL<<17, // Bank 2 write protection error flag
	FLASH_SR2_EOP2 = 1UL<<16, // Bank 2 end-of-program flag
	FLASH_SR2_CRC_BUSY2 = 1UL<<3, // Bank 2 CRC busy flag
	FLASH_SR2_QW2 = 1UL<<2, // Bank 2 wait queue flag
	FLASH_SR2_WBNE2 = 1UL<<1, // Bank 2 write buffer not empty flag
	FLASH_SR2_BSY2 = 1UL<<0, // Bank 2 ongoing program flag		
};

// Flash->CCR2 FLASH clear control register for bank 2
enum {
	FLASH_CCR2_CLR_CRCEND2 = 1UL<<27, // Bank 2 CRCEND1 flag clear bit
	FLASH_CCR2_CLR_DBECCERR1 = 1UL<<26, // Bank 1 DBECCERR1 flag clear bit
	FLASH_CCR2_CLR_SNECCERR2 = 1UL<<25, // Bank 2 SNECCERR1 flag clear bit
	FLASH_CCR2_CLR_RDSERR1 = 1UL<<24, // Bank 1 RDSERR1 flag clear bit
	FLASH_CCR2_CLR_RDPERR2 = 1UL<<23, // Bank 2 RDPERR1 flag clear bit
	FLASH_CCR2_CLR_OPERR2 = 1UL<<22, // Bank 2 OPERR1 flag clear bit
	FLASH_CCR2_CLR_INCERR2 = 1UL<<21, // Bank 2 INCERR1 flag clear bit
	FLASH_CCR2_CLR_STRBERR2 = 1UL<<19, // Bank 2 STRBERR1 flag clear bit
	FLASH_CCR2_CLR_PGSERR2 = 1UL<<18, // Bank 2 PGSERR1 flag clear bi
	FLASH_CCR2_CLR_WRPERR2 = 1UL<<17, // Bank 2 WRPERR1 flag clear bit
	FLASH_CCR2_CLR_EOP2 = 1UL<<16, // Bank 1 EOP1 flag clear bit		
};

// Flash->OPTCR_ FLASH option control register
enum {
	FLASH_OPTCR__SWAP_BANK = 1UL<<31, // Bank swapping configuration bit
	FLASH_OPTCR__OPTCHANGEERRIE = 1UL<<30, // Option byte change error interrupt enable bit
	FLASH_OPTCR__MER = 1UL<<4, // Flash mass erase enable bit
	FLASH_OPTCR__OPTSTART = 1UL<<1, // Option byte start change option configuration bit
	FLASH_OPTCR__OPTLOCK = 1UL<<0, // FLASH_OPTCR lock option configuration bit		
};

// Flash->OPTSR_CUR_ FLASH option status register
enum {
	FLASH_OPTSR_CUR__SWAP_BANK_OPT = 1UL<<31, // Bank swapping option status bit
	FLASH_OPTSR_CUR__OPTCHANGEERR = 1UL<<30, // Option byte change error flag
	FLASH_OPTSR_CUR__IO_HSLV = 1UL<<29, // I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
	FLASH_OPTSR_CUR__PERSO_OK = 1UL<<28, // Device personalization status bit
	FLASH_OPTSR_CUR__RSS1 = 1UL<<26, // User option bit 1
	FLASH_OPTSR_CUR__SECURITY = 1UL<<21, // Security enable option status bit
	FLASH_OPTSR_CUR__ST_RAM_SIZE = ((1UL<<2)-1) << 19, // DTCM RAM size option status
	FLASH_OPTSR_CUR__FZ_IWDG_SDBY = 1UL<<18, // IWDG Standby mode freeze option status bit
	FLASH_OPTSR_CUR__FZ_IWDG_STOP = 1UL<<17, // IWDG Stop mode freeze option status bit
	FLASH_OPTSR_CUR__RDP = ((1UL<<8)-1) << 8, // Readout protection level option status byte
	FLASH_OPTSR_CUR__NRST_STBY_D1 = 1UL<<7, // D1 DStandby entry reset option status bit
	FLASH_OPTSR_CUR__NRST_STOP_D1 = 1UL<<6, // D1 DStop entry reset option status bit
	FLASH_OPTSR_CUR__IWDG1_HW = 1UL<<4, // IWDG1 control option status bit
	FLASH_OPTSR_CUR__BOR_LEV = ((1UL<<2)-1) << 2, // Brownout level option status bit
	FLASH_OPTSR_CUR__OPT_BUSY = 1UL<<0, // Option byte change ongoing flag		
};
inline void flash_optsr_cur__set_st_ram_size(struct Flash_Type* p, uint32_t val) { p->OPTSR_CUR_ = (p->OPTSR_CUR_ & ~FLASH_OPTSR_CUR__ST_RAM_SIZE) | ((val<<19) & FLASH_OPTSR_CUR__ST_RAM_SIZE); }
inline void flash_optsr_cur__set_rdp(struct Flash_Type* p, uint32_t val) { p->OPTSR_CUR_ = (p->OPTSR_CUR_ & ~FLASH_OPTSR_CUR__RDP) | ((val<<8) & FLASH_OPTSR_CUR__RDP); }
inline void flash_optsr_cur__set_bor_lev(struct Flash_Type* p, uint32_t val) { p->OPTSR_CUR_ = (p->OPTSR_CUR_ & ~FLASH_OPTSR_CUR__BOR_LEV) | ((val<<2) & FLASH_OPTSR_CUR__BOR_LEV); }
inline uint32_t flash_optsr_cur__get_st_ram_size(struct Flash_Type* p) { return (p->OPTSR_CUR_ & FLASH_OPTSR_CUR__ST_RAM_SIZE) >> 19 ; }
inline uint32_t flash_optsr_cur__get_rdp(struct Flash_Type* p) { return (p->OPTSR_CUR_ & FLASH_OPTSR_CUR__RDP) >> 8 ; }
inline uint32_t flash_optsr_cur__get_bor_lev(struct Flash_Type* p) { return (p->OPTSR_CUR_ & FLASH_OPTSR_CUR__BOR_LEV) >> 2 ; }

// Flash->OPTSR_PRG_ FLASH option status register
enum {
	FLASH_OPTSR_PRG__SWAP_BANK_OPT = 1UL<<31, // Bank swapping option configuration bit
	FLASH_OPTSR_PRG__IO_HSLV = 1UL<<29, // I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
	FLASH_OPTSR_PRG__RSS2 = 1UL<<27, // User option configuration bit 2
	FLASH_OPTSR_PRG__RSS1 = 1UL<<26, // User option configuration bit 1
	FLASH_OPTSR_PRG__SECURITY = 1UL<<21, // Security option configuration bit
	FLASH_OPTSR_PRG__ST_RAM_SIZE = ((1UL<<2)-1) << 19, // DTCM size select option configuration bits
	FLASH_OPTSR_PRG__FZ_IWDG_SDBY = 1UL<<18, // IWDG Standby mode freeze option configuration bit
	FLASH_OPTSR_PRG__FZ_IWDG_STOP = 1UL<<17, // IWDG Stop mode freeze option configuration bit
	FLASH_OPTSR_PRG__RDP = ((1UL<<8)-1) << 8, // Readout protection level option configuration byte
	FLASH_OPTSR_PRG__NRST_STBY_D1 = 1UL<<7, // Option byte erase after D1 DStandby option configuration bit
	FLASH_OPTSR_PRG__NRST_STOP_D1 = 1UL<<6, // Option byte erase after D1 DStop option configuration bit
	FLASH_OPTSR_PRG__IWDG1_HW = 1UL<<4, // IWDG1 option configuration bit
	FLASH_OPTSR_PRG__BOR_LEV = ((1UL<<2)-1) << 2, // BOR reset level option configuration bits		
};
inline void flash_optsr_prg__set_st_ram_size(struct Flash_Type* p, uint32_t val) { p->OPTSR_PRG_ = (p->OPTSR_PRG_ & ~FLASH_OPTSR_PRG__ST_RAM_SIZE) | ((val<<19) & FLASH_OPTSR_PRG__ST_RAM_SIZE); }
inline void flash_optsr_prg__set_rdp(struct Flash_Type* p, uint32_t val) { p->OPTSR_PRG_ = (p->OPTSR_PRG_ & ~FLASH_OPTSR_PRG__RDP) | ((val<<8) & FLASH_OPTSR_PRG__RDP); }
inline void flash_optsr_prg__set_bor_lev(struct Flash_Type* p, uint32_t val) { p->OPTSR_PRG_ = (p->OPTSR_PRG_ & ~FLASH_OPTSR_PRG__BOR_LEV) | ((val<<2) & FLASH_OPTSR_PRG__BOR_LEV); }
inline uint32_t flash_optsr_prg__get_st_ram_size(struct Flash_Type* p) { return (p->OPTSR_PRG_ & FLASH_OPTSR_PRG__ST_RAM_SIZE) >> 19 ; }
inline uint32_t flash_optsr_prg__get_rdp(struct Flash_Type* p) { return (p->OPTSR_PRG_ & FLASH_OPTSR_PRG__RDP) >> 8 ; }
inline uint32_t flash_optsr_prg__get_bor_lev(struct Flash_Type* p) { return (p->OPTSR_PRG_ & FLASH_OPTSR_PRG__BOR_LEV) >> 2 ; }

// Flash->OPTCCR_ FLASH option clear control register
enum {
	FLASH_OPTCCR__CLR_OPTCHANGEERR = 1UL<<30, // OPTCHANGEERR reset bit		
};

// Flash->PRAR_CUR2 FLASH protection address for bank 1
enum {
	FLASH_PRAR_CUR2_DMEP2 = 1UL<<31, // Bank 2 PCROP protected erase enable option status bit
	FLASH_PRAR_CUR2_PROT_AREA_END2 = ((1UL<<12)-1) << 16, // Bank 2 highest PCROP protected address
	FLASH_PRAR_CUR2_PROT_AREA_START2 = ((1UL<<12)-1) << 0, // Bank 2 lowest PCROP protected address		
};
inline uint32_t flash_prar_cur2_get_prot_area_end2(struct Flash_Type* p) { return (p->PRAR_CUR2 & FLASH_PRAR_CUR2_PROT_AREA_END2) >> 16 ; }
inline uint32_t flash_prar_cur2_get_prot_area_start2(struct Flash_Type* p) { return (p->PRAR_CUR2 & FLASH_PRAR_CUR2_PROT_AREA_START2) >> 0 ; }

// Flash->SCAR_CUR2 FLASH secure address for bank 2
enum {
	FLASH_SCAR_CUR2_DMES2 = 1UL<<31, // Bank 2 secure protected erase enable option status bit
	FLASH_SCAR_CUR2_SEC_AREA_END2 = ((1UL<<12)-1) << 16, // Bank 2 highest secure protected address
	FLASH_SCAR_CUR2_SEC_AREA_START2 = ((1UL<<12)-1) << 0, // Bank 2 lowest secure protected address		
};
inline void flash_scar_cur2_set_sec_area_end2(struct Flash_Type* p, uint32_t val) { p->SCAR_CUR2 = (p->SCAR_CUR2 & ~FLASH_SCAR_CUR2_SEC_AREA_END2) | ((val<<16) & FLASH_SCAR_CUR2_SEC_AREA_END2); }
inline void flash_scar_cur2_set_sec_area_start2(struct Flash_Type* p, uint32_t val) { p->SCAR_CUR2 = (p->SCAR_CUR2 & ~FLASH_SCAR_CUR2_SEC_AREA_START2) | ((val<<0) & FLASH_SCAR_CUR2_SEC_AREA_START2); }
inline uint32_t flash_scar_cur2_get_sec_area_end2(struct Flash_Type* p) { return (p->SCAR_CUR2 & FLASH_SCAR_CUR2_SEC_AREA_END2) >> 16 ; }
inline uint32_t flash_scar_cur2_get_sec_area_start2(struct Flash_Type* p) { return (p->SCAR_CUR2 & FLASH_SCAR_CUR2_SEC_AREA_START2) >> 0 ; }

// Flash->SCAR_PRG2 FLASH secure address for bank 2
enum {
	FLASH_SCAR_PRG2_DMES2 = 1UL<<31, // Bank 2 secure protected erase enable option configuration bit
	FLASH_SCAR_PRG2_SEC_AREA_END2 = ((1UL<<12)-1) << 16, // Bank 2 highest secure protected address configuration
	FLASH_SCAR_PRG2_SEC_AREA_START2 = ((1UL<<12)-1) << 0, // Bank 2 lowest secure protected address configuration		
};
inline void flash_scar_prg2_set_sec_area_end2(struct Flash_Type* p, uint32_t val) { p->SCAR_PRG2 = (p->SCAR_PRG2 & ~FLASH_SCAR_PRG2_SEC_AREA_END2) | ((val<<16) & FLASH_SCAR_PRG2_SEC_AREA_END2); }
inline void flash_scar_prg2_set_sec_area_start2(struct Flash_Type* p, uint32_t val) { p->SCAR_PRG2 = (p->SCAR_PRG2 & ~FLASH_SCAR_PRG2_SEC_AREA_START2) | ((val<<0) & FLASH_SCAR_PRG2_SEC_AREA_START2); }
inline uint32_t flash_scar_prg2_get_sec_area_end2(struct Flash_Type* p) { return (p->SCAR_PRG2 & FLASH_SCAR_PRG2_SEC_AREA_END2) >> 16 ; }
inline uint32_t flash_scar_prg2_get_sec_area_start2(struct Flash_Type* p) { return (p->SCAR_PRG2 & FLASH_SCAR_PRG2_SEC_AREA_START2) >> 0 ; }

// Flash->CRCCR2 FLASH CRC control register for bank 1
enum {
	FLASH_CRCCR2_CRC_BURST = ((1UL<<2)-1) << 20, // Bank 2 CRC burst size
	FLASH_CRCCR2_CLEAN_CRC = 1UL<<17, // Bank 2 CRC clear bit
	FLASH_CRCCR2_START_CRC = 1UL<<16, // Bank 2 CRC start bit
	FLASH_CRCCR2_CLEAN_SECT = 1UL<<10, // Bank 2 CRC sector list clear bit
	FLASH_CRCCR2_ADD_SECT = 1UL<<9, // Bank 2 CRC sector select bit
	FLASH_CRCCR2_CRC_BY_SECT = 1UL<<8, // Bank 2 CRC sector mode select bit
	FLASH_CRCCR2_ALL_BANK = 1UL<<7, // Bank 2 CRC select bit
	FLASH_CRCCR2_CRC_SECT = ((1UL<<3)-1) << 0, // Bank 2 CRC sector number		
};
inline void flash_crccr2_set_crc_burst(struct Flash_Type* p, uint32_t val) { p->CRCCR2 = (p->CRCCR2 & ~FLASH_CRCCR2_CRC_BURST) | ((val<<20) & FLASH_CRCCR2_CRC_BURST); }
inline void flash_crccr2_set_crc_sect(struct Flash_Type* p, uint32_t val) { p->CRCCR2 = (p->CRCCR2 & ~FLASH_CRCCR2_CRC_SECT) | ((val<<0) & FLASH_CRCCR2_CRC_SECT); }
inline uint32_t flash_crccr2_get_crc_burst(struct Flash_Type* p) { return (p->CRCCR2 & FLASH_CRCCR2_CRC_BURST) >> 20 ; }
inline uint32_t flash_crccr2_get_crc_sect(struct Flash_Type* p) { return (p->CRCCR2 & FLASH_CRCCR2_CRC_SECT) >> 0 ; }

// Flash->ECC_FA2R FLASH ECC fail address for bank 2
enum {
	FLASH_ECC_FA2R_FAIL_ECC_ADDR2 = ((1UL<<15)-1) << 0, // Bank 2 ECC error address		
};
inline uint32_t flash_ecc_fa2r_get_fail_ecc_addr2(struct Flash_Type* p) { return (p->ECC_FA2R & FLASH_ECC_FA2R_FAIL_ECC_ADDR2) >> 0 ; }

/* GPIO */
struct GPIOA_Type {
	__IO uint32_t MODER; // @0 GPIO port mode register
	__IO uint16_t OTYPER; // @4 GPIO port output type register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t OSPEEDR; // @8 GPIO port output speed register
	__IO uint32_t PUPDR; // @12 GPIO port pull-up/pull-down register
	__I uint16_t IDR; // @16 GPIO port input data register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t ODR; // @20 GPIO port output data register
	 uint8_t RESERVED2[2]; // @22 
	__O uint32_t BSRR; // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR; // @28 This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
	__IO uint32_t AFRL; // @32 GPIO alternate function low register
	__IO uint32_t AFRH; // @36 GPIO alternate function high register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODE15 = ((1UL<<2)-1) << 30, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE14 = ((1UL<<2)-1) << 28, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE13 = ((1UL<<2)-1) << 26, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE12 = ((1UL<<2)-1) << 24, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE11 = ((1UL<<2)-1) << 22, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE10 = ((1UL<<2)-1) << 20, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE9 = ((1UL<<2)-1) << 18, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE8 = ((1UL<<2)-1) << 16, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE7 = ((1UL<<2)-1) << 14, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE6 = ((1UL<<2)-1) << 12, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE5 = ((1UL<<2)-1) << 10, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE4 = ((1UL<<2)-1) << 8, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE3 = ((1UL<<2)-1) << 6, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE2 = ((1UL<<2)-1) << 4, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE1 = ((1UL<<2)-1) << 2, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
	GPIOA_MODER_MODE0 = ((1UL<<2)-1) << 0, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.		
};
inline void gpioa_moder_set_mode15(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE15) | ((val<<30) & GPIOA_MODER_MODE15); }
inline void gpioa_moder_set_mode14(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE14) | ((val<<28) & GPIOA_MODER_MODE14); }
inline void gpioa_moder_set_mode13(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE13) | ((val<<26) & GPIOA_MODER_MODE13); }
inline void gpioa_moder_set_mode12(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE12) | ((val<<24) & GPIOA_MODER_MODE12); }
inline void gpioa_moder_set_mode11(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE11) | ((val<<22) & GPIOA_MODER_MODE11); }
inline void gpioa_moder_set_mode10(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE10) | ((val<<20) & GPIOA_MODER_MODE10); }
inline void gpioa_moder_set_mode9(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE9) | ((val<<18) & GPIOA_MODER_MODE9); }
inline void gpioa_moder_set_mode8(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE8) | ((val<<16) & GPIOA_MODER_MODE8); }
inline void gpioa_moder_set_mode7(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE7) | ((val<<14) & GPIOA_MODER_MODE7); }
inline void gpioa_moder_set_mode6(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE6) | ((val<<12) & GPIOA_MODER_MODE6); }
inline void gpioa_moder_set_mode5(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE5) | ((val<<10) & GPIOA_MODER_MODE5); }
inline void gpioa_moder_set_mode4(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE4) | ((val<<8) & GPIOA_MODER_MODE4); }
inline void gpioa_moder_set_mode3(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE3) | ((val<<6) & GPIOA_MODER_MODE3); }
inline void gpioa_moder_set_mode2(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE2) | ((val<<4) & GPIOA_MODER_MODE2); }
inline void gpioa_moder_set_mode1(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE1) | ((val<<2) & GPIOA_MODER_MODE1); }
inline void gpioa_moder_set_mode0(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODE0) | ((val<<0) & GPIOA_MODER_MODE0); }
inline uint32_t gpioa_moder_get_mode15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE15) >> 30 ; }
inline uint32_t gpioa_moder_get_mode14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE14) >> 28 ; }
inline uint32_t gpioa_moder_get_mode13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE13) >> 26 ; }
inline uint32_t gpioa_moder_get_mode12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE12) >> 24 ; }
inline uint32_t gpioa_moder_get_mode11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE11) >> 22 ; }
inline uint32_t gpioa_moder_get_mode10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE10) >> 20 ; }
inline uint32_t gpioa_moder_get_mode9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE9) >> 18 ; }
inline uint32_t gpioa_moder_get_mode8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE8) >> 16 ; }
inline uint32_t gpioa_moder_get_mode7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE7) >> 14 ; }
inline uint32_t gpioa_moder_get_mode6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE6) >> 12 ; }
inline uint32_t gpioa_moder_get_mode5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE5) >> 10 ; }
inline uint32_t gpioa_moder_get_mode4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE4) >> 8 ; }
inline uint32_t gpioa_moder_get_mode3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE3) >> 6 ; }
inline uint32_t gpioa_moder_get_mode2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE2) >> 4 ; }
inline uint32_t gpioa_moder_get_mode1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE1) >> 2 ; }
inline uint32_t gpioa_moder_get_mode0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODE0) >> 0 ; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEED15 = ((1UL<<2)-1) << 30, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED14 = ((1UL<<2)-1) << 28, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED13 = ((1UL<<2)-1) << 26, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED12 = ((1UL<<2)-1) << 24, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED11 = ((1UL<<2)-1) << 22, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED10 = ((1UL<<2)-1) << 20, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED9 = ((1UL<<2)-1) << 18, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED8 = ((1UL<<2)-1) << 16, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED7 = ((1UL<<2)-1) << 14, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED6 = ((1UL<<2)-1) << 12, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED5 = ((1UL<<2)-1) << 10, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED4 = ((1UL<<2)-1) << 8, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED3 = ((1UL<<2)-1) << 6, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED2 = ((1UL<<2)-1) << 4, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED1 = ((1UL<<2)-1) << 2, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
	GPIOA_OSPEEDR_OSPEED0 = ((1UL<<2)-1) << 0, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.		
};
inline void gpioa_ospeedr_set_ospeed15(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED15) | ((val<<30) & GPIOA_OSPEEDR_OSPEED15); }
inline void gpioa_ospeedr_set_ospeed14(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED14) | ((val<<28) & GPIOA_OSPEEDR_OSPEED14); }
inline void gpioa_ospeedr_set_ospeed13(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED13) | ((val<<26) & GPIOA_OSPEEDR_OSPEED13); }
inline void gpioa_ospeedr_set_ospeed12(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED12) | ((val<<24) & GPIOA_OSPEEDR_OSPEED12); }
inline void gpioa_ospeedr_set_ospeed11(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED11) | ((val<<22) & GPIOA_OSPEEDR_OSPEED11); }
inline void gpioa_ospeedr_set_ospeed10(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED10) | ((val<<20) & GPIOA_OSPEEDR_OSPEED10); }
inline void gpioa_ospeedr_set_ospeed9(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED9) | ((val<<18) & GPIOA_OSPEEDR_OSPEED9); }
inline void gpioa_ospeedr_set_ospeed8(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED8) | ((val<<16) & GPIOA_OSPEEDR_OSPEED8); }
inline void gpioa_ospeedr_set_ospeed7(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED7) | ((val<<14) & GPIOA_OSPEEDR_OSPEED7); }
inline void gpioa_ospeedr_set_ospeed6(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED6) | ((val<<12) & GPIOA_OSPEEDR_OSPEED6); }
inline void gpioa_ospeedr_set_ospeed5(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED5) | ((val<<10) & GPIOA_OSPEEDR_OSPEED5); }
inline void gpioa_ospeedr_set_ospeed4(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED4) | ((val<<8) & GPIOA_OSPEEDR_OSPEED4); }
inline void gpioa_ospeedr_set_ospeed3(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED3) | ((val<<6) & GPIOA_OSPEEDR_OSPEED3); }
inline void gpioa_ospeedr_set_ospeed2(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED2) | ((val<<4) & GPIOA_OSPEEDR_OSPEED2); }
inline void gpioa_ospeedr_set_ospeed1(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED1) | ((val<<2) & GPIOA_OSPEEDR_OSPEED1); }
inline void gpioa_ospeedr_set_ospeed0(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEED0) | ((val<<0) & GPIOA_OSPEEDR_OSPEED0); }
inline uint32_t gpioa_ospeedr_get_ospeed15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED15) >> 30 ; }
inline uint32_t gpioa_ospeedr_get_ospeed14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED14) >> 28 ; }
inline uint32_t gpioa_ospeedr_get_ospeed13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED13) >> 26 ; }
inline uint32_t gpioa_ospeedr_get_ospeed12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED12) >> 24 ; }
inline uint32_t gpioa_ospeedr_get_ospeed11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED11) >> 22 ; }
inline uint32_t gpioa_ospeedr_get_ospeed10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED10) >> 20 ; }
inline uint32_t gpioa_ospeedr_get_ospeed9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED9) >> 18 ; }
inline uint32_t gpioa_ospeedr_get_ospeed8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED8) >> 16 ; }
inline uint32_t gpioa_ospeedr_get_ospeed7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED7) >> 14 ; }
inline uint32_t gpioa_ospeedr_get_ospeed6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED6) >> 12 ; }
inline uint32_t gpioa_ospeedr_get_ospeed5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED5) >> 10 ; }
inline uint32_t gpioa_ospeedr_get_ospeed4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED4) >> 8 ; }
inline uint32_t gpioa_ospeedr_get_ospeed3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED3) >> 6 ; }
inline uint32_t gpioa_ospeedr_get_ospeed2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED2) >> 4 ; }
inline uint32_t gpioa_ospeedr_get_ospeed1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED1) >> 2 ; }
inline uint32_t gpioa_ospeedr_get_ospeed0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEED0) >> 0 ; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPD15 = ((1UL<<2)-1) << 30, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD14 = ((1UL<<2)-1) << 28, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD13 = ((1UL<<2)-1) << 26, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD12 = ((1UL<<2)-1) << 24, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD11 = ((1UL<<2)-1) << 22, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD10 = ((1UL<<2)-1) << 20, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD9 = ((1UL<<2)-1) << 18, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD8 = ((1UL<<2)-1) << 16, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD7 = ((1UL<<2)-1) << 14, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD6 = ((1UL<<2)-1) << 12, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD5 = ((1UL<<2)-1) << 10, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD4 = ((1UL<<2)-1) << 8, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD3 = ((1UL<<2)-1) << 6, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD2 = ((1UL<<2)-1) << 4, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD1 = ((1UL<<2)-1) << 2, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
	GPIOA_PUPDR_PUPD0 = ((1UL<<2)-1) << 0, // [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down		
};
inline void gpioa_pupdr_set_pupd15(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD15) | ((val<<30) & GPIOA_PUPDR_PUPD15); }
inline void gpioa_pupdr_set_pupd14(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD14) | ((val<<28) & GPIOA_PUPDR_PUPD14); }
inline void gpioa_pupdr_set_pupd13(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD13) | ((val<<26) & GPIOA_PUPDR_PUPD13); }
inline void gpioa_pupdr_set_pupd12(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD12) | ((val<<24) & GPIOA_PUPDR_PUPD12); }
inline void gpioa_pupdr_set_pupd11(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD11) | ((val<<22) & GPIOA_PUPDR_PUPD11); }
inline void gpioa_pupdr_set_pupd10(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD10) | ((val<<20) & GPIOA_PUPDR_PUPD10); }
inline void gpioa_pupdr_set_pupd9(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD9) | ((val<<18) & GPIOA_PUPDR_PUPD9); }
inline void gpioa_pupdr_set_pupd8(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD8) | ((val<<16) & GPIOA_PUPDR_PUPD8); }
inline void gpioa_pupdr_set_pupd7(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD7) | ((val<<14) & GPIOA_PUPDR_PUPD7); }
inline void gpioa_pupdr_set_pupd6(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD6) | ((val<<12) & GPIOA_PUPDR_PUPD6); }
inline void gpioa_pupdr_set_pupd5(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD5) | ((val<<10) & GPIOA_PUPDR_PUPD5); }
inline void gpioa_pupdr_set_pupd4(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD4) | ((val<<8) & GPIOA_PUPDR_PUPD4); }
inline void gpioa_pupdr_set_pupd3(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD3) | ((val<<6) & GPIOA_PUPDR_PUPD3); }
inline void gpioa_pupdr_set_pupd2(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD2) | ((val<<4) & GPIOA_PUPDR_PUPD2); }
inline void gpioa_pupdr_set_pupd1(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD1) | ((val<<2) & GPIOA_PUPDR_PUPD1); }
inline void gpioa_pupdr_set_pupd0(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPD0) | ((val<<0) & GPIOA_PUPDR_PUPD0); }
inline uint32_t gpioa_pupdr_get_pupd15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD15) >> 30 ; }
inline uint32_t gpioa_pupdr_get_pupd14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD14) >> 28 ; }
inline uint32_t gpioa_pupdr_get_pupd13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD13) >> 26 ; }
inline uint32_t gpioa_pupdr_get_pupd12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD12) >> 24 ; }
inline uint32_t gpioa_pupdr_get_pupd11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD11) >> 22 ; }
inline uint32_t gpioa_pupdr_get_pupd10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD10) >> 20 ; }
inline uint32_t gpioa_pupdr_get_pupd9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD9) >> 18 ; }
inline uint32_t gpioa_pupdr_get_pupd8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD8) >> 16 ; }
inline uint32_t gpioa_pupdr_get_pupd7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD7) >> 14 ; }
inline uint32_t gpioa_pupdr_get_pupd6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD6) >> 12 ; }
inline uint32_t gpioa_pupdr_get_pupd5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD5) >> 10 ; }
inline uint32_t gpioa_pupdr_get_pupd4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD4) >> 8 ; }
inline uint32_t gpioa_pupdr_get_pupd3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD3) >> 6 ; }
inline uint32_t gpioa_pupdr_get_pupd2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD2) >> 4 ; }
inline uint32_t gpioa_pupdr_get_pupd1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD1) >> 2 ; }
inline uint32_t gpioa_pupdr_get_pupd0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPD0) >> 0 ; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL<<31, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR14 = 1UL<<30, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR13 = 1UL<<29, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR12 = 1UL<<28, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR11 = 1UL<<27, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR10 = 1UL<<26, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR9 = 1UL<<25, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR8 = 1UL<<24, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR7 = 1UL<<23, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR6 = 1UL<<22, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR5 = 1UL<<21, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR4 = 1UL<<20, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR3 = 1UL<<19, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR2 = 1UL<<18, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR1 = 1UL<<17, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BR0 = 1UL<<16, // Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
	GPIOA_BSRR_BS15 = 1UL<<15, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS14 = 1UL<<14, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS13 = 1UL<<13, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS12 = 1UL<<12, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS11 = 1UL<<11, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS10 = 1UL<<10, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS9 = 1UL<<9, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS8 = 1UL<<8, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS7 = 1UL<<7, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS6 = 1UL<<6, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS5 = 1UL<<5, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS4 = 1UL<<4, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS3 = 1UL<<3, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS2 = 1UL<<2, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS1 = 1UL<<1, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
	GPIOA_BSRR_BS0 = 1UL<<0, // Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.		
};

// GPIOA->LCKR This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
enum {
	GPIOA_LCKR_LCKK = 1UL<<16, // Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
	GPIOA_LCKR_LCK15 = 1UL<<15, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK14 = 1UL<<14, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK13 = 1UL<<13, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK12 = 1UL<<12, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK11 = 1UL<<11, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK10 = 1UL<<10, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK9 = 1UL<<9, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK8 = 1UL<<8, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK7 = 1UL<<7, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK6 = 1UL<<6, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK5 = 1UL<<5, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK4 = 1UL<<4, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK3 = 1UL<<3, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK2 = 1UL<<2, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK1 = 1UL<<1, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
	GPIOA_LCKR_LCK0 = 1UL<<0, // Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.		
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFSEL7 = ((1UL<<4)-1) << 28, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL6 = ((1UL<<4)-1) << 24, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL5 = ((1UL<<4)-1) << 20, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL4 = ((1UL<<4)-1) << 16, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL3 = ((1UL<<4)-1) << 12, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL2 = ((1UL<<4)-1) << 8, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL1 = ((1UL<<4)-1) << 4, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
	GPIOA_AFRL_AFSEL0 = ((1UL<<4)-1) << 0, // [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:		
};
inline void gpioa_afrl_set_afsel7(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL7) | ((val<<28) & GPIOA_AFRL_AFSEL7); }
inline void gpioa_afrl_set_afsel6(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL6) | ((val<<24) & GPIOA_AFRL_AFSEL6); }
inline void gpioa_afrl_set_afsel5(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL5) | ((val<<20) & GPIOA_AFRL_AFSEL5); }
inline void gpioa_afrl_set_afsel4(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL4) | ((val<<16) & GPIOA_AFRL_AFSEL4); }
inline void gpioa_afrl_set_afsel3(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL3) | ((val<<12) & GPIOA_AFRL_AFSEL3); }
inline void gpioa_afrl_set_afsel2(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL2) | ((val<<8) & GPIOA_AFRL_AFSEL2); }
inline void gpioa_afrl_set_afsel1(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL1) | ((val<<4) & GPIOA_AFRL_AFSEL1); }
inline void gpioa_afrl_set_afsel0(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFSEL0) | ((val<<0) & GPIOA_AFRL_AFSEL0); }
inline uint32_t gpioa_afrl_get_afsel7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL7) >> 28 ; }
inline uint32_t gpioa_afrl_get_afsel6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL6) >> 24 ; }
inline uint32_t gpioa_afrl_get_afsel5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL5) >> 20 ; }
inline uint32_t gpioa_afrl_get_afsel4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL4) >> 16 ; }
inline uint32_t gpioa_afrl_get_afsel3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL3) >> 12 ; }
inline uint32_t gpioa_afrl_get_afsel2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL2) >> 8 ; }
inline uint32_t gpioa_afrl_get_afsel1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL1) >> 4 ; }
inline uint32_t gpioa_afrl_get_afsel0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFSEL0) >> 0 ; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFSEL15 = ((1UL<<4)-1) << 28, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL14 = ((1UL<<4)-1) << 24, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL13 = ((1UL<<4)-1) << 20, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL12 = ((1UL<<4)-1) << 16, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL11 = ((1UL<<4)-1) << 12, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL10 = ((1UL<<4)-1) << 8, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL9 = ((1UL<<4)-1) << 4, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
	GPIOA_AFRH_AFSEL8 = ((1UL<<4)-1) << 0, // [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os		
};
inline void gpioa_afrh_set_afsel15(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL15) | ((val<<28) & GPIOA_AFRH_AFSEL15); }
inline void gpioa_afrh_set_afsel14(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL14) | ((val<<24) & GPIOA_AFRH_AFSEL14); }
inline void gpioa_afrh_set_afsel13(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL13) | ((val<<20) & GPIOA_AFRH_AFSEL13); }
inline void gpioa_afrh_set_afsel12(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL12) | ((val<<16) & GPIOA_AFRH_AFSEL12); }
inline void gpioa_afrh_set_afsel11(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL11) | ((val<<12) & GPIOA_AFRH_AFSEL11); }
inline void gpioa_afrh_set_afsel10(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL10) | ((val<<8) & GPIOA_AFRH_AFSEL10); }
inline void gpioa_afrh_set_afsel9(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL9) | ((val<<4) & GPIOA_AFRH_AFSEL9); }
inline void gpioa_afrh_set_afsel8(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFSEL8) | ((val<<0) & GPIOA_AFRH_AFSEL8); }
inline uint32_t gpioa_afrh_get_afsel15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL15) >> 28 ; }
inline uint32_t gpioa_afrh_get_afsel14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL14) >> 24 ; }
inline uint32_t gpioa_afrh_get_afsel13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL13) >> 20 ; }
inline uint32_t gpioa_afrh_get_afsel12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL12) >> 16 ; }
inline uint32_t gpioa_afrh_get_afsel11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL11) >> 12 ; }
inline uint32_t gpioa_afrh_get_afsel10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL10) >> 8 ; }
inline uint32_t gpioa_afrh_get_afsel9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL9) >> 4 ; }
inline uint32_t gpioa_afrh_get_afsel8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFSEL8) >> 0 ; }











/* Hash processor */
struct HASH_Type {
	__IO uint32_t CR; // @0 control register
	__IO uint32_t DIN; // @4 data input register
	__IO uint16_t STR; // @8 start register
	 uint8_t RESERVED0[2]; // @10 
	__I uint32_t HR0; // @12 digest registers
	__I uint32_t HR1; // @16 digest registers
	__I uint32_t HR2; // @20 digest registers
	__I uint32_t HR3; // @24 digest registers
	__I uint32_t HR4; // @28 digest registers
	__IO uint8_t IMR; // @32 interrupt enable register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t SR; // @36 status register
	 uint8_t RESERVED2[211]; // @37 
	__IO uint32_t CSR0; // @248 context swap registers
	__IO uint32_t CSR1; // @252 context swap registers
	__IO uint32_t CSR2; // @256 context swap registers
	__IO uint32_t CSR3; // @260 context swap registers
	__IO uint32_t CSR4; // @264 context swap registers
	__IO uint32_t CSR5; // @268 context swap registers
	__IO uint32_t CSR6; // @272 context swap registers
	__IO uint32_t CSR7; // @276 context swap registers
	__IO uint32_t CSR8; // @280 context swap registers
	__IO uint32_t CSR9; // @284 context swap registers
	__IO uint32_t CSR10; // @288 context swap registers
	__IO uint32_t CSR11; // @292 context swap registers
	__IO uint32_t CSR12; // @296 context swap registers
	__IO uint32_t CSR13; // @300 context swap registers
	__IO uint32_t CSR14; // @304 context swap registers
	__IO uint32_t CSR15; // @308 context swap registers
	__IO uint32_t CSR16; // @312 context swap registers
	__IO uint32_t CSR17; // @316 context swap registers
	__IO uint32_t CSR18; // @320 context swap registers
	__IO uint32_t CSR19; // @324 context swap registers
	__IO uint32_t CSR20; // @328 context swap registers
	__IO uint32_t CSR21; // @332 context swap registers
	__IO uint32_t CSR22; // @336 context swap registers
	__IO uint32_t CSR23; // @340 context swap registers
	__IO uint32_t CSR24; // @344 context swap registers
	__IO uint32_t CSR25; // @348 context swap registers
	__IO uint32_t CSR26; // @352 context swap registers
	__IO uint32_t CSR27; // @356 context swap registers
	__IO uint32_t CSR28; // @360 context swap registers
	__IO uint32_t CSR29; // @364 context swap registers
	__IO uint32_t CSR30; // @368 context swap registers
	__IO uint32_t CSR31; // @372 context swap registers
	__IO uint32_t CSR32; // @376 context swap registers
	__IO uint32_t CSR33; // @380 context swap registers
	__IO uint32_t CSR34; // @384 context swap registers
	__IO uint32_t CSR35; // @388 context swap registers
	__IO uint32_t CSR36; // @392 context swap registers
	__IO uint32_t CSR37; // @396 context swap registers
	__IO uint32_t CSR38; // @400 context swap registers
	__IO uint32_t CSR39; // @404 context swap registers
	__IO uint32_t CSR40; // @408 context swap registers
	__IO uint32_t CSR41; // @412 context swap registers
	__IO uint32_t CSR42; // @416 context swap registers
	__IO uint32_t CSR43; // @420 context swap registers
	__IO uint32_t CSR44; // @424 context swap registers
	__IO uint32_t CSR45; // @428 context swap registers
	__IO uint32_t CSR46; // @432 context swap registers
	__IO uint32_t CSR47; // @436 context swap registers
	__IO uint32_t CSR48; // @440 context swap registers
	__IO uint32_t CSR49; // @444 context swap registers
	__IO uint32_t CSR50; // @448 context swap registers
	__IO uint32_t CSR51; // @452 context swap registers
	__IO uint32_t CSR52; // @456 context swap registers
	__IO uint32_t CSR53; // @460 context swap registers
	 uint8_t RESERVED3[320]; // @464 
	__I uint32_t HASH_HR0; // @784 HASH digest register
	__I uint32_t HASH_HR1; // @788 read-only
	__I uint32_t HASH_HR2; // @792 read-only
	__I uint32_t HASH_HR3; // @796 read-only
	__I uint32_t HASH_HR4; // @800 read-only
	__I uint32_t HASH_HR5; // @804 read-only
	__I uint32_t HASH_HR6; // @808 read-only
	__I uint32_t HASH_HR7; // @812 read-only
};

// HASH->CR control register
enum {
	HASH_CR_ALGO1 = 1UL<<18, // ALGO
	HASH_CR_LKEY = 1UL<<16, // Long key selection
	HASH_CR_MDMAT = 1UL<<13, // Multiple DMA Transfers
	HASH_CR_DINNE = 1UL<<12, // DIN not empty
	HASH_CR_NBW = ((1UL<<4)-1) << 8, // Number of words already pushed
	HASH_CR_ALGO0 = 1UL<<7, // Algorithm selection
	HASH_CR_MODE = 1UL<<6, // Mode selection
	HASH_CR_DATATYPE = ((1UL<<2)-1) << 4, // Data type selection
	HASH_CR_DMAE = 1UL<<3, // DMA enable
	HASH_CR_INIT = 1UL<<2, // Initialize message digest calculation		
};
inline void hash_cr_set_nbw(struct HASH_Type* p, uint32_t val) { p->CR = (p->CR & ~HASH_CR_NBW) | ((val<<8) & HASH_CR_NBW); }
inline void hash_cr_set_datatype(struct HASH_Type* p, uint32_t val) { p->CR = (p->CR & ~HASH_CR_DATATYPE) | ((val<<4) & HASH_CR_DATATYPE); }
inline uint32_t hash_cr_get_nbw(struct HASH_Type* p) { return (p->CR & HASH_CR_NBW) >> 8 ; }
inline uint32_t hash_cr_get_datatype(struct HASH_Type* p) { return (p->CR & HASH_CR_DATATYPE) >> 4 ; }

// HASH->STR start register
enum {
	HASH_STR_DCAL = 1UL<<8, // Digest calculation
	HASH_STR_NBLW = ((1UL<<5)-1) << 0, // Number of valid bits in the last word of the message		
};
inline void hash_str_set_nblw(struct HASH_Type* p, uint32_t val) { p->STR = (p->STR & ~HASH_STR_NBLW) | ((val<<0) & HASH_STR_NBLW); }
inline uint32_t hash_str_get_nblw(struct HASH_Type* p) { return (p->STR & HASH_STR_NBLW) >> 0 ; }

// HASH->IMR interrupt enable register
enum {
	HASH_IMR_DCIE = 1UL<<1, // Digest calculation completion interrupt enable
	HASH_IMR_DINIE = 1UL<<0, // Data input interrupt enable		
};

// HASH->SR status register
enum {
	HASH_SR_BUSY = 1UL<<3, // Busy bit
	HASH_SR_DMAS = 1UL<<2, // DMA Status
	HASH_SR_DCIS = 1UL<<1, // Digest calculation completion interrupt status
	HASH_SR_DINIS = 1UL<<0, // Data input interrupt status		
};

/* High Resolution Timer: Common functions */
struct HRTIM_Common_Type {
	__IO uint32_t CR1; // @0 Control Register 1
	__IO uint16_t CR2; // @4 Control Register 2
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t ISR; // @8 Interrupt Status Register
	__IO uint32_t ICR; // @12 Interrupt Clear Register
	__IO uint32_t IER; // @16 Interrupt Enable Register
	__O uint16_t OENR; // @20 Output Enable Register
	 uint8_t RESERVED1[2]; // @22 
	__IO uint16_t DISR; // @24 DISR
	 uint8_t RESERVED2[2]; // @26 
	__I uint16_t ODSR; // @28 Output Disable Status Register
	 uint8_t RESERVED3[2]; // @30 
	__IO uint32_t BMCR; // @32 Burst Mode Control Register
	__IO uint32_t BMTRG; // @36 BMTRG
	__IO uint16_t BMCMPR6; // @40 BMCMPR6
	 uint8_t RESERVED4[2]; // @42 
	__IO uint16_t BMPER; // @44 Burst Mode Period Register
	 uint8_t RESERVED5[2]; // @46 
	__IO uint32_t EECR1; // @48 Timer External Event Control Register 1
	__IO uint32_t EECR2; // @52 Timer External Event Control Register 2
	__IO uint32_t EECR3; // @56 Timer External Event Control Register 3
	__IO uint32_t ADC1R; // @60 ADC Trigger 1 Register
	__IO uint32_t ADC2R; // @64 ADC Trigger 2 Register
	__IO uint32_t ADC3R; // @68 ADC Trigger 3 Register
	__IO uint32_t ADC4R; // @72 ADC Trigger 4 Register
	__IO uint8_t DLLCR; // @76 DLL Control Register
	 uint8_t RESERVED6[3]; // @77 
	__IO uint32_t FLTINR1; // @80 HRTIM Fault Input Register 1
	__IO uint32_t FLTINR2; // @84 HRTIM Fault Input Register 2
	__IO uint16_t BDMUPDR; // @88 BDMUPDR
	 uint8_t RESERVED7[2]; // @90 
	__IO uint32_t BDTxUPR; // @92 Burst DMA Timerx update Register
	__IO uint32_t BDMADR; // @96 Burst DMA Data Register
};

// HRTIM_Common->CR1 Control Register 1
enum {
	HRTIM_COMMON_CR1_AD4USRC = ((1UL<<3)-1) << 25, // ADC Trigger 4 Update Source
	HRTIM_COMMON_CR1_AD3USRC = ((1UL<<3)-1) << 22, // ADC Trigger 3 Update Source
	HRTIM_COMMON_CR1_AD2USRC = ((1UL<<3)-1) << 19, // ADC Trigger 2 Update Source
	HRTIM_COMMON_CR1_AD1USRC = ((1UL<<3)-1) << 16, // ADC Trigger 1 Update Source
	HRTIM_COMMON_CR1_TEUDIS = 1UL<<5, // Timer E Update Disable
	HRTIM_COMMON_CR1_TDUDIS = 1UL<<4, // Timer D Update Disable
	HRTIM_COMMON_CR1_TCUDIS = 1UL<<3, // Timer C Update Disable
	HRTIM_COMMON_CR1_TBUDIS = 1UL<<2, // Timer B Update Disable
	HRTIM_COMMON_CR1_TAUDIS = 1UL<<1, // Timer A Update Disable
	HRTIM_COMMON_CR1_MUDIS = 1UL<<0, // Master Update Disable		
};
inline void hrtim_common_cr1_set_ad4usrc(struct HRTIM_Common_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD4USRC) | ((val<<25) & HRTIM_COMMON_CR1_AD4USRC); }
inline void hrtim_common_cr1_set_ad3usrc(struct HRTIM_Common_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD3USRC) | ((val<<22) & HRTIM_COMMON_CR1_AD3USRC); }
inline void hrtim_common_cr1_set_ad2usrc(struct HRTIM_Common_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD2USRC) | ((val<<19) & HRTIM_COMMON_CR1_AD2USRC); }
inline void hrtim_common_cr1_set_ad1usrc(struct HRTIM_Common_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD1USRC) | ((val<<16) & HRTIM_COMMON_CR1_AD1USRC); }
inline uint32_t hrtim_common_cr1_get_ad4usrc(struct HRTIM_Common_Type* p) { return (p->CR1 & HRTIM_COMMON_CR1_AD4USRC) >> 25 ; }
inline uint32_t hrtim_common_cr1_get_ad3usrc(struct HRTIM_Common_Type* p) { return (p->CR1 & HRTIM_COMMON_CR1_AD3USRC) >> 22 ; }
inline uint32_t hrtim_common_cr1_get_ad2usrc(struct HRTIM_Common_Type* p) { return (p->CR1 & HRTIM_COMMON_CR1_AD2USRC) >> 19 ; }
inline uint32_t hrtim_common_cr1_get_ad1usrc(struct HRTIM_Common_Type* p) { return (p->CR1 & HRTIM_COMMON_CR1_AD1USRC) >> 16 ; }

// HRTIM_Common->CR2 Control Register 2
enum {
	HRTIM_COMMON_CR2_TERST = 1UL<<13, // Timer E counter software reset
	HRTIM_COMMON_CR2_TDRST = 1UL<<12, // Timer D counter software reset
	HRTIM_COMMON_CR2_TCRST = 1UL<<11, // Timer C counter software reset
	HRTIM_COMMON_CR2_TBRST = 1UL<<10, // Timer B counter software reset
	HRTIM_COMMON_CR2_TARST = 1UL<<9, // Timer A counter software reset
	HRTIM_COMMON_CR2_MRST = 1UL<<8, // Master Counter software reset
	HRTIM_COMMON_CR2_TESWU = 1UL<<5, // Timer E Software Update
	HRTIM_COMMON_CR2_TDSWU = 1UL<<4, // Timer D Software Update
	HRTIM_COMMON_CR2_TCSWU = 1UL<<3, // Timer C Software Update
	HRTIM_COMMON_CR2_TBSWU = 1UL<<2, // Timer B Software Update
	HRTIM_COMMON_CR2_TASWU = 1UL<<1, // Timer A Software update
	HRTIM_COMMON_CR2_MSWU = 1UL<<0, // Master Timer Software update		
};

// HRTIM_Common->ISR Interrupt Status Register
enum {
	HRTIM_COMMON_ISR_BMPER = 1UL<<17, // Burst mode Period Interrupt Flag
	HRTIM_COMMON_ISR_DLLRDY = 1UL<<16, // DLL Ready Interrupt Flag
	HRTIM_COMMON_ISR_SYSFLT = 1UL<<5, // System Fault Interrupt Flag
	HRTIM_COMMON_ISR_FLT5 = 1UL<<4, // Fault 5 Interrupt Flag
	HRTIM_COMMON_ISR_FLT4 = 1UL<<3, // Fault 4 Interrupt Flag
	HRTIM_COMMON_ISR_FLT3 = 1UL<<2, // Fault 3 Interrupt Flag
	HRTIM_COMMON_ISR_FLT2 = 1UL<<1, // Fault 2 Interrupt Flag
	HRTIM_COMMON_ISR_FLT1 = 1UL<<0, // Fault 1 Interrupt Flag		
};

// HRTIM_Common->ICR Interrupt Clear Register
enum {
	HRTIM_COMMON_ICR_BMPERC = 1UL<<17, // Burst mode period flag Clear
	HRTIM_COMMON_ICR_DLLRDYC = 1UL<<16, // DLL Ready Interrupt flag Clear
	HRTIM_COMMON_ICR_SYSFLTC = 1UL<<5, // System Fault Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT5C = 1UL<<4, // Fault 5 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT4C = 1UL<<3, // Fault 4 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT3C = 1UL<<2, // Fault 3 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT2C = 1UL<<1, // Fault 2 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT1C = 1UL<<0, // Fault 1 Interrupt Flag Clear		
};

// HRTIM_Common->IER Interrupt Enable Register
enum {
	HRTIM_COMMON_IER_BMPERIE = 1UL<<17, // Burst mode period Interrupt Enable
	HRTIM_COMMON_IER_DLLRDYIE = 1UL<<16, // DLL Ready Interrupt Enable
	HRTIM_COMMON_IER_SYSFLTE = 1UL<<5, // System Fault Interrupt Enable
	HRTIM_COMMON_IER_FLT5IE = 1UL<<4, // Fault 5 Interrupt Enable
	HRTIM_COMMON_IER_FLT4IE = 1UL<<3, // Fault 4 Interrupt Enable
	HRTIM_COMMON_IER_FLT3IE = 1UL<<2, // Fault 3 Interrupt Enable
	HRTIM_COMMON_IER_FLT2IE = 1UL<<1, // Fault 2 Interrupt Enable
	HRTIM_COMMON_IER_FLT1IE = 1UL<<0, // Fault 1 Interrupt Enable		
};

// HRTIM_Common->OENR Output Enable Register
enum {
	HRTIM_COMMON_OENR_TE2OEN = 1UL<<9, // Timer E Output 2 Enable
	HRTIM_COMMON_OENR_TE1OEN = 1UL<<8, // Timer E Output 1 Enable
	HRTIM_COMMON_OENR_TD2OEN = 1UL<<7, // Timer D Output 2 Enable
	HRTIM_COMMON_OENR_TD1OEN = 1UL<<6, // Timer D Output 1 Enable
	HRTIM_COMMON_OENR_TC2OEN = 1UL<<5, // Timer C Output 2 Enable
	HRTIM_COMMON_OENR_TC1OEN = 1UL<<4, // Timer C Output 1 Enable
	HRTIM_COMMON_OENR_TB2OEN = 1UL<<3, // Timer B Output 2 Enable
	HRTIM_COMMON_OENR_TB1OEN = 1UL<<2, // Timer B Output 1 Enable
	HRTIM_COMMON_OENR_TA2OEN = 1UL<<1, // Timer A Output 2 Enable
	HRTIM_COMMON_OENR_TA1OEN = 1UL<<0, // Timer A Output 1 Enable		
};

// HRTIM_Common->DISR DISR
enum {
	HRTIM_COMMON_DISR_TE2ODIS = 1UL<<9, // TE2ODIS
	HRTIM_COMMON_DISR_TE1ODIS = 1UL<<8, // TE1ODIS
	HRTIM_COMMON_DISR_TD2ODIS = 1UL<<7, // TD2ODIS
	HRTIM_COMMON_DISR_TD1ODIS = 1UL<<6, // TD1ODIS
	HRTIM_COMMON_DISR_TC2ODIS = 1UL<<5, // TC2ODIS
	HRTIM_COMMON_DISR_TC1ODIS = 1UL<<4, // TC1ODIS
	HRTIM_COMMON_DISR_TB2ODIS = 1UL<<3, // TB2ODIS
	HRTIM_COMMON_DISR_TB1ODIS = 1UL<<2, // TB1ODIS
	HRTIM_COMMON_DISR_TA2ODIS = 1UL<<1, // TA2ODIS
	HRTIM_COMMON_DISR_TA1ODIS = 1UL<<0, // TA1ODIS		
};

// HRTIM_Common->ODSR Output Disable Status Register
enum {
	HRTIM_COMMON_ODSR_TE2ODS = 1UL<<9, // Timer E Output 2 disable status
	HRTIM_COMMON_ODSR_TE1ODS = 1UL<<8, // Timer E Output 1 disable status
	HRTIM_COMMON_ODSR_TD2ODS = 1UL<<7, // Timer D Output 2 disable status
	HRTIM_COMMON_ODSR_TD1ODS = 1UL<<6, // Timer D Output 1 disable status
	HRTIM_COMMON_ODSR_TC2ODS = 1UL<<5, // Timer C Output 2 disable status
	HRTIM_COMMON_ODSR_TC1ODS = 1UL<<4, // Timer C Output 1 disable status
	HRTIM_COMMON_ODSR_TB2ODS = 1UL<<3, // Timer B Output 2 disable status
	HRTIM_COMMON_ODSR_TB1ODS = 1UL<<2, // Timer B Output 1 disable status
	HRTIM_COMMON_ODSR_TA2ODS = 1UL<<1, // Timer A Output 2 disable status
	HRTIM_COMMON_ODSR_TA1ODS = 1UL<<0, // Timer A Output 1 disable status		
};

// HRTIM_Common->BMCR Burst Mode Control Register
enum {
	HRTIM_COMMON_BMCR_BMSTAT = 1UL<<31, // Burst Mode Status
	HRTIM_COMMON_BMCR_TEBM = 1UL<<21, // Timer E Burst Mode
	HRTIM_COMMON_BMCR_TDBM = 1UL<<20, // Timer D Burst Mode
	HRTIM_COMMON_BMCR_TCBM = 1UL<<19, // Timer C Burst Mode
	HRTIM_COMMON_BMCR_TBBM = 1UL<<18, // Timer B Burst Mode
	HRTIM_COMMON_BMCR_TABM = 1UL<<17, // Timer A Burst Mode
	HRTIM_COMMON_BMCR_MTBM = 1UL<<16, // Master Timer Burst Mode
	HRTIM_COMMON_BMCR_BMPREN = 1UL<<10, // Burst Mode Preload Enable
	HRTIM_COMMON_BMCR_BMPRSC = ((1UL<<4)-1) << 6, // Burst Mode Prescaler
	HRTIM_COMMON_BMCR_BMCLK = ((1UL<<4)-1) << 2, // Burst Mode Clock source
	HRTIM_COMMON_BMCR_BMOM = 1UL<<1, // Burst Mode operating mode
	HRTIM_COMMON_BMCR_BME = 1UL<<0, // Burst Mode enable		
};
inline void hrtim_common_bmcr_set_bmprsc(struct HRTIM_Common_Type* p, uint32_t val) { p->BMCR = (p->BMCR & ~HRTIM_COMMON_BMCR_BMPRSC) | ((val<<6) & HRTIM_COMMON_BMCR_BMPRSC); }
inline void hrtim_common_bmcr_set_bmclk(struct HRTIM_Common_Type* p, uint32_t val) { p->BMCR = (p->BMCR & ~HRTIM_COMMON_BMCR_BMCLK) | ((val<<2) & HRTIM_COMMON_BMCR_BMCLK); }
inline uint32_t hrtim_common_bmcr_get_bmprsc(struct HRTIM_Common_Type* p) { return (p->BMCR & HRTIM_COMMON_BMCR_BMPRSC) >> 6 ; }
inline uint32_t hrtim_common_bmcr_get_bmclk(struct HRTIM_Common_Type* p) { return (p->BMCR & HRTIM_COMMON_BMCR_BMCLK) >> 2 ; }

// HRTIM_Common->BMTRG BMTRG
enum {
	HRTIM_COMMON_BMTRG_OCHPEV = 1UL<<31, // OCHPEV
	HRTIM_COMMON_BMTRG_TECMP2 = 1UL<<26, // TECMP2
	HRTIM_COMMON_BMTRG_TECMP1 = 1UL<<25, // TECMP1
	HRTIM_COMMON_BMTRG_TEREP = 1UL<<24, // TEREP
	HRTIM_COMMON_BMTRG_TERST = 1UL<<23, // TERST
	HRTIM_COMMON_BMTRG_TDCMP2 = 1UL<<22, // TDCMP2
	HRTIM_COMMON_BMTRG_TDCMP1 = 1UL<<21, // TDCMP1
	HRTIM_COMMON_BMTRG_TDREP = 1UL<<20, // TDREP
	HRTIM_COMMON_BMTRG_TDRST = 1UL<<19, // TDRST
	HRTIM_COMMON_BMTRG_TCCMP2 = 1UL<<18, // TCCMP2
	HRTIM_COMMON_BMTRG_TCCMP1 = 1UL<<17, // TCCMP1
	HRTIM_COMMON_BMTRG_TCREP = 1UL<<16, // TCREP
	HRTIM_COMMON_BMTRG_TCRST = 1UL<<15, // TCRST
	HRTIM_COMMON_BMTRG_TBCMP2 = 1UL<<14, // TBCMP2
	HRTIM_COMMON_BMTRG_TBCMP1 = 1UL<<13, // TBCMP1
	HRTIM_COMMON_BMTRG_TBREP = 1UL<<12, // TBREP
	HRTIM_COMMON_BMTRG_TBRST = 1UL<<11, // TBRST
	HRTIM_COMMON_BMTRG_TACMP2 = 1UL<<10, // TACMP2
	HRTIM_COMMON_BMTRG_TACMP1 = 1UL<<9, // TACMP1
	HRTIM_COMMON_BMTRG_TAREP = 1UL<<8, // TAREP
	HRTIM_COMMON_BMTRG_TARST = 1UL<<7, // TARST
	HRTIM_COMMON_BMTRG_MSTCMP4 = 1UL<<6, // MSTCMP4
	HRTIM_COMMON_BMTRG_MSTCMP3 = 1UL<<5, // MSTCMP3
	HRTIM_COMMON_BMTRG_MSTCMP2 = 1UL<<4, // MSTCMP2
	HRTIM_COMMON_BMTRG_MSTCMP1 = 1UL<<3, // MSTCMP1
	HRTIM_COMMON_BMTRG_MSTREP = 1UL<<2, // MSTREP
	HRTIM_COMMON_BMTRG_MSTRST = 1UL<<1, // MSTRST
	HRTIM_COMMON_BMTRG_SW = 1UL<<0, // SW		
};

// HRTIM_Common->EECR1 Timer External Event Control Register 1
enum {
	HRTIM_COMMON_EECR1_EE5FAST = 1UL<<29, // External Event 5 Fast mode
	HRTIM_COMMON_EECR1_EE5SNS = ((1UL<<2)-1) << 27, // External Event 5 Sensitivity
	HRTIM_COMMON_EECR1_EE5POL = 1UL<<26, // External Event 5 Polarity
	HRTIM_COMMON_EECR1_EE5SRC = ((1UL<<2)-1) << 24, // External Event 5 Source
	HRTIM_COMMON_EECR1_EE4FAST = 1UL<<23, // External Event 4 Fast mode
	HRTIM_COMMON_EECR1_EE4SNS = ((1UL<<2)-1) << 21, // External Event 4 Sensitivity
	HRTIM_COMMON_EECR1_EE4POL = 1UL<<20, // External Event 4 Polarity
	HRTIM_COMMON_EECR1_EE4SRC = ((1UL<<2)-1) << 18, // External Event 4 Source
	HRTIM_COMMON_EECR1_EE3FAST = 1UL<<17, // External Event 3 Fast mode
	HRTIM_COMMON_EECR1_EE3SNS = ((1UL<<2)-1) << 15, // External Event 3 Sensitivity
	HRTIM_COMMON_EECR1_EE3POL = 1UL<<14, // External Event 3 Polarity
	HRTIM_COMMON_EECR1_EE3SRC = ((1UL<<2)-1) << 12, // External Event 3 Source
	HRTIM_COMMON_EECR1_EE2FAST = 1UL<<11, // External Event 2 Fast mode
	HRTIM_COMMON_EECR1_EE2SNS = ((1UL<<2)-1) << 9, // External Event 2 Sensitivity
	HRTIM_COMMON_EECR1_EE2POL = 1UL<<8, // External Event 2 Polarity
	HRTIM_COMMON_EECR1_EE2SRC = ((1UL<<2)-1) << 6, // External Event 2 Source
	HRTIM_COMMON_EECR1_EE1FAST = 1UL<<5, // External Event 1 Fast mode
	HRTIM_COMMON_EECR1_EE1SNS = ((1UL<<2)-1) << 3, // External Event 1 Sensitivity
	HRTIM_COMMON_EECR1_EE1POL = 1UL<<2, // External Event 1 Polarity
	HRTIM_COMMON_EECR1_EE1SRC = ((1UL<<2)-1) << 0, // External Event 1 Source		
};
inline void hrtim_common_eecr1_set_ee5sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE5SNS) | ((val<<27) & HRTIM_COMMON_EECR1_EE5SNS); }
inline void hrtim_common_eecr1_set_ee5src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE5SRC) | ((val<<24) & HRTIM_COMMON_EECR1_EE5SRC); }
inline void hrtim_common_eecr1_set_ee4sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE4SNS) | ((val<<21) & HRTIM_COMMON_EECR1_EE4SNS); }
inline void hrtim_common_eecr1_set_ee4src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE4SRC) | ((val<<18) & HRTIM_COMMON_EECR1_EE4SRC); }
inline void hrtim_common_eecr1_set_ee3sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE3SNS) | ((val<<15) & HRTIM_COMMON_EECR1_EE3SNS); }
inline void hrtim_common_eecr1_set_ee3src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE3SRC) | ((val<<12) & HRTIM_COMMON_EECR1_EE3SRC); }
inline void hrtim_common_eecr1_set_ee2sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE2SNS) | ((val<<9) & HRTIM_COMMON_EECR1_EE2SNS); }
inline void hrtim_common_eecr1_set_ee2src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE2SRC) | ((val<<6) & HRTIM_COMMON_EECR1_EE2SRC); }
inline void hrtim_common_eecr1_set_ee1sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE1SNS) | ((val<<3) & HRTIM_COMMON_EECR1_EE1SNS); }
inline void hrtim_common_eecr1_set_ee1src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE1SRC) | ((val<<0) & HRTIM_COMMON_EECR1_EE1SRC); }
inline uint32_t hrtim_common_eecr1_get_ee5sns(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE5SNS) >> 27 ; }
inline uint32_t hrtim_common_eecr1_get_ee5src(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE5SRC) >> 24 ; }
inline uint32_t hrtim_common_eecr1_get_ee4sns(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE4SNS) >> 21 ; }
inline uint32_t hrtim_common_eecr1_get_ee4src(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE4SRC) >> 18 ; }
inline uint32_t hrtim_common_eecr1_get_ee3sns(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE3SNS) >> 15 ; }
inline uint32_t hrtim_common_eecr1_get_ee3src(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE3SRC) >> 12 ; }
inline uint32_t hrtim_common_eecr1_get_ee2sns(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE2SNS) >> 9 ; }
inline uint32_t hrtim_common_eecr1_get_ee2src(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE2SRC) >> 6 ; }
inline uint32_t hrtim_common_eecr1_get_ee1sns(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE1SNS) >> 3 ; }
inline uint32_t hrtim_common_eecr1_get_ee1src(struct HRTIM_Common_Type* p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE1SRC) >> 0 ; }

// HRTIM_Common->EECR2 Timer External Event Control Register 2
enum {
	HRTIM_COMMON_EECR2_EE10SNS = ((1UL<<2)-1) << 27, // External Event 10 Sensitivity
	HRTIM_COMMON_EECR2_EE10POL = 1UL<<26, // External Event 10 Polarity
	HRTIM_COMMON_EECR2_EE10SRC = ((1UL<<2)-1) << 24, // External Event 10 Source
	HRTIM_COMMON_EECR2_EE9SNS = ((1UL<<2)-1) << 21, // External Event 9 Sensitivity
	HRTIM_COMMON_EECR2_EE9POL = 1UL<<20, // External Event 9 Polarity
	HRTIM_COMMON_EECR2_EE9SRC = ((1UL<<2)-1) << 18, // External Event 9 Source
	HRTIM_COMMON_EECR2_EE8SNS = ((1UL<<2)-1) << 15, // External Event 8 Sensitivity
	HRTIM_COMMON_EECR2_EE8POL = 1UL<<14, // External Event 8 Polarity
	HRTIM_COMMON_EECR2_EE8SRC = ((1UL<<2)-1) << 12, // External Event 8 Source
	HRTIM_COMMON_EECR2_EE7SNS = ((1UL<<2)-1) << 9, // External Event 7 Sensitivity
	HRTIM_COMMON_EECR2_EE7POL = 1UL<<8, // External Event 7 Polarity
	HRTIM_COMMON_EECR2_EE7SRC = ((1UL<<2)-1) << 6, // External Event 7 Source
	HRTIM_COMMON_EECR2_EE6SNS = ((1UL<<2)-1) << 3, // External Event 6 Sensitivity
	HRTIM_COMMON_EECR2_EE6POL = 1UL<<2, // External Event 6 Polarity
	HRTIM_COMMON_EECR2_EE6SRC = ((1UL<<2)-1) << 0, // External Event 6 Source		
};
inline void hrtim_common_eecr2_set_ee10sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE10SNS) | ((val<<27) & HRTIM_COMMON_EECR2_EE10SNS); }
inline void hrtim_common_eecr2_set_ee10src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE10SRC) | ((val<<24) & HRTIM_COMMON_EECR2_EE10SRC); }
inline void hrtim_common_eecr2_set_ee9sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE9SNS) | ((val<<21) & HRTIM_COMMON_EECR2_EE9SNS); }
inline void hrtim_common_eecr2_set_ee9src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE9SRC) | ((val<<18) & HRTIM_COMMON_EECR2_EE9SRC); }
inline void hrtim_common_eecr2_set_ee8sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE8SNS) | ((val<<15) & HRTIM_COMMON_EECR2_EE8SNS); }
inline void hrtim_common_eecr2_set_ee8src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE8SRC) | ((val<<12) & HRTIM_COMMON_EECR2_EE8SRC); }
inline void hrtim_common_eecr2_set_ee7sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE7SNS) | ((val<<9) & HRTIM_COMMON_EECR2_EE7SNS); }
inline void hrtim_common_eecr2_set_ee7src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE7SRC) | ((val<<6) & HRTIM_COMMON_EECR2_EE7SRC); }
inline void hrtim_common_eecr2_set_ee6sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE6SNS) | ((val<<3) & HRTIM_COMMON_EECR2_EE6SNS); }
inline void hrtim_common_eecr2_set_ee6src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE6SRC) | ((val<<0) & HRTIM_COMMON_EECR2_EE6SRC); }
inline uint32_t hrtim_common_eecr2_get_ee10sns(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE10SNS) >> 27 ; }
inline uint32_t hrtim_common_eecr2_get_ee10src(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE10SRC) >> 24 ; }
inline uint32_t hrtim_common_eecr2_get_ee9sns(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE9SNS) >> 21 ; }
inline uint32_t hrtim_common_eecr2_get_ee9src(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE9SRC) >> 18 ; }
inline uint32_t hrtim_common_eecr2_get_ee8sns(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE8SNS) >> 15 ; }
inline uint32_t hrtim_common_eecr2_get_ee8src(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE8SRC) >> 12 ; }
inline uint32_t hrtim_common_eecr2_get_ee7sns(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE7SNS) >> 9 ; }
inline uint32_t hrtim_common_eecr2_get_ee7src(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE7SRC) >> 6 ; }
inline uint32_t hrtim_common_eecr2_get_ee6sns(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE6SNS) >> 3 ; }
inline uint32_t hrtim_common_eecr2_get_ee6src(struct HRTIM_Common_Type* p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE6SRC) >> 0 ; }

// HRTIM_Common->EECR3 Timer External Event Control Register 3
enum {
	HRTIM_COMMON_EECR3_EE10SNS = ((1UL<<2)-1) << 27, // EE10SNS
	HRTIM_COMMON_EECR3_EE10POL = 1UL<<26, // EE10POL
	HRTIM_COMMON_EECR3_EE10SRC = ((1UL<<2)-1) << 24, // EE10SRC
	HRTIM_COMMON_EECR3_EE9SNS = ((1UL<<2)-1) << 21, // EE9SNS
	HRTIM_COMMON_EECR3_EE9POL = 1UL<<20, // EE9POL
	HRTIM_COMMON_EECR3_EE9SRC = ((1UL<<2)-1) << 18, // EE9SRC
	HRTIM_COMMON_EECR3_EE8SNS = ((1UL<<2)-1) << 15, // EE8SNS
	HRTIM_COMMON_EECR3_EE8POL = 1UL<<14, // EE8POL
	HRTIM_COMMON_EECR3_EE8SRC = ((1UL<<2)-1) << 12, // EE8SRC
	HRTIM_COMMON_EECR3_EE7SNS = ((1UL<<2)-1) << 9, // EE7SNS
	HRTIM_COMMON_EECR3_EE7POL = 1UL<<8, // EE7POL
	HRTIM_COMMON_EECR3_EE7SRC = ((1UL<<2)-1) << 6, // EE7SRC
	HRTIM_COMMON_EECR3_EE6SNS = ((1UL<<2)-1) << 3, // EE6SNS
	HRTIM_COMMON_EECR3_EE6POL = 1UL<<2, // EE6POL
	HRTIM_COMMON_EECR3_EE6SRC = ((1UL<<2)-1) << 0, // EE6SRC		
};
inline void hrtim_common_eecr3_set_ee10sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE10SNS) | ((val<<27) & HRTIM_COMMON_EECR3_EE10SNS); }
inline void hrtim_common_eecr3_set_ee10src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE10SRC) | ((val<<24) & HRTIM_COMMON_EECR3_EE10SRC); }
inline void hrtim_common_eecr3_set_ee9sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE9SNS) | ((val<<21) & HRTIM_COMMON_EECR3_EE9SNS); }
inline void hrtim_common_eecr3_set_ee9src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE9SRC) | ((val<<18) & HRTIM_COMMON_EECR3_EE9SRC); }
inline void hrtim_common_eecr3_set_ee8sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE8SNS) | ((val<<15) & HRTIM_COMMON_EECR3_EE8SNS); }
inline void hrtim_common_eecr3_set_ee8src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE8SRC) | ((val<<12) & HRTIM_COMMON_EECR3_EE8SRC); }
inline void hrtim_common_eecr3_set_ee7sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE7SNS) | ((val<<9) & HRTIM_COMMON_EECR3_EE7SNS); }
inline void hrtim_common_eecr3_set_ee7src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE7SRC) | ((val<<6) & HRTIM_COMMON_EECR3_EE7SRC); }
inline void hrtim_common_eecr3_set_ee6sns(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE6SNS) | ((val<<3) & HRTIM_COMMON_EECR3_EE6SNS); }
inline void hrtim_common_eecr3_set_ee6src(struct HRTIM_Common_Type* p, uint32_t val) { p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE6SRC) | ((val<<0) & HRTIM_COMMON_EECR3_EE6SRC); }
inline uint32_t hrtim_common_eecr3_get_ee10sns(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE10SNS) >> 27 ; }
inline uint32_t hrtim_common_eecr3_get_ee10src(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE10SRC) >> 24 ; }
inline uint32_t hrtim_common_eecr3_get_ee9sns(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE9SNS) >> 21 ; }
inline uint32_t hrtim_common_eecr3_get_ee9src(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE9SRC) >> 18 ; }
inline uint32_t hrtim_common_eecr3_get_ee8sns(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE8SNS) >> 15 ; }
inline uint32_t hrtim_common_eecr3_get_ee8src(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE8SRC) >> 12 ; }
inline uint32_t hrtim_common_eecr3_get_ee7sns(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE7SNS) >> 9 ; }
inline uint32_t hrtim_common_eecr3_get_ee7src(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE7SRC) >> 6 ; }
inline uint32_t hrtim_common_eecr3_get_ee6sns(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE6SNS) >> 3 ; }
inline uint32_t hrtim_common_eecr3_get_ee6src(struct HRTIM_Common_Type* p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE6SRC) >> 0 ; }

// HRTIM_Common->ADC1R ADC Trigger 1 Register
enum {
	HRTIM_COMMON_ADC1R_AD1TEPER = 1UL<<31, // ADC trigger 1 on Timer E Period
	HRTIM_COMMON_ADC1R_AD1TEC4 = 1UL<<30, // ADC trigger 1 on Timer E compare 4
	HRTIM_COMMON_ADC1R_AD1TEC3 = 1UL<<29, // ADC trigger 1 on Timer E compare 3
	HRTIM_COMMON_ADC1R_AD1TEC2 = 1UL<<28, // ADC trigger 1 on Timer E compare 2
	HRTIM_COMMON_ADC1R_AD1TDPER = 1UL<<27, // ADC trigger 1 on Timer D Period
	HRTIM_COMMON_ADC1R_AD1TDC4 = 1UL<<26, // ADC trigger 1 on Timer D compare 4
	HRTIM_COMMON_ADC1R_AD1TDC3 = 1UL<<25, // ADC trigger 1 on Timer D compare 3
	HRTIM_COMMON_ADC1R_AD1TDC2 = 1UL<<24, // ADC trigger 1 on Timer D compare 2
	HRTIM_COMMON_ADC1R_AD1TCPER = 1UL<<23, // ADC trigger 1 on Timer C Period
	HRTIM_COMMON_ADC1R_AD1TCC4 = 1UL<<22, // ADC trigger 1 on Timer C compare 4
	HRTIM_COMMON_ADC1R_AD1TCC3 = 1UL<<21, // ADC trigger 1 on Timer C compare 3
	HRTIM_COMMON_ADC1R_AD1TCC2 = 1UL<<20, // ADC trigger 1 on Timer C compare 2
	HRTIM_COMMON_ADC1R_AD1TBRST = 1UL<<19, // ADC trigger 1 on Timer B Reset
	HRTIM_COMMON_ADC1R_AD1TBPER = 1UL<<18, // ADC trigger 1 on Timer B Period
	HRTIM_COMMON_ADC1R_AD1TBC4 = 1UL<<17, // ADC trigger 1 on Timer B compare 4
	HRTIM_COMMON_ADC1R_AD1TBC3 = 1UL<<16, // ADC trigger 1 on Timer B compare 3
	HRTIM_COMMON_ADC1R_AD1TBC2 = 1UL<<15, // ADC trigger 1 on Timer B compare 2
	HRTIM_COMMON_ADC1R_AD1TARST = 1UL<<14, // ADC trigger 1 on Timer A Reset
	HRTIM_COMMON_ADC1R_AD1TAPER = 1UL<<13, // ADC trigger 1 on Timer A Period
	HRTIM_COMMON_ADC1R_AD1TAC4 = 1UL<<12, // ADC trigger 1 on Timer A compare 4
	HRTIM_COMMON_ADC1R_AD1TAC3 = 1UL<<11, // ADC trigger 1 on Timer A compare 3
	HRTIM_COMMON_ADC1R_AD1TAC2 = 1UL<<10, // ADC trigger 1 on Timer A compare 2
	HRTIM_COMMON_ADC1R_AD1EEV5 = 1UL<<9, // ADC trigger 1 on External Event 5
	HRTIM_COMMON_ADC1R_AD1EEV4 = 1UL<<8, // ADC trigger 1 on External Event 4
	HRTIM_COMMON_ADC1R_AD1EEV3 = 1UL<<7, // ADC trigger 1 on External Event 3
	HRTIM_COMMON_ADC1R_AD1EEV2 = 1UL<<6, // ADC trigger 1 on External Event 2
	HRTIM_COMMON_ADC1R_AD1EEV1 = 1UL<<5, // ADC trigger 1 on External Event 1
	HRTIM_COMMON_ADC1R_AD1MPER = 1UL<<4, // ADC trigger 1 on Master Period
	HRTIM_COMMON_ADC1R_AD1MC4 = 1UL<<3, // ADC trigger 1 on Master Compare 4
	HRTIM_COMMON_ADC1R_AD1MC3 = 1UL<<2, // ADC trigger 1 on Master Compare 3
	HRTIM_COMMON_ADC1R_AD1MC2 = 1UL<<1, // ADC trigger 1 on Master Compare 2
	HRTIM_COMMON_ADC1R_AD1MC1 = 1UL<<0, // ADC trigger 1 on Master Compare 1		
};

// HRTIM_Common->ADC2R ADC Trigger 2 Register
enum {
	HRTIM_COMMON_ADC2R_AD2TERST = 1UL<<31, // ADC trigger 2 on Timer E Reset
	HRTIM_COMMON_ADC2R_AD2TEC4 = 1UL<<30, // ADC trigger 2 on Timer E compare 4
	HRTIM_COMMON_ADC2R_AD2TEC3 = 1UL<<29, // ADC trigger 2 on Timer E compare 3
	HRTIM_COMMON_ADC2R_AD2TEC2 = 1UL<<28, // ADC trigger 2 on Timer E compare 2
	HRTIM_COMMON_ADC2R_AD2TDRST = 1UL<<27, // ADC trigger 2 on Timer D Reset
	HRTIM_COMMON_ADC2R_AD2TDPER = 1UL<<26, // ADC trigger 2 on Timer D Period
	HRTIM_COMMON_ADC2R_AD2TDC4 = 1UL<<25, // ADC trigger 2 on Timer D compare 4
	HRTIM_COMMON_ADC2R_AD2TDC3 = 1UL<<24, // ADC trigger 2 on Timer D compare 3
	HRTIM_COMMON_ADC2R_AD2TDC2 = 1UL<<23, // ADC trigger 2 on Timer D compare 2
	HRTIM_COMMON_ADC2R_AD2TCRST = 1UL<<22, // ADC trigger 2 on Timer C Reset
	HRTIM_COMMON_ADC2R_AD2TCPER = 1UL<<21, // ADC trigger 2 on Timer C Period
	HRTIM_COMMON_ADC2R_AD2TCC4 = 1UL<<20, // ADC trigger 2 on Timer C compare 4
	HRTIM_COMMON_ADC2R_AD2TCC3 = 1UL<<19, // ADC trigger 2 on Timer C compare 3
	HRTIM_COMMON_ADC2R_AD2TCC2 = 1UL<<18, // ADC trigger 2 on Timer C compare 2
	HRTIM_COMMON_ADC2R_AD2TBPER = 1UL<<17, // ADC trigger 2 on Timer B Period
	HRTIM_COMMON_ADC2R_AD2TBC4 = 1UL<<16, // ADC trigger 2 on Timer B compare 4
	HRTIM_COMMON_ADC2R_AD2TBC3 = 1UL<<15, // ADC trigger 2 on Timer B compare 3
	HRTIM_COMMON_ADC2R_AD2TBC2 = 1UL<<14, // ADC trigger 2 on Timer B compare 2
	HRTIM_COMMON_ADC2R_AD2TAPER = 1UL<<13, // ADC trigger 2 on Timer A Period
	HRTIM_COMMON_ADC2R_AD2TAC4 = 1UL<<12, // ADC trigger 2 on Timer A compare 4
	HRTIM_COMMON_ADC2R_AD2TAC3 = 1UL<<11, // ADC trigger 2 on Timer A compare 3
	HRTIM_COMMON_ADC2R_AD2TAC2 = 1UL<<10, // ADC trigger 2 on Timer A compare 2
	HRTIM_COMMON_ADC2R_AD2EEV10 = 1UL<<9, // ADC trigger 2 on External Event 10
	HRTIM_COMMON_ADC2R_AD2EEV9 = 1UL<<8, // ADC trigger 2 on External Event 9
	HRTIM_COMMON_ADC2R_AD2EEV8 = 1UL<<7, // ADC trigger 2 on External Event 8
	HRTIM_COMMON_ADC2R_AD2EEV7 = 1UL<<6, // ADC trigger 2 on External Event 7
	HRTIM_COMMON_ADC2R_AD2EEV6 = 1UL<<5, // ADC trigger 2 on External Event 6
	HRTIM_COMMON_ADC2R_AD2MPER = 1UL<<4, // ADC trigger 2 on Master Period
	HRTIM_COMMON_ADC2R_AD2MC4 = 1UL<<3, // ADC trigger 2 on Master Compare 4
	HRTIM_COMMON_ADC2R_AD2MC3 = 1UL<<2, // ADC trigger 2 on Master Compare 3
	HRTIM_COMMON_ADC2R_AD2MC2 = 1UL<<1, // ADC trigger 2 on Master Compare 2
	HRTIM_COMMON_ADC2R_AD2MC1 = 1UL<<0, // ADC trigger 2 on Master Compare 1		
};

// HRTIM_Common->ADC3R ADC Trigger 3 Register
enum {
	HRTIM_COMMON_ADC3R_AD1TEPER = 1UL<<31, // AD1TEPER
	HRTIM_COMMON_ADC3R_AD1TEC4 = 1UL<<30, // AD1TEC4
	HRTIM_COMMON_ADC3R_AD1TEC3 = 1UL<<29, // AD1TEC3
	HRTIM_COMMON_ADC3R_AD1TEC2 = 1UL<<28, // AD1TEC2
	HRTIM_COMMON_ADC3R_AD1TDPER = 1UL<<27, // AD1TDPER
	HRTIM_COMMON_ADC3R_AD1TDC4 = 1UL<<26, // AD1TDC4
	HRTIM_COMMON_ADC3R_AD1TDC3 = 1UL<<25, // AD1TDC3
	HRTIM_COMMON_ADC3R_AD1TDC2 = 1UL<<24, // AD1TDC2
	HRTIM_COMMON_ADC3R_AD1TCPER = 1UL<<23, // AD1TCPER
	HRTIM_COMMON_ADC3R_AD1TCC4 = 1UL<<22, // AD1TCC4
	HRTIM_COMMON_ADC3R_AD1TCC3 = 1UL<<21, // AD1TCC3
	HRTIM_COMMON_ADC3R_AD1TCC2 = 1UL<<20, // AD1TCC2
	HRTIM_COMMON_ADC3R_AD1TBRST = 1UL<<19, // AD1TBRST
	HRTIM_COMMON_ADC3R_AD1TBPER = 1UL<<18, // AD1TBPER
	HRTIM_COMMON_ADC3R_AD1TBC4 = 1UL<<17, // AD1TBC4
	HRTIM_COMMON_ADC3R_AD1TBC3 = 1UL<<16, // AD1TBC3
	HRTIM_COMMON_ADC3R_AD1TBC2 = 1UL<<15, // AD1TBC2
	HRTIM_COMMON_ADC3R_AD1TARST = 1UL<<14, // AD1TARST
	HRTIM_COMMON_ADC3R_AD1TAPER = 1UL<<13, // AD1TAPER
	HRTIM_COMMON_ADC3R_AD1TAC4 = 1UL<<12, // AD1TAC4
	HRTIM_COMMON_ADC3R_AD1TAC3 = 1UL<<11, // AD1TAC3
	HRTIM_COMMON_ADC3R_AD1TAC2 = 1UL<<10, // AD1TAC2
	HRTIM_COMMON_ADC3R_AD1EEV5 = 1UL<<9, // AD1EEV5
	HRTIM_COMMON_ADC3R_AD1EEV4 = 1UL<<8, // AD1EEV4
	HRTIM_COMMON_ADC3R_AD1EEV3 = 1UL<<7, // AD1EEV3
	HRTIM_COMMON_ADC3R_AD1EEV2 = 1UL<<6, // AD1EEV2
	HRTIM_COMMON_ADC3R_AD1EEV1 = 1UL<<5, // AD1EEV1
	HRTIM_COMMON_ADC3R_AD1MPER = 1UL<<4, // AD1MPER
	HRTIM_COMMON_ADC3R_AD1MC4 = 1UL<<3, // AD1MC4
	HRTIM_COMMON_ADC3R_AD1MC3 = 1UL<<2, // AD1MC3
	HRTIM_COMMON_ADC3R_AD1MC2 = 1UL<<1, // AD1MC2
	HRTIM_COMMON_ADC3R_AD1MC1 = 1UL<<0, // AD1MC1		
};

// HRTIM_Common->ADC4R ADC Trigger 4 Register
enum {
	HRTIM_COMMON_ADC4R_AD2TERST = 1UL<<31, // AD2TERST
	HRTIM_COMMON_ADC4R_AD2TEC4 = 1UL<<30, // AD2TEC4
	HRTIM_COMMON_ADC4R_AD2TEC3 = 1UL<<29, // AD2TEC3
	HRTIM_COMMON_ADC4R_AD2TEC2 = 1UL<<28, // AD2TEC2
	HRTIM_COMMON_ADC4R_AD2TDRST = 1UL<<27, // AD2TDRST
	HRTIM_COMMON_ADC4R_AD2TDPER = 1UL<<26, // AD2TDPER
	HRTIM_COMMON_ADC4R_AD2TDC4 = 1UL<<25, // AD2TDC4
	HRTIM_COMMON_ADC4R_AD2TDC3 = 1UL<<24, // AD2TDC3
	HRTIM_COMMON_ADC4R_AD2TDC2 = 1UL<<23, // AD2TDC2
	HRTIM_COMMON_ADC4R_AD2TCRST = 1UL<<22, // AD2TCRST
	HRTIM_COMMON_ADC4R_AD2TCPER = 1UL<<21, // AD2TCPER
	HRTIM_COMMON_ADC4R_AD2TCC4 = 1UL<<20, // AD2TCC4
	HRTIM_COMMON_ADC4R_AD2TCC3 = 1UL<<19, // AD2TCC3
	HRTIM_COMMON_ADC4R_AD2TCC2 = 1UL<<18, // AD2TCC2
	HRTIM_COMMON_ADC4R_AD2TBPER = 1UL<<17, // AD2TBPER
	HRTIM_COMMON_ADC4R_AD2TBC4 = 1UL<<16, // AD2TBC4
	HRTIM_COMMON_ADC4R_AD2TBC3 = 1UL<<15, // AD2TBC3
	HRTIM_COMMON_ADC4R_AD2TBC2 = 1UL<<14, // AD2TBC2
	HRTIM_COMMON_ADC4R_AD2TAPER = 1UL<<13, // AD2TAPER
	HRTIM_COMMON_ADC4R_AD2TAC4 = 1UL<<12, // AD2TAC4
	HRTIM_COMMON_ADC4R_AD2TAC3 = 1UL<<11, // AD2TAC3
	HRTIM_COMMON_ADC4R_AD2TAC2 = 1UL<<10, // AD2TAC2
	HRTIM_COMMON_ADC4R_AD2EEV10 = 1UL<<9, // AD2EEV10
	HRTIM_COMMON_ADC4R_AD2EEV9 = 1UL<<8, // AD2EEV9
	HRTIM_COMMON_ADC4R_AD2EEV8 = 1UL<<7, // AD2EEV8
	HRTIM_COMMON_ADC4R_AD2EEV7 = 1UL<<6, // AD2EEV7
	HRTIM_COMMON_ADC4R_AD2EEV6 = 1UL<<5, // AD2EEV6
	HRTIM_COMMON_ADC4R_AD2MPER = 1UL<<4, // AD2MPER
	HRTIM_COMMON_ADC4R_AD2MC4 = 1UL<<3, // AD2MC4
	HRTIM_COMMON_ADC4R_AD2MC3 = 1UL<<2, // AD2MC3
	HRTIM_COMMON_ADC4R_AD2MC2 = 1UL<<1, // AD2MC2
	HRTIM_COMMON_ADC4R_AD2MC1 = 1UL<<0, // AD2MC1		
};

// HRTIM_Common->DLLCR DLL Control Register
enum {
	HRTIM_COMMON_DLLCR_CALRTE = ((1UL<<2)-1) << 2, // DLL Calibration rate
	HRTIM_COMMON_DLLCR_CALEN = 1UL<<1, // DLL Calibration Enable
	HRTIM_COMMON_DLLCR_CAL = 1UL<<0, // DLL Calibration Start		
};
inline void hrtim_common_dllcr_set_calrte(struct HRTIM_Common_Type* p, uint32_t val) { p->DLLCR = (p->DLLCR & ~HRTIM_COMMON_DLLCR_CALRTE) | ((val<<2) & HRTIM_COMMON_DLLCR_CALRTE); }
inline uint32_t hrtim_common_dllcr_get_calrte(struct HRTIM_Common_Type* p) { return (p->DLLCR & HRTIM_COMMON_DLLCR_CALRTE) >> 2 ; }

// HRTIM_Common->FLTINR1 HRTIM Fault Input Register 1
enum {
	HRTIM_COMMON_FLTINR1_FLT4LCK = 1UL<<31, // FLT4LCK
	HRTIM_COMMON_FLTINR1_FLT4F = ((1UL<<4)-1) << 27, // FLT4F
	HRTIM_COMMON_FLTINR1_FLT4SRC = 1UL<<26, // FLT4SRC
	HRTIM_COMMON_FLTINR1_FLT4P = 1UL<<25, // FLT4P
	HRTIM_COMMON_FLTINR1_FLT4E = 1UL<<24, // FLT4E
	HRTIM_COMMON_FLTINR1_FLT3LCK = 1UL<<23, // FLT3LCK
	HRTIM_COMMON_FLTINR1_FLT3F = ((1UL<<4)-1) << 19, // FLT3F
	HRTIM_COMMON_FLTINR1_FLT3SRC = 1UL<<18, // FLT3SRC
	HRTIM_COMMON_FLTINR1_FLT3P = 1UL<<17, // FLT3P
	HRTIM_COMMON_FLTINR1_FLT3E = 1UL<<16, // FLT3E
	HRTIM_COMMON_FLTINR1_FLT2LCK = 1UL<<15, // FLT2LCK
	HRTIM_COMMON_FLTINR1_FLT2F = ((1UL<<4)-1) << 11, // FLT2F
	HRTIM_COMMON_FLTINR1_FLT2SRC = 1UL<<10, // FLT2SRC
	HRTIM_COMMON_FLTINR1_FLT2P = 1UL<<9, // FLT2P
	HRTIM_COMMON_FLTINR1_FLT2E = 1UL<<8, // FLT2E
	HRTIM_COMMON_FLTINR1_FLT1LCK = 1UL<<7, // FLT1LCK
	HRTIM_COMMON_FLTINR1_FLT1F = ((1UL<<4)-1) << 3, // FLT1F
	HRTIM_COMMON_FLTINR1_FLT1SRC = 1UL<<2, // FLT1SRC
	HRTIM_COMMON_FLTINR1_FLT1P = 1UL<<1, // FLT1P
	HRTIM_COMMON_FLTINR1_FLT1E = 1UL<<0, // FLT1E		
};
inline void hrtim_common_fltinr1_set_flt4f(struct HRTIM_Common_Type* p, uint32_t val) { p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT4F) | ((val<<27) & HRTIM_COMMON_FLTINR1_FLT4F); }
inline void hrtim_common_fltinr1_set_flt3f(struct HRTIM_Common_Type* p, uint32_t val) { p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT3F) | ((val<<19) & HRTIM_COMMON_FLTINR1_FLT3F); }
inline void hrtim_common_fltinr1_set_flt2f(struct HRTIM_Common_Type* p, uint32_t val) { p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT2F) | ((val<<11) & HRTIM_COMMON_FLTINR1_FLT2F); }
inline void hrtim_common_fltinr1_set_flt1f(struct HRTIM_Common_Type* p, uint32_t val) { p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT1F) | ((val<<3) & HRTIM_COMMON_FLTINR1_FLT1F); }
inline uint32_t hrtim_common_fltinr1_get_flt4f(struct HRTIM_Common_Type* p) { return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT4F) >> 27 ; }
inline uint32_t hrtim_common_fltinr1_get_flt3f(struct HRTIM_Common_Type* p) { return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT3F) >> 19 ; }
inline uint32_t hrtim_common_fltinr1_get_flt2f(struct HRTIM_Common_Type* p) { return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT2F) >> 11 ; }
inline uint32_t hrtim_common_fltinr1_get_flt1f(struct HRTIM_Common_Type* p) { return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT1F) >> 3 ; }

// HRTIM_Common->FLTINR2 HRTIM Fault Input Register 2
enum {
	HRTIM_COMMON_FLTINR2_FLTSD = ((1UL<<2)-1) << 24, // FLTSD
	HRTIM_COMMON_FLTINR2_FLT5LCK = 1UL<<7, // FLT5LCK
	HRTIM_COMMON_FLTINR2_FLT5F = ((1UL<<4)-1) << 3, // FLT5F
	HRTIM_COMMON_FLTINR2_FLT5SRC = 1UL<<2, // FLT5SRC
	HRTIM_COMMON_FLTINR2_FLT5P = 1UL<<1, // FLT5P
	HRTIM_COMMON_FLTINR2_FLT5E = 1UL<<0, // FLT5E		
};
inline void hrtim_common_fltinr2_set_fltsd(struct HRTIM_Common_Type* p, uint32_t val) { p->FLTINR2 = (p->FLTINR2 & ~HRTIM_COMMON_FLTINR2_FLTSD) | ((val<<24) & HRTIM_COMMON_FLTINR2_FLTSD); }
inline void hrtim_common_fltinr2_set_flt5f(struct HRTIM_Common_Type* p, uint32_t val) { p->FLTINR2 = (p->FLTINR2 & ~HRTIM_COMMON_FLTINR2_FLT5F) | ((val<<3) & HRTIM_COMMON_FLTINR2_FLT5F); }
inline uint32_t hrtim_common_fltinr2_get_fltsd(struct HRTIM_Common_Type* p) { return (p->FLTINR2 & HRTIM_COMMON_FLTINR2_FLTSD) >> 24 ; }
inline uint32_t hrtim_common_fltinr2_get_flt5f(struct HRTIM_Common_Type* p) { return (p->FLTINR2 & HRTIM_COMMON_FLTINR2_FLT5F) >> 3 ; }

// HRTIM_Common->BDMUPDR BDMUPDR
enum {
	HRTIM_COMMON_BDMUPDR_MCMP4 = 1UL<<9, // MCMP4
	HRTIM_COMMON_BDMUPDR_MCMP3 = 1UL<<8, // MCMP3
	HRTIM_COMMON_BDMUPDR_MCMP2 = 1UL<<7, // MCMP2
	HRTIM_COMMON_BDMUPDR_MCMP1 = 1UL<<6, // MCMP1
	HRTIM_COMMON_BDMUPDR_MREP = 1UL<<5, // MREP
	HRTIM_COMMON_BDMUPDR_MPER = 1UL<<4, // MPER
	HRTIM_COMMON_BDMUPDR_MCNT = 1UL<<3, // MCNT
	HRTIM_COMMON_BDMUPDR_MDIER = 1UL<<2, // MDIER
	HRTIM_COMMON_BDMUPDR_MICR = 1UL<<1, // MICR
	HRTIM_COMMON_BDMUPDR_MCR = 1UL<<0, // MCR		
};

// HRTIM_Common->BDTxUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTXUPR_TIMXFLTR = 1UL<<20, // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXOUTR = 1UL<<19, // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCHPR = 1UL<<18, // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXRSTR = 1UL<<17, // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXEEFR2 = 1UL<<16, // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTXUPR_TIMXEEFR1 = 1UL<<15, // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTXUPR_TIMXRST2R = 1UL<<14, // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXSET2R = 1UL<<13, // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXRST1R = 1UL<<12, // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXSET1R = 1UL<<11, // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMX_DTXR = 1UL<<10, // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCMP4 = 1UL<<9, // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCMP3 = 1UL<<8, // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCMP2 = 1UL<<7, // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCMP1 = 1UL<<6, // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXREP = 1UL<<5, // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXPER = 1UL<<4, // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCNT = 1UL<<3, // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXDIER = 1UL<<2, // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTXUPR_TIMXICR = 1UL<<1, // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTXUPR_TIMXCR = 1UL<<0, // HRTIM_TIMxCR register update enable		
};

/* High Resolution Timer: Master Timers */
struct HRTIM_Master_Type {
	__IO uint32_t MCR; // @0 Master Timer Control Register
	__I uint8_t MISR; // @4 Master Timer Interrupt Status Register
	 uint8_t RESERVED0[3]; // @5 
	__O uint8_t MICR; // @8 Master Timer Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t MDIER4; // @12 MDIER4
	__IO uint16_t MCNTR; // @16 Master Timer Counter Register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint16_t MPER; // @20 Master Timer Period Register
	 uint8_t RESERVED3[2]; // @22 
	__IO uint8_t MREP; // @24 Master Timer Repetition Register
	 uint8_t RESERVED4[3]; // @25 
	__IO uint16_t MCMP1R; // @28 Master Timer Compare 1 Register
	 uint8_t RESERVED5[6]; // @30 
	__IO uint16_t MCMP2R; // @36 Master Timer Compare 2 Register
	 uint8_t RESERVED6[2]; // @38 
	__IO uint16_t MCMP3R; // @40 Master Timer Compare 3 Register
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t MCMP4R; // @44 Master Timer Compare 4 Register
};

// HRTIM_Master->MCR Master Timer Control Register
enum {
	HRTIM_MASTER_MCR_BRSTDMA = ((1UL<<2)-1) << 30, // Burst DMA Update
	HRTIM_MASTER_MCR_MREPU = 1UL<<29, // Master Timer Repetition update
	HRTIM_MASTER_MCR_PREEN = 1UL<<27, // Preload enable
	HRTIM_MASTER_MCR_DACSYNC = ((1UL<<2)-1) << 25, // AC Synchronization
	HRTIM_MASTER_MCR_TECEN = 1UL<<21, // Timer E counter enable
	HRTIM_MASTER_MCR_TDCEN = 1UL<<20, // Timer D counter enable
	HRTIM_MASTER_MCR_TCCEN = 1UL<<19, // Timer C counter enable
	HRTIM_MASTER_MCR_TBCEN = 1UL<<18, // Timer B counter enable
	HRTIM_MASTER_MCR_TACEN = 1UL<<17, // Timer A counter enable
	HRTIM_MASTER_MCR_MCEN = 1UL<<16, // Master Counter enable
	HRTIM_MASTER_MCR_SYNC_SRC = ((1UL<<2)-1) << 14, // Synchronization source
	HRTIM_MASTER_MCR_SYNC_OUT = ((1UL<<2)-1) << 12, // Synchronization output
	HRTIM_MASTER_MCR_SYNCSTRTM = 1UL<<11, // Synchronization Starts Master
	HRTIM_MASTER_MCR_SYNCRSTM = 1UL<<10, // Synchronization Resets Master
	HRTIM_MASTER_MCR_SYNC_IN = ((1UL<<2)-1) << 8, // ynchronization input
	HRTIM_MASTER_MCR_HALF = 1UL<<5, // Half mode enable
	HRTIM_MASTER_MCR_RETRIG = 1UL<<4, // Master Re-triggerable mode
	HRTIM_MASTER_MCR_CONT = 1UL<<3, // Master Continuous mode
	HRTIM_MASTER_MCR_CK_PSC = ((1UL<<3)-1) << 0, // HRTIM Master Clock prescaler		
};
inline void hrtim_master_mcr_set_brstdma(struct HRTIM_Master_Type* p, uint32_t val) { p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_BRSTDMA) | ((val<<30) & HRTIM_MASTER_MCR_BRSTDMA); }
inline void hrtim_master_mcr_set_dacsync(struct HRTIM_Master_Type* p, uint32_t val) { p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_DACSYNC) | ((val<<25) & HRTIM_MASTER_MCR_DACSYNC); }
inline void hrtim_master_mcr_set_sync_src(struct HRTIM_Master_Type* p, uint32_t val) { p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_SYNC_SRC) | ((val<<14) & HRTIM_MASTER_MCR_SYNC_SRC); }
inline void hrtim_master_mcr_set_sync_out(struct HRTIM_Master_Type* p, uint32_t val) { p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_SYNC_OUT) | ((val<<12) & HRTIM_MASTER_MCR_SYNC_OUT); }
inline void hrtim_master_mcr_set_sync_in(struct HRTIM_Master_Type* p, uint32_t val) { p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_SYNC_IN) | ((val<<8) & HRTIM_MASTER_MCR_SYNC_IN); }
inline void hrtim_master_mcr_set_ck_psc(struct HRTIM_Master_Type* p, uint32_t val) { p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_CK_PSC) | ((val<<0) & HRTIM_MASTER_MCR_CK_PSC); }
inline uint32_t hrtim_master_mcr_get_brstdma(struct HRTIM_Master_Type* p) { return (p->MCR & HRTIM_MASTER_MCR_BRSTDMA) >> 30 ; }
inline uint32_t hrtim_master_mcr_get_dacsync(struct HRTIM_Master_Type* p) { return (p->MCR & HRTIM_MASTER_MCR_DACSYNC) >> 25 ; }
inline uint32_t hrtim_master_mcr_get_sync_src(struct HRTIM_Master_Type* p) { return (p->MCR & HRTIM_MASTER_MCR_SYNC_SRC) >> 14 ; }
inline uint32_t hrtim_master_mcr_get_sync_out(struct HRTIM_Master_Type* p) { return (p->MCR & HRTIM_MASTER_MCR_SYNC_OUT) >> 12 ; }
inline uint32_t hrtim_master_mcr_get_sync_in(struct HRTIM_Master_Type* p) { return (p->MCR & HRTIM_MASTER_MCR_SYNC_IN) >> 8 ; }
inline uint32_t hrtim_master_mcr_get_ck_psc(struct HRTIM_Master_Type* p) { return (p->MCR & HRTIM_MASTER_MCR_CK_PSC) >> 0 ; }

// HRTIM_Master->MISR Master Timer Interrupt Status Register
enum {
	HRTIM_MASTER_MISR_MUPD = 1UL<<6, // Master Update Interrupt Flag
	HRTIM_MASTER_MISR_SYNC = 1UL<<5, // Sync Input Interrupt Flag
	HRTIM_MASTER_MISR_MREP = 1UL<<4, // Master Repetition Interrupt Flag
	HRTIM_MASTER_MISR_MCMP4 = 1UL<<3, // Master Compare 4 Interrupt Flag
	HRTIM_MASTER_MISR_MCMP3 = 1UL<<2, // Master Compare 3 Interrupt Flag
	HRTIM_MASTER_MISR_MCMP2 = 1UL<<1, // Master Compare 2 Interrupt Flag
	HRTIM_MASTER_MISR_MCMP1 = 1UL<<0, // Master Compare 1 Interrupt Flag		
};

// HRTIM_Master->MICR Master Timer Interrupt Clear Register
enum {
	HRTIM_MASTER_MICR_MUPDC = 1UL<<6, // Master update Interrupt flag clear
	HRTIM_MASTER_MICR_SYNCC = 1UL<<5, // Sync Input Interrupt flag clear
	HRTIM_MASTER_MICR_MREPC = 1UL<<4, // Repetition Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP4C = 1UL<<3, // Master Compare 4 Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP3C = 1UL<<2, // Master Compare 3 Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP2C = 1UL<<1, // Master Compare 2 Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP1C = 1UL<<0, // Master Compare 1 Interrupt flag clear		
};

// HRTIM_Master->MDIER4 MDIER4
enum {
	HRTIM_MASTER_MDIER4_MUPDDE = 1UL<<22, // MUPDDE
	HRTIM_MASTER_MDIER4_SYNCDE = 1UL<<21, // SYNCDE
	HRTIM_MASTER_MDIER4_MREPDE = 1UL<<20, // MREPDE
	HRTIM_MASTER_MDIER4_MCMP4DE = 1UL<<19, // MCMP4DE
	HRTIM_MASTER_MDIER4_MCMP3DE = 1UL<<18, // MCMP3DE
	HRTIM_MASTER_MDIER4_MCMP2DE = 1UL<<17, // MCMP2DE
	HRTIM_MASTER_MDIER4_MCMP1DE = 1UL<<16, // MCMP1DE
	HRTIM_MASTER_MDIER4_MUPDIE = 1UL<<6, // MUPDIE
	HRTIM_MASTER_MDIER4_SYNCIE = 1UL<<5, // SYNCIE
	HRTIM_MASTER_MDIER4_MREPIE = 1UL<<4, // MREPIE
	HRTIM_MASTER_MDIER4_MCMP4IE = 1UL<<3, // MCMP4IE
	HRTIM_MASTER_MDIER4_MCMP3IE = 1UL<<2, // MCMP3IE
	HRTIM_MASTER_MDIER4_MCMP2IE = 1UL<<1, // MCMP2IE
	HRTIM_MASTER_MDIER4_MCMP1IE = 1UL<<0, // MCMP1IE		
};

/* High Resolution Timer: TIMA */
struct HRTIM_TIMA_Type {
	__IO uint32_t TIMACR; // @0 Timerx Control Register
	__I uint32_t TIMAISR; // @4 Timerx Interrupt Status Register
	__O uint16_t TIMAICR; // @8 Timerx Interrupt Clear Register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t TIMADIER5; // @12 TIMxDIER5
	__IO uint16_t CNTAR; // @16 Timerx Counter Register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t PERAR; // @20 Timerx Period Register
	 uint8_t RESERVED2[2]; // @22 
	__IO uint8_t REPAR; // @24 Timerx Repetition Register
	 uint8_t RESERVED3[3]; // @25 
	__IO uint16_t CMP1AR; // @28 Timerx Compare 1 Register
	 uint8_t RESERVED4[2]; // @30 
	__IO uint32_t CMP1CAR; // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2AR; // @36 Timerx Compare 2 Register
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t CMP3AR; // @40 Timerx Compare 3 Register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t CMP4AR; // @44 Timerx Compare 4 Register
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t CPT1AR; // @48 Timerx Capture 1 Register
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t CPT2AR; // @52 Timerx Capture 2 Register
	 uint8_t RESERVED9[2]; // @54 
	__IO uint32_t DTAR; // @56 Timerx Deadtime Register
	__IO uint32_t SETA1R; // @60 Timerx Output1 Set Register
	__IO uint32_t RSTA1R; // @64 Timerx Output1 Reset Register
	__IO uint32_t SETA2R; // @68 Timerx Output2 Set Register
	__IO uint32_t RSTA2R; // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFAR1; // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFAR2; // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTAR; // @84 TimerA Reset Register
	__IO uint16_t CHPAR; // @88 Timerx Chopper Register
	 uint8_t RESERVED10[2]; // @90 
	__IO uint32_t CPT1ACR; // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2ACR; // @96 CPT2xCR
	__IO uint32_t OUTAR; // @100 Timerx Output Register
	__IO uint32_t FLTAR; // @104 Timerx Fault Register
};

// HRTIM_TIMA->TIMACR Timerx Control Register
enum {
	HRTIM_TIMA_TIMACR_UPDGAT = ((1UL<<4)-1) << 28, // Update Gating
	HRTIM_TIMA_TIMACR_PREEN = 1UL<<27, // Preload enable
	HRTIM_TIMA_TIMACR_DACSYNC = ((1UL<<2)-1) << 25, // AC Synchronization
	HRTIM_TIMA_TIMACR_MSTU = 1UL<<24, // Master Timer update
	HRTIM_TIMA_TIMACR_TEU = 1UL<<23, // TEU
	HRTIM_TIMA_TIMACR_TDU = 1UL<<22, // TDU
	HRTIM_TIMA_TIMACR_TCU = 1UL<<21, // TCU
	HRTIM_TIMA_TIMACR_TBU = 1UL<<20, // TBU
	HRTIM_TIMA_TIMACR_TXRSTU = 1UL<<18, // Timerx reset update
	HRTIM_TIMA_TIMACR_TXREPU = 1UL<<17, // Timer x Repetition update
	HRTIM_TIMA_TIMACR_DELCMP4 = ((1UL<<2)-1) << 14, // Delayed CMP4 mode
	HRTIM_TIMA_TIMACR_DELCMP2 = ((1UL<<2)-1) << 12, // Delayed CMP2 mode
	HRTIM_TIMA_TIMACR_SYNCSTRTX = 1UL<<11, // Synchronization Starts Timer x
	HRTIM_TIMA_TIMACR_SYNCRSTX = 1UL<<10, // Synchronization Resets Timer x
	HRTIM_TIMA_TIMACR_PSHPLL = 1UL<<6, // Push-Pull mode enable
	HRTIM_TIMA_TIMACR_HALF = 1UL<<5, // Half mode enable
	HRTIM_TIMA_TIMACR_RETRIG = 1UL<<4, // Re-triggerable mode
	HRTIM_TIMA_TIMACR_CONT = 1UL<<3, // Continuous mode
	HRTIM_TIMA_TIMACR_CK_PSCX = ((1UL<<3)-1) << 0, // HRTIM Timer x Clock prescaler		
};
inline void hrtim_tima_timacr_set_updgat(struct HRTIM_TIMA_Type* p, uint32_t val) { p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_UPDGAT) | ((val<<28) & HRTIM_TIMA_TIMACR_UPDGAT); }
inline void hrtim_tima_timacr_set_dacsync(struct HRTIM_TIMA_Type* p, uint32_t val) { p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_DACSYNC) | ((val<<25) & HRTIM_TIMA_TIMACR_DACSYNC); }
inline void hrtim_tima_timacr_set_delcmp4(struct HRTIM_TIMA_Type* p, uint32_t val) { p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_DELCMP4) | ((val<<14) & HRTIM_TIMA_TIMACR_DELCMP4); }
inline void hrtim_tima_timacr_set_delcmp2(struct HRTIM_TIMA_Type* p, uint32_t val) { p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_DELCMP2) | ((val<<12) & HRTIM_TIMA_TIMACR_DELCMP2); }
inline void hrtim_tima_timacr_set_ck_pscx(struct HRTIM_TIMA_Type* p, uint32_t val) { p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_CK_PSCX) | ((val<<0) & HRTIM_TIMA_TIMACR_CK_PSCX); }
inline uint32_t hrtim_tima_timacr_get_updgat(struct HRTIM_TIMA_Type* p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_UPDGAT) >> 28 ; }
inline uint32_t hrtim_tima_timacr_get_dacsync(struct HRTIM_TIMA_Type* p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_DACSYNC) >> 25 ; }
inline uint32_t hrtim_tima_timacr_get_delcmp4(struct HRTIM_TIMA_Type* p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_DELCMP4) >> 14 ; }
inline uint32_t hrtim_tima_timacr_get_delcmp2(struct HRTIM_TIMA_Type* p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_DELCMP2) >> 12 ; }
inline uint32_t hrtim_tima_timacr_get_ck_pscx(struct HRTIM_TIMA_Type* p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_CK_PSCX) >> 0 ; }

// HRTIM_TIMA->TIMAISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMA_TIMAISR_O2STAT = 1UL<<19, // Output 2 State
	HRTIM_TIMA_TIMAISR_O1STAT = 1UL<<18, // Output 1 State
	HRTIM_TIMA_TIMAISR_IPPSTAT = 1UL<<17, // Idle Push Pull Status
	HRTIM_TIMA_TIMAISR_CPPSTAT = 1UL<<16, // Current Push Pull Status
	HRTIM_TIMA_TIMAISR_DLYPRT = 1UL<<14, // Delayed Protection Flag
	HRTIM_TIMA_TIMAISR_RST = 1UL<<13, // Reset Interrupt Flag
	HRTIM_TIMA_TIMAISR_RSTX2 = 1UL<<12, // Output 2 Reset Interrupt Flag
	HRTIM_TIMA_TIMAISR_SETX2 = 1UL<<11, // Output 2 Set Interrupt Flag
	HRTIM_TIMA_TIMAISR_RSTX1 = 1UL<<10, // Output 1 Reset Interrupt Flag
	HRTIM_TIMA_TIMAISR_SETX1 = 1UL<<9, // Output 1 Set Interrupt Flag
	HRTIM_TIMA_TIMAISR_CPT2 = 1UL<<8, // Capture2 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CPT1 = 1UL<<7, // Capture1 Interrupt Flag
	HRTIM_TIMA_TIMAISR_UPD = 1UL<<6, // Update Interrupt Flag
	HRTIM_TIMA_TIMAISR_REP = 1UL<<4, // Repetition Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP4 = 1UL<<3, // Compare 4 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP3 = 1UL<<2, // Compare 3 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP2 = 1UL<<1, // Compare 2 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP1 = 1UL<<0, // Compare 1 Interrupt Flag		
};

// HRTIM_TIMA->TIMAICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMA_TIMAICR_DLYPRTC = 1UL<<14, // Delayed Protection Flag Clear
	HRTIM_TIMA_TIMAICR_RSTC = 1UL<<13, // Reset Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_RSTX2C = 1UL<<12, // Output 2 Reset flag Clear
	HRTIM_TIMA_TIMAICR_SET2XC = 1UL<<11, // Output 2 Set flag Clear
	HRTIM_TIMA_TIMAICR_RSTX1C = 1UL<<10, // Output 1 Reset flag Clear
	HRTIM_TIMA_TIMAICR_SET1XC = 1UL<<9, // Output 1 Set flag Clear
	HRTIM_TIMA_TIMAICR_CPT2C = 1UL<<8, // Capture2 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CPT1C = 1UL<<7, // Capture1 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_UPDC = 1UL<<6, // Update Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_REPC = 1UL<<4, // Repetition Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP4C = 1UL<<3, // Compare 4 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP3C = 1UL<<2, // Compare 3 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP2C = 1UL<<1, // Compare 2 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP1C = 1UL<<0, // Compare 1 Interrupt flag Clear		
};

// HRTIM_TIMA->TIMADIER5 TIMxDIER5
enum {
	HRTIM_TIMA_TIMADIER5_DLYPRTDE = 1UL<<30, // DLYPRTDE
	HRTIM_TIMA_TIMADIER5_RSTDE = 1UL<<29, // RSTDE
	HRTIM_TIMA_TIMADIER5_RSTX2DE = 1UL<<28, // RSTx2DE
	HRTIM_TIMA_TIMADIER5_SETX2DE = 1UL<<27, // SETx2DE
	HRTIM_TIMA_TIMADIER5_RSTX1DE = 1UL<<26, // RSTx1DE
	HRTIM_TIMA_TIMADIER5_SET1XDE = 1UL<<25, // SET1xDE
	HRTIM_TIMA_TIMADIER5_CPT2DE = 1UL<<24, // CPT2DE
	HRTIM_TIMA_TIMADIER5_CPT1DE = 1UL<<23, // CPT1DE
	HRTIM_TIMA_TIMADIER5_UPDDE = 1UL<<22, // UPDDE
	HRTIM_TIMA_TIMADIER5_REPDE = 1UL<<20, // REPDE
	HRTIM_TIMA_TIMADIER5_CMP4DE = 1UL<<19, // CMP4DE
	HRTIM_TIMA_TIMADIER5_CMP3DE = 1UL<<18, // CMP3DE
	HRTIM_TIMA_TIMADIER5_CMP2DE = 1UL<<17, // CMP2DE
	HRTIM_TIMA_TIMADIER5_CMP1DE = 1UL<<16, // CMP1DE
	HRTIM_TIMA_TIMADIER5_DLYPRTIE = 1UL<<14, // DLYPRTIE
	HRTIM_TIMA_TIMADIER5_RSTIE = 1UL<<13, // RSTIE
	HRTIM_TIMA_TIMADIER5_RSTX2IE = 1UL<<12, // RSTx2IE
	HRTIM_TIMA_TIMADIER5_SETX2IE = 1UL<<11, // SETx2IE
	HRTIM_TIMA_TIMADIER5_RSTX1IE = 1UL<<10, // RSTx1IE
	HRTIM_TIMA_TIMADIER5_SET1XIE = 1UL<<9, // SET1xIE
	HRTIM_TIMA_TIMADIER5_CPT2IE = 1UL<<8, // CPT2IE
	HRTIM_TIMA_TIMADIER5_CPT1IE = 1UL<<7, // CPT1IE
	HRTIM_TIMA_TIMADIER5_UPDIE = 1UL<<6, // UPDIE
	HRTIM_TIMA_TIMADIER5_REPIE = 1UL<<4, // REPIE
	HRTIM_TIMA_TIMADIER5_CMP4IE = 1UL<<3, // CMP4IE
	HRTIM_TIMA_TIMADIER5_CMP3IE = 1UL<<2, // CMP3IE
	HRTIM_TIMA_TIMADIER5_CMP2IE = 1UL<<1, // CMP2IE
	HRTIM_TIMA_TIMADIER5_CMP1IE = 1UL<<0, // CMP1IE		
};

// HRTIM_TIMA->CMP1CAR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMA_CMP1CAR_REPX = ((1UL<<8)-1) << 16, // Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMA_CMP1CAR_CMP1X = ((1UL<<16)-1) << 0, // Timerx Compare 1 value		
};
inline void hrtim_tima_cmp1car_set_repx(struct HRTIM_TIMA_Type* p, uint32_t val) { p->CMP1CAR = (p->CMP1CAR & ~HRTIM_TIMA_CMP1CAR_REPX) | ((val<<16) & HRTIM_TIMA_CMP1CAR_REPX); }
inline void hrtim_tima_cmp1car_set_cmp1x(struct HRTIM_TIMA_Type* p, uint32_t val) { p->CMP1CAR = (p->CMP1CAR & ~HRTIM_TIMA_CMP1CAR_CMP1X) | ((val<<0) & HRTIM_TIMA_CMP1CAR_CMP1X); }
inline uint32_t hrtim_tima_cmp1car_get_repx(struct HRTIM_TIMA_Type* p) { return (p->CMP1CAR & HRTIM_TIMA_CMP1CAR_REPX) >> 16 ; }
inline uint32_t hrtim_tima_cmp1car_get_cmp1x(struct HRTIM_TIMA_Type* p) { return (p->CMP1CAR & HRTIM_TIMA_CMP1CAR_CMP1X) >> 0 ; }

// HRTIM_TIMA->DTAR Timerx Deadtime Register
enum {
	HRTIM_TIMA_DTAR_DTFLKX = 1UL<<31, // Deadtime Falling Lock
	HRTIM_TIMA_DTAR_DTFSLKX = 1UL<<30, // Deadtime Falling Sign Lock
	HRTIM_TIMA_DTAR_SDTFX = 1UL<<25, // Sign Deadtime Falling value
	HRTIM_TIMA_DTAR_DTFX = ((1UL<<9)-1) << 16, // Deadtime Falling value
	HRTIM_TIMA_DTAR_DTRLKX = 1UL<<15, // Deadtime Rising Lock
	HRTIM_TIMA_DTAR_DTRSLKX = 1UL<<14, // Deadtime Rising Sign Lock
	HRTIM_TIMA_DTAR_DTPRSC = ((1UL<<3)-1) << 10, // Deadtime Prescaler
	HRTIM_TIMA_DTAR_SDTRX = 1UL<<9, // Sign Deadtime Rising value
	HRTIM_TIMA_DTAR_DTRX = ((1UL<<9)-1) << 0, // Deadtime Rising value		
};
inline void hrtim_tima_dtar_set_dtfx(struct HRTIM_TIMA_Type* p, uint32_t val) { p->DTAR = (p->DTAR & ~HRTIM_TIMA_DTAR_DTFX) | ((val<<16) & HRTIM_TIMA_DTAR_DTFX); }
inline void hrtim_tima_dtar_set_dtprsc(struct HRTIM_TIMA_Type* p, uint32_t val) { p->DTAR = (p->DTAR & ~HRTIM_TIMA_DTAR_DTPRSC) | ((val<<10) & HRTIM_TIMA_DTAR_DTPRSC); }
inline void hrtim_tima_dtar_set_dtrx(struct HRTIM_TIMA_Type* p, uint32_t val) { p->DTAR = (p->DTAR & ~HRTIM_TIMA_DTAR_DTRX) | ((val<<0) & HRTIM_TIMA_DTAR_DTRX); }
inline uint32_t hrtim_tima_dtar_get_dtfx(struct HRTIM_TIMA_Type* p) { return (p->DTAR & HRTIM_TIMA_DTAR_DTFX) >> 16 ; }
inline uint32_t hrtim_tima_dtar_get_dtprsc(struct HRTIM_TIMA_Type* p) { return (p->DTAR & HRTIM_TIMA_DTAR_DTPRSC) >> 10 ; }
inline uint32_t hrtim_tima_dtar_get_dtrx(struct HRTIM_TIMA_Type* p) { return (p->DTAR & HRTIM_TIMA_DTAR_DTRX) >> 0 ; }

// HRTIM_TIMA->SETA1R Timerx Output1 Set Register
enum {
	HRTIM_TIMA_SETA1R_UPDATE = 1UL<<31, // Registers update (transfer preload to active)
	HRTIM_TIMA_SETA1R_EXTEVNT10 = 1UL<<30, // External Event 10
	HRTIM_TIMA_SETA1R_EXTEVNT9 = 1UL<<29, // External Event 9
	HRTIM_TIMA_SETA1R_EXTEVNT8 = 1UL<<28, // External Event 8
	HRTIM_TIMA_SETA1R_EXTEVNT7 = 1UL<<27, // External Event 7
	HRTIM_TIMA_SETA1R_EXTEVNT6 = 1UL<<26, // External Event 6
	HRTIM_TIMA_SETA1R_EXTEVNT5 = 1UL<<25, // External Event 5
	HRTIM_TIMA_SETA1R_EXTEVNT4 = 1UL<<24, // External Event 4
	HRTIM_TIMA_SETA1R_EXTEVNT3 = 1UL<<23, // External Event 3
	HRTIM_TIMA_SETA1R_EXTEVNT2 = 1UL<<22, // External Event 2
	HRTIM_TIMA_SETA1R_EXTEVNT1 = 1UL<<21, // External Event 1
	HRTIM_TIMA_SETA1R_TIMEVNT9 = 1UL<<20, // Timer Event 9
	HRTIM_TIMA_SETA1R_TIMEVNT8 = 1UL<<19, // Timer Event 8
	HRTIM_TIMA_SETA1R_TIMEVNT7 = 1UL<<18, // Timer Event 7
	HRTIM_TIMA_SETA1R_TIMEVNT6 = 1UL<<17, // Timer Event 6
	HRTIM_TIMA_SETA1R_TIMEVNT5 = 1UL<<16, // Timer Event 5
	HRTIM_TIMA_SETA1R_TIMEVNT4 = 1UL<<15, // Timer Event 4
	HRTIM_TIMA_SETA1R_TIMEVNT3 = 1UL<<14, // Timer Event 3
	HRTIM_TIMA_SETA1R_TIMEVNT2 = 1UL<<13, // Timer Event 2
	HRTIM_TIMA_SETA1R_TIMEVNT1 = 1UL<<12, // Timer Event 1
	HRTIM_TIMA_SETA1R_MSTCMP4 = 1UL<<11, // Master Compare 4
	HRTIM_TIMA_SETA1R_MSTCMP3 = 1UL<<10, // Master Compare 3
	HRTIM_TIMA_SETA1R_MSTCMP2 = 1UL<<9, // Master Compare 2
	HRTIM_TIMA_SETA1R_MSTCMP1 = 1UL<<8, // Master Compare 1
	HRTIM_TIMA_SETA1R_MSTPER = 1UL<<7, // Master Period
	HRTIM_TIMA_SETA1R_CMP4 = 1UL<<6, // Timer A compare 4
	HRTIM_TIMA_SETA1R_CMP3 = 1UL<<5, // Timer A compare 3
	HRTIM_TIMA_SETA1R_CMP2 = 1UL<<4, // Timer A compare 2
	HRTIM_TIMA_SETA1R_CMP1 = 1UL<<3, // Timer A compare 1
	HRTIM_TIMA_SETA1R_PER = 1UL<<2, // Timer A Period
	HRTIM_TIMA_SETA1R_RESYNC = 1UL<<1, // Timer A resynchronizaton
	HRTIM_TIMA_SETA1R_SST = 1UL<<0, // Software Set trigger		
};

// HRTIM_TIMA->RSTA1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMA_RSTA1R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMA_RSTA1R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMA_RSTA1R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMA_RSTA1R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMA_RSTA1R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMA_RSTA1R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMA_RSTA1R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMA_RSTA1R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMA_RSTA1R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMA_RSTA1R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMA_RSTA1R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMA_RSTA1R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMA_RSTA1R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMA_RSTA1R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMA_RSTA1R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMA_RSTA1R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMA_RSTA1R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMA_RSTA1R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMA_RSTA1R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMA_RSTA1R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMA_RSTA1R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMA_RSTA1R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMA_RSTA1R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMA_RSTA1R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMA_RSTA1R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMA_RSTA1R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMA_RSTA1R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMA_RSTA1R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMA_RSTA1R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMA_RSTA1R_PER = 1UL<<2, // PER
	HRTIM_TIMA_RSTA1R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMA_RSTA1R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMA->SETA2R Timerx Output2 Set Register
enum {
	HRTIM_TIMA_SETA2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMA_SETA2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMA_SETA2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMA_SETA2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMA_SETA2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMA_SETA2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMA_SETA2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMA_SETA2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMA_SETA2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMA_SETA2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMA_SETA2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMA_SETA2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMA_SETA2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMA_SETA2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMA_SETA2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMA_SETA2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMA_SETA2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMA_SETA2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMA_SETA2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMA_SETA2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMA_SETA2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMA_SETA2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMA_SETA2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMA_SETA2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMA_SETA2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMA_SETA2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMA_SETA2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMA_SETA2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMA_SETA2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMA_SETA2R_PER = 1UL<<2, // PER
	HRTIM_TIMA_SETA2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMA_SETA2R_SST = 1UL<<0, // SST		
};

// HRTIM_TIMA->RSTA2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMA_RSTA2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMA_RSTA2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMA_RSTA2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMA_RSTA2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMA_RSTA2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMA_RSTA2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMA_RSTA2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMA_RSTA2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMA_RSTA2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMA_RSTA2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMA_RSTA2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMA_RSTA2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMA_RSTA2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMA_RSTA2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMA_RSTA2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMA_RSTA2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMA_RSTA2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMA_RSTA2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMA_RSTA2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMA_RSTA2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMA_RSTA2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMA_RSTA2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMA_RSTA2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMA_RSTA2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMA_RSTA2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMA_RSTA2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMA_RSTA2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMA_RSTA2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMA_RSTA2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMA_RSTA2R_PER = 1UL<<2, // PER
	HRTIM_TIMA_RSTA2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMA_RSTA2R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMA->EEFAR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMA_EEFAR1_EE5FLTR = ((1UL<<4)-1) << 25, // External Event 5 filter
	HRTIM_TIMA_EEFAR1_EE5LTCH = 1UL<<24, // External Event 5 latch
	HRTIM_TIMA_EEFAR1_EE4FLTR = ((1UL<<4)-1) << 19, // External Event 4 filter
	HRTIM_TIMA_EEFAR1_EE4LTCH = 1UL<<18, // External Event 4 latch
	HRTIM_TIMA_EEFAR1_EE3FLTR = ((1UL<<4)-1) << 13, // External Event 3 filter
	HRTIM_TIMA_EEFAR1_EE3LTCH = 1UL<<12, // External Event 3 latch
	HRTIM_TIMA_EEFAR1_EE2FLTR = ((1UL<<4)-1) << 7, // External Event 2 filter
	HRTIM_TIMA_EEFAR1_EE2LTCH = 1UL<<6, // External Event 2 latch
	HRTIM_TIMA_EEFAR1_EE1FLTR = ((1UL<<4)-1) << 1, // External Event 1 filter
	HRTIM_TIMA_EEFAR1_EE1LTCH = 1UL<<0, // External Event 1 latch		
};
inline void hrtim_tima_eefar1_set_ee5fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE5FLTR) | ((val<<25) & HRTIM_TIMA_EEFAR1_EE5FLTR); }
inline void hrtim_tima_eefar1_set_ee4fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE4FLTR) | ((val<<19) & HRTIM_TIMA_EEFAR1_EE4FLTR); }
inline void hrtim_tima_eefar1_set_ee3fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE3FLTR) | ((val<<13) & HRTIM_TIMA_EEFAR1_EE3FLTR); }
inline void hrtim_tima_eefar1_set_ee2fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE2FLTR) | ((val<<7) & HRTIM_TIMA_EEFAR1_EE2FLTR); }
inline void hrtim_tima_eefar1_set_ee1fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE1FLTR) | ((val<<1) & HRTIM_TIMA_EEFAR1_EE1FLTR); }
inline uint32_t hrtim_tima_eefar1_get_ee5fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE5FLTR) >> 25 ; }
inline uint32_t hrtim_tima_eefar1_get_ee4fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE4FLTR) >> 19 ; }
inline uint32_t hrtim_tima_eefar1_get_ee3fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE3FLTR) >> 13 ; }
inline uint32_t hrtim_tima_eefar1_get_ee2fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE2FLTR) >> 7 ; }
inline uint32_t hrtim_tima_eefar1_get_ee1fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE1FLTR) >> 1 ; }

// HRTIM_TIMA->EEFAR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMA_EEFAR2_EE10FLTR = ((1UL<<4)-1) << 25, // External Event 10 filter
	HRTIM_TIMA_EEFAR2_EE10LTCH = 1UL<<24, // External Event 10 latch
	HRTIM_TIMA_EEFAR2_EE9FLTR = ((1UL<<4)-1) << 19, // External Event 9 filter
	HRTIM_TIMA_EEFAR2_EE9LTCH = 1UL<<18, // External Event 9 latch
	HRTIM_TIMA_EEFAR2_EE8FLTR = ((1UL<<4)-1) << 13, // External Event 8 filter
	HRTIM_TIMA_EEFAR2_EE8LTCH = 1UL<<12, // External Event 8 latch
	HRTIM_TIMA_EEFAR2_EE7FLTR = ((1UL<<4)-1) << 7, // External Event 7 filter
	HRTIM_TIMA_EEFAR2_EE7LTCH = 1UL<<6, // External Event 7 latch
	HRTIM_TIMA_EEFAR2_EE6FLTR = ((1UL<<4)-1) << 1, // External Event 6 filter
	HRTIM_TIMA_EEFAR2_EE6LTCH = 1UL<<0, // External Event 6 latch		
};
inline void hrtim_tima_eefar2_set_ee10fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE10FLTR) | ((val<<25) & HRTIM_TIMA_EEFAR2_EE10FLTR); }
inline void hrtim_tima_eefar2_set_ee9fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE9FLTR) | ((val<<19) & HRTIM_TIMA_EEFAR2_EE9FLTR); }
inline void hrtim_tima_eefar2_set_ee8fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE8FLTR) | ((val<<13) & HRTIM_TIMA_EEFAR2_EE8FLTR); }
inline void hrtim_tima_eefar2_set_ee7fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE7FLTR) | ((val<<7) & HRTIM_TIMA_EEFAR2_EE7FLTR); }
inline void hrtim_tima_eefar2_set_ee6fltr(struct HRTIM_TIMA_Type* p, uint32_t val) { p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE6FLTR) | ((val<<1) & HRTIM_TIMA_EEFAR2_EE6FLTR); }
inline uint32_t hrtim_tima_eefar2_get_ee10fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE10FLTR) >> 25 ; }
inline uint32_t hrtim_tima_eefar2_get_ee9fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE9FLTR) >> 19 ; }
inline uint32_t hrtim_tima_eefar2_get_ee8fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE8FLTR) >> 13 ; }
inline uint32_t hrtim_tima_eefar2_get_ee7fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE7FLTR) >> 7 ; }
inline uint32_t hrtim_tima_eefar2_get_ee6fltr(struct HRTIM_TIMA_Type* p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE6FLTR) >> 1 ; }

// HRTIM_TIMA->RSTAR TimerA Reset Register
enum {
	HRTIM_TIMA_RSTAR_TIMECMP4 = 1UL<<30, // Timer E Compare 4
	HRTIM_TIMA_RSTAR_TIMECMP2 = 1UL<<29, // Timer E Compare 2
	HRTIM_TIMA_RSTAR_TIMECMP1 = 1UL<<28, // Timer E Compare 1
	HRTIM_TIMA_RSTAR_TIMDCMP4 = 1UL<<27, // Timer D Compare 4
	HRTIM_TIMA_RSTAR_TIMDCMP2 = 1UL<<26, // Timer D Compare 2
	HRTIM_TIMA_RSTAR_TIMDCMP1 = 1UL<<25, // Timer D Compare 1
	HRTIM_TIMA_RSTAR_TIMCCMP4 = 1UL<<24, // Timer C Compare 4
	HRTIM_TIMA_RSTAR_TIMCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMA_RSTAR_TIMCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMA_RSTAR_TIMBCMP4 = 1UL<<21, // Timer B Compare 4
	HRTIM_TIMA_RSTAR_TIMBCMP2 = 1UL<<20, // Timer B Compare 2
	HRTIM_TIMA_RSTAR_TIMBCMP1 = 1UL<<19, // Timer B Compare 1
	HRTIM_TIMA_RSTAR_EXTEVNT10 = 1UL<<18, // External Event 10
	HRTIM_TIMA_RSTAR_EXTEVNT9 = 1UL<<17, // External Event 9
	HRTIM_TIMA_RSTAR_EXTEVNT8 = 1UL<<16, // External Event 8
	HRTIM_TIMA_RSTAR_EXTEVNT7 = 1UL<<15, // External Event 7
	HRTIM_TIMA_RSTAR_EXTEVNT6 = 1UL<<14, // External Event 6
	HRTIM_TIMA_RSTAR_EXTEVNT5 = 1UL<<13, // External Event 5
	HRTIM_TIMA_RSTAR_EXTEVNT4 = 1UL<<12, // External Event 4
	HRTIM_TIMA_RSTAR_EXTEVNT3 = 1UL<<11, // External Event 3
	HRTIM_TIMA_RSTAR_EXTEVNT2 = 1UL<<10, // External Event 2
	HRTIM_TIMA_RSTAR_EXTEVNT1 = 1UL<<9, // External Event 1
	HRTIM_TIMA_RSTAR_MSTCMP4 = 1UL<<8, // Master compare 4
	HRTIM_TIMA_RSTAR_MSTCMP3 = 1UL<<7, // Master compare 3
	HRTIM_TIMA_RSTAR_MSTCMP2 = 1UL<<6, // Master compare 2
	HRTIM_TIMA_RSTAR_MSTCMP1 = 1UL<<5, // Master compare 1
	HRTIM_TIMA_RSTAR_MSTPER = 1UL<<4, // Master timer Period
	HRTIM_TIMA_RSTAR_CMP4 = 1UL<<3, // Timer A compare 4 reset
	HRTIM_TIMA_RSTAR_CMP2 = 1UL<<2, // Timer A compare 2 reset
	HRTIM_TIMA_RSTAR_UPDT = 1UL<<1, // Timer A Update reset		
};

// HRTIM_TIMA->CHPAR Timerx Chopper Register
enum {
	HRTIM_TIMA_CHPAR_STRTPW = ((1UL<<4)-1) << 7, // STRTPW
	HRTIM_TIMA_CHPAR_CHPDTY = ((1UL<<3)-1) << 4, // Timerx chopper duty cycle value
	HRTIM_TIMA_CHPAR_CHPFRQ = ((1UL<<4)-1) << 0, // Timerx carrier frequency value		
};
inline void hrtim_tima_chpar_set_strtpw(struct HRTIM_TIMA_Type* p, uint32_t val) { p->CHPAR = (p->CHPAR & ~HRTIM_TIMA_CHPAR_STRTPW) | ((val<<7) & HRTIM_TIMA_CHPAR_STRTPW); }
inline void hrtim_tima_chpar_set_chpdty(struct HRTIM_TIMA_Type* p, uint32_t val) { p->CHPAR = (p->CHPAR & ~HRTIM_TIMA_CHPAR_CHPDTY) | ((val<<4) & HRTIM_TIMA_CHPAR_CHPDTY); }
inline void hrtim_tima_chpar_set_chpfrq(struct HRTIM_TIMA_Type* p, uint32_t val) { p->CHPAR = (p->CHPAR & ~HRTIM_TIMA_CHPAR_CHPFRQ) | ((val<<0) & HRTIM_TIMA_CHPAR_CHPFRQ); }
inline uint32_t hrtim_tima_chpar_get_strtpw(struct HRTIM_TIMA_Type* p) { return (p->CHPAR & HRTIM_TIMA_CHPAR_STRTPW) >> 7 ; }
inline uint32_t hrtim_tima_chpar_get_chpdty(struct HRTIM_TIMA_Type* p) { return (p->CHPAR & HRTIM_TIMA_CHPAR_CHPDTY) >> 4 ; }
inline uint32_t hrtim_tima_chpar_get_chpfrq(struct HRTIM_TIMA_Type* p) { return (p->CHPAR & HRTIM_TIMA_CHPAR_CHPFRQ) >> 0 ; }

// HRTIM_TIMA->CPT1ACR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMA_CPT1ACR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMA_CPT1ACR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMA_CPT1ACR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMA_CPT1ACR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMA_CPT1ACR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIMA_CPT1ACR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIMA_CPT1ACR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIMA_CPT1ACR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIMA_CPT1ACR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMA_CPT1ACR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMA_CPT1ACR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIMA_CPT1ACR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIMA_CPT1ACR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIMA_CPT1ACR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIMA_CPT1ACR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIMA_CPT1ACR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIMA_CPT1ACR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMA_CPT1ACR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMA_CPT1ACR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMA_CPT1ACR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMA_CPT1ACR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMA_CPT1ACR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMA_CPT1ACR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMA_CPT1ACR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMA_CPT1ACR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMA_CPT1ACR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMA_CPT1ACR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMA_CPT1ACR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMA->CPT2ACR CPT2xCR
enum {
	HRTIM_TIMA_CPT2ACR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMA_CPT2ACR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMA_CPT2ACR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMA_CPT2ACR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMA_CPT2ACR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIMA_CPT2ACR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIMA_CPT2ACR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIMA_CPT2ACR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIMA_CPT2ACR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMA_CPT2ACR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMA_CPT2ACR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIMA_CPT2ACR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIMA_CPT2ACR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIMA_CPT2ACR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIMA_CPT2ACR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIMA_CPT2ACR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIMA_CPT2ACR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMA_CPT2ACR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMA_CPT2ACR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMA_CPT2ACR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMA_CPT2ACR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMA_CPT2ACR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMA_CPT2ACR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMA_CPT2ACR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMA_CPT2ACR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMA_CPT2ACR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMA_CPT2ACR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMA_CPT2ACR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMA->OUTAR Timerx Output Register
enum {
	HRTIM_TIMA_OUTAR_DIDL2 = 1UL<<23, // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMA_OUTAR_CHP2 = 1UL<<22, // Output 2 Chopper enable
	HRTIM_TIMA_OUTAR_FAULT2 = ((1UL<<2)-1) << 20, // Output 2 Fault state
	HRTIM_TIMA_OUTAR_IDLES2 = 1UL<<19, // Output 2 Idle State
	HRTIM_TIMA_OUTAR_IDLEM2 = 1UL<<18, // Output 2 Idle mode
	HRTIM_TIMA_OUTAR_POL2 = 1UL<<17, // Output 2 polarity
	HRTIM_TIMA_OUTAR_DLYPRT = ((1UL<<3)-1) << 10, // Delayed Protection
	HRTIM_TIMA_OUTAR_DLYPRTEN = 1UL<<9, // Delayed Protection Enable
	HRTIM_TIMA_OUTAR_DTEN = 1UL<<8, // Deadtime enable
	HRTIM_TIMA_OUTAR_DIDL1 = 1UL<<7, // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMA_OUTAR_CHP1 = 1UL<<6, // Output 1 Chopper enable
	HRTIM_TIMA_OUTAR_FAULT1 = ((1UL<<2)-1) << 4, // Output 1 Fault state
	HRTIM_TIMA_OUTAR_IDLES1 = 1UL<<3, // Output 1 Idle State
	HRTIM_TIMA_OUTAR_IDLEM1 = 1UL<<2, // Output 1 Idle mode
	HRTIM_TIMA_OUTAR_POL1 = 1UL<<1, // Output 1 polarity		
};
inline void hrtim_tima_outar_set_fault2(struct HRTIM_TIMA_Type* p, uint32_t val) { p->OUTAR = (p->OUTAR & ~HRTIM_TIMA_OUTAR_FAULT2) | ((val<<20) & HRTIM_TIMA_OUTAR_FAULT2); }
inline void hrtim_tima_outar_set_dlyprt(struct HRTIM_TIMA_Type* p, uint32_t val) { p->OUTAR = (p->OUTAR & ~HRTIM_TIMA_OUTAR_DLYPRT) | ((val<<10) & HRTIM_TIMA_OUTAR_DLYPRT); }
inline void hrtim_tima_outar_set_fault1(struct HRTIM_TIMA_Type* p, uint32_t val) { p->OUTAR = (p->OUTAR & ~HRTIM_TIMA_OUTAR_FAULT1) | ((val<<4) & HRTIM_TIMA_OUTAR_FAULT1); }
inline uint32_t hrtim_tima_outar_get_fault2(struct HRTIM_TIMA_Type* p) { return (p->OUTAR & HRTIM_TIMA_OUTAR_FAULT2) >> 20 ; }
inline uint32_t hrtim_tima_outar_get_dlyprt(struct HRTIM_TIMA_Type* p) { return (p->OUTAR & HRTIM_TIMA_OUTAR_DLYPRT) >> 10 ; }
inline uint32_t hrtim_tima_outar_get_fault1(struct HRTIM_TIMA_Type* p) { return (p->OUTAR & HRTIM_TIMA_OUTAR_FAULT1) >> 4 ; }

// HRTIM_TIMA->FLTAR Timerx Fault Register
enum {
	HRTIM_TIMA_FLTAR_FLTLCK = 1UL<<31, // Fault sources Lock
	HRTIM_TIMA_FLTAR_FLT5EN = 1UL<<4, // Fault 5 enable
	HRTIM_TIMA_FLTAR_FLT4EN = 1UL<<3, // Fault 4 enable
	HRTIM_TIMA_FLTAR_FLT3EN = 1UL<<2, // Fault 3 enable
	HRTIM_TIMA_FLTAR_FLT2EN = 1UL<<1, // Fault 2 enable
	HRTIM_TIMA_FLTAR_FLT1EN = 1UL<<0, // Fault 1 enable		
};

/* High Resolution Timer: TIMB */
struct HRTIM_TIMB_Type {
	__IO uint32_t TIMBCR; // @0 Timerx Control Register
	__I uint32_t TIMBISR; // @4 Timerx Interrupt Status Register
	__O uint16_t TIMBICR; // @8 Timerx Interrupt Clear Register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t TIMBDIER5; // @12 TIMxDIER5
	__IO uint16_t CNTR; // @16 Timerx Counter Register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t PERBR; // @20 Timerx Period Register
	 uint8_t RESERVED2[2]; // @22 
	__IO uint8_t REPBR; // @24 Timerx Repetition Register
	 uint8_t RESERVED3[3]; // @25 
	__IO uint16_t CMP1BR; // @28 Timerx Compare 1 Register
	 uint8_t RESERVED4[2]; // @30 
	__IO uint32_t CMP1CBR; // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2BR; // @36 Timerx Compare 2 Register
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t CMP3BR; // @40 Timerx Compare 3 Register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t CMP4BR; // @44 Timerx Compare 4 Register
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t CPT1BR; // @48 Timerx Capture 1 Register
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t CPT2BR; // @52 Timerx Capture 2 Register
	 uint8_t RESERVED9[2]; // @54 
	__IO uint32_t DTBR; // @56 Timerx Deadtime Register
	__IO uint32_t SETB1R; // @60 Timerx Output1 Set Register
	__IO uint32_t RSTB1R; // @64 Timerx Output1 Reset Register
	__IO uint32_t SETB2R; // @68 Timerx Output2 Set Register
	__IO uint32_t RSTB2R; // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFBR1; // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFBR2; // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTBR; // @84 TimerA Reset Register
	__IO uint16_t CHPBR; // @88 Timerx Chopper Register
	 uint8_t RESERVED10[2]; // @90 
	__IO uint32_t CPT1BCR; // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2BCR; // @96 CPT2xCR
	__IO uint32_t OUTBR; // @100 Timerx Output Register
	__IO uint32_t FLTBR; // @104 Timerx Fault Register
};

// HRTIM_TIMB->TIMBCR Timerx Control Register
enum {
	HRTIM_TIMB_TIMBCR_UPDGAT = ((1UL<<4)-1) << 28, // Update Gating
	HRTIM_TIMB_TIMBCR_PREEN = 1UL<<27, // Preload enable
	HRTIM_TIMB_TIMBCR_DACSYNC = ((1UL<<2)-1) << 25, // AC Synchronization
	HRTIM_TIMB_TIMBCR_MSTU = 1UL<<24, // Master Timer update
	HRTIM_TIMB_TIMBCR_TEU = 1UL<<23, // TEU
	HRTIM_TIMB_TIMBCR_TDU = 1UL<<22, // TDU
	HRTIM_TIMB_TIMBCR_TCU = 1UL<<21, // TCU
	HRTIM_TIMB_TIMBCR_TBU = 1UL<<20, // TBU
	HRTIM_TIMB_TIMBCR_TXRSTU = 1UL<<18, // Timerx reset update
	HRTIM_TIMB_TIMBCR_TXREPU = 1UL<<17, // Timer x Repetition update
	HRTIM_TIMB_TIMBCR_DELCMP4 = ((1UL<<2)-1) << 14, // Delayed CMP4 mode
	HRTIM_TIMB_TIMBCR_DELCMP2 = ((1UL<<2)-1) << 12, // Delayed CMP2 mode
	HRTIM_TIMB_TIMBCR_SYNCSTRTX = 1UL<<11, // Synchronization Starts Timer x
	HRTIM_TIMB_TIMBCR_SYNCRSTX = 1UL<<10, // Synchronization Resets Timer x
	HRTIM_TIMB_TIMBCR_PSHPLL = 1UL<<6, // Push-Pull mode enable
	HRTIM_TIMB_TIMBCR_HALF = 1UL<<5, // Half mode enable
	HRTIM_TIMB_TIMBCR_RETRIG = 1UL<<4, // Re-triggerable mode
	HRTIM_TIMB_TIMBCR_CONT = 1UL<<3, // Continuous mode
	HRTIM_TIMB_TIMBCR_CK_PSCX = ((1UL<<3)-1) << 0, // HRTIM Timer x Clock prescaler		
};
inline void hrtim_timb_timbcr_set_updgat(struct HRTIM_TIMB_Type* p, uint32_t val) { p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_UPDGAT) | ((val<<28) & HRTIM_TIMB_TIMBCR_UPDGAT); }
inline void hrtim_timb_timbcr_set_dacsync(struct HRTIM_TIMB_Type* p, uint32_t val) { p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_DACSYNC) | ((val<<25) & HRTIM_TIMB_TIMBCR_DACSYNC); }
inline void hrtim_timb_timbcr_set_delcmp4(struct HRTIM_TIMB_Type* p, uint32_t val) { p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_DELCMP4) | ((val<<14) & HRTIM_TIMB_TIMBCR_DELCMP4); }
inline void hrtim_timb_timbcr_set_delcmp2(struct HRTIM_TIMB_Type* p, uint32_t val) { p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_DELCMP2) | ((val<<12) & HRTIM_TIMB_TIMBCR_DELCMP2); }
inline void hrtim_timb_timbcr_set_ck_pscx(struct HRTIM_TIMB_Type* p, uint32_t val) { p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_CK_PSCX) | ((val<<0) & HRTIM_TIMB_TIMBCR_CK_PSCX); }
inline uint32_t hrtim_timb_timbcr_get_updgat(struct HRTIM_TIMB_Type* p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_UPDGAT) >> 28 ; }
inline uint32_t hrtim_timb_timbcr_get_dacsync(struct HRTIM_TIMB_Type* p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_DACSYNC) >> 25 ; }
inline uint32_t hrtim_timb_timbcr_get_delcmp4(struct HRTIM_TIMB_Type* p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_DELCMP4) >> 14 ; }
inline uint32_t hrtim_timb_timbcr_get_delcmp2(struct HRTIM_TIMB_Type* p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_DELCMP2) >> 12 ; }
inline uint32_t hrtim_timb_timbcr_get_ck_pscx(struct HRTIM_TIMB_Type* p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_CK_PSCX) >> 0 ; }

// HRTIM_TIMB->TIMBISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMB_TIMBISR_O2STAT = 1UL<<19, // Output 2 State
	HRTIM_TIMB_TIMBISR_O1STAT = 1UL<<18, // Output 1 State
	HRTIM_TIMB_TIMBISR_IPPSTAT = 1UL<<17, // Idle Push Pull Status
	HRTIM_TIMB_TIMBISR_CPPSTAT = 1UL<<16, // Current Push Pull Status
	HRTIM_TIMB_TIMBISR_DLYPRT = 1UL<<14, // Delayed Protection Flag
	HRTIM_TIMB_TIMBISR_RST = 1UL<<13, // Reset Interrupt Flag
	HRTIM_TIMB_TIMBISR_RSTX2 = 1UL<<12, // Output 2 Reset Interrupt Flag
	HRTIM_TIMB_TIMBISR_SETX2 = 1UL<<11, // Output 2 Set Interrupt Flag
	HRTIM_TIMB_TIMBISR_RSTX1 = 1UL<<10, // Output 1 Reset Interrupt Flag
	HRTIM_TIMB_TIMBISR_SETX1 = 1UL<<9, // Output 1 Set Interrupt Flag
	HRTIM_TIMB_TIMBISR_CPT2 = 1UL<<8, // Capture2 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CPT1 = 1UL<<7, // Capture1 Interrupt Flag
	HRTIM_TIMB_TIMBISR_UPD = 1UL<<6, // Update Interrupt Flag
	HRTIM_TIMB_TIMBISR_REP = 1UL<<4, // Repetition Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP4 = 1UL<<3, // Compare 4 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP3 = 1UL<<2, // Compare 3 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP2 = 1UL<<1, // Compare 2 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP1 = 1UL<<0, // Compare 1 Interrupt Flag		
};

// HRTIM_TIMB->TIMBICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMB_TIMBICR_DLYPRTC = 1UL<<14, // Delayed Protection Flag Clear
	HRTIM_TIMB_TIMBICR_RSTC = 1UL<<13, // Reset Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_RSTX2C = 1UL<<12, // Output 2 Reset flag Clear
	HRTIM_TIMB_TIMBICR_SET2XC = 1UL<<11, // Output 2 Set flag Clear
	HRTIM_TIMB_TIMBICR_RSTX1C = 1UL<<10, // Output 1 Reset flag Clear
	HRTIM_TIMB_TIMBICR_SET1XC = 1UL<<9, // Output 1 Set flag Clear
	HRTIM_TIMB_TIMBICR_CPT2C = 1UL<<8, // Capture2 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CPT1C = 1UL<<7, // Capture1 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_UPDC = 1UL<<6, // Update Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_REPC = 1UL<<4, // Repetition Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP4C = 1UL<<3, // Compare 4 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP3C = 1UL<<2, // Compare 3 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP2C = 1UL<<1, // Compare 2 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP1C = 1UL<<0, // Compare 1 Interrupt flag Clear		
};

// HRTIM_TIMB->TIMBDIER5 TIMxDIER5
enum {
	HRTIM_TIMB_TIMBDIER5_DLYPRTDE = 1UL<<30, // DLYPRTDE
	HRTIM_TIMB_TIMBDIER5_RSTDE = 1UL<<29, // RSTDE
	HRTIM_TIMB_TIMBDIER5_RSTX2DE = 1UL<<28, // RSTx2DE
	HRTIM_TIMB_TIMBDIER5_SETX2DE = 1UL<<27, // SETx2DE
	HRTIM_TIMB_TIMBDIER5_RSTX1DE = 1UL<<26, // RSTx1DE
	HRTIM_TIMB_TIMBDIER5_SET1XDE = 1UL<<25, // SET1xDE
	HRTIM_TIMB_TIMBDIER5_CPT2DE = 1UL<<24, // CPT2DE
	HRTIM_TIMB_TIMBDIER5_CPT1DE = 1UL<<23, // CPT1DE
	HRTIM_TIMB_TIMBDIER5_UPDDE = 1UL<<22, // UPDDE
	HRTIM_TIMB_TIMBDIER5_REPDE = 1UL<<20, // REPDE
	HRTIM_TIMB_TIMBDIER5_CMP4DE = 1UL<<19, // CMP4DE
	HRTIM_TIMB_TIMBDIER5_CMP3DE = 1UL<<18, // CMP3DE
	HRTIM_TIMB_TIMBDIER5_CMP2DE = 1UL<<17, // CMP2DE
	HRTIM_TIMB_TIMBDIER5_CMP1DE = 1UL<<16, // CMP1DE
	HRTIM_TIMB_TIMBDIER5_DLYPRTIE = 1UL<<14, // DLYPRTIE
	HRTIM_TIMB_TIMBDIER5_RSTIE = 1UL<<13, // RSTIE
	HRTIM_TIMB_TIMBDIER5_RSTX2IE = 1UL<<12, // RSTx2IE
	HRTIM_TIMB_TIMBDIER5_SETX2IE = 1UL<<11, // SETx2IE
	HRTIM_TIMB_TIMBDIER5_RSTX1IE = 1UL<<10, // RSTx1IE
	HRTIM_TIMB_TIMBDIER5_SET1XIE = 1UL<<9, // SET1xIE
	HRTIM_TIMB_TIMBDIER5_CPT2IE = 1UL<<8, // CPT2IE
	HRTIM_TIMB_TIMBDIER5_CPT1IE = 1UL<<7, // CPT1IE
	HRTIM_TIMB_TIMBDIER5_UPDIE = 1UL<<6, // UPDIE
	HRTIM_TIMB_TIMBDIER5_REPIE = 1UL<<4, // REPIE
	HRTIM_TIMB_TIMBDIER5_CMP4IE = 1UL<<3, // CMP4IE
	HRTIM_TIMB_TIMBDIER5_CMP3IE = 1UL<<2, // CMP3IE
	HRTIM_TIMB_TIMBDIER5_CMP2IE = 1UL<<1, // CMP2IE
	HRTIM_TIMB_TIMBDIER5_CMP1IE = 1UL<<0, // CMP1IE		
};

// HRTIM_TIMB->CMP1CBR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMB_CMP1CBR_REPX = ((1UL<<8)-1) << 16, // Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMB_CMP1CBR_CMP1X = ((1UL<<16)-1) << 0, // Timerx Compare 1 value		
};
inline void hrtim_timb_cmp1cbr_set_repx(struct HRTIM_TIMB_Type* p, uint32_t val) { p->CMP1CBR = (p->CMP1CBR & ~HRTIM_TIMB_CMP1CBR_REPX) | ((val<<16) & HRTIM_TIMB_CMP1CBR_REPX); }
inline void hrtim_timb_cmp1cbr_set_cmp1x(struct HRTIM_TIMB_Type* p, uint32_t val) { p->CMP1CBR = (p->CMP1CBR & ~HRTIM_TIMB_CMP1CBR_CMP1X) | ((val<<0) & HRTIM_TIMB_CMP1CBR_CMP1X); }
inline uint32_t hrtim_timb_cmp1cbr_get_repx(struct HRTIM_TIMB_Type* p) { return (p->CMP1CBR & HRTIM_TIMB_CMP1CBR_REPX) >> 16 ; }
inline uint32_t hrtim_timb_cmp1cbr_get_cmp1x(struct HRTIM_TIMB_Type* p) { return (p->CMP1CBR & HRTIM_TIMB_CMP1CBR_CMP1X) >> 0 ; }

// HRTIM_TIMB->DTBR Timerx Deadtime Register
enum {
	HRTIM_TIMB_DTBR_DTFLKX = 1UL<<31, // Deadtime Falling Lock
	HRTIM_TIMB_DTBR_DTFSLKX = 1UL<<30, // Deadtime Falling Sign Lock
	HRTIM_TIMB_DTBR_SDTFX = 1UL<<25, // Sign Deadtime Falling value
	HRTIM_TIMB_DTBR_DTFX = ((1UL<<9)-1) << 16, // Deadtime Falling value
	HRTIM_TIMB_DTBR_DTRLKX = 1UL<<15, // Deadtime Rising Lock
	HRTIM_TIMB_DTBR_DTRSLKX = 1UL<<14, // Deadtime Rising Sign Lock
	HRTIM_TIMB_DTBR_DTPRSC = ((1UL<<3)-1) << 10, // Deadtime Prescaler
	HRTIM_TIMB_DTBR_SDTRX = 1UL<<9, // Sign Deadtime Rising value
	HRTIM_TIMB_DTBR_DTRX = ((1UL<<9)-1) << 0, // Deadtime Rising value		
};
inline void hrtim_timb_dtbr_set_dtfx(struct HRTIM_TIMB_Type* p, uint32_t val) { p->DTBR = (p->DTBR & ~HRTIM_TIMB_DTBR_DTFX) | ((val<<16) & HRTIM_TIMB_DTBR_DTFX); }
inline void hrtim_timb_dtbr_set_dtprsc(struct HRTIM_TIMB_Type* p, uint32_t val) { p->DTBR = (p->DTBR & ~HRTIM_TIMB_DTBR_DTPRSC) | ((val<<10) & HRTIM_TIMB_DTBR_DTPRSC); }
inline void hrtim_timb_dtbr_set_dtrx(struct HRTIM_TIMB_Type* p, uint32_t val) { p->DTBR = (p->DTBR & ~HRTIM_TIMB_DTBR_DTRX) | ((val<<0) & HRTIM_TIMB_DTBR_DTRX); }
inline uint32_t hrtim_timb_dtbr_get_dtfx(struct HRTIM_TIMB_Type* p) { return (p->DTBR & HRTIM_TIMB_DTBR_DTFX) >> 16 ; }
inline uint32_t hrtim_timb_dtbr_get_dtprsc(struct HRTIM_TIMB_Type* p) { return (p->DTBR & HRTIM_TIMB_DTBR_DTPRSC) >> 10 ; }
inline uint32_t hrtim_timb_dtbr_get_dtrx(struct HRTIM_TIMB_Type* p) { return (p->DTBR & HRTIM_TIMB_DTBR_DTRX) >> 0 ; }

// HRTIM_TIMB->SETB1R Timerx Output1 Set Register
enum {
	HRTIM_TIMB_SETB1R_UPDATE = 1UL<<31, // Registers update (transfer preload to active)
	HRTIM_TIMB_SETB1R_EXTEVNT10 = 1UL<<30, // External Event 10
	HRTIM_TIMB_SETB1R_EXTEVNT9 = 1UL<<29, // External Event 9
	HRTIM_TIMB_SETB1R_EXTEVNT8 = 1UL<<28, // External Event 8
	HRTIM_TIMB_SETB1R_EXTEVNT7 = 1UL<<27, // External Event 7
	HRTIM_TIMB_SETB1R_EXTEVNT6 = 1UL<<26, // External Event 6
	HRTIM_TIMB_SETB1R_EXTEVNT5 = 1UL<<25, // External Event 5
	HRTIM_TIMB_SETB1R_EXTEVNT4 = 1UL<<24, // External Event 4
	HRTIM_TIMB_SETB1R_EXTEVNT3 = 1UL<<23, // External Event 3
	HRTIM_TIMB_SETB1R_EXTEVNT2 = 1UL<<22, // External Event 2
	HRTIM_TIMB_SETB1R_EXTEVNT1 = 1UL<<21, // External Event 1
	HRTIM_TIMB_SETB1R_TIMEVNT9 = 1UL<<20, // Timer Event 9
	HRTIM_TIMB_SETB1R_TIMEVNT8 = 1UL<<19, // Timer Event 8
	HRTIM_TIMB_SETB1R_TIMEVNT7 = 1UL<<18, // Timer Event 7
	HRTIM_TIMB_SETB1R_TIMEVNT6 = 1UL<<17, // Timer Event 6
	HRTIM_TIMB_SETB1R_TIMEVNT5 = 1UL<<16, // Timer Event 5
	HRTIM_TIMB_SETB1R_TIMEVNT4 = 1UL<<15, // Timer Event 4
	HRTIM_TIMB_SETB1R_TIMEVNT3 = 1UL<<14, // Timer Event 3
	HRTIM_TIMB_SETB1R_TIMEVNT2 = 1UL<<13, // Timer Event 2
	HRTIM_TIMB_SETB1R_TIMEVNT1 = 1UL<<12, // Timer Event 1
	HRTIM_TIMB_SETB1R_MSTCMP4 = 1UL<<11, // Master Compare 4
	HRTIM_TIMB_SETB1R_MSTCMP3 = 1UL<<10, // Master Compare 3
	HRTIM_TIMB_SETB1R_MSTCMP2 = 1UL<<9, // Master Compare 2
	HRTIM_TIMB_SETB1R_MSTCMP1 = 1UL<<8, // Master Compare 1
	HRTIM_TIMB_SETB1R_MSTPER = 1UL<<7, // Master Period
	HRTIM_TIMB_SETB1R_CMP4 = 1UL<<6, // Timer A compare 4
	HRTIM_TIMB_SETB1R_CMP3 = 1UL<<5, // Timer A compare 3
	HRTIM_TIMB_SETB1R_CMP2 = 1UL<<4, // Timer A compare 2
	HRTIM_TIMB_SETB1R_CMP1 = 1UL<<3, // Timer A compare 1
	HRTIM_TIMB_SETB1R_PER = 1UL<<2, // Timer A Period
	HRTIM_TIMB_SETB1R_RESYNC = 1UL<<1, // Timer A resynchronizaton
	HRTIM_TIMB_SETB1R_SST = 1UL<<0, // Software Set trigger		
};

// HRTIM_TIMB->RSTB1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMB_RSTB1R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMB_RSTB1R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMB_RSTB1R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMB_RSTB1R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMB_RSTB1R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMB_RSTB1R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMB_RSTB1R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMB_RSTB1R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMB_RSTB1R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMB_RSTB1R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMB_RSTB1R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMB_RSTB1R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMB_RSTB1R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMB_RSTB1R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMB_RSTB1R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMB_RSTB1R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMB_RSTB1R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMB_RSTB1R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMB_RSTB1R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMB_RSTB1R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMB_RSTB1R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMB_RSTB1R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMB_RSTB1R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMB_RSTB1R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMB_RSTB1R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMB_RSTB1R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMB_RSTB1R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMB_RSTB1R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMB_RSTB1R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMB_RSTB1R_PER = 1UL<<2, // PER
	HRTIM_TIMB_RSTB1R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMB_RSTB1R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMB->SETB2R Timerx Output2 Set Register
enum {
	HRTIM_TIMB_SETB2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMB_SETB2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMB_SETB2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMB_SETB2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMB_SETB2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMB_SETB2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMB_SETB2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMB_SETB2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMB_SETB2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMB_SETB2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMB_SETB2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMB_SETB2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMB_SETB2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMB_SETB2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMB_SETB2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMB_SETB2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMB_SETB2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMB_SETB2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMB_SETB2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMB_SETB2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMB_SETB2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMB_SETB2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMB_SETB2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMB_SETB2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMB_SETB2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMB_SETB2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMB_SETB2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMB_SETB2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMB_SETB2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMB_SETB2R_PER = 1UL<<2, // PER
	HRTIM_TIMB_SETB2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMB_SETB2R_SST = 1UL<<0, // SST		
};

// HRTIM_TIMB->RSTB2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMB_RSTB2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMB_RSTB2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMB_RSTB2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMB_RSTB2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMB_RSTB2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMB_RSTB2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMB_RSTB2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMB_RSTB2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMB_RSTB2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMB_RSTB2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMB_RSTB2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMB_RSTB2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMB_RSTB2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMB_RSTB2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMB_RSTB2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMB_RSTB2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMB_RSTB2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMB_RSTB2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMB_RSTB2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMB_RSTB2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMB_RSTB2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMB_RSTB2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMB_RSTB2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMB_RSTB2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMB_RSTB2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMB_RSTB2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMB_RSTB2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMB_RSTB2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMB_RSTB2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMB_RSTB2R_PER = 1UL<<2, // PER
	HRTIM_TIMB_RSTB2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMB_RSTB2R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMB->EEFBR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMB_EEFBR1_EE5FLTR = ((1UL<<4)-1) << 25, // External Event 5 filter
	HRTIM_TIMB_EEFBR1_EE5LTCH = 1UL<<24, // External Event 5 latch
	HRTIM_TIMB_EEFBR1_EE4FLTR = ((1UL<<4)-1) << 19, // External Event 4 filter
	HRTIM_TIMB_EEFBR1_EE4LTCH = 1UL<<18, // External Event 4 latch
	HRTIM_TIMB_EEFBR1_EE3FLTR = ((1UL<<4)-1) << 13, // External Event 3 filter
	HRTIM_TIMB_EEFBR1_EE3LTCH = 1UL<<12, // External Event 3 latch
	HRTIM_TIMB_EEFBR1_EE2FLTR = ((1UL<<4)-1) << 7, // External Event 2 filter
	HRTIM_TIMB_EEFBR1_EE2LTCH = 1UL<<6, // External Event 2 latch
	HRTIM_TIMB_EEFBR1_EE1FLTR = ((1UL<<4)-1) << 1, // External Event 1 filter
	HRTIM_TIMB_EEFBR1_EE1LTCH = 1UL<<0, // External Event 1 latch		
};
inline void hrtim_timb_eefbr1_set_ee5fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE5FLTR) | ((val<<25) & HRTIM_TIMB_EEFBR1_EE5FLTR); }
inline void hrtim_timb_eefbr1_set_ee4fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE4FLTR) | ((val<<19) & HRTIM_TIMB_EEFBR1_EE4FLTR); }
inline void hrtim_timb_eefbr1_set_ee3fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE3FLTR) | ((val<<13) & HRTIM_TIMB_EEFBR1_EE3FLTR); }
inline void hrtim_timb_eefbr1_set_ee2fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE2FLTR) | ((val<<7) & HRTIM_TIMB_EEFBR1_EE2FLTR); }
inline void hrtim_timb_eefbr1_set_ee1fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE1FLTR) | ((val<<1) & HRTIM_TIMB_EEFBR1_EE1FLTR); }
inline uint32_t hrtim_timb_eefbr1_get_ee5fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE5FLTR) >> 25 ; }
inline uint32_t hrtim_timb_eefbr1_get_ee4fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE4FLTR) >> 19 ; }
inline uint32_t hrtim_timb_eefbr1_get_ee3fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE3FLTR) >> 13 ; }
inline uint32_t hrtim_timb_eefbr1_get_ee2fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE2FLTR) >> 7 ; }
inline uint32_t hrtim_timb_eefbr1_get_ee1fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE1FLTR) >> 1 ; }

// HRTIM_TIMB->EEFBR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMB_EEFBR2_EE10FLTR = ((1UL<<4)-1) << 25, // External Event 10 filter
	HRTIM_TIMB_EEFBR2_EE10LTCH = 1UL<<24, // External Event 10 latch
	HRTIM_TIMB_EEFBR2_EE9FLTR = ((1UL<<4)-1) << 19, // External Event 9 filter
	HRTIM_TIMB_EEFBR2_EE9LTCH = 1UL<<18, // External Event 9 latch
	HRTIM_TIMB_EEFBR2_EE8FLTR = ((1UL<<4)-1) << 13, // External Event 8 filter
	HRTIM_TIMB_EEFBR2_EE8LTCH = 1UL<<12, // External Event 8 latch
	HRTIM_TIMB_EEFBR2_EE7FLTR = ((1UL<<4)-1) << 7, // External Event 7 filter
	HRTIM_TIMB_EEFBR2_EE7LTCH = 1UL<<6, // External Event 7 latch
	HRTIM_TIMB_EEFBR2_EE6FLTR = ((1UL<<4)-1) << 1, // External Event 6 filter
	HRTIM_TIMB_EEFBR2_EE6LTCH = 1UL<<0, // External Event 6 latch		
};
inline void hrtim_timb_eefbr2_set_ee10fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE10FLTR) | ((val<<25) & HRTIM_TIMB_EEFBR2_EE10FLTR); }
inline void hrtim_timb_eefbr2_set_ee9fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE9FLTR) | ((val<<19) & HRTIM_TIMB_EEFBR2_EE9FLTR); }
inline void hrtim_timb_eefbr2_set_ee8fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE8FLTR) | ((val<<13) & HRTIM_TIMB_EEFBR2_EE8FLTR); }
inline void hrtim_timb_eefbr2_set_ee7fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE7FLTR) | ((val<<7) & HRTIM_TIMB_EEFBR2_EE7FLTR); }
inline void hrtim_timb_eefbr2_set_ee6fltr(struct HRTIM_TIMB_Type* p, uint32_t val) { p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE6FLTR) | ((val<<1) & HRTIM_TIMB_EEFBR2_EE6FLTR); }
inline uint32_t hrtim_timb_eefbr2_get_ee10fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE10FLTR) >> 25 ; }
inline uint32_t hrtim_timb_eefbr2_get_ee9fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE9FLTR) >> 19 ; }
inline uint32_t hrtim_timb_eefbr2_get_ee8fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE8FLTR) >> 13 ; }
inline uint32_t hrtim_timb_eefbr2_get_ee7fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE7FLTR) >> 7 ; }
inline uint32_t hrtim_timb_eefbr2_get_ee6fltr(struct HRTIM_TIMB_Type* p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE6FLTR) >> 1 ; }

// HRTIM_TIMB->RSTBR TimerA Reset Register
enum {
	HRTIM_TIMB_RSTBR_TIMECMP4 = 1UL<<30, // Timer E Compare 4
	HRTIM_TIMB_RSTBR_TIMECMP2 = 1UL<<29, // Timer E Compare 2
	HRTIM_TIMB_RSTBR_TIMECMP1 = 1UL<<28, // Timer E Compare 1
	HRTIM_TIMB_RSTBR_TIMDCMP4 = 1UL<<27, // Timer D Compare 4
	HRTIM_TIMB_RSTBR_TIMDCMP2 = 1UL<<26, // Timer D Compare 2
	HRTIM_TIMB_RSTBR_TIMDCMP1 = 1UL<<25, // Timer D Compare 1
	HRTIM_TIMB_RSTBR_TIMCCMP4 = 1UL<<24, // Timer C Compare 4
	HRTIM_TIMB_RSTBR_TIMCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMB_RSTBR_TIMCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMB_RSTBR_TIMACMP4 = 1UL<<21, // Timer A Compare 4
	HRTIM_TIMB_RSTBR_TIMACMP2 = 1UL<<20, // Timer A Compare 2
	HRTIM_TIMB_RSTBR_TIMACMP1 = 1UL<<19, // Timer A Compare 1
	HRTIM_TIMB_RSTBR_EXTEVNT10 = 1UL<<18, // External Event 10
	HRTIM_TIMB_RSTBR_EXTEVNT9 = 1UL<<17, // External Event 9
	HRTIM_TIMB_RSTBR_EXTEVNT8 = 1UL<<16, // External Event 8
	HRTIM_TIMB_RSTBR_EXTEVNT7 = 1UL<<15, // External Event 7
	HRTIM_TIMB_RSTBR_EXTEVNT6 = 1UL<<14, // External Event 6
	HRTIM_TIMB_RSTBR_EXTEVNT5 = 1UL<<13, // External Event 5
	HRTIM_TIMB_RSTBR_EXTEVNT4 = 1UL<<12, // External Event 4
	HRTIM_TIMB_RSTBR_EXTEVNT3 = 1UL<<11, // External Event 3
	HRTIM_TIMB_RSTBR_EXTEVNT2 = 1UL<<10, // External Event 2
	HRTIM_TIMB_RSTBR_EXTEVNT1 = 1UL<<9, // External Event 1
	HRTIM_TIMB_RSTBR_MSTCMP4 = 1UL<<8, // Master compare 4
	HRTIM_TIMB_RSTBR_MSTCMP3 = 1UL<<7, // Master compare 3
	HRTIM_TIMB_RSTBR_MSTCMP2 = 1UL<<6, // Master compare 2
	HRTIM_TIMB_RSTBR_MSTCMP1 = 1UL<<5, // Master compare 1
	HRTIM_TIMB_RSTBR_MSTPER = 1UL<<4, // Master timer Period
	HRTIM_TIMB_RSTBR_CMP4 = 1UL<<3, // Timer A compare 4 reset
	HRTIM_TIMB_RSTBR_CMP2 = 1UL<<2, // Timer A compare 2 reset
	HRTIM_TIMB_RSTBR_UPDT = 1UL<<1, // Timer A Update reset		
};

// HRTIM_TIMB->CHPBR Timerx Chopper Register
enum {
	HRTIM_TIMB_CHPBR_STRTPW = ((1UL<<4)-1) << 7, // STRTPW
	HRTIM_TIMB_CHPBR_CHPDTY = ((1UL<<3)-1) << 4, // Timerx chopper duty cycle value
	HRTIM_TIMB_CHPBR_CHPFRQ = ((1UL<<4)-1) << 0, // Timerx carrier frequency value		
};
inline void hrtim_timb_chpbr_set_strtpw(struct HRTIM_TIMB_Type* p, uint32_t val) { p->CHPBR = (p->CHPBR & ~HRTIM_TIMB_CHPBR_STRTPW) | ((val<<7) & HRTIM_TIMB_CHPBR_STRTPW); }
inline void hrtim_timb_chpbr_set_chpdty(struct HRTIM_TIMB_Type* p, uint32_t val) { p->CHPBR = (p->CHPBR & ~HRTIM_TIMB_CHPBR_CHPDTY) | ((val<<4) & HRTIM_TIMB_CHPBR_CHPDTY); }
inline void hrtim_timb_chpbr_set_chpfrq(struct HRTIM_TIMB_Type* p, uint32_t val) { p->CHPBR = (p->CHPBR & ~HRTIM_TIMB_CHPBR_CHPFRQ) | ((val<<0) & HRTIM_TIMB_CHPBR_CHPFRQ); }
inline uint32_t hrtim_timb_chpbr_get_strtpw(struct HRTIM_TIMB_Type* p) { return (p->CHPBR & HRTIM_TIMB_CHPBR_STRTPW) >> 7 ; }
inline uint32_t hrtim_timb_chpbr_get_chpdty(struct HRTIM_TIMB_Type* p) { return (p->CHPBR & HRTIM_TIMB_CHPBR_CHPDTY) >> 4 ; }
inline uint32_t hrtim_timb_chpbr_get_chpfrq(struct HRTIM_TIMB_Type* p) { return (p->CHPBR & HRTIM_TIMB_CHPBR_CHPFRQ) >> 0 ; }

// HRTIM_TIMB->CPT1BCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMB_CPT1BCR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMB_CPT1BCR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMB_CPT1BCR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMB_CPT1BCR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMB_CPT1BCR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIMB_CPT1BCR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIMB_CPT1BCR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIMB_CPT1BCR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIMB_CPT1BCR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMB_CPT1BCR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMB_CPT1BCR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIMB_CPT1BCR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIMB_CPT1BCR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIMB_CPT1BCR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIMB_CPT1BCR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIMB_CPT1BCR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIMB_CPT1BCR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMB_CPT1BCR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMB_CPT1BCR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMB_CPT1BCR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMB_CPT1BCR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMB_CPT1BCR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMB_CPT1BCR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMB_CPT1BCR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMB_CPT1BCR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMB_CPT1BCR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMB_CPT1BCR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMB_CPT1BCR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMB->CPT2BCR CPT2xCR
enum {
	HRTIM_TIMB_CPT2BCR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMB_CPT2BCR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMB_CPT2BCR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMB_CPT2BCR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMB_CPT2BCR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIMB_CPT2BCR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIMB_CPT2BCR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIMB_CPT2BCR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIMB_CPT2BCR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMB_CPT2BCR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMB_CPT2BCR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIMB_CPT2BCR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIMB_CPT2BCR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIMB_CPT2BCR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIMB_CPT2BCR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIMB_CPT2BCR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIMB_CPT2BCR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMB_CPT2BCR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMB_CPT2BCR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMB_CPT2BCR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMB_CPT2BCR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMB_CPT2BCR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMB_CPT2BCR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMB_CPT2BCR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMB_CPT2BCR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMB_CPT2BCR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMB_CPT2BCR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMB_CPT2BCR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMB->OUTBR Timerx Output Register
enum {
	HRTIM_TIMB_OUTBR_DIDL2 = 1UL<<23, // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMB_OUTBR_CHP2 = 1UL<<22, // Output 2 Chopper enable
	HRTIM_TIMB_OUTBR_FAULT2 = ((1UL<<2)-1) << 20, // Output 2 Fault state
	HRTIM_TIMB_OUTBR_IDLES2 = 1UL<<19, // Output 2 Idle State
	HRTIM_TIMB_OUTBR_IDLEM2 = 1UL<<18, // Output 2 Idle mode
	HRTIM_TIMB_OUTBR_POL2 = 1UL<<17, // Output 2 polarity
	HRTIM_TIMB_OUTBR_DLYPRT = ((1UL<<3)-1) << 10, // Delayed Protection
	HRTIM_TIMB_OUTBR_DLYPRTEN = 1UL<<9, // Delayed Protection Enable
	HRTIM_TIMB_OUTBR_DTEN = 1UL<<8, // Deadtime enable
	HRTIM_TIMB_OUTBR_DIDL1 = 1UL<<7, // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMB_OUTBR_CHP1 = 1UL<<6, // Output 1 Chopper enable
	HRTIM_TIMB_OUTBR_FAULT1 = ((1UL<<2)-1) << 4, // Output 1 Fault state
	HRTIM_TIMB_OUTBR_IDLES1 = 1UL<<3, // Output 1 Idle State
	HRTIM_TIMB_OUTBR_IDLEM1 = 1UL<<2, // Output 1 Idle mode
	HRTIM_TIMB_OUTBR_POL1 = 1UL<<1, // Output 1 polarity		
};
inline void hrtim_timb_outbr_set_fault2(struct HRTIM_TIMB_Type* p, uint32_t val) { p->OUTBR = (p->OUTBR & ~HRTIM_TIMB_OUTBR_FAULT2) | ((val<<20) & HRTIM_TIMB_OUTBR_FAULT2); }
inline void hrtim_timb_outbr_set_dlyprt(struct HRTIM_TIMB_Type* p, uint32_t val) { p->OUTBR = (p->OUTBR & ~HRTIM_TIMB_OUTBR_DLYPRT) | ((val<<10) & HRTIM_TIMB_OUTBR_DLYPRT); }
inline void hrtim_timb_outbr_set_fault1(struct HRTIM_TIMB_Type* p, uint32_t val) { p->OUTBR = (p->OUTBR & ~HRTIM_TIMB_OUTBR_FAULT1) | ((val<<4) & HRTIM_TIMB_OUTBR_FAULT1); }
inline uint32_t hrtim_timb_outbr_get_fault2(struct HRTIM_TIMB_Type* p) { return (p->OUTBR & HRTIM_TIMB_OUTBR_FAULT2) >> 20 ; }
inline uint32_t hrtim_timb_outbr_get_dlyprt(struct HRTIM_TIMB_Type* p) { return (p->OUTBR & HRTIM_TIMB_OUTBR_DLYPRT) >> 10 ; }
inline uint32_t hrtim_timb_outbr_get_fault1(struct HRTIM_TIMB_Type* p) { return (p->OUTBR & HRTIM_TIMB_OUTBR_FAULT1) >> 4 ; }

// HRTIM_TIMB->FLTBR Timerx Fault Register
enum {
	HRTIM_TIMB_FLTBR_FLTLCK = 1UL<<31, // Fault sources Lock
	HRTIM_TIMB_FLTBR_FLT5EN = 1UL<<4, // Fault 5 enable
	HRTIM_TIMB_FLTBR_FLT4EN = 1UL<<3, // Fault 4 enable
	HRTIM_TIMB_FLTBR_FLT3EN = 1UL<<2, // Fault 3 enable
	HRTIM_TIMB_FLTBR_FLT2EN = 1UL<<1, // Fault 2 enable
	HRTIM_TIMB_FLTBR_FLT1EN = 1UL<<0, // Fault 1 enable		
};

/* High Resolution Timer: TIMC */
struct HRTIM_TIMC_Type {
	__IO uint32_t TIMCCR; // @0 Timerx Control Register
	__I uint32_t TIMCISR; // @4 Timerx Interrupt Status Register
	__O uint16_t TIMCICR; // @8 Timerx Interrupt Clear Register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t TIMCDIER5; // @12 TIMxDIER5
	__IO uint16_t CNTCR; // @16 Timerx Counter Register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t PERCR; // @20 Timerx Period Register
	 uint8_t RESERVED2[2]; // @22 
	__IO uint8_t REPCR; // @24 Timerx Repetition Register
	 uint8_t RESERVED3[3]; // @25 
	__IO uint16_t CMP1CR; // @28 Timerx Compare 1 Register
	 uint8_t RESERVED4[2]; // @30 
	__IO uint32_t CMP1CCR; // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2CR; // @36 Timerx Compare 2 Register
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t CMP3CR; // @40 Timerx Compare 3 Register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t CMP4CR; // @44 Timerx Compare 4 Register
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t CPT1CR; // @48 Timerx Capture 1 Register
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t CPT2CR; // @52 Timerx Capture 2 Register
	 uint8_t RESERVED9[2]; // @54 
	__IO uint32_t DTCR; // @56 Timerx Deadtime Register
	__IO uint32_t SETC1R; // @60 Timerx Output1 Set Register
	__IO uint32_t RSTC1R; // @64 Timerx Output1 Reset Register
	__IO uint32_t SETC2R; // @68 Timerx Output2 Set Register
	__IO uint32_t RSTC2R; // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFCR1; // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFCR2; // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTCR; // @84 TimerA Reset Register
	__IO uint16_t CHPCR; // @88 Timerx Chopper Register
	 uint8_t RESERVED10[2]; // @90 
	__IO uint32_t CPT1CCR; // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2CCR; // @96 CPT2xCR
	__IO uint32_t OUTCR; // @100 Timerx Output Register
	__IO uint32_t FLTCR; // @104 Timerx Fault Register
};

// HRTIM_TIMC->TIMCCR Timerx Control Register
enum {
	HRTIM_TIMC_TIMCCR_UPDGAT = ((1UL<<4)-1) << 28, // Update Gating
	HRTIM_TIMC_TIMCCR_PREEN = 1UL<<27, // Preload enable
	HRTIM_TIMC_TIMCCR_DACSYNC = ((1UL<<2)-1) << 25, // AC Synchronization
	HRTIM_TIMC_TIMCCR_MSTU = 1UL<<24, // Master Timer update
	HRTIM_TIMC_TIMCCR_TEU = 1UL<<23, // TEU
	HRTIM_TIMC_TIMCCR_TDU = 1UL<<22, // TDU
	HRTIM_TIMC_TIMCCR_TCU = 1UL<<21, // TCU
	HRTIM_TIMC_TIMCCR_TBU = 1UL<<20, // TBU
	HRTIM_TIMC_TIMCCR_TXRSTU = 1UL<<18, // Timerx reset update
	HRTIM_TIMC_TIMCCR_TXREPU = 1UL<<17, // Timer x Repetition update
	HRTIM_TIMC_TIMCCR_DELCMP4 = ((1UL<<2)-1) << 14, // Delayed CMP4 mode
	HRTIM_TIMC_TIMCCR_DELCMP2 = ((1UL<<2)-1) << 12, // Delayed CMP2 mode
	HRTIM_TIMC_TIMCCR_SYNCSTRTX = 1UL<<11, // Synchronization Starts Timer x
	HRTIM_TIMC_TIMCCR_SYNCRSTX = 1UL<<10, // Synchronization Resets Timer x
	HRTIM_TIMC_TIMCCR_PSHPLL = 1UL<<6, // Push-Pull mode enable
	HRTIM_TIMC_TIMCCR_HALF = 1UL<<5, // Half mode enable
	HRTIM_TIMC_TIMCCR_RETRIG = 1UL<<4, // Re-triggerable mode
	HRTIM_TIMC_TIMCCR_CONT = 1UL<<3, // Continuous mode
	HRTIM_TIMC_TIMCCR_CK_PSCX = ((1UL<<3)-1) << 0, // HRTIM Timer x Clock prescaler		
};
inline void hrtim_timc_timccr_set_updgat(struct HRTIM_TIMC_Type* p, uint32_t val) { p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_UPDGAT) | ((val<<28) & HRTIM_TIMC_TIMCCR_UPDGAT); }
inline void hrtim_timc_timccr_set_dacsync(struct HRTIM_TIMC_Type* p, uint32_t val) { p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_DACSYNC) | ((val<<25) & HRTIM_TIMC_TIMCCR_DACSYNC); }
inline void hrtim_timc_timccr_set_delcmp4(struct HRTIM_TIMC_Type* p, uint32_t val) { p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_DELCMP4) | ((val<<14) & HRTIM_TIMC_TIMCCR_DELCMP4); }
inline void hrtim_timc_timccr_set_delcmp2(struct HRTIM_TIMC_Type* p, uint32_t val) { p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_DELCMP2) | ((val<<12) & HRTIM_TIMC_TIMCCR_DELCMP2); }
inline void hrtim_timc_timccr_set_ck_pscx(struct HRTIM_TIMC_Type* p, uint32_t val) { p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_CK_PSCX) | ((val<<0) & HRTIM_TIMC_TIMCCR_CK_PSCX); }
inline uint32_t hrtim_timc_timccr_get_updgat(struct HRTIM_TIMC_Type* p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_UPDGAT) >> 28 ; }
inline uint32_t hrtim_timc_timccr_get_dacsync(struct HRTIM_TIMC_Type* p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_DACSYNC) >> 25 ; }
inline uint32_t hrtim_timc_timccr_get_delcmp4(struct HRTIM_TIMC_Type* p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_DELCMP4) >> 14 ; }
inline uint32_t hrtim_timc_timccr_get_delcmp2(struct HRTIM_TIMC_Type* p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_DELCMP2) >> 12 ; }
inline uint32_t hrtim_timc_timccr_get_ck_pscx(struct HRTIM_TIMC_Type* p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_CK_PSCX) >> 0 ; }

// HRTIM_TIMC->TIMCISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMC_TIMCISR_O2STAT = 1UL<<19, // Output 2 State
	HRTIM_TIMC_TIMCISR_O1STAT = 1UL<<18, // Output 1 State
	HRTIM_TIMC_TIMCISR_IPPSTAT = 1UL<<17, // Idle Push Pull Status
	HRTIM_TIMC_TIMCISR_CPPSTAT = 1UL<<16, // Current Push Pull Status
	HRTIM_TIMC_TIMCISR_DLYPRT = 1UL<<14, // Delayed Protection Flag
	HRTIM_TIMC_TIMCISR_RST = 1UL<<13, // Reset Interrupt Flag
	HRTIM_TIMC_TIMCISR_RSTX2 = 1UL<<12, // Output 2 Reset Interrupt Flag
	HRTIM_TIMC_TIMCISR_SETX2 = 1UL<<11, // Output 2 Set Interrupt Flag
	HRTIM_TIMC_TIMCISR_RSTX1 = 1UL<<10, // Output 1 Reset Interrupt Flag
	HRTIM_TIMC_TIMCISR_SETX1 = 1UL<<9, // Output 1 Set Interrupt Flag
	HRTIM_TIMC_TIMCISR_CPT2 = 1UL<<8, // Capture2 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CPT1 = 1UL<<7, // Capture1 Interrupt Flag
	HRTIM_TIMC_TIMCISR_UPD = 1UL<<6, // Update Interrupt Flag
	HRTIM_TIMC_TIMCISR_REP = 1UL<<4, // Repetition Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP4 = 1UL<<3, // Compare 4 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP3 = 1UL<<2, // Compare 3 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP2 = 1UL<<1, // Compare 2 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP1 = 1UL<<0, // Compare 1 Interrupt Flag		
};

// HRTIM_TIMC->TIMCICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMC_TIMCICR_DLYPRTC = 1UL<<14, // Delayed Protection Flag Clear
	HRTIM_TIMC_TIMCICR_RSTC = 1UL<<13, // Reset Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_RSTX2C = 1UL<<12, // Output 2 Reset flag Clear
	HRTIM_TIMC_TIMCICR_SET2XC = 1UL<<11, // Output 2 Set flag Clear
	HRTIM_TIMC_TIMCICR_RSTX1C = 1UL<<10, // Output 1 Reset flag Clear
	HRTIM_TIMC_TIMCICR_SET1XC = 1UL<<9, // Output 1 Set flag Clear
	HRTIM_TIMC_TIMCICR_CPT2C = 1UL<<8, // Capture2 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CPT1C = 1UL<<7, // Capture1 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_UPDC = 1UL<<6, // Update Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_REPC = 1UL<<4, // Repetition Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP4C = 1UL<<3, // Compare 4 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP3C = 1UL<<2, // Compare 3 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP2C = 1UL<<1, // Compare 2 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP1C = 1UL<<0, // Compare 1 Interrupt flag Clear		
};

// HRTIM_TIMC->TIMCDIER5 TIMxDIER5
enum {
	HRTIM_TIMC_TIMCDIER5_DLYPRTDE = 1UL<<30, // DLYPRTDE
	HRTIM_TIMC_TIMCDIER5_RSTDE = 1UL<<29, // RSTDE
	HRTIM_TIMC_TIMCDIER5_RSTX2DE = 1UL<<28, // RSTx2DE
	HRTIM_TIMC_TIMCDIER5_SETX2DE = 1UL<<27, // SETx2DE
	HRTIM_TIMC_TIMCDIER5_RSTX1DE = 1UL<<26, // RSTx1DE
	HRTIM_TIMC_TIMCDIER5_SET1XDE = 1UL<<25, // SET1xDE
	HRTIM_TIMC_TIMCDIER5_CPT2DE = 1UL<<24, // CPT2DE
	HRTIM_TIMC_TIMCDIER5_CPT1DE = 1UL<<23, // CPT1DE
	HRTIM_TIMC_TIMCDIER5_UPDDE = 1UL<<22, // UPDDE
	HRTIM_TIMC_TIMCDIER5_REPDE = 1UL<<20, // REPDE
	HRTIM_TIMC_TIMCDIER5_CMP4DE = 1UL<<19, // CMP4DE
	HRTIM_TIMC_TIMCDIER5_CMP3DE = 1UL<<18, // CMP3DE
	HRTIM_TIMC_TIMCDIER5_CMP2DE = 1UL<<17, // CMP2DE
	HRTIM_TIMC_TIMCDIER5_CMP1DE = 1UL<<16, // CMP1DE
	HRTIM_TIMC_TIMCDIER5_DLYPRTIE = 1UL<<14, // DLYPRTIE
	HRTIM_TIMC_TIMCDIER5_RSTIE = 1UL<<13, // RSTIE
	HRTIM_TIMC_TIMCDIER5_RSTX2IE = 1UL<<12, // RSTx2IE
	HRTIM_TIMC_TIMCDIER5_SETX2IE = 1UL<<11, // SETx2IE
	HRTIM_TIMC_TIMCDIER5_RSTX1IE = 1UL<<10, // RSTx1IE
	HRTIM_TIMC_TIMCDIER5_SET1XIE = 1UL<<9, // SET1xIE
	HRTIM_TIMC_TIMCDIER5_CPT2IE = 1UL<<8, // CPT2IE
	HRTIM_TIMC_TIMCDIER5_CPT1IE = 1UL<<7, // CPT1IE
	HRTIM_TIMC_TIMCDIER5_UPDIE = 1UL<<6, // UPDIE
	HRTIM_TIMC_TIMCDIER5_REPIE = 1UL<<4, // REPIE
	HRTIM_TIMC_TIMCDIER5_CMP4IE = 1UL<<3, // CMP4IE
	HRTIM_TIMC_TIMCDIER5_CMP3IE = 1UL<<2, // CMP3IE
	HRTIM_TIMC_TIMCDIER5_CMP2IE = 1UL<<1, // CMP2IE
	HRTIM_TIMC_TIMCDIER5_CMP1IE = 1UL<<0, // CMP1IE		
};

// HRTIM_TIMC->CMP1CCR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMC_CMP1CCR_REPX = ((1UL<<8)-1) << 16, // Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMC_CMP1CCR_CMP1X = ((1UL<<16)-1) << 0, // Timerx Compare 1 value		
};
inline void hrtim_timc_cmp1ccr_set_repx(struct HRTIM_TIMC_Type* p, uint32_t val) { p->CMP1CCR = (p->CMP1CCR & ~HRTIM_TIMC_CMP1CCR_REPX) | ((val<<16) & HRTIM_TIMC_CMP1CCR_REPX); }
inline void hrtim_timc_cmp1ccr_set_cmp1x(struct HRTIM_TIMC_Type* p, uint32_t val) { p->CMP1CCR = (p->CMP1CCR & ~HRTIM_TIMC_CMP1CCR_CMP1X) | ((val<<0) & HRTIM_TIMC_CMP1CCR_CMP1X); }
inline uint32_t hrtim_timc_cmp1ccr_get_repx(struct HRTIM_TIMC_Type* p) { return (p->CMP1CCR & HRTIM_TIMC_CMP1CCR_REPX) >> 16 ; }
inline uint32_t hrtim_timc_cmp1ccr_get_cmp1x(struct HRTIM_TIMC_Type* p) { return (p->CMP1CCR & HRTIM_TIMC_CMP1CCR_CMP1X) >> 0 ; }

// HRTIM_TIMC->DTCR Timerx Deadtime Register
enum {
	HRTIM_TIMC_DTCR_DTFLKX = 1UL<<31, // Deadtime Falling Lock
	HRTIM_TIMC_DTCR_DTFSLKX = 1UL<<30, // Deadtime Falling Sign Lock
	HRTIM_TIMC_DTCR_SDTFX = 1UL<<25, // Sign Deadtime Falling value
	HRTIM_TIMC_DTCR_DTFX = ((1UL<<9)-1) << 16, // Deadtime Falling value
	HRTIM_TIMC_DTCR_DTRLKX = 1UL<<15, // Deadtime Rising Lock
	HRTIM_TIMC_DTCR_DTRSLKX = 1UL<<14, // Deadtime Rising Sign Lock
	HRTIM_TIMC_DTCR_DTPRSC = ((1UL<<3)-1) << 10, // Deadtime Prescaler
	HRTIM_TIMC_DTCR_SDTRX = 1UL<<9, // Sign Deadtime Rising value
	HRTIM_TIMC_DTCR_DTRX = ((1UL<<9)-1) << 0, // Deadtime Rising value		
};
inline void hrtim_timc_dtcr_set_dtfx(struct HRTIM_TIMC_Type* p, uint32_t val) { p->DTCR = (p->DTCR & ~HRTIM_TIMC_DTCR_DTFX) | ((val<<16) & HRTIM_TIMC_DTCR_DTFX); }
inline void hrtim_timc_dtcr_set_dtprsc(struct HRTIM_TIMC_Type* p, uint32_t val) { p->DTCR = (p->DTCR & ~HRTIM_TIMC_DTCR_DTPRSC) | ((val<<10) & HRTIM_TIMC_DTCR_DTPRSC); }
inline void hrtim_timc_dtcr_set_dtrx(struct HRTIM_TIMC_Type* p, uint32_t val) { p->DTCR = (p->DTCR & ~HRTIM_TIMC_DTCR_DTRX) | ((val<<0) & HRTIM_TIMC_DTCR_DTRX); }
inline uint32_t hrtim_timc_dtcr_get_dtfx(struct HRTIM_TIMC_Type* p) { return (p->DTCR & HRTIM_TIMC_DTCR_DTFX) >> 16 ; }
inline uint32_t hrtim_timc_dtcr_get_dtprsc(struct HRTIM_TIMC_Type* p) { return (p->DTCR & HRTIM_TIMC_DTCR_DTPRSC) >> 10 ; }
inline uint32_t hrtim_timc_dtcr_get_dtrx(struct HRTIM_TIMC_Type* p) { return (p->DTCR & HRTIM_TIMC_DTCR_DTRX) >> 0 ; }

// HRTIM_TIMC->SETC1R Timerx Output1 Set Register
enum {
	HRTIM_TIMC_SETC1R_UPDATE = 1UL<<31, // Registers update (transfer preload to active)
	HRTIM_TIMC_SETC1R_EXTEVNT10 = 1UL<<30, // External Event 10
	HRTIM_TIMC_SETC1R_EXTEVNT9 = 1UL<<29, // External Event 9
	HRTIM_TIMC_SETC1R_EXTEVNT8 = 1UL<<28, // External Event 8
	HRTIM_TIMC_SETC1R_EXTEVNT7 = 1UL<<27, // External Event 7
	HRTIM_TIMC_SETC1R_EXTEVNT6 = 1UL<<26, // External Event 6
	HRTIM_TIMC_SETC1R_EXTEVNT5 = 1UL<<25, // External Event 5
	HRTIM_TIMC_SETC1R_EXTEVNT4 = 1UL<<24, // External Event 4
	HRTIM_TIMC_SETC1R_EXTEVNT3 = 1UL<<23, // External Event 3
	HRTIM_TIMC_SETC1R_EXTEVNT2 = 1UL<<22, // External Event 2
	HRTIM_TIMC_SETC1R_EXTEVNT1 = 1UL<<21, // External Event 1
	HRTIM_TIMC_SETC1R_TIMEVNT9 = 1UL<<20, // Timer Event 9
	HRTIM_TIMC_SETC1R_TIMEVNT8 = 1UL<<19, // Timer Event 8
	HRTIM_TIMC_SETC1R_TIMEVNT7 = 1UL<<18, // Timer Event 7
	HRTIM_TIMC_SETC1R_TIMEVNT6 = 1UL<<17, // Timer Event 6
	HRTIM_TIMC_SETC1R_TIMEVNT5 = 1UL<<16, // Timer Event 5
	HRTIM_TIMC_SETC1R_TIMEVNT4 = 1UL<<15, // Timer Event 4
	HRTIM_TIMC_SETC1R_TIMEVNT3 = 1UL<<14, // Timer Event 3
	HRTIM_TIMC_SETC1R_TIMEVNT2 = 1UL<<13, // Timer Event 2
	HRTIM_TIMC_SETC1R_TIMEVNT1 = 1UL<<12, // Timer Event 1
	HRTIM_TIMC_SETC1R_MSTCMP4 = 1UL<<11, // Master Compare 4
	HRTIM_TIMC_SETC1R_MSTCMP3 = 1UL<<10, // Master Compare 3
	HRTIM_TIMC_SETC1R_MSTCMP2 = 1UL<<9, // Master Compare 2
	HRTIM_TIMC_SETC1R_MSTCMP1 = 1UL<<8, // Master Compare 1
	HRTIM_TIMC_SETC1R_MSTPER = 1UL<<7, // Master Period
	HRTIM_TIMC_SETC1R_CMP4 = 1UL<<6, // Timer A compare 4
	HRTIM_TIMC_SETC1R_CMP3 = 1UL<<5, // Timer A compare 3
	HRTIM_TIMC_SETC1R_CMP2 = 1UL<<4, // Timer A compare 2
	HRTIM_TIMC_SETC1R_CMP1 = 1UL<<3, // Timer A compare 1
	HRTIM_TIMC_SETC1R_PER = 1UL<<2, // Timer A Period
	HRTIM_TIMC_SETC1R_RESYNC = 1UL<<1, // Timer A resynchronizaton
	HRTIM_TIMC_SETC1R_SST = 1UL<<0, // Software Set trigger		
};

// HRTIM_TIMC->RSTC1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMC_RSTC1R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMC_RSTC1R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMC_RSTC1R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMC_RSTC1R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMC_RSTC1R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMC_RSTC1R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMC_RSTC1R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMC_RSTC1R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMC_RSTC1R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMC_RSTC1R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMC_RSTC1R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMC_RSTC1R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMC_RSTC1R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMC_RSTC1R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMC_RSTC1R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMC_RSTC1R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMC_RSTC1R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMC_RSTC1R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMC_RSTC1R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMC_RSTC1R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMC_RSTC1R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMC_RSTC1R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMC_RSTC1R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMC_RSTC1R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMC_RSTC1R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMC_RSTC1R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMC_RSTC1R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMC_RSTC1R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMC_RSTC1R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMC_RSTC1R_PER = 1UL<<2, // PER
	HRTIM_TIMC_RSTC1R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMC_RSTC1R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMC->SETC2R Timerx Output2 Set Register
enum {
	HRTIM_TIMC_SETC2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMC_SETC2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMC_SETC2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMC_SETC2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMC_SETC2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMC_SETC2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMC_SETC2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMC_SETC2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMC_SETC2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMC_SETC2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMC_SETC2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMC_SETC2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMC_SETC2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMC_SETC2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMC_SETC2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMC_SETC2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMC_SETC2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMC_SETC2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMC_SETC2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMC_SETC2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMC_SETC2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMC_SETC2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMC_SETC2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMC_SETC2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMC_SETC2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMC_SETC2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMC_SETC2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMC_SETC2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMC_SETC2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMC_SETC2R_PER = 1UL<<2, // PER
	HRTIM_TIMC_SETC2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMC_SETC2R_SST = 1UL<<0, // SST		
};

// HRTIM_TIMC->RSTC2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMC_RSTC2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMC_RSTC2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMC_RSTC2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMC_RSTC2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMC_RSTC2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMC_RSTC2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMC_RSTC2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMC_RSTC2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMC_RSTC2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMC_RSTC2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMC_RSTC2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMC_RSTC2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMC_RSTC2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMC_RSTC2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMC_RSTC2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMC_RSTC2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMC_RSTC2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMC_RSTC2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMC_RSTC2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMC_RSTC2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMC_RSTC2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMC_RSTC2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMC_RSTC2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMC_RSTC2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMC_RSTC2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMC_RSTC2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMC_RSTC2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMC_RSTC2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMC_RSTC2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMC_RSTC2R_PER = 1UL<<2, // PER
	HRTIM_TIMC_RSTC2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMC_RSTC2R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMC->EEFCR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMC_EEFCR1_EE5FLTR = ((1UL<<4)-1) << 25, // External Event 5 filter
	HRTIM_TIMC_EEFCR1_EE5LTCH = 1UL<<24, // External Event 5 latch
	HRTIM_TIMC_EEFCR1_EE4FLTR = ((1UL<<4)-1) << 19, // External Event 4 filter
	HRTIM_TIMC_EEFCR1_EE4LTCH = 1UL<<18, // External Event 4 latch
	HRTIM_TIMC_EEFCR1_EE3FLTR = ((1UL<<4)-1) << 13, // External Event 3 filter
	HRTIM_TIMC_EEFCR1_EE3LTCH = 1UL<<12, // External Event 3 latch
	HRTIM_TIMC_EEFCR1_EE2FLTR = ((1UL<<4)-1) << 7, // External Event 2 filter
	HRTIM_TIMC_EEFCR1_EE2LTCH = 1UL<<6, // External Event 2 latch
	HRTIM_TIMC_EEFCR1_EE1FLTR = ((1UL<<4)-1) << 1, // External Event 1 filter
	HRTIM_TIMC_EEFCR1_EE1LTCH = 1UL<<0, // External Event 1 latch		
};
inline void hrtim_timc_eefcr1_set_ee5fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE5FLTR) | ((val<<25) & HRTIM_TIMC_EEFCR1_EE5FLTR); }
inline void hrtim_timc_eefcr1_set_ee4fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE4FLTR) | ((val<<19) & HRTIM_TIMC_EEFCR1_EE4FLTR); }
inline void hrtim_timc_eefcr1_set_ee3fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE3FLTR) | ((val<<13) & HRTIM_TIMC_EEFCR1_EE3FLTR); }
inline void hrtim_timc_eefcr1_set_ee2fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE2FLTR) | ((val<<7) & HRTIM_TIMC_EEFCR1_EE2FLTR); }
inline void hrtim_timc_eefcr1_set_ee1fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE1FLTR) | ((val<<1) & HRTIM_TIMC_EEFCR1_EE1FLTR); }
inline uint32_t hrtim_timc_eefcr1_get_ee5fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE5FLTR) >> 25 ; }
inline uint32_t hrtim_timc_eefcr1_get_ee4fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE4FLTR) >> 19 ; }
inline uint32_t hrtim_timc_eefcr1_get_ee3fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE3FLTR) >> 13 ; }
inline uint32_t hrtim_timc_eefcr1_get_ee2fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE2FLTR) >> 7 ; }
inline uint32_t hrtim_timc_eefcr1_get_ee1fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE1FLTR) >> 1 ; }

// HRTIM_TIMC->EEFCR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMC_EEFCR2_EE10FLTR = ((1UL<<4)-1) << 25, // External Event 10 filter
	HRTIM_TIMC_EEFCR2_EE10LTCH = 1UL<<24, // External Event 10 latch
	HRTIM_TIMC_EEFCR2_EE9FLTR = ((1UL<<4)-1) << 19, // External Event 9 filter
	HRTIM_TIMC_EEFCR2_EE9LTCH = 1UL<<18, // External Event 9 latch
	HRTIM_TIMC_EEFCR2_EE8FLTR = ((1UL<<4)-1) << 13, // External Event 8 filter
	HRTIM_TIMC_EEFCR2_EE8LTCH = 1UL<<12, // External Event 8 latch
	HRTIM_TIMC_EEFCR2_EE7FLTR = ((1UL<<4)-1) << 7, // External Event 7 filter
	HRTIM_TIMC_EEFCR2_EE7LTCH = 1UL<<6, // External Event 7 latch
	HRTIM_TIMC_EEFCR2_EE6FLTR = ((1UL<<4)-1) << 1, // External Event 6 filter
	HRTIM_TIMC_EEFCR2_EE6LTCH = 1UL<<0, // External Event 6 latch		
};
inline void hrtim_timc_eefcr2_set_ee10fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE10FLTR) | ((val<<25) & HRTIM_TIMC_EEFCR2_EE10FLTR); }
inline void hrtim_timc_eefcr2_set_ee9fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE9FLTR) | ((val<<19) & HRTIM_TIMC_EEFCR2_EE9FLTR); }
inline void hrtim_timc_eefcr2_set_ee8fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE8FLTR) | ((val<<13) & HRTIM_TIMC_EEFCR2_EE8FLTR); }
inline void hrtim_timc_eefcr2_set_ee7fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE7FLTR) | ((val<<7) & HRTIM_TIMC_EEFCR2_EE7FLTR); }
inline void hrtim_timc_eefcr2_set_ee6fltr(struct HRTIM_TIMC_Type* p, uint32_t val) { p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE6FLTR) | ((val<<1) & HRTIM_TIMC_EEFCR2_EE6FLTR); }
inline uint32_t hrtim_timc_eefcr2_get_ee10fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE10FLTR) >> 25 ; }
inline uint32_t hrtim_timc_eefcr2_get_ee9fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE9FLTR) >> 19 ; }
inline uint32_t hrtim_timc_eefcr2_get_ee8fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE8FLTR) >> 13 ; }
inline uint32_t hrtim_timc_eefcr2_get_ee7fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE7FLTR) >> 7 ; }
inline uint32_t hrtim_timc_eefcr2_get_ee6fltr(struct HRTIM_TIMC_Type* p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE6FLTR) >> 1 ; }

// HRTIM_TIMC->RSTCR TimerA Reset Register
enum {
	HRTIM_TIMC_RSTCR_TIMECMP4 = 1UL<<30, // Timer E Compare 4
	HRTIM_TIMC_RSTCR_TIMECMP2 = 1UL<<29, // Timer E Compare 2
	HRTIM_TIMC_RSTCR_TIMECMP1 = 1UL<<28, // Timer E Compare 1
	HRTIM_TIMC_RSTCR_TIMDCMP4 = 1UL<<27, // Timer D Compare 4
	HRTIM_TIMC_RSTCR_TIMDCMP2 = 1UL<<26, // Timer D Compare 2
	HRTIM_TIMC_RSTCR_TIMDCMP1 = 1UL<<25, // Timer D Compare 1
	HRTIM_TIMC_RSTCR_TIMBCMP4 = 1UL<<24, // Timer B Compare 4
	HRTIM_TIMC_RSTCR_TIMBCMP2 = 1UL<<23, // Timer B Compare 2
	HRTIM_TIMC_RSTCR_TIMBCMP1 = 1UL<<22, // Timer B Compare 1
	HRTIM_TIMC_RSTCR_TIMACMP4 = 1UL<<21, // Timer A Compare 4
	HRTIM_TIMC_RSTCR_TIMACMP2 = 1UL<<20, // Timer A Compare 2
	HRTIM_TIMC_RSTCR_TIMACMP1 = 1UL<<19, // Timer A Compare 1
	HRTIM_TIMC_RSTCR_EXTEVNT10 = 1UL<<18, // External Event 10
	HRTIM_TIMC_RSTCR_EXTEVNT9 = 1UL<<17, // External Event 9
	HRTIM_TIMC_RSTCR_EXTEVNT8 = 1UL<<16, // External Event 8
	HRTIM_TIMC_RSTCR_EXTEVNT7 = 1UL<<15, // External Event 7
	HRTIM_TIMC_RSTCR_EXTEVNT6 = 1UL<<14, // External Event 6
	HRTIM_TIMC_RSTCR_EXTEVNT5 = 1UL<<13, // External Event 5
	HRTIM_TIMC_RSTCR_EXTEVNT4 = 1UL<<12, // External Event 4
	HRTIM_TIMC_RSTCR_EXTEVNT3 = 1UL<<11, // External Event 3
	HRTIM_TIMC_RSTCR_EXTEVNT2 = 1UL<<10, // External Event 2
	HRTIM_TIMC_RSTCR_EXTEVNT1 = 1UL<<9, // External Event 1
	HRTIM_TIMC_RSTCR_MSTCMP4 = 1UL<<8, // Master compare 4
	HRTIM_TIMC_RSTCR_MSTCMP3 = 1UL<<7, // Master compare 3
	HRTIM_TIMC_RSTCR_MSTCMP2 = 1UL<<6, // Master compare 2
	HRTIM_TIMC_RSTCR_MSTCMP1 = 1UL<<5, // Master compare 1
	HRTIM_TIMC_RSTCR_MSTPER = 1UL<<4, // Master timer Period
	HRTIM_TIMC_RSTCR_CMP4 = 1UL<<3, // Timer A compare 4 reset
	HRTIM_TIMC_RSTCR_CMP2 = 1UL<<2, // Timer A compare 2 reset
	HRTIM_TIMC_RSTCR_UPDT = 1UL<<1, // Timer A Update reset		
};

// HRTIM_TIMC->CHPCR Timerx Chopper Register
enum {
	HRTIM_TIMC_CHPCR_STRTPW = ((1UL<<4)-1) << 7, // STRTPW
	HRTIM_TIMC_CHPCR_CHPDTY = ((1UL<<3)-1) << 4, // Timerx chopper duty cycle value
	HRTIM_TIMC_CHPCR_CHPFRQ = ((1UL<<4)-1) << 0, // Timerx carrier frequency value		
};
inline void hrtim_timc_chpcr_set_strtpw(struct HRTIM_TIMC_Type* p, uint32_t val) { p->CHPCR = (p->CHPCR & ~HRTIM_TIMC_CHPCR_STRTPW) | ((val<<7) & HRTIM_TIMC_CHPCR_STRTPW); }
inline void hrtim_timc_chpcr_set_chpdty(struct HRTIM_TIMC_Type* p, uint32_t val) { p->CHPCR = (p->CHPCR & ~HRTIM_TIMC_CHPCR_CHPDTY) | ((val<<4) & HRTIM_TIMC_CHPCR_CHPDTY); }
inline void hrtim_timc_chpcr_set_chpfrq(struct HRTIM_TIMC_Type* p, uint32_t val) { p->CHPCR = (p->CHPCR & ~HRTIM_TIMC_CHPCR_CHPFRQ) | ((val<<0) & HRTIM_TIMC_CHPCR_CHPFRQ); }
inline uint32_t hrtim_timc_chpcr_get_strtpw(struct HRTIM_TIMC_Type* p) { return (p->CHPCR & HRTIM_TIMC_CHPCR_STRTPW) >> 7 ; }
inline uint32_t hrtim_timc_chpcr_get_chpdty(struct HRTIM_TIMC_Type* p) { return (p->CHPCR & HRTIM_TIMC_CHPCR_CHPDTY) >> 4 ; }
inline uint32_t hrtim_timc_chpcr_get_chpfrq(struct HRTIM_TIMC_Type* p) { return (p->CHPCR & HRTIM_TIMC_CHPCR_CHPFRQ) >> 0 ; }

// HRTIM_TIMC->CPT1CCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMC_CPT1CCR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMC_CPT1CCR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMC_CPT1CCR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMC_CPT1CCR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMC_CPT1CCR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIMC_CPT1CCR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIMC_CPT1CCR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIMC_CPT1CCR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIMC_CPT1CCR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIMC_CPT1CCR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIMC_CPT1CCR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIMC_CPT1CCR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIMC_CPT1CCR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIMC_CPT1CCR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIMC_CPT1CCR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIMC_CPT1CCR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIMC_CPT1CCR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMC_CPT1CCR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMC_CPT1CCR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMC_CPT1CCR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMC_CPT1CCR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMC_CPT1CCR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMC_CPT1CCR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMC_CPT1CCR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMC_CPT1CCR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMC_CPT1CCR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMC_CPT1CCR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMC_CPT1CCR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMC->CPT2CCR CPT2xCR
enum {
	HRTIM_TIMC_CPT2CCR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMC_CPT2CCR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMC_CPT2CCR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMC_CPT2CCR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMC_CPT2CCR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIMC_CPT2CCR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIMC_CPT2CCR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIMC_CPT2CCR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIMC_CPT2CCR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIMC_CPT2CCR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIMC_CPT2CCR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIMC_CPT2CCR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIMC_CPT2CCR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIMC_CPT2CCR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIMC_CPT2CCR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIMC_CPT2CCR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIMC_CPT2CCR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMC_CPT2CCR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMC_CPT2CCR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMC_CPT2CCR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMC_CPT2CCR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMC_CPT2CCR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMC_CPT2CCR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMC_CPT2CCR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMC_CPT2CCR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMC_CPT2CCR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMC_CPT2CCR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMC_CPT2CCR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMC->OUTCR Timerx Output Register
enum {
	HRTIM_TIMC_OUTCR_DIDL2 = 1UL<<23, // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMC_OUTCR_CHP2 = 1UL<<22, // Output 2 Chopper enable
	HRTIM_TIMC_OUTCR_FAULT2 = ((1UL<<2)-1) << 20, // Output 2 Fault state
	HRTIM_TIMC_OUTCR_IDLES2 = 1UL<<19, // Output 2 Idle State
	HRTIM_TIMC_OUTCR_IDLEM2 = 1UL<<18, // Output 2 Idle mode
	HRTIM_TIMC_OUTCR_POL2 = 1UL<<17, // Output 2 polarity
	HRTIM_TIMC_OUTCR_DLYPRT = ((1UL<<3)-1) << 10, // Delayed Protection
	HRTIM_TIMC_OUTCR_DLYPRTEN = 1UL<<9, // Delayed Protection Enable
	HRTIM_TIMC_OUTCR_DTEN = 1UL<<8, // Deadtime enable
	HRTIM_TIMC_OUTCR_DIDL1 = 1UL<<7, // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMC_OUTCR_CHP1 = 1UL<<6, // Output 1 Chopper enable
	HRTIM_TIMC_OUTCR_FAULT1 = ((1UL<<2)-1) << 4, // Output 1 Fault state
	HRTIM_TIMC_OUTCR_IDLES1 = 1UL<<3, // Output 1 Idle State
	HRTIM_TIMC_OUTCR_IDLEM1 = 1UL<<2, // Output 1 Idle mode
	HRTIM_TIMC_OUTCR_POL1 = 1UL<<1, // Output 1 polarity		
};
inline void hrtim_timc_outcr_set_fault2(struct HRTIM_TIMC_Type* p, uint32_t val) { p->OUTCR = (p->OUTCR & ~HRTIM_TIMC_OUTCR_FAULT2) | ((val<<20) & HRTIM_TIMC_OUTCR_FAULT2); }
inline void hrtim_timc_outcr_set_dlyprt(struct HRTIM_TIMC_Type* p, uint32_t val) { p->OUTCR = (p->OUTCR & ~HRTIM_TIMC_OUTCR_DLYPRT) | ((val<<10) & HRTIM_TIMC_OUTCR_DLYPRT); }
inline void hrtim_timc_outcr_set_fault1(struct HRTIM_TIMC_Type* p, uint32_t val) { p->OUTCR = (p->OUTCR & ~HRTIM_TIMC_OUTCR_FAULT1) | ((val<<4) & HRTIM_TIMC_OUTCR_FAULT1); }
inline uint32_t hrtim_timc_outcr_get_fault2(struct HRTIM_TIMC_Type* p) { return (p->OUTCR & HRTIM_TIMC_OUTCR_FAULT2) >> 20 ; }
inline uint32_t hrtim_timc_outcr_get_dlyprt(struct HRTIM_TIMC_Type* p) { return (p->OUTCR & HRTIM_TIMC_OUTCR_DLYPRT) >> 10 ; }
inline uint32_t hrtim_timc_outcr_get_fault1(struct HRTIM_TIMC_Type* p) { return (p->OUTCR & HRTIM_TIMC_OUTCR_FAULT1) >> 4 ; }

// HRTIM_TIMC->FLTCR Timerx Fault Register
enum {
	HRTIM_TIMC_FLTCR_FLTLCK = 1UL<<31, // Fault sources Lock
	HRTIM_TIMC_FLTCR_FLT5EN = 1UL<<4, // Fault 5 enable
	HRTIM_TIMC_FLTCR_FLT4EN = 1UL<<3, // Fault 4 enable
	HRTIM_TIMC_FLTCR_FLT3EN = 1UL<<2, // Fault 3 enable
	HRTIM_TIMC_FLTCR_FLT2EN = 1UL<<1, // Fault 2 enable
	HRTIM_TIMC_FLTCR_FLT1EN = 1UL<<0, // Fault 1 enable		
};

/* High Resolution Timer: TIMD */
struct HRTIM_TIMD_Type {
	__IO uint32_t TIMDCR; // @0 Timerx Control Register
	__I uint32_t TIMDISR; // @4 Timerx Interrupt Status Register
	__O uint16_t TIMDICR; // @8 Timerx Interrupt Clear Register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t TIMDDIER5; // @12 TIMxDIER5
	__IO uint16_t CNTDR; // @16 Timerx Counter Register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t PERDR; // @20 Timerx Period Register
	 uint8_t RESERVED2[2]; // @22 
	__IO uint8_t REPDR; // @24 Timerx Repetition Register
	 uint8_t RESERVED3[3]; // @25 
	__IO uint16_t CMP1DR; // @28 Timerx Compare 1 Register
	 uint8_t RESERVED4[2]; // @30 
	__IO uint32_t CMP1CDR; // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2DR; // @36 Timerx Compare 2 Register
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t CMP3DR; // @40 Timerx Compare 3 Register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t CMP4DR; // @44 Timerx Compare 4 Register
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t CPT1DR; // @48 Timerx Capture 1 Register
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t CPT2DR; // @52 Timerx Capture 2 Register
	 uint8_t RESERVED9[2]; // @54 
	__IO uint32_t DTDR; // @56 Timerx Deadtime Register
	__IO uint32_t SETD1R; // @60 Timerx Output1 Set Register
	__IO uint32_t RSTD1R; // @64 Timerx Output1 Reset Register
	__IO uint32_t SETD2R; // @68 Timerx Output2 Set Register
	__IO uint32_t RSTD2R; // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFDR1; // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFDR2; // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTDR; // @84 TimerA Reset Register
	__IO uint16_t CHPDR; // @88 Timerx Chopper Register
	 uint8_t RESERVED10[2]; // @90 
	__IO uint32_t CPT1DCR; // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2DCR; // @96 CPT2xCR
	__IO uint32_t OUTDR; // @100 Timerx Output Register
	__IO uint32_t FLTDR; // @104 Timerx Fault Register
};

// HRTIM_TIMD->TIMDCR Timerx Control Register
enum {
	HRTIM_TIMD_TIMDCR_UPDGAT = ((1UL<<4)-1) << 28, // Update Gating
	HRTIM_TIMD_TIMDCR_PREEN = 1UL<<27, // Preload enable
	HRTIM_TIMD_TIMDCR_DACSYNC = ((1UL<<2)-1) << 25, // AC Synchronization
	HRTIM_TIMD_TIMDCR_MSTU = 1UL<<24, // Master Timer update
	HRTIM_TIMD_TIMDCR_TEU = 1UL<<23, // TEU
	HRTIM_TIMD_TIMDCR_TDU = 1UL<<22, // TDU
	HRTIM_TIMD_TIMDCR_TCU = 1UL<<21, // TCU
	HRTIM_TIMD_TIMDCR_TBU = 1UL<<20, // TBU
	HRTIM_TIMD_TIMDCR_TXRSTU = 1UL<<18, // Timerx reset update
	HRTIM_TIMD_TIMDCR_TXREPU = 1UL<<17, // Timer x Repetition update
	HRTIM_TIMD_TIMDCR_DELCMP4 = ((1UL<<2)-1) << 14, // Delayed CMP4 mode
	HRTIM_TIMD_TIMDCR_DELCMP2 = ((1UL<<2)-1) << 12, // Delayed CMP2 mode
	HRTIM_TIMD_TIMDCR_SYNCSTRTX = 1UL<<11, // Synchronization Starts Timer x
	HRTIM_TIMD_TIMDCR_SYNCRSTX = 1UL<<10, // Synchronization Resets Timer x
	HRTIM_TIMD_TIMDCR_PSHPLL = 1UL<<6, // Push-Pull mode enable
	HRTIM_TIMD_TIMDCR_HALF = 1UL<<5, // Half mode enable
	HRTIM_TIMD_TIMDCR_RETRIG = 1UL<<4, // Re-triggerable mode
	HRTIM_TIMD_TIMDCR_CONT = 1UL<<3, // Continuous mode
	HRTIM_TIMD_TIMDCR_CK_PSCX = ((1UL<<3)-1) << 0, // HRTIM Timer x Clock prescaler		
};
inline void hrtim_timd_timdcr_set_updgat(struct HRTIM_TIMD_Type* p, uint32_t val) { p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_UPDGAT) | ((val<<28) & HRTIM_TIMD_TIMDCR_UPDGAT); }
inline void hrtim_timd_timdcr_set_dacsync(struct HRTIM_TIMD_Type* p, uint32_t val) { p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_DACSYNC) | ((val<<25) & HRTIM_TIMD_TIMDCR_DACSYNC); }
inline void hrtim_timd_timdcr_set_delcmp4(struct HRTIM_TIMD_Type* p, uint32_t val) { p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_DELCMP4) | ((val<<14) & HRTIM_TIMD_TIMDCR_DELCMP4); }
inline void hrtim_timd_timdcr_set_delcmp2(struct HRTIM_TIMD_Type* p, uint32_t val) { p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_DELCMP2) | ((val<<12) & HRTIM_TIMD_TIMDCR_DELCMP2); }
inline void hrtim_timd_timdcr_set_ck_pscx(struct HRTIM_TIMD_Type* p, uint32_t val) { p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_CK_PSCX) | ((val<<0) & HRTIM_TIMD_TIMDCR_CK_PSCX); }
inline uint32_t hrtim_timd_timdcr_get_updgat(struct HRTIM_TIMD_Type* p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_UPDGAT) >> 28 ; }
inline uint32_t hrtim_timd_timdcr_get_dacsync(struct HRTIM_TIMD_Type* p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_DACSYNC) >> 25 ; }
inline uint32_t hrtim_timd_timdcr_get_delcmp4(struct HRTIM_TIMD_Type* p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_DELCMP4) >> 14 ; }
inline uint32_t hrtim_timd_timdcr_get_delcmp2(struct HRTIM_TIMD_Type* p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_DELCMP2) >> 12 ; }
inline uint32_t hrtim_timd_timdcr_get_ck_pscx(struct HRTIM_TIMD_Type* p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_CK_PSCX) >> 0 ; }

// HRTIM_TIMD->TIMDISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMD_TIMDISR_O2STAT = 1UL<<19, // Output 2 State
	HRTIM_TIMD_TIMDISR_O1STAT = 1UL<<18, // Output 1 State
	HRTIM_TIMD_TIMDISR_IPPSTAT = 1UL<<17, // Idle Push Pull Status
	HRTIM_TIMD_TIMDISR_CPPSTAT = 1UL<<16, // Current Push Pull Status
	HRTIM_TIMD_TIMDISR_DLYPRT = 1UL<<14, // Delayed Protection Flag
	HRTIM_TIMD_TIMDISR_RST = 1UL<<13, // Reset Interrupt Flag
	HRTIM_TIMD_TIMDISR_RSTX2 = 1UL<<12, // Output 2 Reset Interrupt Flag
	HRTIM_TIMD_TIMDISR_SETX2 = 1UL<<11, // Output 2 Set Interrupt Flag
	HRTIM_TIMD_TIMDISR_RSTX1 = 1UL<<10, // Output 1 Reset Interrupt Flag
	HRTIM_TIMD_TIMDISR_SETX1 = 1UL<<9, // Output 1 Set Interrupt Flag
	HRTIM_TIMD_TIMDISR_CPT2 = 1UL<<8, // Capture2 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CPT1 = 1UL<<7, // Capture1 Interrupt Flag
	HRTIM_TIMD_TIMDISR_UPD = 1UL<<6, // Update Interrupt Flag
	HRTIM_TIMD_TIMDISR_REP = 1UL<<4, // Repetition Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP4 = 1UL<<3, // Compare 4 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP3 = 1UL<<2, // Compare 3 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP2 = 1UL<<1, // Compare 2 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP1 = 1UL<<0, // Compare 1 Interrupt Flag		
};

// HRTIM_TIMD->TIMDICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMD_TIMDICR_DLYPRTC = 1UL<<14, // Delayed Protection Flag Clear
	HRTIM_TIMD_TIMDICR_RSTC = 1UL<<13, // Reset Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_RSTX2C = 1UL<<12, // Output 2 Reset flag Clear
	HRTIM_TIMD_TIMDICR_SET2XC = 1UL<<11, // Output 2 Set flag Clear
	HRTIM_TIMD_TIMDICR_RSTX1C = 1UL<<10, // Output 1 Reset flag Clear
	HRTIM_TIMD_TIMDICR_SET1XC = 1UL<<9, // Output 1 Set flag Clear
	HRTIM_TIMD_TIMDICR_CPT2C = 1UL<<8, // Capture2 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CPT1C = 1UL<<7, // Capture1 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_UPDC = 1UL<<6, // Update Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_REPC = 1UL<<4, // Repetition Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP4C = 1UL<<3, // Compare 4 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP3C = 1UL<<2, // Compare 3 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP2C = 1UL<<1, // Compare 2 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP1C = 1UL<<0, // Compare 1 Interrupt flag Clear		
};

// HRTIM_TIMD->TIMDDIER5 TIMxDIER5
enum {
	HRTIM_TIMD_TIMDDIER5_DLYPRTDE = 1UL<<30, // DLYPRTDE
	HRTIM_TIMD_TIMDDIER5_RSTDE = 1UL<<29, // RSTDE
	HRTIM_TIMD_TIMDDIER5_RSTX2DE = 1UL<<28, // RSTx2DE
	HRTIM_TIMD_TIMDDIER5_SETX2DE = 1UL<<27, // SETx2DE
	HRTIM_TIMD_TIMDDIER5_RSTX1DE = 1UL<<26, // RSTx1DE
	HRTIM_TIMD_TIMDDIER5_SET1XDE = 1UL<<25, // SET1xDE
	HRTIM_TIMD_TIMDDIER5_CPT2DE = 1UL<<24, // CPT2DE
	HRTIM_TIMD_TIMDDIER5_CPT1DE = 1UL<<23, // CPT1DE
	HRTIM_TIMD_TIMDDIER5_UPDDE = 1UL<<22, // UPDDE
	HRTIM_TIMD_TIMDDIER5_REPDE = 1UL<<20, // REPDE
	HRTIM_TIMD_TIMDDIER5_CMP4DE = 1UL<<19, // CMP4DE
	HRTIM_TIMD_TIMDDIER5_CMP3DE = 1UL<<18, // CMP3DE
	HRTIM_TIMD_TIMDDIER5_CMP2DE = 1UL<<17, // CMP2DE
	HRTIM_TIMD_TIMDDIER5_CMP1DE = 1UL<<16, // CMP1DE
	HRTIM_TIMD_TIMDDIER5_DLYPRTIE = 1UL<<14, // DLYPRTIE
	HRTIM_TIMD_TIMDDIER5_RSTIE = 1UL<<13, // RSTIE
	HRTIM_TIMD_TIMDDIER5_RSTX2IE = 1UL<<12, // RSTx2IE
	HRTIM_TIMD_TIMDDIER5_SETX2IE = 1UL<<11, // SETx2IE
	HRTIM_TIMD_TIMDDIER5_RSTX1IE = 1UL<<10, // RSTx1IE
	HRTIM_TIMD_TIMDDIER5_SET1XIE = 1UL<<9, // SET1xIE
	HRTIM_TIMD_TIMDDIER5_CPT2IE = 1UL<<8, // CPT2IE
	HRTIM_TIMD_TIMDDIER5_CPT1IE = 1UL<<7, // CPT1IE
	HRTIM_TIMD_TIMDDIER5_UPDIE = 1UL<<6, // UPDIE
	HRTIM_TIMD_TIMDDIER5_REPIE = 1UL<<4, // REPIE
	HRTIM_TIMD_TIMDDIER5_CMP4IE = 1UL<<3, // CMP4IE
	HRTIM_TIMD_TIMDDIER5_CMP3IE = 1UL<<2, // CMP3IE
	HRTIM_TIMD_TIMDDIER5_CMP2IE = 1UL<<1, // CMP2IE
	HRTIM_TIMD_TIMDDIER5_CMP1IE = 1UL<<0, // CMP1IE		
};

// HRTIM_TIMD->CMP1CDR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMD_CMP1CDR_REPX = ((1UL<<8)-1) << 16, // Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMD_CMP1CDR_CMP1X = ((1UL<<16)-1) << 0, // Timerx Compare 1 value		
};
inline void hrtim_timd_cmp1cdr_set_repx(struct HRTIM_TIMD_Type* p, uint32_t val) { p->CMP1CDR = (p->CMP1CDR & ~HRTIM_TIMD_CMP1CDR_REPX) | ((val<<16) & HRTIM_TIMD_CMP1CDR_REPX); }
inline void hrtim_timd_cmp1cdr_set_cmp1x(struct HRTIM_TIMD_Type* p, uint32_t val) { p->CMP1CDR = (p->CMP1CDR & ~HRTIM_TIMD_CMP1CDR_CMP1X) | ((val<<0) & HRTIM_TIMD_CMP1CDR_CMP1X); }
inline uint32_t hrtim_timd_cmp1cdr_get_repx(struct HRTIM_TIMD_Type* p) { return (p->CMP1CDR & HRTIM_TIMD_CMP1CDR_REPX) >> 16 ; }
inline uint32_t hrtim_timd_cmp1cdr_get_cmp1x(struct HRTIM_TIMD_Type* p) { return (p->CMP1CDR & HRTIM_TIMD_CMP1CDR_CMP1X) >> 0 ; }

// HRTIM_TIMD->DTDR Timerx Deadtime Register
enum {
	HRTIM_TIMD_DTDR_DTFLKX = 1UL<<31, // Deadtime Falling Lock
	HRTIM_TIMD_DTDR_DTFSLKX = 1UL<<30, // Deadtime Falling Sign Lock
	HRTIM_TIMD_DTDR_SDTFX = 1UL<<25, // Sign Deadtime Falling value
	HRTIM_TIMD_DTDR_DTFX = ((1UL<<9)-1) << 16, // Deadtime Falling value
	HRTIM_TIMD_DTDR_DTRLKX = 1UL<<15, // Deadtime Rising Lock
	HRTIM_TIMD_DTDR_DTRSLKX = 1UL<<14, // Deadtime Rising Sign Lock
	HRTIM_TIMD_DTDR_DTPRSC = ((1UL<<3)-1) << 10, // Deadtime Prescaler
	HRTIM_TIMD_DTDR_SDTRX = 1UL<<9, // Sign Deadtime Rising value
	HRTIM_TIMD_DTDR_DTRX = ((1UL<<9)-1) << 0, // Deadtime Rising value		
};
inline void hrtim_timd_dtdr_set_dtfx(struct HRTIM_TIMD_Type* p, uint32_t val) { p->DTDR = (p->DTDR & ~HRTIM_TIMD_DTDR_DTFX) | ((val<<16) & HRTIM_TIMD_DTDR_DTFX); }
inline void hrtim_timd_dtdr_set_dtprsc(struct HRTIM_TIMD_Type* p, uint32_t val) { p->DTDR = (p->DTDR & ~HRTIM_TIMD_DTDR_DTPRSC) | ((val<<10) & HRTIM_TIMD_DTDR_DTPRSC); }
inline void hrtim_timd_dtdr_set_dtrx(struct HRTIM_TIMD_Type* p, uint32_t val) { p->DTDR = (p->DTDR & ~HRTIM_TIMD_DTDR_DTRX) | ((val<<0) & HRTIM_TIMD_DTDR_DTRX); }
inline uint32_t hrtim_timd_dtdr_get_dtfx(struct HRTIM_TIMD_Type* p) { return (p->DTDR & HRTIM_TIMD_DTDR_DTFX) >> 16 ; }
inline uint32_t hrtim_timd_dtdr_get_dtprsc(struct HRTIM_TIMD_Type* p) { return (p->DTDR & HRTIM_TIMD_DTDR_DTPRSC) >> 10 ; }
inline uint32_t hrtim_timd_dtdr_get_dtrx(struct HRTIM_TIMD_Type* p) { return (p->DTDR & HRTIM_TIMD_DTDR_DTRX) >> 0 ; }

// HRTIM_TIMD->SETD1R Timerx Output1 Set Register
enum {
	HRTIM_TIMD_SETD1R_UPDATE = 1UL<<31, // Registers update (transfer preload to active)
	HRTIM_TIMD_SETD1R_EXTEVNT10 = 1UL<<30, // External Event 10
	HRTIM_TIMD_SETD1R_EXTEVNT9 = 1UL<<29, // External Event 9
	HRTIM_TIMD_SETD1R_EXTEVNT8 = 1UL<<28, // External Event 8
	HRTIM_TIMD_SETD1R_EXTEVNT7 = 1UL<<27, // External Event 7
	HRTIM_TIMD_SETD1R_EXTEVNT6 = 1UL<<26, // External Event 6
	HRTIM_TIMD_SETD1R_EXTEVNT5 = 1UL<<25, // External Event 5
	HRTIM_TIMD_SETD1R_EXTEVNT4 = 1UL<<24, // External Event 4
	HRTIM_TIMD_SETD1R_EXTEVNT3 = 1UL<<23, // External Event 3
	HRTIM_TIMD_SETD1R_EXTEVNT2 = 1UL<<22, // External Event 2
	HRTIM_TIMD_SETD1R_EXTEVNT1 = 1UL<<21, // External Event 1
	HRTIM_TIMD_SETD1R_TIMEVNT9 = 1UL<<20, // Timer Event 9
	HRTIM_TIMD_SETD1R_TIMEVNT8 = 1UL<<19, // Timer Event 8
	HRTIM_TIMD_SETD1R_TIMEVNT7 = 1UL<<18, // Timer Event 7
	HRTIM_TIMD_SETD1R_TIMEVNT6 = 1UL<<17, // Timer Event 6
	HRTIM_TIMD_SETD1R_TIMEVNT5 = 1UL<<16, // Timer Event 5
	HRTIM_TIMD_SETD1R_TIMEVNT4 = 1UL<<15, // Timer Event 4
	HRTIM_TIMD_SETD1R_TIMEVNT3 = 1UL<<14, // Timer Event 3
	HRTIM_TIMD_SETD1R_TIMEVNT2 = 1UL<<13, // Timer Event 2
	HRTIM_TIMD_SETD1R_TIMEVNT1 = 1UL<<12, // Timer Event 1
	HRTIM_TIMD_SETD1R_MSTCMP4 = 1UL<<11, // Master Compare 4
	HRTIM_TIMD_SETD1R_MSTCMP3 = 1UL<<10, // Master Compare 3
	HRTIM_TIMD_SETD1R_MSTCMP2 = 1UL<<9, // Master Compare 2
	HRTIM_TIMD_SETD1R_MSTCMP1 = 1UL<<8, // Master Compare 1
	HRTIM_TIMD_SETD1R_MSTPER = 1UL<<7, // Master Period
	HRTIM_TIMD_SETD1R_CMP4 = 1UL<<6, // Timer A compare 4
	HRTIM_TIMD_SETD1R_CMP3 = 1UL<<5, // Timer A compare 3
	HRTIM_TIMD_SETD1R_CMP2 = 1UL<<4, // Timer A compare 2
	HRTIM_TIMD_SETD1R_CMP1 = 1UL<<3, // Timer A compare 1
	HRTIM_TIMD_SETD1R_PER = 1UL<<2, // Timer A Period
	HRTIM_TIMD_SETD1R_RESYNC = 1UL<<1, // Timer A resynchronizaton
	HRTIM_TIMD_SETD1R_SST = 1UL<<0, // Software Set trigger		
};

// HRTIM_TIMD->RSTD1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMD_RSTD1R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMD_RSTD1R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMD_RSTD1R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMD_RSTD1R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMD_RSTD1R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMD_RSTD1R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMD_RSTD1R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMD_RSTD1R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMD_RSTD1R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMD_RSTD1R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMD_RSTD1R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMD_RSTD1R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMD_RSTD1R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMD_RSTD1R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMD_RSTD1R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMD_RSTD1R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMD_RSTD1R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMD_RSTD1R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMD_RSTD1R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMD_RSTD1R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMD_RSTD1R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMD_RSTD1R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMD_RSTD1R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMD_RSTD1R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMD_RSTD1R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMD_RSTD1R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMD_RSTD1R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMD_RSTD1R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMD_RSTD1R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMD_RSTD1R_PER = 1UL<<2, // PER
	HRTIM_TIMD_RSTD1R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMD_RSTD1R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMD->SETD2R Timerx Output2 Set Register
enum {
	HRTIM_TIMD_SETD2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMD_SETD2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMD_SETD2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMD_SETD2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMD_SETD2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMD_SETD2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMD_SETD2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMD_SETD2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMD_SETD2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMD_SETD2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMD_SETD2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMD_SETD2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMD_SETD2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMD_SETD2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMD_SETD2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMD_SETD2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMD_SETD2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMD_SETD2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMD_SETD2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMD_SETD2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMD_SETD2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMD_SETD2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMD_SETD2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMD_SETD2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMD_SETD2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMD_SETD2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMD_SETD2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMD_SETD2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMD_SETD2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMD_SETD2R_PER = 1UL<<2, // PER
	HRTIM_TIMD_SETD2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMD_SETD2R_SST = 1UL<<0, // SST		
};

// HRTIM_TIMD->RSTD2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMD_RSTD2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIMD_RSTD2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIMD_RSTD2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIMD_RSTD2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIMD_RSTD2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIMD_RSTD2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIMD_RSTD2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIMD_RSTD2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIMD_RSTD2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIMD_RSTD2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIMD_RSTD2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIMD_RSTD2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIMD_RSTD2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIMD_RSTD2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIMD_RSTD2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIMD_RSTD2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIMD_RSTD2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIMD_RSTD2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIMD_RSTD2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIMD_RSTD2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIMD_RSTD2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIMD_RSTD2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIMD_RSTD2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIMD_RSTD2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIMD_RSTD2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIMD_RSTD2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIMD_RSTD2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIMD_RSTD2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIMD_RSTD2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIMD_RSTD2R_PER = 1UL<<2, // PER
	HRTIM_TIMD_RSTD2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIMD_RSTD2R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIMD->EEFDR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMD_EEFDR1_EE5FLTR = ((1UL<<4)-1) << 25, // External Event 5 filter
	HRTIM_TIMD_EEFDR1_EE5LTCH = 1UL<<24, // External Event 5 latch
	HRTIM_TIMD_EEFDR1_EE4FLTR = ((1UL<<4)-1) << 19, // External Event 4 filter
	HRTIM_TIMD_EEFDR1_EE4LTCH = 1UL<<18, // External Event 4 latch
	HRTIM_TIMD_EEFDR1_EE3FLTR = ((1UL<<4)-1) << 13, // External Event 3 filter
	HRTIM_TIMD_EEFDR1_EE3LTCH = 1UL<<12, // External Event 3 latch
	HRTIM_TIMD_EEFDR1_EE2FLTR = ((1UL<<4)-1) << 7, // External Event 2 filter
	HRTIM_TIMD_EEFDR1_EE2LTCH = 1UL<<6, // External Event 2 latch
	HRTIM_TIMD_EEFDR1_EE1FLTR = ((1UL<<4)-1) << 1, // External Event 1 filter
	HRTIM_TIMD_EEFDR1_EE1LTCH = 1UL<<0, // External Event 1 latch		
};
inline void hrtim_timd_eefdr1_set_ee5fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE5FLTR) | ((val<<25) & HRTIM_TIMD_EEFDR1_EE5FLTR); }
inline void hrtim_timd_eefdr1_set_ee4fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE4FLTR) | ((val<<19) & HRTIM_TIMD_EEFDR1_EE4FLTR); }
inline void hrtim_timd_eefdr1_set_ee3fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE3FLTR) | ((val<<13) & HRTIM_TIMD_EEFDR1_EE3FLTR); }
inline void hrtim_timd_eefdr1_set_ee2fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE2FLTR) | ((val<<7) & HRTIM_TIMD_EEFDR1_EE2FLTR); }
inline void hrtim_timd_eefdr1_set_ee1fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE1FLTR) | ((val<<1) & HRTIM_TIMD_EEFDR1_EE1FLTR); }
inline uint32_t hrtim_timd_eefdr1_get_ee5fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE5FLTR) >> 25 ; }
inline uint32_t hrtim_timd_eefdr1_get_ee4fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE4FLTR) >> 19 ; }
inline uint32_t hrtim_timd_eefdr1_get_ee3fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE3FLTR) >> 13 ; }
inline uint32_t hrtim_timd_eefdr1_get_ee2fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE2FLTR) >> 7 ; }
inline uint32_t hrtim_timd_eefdr1_get_ee1fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE1FLTR) >> 1 ; }

// HRTIM_TIMD->EEFDR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMD_EEFDR2_EE10FLTR = ((1UL<<4)-1) << 25, // External Event 10 filter
	HRTIM_TIMD_EEFDR2_EE10LTCH = 1UL<<24, // External Event 10 latch
	HRTIM_TIMD_EEFDR2_EE9FLTR = ((1UL<<4)-1) << 19, // External Event 9 filter
	HRTIM_TIMD_EEFDR2_EE9LTCH = 1UL<<18, // External Event 9 latch
	HRTIM_TIMD_EEFDR2_EE8FLTR = ((1UL<<4)-1) << 13, // External Event 8 filter
	HRTIM_TIMD_EEFDR2_EE8LTCH = 1UL<<12, // External Event 8 latch
	HRTIM_TIMD_EEFDR2_EE7FLTR = ((1UL<<4)-1) << 7, // External Event 7 filter
	HRTIM_TIMD_EEFDR2_EE7LTCH = 1UL<<6, // External Event 7 latch
	HRTIM_TIMD_EEFDR2_EE6FLTR = ((1UL<<4)-1) << 1, // External Event 6 filter
	HRTIM_TIMD_EEFDR2_EE6LTCH = 1UL<<0, // External Event 6 latch		
};
inline void hrtim_timd_eefdr2_set_ee10fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE10FLTR) | ((val<<25) & HRTIM_TIMD_EEFDR2_EE10FLTR); }
inline void hrtim_timd_eefdr2_set_ee9fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE9FLTR) | ((val<<19) & HRTIM_TIMD_EEFDR2_EE9FLTR); }
inline void hrtim_timd_eefdr2_set_ee8fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE8FLTR) | ((val<<13) & HRTIM_TIMD_EEFDR2_EE8FLTR); }
inline void hrtim_timd_eefdr2_set_ee7fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE7FLTR) | ((val<<7) & HRTIM_TIMD_EEFDR2_EE7FLTR); }
inline void hrtim_timd_eefdr2_set_ee6fltr(struct HRTIM_TIMD_Type* p, uint32_t val) { p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE6FLTR) | ((val<<1) & HRTIM_TIMD_EEFDR2_EE6FLTR); }
inline uint32_t hrtim_timd_eefdr2_get_ee10fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE10FLTR) >> 25 ; }
inline uint32_t hrtim_timd_eefdr2_get_ee9fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE9FLTR) >> 19 ; }
inline uint32_t hrtim_timd_eefdr2_get_ee8fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE8FLTR) >> 13 ; }
inline uint32_t hrtim_timd_eefdr2_get_ee7fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE7FLTR) >> 7 ; }
inline uint32_t hrtim_timd_eefdr2_get_ee6fltr(struct HRTIM_TIMD_Type* p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE6FLTR) >> 1 ; }

// HRTIM_TIMD->RSTDR TimerA Reset Register
enum {
	HRTIM_TIMD_RSTDR_TIMECMP4 = 1UL<<30, // Timer E Compare 4
	HRTIM_TIMD_RSTDR_TIMECMP2 = 1UL<<29, // Timer E Compare 2
	HRTIM_TIMD_RSTDR_TIMECMP1 = 1UL<<28, // Timer E Compare 1
	HRTIM_TIMD_RSTDR_TIMCCMP4 = 1UL<<27, // Timer C Compare 4
	HRTIM_TIMD_RSTDR_TIMCCMP2 = 1UL<<26, // Timer C Compare 2
	HRTIM_TIMD_RSTDR_TIMCCMP1 = 1UL<<25, // Timer C Compare 1
	HRTIM_TIMD_RSTDR_TIMBCMP4 = 1UL<<24, // Timer B Compare 4
	HRTIM_TIMD_RSTDR_TIMBCMP2 = 1UL<<23, // Timer B Compare 2
	HRTIM_TIMD_RSTDR_TIMBCMP1 = 1UL<<22, // Timer B Compare 1
	HRTIM_TIMD_RSTDR_TIMACMP4 = 1UL<<21, // Timer A Compare 4
	HRTIM_TIMD_RSTDR_TIMACMP2 = 1UL<<20, // Timer A Compare 2
	HRTIM_TIMD_RSTDR_TIMACMP1 = 1UL<<19, // Timer A Compare 1
	HRTIM_TIMD_RSTDR_EXTEVNT10 = 1UL<<18, // External Event 10
	HRTIM_TIMD_RSTDR_EXTEVNT9 = 1UL<<17, // External Event 9
	HRTIM_TIMD_RSTDR_EXTEVNT8 = 1UL<<16, // External Event 8
	HRTIM_TIMD_RSTDR_EXTEVNT7 = 1UL<<15, // External Event 7
	HRTIM_TIMD_RSTDR_EXTEVNT6 = 1UL<<14, // External Event 6
	HRTIM_TIMD_RSTDR_EXTEVNT5 = 1UL<<13, // External Event 5
	HRTIM_TIMD_RSTDR_EXTEVNT4 = 1UL<<12, // External Event 4
	HRTIM_TIMD_RSTDR_EXTEVNT3 = 1UL<<11, // External Event 3
	HRTIM_TIMD_RSTDR_EXTEVNT2 = 1UL<<10, // External Event 2
	HRTIM_TIMD_RSTDR_EXTEVNT1 = 1UL<<9, // External Event 1
	HRTIM_TIMD_RSTDR_MSTCMP4 = 1UL<<8, // Master compare 4
	HRTIM_TIMD_RSTDR_MSTCMP3 = 1UL<<7, // Master compare 3
	HRTIM_TIMD_RSTDR_MSTCMP2 = 1UL<<6, // Master compare 2
	HRTIM_TIMD_RSTDR_MSTCMP1 = 1UL<<5, // Master compare 1
	HRTIM_TIMD_RSTDR_MSTPER = 1UL<<4, // Master timer Period
	HRTIM_TIMD_RSTDR_CMP4 = 1UL<<3, // Timer A compare 4 reset
	HRTIM_TIMD_RSTDR_CMP2 = 1UL<<2, // Timer A compare 2 reset
	HRTIM_TIMD_RSTDR_UPDT = 1UL<<1, // Timer A Update reset		
};

// HRTIM_TIMD->CHPDR Timerx Chopper Register
enum {
	HRTIM_TIMD_CHPDR_STRTPW = ((1UL<<4)-1) << 7, // STRTPW
	HRTIM_TIMD_CHPDR_CHPDTY = ((1UL<<3)-1) << 4, // Timerx chopper duty cycle value
	HRTIM_TIMD_CHPDR_CHPFRQ = ((1UL<<4)-1) << 0, // Timerx carrier frequency value		
};
inline void hrtim_timd_chpdr_set_strtpw(struct HRTIM_TIMD_Type* p, uint32_t val) { p->CHPDR = (p->CHPDR & ~HRTIM_TIMD_CHPDR_STRTPW) | ((val<<7) & HRTIM_TIMD_CHPDR_STRTPW); }
inline void hrtim_timd_chpdr_set_chpdty(struct HRTIM_TIMD_Type* p, uint32_t val) { p->CHPDR = (p->CHPDR & ~HRTIM_TIMD_CHPDR_CHPDTY) | ((val<<4) & HRTIM_TIMD_CHPDR_CHPDTY); }
inline void hrtim_timd_chpdr_set_chpfrq(struct HRTIM_TIMD_Type* p, uint32_t val) { p->CHPDR = (p->CHPDR & ~HRTIM_TIMD_CHPDR_CHPFRQ) | ((val<<0) & HRTIM_TIMD_CHPDR_CHPFRQ); }
inline uint32_t hrtim_timd_chpdr_get_strtpw(struct HRTIM_TIMD_Type* p) { return (p->CHPDR & HRTIM_TIMD_CHPDR_STRTPW) >> 7 ; }
inline uint32_t hrtim_timd_chpdr_get_chpdty(struct HRTIM_TIMD_Type* p) { return (p->CHPDR & HRTIM_TIMD_CHPDR_CHPDTY) >> 4 ; }
inline uint32_t hrtim_timd_chpdr_get_chpfrq(struct HRTIM_TIMD_Type* p) { return (p->CHPDR & HRTIM_TIMD_CHPDR_CHPFRQ) >> 0 ; }

// HRTIM_TIMD->CPT1DCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMD_CPT1DCR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMD_CPT1DCR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMD_CPT1DCR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMD_CPT1DCR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMD_CPT1DCR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMD_CPT1DCR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMD_CPT1DCR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIMD_CPT1DCR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIMD_CPT1DCR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIMD_CPT1DCR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIMD_CPT1DCR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIMD_CPT1DCR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIMD_CPT1DCR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIMD_CPT1DCR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIMD_CPT1DCR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIMD_CPT1DCR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIMD_CPT1DCR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMD_CPT1DCR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMD_CPT1DCR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMD_CPT1DCR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMD_CPT1DCR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMD_CPT1DCR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMD_CPT1DCR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMD_CPT1DCR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMD_CPT1DCR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMD_CPT1DCR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMD_CPT1DCR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMD_CPT1DCR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMD->CPT2DCR CPT2xCR
enum {
	HRTIM_TIMD_CPT2DCR_TECMP2 = 1UL<<31, // Timer E Compare 2
	HRTIM_TIMD_CPT2DCR_TECMP1 = 1UL<<30, // Timer E Compare 1
	HRTIM_TIMD_CPT2DCR_TE1RST = 1UL<<29, // Timer E output 1 Reset
	HRTIM_TIMD_CPT2DCR_TE1SET = 1UL<<28, // Timer E output 1 Set
	HRTIM_TIMD_CPT2DCR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIMD_CPT2DCR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIMD_CPT2DCR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIMD_CPT2DCR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIMD_CPT2DCR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIMD_CPT2DCR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIMD_CPT2DCR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIMD_CPT2DCR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIMD_CPT2DCR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIMD_CPT2DCR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIMD_CPT2DCR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIMD_CPT2DCR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIMD_CPT2DCR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIMD_CPT2DCR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIMD_CPT2DCR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIMD_CPT2DCR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIMD_CPT2DCR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIMD_CPT2DCR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIMD_CPT2DCR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIMD_CPT2DCR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIMD_CPT2DCR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIMD_CPT2DCR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIMD_CPT2DCR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIMD_CPT2DCR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIMD->OUTDR Timerx Output Register
enum {
	HRTIM_TIMD_OUTDR_DIDL2 = 1UL<<23, // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMD_OUTDR_CHP2 = 1UL<<22, // Output 2 Chopper enable
	HRTIM_TIMD_OUTDR_FAULT2 = ((1UL<<2)-1) << 20, // Output 2 Fault state
	HRTIM_TIMD_OUTDR_IDLES2 = 1UL<<19, // Output 2 Idle State
	HRTIM_TIMD_OUTDR_IDLEM2 = 1UL<<18, // Output 2 Idle mode
	HRTIM_TIMD_OUTDR_POL2 = 1UL<<17, // Output 2 polarity
	HRTIM_TIMD_OUTDR_DLYPRT = ((1UL<<3)-1) << 10, // Delayed Protection
	HRTIM_TIMD_OUTDR_DLYPRTEN = 1UL<<9, // Delayed Protection Enable
	HRTIM_TIMD_OUTDR_DTEN = 1UL<<8, // Deadtime enable
	HRTIM_TIMD_OUTDR_DIDL1 = 1UL<<7, // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMD_OUTDR_CHP1 = 1UL<<6, // Output 1 Chopper enable
	HRTIM_TIMD_OUTDR_FAULT1 = ((1UL<<2)-1) << 4, // Output 1 Fault state
	HRTIM_TIMD_OUTDR_IDLES1 = 1UL<<3, // Output 1 Idle State
	HRTIM_TIMD_OUTDR_IDLEM1 = 1UL<<2, // Output 1 Idle mode
	HRTIM_TIMD_OUTDR_POL1 = 1UL<<1, // Output 1 polarity		
};
inline void hrtim_timd_outdr_set_fault2(struct HRTIM_TIMD_Type* p, uint32_t val) { p->OUTDR = (p->OUTDR & ~HRTIM_TIMD_OUTDR_FAULT2) | ((val<<20) & HRTIM_TIMD_OUTDR_FAULT2); }
inline void hrtim_timd_outdr_set_dlyprt(struct HRTIM_TIMD_Type* p, uint32_t val) { p->OUTDR = (p->OUTDR & ~HRTIM_TIMD_OUTDR_DLYPRT) | ((val<<10) & HRTIM_TIMD_OUTDR_DLYPRT); }
inline void hrtim_timd_outdr_set_fault1(struct HRTIM_TIMD_Type* p, uint32_t val) { p->OUTDR = (p->OUTDR & ~HRTIM_TIMD_OUTDR_FAULT1) | ((val<<4) & HRTIM_TIMD_OUTDR_FAULT1); }
inline uint32_t hrtim_timd_outdr_get_fault2(struct HRTIM_TIMD_Type* p) { return (p->OUTDR & HRTIM_TIMD_OUTDR_FAULT2) >> 20 ; }
inline uint32_t hrtim_timd_outdr_get_dlyprt(struct HRTIM_TIMD_Type* p) { return (p->OUTDR & HRTIM_TIMD_OUTDR_DLYPRT) >> 10 ; }
inline uint32_t hrtim_timd_outdr_get_fault1(struct HRTIM_TIMD_Type* p) { return (p->OUTDR & HRTIM_TIMD_OUTDR_FAULT1) >> 4 ; }

// HRTIM_TIMD->FLTDR Timerx Fault Register
enum {
	HRTIM_TIMD_FLTDR_FLTLCK = 1UL<<31, // Fault sources Lock
	HRTIM_TIMD_FLTDR_FLT5EN = 1UL<<4, // Fault 5 enable
	HRTIM_TIMD_FLTDR_FLT4EN = 1UL<<3, // Fault 4 enable
	HRTIM_TIMD_FLTDR_FLT3EN = 1UL<<2, // Fault 3 enable
	HRTIM_TIMD_FLTDR_FLT2EN = 1UL<<1, // Fault 2 enable
	HRTIM_TIMD_FLTDR_FLT1EN = 1UL<<0, // Fault 1 enable		
};

/* High Resolution Timer: TIME */
struct HRTIM_TIME_Type {
	__IO uint32_t TIMECR; // @0 Timerx Control Register
	__I uint32_t TIMEISR; // @4 Timerx Interrupt Status Register
	__O uint16_t TIMEICR; // @8 Timerx Interrupt Clear Register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t TIMEDIER5; // @12 TIMxDIER5
	__IO uint16_t CNTER; // @16 Timerx Counter Register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t PERER; // @20 Timerx Period Register
	 uint8_t RESERVED2[2]; // @22 
	__IO uint8_t REPER; // @24 Timerx Repetition Register
	 uint8_t RESERVED3[3]; // @25 
	__IO uint16_t CMP1ER; // @28 Timerx Compare 1 Register
	 uint8_t RESERVED4[2]; // @30 
	__IO uint32_t CMP1CER; // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2ER; // @36 Timerx Compare 2 Register
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t CMP3ER; // @40 Timerx Compare 3 Register
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t CMP4ER; // @44 Timerx Compare 4 Register
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t CPT1ER; // @48 Timerx Capture 1 Register
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t CPT2ER; // @52 Timerx Capture 2 Register
	 uint8_t RESERVED9[2]; // @54 
	__IO uint32_t DTER; // @56 Timerx Deadtime Register
	__IO uint32_t SETE1R; // @60 Timerx Output1 Set Register
	__IO uint32_t RSTE1R; // @64 Timerx Output1 Reset Register
	__IO uint32_t SETE2R; // @68 Timerx Output2 Set Register
	__IO uint32_t RSTE2R; // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFER1; // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFER2; // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTER; // @84 TimerA Reset Register
	__IO uint16_t CHPER; // @88 Timerx Chopper Register
	 uint8_t RESERVED10[2]; // @90 
	__IO uint32_t CPT1ECR; // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2ECR; // @96 CPT2xCR
	__IO uint32_t OUTER; // @100 Timerx Output Register
	__IO uint32_t FLTER; // @104 Timerx Fault Register
};

// HRTIM_TIME->TIMECR Timerx Control Register
enum {
	HRTIM_TIME_TIMECR_UPDGAT = ((1UL<<4)-1) << 28, // Update Gating
	HRTIM_TIME_TIMECR_PREEN = 1UL<<27, // Preload enable
	HRTIM_TIME_TIMECR_DACSYNC = ((1UL<<2)-1) << 25, // AC Synchronization
	HRTIM_TIME_TIMECR_MSTU = 1UL<<24, // Master Timer update
	HRTIM_TIME_TIMECR_TEU = 1UL<<23, // TEU
	HRTIM_TIME_TIMECR_TDU = 1UL<<22, // TDU
	HRTIM_TIME_TIMECR_TCU = 1UL<<21, // TCU
	HRTIM_TIME_TIMECR_TBU = 1UL<<20, // TBU
	HRTIM_TIME_TIMECR_TXRSTU = 1UL<<18, // Timerx reset update
	HRTIM_TIME_TIMECR_TXREPU = 1UL<<17, // Timer x Repetition update
	HRTIM_TIME_TIMECR_DELCMP4 = ((1UL<<2)-1) << 14, // Delayed CMP4 mode
	HRTIM_TIME_TIMECR_DELCMP2 = ((1UL<<2)-1) << 12, // Delayed CMP2 mode
	HRTIM_TIME_TIMECR_SYNCSTRTX = 1UL<<11, // Synchronization Starts Timer x
	HRTIM_TIME_TIMECR_SYNCRSTX = 1UL<<10, // Synchronization Resets Timer x
	HRTIM_TIME_TIMECR_PSHPLL = 1UL<<6, // Push-Pull mode enable
	HRTIM_TIME_TIMECR_HALF = 1UL<<5, // Half mode enable
	HRTIM_TIME_TIMECR_RETRIG = 1UL<<4, // Re-triggerable mode
	HRTIM_TIME_TIMECR_CONT = 1UL<<3, // Continuous mode
	HRTIM_TIME_TIMECR_CK_PSCX = ((1UL<<3)-1) << 0, // HRTIM Timer x Clock prescaler		
};
inline void hrtim_time_timecr_set_updgat(struct HRTIM_TIME_Type* p, uint32_t val) { p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_UPDGAT) | ((val<<28) & HRTIM_TIME_TIMECR_UPDGAT); }
inline void hrtim_time_timecr_set_dacsync(struct HRTIM_TIME_Type* p, uint32_t val) { p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_DACSYNC) | ((val<<25) & HRTIM_TIME_TIMECR_DACSYNC); }
inline void hrtim_time_timecr_set_delcmp4(struct HRTIM_TIME_Type* p, uint32_t val) { p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_DELCMP4) | ((val<<14) & HRTIM_TIME_TIMECR_DELCMP4); }
inline void hrtim_time_timecr_set_delcmp2(struct HRTIM_TIME_Type* p, uint32_t val) { p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_DELCMP2) | ((val<<12) & HRTIM_TIME_TIMECR_DELCMP2); }
inline void hrtim_time_timecr_set_ck_pscx(struct HRTIM_TIME_Type* p, uint32_t val) { p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_CK_PSCX) | ((val<<0) & HRTIM_TIME_TIMECR_CK_PSCX); }
inline uint32_t hrtim_time_timecr_get_updgat(struct HRTIM_TIME_Type* p) { return (p->TIMECR & HRTIM_TIME_TIMECR_UPDGAT) >> 28 ; }
inline uint32_t hrtim_time_timecr_get_dacsync(struct HRTIM_TIME_Type* p) { return (p->TIMECR & HRTIM_TIME_TIMECR_DACSYNC) >> 25 ; }
inline uint32_t hrtim_time_timecr_get_delcmp4(struct HRTIM_TIME_Type* p) { return (p->TIMECR & HRTIM_TIME_TIMECR_DELCMP4) >> 14 ; }
inline uint32_t hrtim_time_timecr_get_delcmp2(struct HRTIM_TIME_Type* p) { return (p->TIMECR & HRTIM_TIME_TIMECR_DELCMP2) >> 12 ; }
inline uint32_t hrtim_time_timecr_get_ck_pscx(struct HRTIM_TIME_Type* p) { return (p->TIMECR & HRTIM_TIME_TIMECR_CK_PSCX) >> 0 ; }

// HRTIM_TIME->TIMEISR Timerx Interrupt Status Register
enum {
	HRTIM_TIME_TIMEISR_O2STAT = 1UL<<19, // Output 2 State
	HRTIM_TIME_TIMEISR_O1STAT = 1UL<<18, // Output 1 State
	HRTIM_TIME_TIMEISR_IPPSTAT = 1UL<<17, // Idle Push Pull Status
	HRTIM_TIME_TIMEISR_CPPSTAT = 1UL<<16, // Current Push Pull Status
	HRTIM_TIME_TIMEISR_DLYPRT = 1UL<<14, // Delayed Protection Flag
	HRTIM_TIME_TIMEISR_RST = 1UL<<13, // Reset Interrupt Flag
	HRTIM_TIME_TIMEISR_RSTX2 = 1UL<<12, // Output 2 Reset Interrupt Flag
	HRTIM_TIME_TIMEISR_SETX2 = 1UL<<11, // Output 2 Set Interrupt Flag
	HRTIM_TIME_TIMEISR_RSTX1 = 1UL<<10, // Output 1 Reset Interrupt Flag
	HRTIM_TIME_TIMEISR_SETX1 = 1UL<<9, // Output 1 Set Interrupt Flag
	HRTIM_TIME_TIMEISR_CPT2 = 1UL<<8, // Capture2 Interrupt Flag
	HRTIM_TIME_TIMEISR_CPT1 = 1UL<<7, // Capture1 Interrupt Flag
	HRTIM_TIME_TIMEISR_UPD = 1UL<<6, // Update Interrupt Flag
	HRTIM_TIME_TIMEISR_REP = 1UL<<4, // Repetition Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP4 = 1UL<<3, // Compare 4 Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP3 = 1UL<<2, // Compare 3 Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP2 = 1UL<<1, // Compare 2 Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP1 = 1UL<<0, // Compare 1 Interrupt Flag		
};

// HRTIM_TIME->TIMEICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIME_TIMEICR_DLYPRTC = 1UL<<14, // Delayed Protection Flag Clear
	HRTIM_TIME_TIMEICR_RSTC = 1UL<<13, // Reset Interrupt flag Clear
	HRTIM_TIME_TIMEICR_RSTX2C = 1UL<<12, // Output 2 Reset flag Clear
	HRTIM_TIME_TIMEICR_SET2XC = 1UL<<11, // Output 2 Set flag Clear
	HRTIM_TIME_TIMEICR_RSTX1C = 1UL<<10, // Output 1 Reset flag Clear
	HRTIM_TIME_TIMEICR_SET1XC = 1UL<<9, // Output 1 Set flag Clear
	HRTIM_TIME_TIMEICR_CPT2C = 1UL<<8, // Capture2 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CPT1C = 1UL<<7, // Capture1 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_UPDC = 1UL<<6, // Update Interrupt flag Clear
	HRTIM_TIME_TIMEICR_REPC = 1UL<<4, // Repetition Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP4C = 1UL<<3, // Compare 4 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP3C = 1UL<<2, // Compare 3 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP2C = 1UL<<1, // Compare 2 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP1C = 1UL<<0, // Compare 1 Interrupt flag Clear		
};

// HRTIM_TIME->TIMEDIER5 TIMxDIER5
enum {
	HRTIM_TIME_TIMEDIER5_DLYPRTDE = 1UL<<30, // DLYPRTDE
	HRTIM_TIME_TIMEDIER5_RSTDE = 1UL<<29, // RSTDE
	HRTIM_TIME_TIMEDIER5_RSTX2DE = 1UL<<28, // RSTx2DE
	HRTIM_TIME_TIMEDIER5_SETX2DE = 1UL<<27, // SETx2DE
	HRTIM_TIME_TIMEDIER5_RSTX1DE = 1UL<<26, // RSTx1DE
	HRTIM_TIME_TIMEDIER5_SET1XDE = 1UL<<25, // SET1xDE
	HRTIM_TIME_TIMEDIER5_CPT2DE = 1UL<<24, // CPT2DE
	HRTIM_TIME_TIMEDIER5_CPT1DE = 1UL<<23, // CPT1DE
	HRTIM_TIME_TIMEDIER5_UPDDE = 1UL<<22, // UPDDE
	HRTIM_TIME_TIMEDIER5_REPDE = 1UL<<20, // REPDE
	HRTIM_TIME_TIMEDIER5_CMP4DE = 1UL<<19, // CMP4DE
	HRTIM_TIME_TIMEDIER5_CMP3DE = 1UL<<18, // CMP3DE
	HRTIM_TIME_TIMEDIER5_CMP2DE = 1UL<<17, // CMP2DE
	HRTIM_TIME_TIMEDIER5_CMP1DE = 1UL<<16, // CMP1DE
	HRTIM_TIME_TIMEDIER5_DLYPRTIE = 1UL<<14, // DLYPRTIE
	HRTIM_TIME_TIMEDIER5_RSTIE = 1UL<<13, // RSTIE
	HRTIM_TIME_TIMEDIER5_RSTX2IE = 1UL<<12, // RSTx2IE
	HRTIM_TIME_TIMEDIER5_SETX2IE = 1UL<<11, // SETx2IE
	HRTIM_TIME_TIMEDIER5_RSTX1IE = 1UL<<10, // RSTx1IE
	HRTIM_TIME_TIMEDIER5_SET1XIE = 1UL<<9, // SET1xIE
	HRTIM_TIME_TIMEDIER5_CPT2IE = 1UL<<8, // CPT2IE
	HRTIM_TIME_TIMEDIER5_CPT1IE = 1UL<<7, // CPT1IE
	HRTIM_TIME_TIMEDIER5_UPDIE = 1UL<<6, // UPDIE
	HRTIM_TIME_TIMEDIER5_REPIE = 1UL<<4, // REPIE
	HRTIM_TIME_TIMEDIER5_CMP4IE = 1UL<<3, // CMP4IE
	HRTIM_TIME_TIMEDIER5_CMP3IE = 1UL<<2, // CMP3IE
	HRTIM_TIME_TIMEDIER5_CMP2IE = 1UL<<1, // CMP2IE
	HRTIM_TIME_TIMEDIER5_CMP1IE = 1UL<<0, // CMP1IE		
};

// HRTIM_TIME->CMP1CER Timerx Compare 1 Compound Register
enum {
	HRTIM_TIME_CMP1CER_REPX = ((1UL<<8)-1) << 16, // Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIME_CMP1CER_CMP1X = ((1UL<<16)-1) << 0, // Timerx Compare 1 value		
};
inline void hrtim_time_cmp1cer_set_repx(struct HRTIM_TIME_Type* p, uint32_t val) { p->CMP1CER = (p->CMP1CER & ~HRTIM_TIME_CMP1CER_REPX) | ((val<<16) & HRTIM_TIME_CMP1CER_REPX); }
inline void hrtim_time_cmp1cer_set_cmp1x(struct HRTIM_TIME_Type* p, uint32_t val) { p->CMP1CER = (p->CMP1CER & ~HRTIM_TIME_CMP1CER_CMP1X) | ((val<<0) & HRTIM_TIME_CMP1CER_CMP1X); }
inline uint32_t hrtim_time_cmp1cer_get_repx(struct HRTIM_TIME_Type* p) { return (p->CMP1CER & HRTIM_TIME_CMP1CER_REPX) >> 16 ; }
inline uint32_t hrtim_time_cmp1cer_get_cmp1x(struct HRTIM_TIME_Type* p) { return (p->CMP1CER & HRTIM_TIME_CMP1CER_CMP1X) >> 0 ; }

// HRTIM_TIME->DTER Timerx Deadtime Register
enum {
	HRTIM_TIME_DTER_DTFLKX = 1UL<<31, // Deadtime Falling Lock
	HRTIM_TIME_DTER_DTFSLKX = 1UL<<30, // Deadtime Falling Sign Lock
	HRTIM_TIME_DTER_SDTFX = 1UL<<25, // Sign Deadtime Falling value
	HRTIM_TIME_DTER_DTFX = ((1UL<<9)-1) << 16, // Deadtime Falling value
	HRTIM_TIME_DTER_DTRLKX = 1UL<<15, // Deadtime Rising Lock
	HRTIM_TIME_DTER_DTRSLKX = 1UL<<14, // Deadtime Rising Sign Lock
	HRTIM_TIME_DTER_DTPRSC = ((1UL<<3)-1) << 10, // Deadtime Prescaler
	HRTIM_TIME_DTER_SDTRX = 1UL<<9, // Sign Deadtime Rising value
	HRTIM_TIME_DTER_DTRX = ((1UL<<9)-1) << 0, // Deadtime Rising value		
};
inline void hrtim_time_dter_set_dtfx(struct HRTIM_TIME_Type* p, uint32_t val) { p->DTER = (p->DTER & ~HRTIM_TIME_DTER_DTFX) | ((val<<16) & HRTIM_TIME_DTER_DTFX); }
inline void hrtim_time_dter_set_dtprsc(struct HRTIM_TIME_Type* p, uint32_t val) { p->DTER = (p->DTER & ~HRTIM_TIME_DTER_DTPRSC) | ((val<<10) & HRTIM_TIME_DTER_DTPRSC); }
inline void hrtim_time_dter_set_dtrx(struct HRTIM_TIME_Type* p, uint32_t val) { p->DTER = (p->DTER & ~HRTIM_TIME_DTER_DTRX) | ((val<<0) & HRTIM_TIME_DTER_DTRX); }
inline uint32_t hrtim_time_dter_get_dtfx(struct HRTIM_TIME_Type* p) { return (p->DTER & HRTIM_TIME_DTER_DTFX) >> 16 ; }
inline uint32_t hrtim_time_dter_get_dtprsc(struct HRTIM_TIME_Type* p) { return (p->DTER & HRTIM_TIME_DTER_DTPRSC) >> 10 ; }
inline uint32_t hrtim_time_dter_get_dtrx(struct HRTIM_TIME_Type* p) { return (p->DTER & HRTIM_TIME_DTER_DTRX) >> 0 ; }

// HRTIM_TIME->SETE1R Timerx Output1 Set Register
enum {
	HRTIM_TIME_SETE1R_UPDATE = 1UL<<31, // Registers update (transfer preload to active)
	HRTIM_TIME_SETE1R_EXTEVNT10 = 1UL<<30, // External Event 10
	HRTIM_TIME_SETE1R_EXTEVNT9 = 1UL<<29, // External Event 9
	HRTIM_TIME_SETE1R_EXTEVNT8 = 1UL<<28, // External Event 8
	HRTIM_TIME_SETE1R_EXTEVNT7 = 1UL<<27, // External Event 7
	HRTIM_TIME_SETE1R_EXTEVNT6 = 1UL<<26, // External Event 6
	HRTIM_TIME_SETE1R_EXTEVNT5 = 1UL<<25, // External Event 5
	HRTIM_TIME_SETE1R_EXTEVNT4 = 1UL<<24, // External Event 4
	HRTIM_TIME_SETE1R_EXTEVNT3 = 1UL<<23, // External Event 3
	HRTIM_TIME_SETE1R_EXTEVNT2 = 1UL<<22, // External Event 2
	HRTIM_TIME_SETE1R_EXTEVNT1 = 1UL<<21, // External Event 1
	HRTIM_TIME_SETE1R_TIMEVNT9 = 1UL<<20, // Timer Event 9
	HRTIM_TIME_SETE1R_TIMEVNT8 = 1UL<<19, // Timer Event 8
	HRTIM_TIME_SETE1R_TIMEVNT7 = 1UL<<18, // Timer Event 7
	HRTIM_TIME_SETE1R_TIMEVNT6 = 1UL<<17, // Timer Event 6
	HRTIM_TIME_SETE1R_TIMEVNT5 = 1UL<<16, // Timer Event 5
	HRTIM_TIME_SETE1R_TIMEVNT4 = 1UL<<15, // Timer Event 4
	HRTIM_TIME_SETE1R_TIMEVNT3 = 1UL<<14, // Timer Event 3
	HRTIM_TIME_SETE1R_TIMEVNT2 = 1UL<<13, // Timer Event 2
	HRTIM_TIME_SETE1R_TIMEVNT1 = 1UL<<12, // Timer Event 1
	HRTIM_TIME_SETE1R_MSTCMP4 = 1UL<<11, // Master Compare 4
	HRTIM_TIME_SETE1R_MSTCMP3 = 1UL<<10, // Master Compare 3
	HRTIM_TIME_SETE1R_MSTCMP2 = 1UL<<9, // Master Compare 2
	HRTIM_TIME_SETE1R_MSTCMP1 = 1UL<<8, // Master Compare 1
	HRTIM_TIME_SETE1R_MSTPER = 1UL<<7, // Master Period
	HRTIM_TIME_SETE1R_CMP4 = 1UL<<6, // Timer A compare 4
	HRTIM_TIME_SETE1R_CMP3 = 1UL<<5, // Timer A compare 3
	HRTIM_TIME_SETE1R_CMP2 = 1UL<<4, // Timer A compare 2
	HRTIM_TIME_SETE1R_CMP1 = 1UL<<3, // Timer A compare 1
	HRTIM_TIME_SETE1R_PER = 1UL<<2, // Timer A Period
	HRTIM_TIME_SETE1R_RESYNC = 1UL<<1, // Timer A resynchronizaton
	HRTIM_TIME_SETE1R_SST = 1UL<<0, // Software Set trigger		
};

// HRTIM_TIME->RSTE1R Timerx Output1 Reset Register
enum {
	HRTIM_TIME_RSTE1R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIME_RSTE1R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIME_RSTE1R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIME_RSTE1R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIME_RSTE1R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIME_RSTE1R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIME_RSTE1R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIME_RSTE1R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIME_RSTE1R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIME_RSTE1R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIME_RSTE1R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIME_RSTE1R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIME_RSTE1R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIME_RSTE1R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIME_RSTE1R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIME_RSTE1R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIME_RSTE1R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIME_RSTE1R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIME_RSTE1R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIME_RSTE1R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIME_RSTE1R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIME_RSTE1R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIME_RSTE1R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIME_RSTE1R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIME_RSTE1R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIME_RSTE1R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIME_RSTE1R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIME_RSTE1R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIME_RSTE1R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIME_RSTE1R_PER = 1UL<<2, // PER
	HRTIM_TIME_RSTE1R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIME_RSTE1R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIME->SETE2R Timerx Output2 Set Register
enum {
	HRTIM_TIME_SETE2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIME_SETE2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIME_SETE2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIME_SETE2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIME_SETE2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIME_SETE2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIME_SETE2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIME_SETE2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIME_SETE2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIME_SETE2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIME_SETE2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIME_SETE2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIME_SETE2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIME_SETE2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIME_SETE2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIME_SETE2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIME_SETE2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIME_SETE2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIME_SETE2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIME_SETE2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIME_SETE2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIME_SETE2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIME_SETE2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIME_SETE2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIME_SETE2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIME_SETE2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIME_SETE2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIME_SETE2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIME_SETE2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIME_SETE2R_PER = 1UL<<2, // PER
	HRTIM_TIME_SETE2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIME_SETE2R_SST = 1UL<<0, // SST		
};

// HRTIM_TIME->RSTE2R Timerx Output2 Reset Register
enum {
	HRTIM_TIME_RSTE2R_UPDATE = 1UL<<31, // UPDATE
	HRTIM_TIME_RSTE2R_EXTEVNT10 = 1UL<<30, // EXTEVNT10
	HRTIM_TIME_RSTE2R_EXTEVNT9 = 1UL<<29, // EXTEVNT9
	HRTIM_TIME_RSTE2R_EXTEVNT8 = 1UL<<28, // EXTEVNT8
	HRTIM_TIME_RSTE2R_EXTEVNT7 = 1UL<<27, // EXTEVNT7
	HRTIM_TIME_RSTE2R_EXTEVNT6 = 1UL<<26, // EXTEVNT6
	HRTIM_TIME_RSTE2R_EXTEVNT5 = 1UL<<25, // EXTEVNT5
	HRTIM_TIME_RSTE2R_EXTEVNT4 = 1UL<<24, // EXTEVNT4
	HRTIM_TIME_RSTE2R_EXTEVNT3 = 1UL<<23, // EXTEVNT3
	HRTIM_TIME_RSTE2R_EXTEVNT2 = 1UL<<22, // EXTEVNT2
	HRTIM_TIME_RSTE2R_EXTEVNT1 = 1UL<<21, // EXTEVNT1
	HRTIM_TIME_RSTE2R_TIMEVNT9 = 1UL<<20, // TIMEVNT9
	HRTIM_TIME_RSTE2R_TIMEVNT8 = 1UL<<19, // TIMEVNT8
	HRTIM_TIME_RSTE2R_TIMEVNT7 = 1UL<<18, // TIMEVNT7
	HRTIM_TIME_RSTE2R_TIMEVNT6 = 1UL<<17, // TIMEVNT6
	HRTIM_TIME_RSTE2R_TIMEVNT5 = 1UL<<16, // TIMEVNT5
	HRTIM_TIME_RSTE2R_TIMEVNT4 = 1UL<<15, // TIMEVNT4
	HRTIM_TIME_RSTE2R_TIMEVNT3 = 1UL<<14, // TIMEVNT3
	HRTIM_TIME_RSTE2R_TIMEVNT2 = 1UL<<13, // TIMEVNT2
	HRTIM_TIME_RSTE2R_TIMEVNT1 = 1UL<<12, // TIMEVNT1
	HRTIM_TIME_RSTE2R_MSTCMP4 = 1UL<<11, // MSTCMP4
	HRTIM_TIME_RSTE2R_MSTCMP3 = 1UL<<10, // MSTCMP3
	HRTIM_TIME_RSTE2R_MSTCMP2 = 1UL<<9, // MSTCMP2
	HRTIM_TIME_RSTE2R_MSTCMP1 = 1UL<<8, // MSTCMP1
	HRTIM_TIME_RSTE2R_MSTPER = 1UL<<7, // MSTPER
	HRTIM_TIME_RSTE2R_CMP4 = 1UL<<6, // CMP4
	HRTIM_TIME_RSTE2R_CMP3 = 1UL<<5, // CMP3
	HRTIM_TIME_RSTE2R_CMP2 = 1UL<<4, // CMP2
	HRTIM_TIME_RSTE2R_CMP1 = 1UL<<3, // CMP1
	HRTIM_TIME_RSTE2R_PER = 1UL<<2, // PER
	HRTIM_TIME_RSTE2R_RESYNC = 1UL<<1, // RESYNC
	HRTIM_TIME_RSTE2R_SRT = 1UL<<0, // SRT		
};

// HRTIM_TIME->EEFER1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIME_EEFER1_EE5FLTR = ((1UL<<4)-1) << 25, // External Event 5 filter
	HRTIM_TIME_EEFER1_EE5LTCH = 1UL<<24, // External Event 5 latch
	HRTIM_TIME_EEFER1_EE4FLTR = ((1UL<<4)-1) << 19, // External Event 4 filter
	HRTIM_TIME_EEFER1_EE4LTCH = 1UL<<18, // External Event 4 latch
	HRTIM_TIME_EEFER1_EE3FLTR = ((1UL<<4)-1) << 13, // External Event 3 filter
	HRTIM_TIME_EEFER1_EE3LTCH = 1UL<<12, // External Event 3 latch
	HRTIM_TIME_EEFER1_EE2FLTR = ((1UL<<4)-1) << 7, // External Event 2 filter
	HRTIM_TIME_EEFER1_EE2LTCH = 1UL<<6, // External Event 2 latch
	HRTIM_TIME_EEFER1_EE1FLTR = ((1UL<<4)-1) << 1, // External Event 1 filter
	HRTIM_TIME_EEFER1_EE1LTCH = 1UL<<0, // External Event 1 latch		
};
inline void hrtim_time_eefer1_set_ee5fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE5FLTR) | ((val<<25) & HRTIM_TIME_EEFER1_EE5FLTR); }
inline void hrtim_time_eefer1_set_ee4fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE4FLTR) | ((val<<19) & HRTIM_TIME_EEFER1_EE4FLTR); }
inline void hrtim_time_eefer1_set_ee3fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE3FLTR) | ((val<<13) & HRTIM_TIME_EEFER1_EE3FLTR); }
inline void hrtim_time_eefer1_set_ee2fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE2FLTR) | ((val<<7) & HRTIM_TIME_EEFER1_EE2FLTR); }
inline void hrtim_time_eefer1_set_ee1fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE1FLTR) | ((val<<1) & HRTIM_TIME_EEFER1_EE1FLTR); }
inline uint32_t hrtim_time_eefer1_get_ee5fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE5FLTR) >> 25 ; }
inline uint32_t hrtim_time_eefer1_get_ee4fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE4FLTR) >> 19 ; }
inline uint32_t hrtim_time_eefer1_get_ee3fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE3FLTR) >> 13 ; }
inline uint32_t hrtim_time_eefer1_get_ee2fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE2FLTR) >> 7 ; }
inline uint32_t hrtim_time_eefer1_get_ee1fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE1FLTR) >> 1 ; }

// HRTIM_TIME->EEFER2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIME_EEFER2_EE10FLTR = ((1UL<<4)-1) << 25, // External Event 10 filter
	HRTIM_TIME_EEFER2_EE10LTCH = 1UL<<24, // External Event 10 latch
	HRTIM_TIME_EEFER2_EE9FLTR = ((1UL<<4)-1) << 19, // External Event 9 filter
	HRTIM_TIME_EEFER2_EE9LTCH = 1UL<<18, // External Event 9 latch
	HRTIM_TIME_EEFER2_EE8FLTR = ((1UL<<4)-1) << 13, // External Event 8 filter
	HRTIM_TIME_EEFER2_EE8LTCH = 1UL<<12, // External Event 8 latch
	HRTIM_TIME_EEFER2_EE7FLTR = ((1UL<<4)-1) << 7, // External Event 7 filter
	HRTIM_TIME_EEFER2_EE7LTCH = 1UL<<6, // External Event 7 latch
	HRTIM_TIME_EEFER2_EE6FLTR = ((1UL<<4)-1) << 1, // External Event 6 filter
	HRTIM_TIME_EEFER2_EE6LTCH = 1UL<<0, // External Event 6 latch		
};
inline void hrtim_time_eefer2_set_ee10fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE10FLTR) | ((val<<25) & HRTIM_TIME_EEFER2_EE10FLTR); }
inline void hrtim_time_eefer2_set_ee9fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE9FLTR) | ((val<<19) & HRTIM_TIME_EEFER2_EE9FLTR); }
inline void hrtim_time_eefer2_set_ee8fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE8FLTR) | ((val<<13) & HRTIM_TIME_EEFER2_EE8FLTR); }
inline void hrtim_time_eefer2_set_ee7fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE7FLTR) | ((val<<7) & HRTIM_TIME_EEFER2_EE7FLTR); }
inline void hrtim_time_eefer2_set_ee6fltr(struct HRTIM_TIME_Type* p, uint32_t val) { p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE6FLTR) | ((val<<1) & HRTIM_TIME_EEFER2_EE6FLTR); }
inline uint32_t hrtim_time_eefer2_get_ee10fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE10FLTR) >> 25 ; }
inline uint32_t hrtim_time_eefer2_get_ee9fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE9FLTR) >> 19 ; }
inline uint32_t hrtim_time_eefer2_get_ee8fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE8FLTR) >> 13 ; }
inline uint32_t hrtim_time_eefer2_get_ee7fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE7FLTR) >> 7 ; }
inline uint32_t hrtim_time_eefer2_get_ee6fltr(struct HRTIM_TIME_Type* p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE6FLTR) >> 1 ; }

// HRTIM_TIME->RSTER TimerA Reset Register
enum {
	HRTIM_TIME_RSTER_TIMDCMP4 = 1UL<<30, // Timer D Compare 4
	HRTIM_TIME_RSTER_TIMDCMP2 = 1UL<<29, // Timer D Compare 2
	HRTIM_TIME_RSTER_TIMDCMP1 = 1UL<<28, // Timer D Compare 1
	HRTIM_TIME_RSTER_TIMCCMP4 = 1UL<<27, // Timer C Compare 4
	HRTIM_TIME_RSTER_TIMCCMP2 = 1UL<<26, // Timer C Compare 2
	HRTIM_TIME_RSTER_TIMCCMP1 = 1UL<<25, // Timer C Compare 1
	HRTIM_TIME_RSTER_TIMBCMP4 = 1UL<<24, // Timer B Compare 4
	HRTIM_TIME_RSTER_TIMBCMP2 = 1UL<<23, // Timer B Compare 2
	HRTIM_TIME_RSTER_TIMBCMP1 = 1UL<<22, // Timer B Compare 1
	HRTIM_TIME_RSTER_TIMACMP4 = 1UL<<21, // Timer A Compare 4
	HRTIM_TIME_RSTER_TIMACMP2 = 1UL<<20, // Timer A Compare 2
	HRTIM_TIME_RSTER_TIMACMP1 = 1UL<<19, // Timer A Compare 1
	HRTIM_TIME_RSTER_EXTEVNT10 = 1UL<<18, // External Event 10
	HRTIM_TIME_RSTER_EXTEVNT9 = 1UL<<17, // External Event 9
	HRTIM_TIME_RSTER_EXTEVNT8 = 1UL<<16, // External Event 8
	HRTIM_TIME_RSTER_EXTEVNT7 = 1UL<<15, // External Event 7
	HRTIM_TIME_RSTER_EXTEVNT6 = 1UL<<14, // External Event 6
	HRTIM_TIME_RSTER_EXTEVNT5 = 1UL<<13, // External Event 5
	HRTIM_TIME_RSTER_EXTEVNT4 = 1UL<<12, // External Event 4
	HRTIM_TIME_RSTER_EXTEVNT3 = 1UL<<11, // External Event 3
	HRTIM_TIME_RSTER_EXTEVNT2 = 1UL<<10, // External Event 2
	HRTIM_TIME_RSTER_EXTEVNT1 = 1UL<<9, // External Event 1
	HRTIM_TIME_RSTER_MSTCMP4 = 1UL<<8, // Master compare 4
	HRTIM_TIME_RSTER_MSTCMP3 = 1UL<<7, // Master compare 3
	HRTIM_TIME_RSTER_MSTCMP2 = 1UL<<6, // Master compare 2
	HRTIM_TIME_RSTER_MSTCMP1 = 1UL<<5, // Master compare 1
	HRTIM_TIME_RSTER_MSTPER = 1UL<<4, // Master timer Period
	HRTIM_TIME_RSTER_CMP4 = 1UL<<3, // Timer A compare 4 reset
	HRTIM_TIME_RSTER_CMP2 = 1UL<<2, // Timer A compare 2 reset
	HRTIM_TIME_RSTER_UPDT = 1UL<<1, // Timer A Update reset		
};

// HRTIM_TIME->CHPER Timerx Chopper Register
enum {
	HRTIM_TIME_CHPER_STRTPW = ((1UL<<4)-1) << 7, // STRTPW
	HRTIM_TIME_CHPER_CHPDTY = ((1UL<<3)-1) << 4, // Timerx chopper duty cycle value
	HRTIM_TIME_CHPER_CHPFRQ = ((1UL<<4)-1) << 0, // Timerx carrier frequency value		
};
inline void hrtim_time_chper_set_strtpw(struct HRTIM_TIME_Type* p, uint32_t val) { p->CHPER = (p->CHPER & ~HRTIM_TIME_CHPER_STRTPW) | ((val<<7) & HRTIM_TIME_CHPER_STRTPW); }
inline void hrtim_time_chper_set_chpdty(struct HRTIM_TIME_Type* p, uint32_t val) { p->CHPER = (p->CHPER & ~HRTIM_TIME_CHPER_CHPDTY) | ((val<<4) & HRTIM_TIME_CHPER_CHPDTY); }
inline void hrtim_time_chper_set_chpfrq(struct HRTIM_TIME_Type* p, uint32_t val) { p->CHPER = (p->CHPER & ~HRTIM_TIME_CHPER_CHPFRQ) | ((val<<0) & HRTIM_TIME_CHPER_CHPFRQ); }
inline uint32_t hrtim_time_chper_get_strtpw(struct HRTIM_TIME_Type* p) { return (p->CHPER & HRTIM_TIME_CHPER_STRTPW) >> 7 ; }
inline uint32_t hrtim_time_chper_get_chpdty(struct HRTIM_TIME_Type* p) { return (p->CHPER & HRTIM_TIME_CHPER_CHPDTY) >> 4 ; }
inline uint32_t hrtim_time_chper_get_chpfrq(struct HRTIM_TIME_Type* p) { return (p->CHPER & HRTIM_TIME_CHPER_CHPFRQ) >> 0 ; }

// HRTIM_TIME->CPT1ECR Timerx Capture 2 Control Register
enum {
	HRTIM_TIME_CPT1ECR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIME_CPT1ECR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIME_CPT1ECR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIME_CPT1ECR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIME_CPT1ECR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIME_CPT1ECR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIME_CPT1ECR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIME_CPT1ECR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIME_CPT1ECR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIME_CPT1ECR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIME_CPT1ECR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIME_CPT1ECR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIME_CPT1ECR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIME_CPT1ECR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIME_CPT1ECR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIME_CPT1ECR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIME_CPT1ECR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIME_CPT1ECR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIME_CPT1ECR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIME_CPT1ECR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIME_CPT1ECR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIME_CPT1ECR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIME_CPT1ECR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIME_CPT1ECR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIME_CPT1ECR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIME_CPT1ECR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIME_CPT1ECR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIME_CPT1ECR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIME->CPT2ECR CPT2xCR
enum {
	HRTIM_TIME_CPT2ECR_TDCMP2 = 1UL<<27, // Timer D Compare 2
	HRTIM_TIME_CPT2ECR_TDCMP1 = 1UL<<26, // Timer D Compare 1
	HRTIM_TIME_CPT2ECR_TD1RST = 1UL<<25, // Timer D output 1 Reset
	HRTIM_TIME_CPT2ECR_TD1SET = 1UL<<24, // Timer D output 1 Set
	HRTIM_TIME_CPT2ECR_TCCMP2 = 1UL<<23, // Timer C Compare 2
	HRTIM_TIME_CPT2ECR_TCCMP1 = 1UL<<22, // Timer C Compare 1
	HRTIM_TIME_CPT2ECR_TC1RST = 1UL<<21, // Timer C output 1 Reset
	HRTIM_TIME_CPT2ECR_TC1SET = 1UL<<20, // Timer C output 1 Set
	HRTIM_TIME_CPT2ECR_TBCMP2 = 1UL<<19, // Timer B Compare 2
	HRTIM_TIME_CPT2ECR_TBCMP1 = 1UL<<18, // Timer B Compare 1
	HRTIM_TIME_CPT2ECR_TB1RST = 1UL<<17, // Timer B output 1 Reset
	HRTIM_TIME_CPT2ECR_TB1SET = 1UL<<16, // Timer B output 1 Set
	HRTIM_TIME_CPT2ECR_TACMP2 = 1UL<<15, // Timer A Compare 2
	HRTIM_TIME_CPT2ECR_TACMP1 = 1UL<<14, // Timer A Compare 1
	HRTIM_TIME_CPT2ECR_TA1RST = 1UL<<13, // Timer A output 1 Reset
	HRTIM_TIME_CPT2ECR_TA1SET = 1UL<<12, // Timer A output 1 Set
	HRTIM_TIME_CPT2ECR_EXEV10CPT = 1UL<<11, // External Event 10 Capture
	HRTIM_TIME_CPT2ECR_EXEV9CPT = 1UL<<10, // External Event 9 Capture
	HRTIM_TIME_CPT2ECR_EXEV8CPT = 1UL<<9, // External Event 8 Capture
	HRTIM_TIME_CPT2ECR_EXEV7CPT = 1UL<<8, // External Event 7 Capture
	HRTIM_TIME_CPT2ECR_EXEV6CPT = 1UL<<7, // External Event 6 Capture
	HRTIM_TIME_CPT2ECR_EXEV5CPT = 1UL<<6, // External Event 5 Capture
	HRTIM_TIME_CPT2ECR_EXEV4CPT = 1UL<<5, // External Event 4 Capture
	HRTIM_TIME_CPT2ECR_EXEV3CPT = 1UL<<4, // External Event 3 Capture
	HRTIM_TIME_CPT2ECR_EXEV2CPT = 1UL<<3, // External Event 2 Capture
	HRTIM_TIME_CPT2ECR_EXEV1CPT = 1UL<<2, // External Event 1 Capture
	HRTIM_TIME_CPT2ECR_UDPCPT = 1UL<<1, // Update Capture
	HRTIM_TIME_CPT2ECR_SWCPT = 1UL<<0, // Software Capture		
};

// HRTIM_TIME->OUTER Timerx Output Register
enum {
	HRTIM_TIME_OUTER_DIDL2 = 1UL<<23, // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIME_OUTER_CHP2 = 1UL<<22, // Output 2 Chopper enable
	HRTIM_TIME_OUTER_FAULT2 = ((1UL<<2)-1) << 20, // Output 2 Fault state
	HRTIM_TIME_OUTER_IDLES2 = 1UL<<19, // Output 2 Idle State
	HRTIM_TIME_OUTER_IDLEM2 = 1UL<<18, // Output 2 Idle mode
	HRTIM_TIME_OUTER_POL2 = 1UL<<17, // Output 2 polarity
	HRTIM_TIME_OUTER_DLYPRT = ((1UL<<3)-1) << 10, // Delayed Protection
	HRTIM_TIME_OUTER_DLYPRTEN = 1UL<<9, // Delayed Protection Enable
	HRTIM_TIME_OUTER_DTEN = 1UL<<8, // Deadtime enable
	HRTIM_TIME_OUTER_DIDL1 = 1UL<<7, // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIME_OUTER_CHP1 = 1UL<<6, // Output 1 Chopper enable
	HRTIM_TIME_OUTER_FAULT1 = ((1UL<<2)-1) << 4, // Output 1 Fault state
	HRTIM_TIME_OUTER_IDLES1 = 1UL<<3, // Output 1 Idle State
	HRTIM_TIME_OUTER_IDLEM1 = 1UL<<2, // Output 1 Idle mode
	HRTIM_TIME_OUTER_POL1 = 1UL<<1, // Output 1 polarity		
};
inline void hrtim_time_outer_set_fault2(struct HRTIM_TIME_Type* p, uint32_t val) { p->OUTER = (p->OUTER & ~HRTIM_TIME_OUTER_FAULT2) | ((val<<20) & HRTIM_TIME_OUTER_FAULT2); }
inline void hrtim_time_outer_set_dlyprt(struct HRTIM_TIME_Type* p, uint32_t val) { p->OUTER = (p->OUTER & ~HRTIM_TIME_OUTER_DLYPRT) | ((val<<10) & HRTIM_TIME_OUTER_DLYPRT); }
inline void hrtim_time_outer_set_fault1(struct HRTIM_TIME_Type* p, uint32_t val) { p->OUTER = (p->OUTER & ~HRTIM_TIME_OUTER_FAULT1) | ((val<<4) & HRTIM_TIME_OUTER_FAULT1); }
inline uint32_t hrtim_time_outer_get_fault2(struct HRTIM_TIME_Type* p) { return (p->OUTER & HRTIM_TIME_OUTER_FAULT2) >> 20 ; }
inline uint32_t hrtim_time_outer_get_dlyprt(struct HRTIM_TIME_Type* p) { return (p->OUTER & HRTIM_TIME_OUTER_DLYPRT) >> 10 ; }
inline uint32_t hrtim_time_outer_get_fault1(struct HRTIM_TIME_Type* p) { return (p->OUTER & HRTIM_TIME_OUTER_FAULT1) >> 4 ; }

// HRTIM_TIME->FLTER Timerx Fault Register
enum {
	HRTIM_TIME_FLTER_FLTLCK = 1UL<<31, // Fault sources Lock
	HRTIM_TIME_FLTER_FLT5EN = 1UL<<4, // Fault 5 enable
	HRTIM_TIME_FLTER_FLT4EN = 1UL<<3, // Fault 4 enable
	HRTIM_TIME_FLTER_FLT3EN = 1UL<<2, // Fault 3 enable
	HRTIM_TIME_FLTER_FLT2EN = 1UL<<1, // Fault 2 enable
	HRTIM_TIME_FLTER_FLT1EN = 1UL<<0, // Fault 1 enable		
};

/* HSEM */
struct HSEM_Type {
	__IO uint32_t HSEM_R0; // @0 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R1; // @4 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R2; // @8 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R3; // @12 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R4; // @16 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R5; // @20 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R6; // @24 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R7; // @28 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R8; // @32 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R9; // @36 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R10; // @40 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R11; // @44 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R12; // @48 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R13; // @52 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R14; // @56 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R15; // @60 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R16; // @64 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R17; // @68 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R18; // @72 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R19; // @76 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R20; // @80 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R21; // @84 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R22; // @88 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R23; // @92 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R24; // @96 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R25; // @100 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R26; // @104 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R27; // @108 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R28; // @112 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R29; // @116 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R30; // @120 HSEM register HSEM_R0 HSEM_R31
	__IO uint32_t HSEM_R31; // @124 HSEM register HSEM_R0 HSEM_R31
	__I uint32_t HSEM_RLR0; // @128 HSEM Read lock register
	__I uint32_t HSEM_RLR1; // @132 HSEM Read lock register
	__I uint32_t HSEM_RLR2; // @136 HSEM Read lock register
	__I uint32_t HSEM_RLR3; // @140 HSEM Read lock register
	__I uint32_t HSEM_RLR4; // @144 HSEM Read lock register
	__I uint32_t HSEM_RLR5; // @148 HSEM Read lock register
	__I uint32_t HSEM_RLR6; // @152 HSEM Read lock register
	__I uint32_t HSEM_RLR7; // @156 HSEM Read lock register
	__I uint32_t HSEM_RLR8; // @160 HSEM Read lock register
	__I uint32_t HSEM_RLR9; // @164 HSEM Read lock register
	__I uint32_t HSEM_RLR10; // @168 HSEM Read lock register
	__I uint32_t HSEM_RLR11; // @172 HSEM Read lock register
	__I uint32_t HSEM_RLR12; // @176 HSEM Read lock register
	__I uint32_t HSEM_RLR13; // @180 HSEM Read lock register
	__I uint32_t HSEM_RLR14; // @184 HSEM Read lock register
	__I uint32_t HSEM_RLR15; // @188 HSEM Read lock register
	__I uint32_t HSEM_RLR16; // @192 HSEM Read lock register
	__I uint32_t HSEM_RLR17; // @196 HSEM Read lock register
	__I uint32_t HSEM_RLR18; // @200 HSEM Read lock register
	__I uint32_t HSEM_RLR19; // @204 HSEM Read lock register
	__I uint32_t HSEM_RLR20; // @208 HSEM Read lock register
	__I uint32_t HSEM_RLR21; // @212 HSEM Read lock register
	__I uint32_t HSEM_RLR22; // @216 HSEM Read lock register
	__I uint32_t HSEM_RLR23; // @220 HSEM Read lock register
	__I uint32_t HSEM_RLR24; // @224 HSEM Read lock register
	__I uint32_t HSEM_RLR25; // @228 HSEM Read lock register
	__I uint32_t HSEM_RLR26; // @232 HSEM Read lock register
	__I uint32_t HSEM_RLR27; // @236 HSEM Read lock register
	__I uint32_t HSEM_RLR28; // @240 HSEM Read lock register
	__I uint32_t HSEM_RLR29; // @244 HSEM Read lock register
	__I uint32_t HSEM_RLR30; // @248 HSEM Read lock register
	__I uint32_t HSEM_RLR31; // @252 HSEM Read lock register
	__IO uint32_t HSEM_IER; // @256 HSEM Interrupt enable register
	__I uint32_t HSEM_ICR; // @260 HSEM Interrupt clear register
	__I uint32_t HSEM_ISR; // @264 HSEM Interrupt status register
	__I uint32_t HSEM_MISR; // @268 HSEM Masked interrupt status register
	 uint8_t RESERVED0[48]; // @272 
	__IO uint32_t HSEM_CR; // @320 HSEM Clear register
	__IO uint32_t HSEM_KEYR; // @324 HSEM Interrupt clear register
};

// HSEM->HSEM_R0 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R0_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R0_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R0_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r0_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R0 = (p->HSEM_R0 & ~HSEM_HSEM_R0_MASTERID) | ((val<<8) & HSEM_HSEM_R0_MASTERID); }
inline void hsem_hsem_r0_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R0 = (p->HSEM_R0 & ~HSEM_HSEM_R0_PROCID) | ((val<<0) & HSEM_HSEM_R0_PROCID); }
inline uint32_t hsem_hsem_r0_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R0 & HSEM_HSEM_R0_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r0_get_procid(struct HSEM_Type* p) { return (p->HSEM_R0 & HSEM_HSEM_R0_PROCID) >> 0 ; }

// HSEM->HSEM_R1 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R1_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R1_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R1_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r1_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R1 = (p->HSEM_R1 & ~HSEM_HSEM_R1_MASTERID) | ((val<<8) & HSEM_HSEM_R1_MASTERID); }
inline void hsem_hsem_r1_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R1 = (p->HSEM_R1 & ~HSEM_HSEM_R1_PROCID) | ((val<<0) & HSEM_HSEM_R1_PROCID); }
inline uint32_t hsem_hsem_r1_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R1 & HSEM_HSEM_R1_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r1_get_procid(struct HSEM_Type* p) { return (p->HSEM_R1 & HSEM_HSEM_R1_PROCID) >> 0 ; }

// HSEM->HSEM_R2 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R2_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R2_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R2_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r2_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R2 = (p->HSEM_R2 & ~HSEM_HSEM_R2_MASTERID) | ((val<<8) & HSEM_HSEM_R2_MASTERID); }
inline void hsem_hsem_r2_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R2 = (p->HSEM_R2 & ~HSEM_HSEM_R2_PROCID) | ((val<<0) & HSEM_HSEM_R2_PROCID); }
inline uint32_t hsem_hsem_r2_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R2 & HSEM_HSEM_R2_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r2_get_procid(struct HSEM_Type* p) { return (p->HSEM_R2 & HSEM_HSEM_R2_PROCID) >> 0 ; }

// HSEM->HSEM_R3 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R3_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R3_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R3_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r3_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R3 = (p->HSEM_R3 & ~HSEM_HSEM_R3_MASTERID) | ((val<<8) & HSEM_HSEM_R3_MASTERID); }
inline void hsem_hsem_r3_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R3 = (p->HSEM_R3 & ~HSEM_HSEM_R3_PROCID) | ((val<<0) & HSEM_HSEM_R3_PROCID); }
inline uint32_t hsem_hsem_r3_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R3 & HSEM_HSEM_R3_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r3_get_procid(struct HSEM_Type* p) { return (p->HSEM_R3 & HSEM_HSEM_R3_PROCID) >> 0 ; }

// HSEM->HSEM_R4 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R4_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R4_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R4_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r4_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R4 = (p->HSEM_R4 & ~HSEM_HSEM_R4_MASTERID) | ((val<<8) & HSEM_HSEM_R4_MASTERID); }
inline void hsem_hsem_r4_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R4 = (p->HSEM_R4 & ~HSEM_HSEM_R4_PROCID) | ((val<<0) & HSEM_HSEM_R4_PROCID); }
inline uint32_t hsem_hsem_r4_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R4 & HSEM_HSEM_R4_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r4_get_procid(struct HSEM_Type* p) { return (p->HSEM_R4 & HSEM_HSEM_R4_PROCID) >> 0 ; }

// HSEM->HSEM_R5 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R5_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R5_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R5_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r5_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R5 = (p->HSEM_R5 & ~HSEM_HSEM_R5_MASTERID) | ((val<<8) & HSEM_HSEM_R5_MASTERID); }
inline void hsem_hsem_r5_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R5 = (p->HSEM_R5 & ~HSEM_HSEM_R5_PROCID) | ((val<<0) & HSEM_HSEM_R5_PROCID); }
inline uint32_t hsem_hsem_r5_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R5 & HSEM_HSEM_R5_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r5_get_procid(struct HSEM_Type* p) { return (p->HSEM_R5 & HSEM_HSEM_R5_PROCID) >> 0 ; }

// HSEM->HSEM_R6 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R6_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R6_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R6_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r6_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R6 = (p->HSEM_R6 & ~HSEM_HSEM_R6_MASTERID) | ((val<<8) & HSEM_HSEM_R6_MASTERID); }
inline void hsem_hsem_r6_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R6 = (p->HSEM_R6 & ~HSEM_HSEM_R6_PROCID) | ((val<<0) & HSEM_HSEM_R6_PROCID); }
inline uint32_t hsem_hsem_r6_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R6 & HSEM_HSEM_R6_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r6_get_procid(struct HSEM_Type* p) { return (p->HSEM_R6 & HSEM_HSEM_R6_PROCID) >> 0 ; }

// HSEM->HSEM_R7 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R7_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R7_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R7_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r7_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R7 = (p->HSEM_R7 & ~HSEM_HSEM_R7_MASTERID) | ((val<<8) & HSEM_HSEM_R7_MASTERID); }
inline void hsem_hsem_r7_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R7 = (p->HSEM_R7 & ~HSEM_HSEM_R7_PROCID) | ((val<<0) & HSEM_HSEM_R7_PROCID); }
inline uint32_t hsem_hsem_r7_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R7 & HSEM_HSEM_R7_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r7_get_procid(struct HSEM_Type* p) { return (p->HSEM_R7 & HSEM_HSEM_R7_PROCID) >> 0 ; }

// HSEM->HSEM_R8 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R8_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R8_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R8_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r8_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R8 = (p->HSEM_R8 & ~HSEM_HSEM_R8_MASTERID) | ((val<<8) & HSEM_HSEM_R8_MASTERID); }
inline void hsem_hsem_r8_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R8 = (p->HSEM_R8 & ~HSEM_HSEM_R8_PROCID) | ((val<<0) & HSEM_HSEM_R8_PROCID); }
inline uint32_t hsem_hsem_r8_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R8 & HSEM_HSEM_R8_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r8_get_procid(struct HSEM_Type* p) { return (p->HSEM_R8 & HSEM_HSEM_R8_PROCID) >> 0 ; }

// HSEM->HSEM_R9 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R9_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R9_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R9_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r9_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R9 = (p->HSEM_R9 & ~HSEM_HSEM_R9_MASTERID) | ((val<<8) & HSEM_HSEM_R9_MASTERID); }
inline void hsem_hsem_r9_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R9 = (p->HSEM_R9 & ~HSEM_HSEM_R9_PROCID) | ((val<<0) & HSEM_HSEM_R9_PROCID); }
inline uint32_t hsem_hsem_r9_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R9 & HSEM_HSEM_R9_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r9_get_procid(struct HSEM_Type* p) { return (p->HSEM_R9 & HSEM_HSEM_R9_PROCID) >> 0 ; }

// HSEM->HSEM_R10 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R10_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R10_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R10_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r10_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R10 = (p->HSEM_R10 & ~HSEM_HSEM_R10_MASTERID) | ((val<<8) & HSEM_HSEM_R10_MASTERID); }
inline void hsem_hsem_r10_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R10 = (p->HSEM_R10 & ~HSEM_HSEM_R10_PROCID) | ((val<<0) & HSEM_HSEM_R10_PROCID); }
inline uint32_t hsem_hsem_r10_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R10 & HSEM_HSEM_R10_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r10_get_procid(struct HSEM_Type* p) { return (p->HSEM_R10 & HSEM_HSEM_R10_PROCID) >> 0 ; }

// HSEM->HSEM_R11 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R11_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R11_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R11_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r11_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R11 = (p->HSEM_R11 & ~HSEM_HSEM_R11_MASTERID) | ((val<<8) & HSEM_HSEM_R11_MASTERID); }
inline void hsem_hsem_r11_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R11 = (p->HSEM_R11 & ~HSEM_HSEM_R11_PROCID) | ((val<<0) & HSEM_HSEM_R11_PROCID); }
inline uint32_t hsem_hsem_r11_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R11 & HSEM_HSEM_R11_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r11_get_procid(struct HSEM_Type* p) { return (p->HSEM_R11 & HSEM_HSEM_R11_PROCID) >> 0 ; }

// HSEM->HSEM_R12 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R12_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R12_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R12_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r12_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R12 = (p->HSEM_R12 & ~HSEM_HSEM_R12_MASTERID) | ((val<<8) & HSEM_HSEM_R12_MASTERID); }
inline void hsem_hsem_r12_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R12 = (p->HSEM_R12 & ~HSEM_HSEM_R12_PROCID) | ((val<<0) & HSEM_HSEM_R12_PROCID); }
inline uint32_t hsem_hsem_r12_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R12 & HSEM_HSEM_R12_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r12_get_procid(struct HSEM_Type* p) { return (p->HSEM_R12 & HSEM_HSEM_R12_PROCID) >> 0 ; }

// HSEM->HSEM_R13 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R13_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R13_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R13_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r13_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R13 = (p->HSEM_R13 & ~HSEM_HSEM_R13_MASTERID) | ((val<<8) & HSEM_HSEM_R13_MASTERID); }
inline void hsem_hsem_r13_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R13 = (p->HSEM_R13 & ~HSEM_HSEM_R13_PROCID) | ((val<<0) & HSEM_HSEM_R13_PROCID); }
inline uint32_t hsem_hsem_r13_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R13 & HSEM_HSEM_R13_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r13_get_procid(struct HSEM_Type* p) { return (p->HSEM_R13 & HSEM_HSEM_R13_PROCID) >> 0 ; }

// HSEM->HSEM_R14 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R14_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R14_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R14_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r14_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R14 = (p->HSEM_R14 & ~HSEM_HSEM_R14_MASTERID) | ((val<<8) & HSEM_HSEM_R14_MASTERID); }
inline void hsem_hsem_r14_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R14 = (p->HSEM_R14 & ~HSEM_HSEM_R14_PROCID) | ((val<<0) & HSEM_HSEM_R14_PROCID); }
inline uint32_t hsem_hsem_r14_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R14 & HSEM_HSEM_R14_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r14_get_procid(struct HSEM_Type* p) { return (p->HSEM_R14 & HSEM_HSEM_R14_PROCID) >> 0 ; }

// HSEM->HSEM_R15 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R15_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R15_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R15_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r15_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R15 = (p->HSEM_R15 & ~HSEM_HSEM_R15_MASTERID) | ((val<<8) & HSEM_HSEM_R15_MASTERID); }
inline void hsem_hsem_r15_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R15 = (p->HSEM_R15 & ~HSEM_HSEM_R15_PROCID) | ((val<<0) & HSEM_HSEM_R15_PROCID); }
inline uint32_t hsem_hsem_r15_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R15 & HSEM_HSEM_R15_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r15_get_procid(struct HSEM_Type* p) { return (p->HSEM_R15 & HSEM_HSEM_R15_PROCID) >> 0 ; }

// HSEM->HSEM_R16 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R16_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R16_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R16_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r16_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R16 = (p->HSEM_R16 & ~HSEM_HSEM_R16_MASTERID) | ((val<<8) & HSEM_HSEM_R16_MASTERID); }
inline void hsem_hsem_r16_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R16 = (p->HSEM_R16 & ~HSEM_HSEM_R16_PROCID) | ((val<<0) & HSEM_HSEM_R16_PROCID); }
inline uint32_t hsem_hsem_r16_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R16 & HSEM_HSEM_R16_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r16_get_procid(struct HSEM_Type* p) { return (p->HSEM_R16 & HSEM_HSEM_R16_PROCID) >> 0 ; }

// HSEM->HSEM_R17 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R17_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R17_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R17_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r17_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R17 = (p->HSEM_R17 & ~HSEM_HSEM_R17_MASTERID) | ((val<<8) & HSEM_HSEM_R17_MASTERID); }
inline void hsem_hsem_r17_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R17 = (p->HSEM_R17 & ~HSEM_HSEM_R17_PROCID) | ((val<<0) & HSEM_HSEM_R17_PROCID); }
inline uint32_t hsem_hsem_r17_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R17 & HSEM_HSEM_R17_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r17_get_procid(struct HSEM_Type* p) { return (p->HSEM_R17 & HSEM_HSEM_R17_PROCID) >> 0 ; }

// HSEM->HSEM_R18 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R18_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R18_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R18_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r18_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R18 = (p->HSEM_R18 & ~HSEM_HSEM_R18_MASTERID) | ((val<<8) & HSEM_HSEM_R18_MASTERID); }
inline void hsem_hsem_r18_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R18 = (p->HSEM_R18 & ~HSEM_HSEM_R18_PROCID) | ((val<<0) & HSEM_HSEM_R18_PROCID); }
inline uint32_t hsem_hsem_r18_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R18 & HSEM_HSEM_R18_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r18_get_procid(struct HSEM_Type* p) { return (p->HSEM_R18 & HSEM_HSEM_R18_PROCID) >> 0 ; }

// HSEM->HSEM_R19 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R19_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R19_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R19_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r19_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R19 = (p->HSEM_R19 & ~HSEM_HSEM_R19_MASTERID) | ((val<<8) & HSEM_HSEM_R19_MASTERID); }
inline void hsem_hsem_r19_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R19 = (p->HSEM_R19 & ~HSEM_HSEM_R19_PROCID) | ((val<<0) & HSEM_HSEM_R19_PROCID); }
inline uint32_t hsem_hsem_r19_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R19 & HSEM_HSEM_R19_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r19_get_procid(struct HSEM_Type* p) { return (p->HSEM_R19 & HSEM_HSEM_R19_PROCID) >> 0 ; }

// HSEM->HSEM_R20 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R20_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R20_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R20_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r20_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R20 = (p->HSEM_R20 & ~HSEM_HSEM_R20_MASTERID) | ((val<<8) & HSEM_HSEM_R20_MASTERID); }
inline void hsem_hsem_r20_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R20 = (p->HSEM_R20 & ~HSEM_HSEM_R20_PROCID) | ((val<<0) & HSEM_HSEM_R20_PROCID); }
inline uint32_t hsem_hsem_r20_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R20 & HSEM_HSEM_R20_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r20_get_procid(struct HSEM_Type* p) { return (p->HSEM_R20 & HSEM_HSEM_R20_PROCID) >> 0 ; }

// HSEM->HSEM_R21 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R21_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R21_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R21_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r21_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R21 = (p->HSEM_R21 & ~HSEM_HSEM_R21_MASTERID) | ((val<<8) & HSEM_HSEM_R21_MASTERID); }
inline void hsem_hsem_r21_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R21 = (p->HSEM_R21 & ~HSEM_HSEM_R21_PROCID) | ((val<<0) & HSEM_HSEM_R21_PROCID); }
inline uint32_t hsem_hsem_r21_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R21 & HSEM_HSEM_R21_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r21_get_procid(struct HSEM_Type* p) { return (p->HSEM_R21 & HSEM_HSEM_R21_PROCID) >> 0 ; }

// HSEM->HSEM_R22 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R22_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R22_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R22_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r22_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R22 = (p->HSEM_R22 & ~HSEM_HSEM_R22_MASTERID) | ((val<<8) & HSEM_HSEM_R22_MASTERID); }
inline void hsem_hsem_r22_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R22 = (p->HSEM_R22 & ~HSEM_HSEM_R22_PROCID) | ((val<<0) & HSEM_HSEM_R22_PROCID); }
inline uint32_t hsem_hsem_r22_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R22 & HSEM_HSEM_R22_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r22_get_procid(struct HSEM_Type* p) { return (p->HSEM_R22 & HSEM_HSEM_R22_PROCID) >> 0 ; }

// HSEM->HSEM_R23 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R23_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R23_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R23_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r23_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R23 = (p->HSEM_R23 & ~HSEM_HSEM_R23_MASTERID) | ((val<<8) & HSEM_HSEM_R23_MASTERID); }
inline void hsem_hsem_r23_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R23 = (p->HSEM_R23 & ~HSEM_HSEM_R23_PROCID) | ((val<<0) & HSEM_HSEM_R23_PROCID); }
inline uint32_t hsem_hsem_r23_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R23 & HSEM_HSEM_R23_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r23_get_procid(struct HSEM_Type* p) { return (p->HSEM_R23 & HSEM_HSEM_R23_PROCID) >> 0 ; }

// HSEM->HSEM_R24 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R24_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R24_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R24_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r24_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R24 = (p->HSEM_R24 & ~HSEM_HSEM_R24_MASTERID) | ((val<<8) & HSEM_HSEM_R24_MASTERID); }
inline void hsem_hsem_r24_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R24 = (p->HSEM_R24 & ~HSEM_HSEM_R24_PROCID) | ((val<<0) & HSEM_HSEM_R24_PROCID); }
inline uint32_t hsem_hsem_r24_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R24 & HSEM_HSEM_R24_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r24_get_procid(struct HSEM_Type* p) { return (p->HSEM_R24 & HSEM_HSEM_R24_PROCID) >> 0 ; }

// HSEM->HSEM_R25 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R25_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R25_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R25_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r25_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R25 = (p->HSEM_R25 & ~HSEM_HSEM_R25_MASTERID) | ((val<<8) & HSEM_HSEM_R25_MASTERID); }
inline void hsem_hsem_r25_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R25 = (p->HSEM_R25 & ~HSEM_HSEM_R25_PROCID) | ((val<<0) & HSEM_HSEM_R25_PROCID); }
inline uint32_t hsem_hsem_r25_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R25 & HSEM_HSEM_R25_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r25_get_procid(struct HSEM_Type* p) { return (p->HSEM_R25 & HSEM_HSEM_R25_PROCID) >> 0 ; }

// HSEM->HSEM_R26 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R26_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R26_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R26_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r26_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R26 = (p->HSEM_R26 & ~HSEM_HSEM_R26_MASTERID) | ((val<<8) & HSEM_HSEM_R26_MASTERID); }
inline void hsem_hsem_r26_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R26 = (p->HSEM_R26 & ~HSEM_HSEM_R26_PROCID) | ((val<<0) & HSEM_HSEM_R26_PROCID); }
inline uint32_t hsem_hsem_r26_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R26 & HSEM_HSEM_R26_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r26_get_procid(struct HSEM_Type* p) { return (p->HSEM_R26 & HSEM_HSEM_R26_PROCID) >> 0 ; }

// HSEM->HSEM_R27 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R27_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R27_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R27_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r27_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R27 = (p->HSEM_R27 & ~HSEM_HSEM_R27_MASTERID) | ((val<<8) & HSEM_HSEM_R27_MASTERID); }
inline void hsem_hsem_r27_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R27 = (p->HSEM_R27 & ~HSEM_HSEM_R27_PROCID) | ((val<<0) & HSEM_HSEM_R27_PROCID); }
inline uint32_t hsem_hsem_r27_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R27 & HSEM_HSEM_R27_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r27_get_procid(struct HSEM_Type* p) { return (p->HSEM_R27 & HSEM_HSEM_R27_PROCID) >> 0 ; }

// HSEM->HSEM_R28 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R28_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R28_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R28_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r28_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R28 = (p->HSEM_R28 & ~HSEM_HSEM_R28_MASTERID) | ((val<<8) & HSEM_HSEM_R28_MASTERID); }
inline void hsem_hsem_r28_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R28 = (p->HSEM_R28 & ~HSEM_HSEM_R28_PROCID) | ((val<<0) & HSEM_HSEM_R28_PROCID); }
inline uint32_t hsem_hsem_r28_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R28 & HSEM_HSEM_R28_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r28_get_procid(struct HSEM_Type* p) { return (p->HSEM_R28 & HSEM_HSEM_R28_PROCID) >> 0 ; }

// HSEM->HSEM_R29 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R29_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R29_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R29_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r29_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R29 = (p->HSEM_R29 & ~HSEM_HSEM_R29_MASTERID) | ((val<<8) & HSEM_HSEM_R29_MASTERID); }
inline void hsem_hsem_r29_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R29 = (p->HSEM_R29 & ~HSEM_HSEM_R29_PROCID) | ((val<<0) & HSEM_HSEM_R29_PROCID); }
inline uint32_t hsem_hsem_r29_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R29 & HSEM_HSEM_R29_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r29_get_procid(struct HSEM_Type* p) { return (p->HSEM_R29 & HSEM_HSEM_R29_PROCID) >> 0 ; }

// HSEM->HSEM_R30 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R30_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R30_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R30_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r30_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R30 = (p->HSEM_R30 & ~HSEM_HSEM_R30_MASTERID) | ((val<<8) & HSEM_HSEM_R30_MASTERID); }
inline void hsem_hsem_r30_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R30 = (p->HSEM_R30 & ~HSEM_HSEM_R30_PROCID) | ((val<<0) & HSEM_HSEM_R30_PROCID); }
inline uint32_t hsem_hsem_r30_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R30 & HSEM_HSEM_R30_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r30_get_procid(struct HSEM_Type* p) { return (p->HSEM_R30 & HSEM_HSEM_R30_PROCID) >> 0 ; }

// HSEM->HSEM_R31 HSEM register HSEM_R0 HSEM_R31
enum {
	HSEM_HSEM_R31_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_R31_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_R31_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline void hsem_hsem_r31_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R31 = (p->HSEM_R31 & ~HSEM_HSEM_R31_MASTERID) | ((val<<8) & HSEM_HSEM_R31_MASTERID); }
inline void hsem_hsem_r31_set_procid(struct HSEM_Type* p, uint32_t val) { p->HSEM_R31 = (p->HSEM_R31 & ~HSEM_HSEM_R31_PROCID) | ((val<<0) & HSEM_HSEM_R31_PROCID); }
inline uint32_t hsem_hsem_r31_get_masterid(struct HSEM_Type* p) { return (p->HSEM_R31 & HSEM_HSEM_R31_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_r31_get_procid(struct HSEM_Type* p) { return (p->HSEM_R31 & HSEM_HSEM_R31_PROCID) >> 0 ; }

// HSEM->HSEM_RLR0 HSEM Read lock register
enum {
	HSEM_HSEM_RLR0_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR0_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR0_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr0_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR0 & HSEM_HSEM_RLR0_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr0_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR0 & HSEM_HSEM_RLR0_PROCID) >> 0 ; }

// HSEM->HSEM_RLR1 HSEM Read lock register
enum {
	HSEM_HSEM_RLR1_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR1_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR1_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr1_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR1 & HSEM_HSEM_RLR1_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr1_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR1 & HSEM_HSEM_RLR1_PROCID) >> 0 ; }

// HSEM->HSEM_RLR2 HSEM Read lock register
enum {
	HSEM_HSEM_RLR2_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR2_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR2_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr2_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR2 & HSEM_HSEM_RLR2_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr2_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR2 & HSEM_HSEM_RLR2_PROCID) >> 0 ; }

// HSEM->HSEM_RLR3 HSEM Read lock register
enum {
	HSEM_HSEM_RLR3_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR3_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR3_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr3_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR3 & HSEM_HSEM_RLR3_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr3_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR3 & HSEM_HSEM_RLR3_PROCID) >> 0 ; }

// HSEM->HSEM_RLR4 HSEM Read lock register
enum {
	HSEM_HSEM_RLR4_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR4_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR4_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr4_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR4 & HSEM_HSEM_RLR4_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr4_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR4 & HSEM_HSEM_RLR4_PROCID) >> 0 ; }

// HSEM->HSEM_RLR5 HSEM Read lock register
enum {
	HSEM_HSEM_RLR5_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR5_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR5_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr5_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR5 & HSEM_HSEM_RLR5_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr5_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR5 & HSEM_HSEM_RLR5_PROCID) >> 0 ; }

// HSEM->HSEM_RLR6 HSEM Read lock register
enum {
	HSEM_HSEM_RLR6_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR6_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR6_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr6_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR6 & HSEM_HSEM_RLR6_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr6_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR6 & HSEM_HSEM_RLR6_PROCID) >> 0 ; }

// HSEM->HSEM_RLR7 HSEM Read lock register
enum {
	HSEM_HSEM_RLR7_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR7_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR7_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr7_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR7 & HSEM_HSEM_RLR7_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr7_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR7 & HSEM_HSEM_RLR7_PROCID) >> 0 ; }

// HSEM->HSEM_RLR8 HSEM Read lock register
enum {
	HSEM_HSEM_RLR8_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR8_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR8_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr8_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR8 & HSEM_HSEM_RLR8_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr8_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR8 & HSEM_HSEM_RLR8_PROCID) >> 0 ; }

// HSEM->HSEM_RLR9 HSEM Read lock register
enum {
	HSEM_HSEM_RLR9_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR9_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR9_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr9_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR9 & HSEM_HSEM_RLR9_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr9_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR9 & HSEM_HSEM_RLR9_PROCID) >> 0 ; }

// HSEM->HSEM_RLR10 HSEM Read lock register
enum {
	HSEM_HSEM_RLR10_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR10_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR10_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr10_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR10 & HSEM_HSEM_RLR10_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr10_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR10 & HSEM_HSEM_RLR10_PROCID) >> 0 ; }

// HSEM->HSEM_RLR11 HSEM Read lock register
enum {
	HSEM_HSEM_RLR11_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR11_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR11_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr11_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR11 & HSEM_HSEM_RLR11_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr11_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR11 & HSEM_HSEM_RLR11_PROCID) >> 0 ; }

// HSEM->HSEM_RLR12 HSEM Read lock register
enum {
	HSEM_HSEM_RLR12_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR12_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR12_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr12_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR12 & HSEM_HSEM_RLR12_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr12_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR12 & HSEM_HSEM_RLR12_PROCID) >> 0 ; }

// HSEM->HSEM_RLR13 HSEM Read lock register
enum {
	HSEM_HSEM_RLR13_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR13_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR13_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr13_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR13 & HSEM_HSEM_RLR13_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr13_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR13 & HSEM_HSEM_RLR13_PROCID) >> 0 ; }

// HSEM->HSEM_RLR14 HSEM Read lock register
enum {
	HSEM_HSEM_RLR14_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR14_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR14_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr14_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR14 & HSEM_HSEM_RLR14_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr14_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR14 & HSEM_HSEM_RLR14_PROCID) >> 0 ; }

// HSEM->HSEM_RLR15 HSEM Read lock register
enum {
	HSEM_HSEM_RLR15_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR15_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR15_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr15_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR15 & HSEM_HSEM_RLR15_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr15_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR15 & HSEM_HSEM_RLR15_PROCID) >> 0 ; }

// HSEM->HSEM_RLR16 HSEM Read lock register
enum {
	HSEM_HSEM_RLR16_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR16_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR16_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr16_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR16 & HSEM_HSEM_RLR16_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr16_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR16 & HSEM_HSEM_RLR16_PROCID) >> 0 ; }

// HSEM->HSEM_RLR17 HSEM Read lock register
enum {
	HSEM_HSEM_RLR17_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR17_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR17_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr17_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR17 & HSEM_HSEM_RLR17_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr17_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR17 & HSEM_HSEM_RLR17_PROCID) >> 0 ; }

// HSEM->HSEM_RLR18 HSEM Read lock register
enum {
	HSEM_HSEM_RLR18_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR18_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR18_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr18_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR18 & HSEM_HSEM_RLR18_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr18_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR18 & HSEM_HSEM_RLR18_PROCID) >> 0 ; }

// HSEM->HSEM_RLR19 HSEM Read lock register
enum {
	HSEM_HSEM_RLR19_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR19_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR19_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr19_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR19 & HSEM_HSEM_RLR19_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr19_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR19 & HSEM_HSEM_RLR19_PROCID) >> 0 ; }

// HSEM->HSEM_RLR20 HSEM Read lock register
enum {
	HSEM_HSEM_RLR20_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR20_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR20_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr20_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR20 & HSEM_HSEM_RLR20_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr20_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR20 & HSEM_HSEM_RLR20_PROCID) >> 0 ; }

// HSEM->HSEM_RLR21 HSEM Read lock register
enum {
	HSEM_HSEM_RLR21_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR21_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR21_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr21_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR21 & HSEM_HSEM_RLR21_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr21_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR21 & HSEM_HSEM_RLR21_PROCID) >> 0 ; }

// HSEM->HSEM_RLR22 HSEM Read lock register
enum {
	HSEM_HSEM_RLR22_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR22_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR22_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr22_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR22 & HSEM_HSEM_RLR22_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr22_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR22 & HSEM_HSEM_RLR22_PROCID) >> 0 ; }

// HSEM->HSEM_RLR23 HSEM Read lock register
enum {
	HSEM_HSEM_RLR23_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR23_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR23_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr23_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR23 & HSEM_HSEM_RLR23_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr23_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR23 & HSEM_HSEM_RLR23_PROCID) >> 0 ; }

// HSEM->HSEM_RLR24 HSEM Read lock register
enum {
	HSEM_HSEM_RLR24_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR24_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR24_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr24_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR24 & HSEM_HSEM_RLR24_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr24_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR24 & HSEM_HSEM_RLR24_PROCID) >> 0 ; }

// HSEM->HSEM_RLR25 HSEM Read lock register
enum {
	HSEM_HSEM_RLR25_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR25_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR25_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr25_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR25 & HSEM_HSEM_RLR25_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr25_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR25 & HSEM_HSEM_RLR25_PROCID) >> 0 ; }

// HSEM->HSEM_RLR26 HSEM Read lock register
enum {
	HSEM_HSEM_RLR26_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR26_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR26_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr26_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR26 & HSEM_HSEM_RLR26_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr26_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR26 & HSEM_HSEM_RLR26_PROCID) >> 0 ; }

// HSEM->HSEM_RLR27 HSEM Read lock register
enum {
	HSEM_HSEM_RLR27_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR27_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR27_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr27_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR27 & HSEM_HSEM_RLR27_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr27_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR27 & HSEM_HSEM_RLR27_PROCID) >> 0 ; }

// HSEM->HSEM_RLR28 HSEM Read lock register
enum {
	HSEM_HSEM_RLR28_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR28_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR28_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr28_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR28 & HSEM_HSEM_RLR28_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr28_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR28 & HSEM_HSEM_RLR28_PROCID) >> 0 ; }

// HSEM->HSEM_RLR29 HSEM Read lock register
enum {
	HSEM_HSEM_RLR29_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR29_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR29_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr29_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR29 & HSEM_HSEM_RLR29_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr29_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR29 & HSEM_HSEM_RLR29_PROCID) >> 0 ; }

// HSEM->HSEM_RLR30 HSEM Read lock register
enum {
	HSEM_HSEM_RLR30_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR30_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR30_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr30_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR30 & HSEM_HSEM_RLR30_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr30_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR30 & HSEM_HSEM_RLR30_PROCID) >> 0 ; }

// HSEM->HSEM_RLR31 HSEM Read lock register
enum {
	HSEM_HSEM_RLR31_LOCK = 1UL<<31, // Lock indication
	HSEM_HSEM_RLR31_MASTERID = ((1UL<<8)-1) << 8, // Semaphore MasterID
	HSEM_HSEM_RLR31_PROCID = ((1UL<<8)-1) << 0, // Semaphore ProcessID		
};
inline uint32_t hsem_hsem_rlr31_get_masterid(struct HSEM_Type* p) { return (p->HSEM_RLR31 & HSEM_HSEM_RLR31_MASTERID) >> 8 ; }
inline uint32_t hsem_hsem_rlr31_get_procid(struct HSEM_Type* p) { return (p->HSEM_RLR31 & HSEM_HSEM_RLR31_PROCID) >> 0 ; }

// HSEM->HSEM_CR HSEM Clear register
enum {
	HSEM_HSEM_CR_KEY = ((1UL<<16)-1) << 16, // Semaphore clear Key
	HSEM_HSEM_CR_MASTERID = ((1UL<<8)-1) << 8, // MasterID of semaphores to be cleared		
};
inline void hsem_hsem_cr_set_key(struct HSEM_Type* p, uint32_t val) { p->HSEM_CR = (p->HSEM_CR & ~HSEM_HSEM_CR_KEY) | ((val<<16) & HSEM_HSEM_CR_KEY); }
inline void hsem_hsem_cr_set_masterid(struct HSEM_Type* p, uint32_t val) { p->HSEM_CR = (p->HSEM_CR & ~HSEM_HSEM_CR_MASTERID) | ((val<<8) & HSEM_HSEM_CR_MASTERID); }
inline uint32_t hsem_hsem_cr_get_key(struct HSEM_Type* p) { return (p->HSEM_CR & HSEM_HSEM_CR_KEY) >> 16 ; }
inline uint32_t hsem_hsem_cr_get_masterid(struct HSEM_Type* p) { return (p->HSEM_CR & HSEM_HSEM_CR_MASTERID) >> 8 ; }

// HSEM->HSEM_KEYR HSEM Interrupt clear register
enum {
	HSEM_HSEM_KEYR_KEY = ((1UL<<16)-1) << 16, // Semaphore Clear Key		
};
inline void hsem_hsem_keyr_set_key(struct HSEM_Type* p, uint32_t val) { p->HSEM_KEYR = (p->HSEM_KEYR & ~HSEM_HSEM_KEYR_KEY) | ((val<<16) & HSEM_HSEM_KEYR_KEY); }
inline uint32_t hsem_hsem_keyr_get_key(struct HSEM_Type* p) { return (p->HSEM_KEYR & HSEM_HSEM_KEYR_KEY) >> 16 ; }

/* I2C */
struct I2C1_Type {
	__IO uint32_t CR1; // @0 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	__IO uint32_t CR2; // @4 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	__IO uint16_t OAR1; // @8 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t OAR2; // @12 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t TIMINGR; // @16 Access: No wait states
	__IO uint32_t TIMEOUTR; // @20 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
	__IO uint32_t ISR; // @24 Access: No wait states
	__O uint16_t ICR; // @28 Access: No wait states
	 uint8_t RESERVED2[2]; // @30 
	__I uint8_t PECR; // @32 Access: No wait states
	 uint8_t RESERVED3[3]; // @33 
	__I uint8_t RXDR; // @36 Access: No wait states
	 uint8_t RESERVED4[3]; // @37 
	__IO uint8_t TXDR; // @40 Access: No wait states
};

// I2C1->CR1 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
enum {
	I2C1_CR1_PECEN = 1UL<<23, // PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_CR1_ALERTEN = 1UL<<22, // SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_CR1_SMBDEN = 1UL<<21, // SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_CR1_SMBHEN = 1UL<<20, // SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_CR1_GCEN = 1UL<<19, // General call enable
	I2C1_CR1_WUPEN = 1UL<<18, // Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
	I2C1_CR1_NOSTRETCH = 1UL<<17, // Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
	I2C1_CR1_SBC = 1UL<<16, // Slave byte control This bit is used to enable hardware byte control in slave mode.
	I2C1_CR1_RXDMAEN = 1UL<<15, // DMA reception requests enable
	I2C1_CR1_TXDMAEN = 1UL<<14, // DMA transmission requests enable
	I2C1_CR1_ANFOFF = 1UL<<12, // Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
	I2C1_CR1_DNF = ((1UL<<4)-1) << 8, // Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
	I2C1_CR1_ERRIE = 1UL<<7, // Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
	I2C1_CR1_TCIE = 1UL<<6, // Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
	I2C1_CR1_STOPIE = 1UL<<5, // STOP detection Interrupt enable
	I2C1_CR1_NACKIE = 1UL<<4, // Not acknowledge received Interrupt enable
	I2C1_CR1_ADDRIE = 1UL<<3, // Address match Interrupt enable (slave only)
	I2C1_CR1_RXIE = 1UL<<2, // RX Interrupt enable
	I2C1_CR1_TXIE = 1UL<<1, // TX Interrupt enable
	I2C1_CR1_PE = 1UL<<0, // Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.		
};
inline void i2c1_cr1_set_dnf(struct I2C1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C1_CR1_DNF) | ((val<<8) & I2C1_CR1_DNF); }
inline uint32_t i2c1_cr1_get_dnf(struct I2C1_Type* p) { return (p->CR1 & I2C1_CR1_DNF) >> 8 ; }

// I2C1->CR2 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
enum {
	I2C1_CR2_PECBYTE = 1UL<<26, // Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_CR2_AUTOEND = 1UL<<25, // Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
	I2C1_CR2_RELOAD = 1UL<<24, // NBYTES reload mode This bit is set and cleared by software.
	I2C1_CR2_NBYTES = ((1UL<<8)-1) << 16, // Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_NACK = 1UL<<15, // NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
	I2C1_CR2_STOP = 1UL<<14, // Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
	I2C1_CR2_START = 1UL<<13, // Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
	I2C1_CR2_HEAD10R = 1UL<<12, // 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
	I2C1_CR2_ADD10 = 1UL<<11, // 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
	I2C1_CR2_RD_WRN = 1UL<<10, // Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
	I2C1_CR2_SADD9 = 1UL<<9, // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD8 = 1UL<<8, // Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD7 = 1UL<<7, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD6 = 1UL<<6, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD5 = 1UL<<5, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD4 = 1UL<<4, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD3 = 1UL<<3, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD2 = 1UL<<2, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD1 = 1UL<<1, // Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
	I2C1_CR2_SADD0 = 1UL<<0, // Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.		
};
inline void i2c1_cr2_set_nbytes(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_NBYTES) | ((val<<16) & I2C1_CR2_NBYTES); }
inline uint32_t i2c1_cr2_get_nbytes(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_NBYTES) >> 16 ; }

// I2C1->OAR1 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
enum {
	I2C1_OAR1_OA1EN = 1UL<<15, // Own Address 1 enable
	I2C1_OAR1_OA1MODE = 1UL<<10, // Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
	I2C1_OAR1_OA1 = ((1UL<<10)-1) << 0, // Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.		
};
inline void i2c1_oar1_set_oa1(struct I2C1_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1) | ((val<<0) & I2C1_OAR1_OA1); }
inline uint32_t i2c1_oar1_get_oa1(struct I2C1_Type* p) { return (p->OAR1 & I2C1_OAR1_OA1) >> 0 ; }

// I2C1->OAR2 Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
enum {
	I2C1_OAR2_OA2EN = 1UL<<15, // Own Address 2 enable
	I2C1_OAR2_OA2MSK = ((1UL<<3)-1) << 8, // Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
	I2C1_OAR2_OA2 = ((1UL<<7)-1) << 1, // Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.		
};
inline void i2c1_oar2_set_oa2msk(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2MSK) | ((val<<8) & I2C1_OAR2_OA2MSK); }
inline void i2c1_oar2_set_oa2(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2) | ((val<<1) & I2C1_OAR2_OA2); }
inline uint32_t i2c1_oar2_get_oa2msk(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2MSK) >> 8 ; }
inline uint32_t i2c1_oar2_get_oa2(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2) >> 1 ; }

// I2C1->TIMINGR Access: No wait states
enum {
	I2C1_TIMINGR_PRESC = ((1UL<<4)-1) << 28, // Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
	I2C1_TIMINGR_SCLDEL = ((1UL<<4)-1) << 20, // Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
	I2C1_TIMINGR_SDADEL = ((1UL<<4)-1) << 16, // Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
	I2C1_TIMINGR_SCLH = ((1UL<<8)-1) << 8, // SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
	I2C1_TIMINGR_SCLL = ((1UL<<8)-1) << 0, // SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.		
};
inline void i2c1_timingr_set_presc(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_PRESC) | ((val<<28) & I2C1_TIMINGR_PRESC); }
inline void i2c1_timingr_set_scldel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLDEL) | ((val<<20) & I2C1_TIMINGR_SCLDEL); }
inline void i2c1_timingr_set_sdadel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SDADEL) | ((val<<16) & I2C1_TIMINGR_SDADEL); }
inline void i2c1_timingr_set_sclh(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLH) | ((val<<8) & I2C1_TIMINGR_SCLH); }
inline void i2c1_timingr_set_scll(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLL) | ((val<<0) & I2C1_TIMINGR_SCLL); }
inline uint32_t i2c1_timingr_get_presc(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_PRESC) >> 28 ; }
inline uint32_t i2c1_timingr_get_scldel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLDEL) >> 20 ; }
inline uint32_t i2c1_timingr_get_sdadel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SDADEL) >> 16 ; }
inline uint32_t i2c1_timingr_get_sclh(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLH) >> 8 ; }
inline uint32_t i2c1_timingr_get_scll(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLL) >> 0 ; }

// I2C1->TIMEOUTR Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
enum {
	I2C1_TIMEOUTR_TEXTEN = 1UL<<31, // Extended clock timeout enable
	I2C1_TIMEOUTR_TIMEOUTB = ((1UL<<12)-1) << 16, // Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
	I2C1_TIMEOUTR_TIMOUTEN = 1UL<<15, // Clock timeout enable
	I2C1_TIMEOUTR_TIDLE = 1UL<<12, // Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
	I2C1_TIMEOUTR_TIMEOUTA = ((1UL<<12)-1) << 0, // Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.		
};
inline void i2c1_timeoutr_set_timeoutb(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTB) | ((val<<16) & I2C1_TIMEOUTR_TIMEOUTB); }
inline void i2c1_timeoutr_set_timeouta(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTA) | ((val<<0) & I2C1_TIMEOUTR_TIMEOUTA); }
inline uint32_t i2c1_timeoutr_get_timeoutb(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTB) >> 16 ; }
inline uint32_t i2c1_timeoutr_get_timeouta(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTA) >> 0 ; }

// I2C1->ISR Access: No wait states
enum {
	I2C1_ISR_ADDCODE = ((1UL<<7)-1) << 17, // Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
	I2C1_ISR_DIR = 1UL<<16, // Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
	I2C1_ISR_BUSY = 1UL<<15, // Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
	I2C1_ISR_ALERT = 1UL<<13, // SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_ISR_TIMEOUT = 1UL<<12, // Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_ISR_PECERR = 1UL<<11, // PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_ISR_OVR = 1UL<<10, // Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_ARLO = 1UL<<9, // Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_BERR = 1UL<<8, // Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_TCR = 1UL<<7, // Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
	I2C1_ISR_TC = 1UL<<6, // Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_STOPF = 1UL<<5, // Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_NACKF = 1UL<<4, // Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_ADDR = 1UL<<3, // Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_RXNE = 1UL<<2, // Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_TXIS = 1UL<<1, // Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
	I2C1_ISR_TXE = 1UL<<0, // Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.		
};
inline void i2c1_isr_set_addcode(struct I2C1_Type* p, uint32_t val) { p->ISR = (p->ISR & ~I2C1_ISR_ADDCODE) | ((val<<17) & I2C1_ISR_ADDCODE); }
inline uint32_t i2c1_isr_get_addcode(struct I2C1_Type* p) { return (p->ISR & I2C1_ISR_ADDCODE) >> 17 ; }

// I2C1->ICR Access: No wait states
enum {
	I2C1_ICR_ALERTCF = 1UL<<13, // Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_ICR_TIMOUTCF = 1UL<<12, // Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_ICR_PECCF = 1UL<<11, // PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
	I2C1_ICR_OVRCF = 1UL<<10, // Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
	I2C1_ICR_ARLOCF = 1UL<<9, // Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
	I2C1_ICR_BERRCF = 1UL<<8, // Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
	I2C1_ICR_STOPCF = 1UL<<5, // Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
	I2C1_ICR_NACKCF = 1UL<<4, // Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
	I2C1_ICR_ADDRCF = 1UL<<3, // Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.		
};




/* IWDG */
struct IWDG1_Type {
	__O uint16_t KR; // @0 Key register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t PR; // @4 Prescaler register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t RLR; // @8 Reload register
	 uint8_t RESERVED2[2]; // @10 
	__I uint8_t SR; // @12 Status register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t WINR; // @16 Window register
};

// IWDG1->PR Prescaler register
enum {
	IWDG1_PR_PR = ((1UL<<3)-1) << 0, // Prescaler divider These bits are write access protected see Section23.3.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset.		
};
inline void iwdg1_pr_set_pr(struct IWDG1_Type* p, uint32_t val) { p->PR = (p->PR & ~IWDG1_PR_PR) | ((val<<0) & IWDG1_PR_PR); }
inline uint32_t iwdg1_pr_get_pr(struct IWDG1_Type* p) { return (p->PR & IWDG1_PR_PR) >> 0 ; }

// IWDG1->RLR Reload register
enum {
	IWDG1_RLR_RL = ((1UL<<12)-1) << 0, // Watchdog counter reload value These bits are write access protected see Section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset.		
};
inline void iwdg1_rlr_set_rl(struct IWDG1_Type* p, uint32_t val) { p->RLR = (p->RLR & ~IWDG1_RLR_RL) | ((val<<0) & IWDG1_RLR_RL); }
inline uint32_t iwdg1_rlr_get_rl(struct IWDG1_Type* p) { return (p->RLR & IWDG1_RLR_RL) >> 0 ; }

// IWDG1->SR Status register
enum {
	IWDG1_SR_WVU = 1UL<<2, // Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1
	IWDG1_SR_RVU = 1UL<<1, // Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Reload value can be updated only when RVU bit is reset.
	IWDG1_SR_PVU = 1UL<<0, // Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Prescaler value can be updated only when PVU bit is reset.		
};

// IWDG1->WINR Window register
enum {
	IWDG1_WINR_WIN = ((1UL<<12)-1) << 0, // Watchdog counter window value These bits are write access protected see Section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 The WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset.		
};
inline void iwdg1_winr_set_win(struct IWDG1_Type* p, uint32_t val) { p->WINR = (p->WINR & ~IWDG1_WINR_WIN) | ((val<<0) & IWDG1_WINR_WIN); }
inline uint32_t iwdg1_winr_get_win(struct IWDG1_Type* p) { return (p->WINR & IWDG1_WINR_WIN) >> 0 ; }


/* JPEG */
struct JPEG_Type {
	__O uint8_t CONFR0; // @0 JPEG codec control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CONFR1; // @4 JPEG codec configuration register 1
	__IO uint32_t CONFR2; // @8 JPEG codec configuration register 2
	__IO uint32_t CONFR3; // @12 JPEG codec configuration register 3
	__IO uint16_t CONFRN1; // @16 JPEG codec configuration register 4-7
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t CONFRN2; // @20 JPEG codec configuration register 4-7
	 uint8_t RESERVED2[2]; // @22 
	__IO uint16_t CONFRN3; // @24 JPEG codec configuration register 4-7
	 uint8_t RESERVED3[2]; // @26 
	__IO uint16_t CONFRN4; // @28 JPEG codec configuration register 4-7
	 uint8_t RESERVED4[18]; // @30 
	__IO uint16_t CR; // @48 JPEG control register
	 uint8_t RESERVED5[2]; // @50 
	__I uint8_t SR; // @52 JPEG status register
	 uint8_t RESERVED6[3]; // @53 
	__IO uint8_t CFR; // @56 JPEG clear flag register
	 uint8_t RESERVED7[7]; // @57 
	__O uint32_t DIR; // @64 JPEG data input register
	__I uint32_t DOR; // @68 JPEG data output register
};

// JPEG->CONFR0 JPEG codec control register
enum {
	JPEG_CONFR0_START = 1UL<<0, // Start This bit start or stop the encoding or decoding process. Read this register always return 0.		
};

// JPEG->CONFR1 JPEG codec configuration register 1
enum {
	JPEG_CONFR1_YSIZE = ((1UL<<16)-1) << 16, // Y Size This field defines the number of lines in source image.
	JPEG_CONFR1_HDR = 1UL<<8, // Header Processing This bit enable the header processing (generation/parsing).
	JPEG_CONFR1_NS = ((1UL<<2)-1) << 6, // Number of components for Scan This field defines the number of components minus 1 for scan header marker segment.
	JPEG_CONFR1_COLORSPACE = ((1UL<<2)-1) << 4, // Color Space This filed defines the number of quantization tables minus 1 to insert in the output stream.
	JPEG_CONFR1_DE = 1UL<<3, // Decoding Enable This bit selects the coding or decoding process
	JPEG_CONFR1_NF = ((1UL<<2)-1) << 0, // Number of color components This field defines the number of color components minus 1.		
};
inline void jpeg_confr1_set_ysize(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_YSIZE) | ((val<<16) & JPEG_CONFR1_YSIZE); }
inline void jpeg_confr1_set_ns(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_NS) | ((val<<6) & JPEG_CONFR1_NS); }
inline void jpeg_confr1_set_colorspace(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_COLORSPACE) | ((val<<4) & JPEG_CONFR1_COLORSPACE); }
inline void jpeg_confr1_set_nf(struct JPEG_Type* p, uint32_t val) { p->CONFR1 = (p->CONFR1 & ~JPEG_CONFR1_NF) | ((val<<0) & JPEG_CONFR1_NF); }
inline uint32_t jpeg_confr1_get_ysize(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_YSIZE) >> 16 ; }
inline uint32_t jpeg_confr1_get_ns(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_NS) >> 6 ; }
inline uint32_t jpeg_confr1_get_colorspace(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_COLORSPACE) >> 4 ; }
inline uint32_t jpeg_confr1_get_nf(struct JPEG_Type* p) { return (p->CONFR1 & JPEG_CONFR1_NF) >> 0 ; }

// JPEG->CONFR2 JPEG codec configuration register 2
enum {
	JPEG_CONFR2_NMCU = ((1UL<<26)-1) << 0, // Number of MCU For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated.		
};
inline void jpeg_confr2_set_nmcu(struct JPEG_Type* p, uint32_t val) { p->CONFR2 = (p->CONFR2 & ~JPEG_CONFR2_NMCU) | ((val<<0) & JPEG_CONFR2_NMCU); }
inline uint32_t jpeg_confr2_get_nmcu(struct JPEG_Type* p) { return (p->CONFR2 & JPEG_CONFR2_NMCU) >> 0 ; }

// JPEG->CONFR3 JPEG codec configuration register 3
enum {
	JPEG_CONFR3_XSIZE = ((1UL<<16)-1) << 16, // X size This field defines the number of pixels per line.		
};
inline void jpeg_confr3_set_xsize(struct JPEG_Type* p, uint32_t val) { p->CONFR3 = (p->CONFR3 & ~JPEG_CONFR3_XSIZE) | ((val<<16) & JPEG_CONFR3_XSIZE); }
inline uint32_t jpeg_confr3_get_xsize(struct JPEG_Type* p) { return (p->CONFR3 & JPEG_CONFR3_XSIZE) >> 16 ; }

// JPEG->CONFRN1 JPEG codec configuration register 4-7
enum {
	JPEG_CONFRN1_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor Horizontal sampling factor for component i.
	JPEG_CONFRN1_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor Vertical sampling factor for component i.
	JPEG_CONFRN1_NB = ((1UL<<4)-1) << 4, // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
	JPEG_CONFRN1_QT = ((1UL<<2)-1) << 2, // Quantization Table Selects quantization table associated with a color component.
	JPEG_CONFRN1_HA = 1UL<<1, // Huffman AC Selects the Huffman table for encoding the AC coefficients.
	JPEG_CONFRN1_HD = 1UL<<0, // Huffman DC Selects the Huffman table for encoding the DC coefficients.		
};
inline void jpeg_confrn1_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN1 = (p->CONFRN1 & ~JPEG_CONFRN1_HSF) | ((val<<12) & JPEG_CONFRN1_HSF); }
inline void jpeg_confrn1_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN1 = (p->CONFRN1 & ~JPEG_CONFRN1_VSF) | ((val<<8) & JPEG_CONFRN1_VSF); }
inline void jpeg_confrn1_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFRN1 = (p->CONFRN1 & ~JPEG_CONFRN1_NB) | ((val<<4) & JPEG_CONFRN1_NB); }
inline void jpeg_confrn1_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFRN1 = (p->CONFRN1 & ~JPEG_CONFRN1_QT) | ((val<<2) & JPEG_CONFRN1_QT); }
inline uint32_t jpeg_confrn1_get_hsf(struct JPEG_Type* p) { return (p->CONFRN1 & JPEG_CONFRN1_HSF) >> 12 ; }
inline uint32_t jpeg_confrn1_get_vsf(struct JPEG_Type* p) { return (p->CONFRN1 & JPEG_CONFRN1_VSF) >> 8 ; }
inline uint32_t jpeg_confrn1_get_nb(struct JPEG_Type* p) { return (p->CONFRN1 & JPEG_CONFRN1_NB) >> 4 ; }
inline uint32_t jpeg_confrn1_get_qt(struct JPEG_Type* p) { return (p->CONFRN1 & JPEG_CONFRN1_QT) >> 2 ; }

// JPEG->CONFRN2 JPEG codec configuration register 4-7
enum {
	JPEG_CONFRN2_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor Horizontal sampling factor for component i.
	JPEG_CONFRN2_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor Vertical sampling factor for component i.
	JPEG_CONFRN2_NB = ((1UL<<4)-1) << 4, // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
	JPEG_CONFRN2_QT = ((1UL<<2)-1) << 2, // Quantization Table Selects quantization table associated with a color component.
	JPEG_CONFRN2_HA = 1UL<<1, // Huffman AC Selects the Huffman table for encoding the AC coefficients.
	JPEG_CONFRN2_HD = 1UL<<0, // Huffman DC Selects the Huffman table for encoding the DC coefficients.		
};
inline void jpeg_confrn2_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN2 = (p->CONFRN2 & ~JPEG_CONFRN2_HSF) | ((val<<12) & JPEG_CONFRN2_HSF); }
inline void jpeg_confrn2_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN2 = (p->CONFRN2 & ~JPEG_CONFRN2_VSF) | ((val<<8) & JPEG_CONFRN2_VSF); }
inline void jpeg_confrn2_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFRN2 = (p->CONFRN2 & ~JPEG_CONFRN2_NB) | ((val<<4) & JPEG_CONFRN2_NB); }
inline void jpeg_confrn2_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFRN2 = (p->CONFRN2 & ~JPEG_CONFRN2_QT) | ((val<<2) & JPEG_CONFRN2_QT); }
inline uint32_t jpeg_confrn2_get_hsf(struct JPEG_Type* p) { return (p->CONFRN2 & JPEG_CONFRN2_HSF) >> 12 ; }
inline uint32_t jpeg_confrn2_get_vsf(struct JPEG_Type* p) { return (p->CONFRN2 & JPEG_CONFRN2_VSF) >> 8 ; }
inline uint32_t jpeg_confrn2_get_nb(struct JPEG_Type* p) { return (p->CONFRN2 & JPEG_CONFRN2_NB) >> 4 ; }
inline uint32_t jpeg_confrn2_get_qt(struct JPEG_Type* p) { return (p->CONFRN2 & JPEG_CONFRN2_QT) >> 2 ; }

// JPEG->CONFRN3 JPEG codec configuration register 4-7
enum {
	JPEG_CONFRN3_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor Horizontal sampling factor for component i.
	JPEG_CONFRN3_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor Vertical sampling factor for component i.
	JPEG_CONFRN3_NB = ((1UL<<4)-1) << 4, // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
	JPEG_CONFRN3_QT = ((1UL<<2)-1) << 2, // Quantization Table Selects quantization table associated with a color component.
	JPEG_CONFRN3_HA = 1UL<<1, // Huffman AC Selects the Huffman table for encoding the AC coefficients.
	JPEG_CONFRN3_HD = 1UL<<0, // Huffman DC Selects the Huffman table for encoding the DC coefficients.		
};
inline void jpeg_confrn3_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN3 = (p->CONFRN3 & ~JPEG_CONFRN3_HSF) | ((val<<12) & JPEG_CONFRN3_HSF); }
inline void jpeg_confrn3_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN3 = (p->CONFRN3 & ~JPEG_CONFRN3_VSF) | ((val<<8) & JPEG_CONFRN3_VSF); }
inline void jpeg_confrn3_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFRN3 = (p->CONFRN3 & ~JPEG_CONFRN3_NB) | ((val<<4) & JPEG_CONFRN3_NB); }
inline void jpeg_confrn3_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFRN3 = (p->CONFRN3 & ~JPEG_CONFRN3_QT) | ((val<<2) & JPEG_CONFRN3_QT); }
inline uint32_t jpeg_confrn3_get_hsf(struct JPEG_Type* p) { return (p->CONFRN3 & JPEG_CONFRN3_HSF) >> 12 ; }
inline uint32_t jpeg_confrn3_get_vsf(struct JPEG_Type* p) { return (p->CONFRN3 & JPEG_CONFRN3_VSF) >> 8 ; }
inline uint32_t jpeg_confrn3_get_nb(struct JPEG_Type* p) { return (p->CONFRN3 & JPEG_CONFRN3_NB) >> 4 ; }
inline uint32_t jpeg_confrn3_get_qt(struct JPEG_Type* p) { return (p->CONFRN3 & JPEG_CONFRN3_QT) >> 2 ; }

// JPEG->CONFRN4 JPEG codec configuration register 4-7
enum {
	JPEG_CONFRN4_HSF = ((1UL<<4)-1) << 12, // Horizontal Sampling Factor Horizontal sampling factor for component i.
	JPEG_CONFRN4_VSF = ((1UL<<4)-1) << 8, // Vertical Sampling Factor Vertical sampling factor for component i.
	JPEG_CONFRN4_NB = ((1UL<<4)-1) << 4, // Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
	JPEG_CONFRN4_QT = ((1UL<<2)-1) << 2, // Quantization Table Selects quantization table associated with a color component.
	JPEG_CONFRN4_HA = 1UL<<1, // Huffman AC Selects the Huffman table for encoding the AC coefficients.
	JPEG_CONFRN4_HD = 1UL<<0, // Huffman DC Selects the Huffman table for encoding the DC coefficients.		
};
inline void jpeg_confrn4_set_hsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN4 = (p->CONFRN4 & ~JPEG_CONFRN4_HSF) | ((val<<12) & JPEG_CONFRN4_HSF); }
inline void jpeg_confrn4_set_vsf(struct JPEG_Type* p, uint32_t val) { p->CONFRN4 = (p->CONFRN4 & ~JPEG_CONFRN4_VSF) | ((val<<8) & JPEG_CONFRN4_VSF); }
inline void jpeg_confrn4_set_nb(struct JPEG_Type* p, uint32_t val) { p->CONFRN4 = (p->CONFRN4 & ~JPEG_CONFRN4_NB) | ((val<<4) & JPEG_CONFRN4_NB); }
inline void jpeg_confrn4_set_qt(struct JPEG_Type* p, uint32_t val) { p->CONFRN4 = (p->CONFRN4 & ~JPEG_CONFRN4_QT) | ((val<<2) & JPEG_CONFRN4_QT); }
inline uint32_t jpeg_confrn4_get_hsf(struct JPEG_Type* p) { return (p->CONFRN4 & JPEG_CONFRN4_HSF) >> 12 ; }
inline uint32_t jpeg_confrn4_get_vsf(struct JPEG_Type* p) { return (p->CONFRN4 & JPEG_CONFRN4_VSF) >> 8 ; }
inline uint32_t jpeg_confrn4_get_nb(struct JPEG_Type* p) { return (p->CONFRN4 & JPEG_CONFRN4_NB) >> 4 ; }
inline uint32_t jpeg_confrn4_get_qt(struct JPEG_Type* p) { return (p->CONFRN4 & JPEG_CONFRN4_QT) >> 2 ; }

// JPEG->CR JPEG control register
enum {
	JPEG_CR_OFF = 1UL<<14, // Output FIFO Flush This bit flush the output FIFO. This bit is always read as 0.
	JPEG_CR_IFF = 1UL<<13, // Input FIFO Flush This bit flush the input FIFO. This bit is always read as 0.
	JPEG_CR_ODMAEN = 1UL<<12, // Output DMA Enable Enable the DMA request generation for the output FIFO.
	JPEG_CR_IDMAEN = 1UL<<11, // Input DMA Enable Enable the DMA request generation for the input FIFO.
	JPEG_CR_HPDIE = 1UL<<6, // Header Parsing Done Interrupt Enable This bit enables the interrupt generation on the Header Parsing Operation.
	JPEG_CR_EOCIE = 1UL<<5, // End of Conversion Interrupt Enable This bit enables the interrupt generation on the end of conversion.
	JPEG_CR_OFNEIE = 1UL<<4, // Output FIFO Not Empty Interrupt Enable This bit enables the interrupt generation when output FIFO is not empty.
	JPEG_CR_OFTIE = 1UL<<3, // Output FIFO Threshold Interrupt Enable This bit enables the interrupt generation when output FIFO reach the threshold.
	JPEG_CR_IFNFIE = 1UL<<2, // Input FIFO Not Full Interrupt Enable This bit enables the interrupt generation when input FIFO is not empty.
	JPEG_CR_IFTIE = 1UL<<1, // Input FIFO Threshold Interrupt Enable This bit enables the interrupt generation when input FIFO reach the threshold.
	JPEG_CR_JCEN = 1UL<<0, // JPEG Core Enable Enable the JPEG codec Core.		
};

// JPEG->SR JPEG status register
enum {
	JPEG_SR_COF = 1UL<<7, // Codec Operation Flag This bit is set when when a JPEG codec operation is on going (encoding or decoding).
	JPEG_SR_HPDF = 1UL<<6, // Header Parsing Done Flag This bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated.
	JPEG_SR_EOCF = 1UL<<5, // End of Conversion Flag This bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO.
	JPEG_SR_OFNEF = 1UL<<4, // Output FIFO Not Empty Flag This bit is set when the output FIFO is not empty (a data is available).
	JPEG_SR_OFTF = 1UL<<3, // Output FIFO Threshold Flag This bit is set when the output FIFO is not empty and has reach its threshold.
	JPEG_SR_IFNFF = 1UL<<2, // Input FIFO Not Full Flag This bit is set when the input FIFO is not full (a data can be written).
	JPEG_SR_IFTF = 1UL<<1, // Input FIFO Threshold Flag This bit is set when the input FIFO is not full and is bellow its threshold.		
};

// JPEG->CFR JPEG clear flag register
enum {
	JPEG_CFR_CHPDF = 1UL<<6, // Clear Header Parsing Done Flag Writing 1 clears the Header Parsing Done Flag of the JPEG Status Register.
	JPEG_CFR_CEOCF = 1UL<<5, // Clear End of Conversion Flag Writing 1 clears the End of Conversion Flag of the JPEG Status Register.		
};

/* Low power timer */
struct LPTIM1_Type {
	__I uint8_t ISR; // @0 Interrupt and Status Register
	 uint8_t RESERVED0[3]; // @1 
	__O uint8_t ICR; // @4 Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t IER; // @8 Interrupt Enable Register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint32_t CFGR; // @12 Configuration Register
	__IO uint8_t CR; // @16 Control Register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t CMP; // @20 Compare Register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t ARR; // @24 Autoreload Register
	 uint8_t RESERVED5[2]; // @26 
	__I uint16_t CNT; // @28 Counter Register
	 uint8_t RESERVED6[6]; // @30 
	__IO uint8_t CFGR2; // @36 LPTIM configuration register 2
};

// LPTIM1->ISR Interrupt and Status Register
enum {
	LPTIM1_ISR_DOWN = 1UL<<6, // Counter direction change up to down
	LPTIM1_ISR_UP = 1UL<<5, // Counter direction change down to up
	LPTIM1_ISR_ARROK = 1UL<<4, // Autoreload register update OK
	LPTIM1_ISR_CMPOK = 1UL<<3, // Compare register update OK
	LPTIM1_ISR_EXTTRIG = 1UL<<2, // External trigger edge event
	LPTIM1_ISR_ARRM = 1UL<<1, // Autoreload match
	LPTIM1_ISR_CMPM = 1UL<<0, // Compare match		
};

// LPTIM1->ICR Interrupt Clear Register
enum {
	LPTIM1_ICR_DOWNCF = 1UL<<6, // Direction change to down Clear Flag
	LPTIM1_ICR_UPCF = 1UL<<5, // Direction change to UP Clear Flag
	LPTIM1_ICR_ARROKCF = 1UL<<4, // Autoreload register update OK Clear Flag
	LPTIM1_ICR_CMPOKCF = 1UL<<3, // Compare register update OK Clear Flag
	LPTIM1_ICR_EXTTRIGCF = 1UL<<2, // External trigger valid edge Clear Flag
	LPTIM1_ICR_ARRMCF = 1UL<<1, // Autoreload match Clear Flag
	LPTIM1_ICR_CMPMCF = 1UL<<0, // compare match Clear Flag		
};

// LPTIM1->IER Interrupt Enable Register
enum {
	LPTIM1_IER_DOWNIE = 1UL<<6, // Direction change to down Interrupt Enable
	LPTIM1_IER_UPIE = 1UL<<5, // Direction change to UP Interrupt Enable
	LPTIM1_IER_ARROKIE = 1UL<<4, // Autoreload register update OK Interrupt Enable
	LPTIM1_IER_CMPOKIE = 1UL<<3, // Compare register update OK Interrupt Enable
	LPTIM1_IER_EXTTRIGIE = 1UL<<2, // External trigger valid edge Interrupt Enable
	LPTIM1_IER_ARRMIE = 1UL<<1, // Autoreload match Interrupt Enable
	LPTIM1_IER_CMPMIE = 1UL<<0, // Compare match Interrupt Enable		
};

// LPTIM1->CFGR Configuration Register
enum {
	LPTIM1_CFGR_ENC = 1UL<<24, // Encoder mode enable
	LPTIM1_CFGR_COUNTMODE = 1UL<<23, // counter mode enabled
	LPTIM1_CFGR_PRELOAD = 1UL<<22, // Registers update mode
	LPTIM1_CFGR_WAVPOL = 1UL<<21, // Waveform shape polarity
	LPTIM1_CFGR_WAVE = 1UL<<20, // Waveform shape
	LPTIM1_CFGR_TIMOUT = 1UL<<19, // Timeout enable
	LPTIM1_CFGR_TRIGEN = ((1UL<<2)-1) << 17, // Trigger enable and polarity
	LPTIM1_CFGR_TRIGSEL = ((1UL<<3)-1) << 13, // Trigger selector
	LPTIM1_CFGR_PRESC = ((1UL<<3)-1) << 9, // Clock prescaler
	LPTIM1_CFGR_TRGFLT = ((1UL<<2)-1) << 6, // Configurable digital filter for trigger
	LPTIM1_CFGR_CKFLT = ((1UL<<2)-1) << 3, // Configurable digital filter for external clock
	LPTIM1_CFGR_CKPOL = ((1UL<<2)-1) << 1, // Clock Polarity
	LPTIM1_CFGR_CKSEL = 1UL<<0, // Clock selector		
};
inline void lptim1_cfgr_set_trigen(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGEN) | ((val<<17) & LPTIM1_CFGR_TRIGEN); }
inline void lptim1_cfgr_set_trigsel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGSEL) | ((val<<13) & LPTIM1_CFGR_TRIGSEL); }
inline void lptim1_cfgr_set_presc(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_PRESC) | ((val<<9) & LPTIM1_CFGR_PRESC); }
inline void lptim1_cfgr_set_trgflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRGFLT) | ((val<<6) & LPTIM1_CFGR_TRGFLT); }
inline void lptim1_cfgr_set_ckflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKFLT) | ((val<<3) & LPTIM1_CFGR_CKFLT); }
inline void lptim1_cfgr_set_ckpol(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKPOL) | ((val<<1) & LPTIM1_CFGR_CKPOL); }
inline uint32_t lptim1_cfgr_get_trigen(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGEN) >> 17 ; }
inline uint32_t lptim1_cfgr_get_trigsel(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGSEL) >> 13 ; }
inline uint32_t lptim1_cfgr_get_presc(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_PRESC) >> 9 ; }
inline uint32_t lptim1_cfgr_get_trgflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRGFLT) >> 6 ; }
inline uint32_t lptim1_cfgr_get_ckflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKFLT) >> 3 ; }
inline uint32_t lptim1_cfgr_get_ckpol(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKPOL) >> 1 ; }

// LPTIM1->CR Control Register
enum {
	LPTIM1_CR_RSTARE = 1UL<<4, // Reset after read enable
	LPTIM1_CR_COUNTRST = 1UL<<3, // Counter reset
	LPTIM1_CR_CNTSTRT = 1UL<<2, // Timer start in continuous mode
	LPTIM1_CR_SNGSTRT = 1UL<<1, // LPTIM start in single mode
	LPTIM1_CR_ENABLE = 1UL<<0, // LPTIM Enable		
};

// LPTIM1->CFGR2 LPTIM configuration register 2
enum {
	LPTIM1_CFGR2_IN2SEL = ((1UL<<2)-1) << 4, // LPTIM Input 2 selection
	LPTIM1_CFGR2_IN1SEL = ((1UL<<2)-1) << 0, // LPTIM Input 1 selection		
};
inline void lptim1_cfgr2_set_in2sel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~LPTIM1_CFGR2_IN2SEL) | ((val<<4) & LPTIM1_CFGR2_IN2SEL); }
inline void lptim1_cfgr2_set_in1sel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~LPTIM1_CFGR2_IN1SEL) | ((val<<0) & LPTIM1_CFGR2_IN1SEL); }
inline uint32_t lptim1_cfgr2_get_in2sel(struct LPTIM1_Type* p) { return (p->CFGR2 & LPTIM1_CFGR2_IN2SEL) >> 4 ; }
inline uint32_t lptim1_cfgr2_get_in1sel(struct LPTIM1_Type* p) { return (p->CFGR2 & LPTIM1_CFGR2_IN1SEL) >> 0 ; }

// Valid Casts:
 
inline struct LPTIM3_Type* LPTIM1_as_LPTIM3_Type(struct LPTIM1_Type* p) { return (struct LPTIM3_Type*)p; }



/* Low power timer */
struct LPTIM3_Type {
	__I uint8_t ISR; // @0 Interrupt and Status Register
	 uint8_t RESERVED0[3]; // @1 
	__O uint8_t ICR; // @4 Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t IER; // @8 Interrupt Enable Register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint32_t CFGR; // @12 Configuration Register
	__IO uint8_t CR; // @16 Control Register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t CMP; // @20 Compare Register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t ARR; // @24 Autoreload Register
	 uint8_t RESERVED5[2]; // @26 
	__I uint16_t CNT; // @28 Counter Register
	 uint8_t RESERVED6[6]; // @30 
	__IO uint8_t CFGR2; // @36 LPTIM configuration register 2
};

// LPTIM3->ISR Interrupt and Status Register
enum {
	LPTIM3_ISR_DOWN = 1UL<<6, // Counter direction change up to down
	LPTIM3_ISR_UP = 1UL<<5, // Counter direction change down to up
	LPTIM3_ISR_ARROK = 1UL<<4, // Autoreload register update OK
	LPTIM3_ISR_CMPOK = 1UL<<3, // Compare register update OK
	LPTIM3_ISR_EXTTRIG = 1UL<<2, // External trigger edge event
	LPTIM3_ISR_ARRM = 1UL<<1, // Autoreload match
	LPTIM3_ISR_CMPM = 1UL<<0, // Compare match		
};

// LPTIM3->ICR Interrupt Clear Register
enum {
	LPTIM3_ICR_DOWNCF = 1UL<<6, // Direction change to down Clear Flag
	LPTIM3_ICR_UPCF = 1UL<<5, // Direction change to UP Clear Flag
	LPTIM3_ICR_ARROKCF = 1UL<<4, // Autoreload register update OK Clear Flag
	LPTIM3_ICR_CMPOKCF = 1UL<<3, // Compare register update OK Clear Flag
	LPTIM3_ICR_EXTTRIGCF = 1UL<<2, // External trigger valid edge Clear Flag
	LPTIM3_ICR_ARRMCF = 1UL<<1, // Autoreload match Clear Flag
	LPTIM3_ICR_CMPMCF = 1UL<<0, // compare match Clear Flag		
};

// LPTIM3->IER Interrupt Enable Register
enum {
	LPTIM3_IER_DOWNIE = 1UL<<6, // Direction change to down Interrupt Enable
	LPTIM3_IER_UPIE = 1UL<<5, // Direction change to UP Interrupt Enable
	LPTIM3_IER_ARROKIE = 1UL<<4, // Autoreload register update OK Interrupt Enable
	LPTIM3_IER_CMPOKIE = 1UL<<3, // Compare register update OK Interrupt Enable
	LPTIM3_IER_EXTTRIGIE = 1UL<<2, // External trigger valid edge Interrupt Enable
	LPTIM3_IER_ARRMIE = 1UL<<1, // Autoreload match Interrupt Enable
	LPTIM3_IER_CMPMIE = 1UL<<0, // Compare match Interrupt Enable		
};

// LPTIM3->CFGR Configuration Register
enum {
	LPTIM3_CFGR_ENC = 1UL<<24, // Encoder mode enable
	LPTIM3_CFGR_COUNTMODE = 1UL<<23, // counter mode enabled
	LPTIM3_CFGR_PRELOAD = 1UL<<22, // Registers update mode
	LPTIM3_CFGR_WAVPOL = 1UL<<21, // Waveform shape polarity
	LPTIM3_CFGR_WAVE = 1UL<<20, // Waveform shape
	LPTIM3_CFGR_TIMOUT = 1UL<<19, // Timeout enable
	LPTIM3_CFGR_TRIGEN = ((1UL<<2)-1) << 17, // Trigger enable and polarity
	LPTIM3_CFGR_TRIGSEL = ((1UL<<3)-1) << 13, // Trigger selector
	LPTIM3_CFGR_PRESC = ((1UL<<3)-1) << 9, // Clock prescaler
	LPTIM3_CFGR_TRGFLT = ((1UL<<2)-1) << 6, // Configurable digital filter for trigger
	LPTIM3_CFGR_CKFLT = ((1UL<<2)-1) << 3, // Configurable digital filter for external clock
	LPTIM3_CFGR_CKPOL = ((1UL<<2)-1) << 1, // Clock Polarity
	LPTIM3_CFGR_CKSEL = 1UL<<0, // Clock selector		
};
inline void lptim3_cfgr_set_trigen(struct LPTIM3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM3_CFGR_TRIGEN) | ((val<<17) & LPTIM3_CFGR_TRIGEN); }
inline void lptim3_cfgr_set_trigsel(struct LPTIM3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM3_CFGR_TRIGSEL) | ((val<<13) & LPTIM3_CFGR_TRIGSEL); }
inline void lptim3_cfgr_set_presc(struct LPTIM3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM3_CFGR_PRESC) | ((val<<9) & LPTIM3_CFGR_PRESC); }
inline void lptim3_cfgr_set_trgflt(struct LPTIM3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM3_CFGR_TRGFLT) | ((val<<6) & LPTIM3_CFGR_TRGFLT); }
inline void lptim3_cfgr_set_ckflt(struct LPTIM3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM3_CFGR_CKFLT) | ((val<<3) & LPTIM3_CFGR_CKFLT); }
inline void lptim3_cfgr_set_ckpol(struct LPTIM3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM3_CFGR_CKPOL) | ((val<<1) & LPTIM3_CFGR_CKPOL); }
inline uint32_t lptim3_cfgr_get_trigen(struct LPTIM3_Type* p) { return (p->CFGR & LPTIM3_CFGR_TRIGEN) >> 17 ; }
inline uint32_t lptim3_cfgr_get_trigsel(struct LPTIM3_Type* p) { return (p->CFGR & LPTIM3_CFGR_TRIGSEL) >> 13 ; }
inline uint32_t lptim3_cfgr_get_presc(struct LPTIM3_Type* p) { return (p->CFGR & LPTIM3_CFGR_PRESC) >> 9 ; }
inline uint32_t lptim3_cfgr_get_trgflt(struct LPTIM3_Type* p) { return (p->CFGR & LPTIM3_CFGR_TRGFLT) >> 6 ; }
inline uint32_t lptim3_cfgr_get_ckflt(struct LPTIM3_Type* p) { return (p->CFGR & LPTIM3_CFGR_CKFLT) >> 3 ; }
inline uint32_t lptim3_cfgr_get_ckpol(struct LPTIM3_Type* p) { return (p->CFGR & LPTIM3_CFGR_CKPOL) >> 1 ; }

// LPTIM3->CR Control Register
enum {
	LPTIM3_CR_RSTARE = 1UL<<4, // Reset after read enable
	LPTIM3_CR_COUNTRST = 1UL<<3, // Counter reset
	LPTIM3_CR_CNTSTRT = 1UL<<2, // Timer start in continuous mode
	LPTIM3_CR_SNGSTRT = 1UL<<1, // LPTIM start in single mode
	LPTIM3_CR_ENABLE = 1UL<<0, // LPTIM Enable		
};

// LPTIM3->CFGR2 LPTIM configuration register 2
enum {
	LPTIM3_CFGR2_IN1SEL = ((1UL<<2)-1) << 0, // LPTIM Input 1 selection		
};
inline void lptim3_cfgr2_set_in1sel(struct LPTIM3_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~LPTIM3_CFGR2_IN1SEL) | ((val<<0) & LPTIM3_CFGR2_IN1SEL); }
inline uint32_t lptim3_cfgr2_get_in1sel(struct LPTIM3_Type* p) { return (p->CFGR2 & LPTIM3_CFGR2_IN1SEL) >> 0 ; }



/* LPUART1 */
struct LPUART1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint32_t BRR; // @12 Baud rate register
	__IO uint16_t GTPR; // @16 Guard time and prescaler register
	 uint8_t RESERVED0[2]; // @18 
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED1[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED2[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
	 uint8_t RESERVED3[2]; // @42 
	__IO uint8_t PRESC; // @44 Prescaler register
};

// LPUART1->CR1 Control register 1
enum {
	LPUART1_CR1_RXFFIE = 1UL<<31, // RXFIFO Full interrupt enable
	LPUART1_CR1_TXFEIE = 1UL<<30, // TXFIFO empty interrupt enable
	LPUART1_CR1_FIFOEN = 1UL<<29, // FIFO mode enable
	LPUART1_CR1_M1 = 1UL<<28, // Word length
	LPUART1_CR1_DEAT = ((1UL<<5)-1) << 21, // Driver Enable assertion time
	LPUART1_CR1_DEDT = ((1UL<<5)-1) << 16, // Driver Enable deassertion time
	LPUART1_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	LPUART1_CR1_MME = 1UL<<13, // Mute mode enable
	LPUART1_CR1_M0 = 1UL<<12, // Word length
	LPUART1_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	LPUART1_CR1_PCE = 1UL<<10, // Parity control enable
	LPUART1_CR1_PS = 1UL<<9, // Parity selection
	LPUART1_CR1_PEIE = 1UL<<8, // PE interrupt enable
	LPUART1_CR1_TXEIE = 1UL<<7, // interrupt enable
	LPUART1_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	LPUART1_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	LPUART1_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	LPUART1_CR1_TE = 1UL<<3, // Transmitter enable
	LPUART1_CR1_RE = 1UL<<2, // Receiver enable
	LPUART1_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	LPUART1_CR1_UE = 1UL<<0, // USART enable		
};
inline void lpuart1_cr1_set_deat(struct LPUART1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~LPUART1_CR1_DEAT) | ((val<<21) & LPUART1_CR1_DEAT); }
inline void lpuart1_cr1_set_dedt(struct LPUART1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~LPUART1_CR1_DEDT) | ((val<<16) & LPUART1_CR1_DEDT); }
inline uint32_t lpuart1_cr1_get_deat(struct LPUART1_Type* p) { return (p->CR1 & LPUART1_CR1_DEAT) >> 21 ; }
inline uint32_t lpuart1_cr1_get_dedt(struct LPUART1_Type* p) { return (p->CR1 & LPUART1_CR1_DEDT) >> 16 ; }

// LPUART1->CR2 Control register 2
enum {
	LPUART1_CR2_ADD = ((1UL<<8)-1) << 24, // Address of the USART node
	LPUART1_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	LPUART1_CR2_DATAINV = 1UL<<18, // Binary data inversion
	LPUART1_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	LPUART1_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	LPUART1_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	LPUART1_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	LPUART1_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
inline void lpuart1_cr2_set_add(struct LPUART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD) | ((val<<24) & LPUART1_CR2_ADD); }
inline void lpuart1_cr2_set_stop(struct LPUART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART1_CR2_STOP) | ((val<<12) & LPUART1_CR2_STOP); }
inline uint32_t lpuart1_cr2_get_add(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_ADD) >> 24 ; }
inline uint32_t lpuart1_cr2_get_stop(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_STOP) >> 12 ; }

// LPUART1->CR3 Control register 3
enum {
	LPUART1_CR3_TXFTCFG = ((1UL<<3)-1) << 29, // TXFIFO threshold configuration
	LPUART1_CR3_RXFTIE = 1UL<<28, // RXFIFO threshold interrupt enable
	LPUART1_CR3_RXFTCFG = ((1UL<<3)-1) << 25, // Receive FIFO threshold configuration
	LPUART1_CR3_TXFTIE = 1UL<<23, // TXFIFO threshold interrupt enable
	LPUART1_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	LPUART1_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	LPUART1_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	LPUART1_CR3_DEM = 1UL<<14, // Driver enable mode
	LPUART1_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	LPUART1_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	LPUART1_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	LPUART1_CR3_CTSE = 1UL<<9, // CTS enable
	LPUART1_CR3_RTSE = 1UL<<8, // RTS enable
	LPUART1_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	LPUART1_CR3_DMAR = 1UL<<6, // DMA enable receiver
	LPUART1_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	LPUART1_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void lpuart1_cr3_set_txftcfg(struct LPUART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART1_CR3_TXFTCFG) | ((val<<29) & LPUART1_CR3_TXFTCFG); }
inline void lpuart1_cr3_set_rxftcfg(struct LPUART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART1_CR3_RXFTCFG) | ((val<<25) & LPUART1_CR3_RXFTCFG); }
inline void lpuart1_cr3_set_wus(struct LPUART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART1_CR3_WUS) | ((val<<20) & LPUART1_CR3_WUS); }
inline uint32_t lpuart1_cr3_get_txftcfg(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_TXFTCFG) >> 29 ; }
inline uint32_t lpuart1_cr3_get_rxftcfg(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_RXFTCFG) >> 25 ; }
inline uint32_t lpuart1_cr3_get_wus(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_WUS) >> 20 ; }

// LPUART1->BRR Baud rate register
enum {
	LPUART1_BRR_BRR = ((1UL<<20)-1) << 0, // BRR		
};
inline void lpuart1_brr_set_brr(struct LPUART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~LPUART1_BRR_BRR) | ((val<<0) & LPUART1_BRR_BRR); }
inline uint32_t lpuart1_brr_get_brr(struct LPUART1_Type* p) { return (p->BRR & LPUART1_BRR_BRR) >> 0 ; }

// LPUART1->GTPR Guard time and prescaler register
enum {
	LPUART1_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	LPUART1_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
inline void lpuart1_gtpr_set_gt(struct LPUART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~LPUART1_GTPR_GT) | ((val<<8) & LPUART1_GTPR_GT); }
inline void lpuart1_gtpr_set_psc(struct LPUART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~LPUART1_GTPR_PSC) | ((val<<0) & LPUART1_GTPR_PSC); }
inline uint32_t lpuart1_gtpr_get_gt(struct LPUART1_Type* p) { return (p->GTPR & LPUART1_GTPR_GT) >> 8 ; }
inline uint32_t lpuart1_gtpr_get_psc(struct LPUART1_Type* p) { return (p->GTPR & LPUART1_GTPR_PSC) >> 0 ; }

// LPUART1->RTOR Receiver timeout register
enum {
	LPUART1_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	LPUART1_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
inline void lpuart1_rtor_set_blen(struct LPUART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~LPUART1_RTOR_BLEN) | ((val<<24) & LPUART1_RTOR_BLEN); }
inline void lpuart1_rtor_set_rto(struct LPUART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~LPUART1_RTOR_RTO) | ((val<<0) & LPUART1_RTOR_RTO); }
inline uint32_t lpuart1_rtor_get_blen(struct LPUART1_Type* p) { return (p->RTOR & LPUART1_RTOR_BLEN) >> 24 ; }
inline uint32_t lpuart1_rtor_get_rto(struct LPUART1_Type* p) { return (p->RTOR & LPUART1_RTOR_RTO) >> 0 ; }

// LPUART1->RQR Request register
enum {
	LPUART1_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	LPUART1_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	LPUART1_RQR_MMRQ = 1UL<<2, // Mute mode request
	LPUART1_RQR_SBKRQ = 1UL<<1, // Send break request
	LPUART1_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// LPUART1->ISR Interrupt & status register
enum {
	LPUART1_ISR_TXFT = 1UL<<27, // TXFIFO threshold flag
	LPUART1_ISR_RXFT = 1UL<<26, // RXFIFO threshold flag
	LPUART1_ISR_RXFF = 1UL<<24, // RXFIFO Full
	LPUART1_ISR_TXFE = 1UL<<23, // TXFIFO Empty
	LPUART1_ISR_REACK = 1UL<<22, // REACK
	LPUART1_ISR_TEACK = 1UL<<21, // TEACK
	LPUART1_ISR_WUF = 1UL<<20, // WUF
	LPUART1_ISR_RWU = 1UL<<19, // RWU
	LPUART1_ISR_SBKF = 1UL<<18, // SBKF
	LPUART1_ISR_CMF = 1UL<<17, // CMF
	LPUART1_ISR_BUSY = 1UL<<16, // BUSY
	LPUART1_ISR_CTS = 1UL<<10, // CTS
	LPUART1_ISR_CTSIF = 1UL<<9, // CTSIF
	LPUART1_ISR_TXE = 1UL<<7, // TXE
	LPUART1_ISR_TC = 1UL<<6, // TC
	LPUART1_ISR_RXNE = 1UL<<5, // RXNE
	LPUART1_ISR_IDLE = 1UL<<4, // IDLE
	LPUART1_ISR_ORE = 1UL<<3, // ORE
	LPUART1_ISR_NE = 1UL<<2, // NE
	LPUART1_ISR_FE = 1UL<<1, // FE
	LPUART1_ISR_PE = 1UL<<0, // PE		
};

// LPUART1->ICR Interrupt flag clear register
enum {
	LPUART1_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	LPUART1_ICR_CMCF = 1UL<<17, // Character match clear flag
	LPUART1_ICR_CTSCF = 1UL<<9, // CTS clear flag
	LPUART1_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	LPUART1_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	LPUART1_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	LPUART1_ICR_NCF = 1UL<<2, // Noise detected clear flag
	LPUART1_ICR_FECF = 1UL<<1, // Framing error clear flag
	LPUART1_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// LPUART1->RDR Receive data register
enum {
	LPUART1_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t lpuart1_rdr_get_rdr(struct LPUART1_Type* p) { return (p->RDR & LPUART1_RDR_RDR) >> 0 ; }

// LPUART1->TDR Transmit data register
enum {
	LPUART1_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void lpuart1_tdr_set_tdr(struct LPUART1_Type* p, uint32_t val) { p->TDR = (p->TDR & ~LPUART1_TDR_TDR) | ((val<<0) & LPUART1_TDR_TDR); }
inline uint32_t lpuart1_tdr_get_tdr(struct LPUART1_Type* p) { return (p->TDR & LPUART1_TDR_TDR) >> 0 ; }

// LPUART1->PRESC Prescaler register
enum {
	LPUART1_PRESC_PRESCALER = ((1UL<<4)-1) << 0, // Clock prescaler		
};
inline void lpuart1_presc_set_prescaler(struct LPUART1_Type* p, uint32_t val) { p->PRESC = (p->PRESC & ~LPUART1_PRESC_PRESCALER) | ((val<<0) & LPUART1_PRESC_PRESCALER); }
inline uint32_t lpuart1_presc_get_prescaler(struct LPUART1_Type* p) { return (p->PRESC & LPUART1_PRESC_PRESCALER) >> 0 ; }

/* LCD-TFT Controller */
struct LTDC_Type {
	 uint8_t RESERVED0[8]; // @0 
	__IO uint32_t SSCR; // @8 Synchronization Size Configuration Register
	__IO uint32_t BPCR; // @12 Back Porch Configuration Register
	__IO uint32_t AWCR; // @16 Active Width Configuration Register
	__IO uint32_t TWCR; // @20 Total Width Configuration Register
	__IO uint32_t GCR; // @24 Global Control Register
	 uint8_t RESERVED1[8]; // @28 
	__IO uint8_t SRCR; // @36 Shadow Reload Configuration Register
	 uint8_t RESERVED2[7]; // @37 
	__IO uint32_t BCCR; // @44 Background Color Configuration Register
	 uint8_t RESERVED3[4]; // @48 
	__IO uint8_t IER; // @52 Interrupt Enable Register
	 uint8_t RESERVED4[3]; // @53 
	__I uint8_t ISR; // @56 Interrupt Status Register
	 uint8_t RESERVED5[3]; // @57 
	__O uint8_t ICR; // @60 Interrupt Clear Register
	 uint8_t RESERVED6[3]; // @61 
	__IO uint16_t LIPCR; // @64 Line Interrupt Position Configuration Register
	 uint8_t RESERVED7[2]; // @66 
	__I uint32_t CPSR; // @68 Current Position Status Register
	__I uint8_t CDSR; // @72 Current Display Status Register
	 uint8_t RESERVED8[59]; // @73 
	__IO uint8_t L1CR; // @132 Layerx Control Register
	 uint8_t RESERVED9[3]; // @133 
	__IO uint32_t L1WHPCR; // @136 Layerx Window Horizontal Position Configuration Register
	__IO uint32_t L1WVPCR; // @140 Layerx Window Vertical Position Configuration Register
	__IO uint32_t L1CKCR; // @144 Layerx Color Keying Configuration Register
	__IO uint8_t L1PFCR; // @148 Layerx Pixel Format Configuration Register
	 uint8_t RESERVED10[3]; // @149 
	__IO uint8_t L1CACR; // @152 Layerx Constant Alpha Configuration Register
	 uint8_t RESERVED11[3]; // @153 
	__IO uint32_t L1DCCR; // @156 Layerx Default Color Configuration Register
	__IO uint16_t L1BFCR; // @160 Layerx Blending Factors Configuration Register
	 uint8_t RESERVED12[10]; // @162 
	__IO uint32_t L1CFBAR; // @172 Layerx Color Frame Buffer Address Register
	__IO uint32_t L1CFBLR; // @176 Layerx Color Frame Buffer Length Register
	__IO uint16_t L1CFBLNR; // @180 Layerx ColorFrame Buffer Line Number Register
	 uint8_t RESERVED13[14]; // @182 
	__O uint32_t L1CLUTWR; // @196 Layerx CLUT Write Register
	 uint8_t RESERVED14[60]; // @200 
	__IO uint8_t L2CR; // @260 Layerx Control Register
	 uint8_t RESERVED15[3]; // @261 
	__IO uint32_t L2WHPCR; // @264 Layerx Window Horizontal Position Configuration Register
	__IO uint32_t L2WVPCR; // @268 Layerx Window Vertical Position Configuration Register
	__IO uint32_t L2CKCR; // @272 Layerx Color Keying Configuration Register
	__IO uint8_t L2PFCR; // @276 Layerx Pixel Format Configuration Register
	 uint8_t RESERVED16[3]; // @277 
	__IO uint8_t L2CACR; // @280 Layerx Constant Alpha Configuration Register
	 uint8_t RESERVED17[3]; // @281 
	__IO uint32_t L2DCCR; // @284 Layerx Default Color Configuration Register
	__IO uint16_t L2BFCR; // @288 Layerx Blending Factors Configuration Register
	 uint8_t RESERVED18[10]; // @290 
	__IO uint32_t L2CFBAR; // @300 Layerx Color Frame Buffer Address Register
	__IO uint32_t L2CFBLR; // @304 Layerx Color Frame Buffer Length Register
	__IO uint16_t L2CFBLNR; // @308 Layerx ColorFrame Buffer Line Number Register
	 uint8_t RESERVED19[14]; // @310 
	__O uint32_t L2CLUTWR; // @324 Layerx CLUT Write Register
};

// LTDC->SSCR Synchronization Size Configuration Register
enum {
	LTDC_SSCR_HSW = ((1UL<<10)-1) << 16, // Horizontal Synchronization Width (in units of pixel clock period)
	LTDC_SSCR_VSH = ((1UL<<11)-1) << 0, // Vertical Synchronization Height (in units of horizontal scan line)		
};
inline void ltdc_sscr_set_hsw(struct LTDC_Type* p, uint32_t val) { p->SSCR = (p->SSCR & ~LTDC_SSCR_HSW) | ((val<<16) & LTDC_SSCR_HSW); }
inline void ltdc_sscr_set_vsh(struct LTDC_Type* p, uint32_t val) { p->SSCR = (p->SSCR & ~LTDC_SSCR_VSH) | ((val<<0) & LTDC_SSCR_VSH); }
inline uint32_t ltdc_sscr_get_hsw(struct LTDC_Type* p) { return (p->SSCR & LTDC_SSCR_HSW) >> 16 ; }
inline uint32_t ltdc_sscr_get_vsh(struct LTDC_Type* p) { return (p->SSCR & LTDC_SSCR_VSH) >> 0 ; }

// LTDC->BPCR Back Porch Configuration Register
enum {
	LTDC_BPCR_AHBP = ((1UL<<12)-1) << 16, // Accumulated Horizontal back porch (in units of pixel clock period)
	LTDC_BPCR_AVBP = ((1UL<<11)-1) << 0, // Accumulated Vertical back porch (in units of horizontal scan line)		
};
inline void ltdc_bpcr_set_ahbp(struct LTDC_Type* p, uint32_t val) { p->BPCR = (p->BPCR & ~LTDC_BPCR_AHBP) | ((val<<16) & LTDC_BPCR_AHBP); }
inline void ltdc_bpcr_set_avbp(struct LTDC_Type* p, uint32_t val) { p->BPCR = (p->BPCR & ~LTDC_BPCR_AVBP) | ((val<<0) & LTDC_BPCR_AVBP); }
inline uint32_t ltdc_bpcr_get_ahbp(struct LTDC_Type* p) { return (p->BPCR & LTDC_BPCR_AHBP) >> 16 ; }
inline uint32_t ltdc_bpcr_get_avbp(struct LTDC_Type* p) { return (p->BPCR & LTDC_BPCR_AVBP) >> 0 ; }

// LTDC->AWCR Active Width Configuration Register
enum {
	LTDC_AWCR_AAV = ((1UL<<12)-1) << 16, // AAV
	LTDC_AWCR_AAH = ((1UL<<11)-1) << 0, // Accumulated Active Height (in units of horizontal scan line)		
};
inline void ltdc_awcr_set_aav(struct LTDC_Type* p, uint32_t val) { p->AWCR = (p->AWCR & ~LTDC_AWCR_AAV) | ((val<<16) & LTDC_AWCR_AAV); }
inline void ltdc_awcr_set_aah(struct LTDC_Type* p, uint32_t val) { p->AWCR = (p->AWCR & ~LTDC_AWCR_AAH) | ((val<<0) & LTDC_AWCR_AAH); }
inline uint32_t ltdc_awcr_get_aav(struct LTDC_Type* p) { return (p->AWCR & LTDC_AWCR_AAV) >> 16 ; }
inline uint32_t ltdc_awcr_get_aah(struct LTDC_Type* p) { return (p->AWCR & LTDC_AWCR_AAH) >> 0 ; }

// LTDC->TWCR Total Width Configuration Register
enum {
	LTDC_TWCR_TOTALW = ((1UL<<12)-1) << 16, // Total Width (in units of pixel clock period)
	LTDC_TWCR_TOTALH = ((1UL<<11)-1) << 0, // Total Height (in units of horizontal scan line)		
};
inline void ltdc_twcr_set_totalw(struct LTDC_Type* p, uint32_t val) { p->TWCR = (p->TWCR & ~LTDC_TWCR_TOTALW) | ((val<<16) & LTDC_TWCR_TOTALW); }
inline void ltdc_twcr_set_totalh(struct LTDC_Type* p, uint32_t val) { p->TWCR = (p->TWCR & ~LTDC_TWCR_TOTALH) | ((val<<0) & LTDC_TWCR_TOTALH); }
inline uint32_t ltdc_twcr_get_totalw(struct LTDC_Type* p) { return (p->TWCR & LTDC_TWCR_TOTALW) >> 16 ; }
inline uint32_t ltdc_twcr_get_totalh(struct LTDC_Type* p) { return (p->TWCR & LTDC_TWCR_TOTALH) >> 0 ; }

// LTDC->GCR Global Control Register
enum {
	LTDC_GCR_HSPOL = 1UL<<31, // Horizontal Synchronization Polarity
	LTDC_GCR_VSPOL = 1UL<<30, // Vertical Synchronization Polarity
	LTDC_GCR_DEPOL = 1UL<<29, // Data Enable Polarity
	LTDC_GCR_PCPOL = 1UL<<28, // Pixel Clock Polarity
	LTDC_GCR_DEN = 1UL<<16, // Dither Enable
	LTDC_GCR_DRW = ((1UL<<3)-1) << 12, // Dither Red Width
	LTDC_GCR_DGW = ((1UL<<3)-1) << 8, // Dither Green Width
	LTDC_GCR_DBW = ((1UL<<3)-1) << 4, // Dither Blue Width
	LTDC_GCR_LTDCEN = 1UL<<0, // LCD-TFT controller enable bit		
};
inline void ltdc_gcr_set_drw(struct LTDC_Type* p, uint32_t val) { p->GCR = (p->GCR & ~LTDC_GCR_DRW) | ((val<<12) & LTDC_GCR_DRW); }
inline void ltdc_gcr_set_dgw(struct LTDC_Type* p, uint32_t val) { p->GCR = (p->GCR & ~LTDC_GCR_DGW) | ((val<<8) & LTDC_GCR_DGW); }
inline void ltdc_gcr_set_dbw(struct LTDC_Type* p, uint32_t val) { p->GCR = (p->GCR & ~LTDC_GCR_DBW) | ((val<<4) & LTDC_GCR_DBW); }
inline uint32_t ltdc_gcr_get_drw(struct LTDC_Type* p) { return (p->GCR & LTDC_GCR_DRW) >> 12 ; }
inline uint32_t ltdc_gcr_get_dgw(struct LTDC_Type* p) { return (p->GCR & LTDC_GCR_DGW) >> 8 ; }
inline uint32_t ltdc_gcr_get_dbw(struct LTDC_Type* p) { return (p->GCR & LTDC_GCR_DBW) >> 4 ; }

// LTDC->SRCR Shadow Reload Configuration Register
enum {
	LTDC_SRCR_VBR = 1UL<<1, // Vertical Blanking Reload
	LTDC_SRCR_IMR = 1UL<<0, // Immediate Reload		
};

// LTDC->BCCR Background Color Configuration Register
enum {
	LTDC_BCCR_BCRED = ((1UL<<8)-1) << 16, // Background Color Red value
	LTDC_BCCR_BCGREEN = ((1UL<<8)-1) << 8, // Background Color Green value
	LTDC_BCCR_BCBLUE = ((1UL<<8)-1) << 0, // Background Color Blue value		
};
inline void ltdc_bccr_set_bcred(struct LTDC_Type* p, uint32_t val) { p->BCCR = (p->BCCR & ~LTDC_BCCR_BCRED) | ((val<<16) & LTDC_BCCR_BCRED); }
inline void ltdc_bccr_set_bcgreen(struct LTDC_Type* p, uint32_t val) { p->BCCR = (p->BCCR & ~LTDC_BCCR_BCGREEN) | ((val<<8) & LTDC_BCCR_BCGREEN); }
inline void ltdc_bccr_set_bcblue(struct LTDC_Type* p, uint32_t val) { p->BCCR = (p->BCCR & ~LTDC_BCCR_BCBLUE) | ((val<<0) & LTDC_BCCR_BCBLUE); }
inline uint32_t ltdc_bccr_get_bcred(struct LTDC_Type* p) { return (p->BCCR & LTDC_BCCR_BCRED) >> 16 ; }
inline uint32_t ltdc_bccr_get_bcgreen(struct LTDC_Type* p) { return (p->BCCR & LTDC_BCCR_BCGREEN) >> 8 ; }
inline uint32_t ltdc_bccr_get_bcblue(struct LTDC_Type* p) { return (p->BCCR & LTDC_BCCR_BCBLUE) >> 0 ; }

// LTDC->IER Interrupt Enable Register
enum {
	LTDC_IER_RRIE = 1UL<<3, // Register Reload interrupt enable
	LTDC_IER_TERRIE = 1UL<<2, // Transfer Error Interrupt Enable
	LTDC_IER_FUIE = 1UL<<1, // FIFO Underrun Interrupt Enable
	LTDC_IER_LIE = 1UL<<0, // Line Interrupt Enable		
};

// LTDC->ISR Interrupt Status Register
enum {
	LTDC_ISR_RRIF = 1UL<<3, // Register Reload Interrupt Flag
	LTDC_ISR_TERRIF = 1UL<<2, // Transfer Error interrupt flag
	LTDC_ISR_FUIF = 1UL<<1, // FIFO Underrun Interrupt flag
	LTDC_ISR_LIF = 1UL<<0, // Line Interrupt flag		
};

// LTDC->ICR Interrupt Clear Register
enum {
	LTDC_ICR_CRRIF = 1UL<<3, // Clears Register Reload Interrupt Flag
	LTDC_ICR_CTERRIF = 1UL<<2, // Clears the Transfer Error Interrupt Flag
	LTDC_ICR_CFUIF = 1UL<<1, // Clears the FIFO Underrun Interrupt flag
	LTDC_ICR_CLIF = 1UL<<0, // Clears the Line Interrupt Flag		
};

// LTDC->LIPCR Line Interrupt Position Configuration Register
enum {
	LTDC_LIPCR_LIPOS = ((1UL<<11)-1) << 0, // Line Interrupt Position		
};
inline void ltdc_lipcr_set_lipos(struct LTDC_Type* p, uint32_t val) { p->LIPCR = (p->LIPCR & ~LTDC_LIPCR_LIPOS) | ((val<<0) & LTDC_LIPCR_LIPOS); }
inline uint32_t ltdc_lipcr_get_lipos(struct LTDC_Type* p) { return (p->LIPCR & LTDC_LIPCR_LIPOS) >> 0 ; }

// LTDC->CPSR Current Position Status Register
enum {
	LTDC_CPSR_CXPOS = ((1UL<<16)-1) << 16, // Current X Position
	LTDC_CPSR_CYPOS = ((1UL<<16)-1) << 0, // Current Y Position		
};
inline uint32_t ltdc_cpsr_get_cxpos(struct LTDC_Type* p) { return (p->CPSR & LTDC_CPSR_CXPOS) >> 16 ; }
inline uint32_t ltdc_cpsr_get_cypos(struct LTDC_Type* p) { return (p->CPSR & LTDC_CPSR_CYPOS) >> 0 ; }

// LTDC->CDSR Current Display Status Register
enum {
	LTDC_CDSR_HSYNCS = 1UL<<3, // Horizontal Synchronization display Status
	LTDC_CDSR_VSYNCS = 1UL<<2, // Vertical Synchronization display Status
	LTDC_CDSR_HDES = 1UL<<1, // Horizontal Data Enable display Status
	LTDC_CDSR_VDES = 1UL<<0, // Vertical Data Enable display Status		
};

// LTDC->L1CR Layerx Control Register
enum {
	LTDC_L1CR_CLUTEN = 1UL<<4, // Color Look-Up Table Enable
	LTDC_L1CR_COLKEN = 1UL<<1, // Color Keying Enable
	LTDC_L1CR_LEN = 1UL<<0, // Layer Enable		
};

// LTDC->L1WHPCR Layerx Window Horizontal Position Configuration Register
enum {
	LTDC_L1WHPCR_WHSPPOS = ((1UL<<12)-1) << 16, // Window Horizontal Stop Position
	LTDC_L1WHPCR_WHSTPOS = ((1UL<<12)-1) << 0, // Window Horizontal Start Position		
};
inline void ltdc_l1whpcr_set_whsppos(struct LTDC_Type* p, uint32_t val) { p->L1WHPCR = (p->L1WHPCR & ~LTDC_L1WHPCR_WHSPPOS) | ((val<<16) & LTDC_L1WHPCR_WHSPPOS); }
inline void ltdc_l1whpcr_set_whstpos(struct LTDC_Type* p, uint32_t val) { p->L1WHPCR = (p->L1WHPCR & ~LTDC_L1WHPCR_WHSTPOS) | ((val<<0) & LTDC_L1WHPCR_WHSTPOS); }
inline uint32_t ltdc_l1whpcr_get_whsppos(struct LTDC_Type* p) { return (p->L1WHPCR & LTDC_L1WHPCR_WHSPPOS) >> 16 ; }
inline uint32_t ltdc_l1whpcr_get_whstpos(struct LTDC_Type* p) { return (p->L1WHPCR & LTDC_L1WHPCR_WHSTPOS) >> 0 ; }

// LTDC->L1WVPCR Layerx Window Vertical Position Configuration Register
enum {
	LTDC_L1WVPCR_WVSPPOS = ((1UL<<11)-1) << 16, // Window Vertical Stop Position
	LTDC_L1WVPCR_WVSTPOS = ((1UL<<11)-1) << 0, // Window Vertical Start Position		
};
inline void ltdc_l1wvpcr_set_wvsppos(struct LTDC_Type* p, uint32_t val) { p->L1WVPCR = (p->L1WVPCR & ~LTDC_L1WVPCR_WVSPPOS) | ((val<<16) & LTDC_L1WVPCR_WVSPPOS); }
inline void ltdc_l1wvpcr_set_wvstpos(struct LTDC_Type* p, uint32_t val) { p->L1WVPCR = (p->L1WVPCR & ~LTDC_L1WVPCR_WVSTPOS) | ((val<<0) & LTDC_L1WVPCR_WVSTPOS); }
inline uint32_t ltdc_l1wvpcr_get_wvsppos(struct LTDC_Type* p) { return (p->L1WVPCR & LTDC_L1WVPCR_WVSPPOS) >> 16 ; }
inline uint32_t ltdc_l1wvpcr_get_wvstpos(struct LTDC_Type* p) { return (p->L1WVPCR & LTDC_L1WVPCR_WVSTPOS) >> 0 ; }

// LTDC->L1CKCR Layerx Color Keying Configuration Register
enum {
	LTDC_L1CKCR_CKRED = ((1UL<<8)-1) << 16, // Color Key Red value
	LTDC_L1CKCR_CKGREEN = ((1UL<<8)-1) << 8, // Color Key Green value
	LTDC_L1CKCR_CKBLUE = ((1UL<<8)-1) << 0, // Color Key Blue value		
};
inline void ltdc_l1ckcr_set_ckred(struct LTDC_Type* p, uint32_t val) { p->L1CKCR = (p->L1CKCR & ~LTDC_L1CKCR_CKRED) | ((val<<16) & LTDC_L1CKCR_CKRED); }
inline void ltdc_l1ckcr_set_ckgreen(struct LTDC_Type* p, uint32_t val) { p->L1CKCR = (p->L1CKCR & ~LTDC_L1CKCR_CKGREEN) | ((val<<8) & LTDC_L1CKCR_CKGREEN); }
inline void ltdc_l1ckcr_set_ckblue(struct LTDC_Type* p, uint32_t val) { p->L1CKCR = (p->L1CKCR & ~LTDC_L1CKCR_CKBLUE) | ((val<<0) & LTDC_L1CKCR_CKBLUE); }
inline uint32_t ltdc_l1ckcr_get_ckred(struct LTDC_Type* p) { return (p->L1CKCR & LTDC_L1CKCR_CKRED) >> 16 ; }
inline uint32_t ltdc_l1ckcr_get_ckgreen(struct LTDC_Type* p) { return (p->L1CKCR & LTDC_L1CKCR_CKGREEN) >> 8 ; }
inline uint32_t ltdc_l1ckcr_get_ckblue(struct LTDC_Type* p) { return (p->L1CKCR & LTDC_L1CKCR_CKBLUE) >> 0 ; }

// LTDC->L1PFCR Layerx Pixel Format Configuration Register
enum {
	LTDC_L1PFCR_PF = ((1UL<<3)-1) << 0, // Pixel Format		
};
inline void ltdc_l1pfcr_set_pf(struct LTDC_Type* p, uint32_t val) { p->L1PFCR = (p->L1PFCR & ~LTDC_L1PFCR_PF) | ((val<<0) & LTDC_L1PFCR_PF); }
inline uint32_t ltdc_l1pfcr_get_pf(struct LTDC_Type* p) { return (p->L1PFCR & LTDC_L1PFCR_PF) >> 0 ; }

// LTDC->L1DCCR Layerx Default Color Configuration Register
enum {
	LTDC_L1DCCR_DCALPHA = ((1UL<<8)-1) << 24, // Default Color Alpha
	LTDC_L1DCCR_DCRED = ((1UL<<8)-1) << 16, // Default Color Red
	LTDC_L1DCCR_DCGREEN = ((1UL<<8)-1) << 8, // Default Color Green
	LTDC_L1DCCR_DCBLUE = ((1UL<<8)-1) << 0, // Default Color Blue		
};
inline void ltdc_l1dccr_set_dcalpha(struct LTDC_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTDC_L1DCCR_DCALPHA) | ((val<<24) & LTDC_L1DCCR_DCALPHA); }
inline void ltdc_l1dccr_set_dcred(struct LTDC_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTDC_L1DCCR_DCRED) | ((val<<16) & LTDC_L1DCCR_DCRED); }
inline void ltdc_l1dccr_set_dcgreen(struct LTDC_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTDC_L1DCCR_DCGREEN) | ((val<<8) & LTDC_L1DCCR_DCGREEN); }
inline void ltdc_l1dccr_set_dcblue(struct LTDC_Type* p, uint32_t val) { p->L1DCCR = (p->L1DCCR & ~LTDC_L1DCCR_DCBLUE) | ((val<<0) & LTDC_L1DCCR_DCBLUE); }
inline uint32_t ltdc_l1dccr_get_dcalpha(struct LTDC_Type* p) { return (p->L1DCCR & LTDC_L1DCCR_DCALPHA) >> 24 ; }
inline uint32_t ltdc_l1dccr_get_dcred(struct LTDC_Type* p) { return (p->L1DCCR & LTDC_L1DCCR_DCRED) >> 16 ; }
inline uint32_t ltdc_l1dccr_get_dcgreen(struct LTDC_Type* p) { return (p->L1DCCR & LTDC_L1DCCR_DCGREEN) >> 8 ; }
inline uint32_t ltdc_l1dccr_get_dcblue(struct LTDC_Type* p) { return (p->L1DCCR & LTDC_L1DCCR_DCBLUE) >> 0 ; }

// LTDC->L1BFCR Layerx Blending Factors Configuration Register
enum {
	LTDC_L1BFCR_BF1 = ((1UL<<3)-1) << 8, // Blending Factor 1
	LTDC_L1BFCR_BF2 = ((1UL<<3)-1) << 0, // Blending Factor 2		
};
inline void ltdc_l1bfcr_set_bf1(struct LTDC_Type* p, uint32_t val) { p->L1BFCR = (p->L1BFCR & ~LTDC_L1BFCR_BF1) | ((val<<8) & LTDC_L1BFCR_BF1); }
inline void ltdc_l1bfcr_set_bf2(struct LTDC_Type* p, uint32_t val) { p->L1BFCR = (p->L1BFCR & ~LTDC_L1BFCR_BF2) | ((val<<0) & LTDC_L1BFCR_BF2); }
inline uint32_t ltdc_l1bfcr_get_bf1(struct LTDC_Type* p) { return (p->L1BFCR & LTDC_L1BFCR_BF1) >> 8 ; }
inline uint32_t ltdc_l1bfcr_get_bf2(struct LTDC_Type* p) { return (p->L1BFCR & LTDC_L1BFCR_BF2) >> 0 ; }

// LTDC->L1CFBLR Layerx Color Frame Buffer Length Register
enum {
	LTDC_L1CFBLR_CFBP = ((1UL<<13)-1) << 16, // Color Frame Buffer Pitch in bytes
	LTDC_L1CFBLR_CFBLL = ((1UL<<13)-1) << 0, // Color Frame Buffer Line Length		
};
inline void ltdc_l1cfblr_set_cfbp(struct LTDC_Type* p, uint32_t val) { p->L1CFBLR = (p->L1CFBLR & ~LTDC_L1CFBLR_CFBP) | ((val<<16) & LTDC_L1CFBLR_CFBP); }
inline void ltdc_l1cfblr_set_cfbll(struct LTDC_Type* p, uint32_t val) { p->L1CFBLR = (p->L1CFBLR & ~LTDC_L1CFBLR_CFBLL) | ((val<<0) & LTDC_L1CFBLR_CFBLL); }
inline uint32_t ltdc_l1cfblr_get_cfbp(struct LTDC_Type* p) { return (p->L1CFBLR & LTDC_L1CFBLR_CFBP) >> 16 ; }
inline uint32_t ltdc_l1cfblr_get_cfbll(struct LTDC_Type* p) { return (p->L1CFBLR & LTDC_L1CFBLR_CFBLL) >> 0 ; }

// LTDC->L1CFBLNR Layerx ColorFrame Buffer Line Number Register
enum {
	LTDC_L1CFBLNR_CFBLNBR = ((1UL<<11)-1) << 0, // Frame Buffer Line Number		
};
inline void ltdc_l1cfblnr_set_cfblnbr(struct LTDC_Type* p, uint32_t val) { p->L1CFBLNR = (p->L1CFBLNR & ~LTDC_L1CFBLNR_CFBLNBR) | ((val<<0) & LTDC_L1CFBLNR_CFBLNBR); }
inline uint32_t ltdc_l1cfblnr_get_cfblnbr(struct LTDC_Type* p) { return (p->L1CFBLNR & LTDC_L1CFBLNR_CFBLNBR) >> 0 ; }

// LTDC->L1CLUTWR Layerx CLUT Write Register
enum {
	LTDC_L1CLUTWR_CLUTADD = ((1UL<<8)-1) << 24, // CLUT Address
	LTDC_L1CLUTWR_RED = ((1UL<<8)-1) << 16, // Red value
	LTDC_L1CLUTWR_GREEN = ((1UL<<8)-1) << 8, // Green value
	LTDC_L1CLUTWR_BLUE = ((1UL<<8)-1) << 0, // Blue value		
};
inline void ltdc_l1clutwr_set_clutadd(struct LTDC_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTDC_L1CLUTWR_CLUTADD) | ((val<<24) & LTDC_L1CLUTWR_CLUTADD); }
inline void ltdc_l1clutwr_set_red(struct LTDC_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTDC_L1CLUTWR_RED) | ((val<<16) & LTDC_L1CLUTWR_RED); }
inline void ltdc_l1clutwr_set_green(struct LTDC_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTDC_L1CLUTWR_GREEN) | ((val<<8) & LTDC_L1CLUTWR_GREEN); }
inline void ltdc_l1clutwr_set_blue(struct LTDC_Type* p, uint32_t val) { p->L1CLUTWR = (p->L1CLUTWR & ~LTDC_L1CLUTWR_BLUE) | ((val<<0) & LTDC_L1CLUTWR_BLUE); }
inline uint32_t ltdc_l1clutwr_get_clutadd(struct LTDC_Type* p) { return (p->L1CLUTWR & LTDC_L1CLUTWR_CLUTADD) >> 24 ; }
inline uint32_t ltdc_l1clutwr_get_red(struct LTDC_Type* p) { return (p->L1CLUTWR & LTDC_L1CLUTWR_RED) >> 16 ; }
inline uint32_t ltdc_l1clutwr_get_green(struct LTDC_Type* p) { return (p->L1CLUTWR & LTDC_L1CLUTWR_GREEN) >> 8 ; }
inline uint32_t ltdc_l1clutwr_get_blue(struct LTDC_Type* p) { return (p->L1CLUTWR & LTDC_L1CLUTWR_BLUE) >> 0 ; }

// LTDC->L2CR Layerx Control Register
enum {
	LTDC_L2CR_CLUTEN = 1UL<<4, // Color Look-Up Table Enable
	LTDC_L2CR_COLKEN = 1UL<<1, // Color Keying Enable
	LTDC_L2CR_LEN = 1UL<<0, // Layer Enable		
};

// LTDC->L2WHPCR Layerx Window Horizontal Position Configuration Register
enum {
	LTDC_L2WHPCR_WHSPPOS = ((1UL<<12)-1) << 16, // Window Horizontal Stop Position
	LTDC_L2WHPCR_WHSTPOS = ((1UL<<12)-1) << 0, // Window Horizontal Start Position		
};
inline void ltdc_l2whpcr_set_whsppos(struct LTDC_Type* p, uint32_t val) { p->L2WHPCR = (p->L2WHPCR & ~LTDC_L2WHPCR_WHSPPOS) | ((val<<16) & LTDC_L2WHPCR_WHSPPOS); }
inline void ltdc_l2whpcr_set_whstpos(struct LTDC_Type* p, uint32_t val) { p->L2WHPCR = (p->L2WHPCR & ~LTDC_L2WHPCR_WHSTPOS) | ((val<<0) & LTDC_L2WHPCR_WHSTPOS); }
inline uint32_t ltdc_l2whpcr_get_whsppos(struct LTDC_Type* p) { return (p->L2WHPCR & LTDC_L2WHPCR_WHSPPOS) >> 16 ; }
inline uint32_t ltdc_l2whpcr_get_whstpos(struct LTDC_Type* p) { return (p->L2WHPCR & LTDC_L2WHPCR_WHSTPOS) >> 0 ; }

// LTDC->L2WVPCR Layerx Window Vertical Position Configuration Register
enum {
	LTDC_L2WVPCR_WVSPPOS = ((1UL<<11)-1) << 16, // Window Vertical Stop Position
	LTDC_L2WVPCR_WVSTPOS = ((1UL<<11)-1) << 0, // Window Vertical Start Position		
};
inline void ltdc_l2wvpcr_set_wvsppos(struct LTDC_Type* p, uint32_t val) { p->L2WVPCR = (p->L2WVPCR & ~LTDC_L2WVPCR_WVSPPOS) | ((val<<16) & LTDC_L2WVPCR_WVSPPOS); }
inline void ltdc_l2wvpcr_set_wvstpos(struct LTDC_Type* p, uint32_t val) { p->L2WVPCR = (p->L2WVPCR & ~LTDC_L2WVPCR_WVSTPOS) | ((val<<0) & LTDC_L2WVPCR_WVSTPOS); }
inline uint32_t ltdc_l2wvpcr_get_wvsppos(struct LTDC_Type* p) { return (p->L2WVPCR & LTDC_L2WVPCR_WVSPPOS) >> 16 ; }
inline uint32_t ltdc_l2wvpcr_get_wvstpos(struct LTDC_Type* p) { return (p->L2WVPCR & LTDC_L2WVPCR_WVSTPOS) >> 0 ; }

// LTDC->L2CKCR Layerx Color Keying Configuration Register
enum {
	LTDC_L2CKCR_CKRED = ((1UL<<8)-1) << 16, // Color Key Red value
	LTDC_L2CKCR_CKGREEN = ((1UL<<8)-1) << 8, // Color Key Green value
	LTDC_L2CKCR_CKBLUE = ((1UL<<8)-1) << 0, // Color Key Blue value		
};
inline void ltdc_l2ckcr_set_ckred(struct LTDC_Type* p, uint32_t val) { p->L2CKCR = (p->L2CKCR & ~LTDC_L2CKCR_CKRED) | ((val<<16) & LTDC_L2CKCR_CKRED); }
inline void ltdc_l2ckcr_set_ckgreen(struct LTDC_Type* p, uint32_t val) { p->L2CKCR = (p->L2CKCR & ~LTDC_L2CKCR_CKGREEN) | ((val<<8) & LTDC_L2CKCR_CKGREEN); }
inline void ltdc_l2ckcr_set_ckblue(struct LTDC_Type* p, uint32_t val) { p->L2CKCR = (p->L2CKCR & ~LTDC_L2CKCR_CKBLUE) | ((val<<0) & LTDC_L2CKCR_CKBLUE); }
inline uint32_t ltdc_l2ckcr_get_ckred(struct LTDC_Type* p) { return (p->L2CKCR & LTDC_L2CKCR_CKRED) >> 16 ; }
inline uint32_t ltdc_l2ckcr_get_ckgreen(struct LTDC_Type* p) { return (p->L2CKCR & LTDC_L2CKCR_CKGREEN) >> 8 ; }
inline uint32_t ltdc_l2ckcr_get_ckblue(struct LTDC_Type* p) { return (p->L2CKCR & LTDC_L2CKCR_CKBLUE) >> 0 ; }

// LTDC->L2PFCR Layerx Pixel Format Configuration Register
enum {
	LTDC_L2PFCR_PF = ((1UL<<3)-1) << 0, // Pixel Format		
};
inline void ltdc_l2pfcr_set_pf(struct LTDC_Type* p, uint32_t val) { p->L2PFCR = (p->L2PFCR & ~LTDC_L2PFCR_PF) | ((val<<0) & LTDC_L2PFCR_PF); }
inline uint32_t ltdc_l2pfcr_get_pf(struct LTDC_Type* p) { return (p->L2PFCR & LTDC_L2PFCR_PF) >> 0 ; }

// LTDC->L2DCCR Layerx Default Color Configuration Register
enum {
	LTDC_L2DCCR_DCALPHA = ((1UL<<8)-1) << 24, // Default Color Alpha
	LTDC_L2DCCR_DCRED = ((1UL<<8)-1) << 16, // Default Color Red
	LTDC_L2DCCR_DCGREEN = ((1UL<<8)-1) << 8, // Default Color Green
	LTDC_L2DCCR_DCBLUE = ((1UL<<8)-1) << 0, // Default Color Blue		
};
inline void ltdc_l2dccr_set_dcalpha(struct LTDC_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTDC_L2DCCR_DCALPHA) | ((val<<24) & LTDC_L2DCCR_DCALPHA); }
inline void ltdc_l2dccr_set_dcred(struct LTDC_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTDC_L2DCCR_DCRED) | ((val<<16) & LTDC_L2DCCR_DCRED); }
inline void ltdc_l2dccr_set_dcgreen(struct LTDC_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTDC_L2DCCR_DCGREEN) | ((val<<8) & LTDC_L2DCCR_DCGREEN); }
inline void ltdc_l2dccr_set_dcblue(struct LTDC_Type* p, uint32_t val) { p->L2DCCR = (p->L2DCCR & ~LTDC_L2DCCR_DCBLUE) | ((val<<0) & LTDC_L2DCCR_DCBLUE); }
inline uint32_t ltdc_l2dccr_get_dcalpha(struct LTDC_Type* p) { return (p->L2DCCR & LTDC_L2DCCR_DCALPHA) >> 24 ; }
inline uint32_t ltdc_l2dccr_get_dcred(struct LTDC_Type* p) { return (p->L2DCCR & LTDC_L2DCCR_DCRED) >> 16 ; }
inline uint32_t ltdc_l2dccr_get_dcgreen(struct LTDC_Type* p) { return (p->L2DCCR & LTDC_L2DCCR_DCGREEN) >> 8 ; }
inline uint32_t ltdc_l2dccr_get_dcblue(struct LTDC_Type* p) { return (p->L2DCCR & LTDC_L2DCCR_DCBLUE) >> 0 ; }

// LTDC->L2BFCR Layerx Blending Factors Configuration Register
enum {
	LTDC_L2BFCR_BF1 = ((1UL<<3)-1) << 8, // Blending Factor 1
	LTDC_L2BFCR_BF2 = ((1UL<<3)-1) << 0, // Blending Factor 2		
};
inline void ltdc_l2bfcr_set_bf1(struct LTDC_Type* p, uint32_t val) { p->L2BFCR = (p->L2BFCR & ~LTDC_L2BFCR_BF1) | ((val<<8) & LTDC_L2BFCR_BF1); }
inline void ltdc_l2bfcr_set_bf2(struct LTDC_Type* p, uint32_t val) { p->L2BFCR = (p->L2BFCR & ~LTDC_L2BFCR_BF2) | ((val<<0) & LTDC_L2BFCR_BF2); }
inline uint32_t ltdc_l2bfcr_get_bf1(struct LTDC_Type* p) { return (p->L2BFCR & LTDC_L2BFCR_BF1) >> 8 ; }
inline uint32_t ltdc_l2bfcr_get_bf2(struct LTDC_Type* p) { return (p->L2BFCR & LTDC_L2BFCR_BF2) >> 0 ; }

// LTDC->L2CFBLR Layerx Color Frame Buffer Length Register
enum {
	LTDC_L2CFBLR_CFBP = ((1UL<<13)-1) << 16, // Color Frame Buffer Pitch in bytes
	LTDC_L2CFBLR_CFBLL = ((1UL<<13)-1) << 0, // Color Frame Buffer Line Length		
};
inline void ltdc_l2cfblr_set_cfbp(struct LTDC_Type* p, uint32_t val) { p->L2CFBLR = (p->L2CFBLR & ~LTDC_L2CFBLR_CFBP) | ((val<<16) & LTDC_L2CFBLR_CFBP); }
inline void ltdc_l2cfblr_set_cfbll(struct LTDC_Type* p, uint32_t val) { p->L2CFBLR = (p->L2CFBLR & ~LTDC_L2CFBLR_CFBLL) | ((val<<0) & LTDC_L2CFBLR_CFBLL); }
inline uint32_t ltdc_l2cfblr_get_cfbp(struct LTDC_Type* p) { return (p->L2CFBLR & LTDC_L2CFBLR_CFBP) >> 16 ; }
inline uint32_t ltdc_l2cfblr_get_cfbll(struct LTDC_Type* p) { return (p->L2CFBLR & LTDC_L2CFBLR_CFBLL) >> 0 ; }

// LTDC->L2CFBLNR Layerx ColorFrame Buffer Line Number Register
enum {
	LTDC_L2CFBLNR_CFBLNBR = ((1UL<<11)-1) << 0, // Frame Buffer Line Number		
};
inline void ltdc_l2cfblnr_set_cfblnbr(struct LTDC_Type* p, uint32_t val) { p->L2CFBLNR = (p->L2CFBLNR & ~LTDC_L2CFBLNR_CFBLNBR) | ((val<<0) & LTDC_L2CFBLNR_CFBLNBR); }
inline uint32_t ltdc_l2cfblnr_get_cfblnbr(struct LTDC_Type* p) { return (p->L2CFBLNR & LTDC_L2CFBLNR_CFBLNBR) >> 0 ; }

// LTDC->L2CLUTWR Layerx CLUT Write Register
enum {
	LTDC_L2CLUTWR_CLUTADD = ((1UL<<8)-1) << 24, // CLUT Address
	LTDC_L2CLUTWR_RED = ((1UL<<8)-1) << 16, // Red value
	LTDC_L2CLUTWR_GREEN = ((1UL<<8)-1) << 8, // Green value
	LTDC_L2CLUTWR_BLUE = ((1UL<<8)-1) << 0, // Blue value		
};
inline void ltdc_l2clutwr_set_clutadd(struct LTDC_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTDC_L2CLUTWR_CLUTADD) | ((val<<24) & LTDC_L2CLUTWR_CLUTADD); }
inline void ltdc_l2clutwr_set_red(struct LTDC_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTDC_L2CLUTWR_RED) | ((val<<16) & LTDC_L2CLUTWR_RED); }
inline void ltdc_l2clutwr_set_green(struct LTDC_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTDC_L2CLUTWR_GREEN) | ((val<<8) & LTDC_L2CLUTWR_GREEN); }
inline void ltdc_l2clutwr_set_blue(struct LTDC_Type* p, uint32_t val) { p->L2CLUTWR = (p->L2CLUTWR & ~LTDC_L2CLUTWR_BLUE) | ((val<<0) & LTDC_L2CLUTWR_BLUE); }
inline uint32_t ltdc_l2clutwr_get_clutadd(struct LTDC_Type* p) { return (p->L2CLUTWR & LTDC_L2CLUTWR_CLUTADD) >> 24 ; }
inline uint32_t ltdc_l2clutwr_get_red(struct LTDC_Type* p) { return (p->L2CLUTWR & LTDC_L2CLUTWR_RED) >> 16 ; }
inline uint32_t ltdc_l2clutwr_get_green(struct LTDC_Type* p) { return (p->L2CLUTWR & LTDC_L2CLUTWR_GREEN) >> 8 ; }
inline uint32_t ltdc_l2clutwr_get_blue(struct LTDC_Type* p) { return (p->L2CLUTWR & LTDC_L2CLUTWR_BLUE) >> 0 ; }

/* Management data input/output slave */
struct MDIOS_Type {
	__IO uint16_t MDIOS_CR; // @0 MDIOS configuration register
	 uint8_t RESERVED0[2]; // @2 
	__I uint32_t MDIOS_WRFR; // @4 MDIOS write flag register
	__IO uint32_t MDIOS_CWRFR; // @8 MDIOS clear write flag register
	__I uint32_t MDIOS_RDFR; // @12 MDIOS read flag register
	__IO uint32_t MDIOS_CRDFR; // @16 MDIOS clear read flag register
	__I uint8_t MDIOS_SR; // @20 MDIOS status register
	 uint8_t RESERVED1[3]; // @21 
	__IO uint8_t MDIOS_CLRFR; // @24 MDIOS clear flag register
	 uint8_t RESERVED2[3]; // @25 
	__I uint16_t MDIOS_DINR0; // @28 MDIOS input data register 0
	 uint8_t RESERVED3[2]; // @30 
	__I uint16_t MDIOS_DINR1; // @32 MDIOS input data register 1
	 uint8_t RESERVED4[2]; // @34 
	__I uint16_t MDIOS_DINR2; // @36 MDIOS input data register 2
	 uint8_t RESERVED5[2]; // @38 
	__I uint16_t MDIOS_DINR3; // @40 MDIOS input data register 3
	 uint8_t RESERVED6[2]; // @42 
	__I uint16_t MDIOS_DINR4; // @44 MDIOS input data register 4
	 uint8_t RESERVED7[2]; // @46 
	__I uint16_t MDIOS_DINR5; // @48 MDIOS input data register 5
	 uint8_t RESERVED8[2]; // @50 
	__I uint16_t MDIOS_DINR6; // @52 MDIOS input data register 6
	 uint8_t RESERVED9[2]; // @54 
	__I uint16_t MDIOS_DINR7; // @56 MDIOS input data register 7
	 uint8_t RESERVED10[2]; // @58 
	__I uint16_t MDIOS_DINR8; // @60 MDIOS input data register 8
	 uint8_t RESERVED11[2]; // @62 
	__I uint16_t MDIOS_DINR9; // @64 MDIOS input data register 9
	 uint8_t RESERVED12[2]; // @66 
	__I uint16_t MDIOS_DINR10; // @68 MDIOS input data register 10
	 uint8_t RESERVED13[2]; // @70 
	__I uint16_t MDIOS_DINR11; // @72 MDIOS input data register 11
	 uint8_t RESERVED14[2]; // @74 
	__I uint16_t MDIOS_DINR12; // @76 MDIOS input data register 12
	 uint8_t RESERVED15[2]; // @78 
	__I uint16_t MDIOS_DINR13; // @80 MDIOS input data register 13
	 uint8_t RESERVED16[2]; // @82 
	__I uint16_t MDIOS_DINR14; // @84 MDIOS input data register 14
	 uint8_t RESERVED17[2]; // @86 
	__I uint16_t MDIOS_DINR15; // @88 MDIOS input data register 15
	 uint8_t RESERVED18[2]; // @90 
	__I uint16_t MDIOS_DINR16; // @92 MDIOS input data register 16
	 uint8_t RESERVED19[2]; // @94 
	__I uint16_t MDIOS_DINR17; // @96 MDIOS input data register 17
	 uint8_t RESERVED20[2]; // @98 
	__I uint16_t MDIOS_DINR18; // @100 MDIOS input data register 18
	 uint8_t RESERVED21[2]; // @102 
	__I uint16_t MDIOS_DINR19; // @104 MDIOS input data register 19
	 uint8_t RESERVED22[2]; // @106 
	__I uint16_t MDIOS_DINR20; // @108 MDIOS input data register 20
	 uint8_t RESERVED23[2]; // @110 
	__I uint16_t MDIOS_DINR21; // @112 MDIOS input data register 21
	 uint8_t RESERVED24[2]; // @114 
	__I uint16_t MDIOS_DINR22; // @116 MDIOS input data register 22
	 uint8_t RESERVED25[2]; // @118 
	__I uint16_t MDIOS_DINR23; // @120 MDIOS input data register 23
	 uint8_t RESERVED26[2]; // @122 
	__I uint16_t MDIOS_DINR24; // @124 MDIOS input data register 24
	 uint8_t RESERVED27[2]; // @126 
	__I uint16_t MDIOS_DINR25; // @128 MDIOS input data register 25
	 uint8_t RESERVED28[2]; // @130 
	__I uint16_t MDIOS_DINR26; // @132 MDIOS input data register 26
	 uint8_t RESERVED29[2]; // @134 
	__I uint16_t MDIOS_DINR27; // @136 MDIOS input data register 27
	 uint8_t RESERVED30[2]; // @138 
	__I uint16_t MDIOS_DINR28; // @140 MDIOS input data register 28
	 uint8_t RESERVED31[2]; // @142 
	__I uint16_t MDIOS_DINR29; // @144 MDIOS input data register 29
	 uint8_t RESERVED32[2]; // @146 
	__I uint16_t MDIOS_DINR30; // @148 MDIOS input data register 30
	 uint8_t RESERVED33[2]; // @150 
	__I uint16_t MDIOS_DINR31; // @152 MDIOS input data register 31
	 uint8_t RESERVED34[2]; // @154 
	__IO uint16_t MDIOS_DOUTR0; // @156 MDIOS output data register 0
	 uint8_t RESERVED35[2]; // @158 
	__IO uint16_t MDIOS_DOUTR1; // @160 MDIOS output data register 1
	 uint8_t RESERVED36[2]; // @162 
	__IO uint16_t MDIOS_DOUTR2; // @164 MDIOS output data register 2
	 uint8_t RESERVED37[2]; // @166 
	__IO uint16_t MDIOS_DOUTR3; // @168 MDIOS output data register 3
	 uint8_t RESERVED38[2]; // @170 
	__IO uint16_t MDIOS_DOUTR4; // @172 MDIOS output data register 4
	 uint8_t RESERVED39[2]; // @174 
	__IO uint16_t MDIOS_DOUTR5; // @176 MDIOS output data register 5
	 uint8_t RESERVED40[2]; // @178 
	__IO uint16_t MDIOS_DOUTR6; // @180 MDIOS output data register 6
	 uint8_t RESERVED41[2]; // @182 
	__IO uint16_t MDIOS_DOUTR7; // @184 MDIOS output data register 7
	 uint8_t RESERVED42[2]; // @186 
	__IO uint16_t MDIOS_DOUTR8; // @188 MDIOS output data register 8
	 uint8_t RESERVED43[2]; // @190 
	__IO uint16_t MDIOS_DOUTR9; // @192 MDIOS output data register 9
	 uint8_t RESERVED44[2]; // @194 
	__IO uint16_t MDIOS_DOUTR10; // @196 MDIOS output data register 10
	 uint8_t RESERVED45[2]; // @198 
	__IO uint16_t MDIOS_DOUTR11; // @200 MDIOS output data register 11
	 uint8_t RESERVED46[2]; // @202 
	__IO uint16_t MDIOS_DOUTR12; // @204 MDIOS output data register 12
	 uint8_t RESERVED47[2]; // @206 
	__IO uint16_t MDIOS_DOUTR13; // @208 MDIOS output data register 13
	 uint8_t RESERVED48[2]; // @210 
	__IO uint16_t MDIOS_DOUTR14; // @212 MDIOS output data register 14
	 uint8_t RESERVED49[2]; // @214 
	__IO uint16_t MDIOS_DOUTR15; // @216 MDIOS output data register 15
	 uint8_t RESERVED50[2]; // @218 
	__IO uint16_t MDIOS_DOUTR16; // @220 MDIOS output data register 16
	 uint8_t RESERVED51[2]; // @222 
	__IO uint16_t MDIOS_DOUTR17; // @224 MDIOS output data register 17
	 uint8_t RESERVED52[2]; // @226 
	__IO uint16_t MDIOS_DOUTR18; // @228 MDIOS output data register 18
	 uint8_t RESERVED53[2]; // @230 
	__IO uint16_t MDIOS_DOUTR19; // @232 MDIOS output data register 19
	 uint8_t RESERVED54[2]; // @234 
	__IO uint16_t MDIOS_DOUTR20; // @236 MDIOS output data register 20
	 uint8_t RESERVED55[2]; // @238 
	__IO uint16_t MDIOS_DOUTR21; // @240 MDIOS output data register 21
	 uint8_t RESERVED56[2]; // @242 
	__IO uint16_t MDIOS_DOUTR22; // @244 MDIOS output data register 22
	 uint8_t RESERVED57[2]; // @246 
	__IO uint16_t MDIOS_DOUTR23; // @248 MDIOS output data register 23
	 uint8_t RESERVED58[2]; // @250 
	__IO uint16_t MDIOS_DOUTR24; // @252 MDIOS output data register 24
	 uint8_t RESERVED59[2]; // @254 
	__IO uint16_t MDIOS_DOUTR25; // @256 MDIOS output data register 25
	 uint8_t RESERVED60[2]; // @258 
	__IO uint16_t MDIOS_DOUTR26; // @260 MDIOS output data register 26
	 uint8_t RESERVED61[2]; // @262 
	__IO uint16_t MDIOS_DOUTR27; // @264 MDIOS output data register 27
	 uint8_t RESERVED62[2]; // @266 
	__IO uint16_t MDIOS_DOUTR28; // @268 MDIOS output data register 28
	 uint8_t RESERVED63[2]; // @270 
	__IO uint16_t MDIOS_DOUTR29; // @272 MDIOS output data register 29
	 uint8_t RESERVED64[2]; // @274 
	__IO uint16_t MDIOS_DOUTR30; // @276 MDIOS output data register 30
	 uint8_t RESERVED65[2]; // @278 
	__IO uint16_t MDIOS_DOUTR31; // @280 MDIOS output data register 31
};

// MDIOS->MDIOS_CR MDIOS configuration register
enum {
	MDIOS_MDIOS_CR_PORT_ADDRESS = ((1UL<<5)-1) << 8, // Slaves's address
	MDIOS_MDIOS_CR_DPC = 1UL<<7, // Disable Preamble Check
	MDIOS_MDIOS_CR_EIE = 1UL<<3, // Error interrupt enable
	MDIOS_MDIOS_CR_RDIE = 1UL<<2, // Register Read Interrupt Enable
	MDIOS_MDIOS_CR_WRIE = 1UL<<1, // Register write interrupt enable
	MDIOS_MDIOS_CR_EN = 1UL<<0, // Peripheral enable		
};
inline void mdios_mdios_cr_set_port_address(struct MDIOS_Type* p, uint32_t val) { p->MDIOS_CR = (p->MDIOS_CR & ~MDIOS_MDIOS_CR_PORT_ADDRESS) | ((val<<8) & MDIOS_MDIOS_CR_PORT_ADDRESS); }
inline uint32_t mdios_mdios_cr_get_port_address(struct MDIOS_Type* p) { return (p->MDIOS_CR & MDIOS_MDIOS_CR_PORT_ADDRESS) >> 8 ; }

// MDIOS->MDIOS_SR MDIOS status register
enum {
	MDIOS_MDIOS_SR_TERF = 1UL<<2, // Turnaround error flag
	MDIOS_MDIOS_SR_SERF = 1UL<<1, // Start error flag
	MDIOS_MDIOS_SR_PERF = 1UL<<0, // Preamble error flag		
};

// MDIOS->MDIOS_CLRFR MDIOS clear flag register
enum {
	MDIOS_MDIOS_CLRFR_CTERF = 1UL<<2, // Clear the turnaround error flag
	MDIOS_MDIOS_CLRFR_CSERF = 1UL<<1, // Clear the start error flag
	MDIOS_MDIOS_CLRFR_CPERF = 1UL<<0, // Clear the preamble error flag		
};

/* MDMA */
struct MDMA_Type {
	__I uint16_t MDMA_GISR0; // @0 MDMA Global Interrupt/Status Register
	 uint8_t RESERVED0[62]; // @2 
	__I uint32_t MDMA_C0ISR; // @64 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C0IFCR; // @68 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED1[3]; // @69 
	__I uint16_t MDMA_C0ESR; // @72 MDMA Channel x error status register
	 uint8_t RESERVED2[2]; // @74 
	__IO uint32_t MDMA_C0CR; // @76 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C0TCR; // @80 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C0BNDTR; // @84 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C0SAR; // @88 MDMA channel x source address register
	__IO uint32_t MDMA_C0DAR; // @92 MDMA channel x destination address register
	__IO uint32_t MDMA_C0BRUR; // @96 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C0LAR; // @100 MDMA channel x Link Address register
	__IO uint32_t MDMA_C0TBR; // @104 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED3[4]; // @108 
	__IO uint32_t MDMA_C0MAR; // @112 MDMA channel x Mask address register
	__IO uint32_t MDMA_C0MDR; // @116 MDMA channel x Mask Data register
	 uint8_t RESERVED4[8]; // @120 
	__I uint32_t MDMA_C1ISR; // @128 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C1IFCR; // @132 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED5[3]; // @133 
	__I uint16_t MDMA_C1ESR; // @136 MDMA Channel x error status register
	 uint8_t RESERVED6[2]; // @138 
	__IO uint32_t MDMA_C1CR; // @140 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C1TCR; // @144 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C1BNDTR; // @148 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C1SAR; // @152 MDMA channel x source address register
	__IO uint32_t MDMA_C1DAR; // @156 MDMA channel x destination address register
	__IO uint32_t MDMA_C1BRUR; // @160 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C1LAR; // @164 MDMA channel x Link Address register
	__IO uint32_t MDMA_C1TBR; // @168 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED7[4]; // @172 
	__IO uint32_t MDMA_C1MAR; // @176 MDMA channel x Mask address register
	__IO uint32_t MDMA_C1MDR; // @180 MDMA channel x Mask Data register
	 uint8_t RESERVED8[8]; // @184 
	__I uint32_t MDMA_C2ISR; // @192 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C2IFCR; // @196 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED9[3]; // @197 
	__I uint16_t MDMA_C2ESR; // @200 MDMA Channel x error status register
	 uint8_t RESERVED10[2]; // @202 
	__IO uint32_t MDMA_C2CR; // @204 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C2TCR; // @208 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C2BNDTR; // @212 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C2SAR; // @216 MDMA channel x source address register
	__IO uint32_t MDMA_C2DAR; // @220 MDMA channel x destination address register
	__IO uint32_t MDMA_C2BRUR; // @224 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C2LAR; // @228 MDMA channel x Link Address register
	__IO uint32_t MDMA_C2TBR; // @232 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED11[4]; // @236 
	__IO uint32_t MDMA_C2MAR; // @240 MDMA channel x Mask address register
	__IO uint32_t MDMA_C2MDR; // @244 MDMA channel x Mask Data register
	 uint8_t RESERVED12[8]; // @248 
	__I uint32_t MDMA_C3ISR; // @256 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C3IFCR; // @260 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED13[3]; // @261 
	__I uint16_t MDMA_C3ESR; // @264 MDMA Channel x error status register
	 uint8_t RESERVED14[2]; // @266 
	__IO uint32_t MDMA_C3CR; // @268 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C3TCR; // @272 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C3BNDTR; // @276 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C3SAR; // @280 MDMA channel x source address register
	__IO uint32_t MDMA_C3DAR; // @284 MDMA channel x destination address register
	__IO uint32_t MDMA_C3BRUR; // @288 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C3LAR; // @292 MDMA channel x Link Address register
	__IO uint32_t MDMA_C3TBR; // @296 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED15[4]; // @300 
	__IO uint32_t MDMA_C3MAR; // @304 MDMA channel x Mask address register
	__IO uint32_t MDMA_C3MDR; // @308 MDMA channel x Mask Data register
	 uint8_t RESERVED16[8]; // @312 
	__I uint32_t MDMA_C4ISR; // @320 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C4IFCR; // @324 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED17[3]; // @325 
	__I uint16_t MDMA_C4ESR; // @328 MDMA Channel x error status register
	 uint8_t RESERVED18[2]; // @330 
	__IO uint32_t MDMA_C4CR; // @332 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C4TCR; // @336 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C4BNDTR; // @340 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C4SAR; // @344 MDMA channel x source address register
	__IO uint32_t MDMA_C4DAR; // @348 MDMA channel x destination address register
	__IO uint32_t MDMA_C4BRUR; // @352 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C4LAR; // @356 MDMA channel x Link Address register
	__IO uint32_t MDMA_C4TBR; // @360 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED19[4]; // @364 
	__IO uint32_t MDMA_C4MAR; // @368 MDMA channel x Mask address register
	__IO uint32_t MDMA_C4MDR; // @372 MDMA channel x Mask Data register
	 uint8_t RESERVED20[8]; // @376 
	__I uint32_t MDMA_C5ISR; // @384 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C5IFCR; // @388 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED21[3]; // @389 
	__I uint16_t MDMA_C5ESR; // @392 MDMA Channel x error status register
	 uint8_t RESERVED22[2]; // @394 
	__IO uint32_t MDMA_C5CR; // @396 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C5TCR; // @400 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C5BNDTR; // @404 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C5SAR; // @408 MDMA channel x source address register
	__IO uint32_t MDMA_C5DAR; // @412 MDMA channel x destination address register
	__IO uint32_t MDMA_C5BRUR; // @416 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C5LAR; // @420 MDMA channel x Link Address register
	__IO uint32_t MDMA_C5TBR; // @424 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED23[4]; // @428 
	__IO uint32_t MDMA_C5MAR; // @432 MDMA channel x Mask address register
	__IO uint32_t MDMA_C5MDR; // @436 MDMA channel x Mask Data register
	 uint8_t RESERVED24[8]; // @440 
	__I uint32_t MDMA_C6ISR; // @448 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C6IFCR; // @452 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED25[3]; // @453 
	__I uint16_t MDMA_C6ESR; // @456 MDMA Channel x error status register
	 uint8_t RESERVED26[2]; // @458 
	__IO uint32_t MDMA_C6CR; // @460 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C6TCR; // @464 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C6BNDTR; // @468 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C6SAR; // @472 MDMA channel x source address register
	__IO uint32_t MDMA_C6DAR; // @476 MDMA channel x destination address register
	__IO uint32_t MDMA_C6BRUR; // @480 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C6LAR; // @484 MDMA channel x Link Address register
	__IO uint32_t MDMA_C6TBR; // @488 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED27[4]; // @492 
	__IO uint32_t MDMA_C6MAR; // @496 MDMA channel x Mask address register
	__IO uint32_t MDMA_C6MDR; // @500 MDMA channel x Mask Data register
	 uint8_t RESERVED28[8]; // @504 
	__I uint32_t MDMA_C7ISR; // @512 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C7IFCR; // @516 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED29[3]; // @517 
	__I uint16_t MDMA_C7ESR; // @520 MDMA Channel x error status register
	 uint8_t RESERVED30[2]; // @522 
	__IO uint32_t MDMA_C7CR; // @524 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C7TCR; // @528 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C7BNDTR; // @532 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C7SAR; // @536 MDMA channel x source address register
	__IO uint32_t MDMA_C7DAR; // @540 MDMA channel x destination address register
	__IO uint32_t MDMA_C7BRUR; // @544 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C7LAR; // @548 MDMA channel x Link Address register
	__IO uint32_t MDMA_C7TBR; // @552 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED31[4]; // @556 
	__IO uint32_t MDMA_C7MAR; // @560 MDMA channel x Mask address register
	__IO uint32_t MDMA_C7MDR; // @564 MDMA channel x Mask Data register
	 uint8_t RESERVED32[8]; // @568 
	__I uint32_t MDMA_C8ISR; // @576 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C8IFCR; // @580 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED33[3]; // @581 
	__I uint16_t MDMA_C8ESR; // @584 MDMA Channel x error status register
	 uint8_t RESERVED34[2]; // @586 
	__IO uint32_t MDMA_C8CR; // @588 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C8TCR; // @592 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C8BNDTR; // @596 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C8SAR; // @600 MDMA channel x source address register
	__IO uint32_t MDMA_C8DAR; // @604 MDMA channel x destination address register
	__IO uint32_t MDMA_C8BRUR; // @608 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C8LAR; // @612 MDMA channel x Link Address register
	__IO uint32_t MDMA_C8TBR; // @616 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED35[4]; // @620 
	__IO uint32_t MDMA_C8MAR; // @624 MDMA channel x Mask address register
	__IO uint32_t MDMA_C8MDR; // @628 MDMA channel x Mask Data register
	 uint8_t RESERVED36[8]; // @632 
	__I uint32_t MDMA_C9ISR; // @640 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C9IFCR; // @644 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED37[3]; // @645 
	__I uint16_t MDMA_C9ESR; // @648 MDMA Channel x error status register
	 uint8_t RESERVED38[2]; // @650 
	__IO uint32_t MDMA_C9CR; // @652 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C9TCR; // @656 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C9BNDTR; // @660 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C9SAR; // @664 MDMA channel x source address register
	__IO uint32_t MDMA_C9DAR; // @668 MDMA channel x destination address register
	__IO uint32_t MDMA_C9BRUR; // @672 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C9LAR; // @676 MDMA channel x Link Address register
	__IO uint32_t MDMA_C9TBR; // @680 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED39[4]; // @684 
	__IO uint32_t MDMA_C9MAR; // @688 MDMA channel x Mask address register
	__IO uint32_t MDMA_C9MDR; // @692 MDMA channel x Mask Data register
	 uint8_t RESERVED40[8]; // @696 
	__I uint32_t MDMA_C10ISR; // @704 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C10IFCR; // @708 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED41[3]; // @709 
	__I uint16_t MDMA_C10ESR; // @712 MDMA Channel x error status register
	 uint8_t RESERVED42[2]; // @714 
	__IO uint32_t MDMA_C10CR; // @716 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C10TCR; // @720 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C10BNDTR; // @724 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C10SAR; // @728 MDMA channel x source address register
	__IO uint32_t MDMA_C10DAR; // @732 MDMA channel x destination address register
	__IO uint32_t MDMA_C10BRUR; // @736 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C10LAR; // @740 MDMA channel x Link Address register
	__IO uint32_t MDMA_C10TBR; // @744 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED43[4]; // @748 
	__IO uint32_t MDMA_C10MAR; // @752 MDMA channel x Mask address register
	__IO uint32_t MDMA_C10MDR; // @756 MDMA channel x Mask Data register
	 uint8_t RESERVED44[8]; // @760 
	__I uint32_t MDMA_C11ISR; // @768 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C11IFCR; // @772 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED45[3]; // @773 
	__I uint16_t MDMA_C11ESR; // @776 MDMA Channel x error status register
	 uint8_t RESERVED46[2]; // @778 
	__IO uint32_t MDMA_C11CR; // @780 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C11TCR; // @784 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C11BNDTR; // @788 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C11SAR; // @792 MDMA channel x source address register
	__IO uint32_t MDMA_C11DAR; // @796 MDMA channel x destination address register
	__IO uint32_t MDMA_C11BRUR; // @800 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C11LAR; // @804 MDMA channel x Link Address register
	__IO uint32_t MDMA_C11TBR; // @808 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED47[4]; // @812 
	__IO uint32_t MDMA_C11MAR; // @816 MDMA channel x Mask address register
	__IO uint32_t MDMA_C11MDR; // @820 MDMA channel x Mask Data register
	 uint8_t RESERVED48[8]; // @824 
	__I uint32_t MDMA_C12ISR; // @832 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C12IFCR; // @836 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED49[3]; // @837 
	__I uint16_t MDMA_C12ESR; // @840 MDMA Channel x error status register
	 uint8_t RESERVED50[2]; // @842 
	__IO uint32_t MDMA_C12CR; // @844 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C12TCR; // @848 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C12BNDTR; // @852 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C12SAR; // @856 MDMA channel x source address register
	__IO uint32_t MDMA_C12DAR; // @860 MDMA channel x destination address register
	__IO uint32_t MDMA_C12BRUR; // @864 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C12LAR; // @868 MDMA channel x Link Address register
	__IO uint32_t MDMA_C12TBR; // @872 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED51[4]; // @876 
	__IO uint32_t MDMA_C12MAR; // @880 MDMA channel x Mask address register
	__IO uint32_t MDMA_C12MDR; // @884 MDMA channel x Mask Data register
	 uint8_t RESERVED52[8]; // @888 
	__I uint32_t MDMA_C13ISR; // @896 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C13IFCR; // @900 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED53[3]; // @901 
	__I uint16_t MDMA_C13ESR; // @904 MDMA Channel x error status register
	 uint8_t RESERVED54[2]; // @906 
	__IO uint32_t MDMA_C13CR; // @908 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C13TCR; // @912 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C13BNDTR; // @916 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C13SAR; // @920 MDMA channel x source address register
	__IO uint32_t MDMA_C13DAR; // @924 MDMA channel x destination address register
	__IO uint32_t MDMA_C13BRUR; // @928 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C13LAR; // @932 MDMA channel x Link Address register
	__IO uint32_t MDMA_C13TBR; // @936 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED55[4]; // @940 
	__IO uint32_t MDMA_C13MAR; // @944 MDMA channel x Mask address register
	__IO uint32_t MDMA_C13MDR; // @948 MDMA channel x Mask Data register
	 uint8_t RESERVED56[8]; // @952 
	__I uint32_t MDMA_C14ISR; // @960 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C14IFCR; // @964 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED57[3]; // @965 
	__I uint16_t MDMA_C14ESR; // @968 MDMA Channel x error status register
	 uint8_t RESERVED58[2]; // @970 
	__IO uint32_t MDMA_C14CR; // @972 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C14TCR; // @976 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C14BNDTR; // @980 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C14SAR; // @984 MDMA channel x source address register
	__IO uint32_t MDMA_C14DAR; // @988 MDMA channel x destination address register
	__IO uint32_t MDMA_C14BRUR; // @992 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C14LAR; // @996 MDMA channel x Link Address register
	__IO uint32_t MDMA_C14TBR; // @1000 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED59[4]; // @1004 
	__IO uint32_t MDMA_C14MAR; // @1008 MDMA channel x Mask address register
	__IO uint32_t MDMA_C14MDR; // @1012 MDMA channel x Mask Data register
	 uint8_t RESERVED60[8]; // @1016 
	__I uint32_t MDMA_C15ISR; // @1024 MDMA channel x interrupt/status register
	__O uint8_t MDMA_C15IFCR; // @1028 MDMA channel x interrupt flag clear register
	 uint8_t RESERVED61[3]; // @1029 
	__I uint16_t MDMA_C15ESR; // @1032 MDMA Channel x error status register
	 uint8_t RESERVED62[2]; // @1034 
	__IO uint32_t MDMA_C15CR; // @1036 This register is used to control the concerned channel.
	__IO uint32_t MDMA_C15TCR; // @1040 This register is used to configure the concerned channel.
	__IO uint32_t MDMA_C15BNDTR; // @1044 MDMA Channel x block number of data register
	__IO uint32_t MDMA_C15SAR; // @1048 MDMA channel x source address register
	__IO uint32_t MDMA_C15DAR; // @1052 MDMA channel x destination address register
	__IO uint32_t MDMA_C15BRUR; // @1056 MDMA channel x Block Repeat address Update register
	__IO uint32_t MDMA_C15LAR; // @1060 MDMA channel x Link Address register
	__IO uint32_t MDMA_C15TBR; // @1064 MDMA channel x Trigger and Bus selection Register
	 uint8_t RESERVED63[4]; // @1068 
	__IO uint32_t MDMA_C15MAR; // @1072 MDMA channel x Mask address register
	__IO uint32_t MDMA_C15MDR; // @1076 MDMA channel x Mask Data register
};

// MDMA->MDMA_C0ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C0ISR_CRQA0 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C0ISR_TCIF0 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C0ISR_BTIF0 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C0ISR_BRTIF0 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C0ISR_CTCIF0 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C0ISR_TEIF0 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C0IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C0IFCR_CLTCIF0 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C0IFCR_CBTIF0 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C0IFCR_CBRTIF0 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C0IFCR_CCTCIF0 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C0IFCR_CTEIF0 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C0ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C0ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C0ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C0ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C0ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C0ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C0ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c0esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C0ESR & MDMA_MDMA_C0ESR_TEA) >> 0 ; }

// MDMA->MDMA_C0CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C0CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C0CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C0CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C0CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C0CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C0CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C0CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C0CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C0CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C0CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C0CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c0cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0CR = (p->MDMA_C0CR & ~MDMA_MDMA_C0CR_PL) | ((val<<6) & MDMA_MDMA_C0CR_PL); }
inline uint32_t mdma_mdma_c0cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C0CR & MDMA_MDMA_C0CR_PL) >> 6 ; }

// MDMA->MDMA_C0TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C0TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C0TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C0TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C0TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C0TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C0TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C0TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C0TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C0TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C0TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C0TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C0TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C0TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C0TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c0tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_TRGM) | ((val<<28) & MDMA_MDMA_C0TCR_TRGM); }
inline void mdma_mdma_c0tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_PAM) | ((val<<26) & MDMA_MDMA_C0TCR_PAM); }
inline void mdma_mdma_c0tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_TLEN) | ((val<<18) & MDMA_MDMA_C0TCR_TLEN); }
inline void mdma_mdma_c0tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_DBURST) | ((val<<15) & MDMA_MDMA_C0TCR_DBURST); }
inline void mdma_mdma_c0tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_SBURST) | ((val<<12) & MDMA_MDMA_C0TCR_SBURST); }
inline void mdma_mdma_c0tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C0TCR_DINCOS); }
inline void mdma_mdma_c0tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C0TCR_SINCOS); }
inline void mdma_mdma_c0tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C0TCR_DSIZE); }
inline void mdma_mdma_c0tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C0TCR_SSIZE); }
inline void mdma_mdma_c0tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_DINC) | ((val<<2) & MDMA_MDMA_C0TCR_DINC); }
inline void mdma_mdma_c0tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TCR = (p->MDMA_C0TCR & ~MDMA_MDMA_C0TCR_SINC) | ((val<<0) & MDMA_MDMA_C0TCR_SINC); }
inline uint32_t mdma_mdma_c0tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c0tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c0tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c0tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c0tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c0tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c0tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c0tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c0tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c0tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c0tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C0TCR & MDMA_MDMA_C0TCR_SINC) >> 0 ; }

// MDMA->MDMA_C0BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C0BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C0BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C0BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C0BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c0bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0BNDTR = (p->MDMA_C0BNDTR & ~MDMA_MDMA_C0BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C0BNDTR_BRC); }
inline void mdma_mdma_c0bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0BNDTR = (p->MDMA_C0BNDTR & ~MDMA_MDMA_C0BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C0BNDTR_BNDT); }
inline uint32_t mdma_mdma_c0bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C0BNDTR & MDMA_MDMA_C0BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c0bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C0BNDTR & MDMA_MDMA_C0BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C0BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C0BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C0BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c0brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0BRUR = (p->MDMA_C0BRUR & ~MDMA_MDMA_C0BRUR_DUV) | ((val<<16) & MDMA_MDMA_C0BRUR_DUV); }
inline void mdma_mdma_c0brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0BRUR = (p->MDMA_C0BRUR & ~MDMA_MDMA_C0BRUR_SUV) | ((val<<0) & MDMA_MDMA_C0BRUR_SUV); }
inline uint32_t mdma_mdma_c0brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C0BRUR & MDMA_MDMA_C0BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c0brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C0BRUR & MDMA_MDMA_C0BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C0TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C0TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C0TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C0TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c0tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C0TBR = (p->MDMA_C0TBR & ~MDMA_MDMA_C0TBR_TSEL) | ((val<<0) & MDMA_MDMA_C0TBR_TSEL); }
inline uint32_t mdma_mdma_c0tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C0TBR & MDMA_MDMA_C0TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C1ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C1ISR_CRQA1 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C1ISR_TCIF1 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C1ISR_BTIF1 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C1ISR_BRTIF1 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C1ISR_CTCIF1 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C1ISR_TEIF1 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C1IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C1IFCR_CLTCIF1 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C1IFCR_CBTIF1 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C1IFCR_CBRTIF1 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C1IFCR_CCTCIF1 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C1IFCR_CTEIF1 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C1ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C1ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C1ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C1ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C1ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C1ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C1ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c1esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C1ESR & MDMA_MDMA_C1ESR_TEA) >> 0 ; }

// MDMA->MDMA_C1CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C1CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C1CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C1CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C1CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C1CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C1CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C1CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C1CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C1CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C1CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C1CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c1cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1CR = (p->MDMA_C1CR & ~MDMA_MDMA_C1CR_PL) | ((val<<6) & MDMA_MDMA_C1CR_PL); }
inline uint32_t mdma_mdma_c1cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C1CR & MDMA_MDMA_C1CR_PL) >> 6 ; }

// MDMA->MDMA_C1TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C1TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C1TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C1TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C1TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C1TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C1TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C1TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C1TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C1TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C1TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C1TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C1TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C1TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C1TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c1tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_TRGM) | ((val<<28) & MDMA_MDMA_C1TCR_TRGM); }
inline void mdma_mdma_c1tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_PAM) | ((val<<26) & MDMA_MDMA_C1TCR_PAM); }
inline void mdma_mdma_c1tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_TLEN) | ((val<<18) & MDMA_MDMA_C1TCR_TLEN); }
inline void mdma_mdma_c1tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_DBURST) | ((val<<15) & MDMA_MDMA_C1TCR_DBURST); }
inline void mdma_mdma_c1tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_SBURST) | ((val<<12) & MDMA_MDMA_C1TCR_SBURST); }
inline void mdma_mdma_c1tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C1TCR_DINCOS); }
inline void mdma_mdma_c1tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C1TCR_SINCOS); }
inline void mdma_mdma_c1tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C1TCR_DSIZE); }
inline void mdma_mdma_c1tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C1TCR_SSIZE); }
inline void mdma_mdma_c1tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_DINC) | ((val<<2) & MDMA_MDMA_C1TCR_DINC); }
inline void mdma_mdma_c1tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TCR = (p->MDMA_C1TCR & ~MDMA_MDMA_C1TCR_SINC) | ((val<<0) & MDMA_MDMA_C1TCR_SINC); }
inline uint32_t mdma_mdma_c1tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c1tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c1tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c1tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c1tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c1tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c1tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c1tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c1tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c1tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c1tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C1TCR & MDMA_MDMA_C1TCR_SINC) >> 0 ; }

// MDMA->MDMA_C1BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C1BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C1BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C1BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C1BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c1bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1BNDTR = (p->MDMA_C1BNDTR & ~MDMA_MDMA_C1BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C1BNDTR_BRC); }
inline void mdma_mdma_c1bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1BNDTR = (p->MDMA_C1BNDTR & ~MDMA_MDMA_C1BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C1BNDTR_BNDT); }
inline uint32_t mdma_mdma_c1bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C1BNDTR & MDMA_MDMA_C1BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c1bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C1BNDTR & MDMA_MDMA_C1BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C1BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C1BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C1BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c1brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1BRUR = (p->MDMA_C1BRUR & ~MDMA_MDMA_C1BRUR_DUV) | ((val<<16) & MDMA_MDMA_C1BRUR_DUV); }
inline void mdma_mdma_c1brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1BRUR = (p->MDMA_C1BRUR & ~MDMA_MDMA_C1BRUR_SUV) | ((val<<0) & MDMA_MDMA_C1BRUR_SUV); }
inline uint32_t mdma_mdma_c1brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C1BRUR & MDMA_MDMA_C1BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c1brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C1BRUR & MDMA_MDMA_C1BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C1TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C1TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C1TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C1TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c1tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C1TBR = (p->MDMA_C1TBR & ~MDMA_MDMA_C1TBR_TSEL) | ((val<<0) & MDMA_MDMA_C1TBR_TSEL); }
inline uint32_t mdma_mdma_c1tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C1TBR & MDMA_MDMA_C1TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C2ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C2ISR_CRQA2 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C2ISR_TCIF2 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C2ISR_BTIF2 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C2ISR_BRTIF2 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C2ISR_CTCIF2 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C2ISR_TEIF2 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C2IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C2IFCR_CLTCIF2 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C2IFCR_CBTIF2 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C2IFCR_CBRTIF2 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C2IFCR_CCTCIF2 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C2IFCR_CTEIF2 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C2ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C2ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C2ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C2ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C2ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C2ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C2ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c2esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C2ESR & MDMA_MDMA_C2ESR_TEA) >> 0 ; }

// MDMA->MDMA_C2CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C2CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C2CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C2CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C2CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C2CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C2CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C2CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C2CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C2CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C2CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C2CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c2cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2CR = (p->MDMA_C2CR & ~MDMA_MDMA_C2CR_PL) | ((val<<6) & MDMA_MDMA_C2CR_PL); }
inline uint32_t mdma_mdma_c2cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C2CR & MDMA_MDMA_C2CR_PL) >> 6 ; }

// MDMA->MDMA_C2TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C2TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C2TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C2TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C2TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C2TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C2TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C2TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C2TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C2TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C2TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C2TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C2TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C2TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C2TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c2tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_TRGM) | ((val<<28) & MDMA_MDMA_C2TCR_TRGM); }
inline void mdma_mdma_c2tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_PAM) | ((val<<26) & MDMA_MDMA_C2TCR_PAM); }
inline void mdma_mdma_c2tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_TLEN) | ((val<<18) & MDMA_MDMA_C2TCR_TLEN); }
inline void mdma_mdma_c2tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_DBURST) | ((val<<15) & MDMA_MDMA_C2TCR_DBURST); }
inline void mdma_mdma_c2tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_SBURST) | ((val<<12) & MDMA_MDMA_C2TCR_SBURST); }
inline void mdma_mdma_c2tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C2TCR_DINCOS); }
inline void mdma_mdma_c2tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C2TCR_SINCOS); }
inline void mdma_mdma_c2tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C2TCR_DSIZE); }
inline void mdma_mdma_c2tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C2TCR_SSIZE); }
inline void mdma_mdma_c2tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_DINC) | ((val<<2) & MDMA_MDMA_C2TCR_DINC); }
inline void mdma_mdma_c2tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TCR = (p->MDMA_C2TCR & ~MDMA_MDMA_C2TCR_SINC) | ((val<<0) & MDMA_MDMA_C2TCR_SINC); }
inline uint32_t mdma_mdma_c2tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c2tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c2tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c2tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c2tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c2tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c2tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c2tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c2tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c2tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c2tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C2TCR & MDMA_MDMA_C2TCR_SINC) >> 0 ; }

// MDMA->MDMA_C2BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C2BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C2BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C2BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C2BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c2bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2BNDTR = (p->MDMA_C2BNDTR & ~MDMA_MDMA_C2BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C2BNDTR_BRC); }
inline void mdma_mdma_c2bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2BNDTR = (p->MDMA_C2BNDTR & ~MDMA_MDMA_C2BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C2BNDTR_BNDT); }
inline uint32_t mdma_mdma_c2bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C2BNDTR & MDMA_MDMA_C2BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c2bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C2BNDTR & MDMA_MDMA_C2BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C2BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C2BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C2BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c2brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2BRUR = (p->MDMA_C2BRUR & ~MDMA_MDMA_C2BRUR_DUV) | ((val<<16) & MDMA_MDMA_C2BRUR_DUV); }
inline void mdma_mdma_c2brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2BRUR = (p->MDMA_C2BRUR & ~MDMA_MDMA_C2BRUR_SUV) | ((val<<0) & MDMA_MDMA_C2BRUR_SUV); }
inline uint32_t mdma_mdma_c2brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C2BRUR & MDMA_MDMA_C2BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c2brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C2BRUR & MDMA_MDMA_C2BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C2TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C2TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C2TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C2TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c2tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C2TBR = (p->MDMA_C2TBR & ~MDMA_MDMA_C2TBR_TSEL) | ((val<<0) & MDMA_MDMA_C2TBR_TSEL); }
inline uint32_t mdma_mdma_c2tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C2TBR & MDMA_MDMA_C2TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C3ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C3ISR_CRQA3 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C3ISR_TCIF3 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C3ISR_BTIF3 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C3ISR_BRTIF3 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C3ISR_CTCIF3 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C3ISR_TEIF3 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C3IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C3IFCR_CLTCIF3 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C3IFCR_CBTIF3 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C3IFCR_CBRTIF3 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C3IFCR_CCTCIF3 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C3IFCR_CTEIF3 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C3ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C3ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C3ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C3ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C3ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C3ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C3ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c3esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C3ESR & MDMA_MDMA_C3ESR_TEA) >> 0 ; }

// MDMA->MDMA_C3CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C3CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C3CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C3CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C3CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C3CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C3CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C3CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C3CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C3CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C3CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C3CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c3cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3CR = (p->MDMA_C3CR & ~MDMA_MDMA_C3CR_PL) | ((val<<6) & MDMA_MDMA_C3CR_PL); }
inline uint32_t mdma_mdma_c3cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C3CR & MDMA_MDMA_C3CR_PL) >> 6 ; }

// MDMA->MDMA_C3TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C3TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C3TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C3TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C3TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C3TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C3TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C3TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C3TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C3TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C3TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C3TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C3TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C3TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C3TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c3tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_TRGM) | ((val<<28) & MDMA_MDMA_C3TCR_TRGM); }
inline void mdma_mdma_c3tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_PAM) | ((val<<26) & MDMA_MDMA_C3TCR_PAM); }
inline void mdma_mdma_c3tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_TLEN) | ((val<<18) & MDMA_MDMA_C3TCR_TLEN); }
inline void mdma_mdma_c3tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_DBURST) | ((val<<15) & MDMA_MDMA_C3TCR_DBURST); }
inline void mdma_mdma_c3tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_SBURST) | ((val<<12) & MDMA_MDMA_C3TCR_SBURST); }
inline void mdma_mdma_c3tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C3TCR_DINCOS); }
inline void mdma_mdma_c3tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C3TCR_SINCOS); }
inline void mdma_mdma_c3tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C3TCR_DSIZE); }
inline void mdma_mdma_c3tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C3TCR_SSIZE); }
inline void mdma_mdma_c3tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_DINC) | ((val<<2) & MDMA_MDMA_C3TCR_DINC); }
inline void mdma_mdma_c3tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TCR = (p->MDMA_C3TCR & ~MDMA_MDMA_C3TCR_SINC) | ((val<<0) & MDMA_MDMA_C3TCR_SINC); }
inline uint32_t mdma_mdma_c3tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c3tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c3tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c3tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c3tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c3tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c3tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c3tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c3tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c3tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c3tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C3TCR & MDMA_MDMA_C3TCR_SINC) >> 0 ; }

// MDMA->MDMA_C3BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C3BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C3BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C3BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C3BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c3bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3BNDTR = (p->MDMA_C3BNDTR & ~MDMA_MDMA_C3BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C3BNDTR_BRC); }
inline void mdma_mdma_c3bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3BNDTR = (p->MDMA_C3BNDTR & ~MDMA_MDMA_C3BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C3BNDTR_BNDT); }
inline uint32_t mdma_mdma_c3bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C3BNDTR & MDMA_MDMA_C3BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c3bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C3BNDTR & MDMA_MDMA_C3BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C3BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C3BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C3BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c3brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3BRUR = (p->MDMA_C3BRUR & ~MDMA_MDMA_C3BRUR_DUV) | ((val<<16) & MDMA_MDMA_C3BRUR_DUV); }
inline void mdma_mdma_c3brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3BRUR = (p->MDMA_C3BRUR & ~MDMA_MDMA_C3BRUR_SUV) | ((val<<0) & MDMA_MDMA_C3BRUR_SUV); }
inline uint32_t mdma_mdma_c3brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C3BRUR & MDMA_MDMA_C3BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c3brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C3BRUR & MDMA_MDMA_C3BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C3TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C3TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C3TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C3TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c3tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C3TBR = (p->MDMA_C3TBR & ~MDMA_MDMA_C3TBR_TSEL) | ((val<<0) & MDMA_MDMA_C3TBR_TSEL); }
inline uint32_t mdma_mdma_c3tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C3TBR & MDMA_MDMA_C3TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C4ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C4ISR_CRQA4 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C4ISR_TCIF4 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C4ISR_BTIF4 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C4ISR_BRTIF4 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C4ISR_CTCIF4 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C4ISR_TEIF4 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C4IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C4IFCR_CLTCIF4 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C4IFCR_CBTIF4 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C4IFCR_CBRTIF4 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C4IFCR_CCTCIF4 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C4IFCR_CTEIF4 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C4ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C4ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C4ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C4ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C4ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C4ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C4ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c4esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C4ESR & MDMA_MDMA_C4ESR_TEA) >> 0 ; }

// MDMA->MDMA_C4CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C4CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C4CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C4CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C4CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C4CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C4CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C4CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C4CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C4CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C4CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C4CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c4cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4CR = (p->MDMA_C4CR & ~MDMA_MDMA_C4CR_PL) | ((val<<6) & MDMA_MDMA_C4CR_PL); }
inline uint32_t mdma_mdma_c4cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C4CR & MDMA_MDMA_C4CR_PL) >> 6 ; }

// MDMA->MDMA_C4TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C4TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C4TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C4TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C4TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C4TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C4TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C4TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C4TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C4TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C4TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C4TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C4TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C4TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C4TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c4tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_TRGM) | ((val<<28) & MDMA_MDMA_C4TCR_TRGM); }
inline void mdma_mdma_c4tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_PAM) | ((val<<26) & MDMA_MDMA_C4TCR_PAM); }
inline void mdma_mdma_c4tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_TLEN) | ((val<<18) & MDMA_MDMA_C4TCR_TLEN); }
inline void mdma_mdma_c4tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_DBURST) | ((val<<15) & MDMA_MDMA_C4TCR_DBURST); }
inline void mdma_mdma_c4tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_SBURST) | ((val<<12) & MDMA_MDMA_C4TCR_SBURST); }
inline void mdma_mdma_c4tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C4TCR_DINCOS); }
inline void mdma_mdma_c4tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C4TCR_SINCOS); }
inline void mdma_mdma_c4tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C4TCR_DSIZE); }
inline void mdma_mdma_c4tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C4TCR_SSIZE); }
inline void mdma_mdma_c4tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_DINC) | ((val<<2) & MDMA_MDMA_C4TCR_DINC); }
inline void mdma_mdma_c4tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TCR = (p->MDMA_C4TCR & ~MDMA_MDMA_C4TCR_SINC) | ((val<<0) & MDMA_MDMA_C4TCR_SINC); }
inline uint32_t mdma_mdma_c4tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c4tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c4tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c4tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c4tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c4tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c4tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c4tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c4tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c4tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c4tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C4TCR & MDMA_MDMA_C4TCR_SINC) >> 0 ; }

// MDMA->MDMA_C4BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C4BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C4BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C4BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C4BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c4bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4BNDTR = (p->MDMA_C4BNDTR & ~MDMA_MDMA_C4BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C4BNDTR_BRC); }
inline void mdma_mdma_c4bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4BNDTR = (p->MDMA_C4BNDTR & ~MDMA_MDMA_C4BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C4BNDTR_BNDT); }
inline uint32_t mdma_mdma_c4bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C4BNDTR & MDMA_MDMA_C4BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c4bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C4BNDTR & MDMA_MDMA_C4BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C4BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C4BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C4BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c4brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4BRUR = (p->MDMA_C4BRUR & ~MDMA_MDMA_C4BRUR_DUV) | ((val<<16) & MDMA_MDMA_C4BRUR_DUV); }
inline void mdma_mdma_c4brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4BRUR = (p->MDMA_C4BRUR & ~MDMA_MDMA_C4BRUR_SUV) | ((val<<0) & MDMA_MDMA_C4BRUR_SUV); }
inline uint32_t mdma_mdma_c4brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C4BRUR & MDMA_MDMA_C4BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c4brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C4BRUR & MDMA_MDMA_C4BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C4TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C4TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C4TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C4TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c4tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C4TBR = (p->MDMA_C4TBR & ~MDMA_MDMA_C4TBR_TSEL) | ((val<<0) & MDMA_MDMA_C4TBR_TSEL); }
inline uint32_t mdma_mdma_c4tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C4TBR & MDMA_MDMA_C4TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C5ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C5ISR_CRQA5 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C5ISR_TCIF5 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C5ISR_BTIF5 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C5ISR_BRTIF5 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C5ISR_CTCIF5 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C5ISR_TEIF5 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C5IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C5IFCR_CLTCIF5 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C5IFCR_CBTIF5 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C5IFCR_CBRTIF5 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C5IFCR_CCTCIF5 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C5IFCR_CTEIF5 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C5ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C5ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C5ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C5ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C5ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C5ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C5ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c5esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C5ESR & MDMA_MDMA_C5ESR_TEA) >> 0 ; }

// MDMA->MDMA_C5CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C5CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C5CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C5CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C5CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C5CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C5CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C5CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C5CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C5CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C5CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C5CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c5cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5CR = (p->MDMA_C5CR & ~MDMA_MDMA_C5CR_PL) | ((val<<6) & MDMA_MDMA_C5CR_PL); }
inline uint32_t mdma_mdma_c5cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C5CR & MDMA_MDMA_C5CR_PL) >> 6 ; }

// MDMA->MDMA_C5TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C5TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C5TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C5TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C5TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C5TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C5TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C5TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C5TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C5TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C5TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C5TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C5TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C5TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C5TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c5tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_TRGM) | ((val<<28) & MDMA_MDMA_C5TCR_TRGM); }
inline void mdma_mdma_c5tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_PAM) | ((val<<26) & MDMA_MDMA_C5TCR_PAM); }
inline void mdma_mdma_c5tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_TLEN) | ((val<<18) & MDMA_MDMA_C5TCR_TLEN); }
inline void mdma_mdma_c5tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_DBURST) | ((val<<15) & MDMA_MDMA_C5TCR_DBURST); }
inline void mdma_mdma_c5tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_SBURST) | ((val<<12) & MDMA_MDMA_C5TCR_SBURST); }
inline void mdma_mdma_c5tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C5TCR_DINCOS); }
inline void mdma_mdma_c5tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C5TCR_SINCOS); }
inline void mdma_mdma_c5tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C5TCR_DSIZE); }
inline void mdma_mdma_c5tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C5TCR_SSIZE); }
inline void mdma_mdma_c5tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_DINC) | ((val<<2) & MDMA_MDMA_C5TCR_DINC); }
inline void mdma_mdma_c5tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TCR = (p->MDMA_C5TCR & ~MDMA_MDMA_C5TCR_SINC) | ((val<<0) & MDMA_MDMA_C5TCR_SINC); }
inline uint32_t mdma_mdma_c5tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c5tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c5tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c5tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c5tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c5tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c5tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c5tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c5tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c5tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c5tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C5TCR & MDMA_MDMA_C5TCR_SINC) >> 0 ; }

// MDMA->MDMA_C5BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C5BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C5BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C5BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C5BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c5bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5BNDTR = (p->MDMA_C5BNDTR & ~MDMA_MDMA_C5BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C5BNDTR_BRC); }
inline void mdma_mdma_c5bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5BNDTR = (p->MDMA_C5BNDTR & ~MDMA_MDMA_C5BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C5BNDTR_BNDT); }
inline uint32_t mdma_mdma_c5bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C5BNDTR & MDMA_MDMA_C5BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c5bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C5BNDTR & MDMA_MDMA_C5BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C5BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C5BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C5BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c5brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5BRUR = (p->MDMA_C5BRUR & ~MDMA_MDMA_C5BRUR_DUV) | ((val<<16) & MDMA_MDMA_C5BRUR_DUV); }
inline void mdma_mdma_c5brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5BRUR = (p->MDMA_C5BRUR & ~MDMA_MDMA_C5BRUR_SUV) | ((val<<0) & MDMA_MDMA_C5BRUR_SUV); }
inline uint32_t mdma_mdma_c5brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C5BRUR & MDMA_MDMA_C5BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c5brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C5BRUR & MDMA_MDMA_C5BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C5TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C5TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C5TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C5TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c5tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C5TBR = (p->MDMA_C5TBR & ~MDMA_MDMA_C5TBR_TSEL) | ((val<<0) & MDMA_MDMA_C5TBR_TSEL); }
inline uint32_t mdma_mdma_c5tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C5TBR & MDMA_MDMA_C5TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C6ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C6ISR_CRQA6 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C6ISR_TCIF6 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C6ISR_BTIF6 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C6ISR_BRTIF6 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C6ISR_CTCIF6 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C6ISR_TEIF6 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C6IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C6IFCR_CLTCIF6 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C6IFCR_CBTIF6 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C6IFCR_CBRTIF6 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C6IFCR_CCTCIF6 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C6IFCR_CTEIF6 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C6ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C6ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C6ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C6ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C6ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C6ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C6ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c6esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C6ESR & MDMA_MDMA_C6ESR_TEA) >> 0 ; }

// MDMA->MDMA_C6CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C6CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C6CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C6CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C6CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C6CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C6CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C6CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C6CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C6CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C6CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C6CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c6cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6CR = (p->MDMA_C6CR & ~MDMA_MDMA_C6CR_PL) | ((val<<6) & MDMA_MDMA_C6CR_PL); }
inline uint32_t mdma_mdma_c6cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C6CR & MDMA_MDMA_C6CR_PL) >> 6 ; }

// MDMA->MDMA_C6TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C6TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C6TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C6TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C6TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C6TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C6TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C6TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C6TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C6TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C6TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C6TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C6TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C6TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C6TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c6tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_TRGM) | ((val<<28) & MDMA_MDMA_C6TCR_TRGM); }
inline void mdma_mdma_c6tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_PAM) | ((val<<26) & MDMA_MDMA_C6TCR_PAM); }
inline void mdma_mdma_c6tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_TLEN) | ((val<<18) & MDMA_MDMA_C6TCR_TLEN); }
inline void mdma_mdma_c6tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_DBURST) | ((val<<15) & MDMA_MDMA_C6TCR_DBURST); }
inline void mdma_mdma_c6tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_SBURST) | ((val<<12) & MDMA_MDMA_C6TCR_SBURST); }
inline void mdma_mdma_c6tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C6TCR_DINCOS); }
inline void mdma_mdma_c6tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C6TCR_SINCOS); }
inline void mdma_mdma_c6tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C6TCR_DSIZE); }
inline void mdma_mdma_c6tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C6TCR_SSIZE); }
inline void mdma_mdma_c6tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_DINC) | ((val<<2) & MDMA_MDMA_C6TCR_DINC); }
inline void mdma_mdma_c6tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TCR = (p->MDMA_C6TCR & ~MDMA_MDMA_C6TCR_SINC) | ((val<<0) & MDMA_MDMA_C6TCR_SINC); }
inline uint32_t mdma_mdma_c6tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c6tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c6tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c6tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c6tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c6tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c6tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c6tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c6tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c6tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c6tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C6TCR & MDMA_MDMA_C6TCR_SINC) >> 0 ; }

// MDMA->MDMA_C6BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C6BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C6BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C6BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C6BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c6bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6BNDTR = (p->MDMA_C6BNDTR & ~MDMA_MDMA_C6BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C6BNDTR_BRC); }
inline void mdma_mdma_c6bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6BNDTR = (p->MDMA_C6BNDTR & ~MDMA_MDMA_C6BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C6BNDTR_BNDT); }
inline uint32_t mdma_mdma_c6bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C6BNDTR & MDMA_MDMA_C6BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c6bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C6BNDTR & MDMA_MDMA_C6BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C6BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C6BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C6BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c6brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6BRUR = (p->MDMA_C6BRUR & ~MDMA_MDMA_C6BRUR_DUV) | ((val<<16) & MDMA_MDMA_C6BRUR_DUV); }
inline void mdma_mdma_c6brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6BRUR = (p->MDMA_C6BRUR & ~MDMA_MDMA_C6BRUR_SUV) | ((val<<0) & MDMA_MDMA_C6BRUR_SUV); }
inline uint32_t mdma_mdma_c6brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C6BRUR & MDMA_MDMA_C6BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c6brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C6BRUR & MDMA_MDMA_C6BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C6TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C6TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C6TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C6TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c6tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C6TBR = (p->MDMA_C6TBR & ~MDMA_MDMA_C6TBR_TSEL) | ((val<<0) & MDMA_MDMA_C6TBR_TSEL); }
inline uint32_t mdma_mdma_c6tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C6TBR & MDMA_MDMA_C6TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C7ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C7ISR_CRQA7 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C7ISR_TCIF7 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C7ISR_BTIF7 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C7ISR_BRTIF7 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C7ISR_CTCIF7 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C7ISR_TEIF7 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C7IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C7IFCR_CLTCIF7 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C7IFCR_CBTIF7 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C7IFCR_CBRTIF7 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C7IFCR_CCTCIF7 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C7IFCR_CTEIF7 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C7ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C7ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C7ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C7ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C7ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C7ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C7ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c7esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C7ESR & MDMA_MDMA_C7ESR_TEA) >> 0 ; }

// MDMA->MDMA_C7CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C7CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C7CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C7CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C7CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C7CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C7CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C7CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C7CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C7CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C7CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C7CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c7cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7CR = (p->MDMA_C7CR & ~MDMA_MDMA_C7CR_PL) | ((val<<6) & MDMA_MDMA_C7CR_PL); }
inline uint32_t mdma_mdma_c7cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C7CR & MDMA_MDMA_C7CR_PL) >> 6 ; }

// MDMA->MDMA_C7TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C7TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C7TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C7TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C7TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C7TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C7TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C7TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C7TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C7TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C7TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C7TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C7TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C7TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C7TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c7tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_TRGM) | ((val<<28) & MDMA_MDMA_C7TCR_TRGM); }
inline void mdma_mdma_c7tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_PAM) | ((val<<26) & MDMA_MDMA_C7TCR_PAM); }
inline void mdma_mdma_c7tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_TLEN) | ((val<<18) & MDMA_MDMA_C7TCR_TLEN); }
inline void mdma_mdma_c7tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_DBURST) | ((val<<15) & MDMA_MDMA_C7TCR_DBURST); }
inline void mdma_mdma_c7tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_SBURST) | ((val<<12) & MDMA_MDMA_C7TCR_SBURST); }
inline void mdma_mdma_c7tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C7TCR_DINCOS); }
inline void mdma_mdma_c7tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C7TCR_SINCOS); }
inline void mdma_mdma_c7tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C7TCR_DSIZE); }
inline void mdma_mdma_c7tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C7TCR_SSIZE); }
inline void mdma_mdma_c7tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_DINC) | ((val<<2) & MDMA_MDMA_C7TCR_DINC); }
inline void mdma_mdma_c7tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TCR = (p->MDMA_C7TCR & ~MDMA_MDMA_C7TCR_SINC) | ((val<<0) & MDMA_MDMA_C7TCR_SINC); }
inline uint32_t mdma_mdma_c7tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c7tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c7tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c7tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c7tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c7tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c7tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c7tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c7tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c7tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c7tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C7TCR & MDMA_MDMA_C7TCR_SINC) >> 0 ; }

// MDMA->MDMA_C7BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C7BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C7BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C7BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C7BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c7bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7BNDTR = (p->MDMA_C7BNDTR & ~MDMA_MDMA_C7BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C7BNDTR_BRC); }
inline void mdma_mdma_c7bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7BNDTR = (p->MDMA_C7BNDTR & ~MDMA_MDMA_C7BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C7BNDTR_BNDT); }
inline uint32_t mdma_mdma_c7bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C7BNDTR & MDMA_MDMA_C7BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c7bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C7BNDTR & MDMA_MDMA_C7BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C7BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C7BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C7BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c7brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7BRUR = (p->MDMA_C7BRUR & ~MDMA_MDMA_C7BRUR_DUV) | ((val<<16) & MDMA_MDMA_C7BRUR_DUV); }
inline void mdma_mdma_c7brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7BRUR = (p->MDMA_C7BRUR & ~MDMA_MDMA_C7BRUR_SUV) | ((val<<0) & MDMA_MDMA_C7BRUR_SUV); }
inline uint32_t mdma_mdma_c7brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C7BRUR & MDMA_MDMA_C7BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c7brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C7BRUR & MDMA_MDMA_C7BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C7TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C7TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C7TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C7TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c7tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C7TBR = (p->MDMA_C7TBR & ~MDMA_MDMA_C7TBR_TSEL) | ((val<<0) & MDMA_MDMA_C7TBR_TSEL); }
inline uint32_t mdma_mdma_c7tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C7TBR & MDMA_MDMA_C7TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C8ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C8ISR_CRQA8 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C8ISR_TCIF8 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C8ISR_BTIF8 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C8ISR_BRTIF8 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C8ISR_CTCIF8 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C8ISR_TEIF8 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C8IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C8IFCR_CLTCIF8 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C8IFCR_CBTIF8 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C8IFCR_CBRTIF8 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C8IFCR_CCTCIF8 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C8IFCR_CTEIF8 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C8ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C8ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C8ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C8ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C8ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C8ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C8ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c8esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C8ESR & MDMA_MDMA_C8ESR_TEA) >> 0 ; }

// MDMA->MDMA_C8CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C8CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C8CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C8CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C8CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C8CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C8CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C8CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C8CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C8CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C8CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C8CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c8cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8CR = (p->MDMA_C8CR & ~MDMA_MDMA_C8CR_PL) | ((val<<6) & MDMA_MDMA_C8CR_PL); }
inline uint32_t mdma_mdma_c8cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C8CR & MDMA_MDMA_C8CR_PL) >> 6 ; }

// MDMA->MDMA_C8TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C8TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C8TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C8TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C8TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C8TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C8TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C8TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C8TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C8TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C8TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C8TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C8TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C8TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C8TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c8tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_TRGM) | ((val<<28) & MDMA_MDMA_C8TCR_TRGM); }
inline void mdma_mdma_c8tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_PAM) | ((val<<26) & MDMA_MDMA_C8TCR_PAM); }
inline void mdma_mdma_c8tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_TLEN) | ((val<<18) & MDMA_MDMA_C8TCR_TLEN); }
inline void mdma_mdma_c8tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_DBURST) | ((val<<15) & MDMA_MDMA_C8TCR_DBURST); }
inline void mdma_mdma_c8tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_SBURST) | ((val<<12) & MDMA_MDMA_C8TCR_SBURST); }
inline void mdma_mdma_c8tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C8TCR_DINCOS); }
inline void mdma_mdma_c8tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C8TCR_SINCOS); }
inline void mdma_mdma_c8tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C8TCR_DSIZE); }
inline void mdma_mdma_c8tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C8TCR_SSIZE); }
inline void mdma_mdma_c8tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_DINC) | ((val<<2) & MDMA_MDMA_C8TCR_DINC); }
inline void mdma_mdma_c8tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TCR = (p->MDMA_C8TCR & ~MDMA_MDMA_C8TCR_SINC) | ((val<<0) & MDMA_MDMA_C8TCR_SINC); }
inline uint32_t mdma_mdma_c8tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c8tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c8tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c8tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c8tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c8tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c8tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c8tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c8tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c8tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c8tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C8TCR & MDMA_MDMA_C8TCR_SINC) >> 0 ; }

// MDMA->MDMA_C8BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C8BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C8BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C8BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C8BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c8bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8BNDTR = (p->MDMA_C8BNDTR & ~MDMA_MDMA_C8BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C8BNDTR_BRC); }
inline void mdma_mdma_c8bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8BNDTR = (p->MDMA_C8BNDTR & ~MDMA_MDMA_C8BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C8BNDTR_BNDT); }
inline uint32_t mdma_mdma_c8bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C8BNDTR & MDMA_MDMA_C8BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c8bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C8BNDTR & MDMA_MDMA_C8BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C8BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C8BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C8BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c8brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8BRUR = (p->MDMA_C8BRUR & ~MDMA_MDMA_C8BRUR_DUV) | ((val<<16) & MDMA_MDMA_C8BRUR_DUV); }
inline void mdma_mdma_c8brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8BRUR = (p->MDMA_C8BRUR & ~MDMA_MDMA_C8BRUR_SUV) | ((val<<0) & MDMA_MDMA_C8BRUR_SUV); }
inline uint32_t mdma_mdma_c8brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C8BRUR & MDMA_MDMA_C8BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c8brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C8BRUR & MDMA_MDMA_C8BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C8TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C8TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C8TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C8TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c8tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C8TBR = (p->MDMA_C8TBR & ~MDMA_MDMA_C8TBR_TSEL) | ((val<<0) & MDMA_MDMA_C8TBR_TSEL); }
inline uint32_t mdma_mdma_c8tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C8TBR & MDMA_MDMA_C8TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C9ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C9ISR_CRQA9 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C9ISR_TCIF9 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C9ISR_BTIF9 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C9ISR_BRTIF9 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C9ISR_CTCIF9 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C9ISR_TEIF9 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C9IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C9IFCR_CLTCIF9 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C9IFCR_CBTIF9 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C9IFCR_CBRTIF9 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C9IFCR_CCTCIF9 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C9IFCR_CTEIF9 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C9ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C9ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C9ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C9ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C9ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C9ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C9ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c9esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C9ESR & MDMA_MDMA_C9ESR_TEA) >> 0 ; }

// MDMA->MDMA_C9CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C9CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C9CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C9CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C9CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C9CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C9CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C9CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C9CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C9CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C9CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C9CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c9cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9CR = (p->MDMA_C9CR & ~MDMA_MDMA_C9CR_PL) | ((val<<6) & MDMA_MDMA_C9CR_PL); }
inline uint32_t mdma_mdma_c9cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C9CR & MDMA_MDMA_C9CR_PL) >> 6 ; }

// MDMA->MDMA_C9TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C9TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C9TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C9TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C9TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C9TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C9TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C9TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C9TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C9TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C9TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C9TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C9TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C9TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C9TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c9tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_TRGM) | ((val<<28) & MDMA_MDMA_C9TCR_TRGM); }
inline void mdma_mdma_c9tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_PAM) | ((val<<26) & MDMA_MDMA_C9TCR_PAM); }
inline void mdma_mdma_c9tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_TLEN) | ((val<<18) & MDMA_MDMA_C9TCR_TLEN); }
inline void mdma_mdma_c9tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_DBURST) | ((val<<15) & MDMA_MDMA_C9TCR_DBURST); }
inline void mdma_mdma_c9tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_SBURST) | ((val<<12) & MDMA_MDMA_C9TCR_SBURST); }
inline void mdma_mdma_c9tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C9TCR_DINCOS); }
inline void mdma_mdma_c9tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C9TCR_SINCOS); }
inline void mdma_mdma_c9tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C9TCR_DSIZE); }
inline void mdma_mdma_c9tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C9TCR_SSIZE); }
inline void mdma_mdma_c9tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_DINC) | ((val<<2) & MDMA_MDMA_C9TCR_DINC); }
inline void mdma_mdma_c9tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TCR = (p->MDMA_C9TCR & ~MDMA_MDMA_C9TCR_SINC) | ((val<<0) & MDMA_MDMA_C9TCR_SINC); }
inline uint32_t mdma_mdma_c9tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c9tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c9tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c9tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c9tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c9tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c9tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c9tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c9tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c9tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c9tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C9TCR & MDMA_MDMA_C9TCR_SINC) >> 0 ; }

// MDMA->MDMA_C9BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C9BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C9BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C9BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C9BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c9bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9BNDTR = (p->MDMA_C9BNDTR & ~MDMA_MDMA_C9BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C9BNDTR_BRC); }
inline void mdma_mdma_c9bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9BNDTR = (p->MDMA_C9BNDTR & ~MDMA_MDMA_C9BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C9BNDTR_BNDT); }
inline uint32_t mdma_mdma_c9bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C9BNDTR & MDMA_MDMA_C9BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c9bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C9BNDTR & MDMA_MDMA_C9BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C9BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C9BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C9BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c9brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9BRUR = (p->MDMA_C9BRUR & ~MDMA_MDMA_C9BRUR_DUV) | ((val<<16) & MDMA_MDMA_C9BRUR_DUV); }
inline void mdma_mdma_c9brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9BRUR = (p->MDMA_C9BRUR & ~MDMA_MDMA_C9BRUR_SUV) | ((val<<0) & MDMA_MDMA_C9BRUR_SUV); }
inline uint32_t mdma_mdma_c9brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C9BRUR & MDMA_MDMA_C9BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c9brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C9BRUR & MDMA_MDMA_C9BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C9TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C9TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C9TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C9TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c9tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C9TBR = (p->MDMA_C9TBR & ~MDMA_MDMA_C9TBR_TSEL) | ((val<<0) & MDMA_MDMA_C9TBR_TSEL); }
inline uint32_t mdma_mdma_c9tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C9TBR & MDMA_MDMA_C9TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C10ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C10ISR_CRQA10 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C10ISR_TCIF10 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C10ISR_BTIF10 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C10ISR_BRTIF10 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C10ISR_CTCIF10 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C10ISR_TEIF10 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C10IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C10IFCR_CLTCIF10 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C10IFCR_CBTIF10 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C10IFCR_CBRTIF10 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C10IFCR_CCTCIF10 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C10IFCR_CTEIF10 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C10ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C10ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C10ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C10ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C10ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C10ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C10ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c10esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C10ESR & MDMA_MDMA_C10ESR_TEA) >> 0 ; }

// MDMA->MDMA_C10CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C10CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C10CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C10CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C10CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C10CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C10CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C10CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C10CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C10CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C10CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C10CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c10cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10CR = (p->MDMA_C10CR & ~MDMA_MDMA_C10CR_PL) | ((val<<6) & MDMA_MDMA_C10CR_PL); }
inline uint32_t mdma_mdma_c10cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C10CR & MDMA_MDMA_C10CR_PL) >> 6 ; }

// MDMA->MDMA_C10TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C10TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C10TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C10TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C10TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C10TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C10TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C10TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C10TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C10TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C10TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C10TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C10TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C10TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C10TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c10tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_TRGM) | ((val<<28) & MDMA_MDMA_C10TCR_TRGM); }
inline void mdma_mdma_c10tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_PAM) | ((val<<26) & MDMA_MDMA_C10TCR_PAM); }
inline void mdma_mdma_c10tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_TLEN) | ((val<<18) & MDMA_MDMA_C10TCR_TLEN); }
inline void mdma_mdma_c10tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_DBURST) | ((val<<15) & MDMA_MDMA_C10TCR_DBURST); }
inline void mdma_mdma_c10tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_SBURST) | ((val<<12) & MDMA_MDMA_C10TCR_SBURST); }
inline void mdma_mdma_c10tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C10TCR_DINCOS); }
inline void mdma_mdma_c10tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C10TCR_SINCOS); }
inline void mdma_mdma_c10tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C10TCR_DSIZE); }
inline void mdma_mdma_c10tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C10TCR_SSIZE); }
inline void mdma_mdma_c10tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_DINC) | ((val<<2) & MDMA_MDMA_C10TCR_DINC); }
inline void mdma_mdma_c10tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TCR = (p->MDMA_C10TCR & ~MDMA_MDMA_C10TCR_SINC) | ((val<<0) & MDMA_MDMA_C10TCR_SINC); }
inline uint32_t mdma_mdma_c10tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c10tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c10tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c10tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c10tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c10tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c10tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c10tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c10tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c10tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c10tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C10TCR & MDMA_MDMA_C10TCR_SINC) >> 0 ; }

// MDMA->MDMA_C10BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C10BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C10BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C10BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C10BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c10bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10BNDTR = (p->MDMA_C10BNDTR & ~MDMA_MDMA_C10BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C10BNDTR_BRC); }
inline void mdma_mdma_c10bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10BNDTR = (p->MDMA_C10BNDTR & ~MDMA_MDMA_C10BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C10BNDTR_BNDT); }
inline uint32_t mdma_mdma_c10bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C10BNDTR & MDMA_MDMA_C10BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c10bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C10BNDTR & MDMA_MDMA_C10BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C10BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C10BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C10BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c10brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10BRUR = (p->MDMA_C10BRUR & ~MDMA_MDMA_C10BRUR_DUV) | ((val<<16) & MDMA_MDMA_C10BRUR_DUV); }
inline void mdma_mdma_c10brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10BRUR = (p->MDMA_C10BRUR & ~MDMA_MDMA_C10BRUR_SUV) | ((val<<0) & MDMA_MDMA_C10BRUR_SUV); }
inline uint32_t mdma_mdma_c10brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C10BRUR & MDMA_MDMA_C10BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c10brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C10BRUR & MDMA_MDMA_C10BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C10TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C10TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C10TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C10TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c10tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C10TBR = (p->MDMA_C10TBR & ~MDMA_MDMA_C10TBR_TSEL) | ((val<<0) & MDMA_MDMA_C10TBR_TSEL); }
inline uint32_t mdma_mdma_c10tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C10TBR & MDMA_MDMA_C10TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C11ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C11ISR_CRQA11 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C11ISR_TCIF11 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C11ISR_BTIF11 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C11ISR_BRTIF11 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C11ISR_CTCIF11 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C11ISR_TEIF11 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C11IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C11IFCR_CLTCIF11 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C11IFCR_CBTIF11 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C11IFCR_CBRTIF11 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C11IFCR_CCTCIF11 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C11IFCR_CTEIF11 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C11ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C11ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C11ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C11ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C11ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C11ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C11ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c11esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C11ESR & MDMA_MDMA_C11ESR_TEA) >> 0 ; }

// MDMA->MDMA_C11CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C11CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C11CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C11CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C11CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C11CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C11CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C11CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C11CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C11CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C11CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C11CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c11cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11CR = (p->MDMA_C11CR & ~MDMA_MDMA_C11CR_PL) | ((val<<6) & MDMA_MDMA_C11CR_PL); }
inline uint32_t mdma_mdma_c11cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C11CR & MDMA_MDMA_C11CR_PL) >> 6 ; }

// MDMA->MDMA_C11TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C11TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C11TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C11TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C11TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C11TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C11TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C11TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C11TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C11TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C11TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C11TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C11TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C11TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C11TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c11tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_TRGM) | ((val<<28) & MDMA_MDMA_C11TCR_TRGM); }
inline void mdma_mdma_c11tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_PAM) | ((val<<26) & MDMA_MDMA_C11TCR_PAM); }
inline void mdma_mdma_c11tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_TLEN) | ((val<<18) & MDMA_MDMA_C11TCR_TLEN); }
inline void mdma_mdma_c11tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_DBURST) | ((val<<15) & MDMA_MDMA_C11TCR_DBURST); }
inline void mdma_mdma_c11tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_SBURST) | ((val<<12) & MDMA_MDMA_C11TCR_SBURST); }
inline void mdma_mdma_c11tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C11TCR_DINCOS); }
inline void mdma_mdma_c11tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C11TCR_SINCOS); }
inline void mdma_mdma_c11tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C11TCR_DSIZE); }
inline void mdma_mdma_c11tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C11TCR_SSIZE); }
inline void mdma_mdma_c11tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_DINC) | ((val<<2) & MDMA_MDMA_C11TCR_DINC); }
inline void mdma_mdma_c11tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TCR = (p->MDMA_C11TCR & ~MDMA_MDMA_C11TCR_SINC) | ((val<<0) & MDMA_MDMA_C11TCR_SINC); }
inline uint32_t mdma_mdma_c11tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c11tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c11tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c11tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c11tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c11tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c11tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c11tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c11tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c11tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c11tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C11TCR & MDMA_MDMA_C11TCR_SINC) >> 0 ; }

// MDMA->MDMA_C11BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C11BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C11BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C11BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C11BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c11bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11BNDTR = (p->MDMA_C11BNDTR & ~MDMA_MDMA_C11BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C11BNDTR_BRC); }
inline void mdma_mdma_c11bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11BNDTR = (p->MDMA_C11BNDTR & ~MDMA_MDMA_C11BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C11BNDTR_BNDT); }
inline uint32_t mdma_mdma_c11bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C11BNDTR & MDMA_MDMA_C11BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c11bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C11BNDTR & MDMA_MDMA_C11BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C11BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C11BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C11BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c11brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11BRUR = (p->MDMA_C11BRUR & ~MDMA_MDMA_C11BRUR_DUV) | ((val<<16) & MDMA_MDMA_C11BRUR_DUV); }
inline void mdma_mdma_c11brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11BRUR = (p->MDMA_C11BRUR & ~MDMA_MDMA_C11BRUR_SUV) | ((val<<0) & MDMA_MDMA_C11BRUR_SUV); }
inline uint32_t mdma_mdma_c11brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C11BRUR & MDMA_MDMA_C11BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c11brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C11BRUR & MDMA_MDMA_C11BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C11TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C11TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C11TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C11TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c11tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C11TBR = (p->MDMA_C11TBR & ~MDMA_MDMA_C11TBR_TSEL) | ((val<<0) & MDMA_MDMA_C11TBR_TSEL); }
inline uint32_t mdma_mdma_c11tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C11TBR & MDMA_MDMA_C11TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C12ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C12ISR_CRQA12 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C12ISR_TCIF12 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C12ISR_BTIF12 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C12ISR_BRTIF12 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C12ISR_CTCIF12 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C12ISR_TEIF12 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C12IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C12IFCR_CLTCIF12 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C12IFCR_CBTIF12 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C12IFCR_CBRTIF12 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C12IFCR_CCTCIF12 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C12IFCR_CTEIF12 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C12ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C12ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C12ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C12ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C12ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C12ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C12ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c12esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C12ESR & MDMA_MDMA_C12ESR_TEA) >> 0 ; }

// MDMA->MDMA_C12CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C12CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C12CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C12CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C12CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C12CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C12CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C12CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C12CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C12CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C12CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C12CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c12cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12CR = (p->MDMA_C12CR & ~MDMA_MDMA_C12CR_PL) | ((val<<6) & MDMA_MDMA_C12CR_PL); }
inline uint32_t mdma_mdma_c12cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C12CR & MDMA_MDMA_C12CR_PL) >> 6 ; }

// MDMA->MDMA_C12TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C12TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C12TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C12TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C12TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C12TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C12TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C12TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C12TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C12TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C12TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C12TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C12TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C12TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C12TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c12tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_TRGM) | ((val<<28) & MDMA_MDMA_C12TCR_TRGM); }
inline void mdma_mdma_c12tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_PAM) | ((val<<26) & MDMA_MDMA_C12TCR_PAM); }
inline void mdma_mdma_c12tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_TLEN) | ((val<<18) & MDMA_MDMA_C12TCR_TLEN); }
inline void mdma_mdma_c12tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_DBURST) | ((val<<15) & MDMA_MDMA_C12TCR_DBURST); }
inline void mdma_mdma_c12tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_SBURST) | ((val<<12) & MDMA_MDMA_C12TCR_SBURST); }
inline void mdma_mdma_c12tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C12TCR_DINCOS); }
inline void mdma_mdma_c12tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C12TCR_SINCOS); }
inline void mdma_mdma_c12tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C12TCR_DSIZE); }
inline void mdma_mdma_c12tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C12TCR_SSIZE); }
inline void mdma_mdma_c12tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_DINC) | ((val<<2) & MDMA_MDMA_C12TCR_DINC); }
inline void mdma_mdma_c12tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TCR = (p->MDMA_C12TCR & ~MDMA_MDMA_C12TCR_SINC) | ((val<<0) & MDMA_MDMA_C12TCR_SINC); }
inline uint32_t mdma_mdma_c12tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c12tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c12tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c12tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c12tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c12tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c12tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c12tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c12tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c12tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c12tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C12TCR & MDMA_MDMA_C12TCR_SINC) >> 0 ; }

// MDMA->MDMA_C12BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C12BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C12BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C12BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C12BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c12bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12BNDTR = (p->MDMA_C12BNDTR & ~MDMA_MDMA_C12BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C12BNDTR_BRC); }
inline void mdma_mdma_c12bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12BNDTR = (p->MDMA_C12BNDTR & ~MDMA_MDMA_C12BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C12BNDTR_BNDT); }
inline uint32_t mdma_mdma_c12bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C12BNDTR & MDMA_MDMA_C12BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c12bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C12BNDTR & MDMA_MDMA_C12BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C12BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C12BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C12BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c12brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12BRUR = (p->MDMA_C12BRUR & ~MDMA_MDMA_C12BRUR_DUV) | ((val<<16) & MDMA_MDMA_C12BRUR_DUV); }
inline void mdma_mdma_c12brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12BRUR = (p->MDMA_C12BRUR & ~MDMA_MDMA_C12BRUR_SUV) | ((val<<0) & MDMA_MDMA_C12BRUR_SUV); }
inline uint32_t mdma_mdma_c12brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C12BRUR & MDMA_MDMA_C12BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c12brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C12BRUR & MDMA_MDMA_C12BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C12TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C12TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C12TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C12TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c12tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C12TBR = (p->MDMA_C12TBR & ~MDMA_MDMA_C12TBR_TSEL) | ((val<<0) & MDMA_MDMA_C12TBR_TSEL); }
inline uint32_t mdma_mdma_c12tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C12TBR & MDMA_MDMA_C12TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C13ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C13ISR_CRQA13 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C13ISR_TCIF13 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C13ISR_BTIF13 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C13ISR_BRTIF13 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C13ISR_CTCIF13 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C13ISR_TEIF13 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C13IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C13IFCR_CLTCIF13 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C13IFCR_CBTIF13 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C13IFCR_CBRTIF13 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C13IFCR_CCTCIF13 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C13IFCR_CTEIF13 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C13ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C13ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C13ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C13ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C13ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C13ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C13ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c13esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C13ESR & MDMA_MDMA_C13ESR_TEA) >> 0 ; }

// MDMA->MDMA_C13CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C13CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C13CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C13CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C13CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C13CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C13CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C13CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C13CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C13CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C13CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C13CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c13cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13CR = (p->MDMA_C13CR & ~MDMA_MDMA_C13CR_PL) | ((val<<6) & MDMA_MDMA_C13CR_PL); }
inline uint32_t mdma_mdma_c13cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C13CR & MDMA_MDMA_C13CR_PL) >> 6 ; }

// MDMA->MDMA_C13TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C13TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C13TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C13TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C13TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C13TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C13TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C13TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C13TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C13TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C13TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C13TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C13TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C13TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C13TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c13tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_TRGM) | ((val<<28) & MDMA_MDMA_C13TCR_TRGM); }
inline void mdma_mdma_c13tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_PAM) | ((val<<26) & MDMA_MDMA_C13TCR_PAM); }
inline void mdma_mdma_c13tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_TLEN) | ((val<<18) & MDMA_MDMA_C13TCR_TLEN); }
inline void mdma_mdma_c13tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_DBURST) | ((val<<15) & MDMA_MDMA_C13TCR_DBURST); }
inline void mdma_mdma_c13tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_SBURST) | ((val<<12) & MDMA_MDMA_C13TCR_SBURST); }
inline void mdma_mdma_c13tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C13TCR_DINCOS); }
inline void mdma_mdma_c13tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C13TCR_SINCOS); }
inline void mdma_mdma_c13tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C13TCR_DSIZE); }
inline void mdma_mdma_c13tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C13TCR_SSIZE); }
inline void mdma_mdma_c13tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_DINC) | ((val<<2) & MDMA_MDMA_C13TCR_DINC); }
inline void mdma_mdma_c13tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TCR = (p->MDMA_C13TCR & ~MDMA_MDMA_C13TCR_SINC) | ((val<<0) & MDMA_MDMA_C13TCR_SINC); }
inline uint32_t mdma_mdma_c13tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c13tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c13tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c13tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c13tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c13tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c13tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c13tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c13tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c13tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c13tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C13TCR & MDMA_MDMA_C13TCR_SINC) >> 0 ; }

// MDMA->MDMA_C13BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C13BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C13BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C13BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C13BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c13bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13BNDTR = (p->MDMA_C13BNDTR & ~MDMA_MDMA_C13BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C13BNDTR_BRC); }
inline void mdma_mdma_c13bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13BNDTR = (p->MDMA_C13BNDTR & ~MDMA_MDMA_C13BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C13BNDTR_BNDT); }
inline uint32_t mdma_mdma_c13bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C13BNDTR & MDMA_MDMA_C13BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c13bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C13BNDTR & MDMA_MDMA_C13BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C13BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C13BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C13BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c13brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13BRUR = (p->MDMA_C13BRUR & ~MDMA_MDMA_C13BRUR_DUV) | ((val<<16) & MDMA_MDMA_C13BRUR_DUV); }
inline void mdma_mdma_c13brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13BRUR = (p->MDMA_C13BRUR & ~MDMA_MDMA_C13BRUR_SUV) | ((val<<0) & MDMA_MDMA_C13BRUR_SUV); }
inline uint32_t mdma_mdma_c13brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C13BRUR & MDMA_MDMA_C13BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c13brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C13BRUR & MDMA_MDMA_C13BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C13TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C13TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C13TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C13TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c13tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C13TBR = (p->MDMA_C13TBR & ~MDMA_MDMA_C13TBR_TSEL) | ((val<<0) & MDMA_MDMA_C13TBR_TSEL); }
inline uint32_t mdma_mdma_c13tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C13TBR & MDMA_MDMA_C13TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C14ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C14ISR_CRQA14 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C14ISR_TCIF14 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C14ISR_BTIF14 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C14ISR_BRTIF14 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C14ISR_CTCIF14 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C14ISR_TEIF14 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C14IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C14IFCR_CLTCIF14 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C14IFCR_CBTIF14 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C14IFCR_CBRTIF14 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C14IFCR_CCTCIF14 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C14IFCR_CTEIF14 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C14ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C14ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C14ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C14ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C14ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C14ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C14ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c14esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C14ESR & MDMA_MDMA_C14ESR_TEA) >> 0 ; }

// MDMA->MDMA_C14CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C14CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C14CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C14CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C14CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C14CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C14CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C14CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C14CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C14CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C14CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C14CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c14cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14CR = (p->MDMA_C14CR & ~MDMA_MDMA_C14CR_PL) | ((val<<6) & MDMA_MDMA_C14CR_PL); }
inline uint32_t mdma_mdma_c14cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C14CR & MDMA_MDMA_C14CR_PL) >> 6 ; }

// MDMA->MDMA_C14TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C14TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C14TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C14TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C14TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C14TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C14TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C14TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C14TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C14TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C14TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C14TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C14TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C14TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C14TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c14tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_TRGM) | ((val<<28) & MDMA_MDMA_C14TCR_TRGM); }
inline void mdma_mdma_c14tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_PAM) | ((val<<26) & MDMA_MDMA_C14TCR_PAM); }
inline void mdma_mdma_c14tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_TLEN) | ((val<<18) & MDMA_MDMA_C14TCR_TLEN); }
inline void mdma_mdma_c14tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_DBURST) | ((val<<15) & MDMA_MDMA_C14TCR_DBURST); }
inline void mdma_mdma_c14tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_SBURST) | ((val<<12) & MDMA_MDMA_C14TCR_SBURST); }
inline void mdma_mdma_c14tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C14TCR_DINCOS); }
inline void mdma_mdma_c14tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C14TCR_SINCOS); }
inline void mdma_mdma_c14tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C14TCR_DSIZE); }
inline void mdma_mdma_c14tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C14TCR_SSIZE); }
inline void mdma_mdma_c14tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_DINC) | ((val<<2) & MDMA_MDMA_C14TCR_DINC); }
inline void mdma_mdma_c14tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TCR = (p->MDMA_C14TCR & ~MDMA_MDMA_C14TCR_SINC) | ((val<<0) & MDMA_MDMA_C14TCR_SINC); }
inline uint32_t mdma_mdma_c14tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c14tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c14tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c14tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c14tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c14tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c14tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c14tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c14tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c14tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c14tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C14TCR & MDMA_MDMA_C14TCR_SINC) >> 0 ; }

// MDMA->MDMA_C14BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C14BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C14BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C14BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C14BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c14bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14BNDTR = (p->MDMA_C14BNDTR & ~MDMA_MDMA_C14BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C14BNDTR_BRC); }
inline void mdma_mdma_c14bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14BNDTR = (p->MDMA_C14BNDTR & ~MDMA_MDMA_C14BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C14BNDTR_BNDT); }
inline uint32_t mdma_mdma_c14bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C14BNDTR & MDMA_MDMA_C14BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c14bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C14BNDTR & MDMA_MDMA_C14BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C14BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C14BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C14BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c14brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14BRUR = (p->MDMA_C14BRUR & ~MDMA_MDMA_C14BRUR_DUV) | ((val<<16) & MDMA_MDMA_C14BRUR_DUV); }
inline void mdma_mdma_c14brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14BRUR = (p->MDMA_C14BRUR & ~MDMA_MDMA_C14BRUR_SUV) | ((val<<0) & MDMA_MDMA_C14BRUR_SUV); }
inline uint32_t mdma_mdma_c14brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C14BRUR & MDMA_MDMA_C14BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c14brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C14BRUR & MDMA_MDMA_C14BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C14TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C14TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C14TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C14TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c14tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C14TBR = (p->MDMA_C14TBR & ~MDMA_MDMA_C14TBR_TSEL) | ((val<<0) & MDMA_MDMA_C14TBR_TSEL); }
inline uint32_t mdma_mdma_c14tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C14TBR & MDMA_MDMA_C14TBR_TSEL) >> 0 ; }

// MDMA->MDMA_C15ISR MDMA channel x interrupt/status register
enum {
	MDMA_MDMA_C15ISR_CRQA15 = 1UL<<16, // channel x request active flag
	MDMA_MDMA_C15ISR_TCIF15 = 1UL<<4, // channel x buffer transfer complete
	MDMA_MDMA_C15ISR_BTIF15 = 1UL<<3, // Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C15ISR_BRTIF15 = 1UL<<2, // Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
	MDMA_MDMA_C15ISR_CTCIF15 = 1UL<<1, // Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
	MDMA_MDMA_C15ISR_TEIF15 = 1UL<<0, // Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.		
};

// MDMA->MDMA_C15IFCR MDMA channel x interrupt flag clear register
enum {
	MDMA_MDMA_C15IFCR_CLTCIF15 = 1UL<<4, // CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
	MDMA_MDMA_C15IFCR_CBTIF15 = 1UL<<3, // Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
	MDMA_MDMA_C15IFCR_CBRTIF15 = 1UL<<2, // Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
	MDMA_MDMA_C15IFCR_CCTCIF15 = 1UL<<1, // Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
	MDMA_MDMA_C15IFCR_CTEIF15 = 1UL<<0, // Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register		
};

// MDMA->MDMA_C15ESR MDMA Channel x error status register
enum {
	MDMA_MDMA_C15ESR_BSE = 1UL<<11, // Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C15ESR_ASE = 1UL<<10, // Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C15ESR_TEMD = 1UL<<9, // Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C15ESR_TELD = 1UL<<8, // Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
	MDMA_MDMA_C15ESR_TED = 1UL<<7, // Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
	MDMA_MDMA_C15ESR_TEA = ((1UL<<7)-1) << 0, // Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.		
};
inline uint32_t mdma_mdma_c15esr_get_tea(struct MDMA_Type* p) { return (p->MDMA_C15ESR & MDMA_MDMA_C15ESR_TEA) >> 0 ; }

// MDMA->MDMA_C15CR This register is used to control the concerned channel.
enum {
	MDMA_MDMA_C15CR_SWRQ = 1UL<<16, // SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
	MDMA_MDMA_C15CR_WEX = 1UL<<14, // Word Endianness exchange
	MDMA_MDMA_C15CR_HEX = 1UL<<13, // Half word Endianes exchange
	MDMA_MDMA_C15CR_BEX = 1UL<<12, // byte Endianness exchange
	MDMA_MDMA_C15CR_PL = ((1UL<<2)-1) << 6, // Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C15CR_TCIE = 1UL<<5, // buffer Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C15CR_BTIE = 1UL<<4, // Block Transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C15CR_BRTIE = 1UL<<3, // Block Repeat transfer interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C15CR_CTCIE = 1UL<<2, // Channel Transfer Complete interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C15CR_TEIE = 1UL<<1, // Transfer error interrupt enable This bit is set and cleared by software.
	MDMA_MDMA_C15CR_EN = 1UL<<0, // channel enable		
};
inline void mdma_mdma_c15cr_set_pl(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15CR = (p->MDMA_C15CR & ~MDMA_MDMA_C15CR_PL) | ((val<<6) & MDMA_MDMA_C15CR_PL); }
inline uint32_t mdma_mdma_c15cr_get_pl(struct MDMA_Type* p) { return (p->MDMA_C15CR & MDMA_MDMA_C15CR_PL) >> 6 ; }

// MDMA->MDMA_C15TCR This register is used to configure the concerned channel.
enum {
	MDMA_MDMA_C15TCR_BWM = 1UL<<31, // Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
	MDMA_MDMA_C15TCR_SWRM = 1UL<<30, // SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C15TCR_TRGM = ((1UL<<2)-1) << 28, // Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C15TCR_PAM = ((1UL<<2)-1) << 26, // Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
	MDMA_MDMA_C15TCR_PKE = 1UL<<25, // PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
	MDMA_MDMA_C15TCR_TLEN = ((1UL<<7)-1) << 18, // buffer transfer lengh
	MDMA_MDMA_C15TCR_DBURST = ((1UL<<3)-1) << 15, // Destination burst transfer configuration
	MDMA_MDMA_C15TCR_SBURST = ((1UL<<3)-1) << 12, // source burst transfer configuration
	MDMA_MDMA_C15TCR_DINCOS = ((1UL<<2)-1) << 10, // Destination increment offset
	MDMA_MDMA_C15TCR_SINCOS = ((1UL<<2)-1) << 8, // source increment offset size
	MDMA_MDMA_C15TCR_DSIZE = ((1UL<<2)-1) << 6, // Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
	MDMA_MDMA_C15TCR_SSIZE = ((1UL<<2)-1) << 4, // Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
	MDMA_MDMA_C15TCR_DINC = ((1UL<<2)-1) << 2, // Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
	MDMA_MDMA_C15TCR_SINC = ((1UL<<2)-1) << 0, // Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).		
};
inline void mdma_mdma_c15tcr_set_trgm(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_TRGM) | ((val<<28) & MDMA_MDMA_C15TCR_TRGM); }
inline void mdma_mdma_c15tcr_set_pam(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_PAM) | ((val<<26) & MDMA_MDMA_C15TCR_PAM); }
inline void mdma_mdma_c15tcr_set_tlen(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_TLEN) | ((val<<18) & MDMA_MDMA_C15TCR_TLEN); }
inline void mdma_mdma_c15tcr_set_dburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_DBURST) | ((val<<15) & MDMA_MDMA_C15TCR_DBURST); }
inline void mdma_mdma_c15tcr_set_sburst(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_SBURST) | ((val<<12) & MDMA_MDMA_C15TCR_SBURST); }
inline void mdma_mdma_c15tcr_set_dincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_DINCOS) | ((val<<10) & MDMA_MDMA_C15TCR_DINCOS); }
inline void mdma_mdma_c15tcr_set_sincos(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_SINCOS) | ((val<<8) & MDMA_MDMA_C15TCR_SINCOS); }
inline void mdma_mdma_c15tcr_set_dsize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_DSIZE) | ((val<<6) & MDMA_MDMA_C15TCR_DSIZE); }
inline void mdma_mdma_c15tcr_set_ssize(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_SSIZE) | ((val<<4) & MDMA_MDMA_C15TCR_SSIZE); }
inline void mdma_mdma_c15tcr_set_dinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_DINC) | ((val<<2) & MDMA_MDMA_C15TCR_DINC); }
inline void mdma_mdma_c15tcr_set_sinc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TCR = (p->MDMA_C15TCR & ~MDMA_MDMA_C15TCR_SINC) | ((val<<0) & MDMA_MDMA_C15TCR_SINC); }
inline uint32_t mdma_mdma_c15tcr_get_trgm(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_TRGM) >> 28 ; }
inline uint32_t mdma_mdma_c15tcr_get_pam(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_PAM) >> 26 ; }
inline uint32_t mdma_mdma_c15tcr_get_tlen(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_TLEN) >> 18 ; }
inline uint32_t mdma_mdma_c15tcr_get_dburst(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_DBURST) >> 15 ; }
inline uint32_t mdma_mdma_c15tcr_get_sburst(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_SBURST) >> 12 ; }
inline uint32_t mdma_mdma_c15tcr_get_dincos(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_DINCOS) >> 10 ; }
inline uint32_t mdma_mdma_c15tcr_get_sincos(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_SINCOS) >> 8 ; }
inline uint32_t mdma_mdma_c15tcr_get_dsize(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_DSIZE) >> 6 ; }
inline uint32_t mdma_mdma_c15tcr_get_ssize(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_SSIZE) >> 4 ; }
inline uint32_t mdma_mdma_c15tcr_get_dinc(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_DINC) >> 2 ; }
inline uint32_t mdma_mdma_c15tcr_get_sinc(struct MDMA_Type* p) { return (p->MDMA_C15TCR & MDMA_MDMA_C15TCR_SINC) >> 0 ; }

// MDMA->MDMA_C15BNDTR MDMA Channel x block number of data register
enum {
	MDMA_MDMA_C15BNDTR_BRC = ((1UL<<12)-1) << 20, // Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C15BNDTR_BRDUM = 1UL<<19, // Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C15BNDTR_BRSUM = 1UL<<18, // Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
	MDMA_MDMA_C15BNDTR_BNDT = ((1UL<<17)-1) << 0, // block number of data to transfer		
};
inline void mdma_mdma_c15bndtr_set_brc(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15BNDTR = (p->MDMA_C15BNDTR & ~MDMA_MDMA_C15BNDTR_BRC) | ((val<<20) & MDMA_MDMA_C15BNDTR_BRC); }
inline void mdma_mdma_c15bndtr_set_bndt(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15BNDTR = (p->MDMA_C15BNDTR & ~MDMA_MDMA_C15BNDTR_BNDT) | ((val<<0) & MDMA_MDMA_C15BNDTR_BNDT); }
inline uint32_t mdma_mdma_c15bndtr_get_brc(struct MDMA_Type* p) { return (p->MDMA_C15BNDTR & MDMA_MDMA_C15BNDTR_BRC) >> 20 ; }
inline uint32_t mdma_mdma_c15bndtr_get_bndt(struct MDMA_Type* p) { return (p->MDMA_C15BNDTR & MDMA_MDMA_C15BNDTR_BNDT) >> 0 ; }

// MDMA->MDMA_C15BRUR MDMA channel x Block Repeat address Update register
enum {
	MDMA_MDMA_C15BRUR_DUV = ((1UL<<16)-1) << 16, // destination address update
	MDMA_MDMA_C15BRUR_SUV = ((1UL<<16)-1) << 0, // source adresse update value		
};
inline void mdma_mdma_c15brur_set_duv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15BRUR = (p->MDMA_C15BRUR & ~MDMA_MDMA_C15BRUR_DUV) | ((val<<16) & MDMA_MDMA_C15BRUR_DUV); }
inline void mdma_mdma_c15brur_set_suv(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15BRUR = (p->MDMA_C15BRUR & ~MDMA_MDMA_C15BRUR_SUV) | ((val<<0) & MDMA_MDMA_C15BRUR_SUV); }
inline uint32_t mdma_mdma_c15brur_get_duv(struct MDMA_Type* p) { return (p->MDMA_C15BRUR & MDMA_MDMA_C15BRUR_DUV) >> 16 ; }
inline uint32_t mdma_mdma_c15brur_get_suv(struct MDMA_Type* p) { return (p->MDMA_C15BRUR & MDMA_MDMA_C15BRUR_SUV) >> 0 ; }

// MDMA->MDMA_C15TBR MDMA channel x Trigger and Bus selection Register
enum {
	MDMA_MDMA_C15TBR_DBUS = 1UL<<17, // Destination BUS slect This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C15TBR_SBUS = 1UL<<16, // Source BUS select This bit is protected and can be written only if EN is 0.
	MDMA_MDMA_C15TBR_TSEL = ((1UL<<6)-1) << 0, // Trigger selection		
};
inline void mdma_mdma_c15tbr_set_tsel(struct MDMA_Type* p, uint32_t val) { p->MDMA_C15TBR = (p->MDMA_C15TBR & ~MDMA_MDMA_C15TBR_TSEL) | ((val<<0) & MDMA_MDMA_C15TBR_TSEL); }
inline uint32_t mdma_mdma_c15tbr_get_tsel(struct MDMA_Type* p) { return (p->MDMA_C15TBR & MDMA_MDMA_C15TBR_TSEL) >> 0 ; }

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t MPU_TYPER; // @0 MPU type register
	__I uint8_t MPU_CTRL; // @4 MPU control register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t MPU_RNR; // @8 MPU region number register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t MPU_RBAR; // @12 MPU region base address register
	__IO uint32_t MPU_RASR; // @16 MPU region attribute and size register
};

// MPU->MPU_TYPER MPU type register
enum {
	MPU_MPU_TYPER_IREGION = ((1UL<<8)-1) << 16, // Number of MPU instruction regions
	MPU_MPU_TYPER_DREGION = ((1UL<<8)-1) << 8, // Number of MPU data regions
	MPU_MPU_TYPER_SEPARATE = 1UL<<0, // Separate flag		
};
inline uint32_t mpu_mpu_typer_get_iregion(struct MPU_Type* p) { return (p->MPU_TYPER & MPU_MPU_TYPER_IREGION) >> 16 ; }
inline uint32_t mpu_mpu_typer_get_dregion(struct MPU_Type* p) { return (p->MPU_TYPER & MPU_MPU_TYPER_DREGION) >> 8 ; }

// MPU->MPU_CTRL MPU control register
enum {
	MPU_MPU_CTRL_PRIVDEFENA = 1UL<<2, // Enable priviliged software access to default memory map
	MPU_MPU_CTRL_HFNMIENA = 1UL<<1, // Enables the operation of MPU during hard fault
	MPU_MPU_CTRL_ENABLE = 1UL<<0, // Enables the MPU		
};

// MPU->MPU_RBAR MPU region base address register
enum {
	MPU_MPU_RBAR_ADDR = ((1UL<<27)-1) << 5, // Region base address field
	MPU_MPU_RBAR_VALID = 1UL<<4, // MPU region number valid
	MPU_MPU_RBAR_REGION = ((1UL<<4)-1) << 0, // MPU region field		
};
inline void mpu_mpu_rbar_set_addr(struct MPU_Type* p, uint32_t val) { p->MPU_RBAR = (p->MPU_RBAR & ~MPU_MPU_RBAR_ADDR) | ((val<<5) & MPU_MPU_RBAR_ADDR); }
inline void mpu_mpu_rbar_set_region(struct MPU_Type* p, uint32_t val) { p->MPU_RBAR = (p->MPU_RBAR & ~MPU_MPU_RBAR_REGION) | ((val<<0) & MPU_MPU_RBAR_REGION); }
inline uint32_t mpu_mpu_rbar_get_addr(struct MPU_Type* p) { return (p->MPU_RBAR & MPU_MPU_RBAR_ADDR) >> 5 ; }
inline uint32_t mpu_mpu_rbar_get_region(struct MPU_Type* p) { return (p->MPU_RBAR & MPU_MPU_RBAR_REGION) >> 0 ; }

// MPU->MPU_RASR MPU region attribute and size register
enum {
	MPU_MPU_RASR_XN = 1UL<<28, // Instruction access disable bit
	MPU_MPU_RASR_AP = ((1UL<<3)-1) << 24, // Access permission
	MPU_MPU_RASR_TEX = ((1UL<<3)-1) << 19, // memory attribute
	MPU_MPU_RASR_S = 1UL<<18, // Shareable memory attribute
	MPU_MPU_RASR_C = 1UL<<17, // memory attribute
	MPU_MPU_RASR_B = 1UL<<16, // memory attribute
	MPU_MPU_RASR_SRD = ((1UL<<8)-1) << 8, // Subregion disable bits
	MPU_MPU_RASR_SIZE = ((1UL<<5)-1) << 1, // Size of the MPU protection region
	MPU_MPU_RASR_ENABLE = 1UL<<0, // Region enable bit.		
};
inline void mpu_mpu_rasr_set_ap(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_AP) | ((val<<24) & MPU_MPU_RASR_AP); }
inline void mpu_mpu_rasr_set_tex(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_TEX) | ((val<<19) & MPU_MPU_RASR_TEX); }
inline void mpu_mpu_rasr_set_srd(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_SRD) | ((val<<8) & MPU_MPU_RASR_SRD); }
inline void mpu_mpu_rasr_set_size(struct MPU_Type* p, uint32_t val) { p->MPU_RASR = (p->MPU_RASR & ~MPU_MPU_RASR_SIZE) | ((val<<1) & MPU_MPU_RASR_SIZE); }
inline uint32_t mpu_mpu_rasr_get_ap(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_AP) >> 24 ; }
inline uint32_t mpu_mpu_rasr_get_tex(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_TEX) >> 19 ; }
inline uint32_t mpu_mpu_rasr_get_srd(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_SRD) >> 8 ; }
inline uint32_t mpu_mpu_rasr_get_size(struct MPU_Type* p) { return (p->MPU_RASR & MPU_MPU_RASR_SIZE) >> 1 ; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER0; // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1; // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2; // @8 Interrupt Set-Enable Register
	__IO uint32_t ISER3; // @12 Interrupt Set-Enable Register
	 uint8_t RESERVED0[112]; // @16 
	__IO uint32_t ICER0; // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1; // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2; // @136 Interrupt Clear-Enable Register
	__IO uint32_t ICER3; // @140 Interrupt Clear-Enable Register
	 uint8_t RESERVED1[112]; // @144 
	__IO uint32_t ISPR0; // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1; // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2; // @264 Interrupt Set-Pending Register
	__IO uint32_t ISPR3; // @268 Interrupt Set-Pending Register
	 uint8_t RESERVED2[112]; // @272 
	__IO uint32_t ICPR0; // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1; // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2; // @392 Interrupt Clear-Pending Register
	 uint8_t RESERVED3[52]; // @396 
	__IO uint32_t ICPR3; // @448 Interrupt Clear-Pending Register
	 uint8_t RESERVED4[60]; // @452 
	__I uint32_t IABR0; // @512 Interrupt Active Bit Register
	__I uint32_t IABR1; // @516 Interrupt Active Bit Register
	__I uint32_t IABR2; // @520 Interrupt Active Bit Register
	__IO uint32_t IABR3; // @524 Interrupt Active Bit Register
	 uint8_t RESERVED5[240]; // @528 
	__IO uint32_t IPR0; // @768 Interrupt Priority Register
	__IO uint32_t IPR1; // @772 Interrupt Priority Register
	__IO uint32_t IPR2; // @776 Interrupt Priority Register
	__IO uint32_t IPR3; // @780 Interrupt Priority Register
	__IO uint32_t IPR4; // @784 Interrupt Priority Register
	__IO uint32_t IPR5; // @788 Interrupt Priority Register
	__IO uint32_t IPR6; // @792 Interrupt Priority Register
	__IO uint32_t IPR7; // @796 Interrupt Priority Register
	__IO uint32_t IPR8; // @800 Interrupt Priority Register
	__IO uint32_t IPR9; // @804 Interrupt Priority Register
	__IO uint32_t IPR10; // @808 Interrupt Priority Register
	__IO uint32_t IPR11; // @812 Interrupt Priority Register
	__IO uint32_t IPR12; // @816 Interrupt Priority Register
	__IO uint32_t IPR13; // @820 Interrupt Priority Register
	__IO uint32_t IPR14; // @824 Interrupt Priority Register
	__IO uint32_t IPR15; // @828 Interrupt Priority Register
	__IO uint32_t IPR16; // @832 Interrupt Priority Register
	__IO uint32_t IPR17; // @836 Interrupt Priority Register
	__IO uint32_t IPR18; // @840 Interrupt Priority Register
	__IO uint32_t IPR19; // @844 Interrupt Priority Register
	__IO uint32_t IPR20; // @848 Interrupt Priority Register
	__IO uint32_t IPR21; // @852 Interrupt Priority Register
	__IO uint32_t IPR22; // @856 Interrupt Priority Register
	__IO uint32_t IPR23; // @860 Interrupt Priority Register
	__IO uint32_t IPR24; // @864 Interrupt Priority Register
	__IO uint32_t IPR25; // @868 Interrupt Priority Register
	__IO uint32_t IPR26; // @872 Interrupt Priority Register
	__IO uint32_t IPR27; // @876 Interrupt Priority Register
	__IO uint32_t IPR28; // @880 Interrupt Priority Register
	__IO uint32_t IPR29; // @884 Interrupt Priority Register
	__IO uint32_t IPR30; // @888 Interrupt Priority Register
	__IO uint32_t IPR31; // @892 Interrupt Priority Register
	__IO uint32_t IPR32; // @896 Interrupt Priority Register
	__IO uint32_t IPR33; // @900 Interrupt Priority Register
	__IO uint32_t IPR34; // @904 Interrupt Priority Register
	__IO uint32_t IPR35; // @908 Interrupt Priority Register
	__IO uint32_t IPR36; // @912 Interrupt Priority Register
	__IO uint32_t IPR37; // @916 Interrupt Priority Register
	__IO uint32_t IPR38; // @920 Interrupt Priority Register
};

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr0_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N3) | ((val<<24) & NVIC_IPR0_IPR_N3); }
inline void nvic_ipr0_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N2) | ((val<<16) & NVIC_IPR0_IPR_N2); }
inline void nvic_ipr0_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N1) | ((val<<8) & NVIC_IPR0_IPR_N1); }
inline void nvic_ipr0_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N0) | ((val<<0) & NVIC_IPR0_IPR_N0); }
inline uint32_t nvic_ipr0_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr0_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr0_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr0_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N0) >> 0 ; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr1_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N3) | ((val<<24) & NVIC_IPR1_IPR_N3); }
inline void nvic_ipr1_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N2) | ((val<<16) & NVIC_IPR1_IPR_N2); }
inline void nvic_ipr1_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N1) | ((val<<8) & NVIC_IPR1_IPR_N1); }
inline void nvic_ipr1_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N0) | ((val<<0) & NVIC_IPR1_IPR_N0); }
inline uint32_t nvic_ipr1_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr1_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr1_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr1_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N0) >> 0 ; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr2_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N3) | ((val<<24) & NVIC_IPR2_IPR_N3); }
inline void nvic_ipr2_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N2) | ((val<<16) & NVIC_IPR2_IPR_N2); }
inline void nvic_ipr2_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N1) | ((val<<8) & NVIC_IPR2_IPR_N1); }
inline void nvic_ipr2_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N0) | ((val<<0) & NVIC_IPR2_IPR_N0); }
inline uint32_t nvic_ipr2_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr2_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr2_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr2_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N0) >> 0 ; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr3_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N3) | ((val<<24) & NVIC_IPR3_IPR_N3); }
inline void nvic_ipr3_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N2) | ((val<<16) & NVIC_IPR3_IPR_N2); }
inline void nvic_ipr3_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N1) | ((val<<8) & NVIC_IPR3_IPR_N1); }
inline void nvic_ipr3_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N0) | ((val<<0) & NVIC_IPR3_IPR_N0); }
inline uint32_t nvic_ipr3_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr3_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr3_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr3_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N0) >> 0 ; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr4_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N3) | ((val<<24) & NVIC_IPR4_IPR_N3); }
inline void nvic_ipr4_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N2) | ((val<<16) & NVIC_IPR4_IPR_N2); }
inline void nvic_ipr4_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N1) | ((val<<8) & NVIC_IPR4_IPR_N1); }
inline void nvic_ipr4_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N0) | ((val<<0) & NVIC_IPR4_IPR_N0); }
inline uint32_t nvic_ipr4_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr4_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr4_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr4_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N0) >> 0 ; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr5_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N3) | ((val<<24) & NVIC_IPR5_IPR_N3); }
inline void nvic_ipr5_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N2) | ((val<<16) & NVIC_IPR5_IPR_N2); }
inline void nvic_ipr5_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N1) | ((val<<8) & NVIC_IPR5_IPR_N1); }
inline void nvic_ipr5_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N0) | ((val<<0) & NVIC_IPR5_IPR_N0); }
inline uint32_t nvic_ipr5_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr5_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr5_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr5_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N0) >> 0 ; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr6_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N3) | ((val<<24) & NVIC_IPR6_IPR_N3); }
inline void nvic_ipr6_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N2) | ((val<<16) & NVIC_IPR6_IPR_N2); }
inline void nvic_ipr6_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N1) | ((val<<8) & NVIC_IPR6_IPR_N1); }
inline void nvic_ipr6_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N0) | ((val<<0) & NVIC_IPR6_IPR_N0); }
inline uint32_t nvic_ipr6_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr6_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr6_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr6_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N0) >> 0 ; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr7_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N3) | ((val<<24) & NVIC_IPR7_IPR_N3); }
inline void nvic_ipr7_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N2) | ((val<<16) & NVIC_IPR7_IPR_N2); }
inline void nvic_ipr7_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N1) | ((val<<8) & NVIC_IPR7_IPR_N1); }
inline void nvic_ipr7_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N0) | ((val<<0) & NVIC_IPR7_IPR_N0); }
inline uint32_t nvic_ipr7_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr7_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr7_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr7_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N0) >> 0 ; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr8_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N3) | ((val<<24) & NVIC_IPR8_IPR_N3); }
inline void nvic_ipr8_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N2) | ((val<<16) & NVIC_IPR8_IPR_N2); }
inline void nvic_ipr8_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N1) | ((val<<8) & NVIC_IPR8_IPR_N1); }
inline void nvic_ipr8_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N0) | ((val<<0) & NVIC_IPR8_IPR_N0); }
inline uint32_t nvic_ipr8_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr8_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr8_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr8_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N0) >> 0 ; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr9_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N3) | ((val<<24) & NVIC_IPR9_IPR_N3); }
inline void nvic_ipr9_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N2) | ((val<<16) & NVIC_IPR9_IPR_N2); }
inline void nvic_ipr9_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N1) | ((val<<8) & NVIC_IPR9_IPR_N1); }
inline void nvic_ipr9_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N0) | ((val<<0) & NVIC_IPR9_IPR_N0); }
inline uint32_t nvic_ipr9_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr9_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr9_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr9_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N0) >> 0 ; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr10_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N3) | ((val<<24) & NVIC_IPR10_IPR_N3); }
inline void nvic_ipr10_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N2) | ((val<<16) & NVIC_IPR10_IPR_N2); }
inline void nvic_ipr10_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N1) | ((val<<8) & NVIC_IPR10_IPR_N1); }
inline void nvic_ipr10_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N0) | ((val<<0) & NVIC_IPR10_IPR_N0); }
inline uint32_t nvic_ipr10_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr10_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr10_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr10_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N0) >> 0 ; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr11_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N3) | ((val<<24) & NVIC_IPR11_IPR_N3); }
inline void nvic_ipr11_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N2) | ((val<<16) & NVIC_IPR11_IPR_N2); }
inline void nvic_ipr11_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N1) | ((val<<8) & NVIC_IPR11_IPR_N1); }
inline void nvic_ipr11_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N0) | ((val<<0) & NVIC_IPR11_IPR_N0); }
inline uint32_t nvic_ipr11_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr11_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr11_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr11_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N0) >> 0 ; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr12_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N3) | ((val<<24) & NVIC_IPR12_IPR_N3); }
inline void nvic_ipr12_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N2) | ((val<<16) & NVIC_IPR12_IPR_N2); }
inline void nvic_ipr12_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N1) | ((val<<8) & NVIC_IPR12_IPR_N1); }
inline void nvic_ipr12_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N0) | ((val<<0) & NVIC_IPR12_IPR_N0); }
inline uint32_t nvic_ipr12_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr12_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr12_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr12_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N0) >> 0 ; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr13_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N3) | ((val<<24) & NVIC_IPR13_IPR_N3); }
inline void nvic_ipr13_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N2) | ((val<<16) & NVIC_IPR13_IPR_N2); }
inline void nvic_ipr13_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N1) | ((val<<8) & NVIC_IPR13_IPR_N1); }
inline void nvic_ipr13_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N0) | ((val<<0) & NVIC_IPR13_IPR_N0); }
inline uint32_t nvic_ipr13_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr13_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr13_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr13_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N0) >> 0 ; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr14_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N3) | ((val<<24) & NVIC_IPR14_IPR_N3); }
inline void nvic_ipr14_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N2) | ((val<<16) & NVIC_IPR14_IPR_N2); }
inline void nvic_ipr14_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N1) | ((val<<8) & NVIC_IPR14_IPR_N1); }
inline void nvic_ipr14_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N0) | ((val<<0) & NVIC_IPR14_IPR_N0); }
inline uint32_t nvic_ipr14_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr14_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr14_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr14_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N0) >> 0 ; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr15_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N3) | ((val<<24) & NVIC_IPR15_IPR_N3); }
inline void nvic_ipr15_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N2) | ((val<<16) & NVIC_IPR15_IPR_N2); }
inline void nvic_ipr15_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N1) | ((val<<8) & NVIC_IPR15_IPR_N1); }
inline void nvic_ipr15_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N0) | ((val<<0) & NVIC_IPR15_IPR_N0); }
inline uint32_t nvic_ipr15_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr15_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr15_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr15_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N0) >> 0 ; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr16_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N3) | ((val<<24) & NVIC_IPR16_IPR_N3); }
inline void nvic_ipr16_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N2) | ((val<<16) & NVIC_IPR16_IPR_N2); }
inline void nvic_ipr16_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N1) | ((val<<8) & NVIC_IPR16_IPR_N1); }
inline void nvic_ipr16_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N0) | ((val<<0) & NVIC_IPR16_IPR_N0); }
inline uint32_t nvic_ipr16_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr16_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr16_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr16_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N0) >> 0 ; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr17_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N3) | ((val<<24) & NVIC_IPR17_IPR_N3); }
inline void nvic_ipr17_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N2) | ((val<<16) & NVIC_IPR17_IPR_N2); }
inline void nvic_ipr17_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N1) | ((val<<8) & NVIC_IPR17_IPR_N1); }
inline void nvic_ipr17_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N0) | ((val<<0) & NVIC_IPR17_IPR_N0); }
inline uint32_t nvic_ipr17_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr17_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr17_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr17_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N0) >> 0 ; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr18_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N3) | ((val<<24) & NVIC_IPR18_IPR_N3); }
inline void nvic_ipr18_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N2) | ((val<<16) & NVIC_IPR18_IPR_N2); }
inline void nvic_ipr18_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N1) | ((val<<8) & NVIC_IPR18_IPR_N1); }
inline void nvic_ipr18_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N0) | ((val<<0) & NVIC_IPR18_IPR_N0); }
inline uint32_t nvic_ipr18_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr18_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr18_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr18_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N0) >> 0 ; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr19_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N3) | ((val<<24) & NVIC_IPR19_IPR_N3); }
inline void nvic_ipr19_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N2) | ((val<<16) & NVIC_IPR19_IPR_N2); }
inline void nvic_ipr19_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N1) | ((val<<8) & NVIC_IPR19_IPR_N1); }
inline void nvic_ipr19_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N0) | ((val<<0) & NVIC_IPR19_IPR_N0); }
inline uint32_t nvic_ipr19_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr19_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr19_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr19_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N0) >> 0 ; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr20_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N3) | ((val<<24) & NVIC_IPR20_IPR_N3); }
inline void nvic_ipr20_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N2) | ((val<<16) & NVIC_IPR20_IPR_N2); }
inline void nvic_ipr20_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N1) | ((val<<8) & NVIC_IPR20_IPR_N1); }
inline void nvic_ipr20_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N0) | ((val<<0) & NVIC_IPR20_IPR_N0); }
inline uint32_t nvic_ipr20_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr20_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr20_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr20_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N0) >> 0 ; }

// NVIC->IPR21 Interrupt Priority Register
enum {
	NVIC_IPR21_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR21_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR21_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR21_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr21_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N3) | ((val<<24) & NVIC_IPR21_IPR_N3); }
inline void nvic_ipr21_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N2) | ((val<<16) & NVIC_IPR21_IPR_N2); }
inline void nvic_ipr21_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N1) | ((val<<8) & NVIC_IPR21_IPR_N1); }
inline void nvic_ipr21_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR21 = (p->IPR21 & ~NVIC_IPR21_IPR_N0) | ((val<<0) & NVIC_IPR21_IPR_N0); }
inline uint32_t nvic_ipr21_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr21_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr21_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr21_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR21 & NVIC_IPR21_IPR_N0) >> 0 ; }

// NVIC->IPR22 Interrupt Priority Register
enum {
	NVIC_IPR22_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR22_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR22_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR22_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr22_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N3) | ((val<<24) & NVIC_IPR22_IPR_N3); }
inline void nvic_ipr22_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N2) | ((val<<16) & NVIC_IPR22_IPR_N2); }
inline void nvic_ipr22_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N1) | ((val<<8) & NVIC_IPR22_IPR_N1); }
inline void nvic_ipr22_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR22 = (p->IPR22 & ~NVIC_IPR22_IPR_N0) | ((val<<0) & NVIC_IPR22_IPR_N0); }
inline uint32_t nvic_ipr22_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr22_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr22_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr22_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR22 & NVIC_IPR22_IPR_N0) >> 0 ; }

// NVIC->IPR23 Interrupt Priority Register
enum {
	NVIC_IPR23_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR23_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR23_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR23_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr23_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N3) | ((val<<24) & NVIC_IPR23_IPR_N3); }
inline void nvic_ipr23_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N2) | ((val<<16) & NVIC_IPR23_IPR_N2); }
inline void nvic_ipr23_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N1) | ((val<<8) & NVIC_IPR23_IPR_N1); }
inline void nvic_ipr23_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR23 = (p->IPR23 & ~NVIC_IPR23_IPR_N0) | ((val<<0) & NVIC_IPR23_IPR_N0); }
inline uint32_t nvic_ipr23_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr23_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr23_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr23_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR23 & NVIC_IPR23_IPR_N0) >> 0 ; }

// NVIC->IPR24 Interrupt Priority Register
enum {
	NVIC_IPR24_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR24_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR24_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR24_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr24_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N3) | ((val<<24) & NVIC_IPR24_IPR_N3); }
inline void nvic_ipr24_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N2) | ((val<<16) & NVIC_IPR24_IPR_N2); }
inline void nvic_ipr24_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N1) | ((val<<8) & NVIC_IPR24_IPR_N1); }
inline void nvic_ipr24_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR24 = (p->IPR24 & ~NVIC_IPR24_IPR_N0) | ((val<<0) & NVIC_IPR24_IPR_N0); }
inline uint32_t nvic_ipr24_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr24_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr24_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr24_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR24 & NVIC_IPR24_IPR_N0) >> 0 ; }

// NVIC->IPR25 Interrupt Priority Register
enum {
	NVIC_IPR25_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR25_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR25_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR25_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr25_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N3) | ((val<<24) & NVIC_IPR25_IPR_N3); }
inline void nvic_ipr25_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N2) | ((val<<16) & NVIC_IPR25_IPR_N2); }
inline void nvic_ipr25_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N1) | ((val<<8) & NVIC_IPR25_IPR_N1); }
inline void nvic_ipr25_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR25 = (p->IPR25 & ~NVIC_IPR25_IPR_N0) | ((val<<0) & NVIC_IPR25_IPR_N0); }
inline uint32_t nvic_ipr25_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr25_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr25_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr25_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR25 & NVIC_IPR25_IPR_N0) >> 0 ; }

// NVIC->IPR26 Interrupt Priority Register
enum {
	NVIC_IPR26_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR26_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR26_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR26_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr26_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N3) | ((val<<24) & NVIC_IPR26_IPR_N3); }
inline void nvic_ipr26_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N2) | ((val<<16) & NVIC_IPR26_IPR_N2); }
inline void nvic_ipr26_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N1) | ((val<<8) & NVIC_IPR26_IPR_N1); }
inline void nvic_ipr26_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR26 = (p->IPR26 & ~NVIC_IPR26_IPR_N0) | ((val<<0) & NVIC_IPR26_IPR_N0); }
inline uint32_t nvic_ipr26_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr26_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr26_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr26_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR26 & NVIC_IPR26_IPR_N0) >> 0 ; }

// NVIC->IPR27 Interrupt Priority Register
enum {
	NVIC_IPR27_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR27_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR27_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR27_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr27_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N3) | ((val<<24) & NVIC_IPR27_IPR_N3); }
inline void nvic_ipr27_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N2) | ((val<<16) & NVIC_IPR27_IPR_N2); }
inline void nvic_ipr27_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N1) | ((val<<8) & NVIC_IPR27_IPR_N1); }
inline void nvic_ipr27_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR27 = (p->IPR27 & ~NVIC_IPR27_IPR_N0) | ((val<<0) & NVIC_IPR27_IPR_N0); }
inline uint32_t nvic_ipr27_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr27_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr27_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr27_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR27 & NVIC_IPR27_IPR_N0) >> 0 ; }

// NVIC->IPR28 Interrupt Priority Register
enum {
	NVIC_IPR28_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR28_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR28_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR28_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr28_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N3) | ((val<<24) & NVIC_IPR28_IPR_N3); }
inline void nvic_ipr28_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N2) | ((val<<16) & NVIC_IPR28_IPR_N2); }
inline void nvic_ipr28_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N1) | ((val<<8) & NVIC_IPR28_IPR_N1); }
inline void nvic_ipr28_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR28 = (p->IPR28 & ~NVIC_IPR28_IPR_N0) | ((val<<0) & NVIC_IPR28_IPR_N0); }
inline uint32_t nvic_ipr28_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr28_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr28_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr28_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR28 & NVIC_IPR28_IPR_N0) >> 0 ; }

// NVIC->IPR29 Interrupt Priority Register
enum {
	NVIC_IPR29_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR29_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR29_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR29_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr29_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR29 = (p->IPR29 & ~NVIC_IPR29_IPR_N3) | ((val<<24) & NVIC_IPR29_IPR_N3); }
inline void nvic_ipr29_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR29 = (p->IPR29 & ~NVIC_IPR29_IPR_N2) | ((val<<16) & NVIC_IPR29_IPR_N2); }
inline void nvic_ipr29_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR29 = (p->IPR29 & ~NVIC_IPR29_IPR_N1) | ((val<<8) & NVIC_IPR29_IPR_N1); }
inline void nvic_ipr29_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR29 = (p->IPR29 & ~NVIC_IPR29_IPR_N0) | ((val<<0) & NVIC_IPR29_IPR_N0); }
inline uint32_t nvic_ipr29_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR29 & NVIC_IPR29_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr29_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR29 & NVIC_IPR29_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr29_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR29 & NVIC_IPR29_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr29_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR29 & NVIC_IPR29_IPR_N0) >> 0 ; }

// NVIC->IPR30 Interrupt Priority Register
enum {
	NVIC_IPR30_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR30_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR30_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR30_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr30_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR30 = (p->IPR30 & ~NVIC_IPR30_IPR_N3) | ((val<<24) & NVIC_IPR30_IPR_N3); }
inline void nvic_ipr30_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR30 = (p->IPR30 & ~NVIC_IPR30_IPR_N2) | ((val<<16) & NVIC_IPR30_IPR_N2); }
inline void nvic_ipr30_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR30 = (p->IPR30 & ~NVIC_IPR30_IPR_N1) | ((val<<8) & NVIC_IPR30_IPR_N1); }
inline void nvic_ipr30_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR30 = (p->IPR30 & ~NVIC_IPR30_IPR_N0) | ((val<<0) & NVIC_IPR30_IPR_N0); }
inline uint32_t nvic_ipr30_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR30 & NVIC_IPR30_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr30_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR30 & NVIC_IPR30_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr30_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR30 & NVIC_IPR30_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr30_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR30 & NVIC_IPR30_IPR_N0) >> 0 ; }

// NVIC->IPR31 Interrupt Priority Register
enum {
	NVIC_IPR31_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR31_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR31_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR31_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr31_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR31 = (p->IPR31 & ~NVIC_IPR31_IPR_N3) | ((val<<24) & NVIC_IPR31_IPR_N3); }
inline void nvic_ipr31_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR31 = (p->IPR31 & ~NVIC_IPR31_IPR_N2) | ((val<<16) & NVIC_IPR31_IPR_N2); }
inline void nvic_ipr31_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR31 = (p->IPR31 & ~NVIC_IPR31_IPR_N1) | ((val<<8) & NVIC_IPR31_IPR_N1); }
inline void nvic_ipr31_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR31 = (p->IPR31 & ~NVIC_IPR31_IPR_N0) | ((val<<0) & NVIC_IPR31_IPR_N0); }
inline uint32_t nvic_ipr31_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR31 & NVIC_IPR31_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr31_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR31 & NVIC_IPR31_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr31_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR31 & NVIC_IPR31_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr31_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR31 & NVIC_IPR31_IPR_N0) >> 0 ; }

// NVIC->IPR32 Interrupt Priority Register
enum {
	NVIC_IPR32_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR32_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR32_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR32_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr32_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR32 = (p->IPR32 & ~NVIC_IPR32_IPR_N3) | ((val<<24) & NVIC_IPR32_IPR_N3); }
inline void nvic_ipr32_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR32 = (p->IPR32 & ~NVIC_IPR32_IPR_N2) | ((val<<16) & NVIC_IPR32_IPR_N2); }
inline void nvic_ipr32_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR32 = (p->IPR32 & ~NVIC_IPR32_IPR_N1) | ((val<<8) & NVIC_IPR32_IPR_N1); }
inline void nvic_ipr32_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR32 = (p->IPR32 & ~NVIC_IPR32_IPR_N0) | ((val<<0) & NVIC_IPR32_IPR_N0); }
inline uint32_t nvic_ipr32_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR32 & NVIC_IPR32_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr32_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR32 & NVIC_IPR32_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr32_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR32 & NVIC_IPR32_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr32_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR32 & NVIC_IPR32_IPR_N0) >> 0 ; }

// NVIC->IPR33 Interrupt Priority Register
enum {
	NVIC_IPR33_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR33_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR33_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR33_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr33_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR33 = (p->IPR33 & ~NVIC_IPR33_IPR_N3) | ((val<<24) & NVIC_IPR33_IPR_N3); }
inline void nvic_ipr33_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR33 = (p->IPR33 & ~NVIC_IPR33_IPR_N2) | ((val<<16) & NVIC_IPR33_IPR_N2); }
inline void nvic_ipr33_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR33 = (p->IPR33 & ~NVIC_IPR33_IPR_N1) | ((val<<8) & NVIC_IPR33_IPR_N1); }
inline void nvic_ipr33_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR33 = (p->IPR33 & ~NVIC_IPR33_IPR_N0) | ((val<<0) & NVIC_IPR33_IPR_N0); }
inline uint32_t nvic_ipr33_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR33 & NVIC_IPR33_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr33_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR33 & NVIC_IPR33_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr33_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR33 & NVIC_IPR33_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr33_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR33 & NVIC_IPR33_IPR_N0) >> 0 ; }

// NVIC->IPR34 Interrupt Priority Register
enum {
	NVIC_IPR34_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR34_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR34_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR34_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr34_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR34 = (p->IPR34 & ~NVIC_IPR34_IPR_N3) | ((val<<24) & NVIC_IPR34_IPR_N3); }
inline void nvic_ipr34_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR34 = (p->IPR34 & ~NVIC_IPR34_IPR_N2) | ((val<<16) & NVIC_IPR34_IPR_N2); }
inline void nvic_ipr34_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR34 = (p->IPR34 & ~NVIC_IPR34_IPR_N1) | ((val<<8) & NVIC_IPR34_IPR_N1); }
inline void nvic_ipr34_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR34 = (p->IPR34 & ~NVIC_IPR34_IPR_N0) | ((val<<0) & NVIC_IPR34_IPR_N0); }
inline uint32_t nvic_ipr34_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR34 & NVIC_IPR34_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr34_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR34 & NVIC_IPR34_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr34_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR34 & NVIC_IPR34_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr34_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR34 & NVIC_IPR34_IPR_N0) >> 0 ; }

// NVIC->IPR35 Interrupt Priority Register
enum {
	NVIC_IPR35_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR35_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR35_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR35_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr35_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR35 = (p->IPR35 & ~NVIC_IPR35_IPR_N3) | ((val<<24) & NVIC_IPR35_IPR_N3); }
inline void nvic_ipr35_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR35 = (p->IPR35 & ~NVIC_IPR35_IPR_N2) | ((val<<16) & NVIC_IPR35_IPR_N2); }
inline void nvic_ipr35_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR35 = (p->IPR35 & ~NVIC_IPR35_IPR_N1) | ((val<<8) & NVIC_IPR35_IPR_N1); }
inline void nvic_ipr35_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR35 = (p->IPR35 & ~NVIC_IPR35_IPR_N0) | ((val<<0) & NVIC_IPR35_IPR_N0); }
inline uint32_t nvic_ipr35_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR35 & NVIC_IPR35_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr35_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR35 & NVIC_IPR35_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr35_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR35 & NVIC_IPR35_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr35_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR35 & NVIC_IPR35_IPR_N0) >> 0 ; }

// NVIC->IPR36 Interrupt Priority Register
enum {
	NVIC_IPR36_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR36_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR36_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR36_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr36_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR36 = (p->IPR36 & ~NVIC_IPR36_IPR_N3) | ((val<<24) & NVIC_IPR36_IPR_N3); }
inline void nvic_ipr36_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR36 = (p->IPR36 & ~NVIC_IPR36_IPR_N2) | ((val<<16) & NVIC_IPR36_IPR_N2); }
inline void nvic_ipr36_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR36 = (p->IPR36 & ~NVIC_IPR36_IPR_N1) | ((val<<8) & NVIC_IPR36_IPR_N1); }
inline void nvic_ipr36_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR36 = (p->IPR36 & ~NVIC_IPR36_IPR_N0) | ((val<<0) & NVIC_IPR36_IPR_N0); }
inline uint32_t nvic_ipr36_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR36 & NVIC_IPR36_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr36_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR36 & NVIC_IPR36_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr36_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR36 & NVIC_IPR36_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr36_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR36 & NVIC_IPR36_IPR_N0) >> 0 ; }

// NVIC->IPR37 Interrupt Priority Register
enum {
	NVIC_IPR37_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR37_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR37_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR37_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr37_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR37 = (p->IPR37 & ~NVIC_IPR37_IPR_N3) | ((val<<24) & NVIC_IPR37_IPR_N3); }
inline void nvic_ipr37_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR37 = (p->IPR37 & ~NVIC_IPR37_IPR_N2) | ((val<<16) & NVIC_IPR37_IPR_N2); }
inline void nvic_ipr37_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR37 = (p->IPR37 & ~NVIC_IPR37_IPR_N1) | ((val<<8) & NVIC_IPR37_IPR_N1); }
inline void nvic_ipr37_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR37 = (p->IPR37 & ~NVIC_IPR37_IPR_N0) | ((val<<0) & NVIC_IPR37_IPR_N0); }
inline uint32_t nvic_ipr37_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR37 & NVIC_IPR37_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr37_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR37 & NVIC_IPR37_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr37_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR37 & NVIC_IPR37_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr37_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR37 & NVIC_IPR37_IPR_N0) >> 0 ; }

// NVIC->IPR38 Interrupt Priority Register
enum {
	NVIC_IPR38_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR38_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR38_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR38_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr38_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR38 = (p->IPR38 & ~NVIC_IPR38_IPR_N3) | ((val<<24) & NVIC_IPR38_IPR_N3); }
inline void nvic_ipr38_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR38 = (p->IPR38 & ~NVIC_IPR38_IPR_N2) | ((val<<16) & NVIC_IPR38_IPR_N2); }
inline void nvic_ipr38_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR38 = (p->IPR38 & ~NVIC_IPR38_IPR_N1) | ((val<<8) & NVIC_IPR38_IPR_N1); }
inline void nvic_ipr38_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR38 = (p->IPR38 & ~NVIC_IPR38_IPR_N0) | ((val<<0) & NVIC_IPR38_IPR_N0); }
inline uint32_t nvic_ipr38_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR38 & NVIC_IPR38_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr38_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR38 & NVIC_IPR38_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr38_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR38 & NVIC_IPR38_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr38_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR38 & NVIC_IPR38_IPR_N0) >> 0 ; }

/* Nested vectored interrupt controller */
struct NVIC_STIR_Type {
	__IO uint16_t STIR; // @0 Software trigger interrupt register
};

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL<<9)-1) << 0, // Software generated interrupt ID		
};
inline void nvic_stir_stir_set_intid(struct NVIC_STIR_Type* p, uint32_t val) { p->STIR = (p->STIR & ~NVIC_STIR_STIR_INTID) | ((val<<0) & NVIC_STIR_STIR_INTID); }
inline uint32_t nvic_stir_stir_get_intid(struct NVIC_STIR_Type* p) { return (p->STIR & NVIC_STIR_STIR_INTID) >> 0 ; }

/* Operational amplifiers */
struct OPAMP_Type {
	__IO uint32_t OPAMP1_CSR; // @0 OPAMP1 control/status register
	__IO uint16_t OPAMP1_OTR; // @4 OPAMP1 offset trimming register in normal mode
	 uint8_t RESERVED0[2]; // @6 
	__IO uint16_t OPAMP1_HSOTR; // @8 OPAMP1 offset trimming register in low-power mode
	 uint8_t RESERVED1[6]; // @10 
	__IO uint32_t OPAMP2_CSR; // @16 OPAMP2 control/status register
	__IO uint16_t OPAMP2_OTR; // @20 OPAMP2 offset trimming register in normal mode
	 uint8_t RESERVED2[2]; // @22 
	__IO uint16_t OPAMP2_HSOTR; // @24 OPAMP2 offset trimming register in low-power mode
};

// OPAMP->OPAMP1_CSR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_CSR_CALOUT = 1UL<<30, // Operational amplifier calibration output
	OPAMP_OPAMP1_CSR_TSTREF = 1UL<<29, // OPAMP calibration reference voltage output control (reserved for test)
	OPAMP_OPAMP1_CSR_USERTRIM = 1UL<<18, // User trimming enable
	OPAMP_OPAMP1_CSR_PGA_GAIN = ((1UL<<4)-1) << 14, // allows to switch from AOP offset trimmed values to AOP offset
	OPAMP_OPAMP1_CSR_CALSEL = ((1UL<<2)-1) << 12, // Calibration selection
	OPAMP_OPAMP1_CSR_CALON = 1UL<<11, // Calibration mode enabled
	OPAMP_OPAMP1_CSR_OPAHSM = 1UL<<8, // Operational amplifier high-speed mode
	OPAMP_OPAMP1_CSR_VM_SEL = ((1UL<<2)-1) << 5, // Inverting input selection
	OPAMP_OPAMP1_CSR_VP_SEL = ((1UL<<2)-1) << 2, // Operational amplifier PGA mode
	OPAMP_OPAMP1_CSR_FORCE_VP = 1UL<<1, // Force internal reference on VP (reserved for test
	OPAMP_OPAMP1_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
inline void opamp_opamp1_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP1_CSR_PGA_GAIN); }
inline void opamp_opamp1_csr_set_calsel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP1_CSR_CALSEL); }
inline void opamp_opamp1_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP1_CSR_VM_SEL); }
inline void opamp_opamp1_csr_set_vp_sel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP1_CSR_VP_SEL); }
inline uint32_t opamp_opamp1_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_PGA_GAIN) >> 14 ; }
inline uint32_t opamp_opamp1_csr_get_calsel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_CALSEL) >> 12 ; }
inline uint32_t opamp_opamp1_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VM_SEL) >> 5 ; }
inline uint32_t opamp_opamp1_csr_get_vp_sel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP1_OTR OPAMP1 offset trimming register in normal mode
enum {
	OPAMP_OPAMP1_OTR_TRIMOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP1_OTR_TRIMOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp1_otr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_OTR = (p->OPAMP1_OTR & ~OPAMP_OPAMP1_OTR_TRIMOFFSETP) | ((val<<8) & OPAMP_OPAMP1_OTR_TRIMOFFSETP); }
inline void opamp_opamp1_otr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_OTR = (p->OPAMP1_OTR & ~OPAMP_OPAMP1_OTR_TRIMOFFSETN) | ((val<<0) & OPAMP_OPAMP1_OTR_TRIMOFFSETN); }
inline uint32_t opamp_opamp1_otr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP1_OTR & OPAMP_OPAMP1_OTR_TRIMOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp1_otr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP1_OTR & OPAMP_OPAMP1_OTR_TRIMOFFSETN) >> 0 ; }

// OPAMP->OPAMP1_HSOTR OPAMP1 offset trimming register in low-power mode
enum {
	OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp1_hsotr_set_trimlpoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_HSOTR = (p->OPAMP1_HSOTR & ~OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP) | ((val<<8) & OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP); }
inline void opamp_opamp1_hsotr_set_trimlpoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_HSOTR = (p->OPAMP1_HSOTR & ~OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN) | ((val<<0) & OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN); }
inline uint32_t opamp_opamp1_hsotr_get_trimlpoffsetp(struct OPAMP_Type* p) { return (p->OPAMP1_HSOTR & OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp1_hsotr_get_trimlpoffsetn(struct OPAMP_Type* p) { return (p->OPAMP1_HSOTR & OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN) >> 0 ; }

// OPAMP->OPAMP2_CSR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_CSR_CALOUT = 1UL<<30, // Operational amplifier calibration output
	OPAMP_OPAMP2_CSR_TSTREF = 1UL<<29, // OPAMP calibration reference voltage output control (reserved for test)
	OPAMP_OPAMP2_CSR_USERTRIM = 1UL<<18, // User trimming enable
	OPAMP_OPAMP2_CSR_PGA_GAIN = ((1UL<<4)-1) << 14, // Operational amplifier Programmable amplifier gain value
	OPAMP_OPAMP2_CSR_CALSEL = ((1UL<<2)-1) << 12, // Calibration selection
	OPAMP_OPAMP2_CSR_CALON = 1UL<<11, // Calibration mode enabled
	OPAMP_OPAMP2_CSR_OPAHSM = 1UL<<8, // Operational amplifier high-speed mode
	OPAMP_OPAMP2_CSR_VM_SEL = ((1UL<<2)-1) << 5, // Inverting input selection
	OPAMP_OPAMP2_CSR_FORCE_VP = 1UL<<1, // Force internal reference on VP (reserved for test)
	OPAMP_OPAMP2_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
inline void opamp_opamp2_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP2_CSR_PGA_GAIN); }
inline void opamp_opamp2_csr_set_calsel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP2_CSR_CALSEL); }
inline void opamp_opamp2_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP2_CSR_VM_SEL); }
inline uint32_t opamp_opamp2_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_PGA_GAIN) >> 14 ; }
inline uint32_t opamp_opamp2_csr_get_calsel(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_CALSEL) >> 12 ; }
inline uint32_t opamp_opamp2_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_VM_SEL) >> 5 ; }

// OPAMP->OPAMP2_OTR OPAMP2 offset trimming register in normal mode
enum {
	OPAMP_OPAMP2_OTR_TRIMOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP2_OTR_TRIMOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp2_otr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_OTR = (p->OPAMP2_OTR & ~OPAMP_OPAMP2_OTR_TRIMOFFSETP) | ((val<<8) & OPAMP_OPAMP2_OTR_TRIMOFFSETP); }
inline void opamp_opamp2_otr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_OTR = (p->OPAMP2_OTR & ~OPAMP_OPAMP2_OTR_TRIMOFFSETN) | ((val<<0) & OPAMP_OPAMP2_OTR_TRIMOFFSETN); }
inline uint32_t opamp_opamp2_otr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP2_OTR & OPAMP_OPAMP2_OTR_TRIMOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp2_otr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP2_OTR & OPAMP_OPAMP2_OTR_TRIMOFFSETN) >> 0 ; }

// OPAMP->OPAMP2_HSOTR OPAMP2 offset trimming register in low-power mode
enum {
	OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp2_hsotr_set_trimlpoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_HSOTR = (p->OPAMP2_HSOTR & ~OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP) | ((val<<8) & OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP); }
inline void opamp_opamp2_hsotr_set_trimlpoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_HSOTR = (p->OPAMP2_HSOTR & ~OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN) | ((val<<0) & OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN); }
inline uint32_t opamp_opamp2_hsotr_get_trimlpoffsetp(struct OPAMP_Type* p) { return (p->OPAMP2_HSOTR & OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp2_hsotr_get_trimlpoffsetn(struct OPAMP_Type* p) { return (p->OPAMP2_HSOTR & OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN) >> 0 ; }

/* USB 1 on the go high speed */
struct OTG1_HS_DEVICE_Type {
	__IO uint32_t OTG_HS_DCFG; // @0 OTG_HS device configuration register
	__IO uint16_t OTG_HS_DCTL; // @4 OTG_HS device control register
	 uint8_t RESERVED0[2]; // @6 
	__I uint32_t OTG_HS_DSTS; // @8 OTG_HS device status register
	 uint8_t RESERVED1[4]; // @12 
	__IO uint16_t OTG_HS_DIEPMSK; // @16 OTG_HS device IN endpoint common interrupt mask register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint16_t OTG_HS_DOEPMSK; // @20 OTG_HS device OUT endpoint common interrupt mask register
	 uint8_t RESERVED3[2]; // @22 
	__I uint32_t OTG_HS_DAINT; // @24 OTG_HS device all endpoints interrupt register
	__IO uint32_t OTG_HS_DAINTMSK; // @28 OTG_HS all endpoints interrupt mask register
	 uint8_t RESERVED4[8]; // @32 
	__IO uint16_t OTG_HS_DVBUSDIS; // @40 OTG_HS device VBUS discharge time register
	 uint8_t RESERVED5[2]; // @42 
	__IO uint16_t OTG_HS_DVBUSPULSE; // @44 OTG_HS device VBUS pulsing time register
	 uint8_t RESERVED6[2]; // @46 
	__IO uint32_t OTG_HS_DTHRCTL; // @48 OTG_HS Device threshold control register
	__IO uint16_t OTG_HS_DIEPEMPMSK; // @52 OTG_HS device IN endpoint FIFO empty interrupt mask register
	 uint8_t RESERVED7[2]; // @54 
	__IO uint32_t OTG_HS_DEACHINT; // @56 OTG_HS device each endpoint interrupt register
	__IO uint32_t OTG_HS_DEACHINTMSK; // @60 OTG_HS device each endpoint interrupt register mask
	 uint8_t RESERVED8[192]; // @64 
	__IO uint32_t OTG_HS_DIEPCTL0; // @256 OTG device endpoint-0 control register
	 uint8_t RESERVED9[4]; // @260 
	__IO uint16_t OTG_HS_DIEPINT0; // @264 OTG device endpoint-0 interrupt register
	 uint8_t RESERVED10[6]; // @266 
	__IO uint32_t OTG_HS_DIEPTSIZ0; // @272 OTG_HS device IN endpoint 0 transfer size register
	__IO uint32_t OTG_HS_DIEPDMA1; // @276 OTG_HS device endpoint-1 DMA address register
	__I uint16_t OTG_HS_DTXFSTS0; // @280 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED11[6]; // @282 
	__IO uint32_t OTG_HS_DIEPCTL1; // @288 OTG device endpoint-1 control register
	 uint8_t RESERVED12[4]; // @292 
	__IO uint16_t OTG_HS_DIEPINT1; // @296 OTG device endpoint-1 interrupt register
	 uint8_t RESERVED13[6]; // @298 
	__IO uint32_t OTG_HS_DIEPTSIZ1; // @304 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA2; // @308 OTG_HS device endpoint-2 DMA address register
	__I uint16_t OTG_HS_DTXFSTS1; // @312 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED14[6]; // @314 
	__IO uint32_t OTG_HS_DIEPCTL2; // @320 OTG device endpoint-2 control register
	 uint8_t RESERVED15[4]; // @324 
	__IO uint16_t OTG_HS_DIEPINT2; // @328 OTG device endpoint-2 interrupt register
	 uint8_t RESERVED16[6]; // @330 
	__IO uint32_t OTG_HS_DIEPTSIZ2; // @336 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA3; // @340 OTG_HS device endpoint-3 DMA address register
	__I uint16_t OTG_HS_DTXFSTS2; // @344 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED17[6]; // @346 
	__IO uint32_t OTG_HS_DIEPCTL3; // @352 OTG device endpoint-3 control register
	 uint8_t RESERVED18[4]; // @356 
	__IO uint16_t OTG_HS_DIEPINT3; // @360 OTG device endpoint-3 interrupt register
	 uint8_t RESERVED19[6]; // @362 
	__IO uint32_t OTG_HS_DIEPTSIZ3; // @368 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA4; // @372 OTG_HS device endpoint-4 DMA address register
	__I uint16_t OTG_HS_DTXFSTS3; // @376 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED20[6]; // @378 
	__IO uint32_t OTG_HS_DIEPCTL4; // @384 OTG device endpoint-4 control register
	 uint8_t RESERVED21[4]; // @388 
	__IO uint16_t OTG_HS_DIEPINT4; // @392 OTG device endpoint-4 interrupt register
	 uint8_t RESERVED22[6]; // @394 
	__IO uint32_t OTG_HS_DIEPTSIZ4; // @400 OTG_HS device endpoint transfer size register
	__IO uint32_t OTG_HS_DIEPDMA5; // @404 OTG_HS device endpoint-5 DMA address register
	__I uint16_t OTG_HS_DTXFSTS4; // @408 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED23[6]; // @410 
	union {  // @416
		__IO uint32_t OTG_HS_DIEPCTL5; // OTG device endpoint-5 control register
		__IO uint32_t OTG_HS_DIEPTSIZ6; // OTG_HS device endpoint transfer size register
	};
	__IO uint16_t OTG_HS_DTXFSTS6; // @420 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED24[2]; // @422 
	union {  // @424
		__IO uint32_t OTG_HS_DIEPTSIZ7; // OTG_HS device endpoint transfer size register
		__IO uint16_t OTG_HS_DIEPINT5; // OTG device endpoint-5 interrupt register
	};
	__IO uint16_t OTG_HS_DTXFSTS7; // @428 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED25[2]; // @430 
	__IO uint32_t OTG_HS_DIEPTSIZ5; // @432 OTG_HS device endpoint transfer size register
	 uint8_t RESERVED26[4]; // @436 
	__I uint16_t OTG_HS_DTXFSTS5; // @440 OTG_HS device IN endpoint transmit FIFO status register
	 uint8_t RESERVED27[6]; // @442 
	__IO uint32_t OTG_HS_DIEPCTL6; // @448 OTG device endpoint-6 control register
	 uint8_t RESERVED28[4]; // @452 
	__IO uint16_t OTG_HS_DIEPINT6; // @456 OTG device endpoint-6 interrupt register
	 uint8_t RESERVED29[22]; // @458 
	__IO uint32_t OTG_HS_DIEPCTL7; // @480 OTG device endpoint-7 control register
	 uint8_t RESERVED30[4]; // @484 
	__IO uint16_t OTG_HS_DIEPINT7; // @488 OTG device endpoint-7 interrupt register
	 uint8_t RESERVED31[278]; // @490 
	__IO uint32_t OTG_HS_DOEPCTL0; // @768 OTG_HS device control OUT endpoint 0 control register
	 uint8_t RESERVED32[4]; // @772 
	__IO uint16_t OTG_HS_DOEPINT0; // @776 OTG_HS device endpoint-0 interrupt register
	 uint8_t RESERVED33[6]; // @778 
	__IO uint32_t OTG_HS_DOEPTSIZ0; // @784 OTG_HS device endpoint-0 transfer size register
	 uint8_t RESERVED34[12]; // @788 
	__IO uint32_t OTG_HS_DOEPCTL1; // @800 OTG device endpoint-1 control register
	 uint8_t RESERVED35[4]; // @804 
	__IO uint16_t OTG_HS_DOEPINT1; // @808 OTG_HS device endpoint-1 interrupt register
	 uint8_t RESERVED36[6]; // @810 
	__IO uint32_t OTG_HS_DOEPTSIZ1; // @816 OTG_HS device endpoint-1 transfer size register
	 uint8_t RESERVED37[12]; // @820 
	__IO uint32_t OTG_HS_DOEPCTL2; // @832 OTG device endpoint-2 control register
	 uint8_t RESERVED38[4]; // @836 
	__IO uint16_t OTG_HS_DOEPINT2; // @840 OTG_HS device endpoint-2 interrupt register
	 uint8_t RESERVED39[6]; // @842 
	__IO uint32_t OTG_HS_DOEPTSIZ2; // @848 OTG_HS device endpoint-2 transfer size register
	 uint8_t RESERVED40[12]; // @852 
	__IO uint32_t OTG_HS_DOEPCTL3; // @864 OTG device endpoint-3 control register
	 uint8_t RESERVED41[4]; // @868 
	__IO uint16_t OTG_HS_DOEPINT3; // @872 OTG_HS device endpoint-3 interrupt register
	 uint8_t RESERVED42[6]; // @874 
	__IO uint32_t OTG_HS_DOEPTSIZ3; // @880 OTG_HS device endpoint-3 transfer size register
	 uint8_t RESERVED43[12]; // @884 
	__IO uint32_t OTG_HS_DOEPCTL4; // @896 OTG device endpoint-4 control register
	 uint8_t RESERVED44[4]; // @900 
	__IO uint16_t OTG_HS_DOEPINT4; // @904 OTG_HS device endpoint-4 interrupt register
	 uint8_t RESERVED45[6]; // @906 
	__IO uint32_t OTG_HS_DOEPTSIZ4; // @912 OTG_HS device endpoint-4 transfer size register
	 uint8_t RESERVED46[12]; // @916 
	__IO uint32_t OTG_HS_DOEPCTL5; // @928 OTG device endpoint-5 control register
	 uint8_t RESERVED47[4]; // @932 
	__IO uint16_t OTG_HS_DOEPINT5; // @936 OTG_HS device endpoint-5 interrupt register
	 uint8_t RESERVED48[6]; // @938 
	__IO uint32_t OTG_HS_DOEPTSIZ5; // @944 OTG_HS device endpoint-5 transfer size register
	 uint8_t RESERVED49[12]; // @948 
	__IO uint32_t OTG_HS_DOEPCTL6; // @960 OTG device endpoint-6 control register
	 uint8_t RESERVED50[4]; // @964 
	__IO uint16_t OTG_HS_DOEPINT6; // @968 OTG_HS device endpoint-6 interrupt register
	 uint8_t RESERVED51[6]; // @970 
	__IO uint32_t OTG_HS_DOEPTSIZ6; // @976 OTG_HS device endpoint-6 transfer size register
	 uint8_t RESERVED52[12]; // @980 
	__IO uint32_t OTG_HS_DOEPCTL7; // @992 OTG device endpoint-7 control register
	 uint8_t RESERVED53[4]; // @996 
	__IO uint16_t OTG_HS_DOEPINT7; // @1000 OTG_HS device endpoint-7 interrupt register
	 uint8_t RESERVED54[6]; // @1002 
	__IO uint32_t OTG_HS_DOEPTSIZ7; // @1008 OTG_HS device endpoint-7 transfer size register
};

// OTG1_HS_DEVICE->OTG_HS_DCFG OTG_HS device configuration register
enum {
	OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL = ((1UL<<2)-1) << 24, // Periodic scheduling interval
	OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL = ((1UL<<2)-1) << 11, // Periodic (micro)frame interval
	OTG1_HS_DEVICE_OTG_HS_DCFG_DAD = ((1UL<<7)-1) << 4, // Device address
	OTG1_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK = 1UL<<2, // Nonzero-length status OUT handshake
	OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD = ((1UL<<2)-1) << 0, // Device speed		
};
inline void otg1_hs_device_otg_hs_dcfg_set_perschivl(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL) | ((val<<24) & OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL); }
inline void otg1_hs_device_otg_hs_dcfg_set_pfivl(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL) | ((val<<11) & OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL); }
inline void otg1_hs_device_otg_hs_dcfg_set_dad(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG1_HS_DEVICE_OTG_HS_DCFG_DAD) | ((val<<4) & OTG1_HS_DEVICE_OTG_HS_DCFG_DAD); }
inline void otg1_hs_device_otg_hs_dcfg_set_dspd(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCFG = (p->OTG_HS_DCFG & ~OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD); }
inline uint32_t otg1_hs_device_otg_hs_dcfg_get_perschivl(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL) >> 24 ; }
inline uint32_t otg1_hs_device_otg_hs_dcfg_get_pfivl(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL) >> 11 ; }
inline uint32_t otg1_hs_device_otg_hs_dcfg_get_dad(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG1_HS_DEVICE_OTG_HS_DCFG_DAD) >> 4 ; }
inline uint32_t otg1_hs_device_otg_hs_dcfg_get_dspd(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DCFG & OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DCTL OTG_HS device control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DCTL_POPRGDNE = 1UL<<11, // Power-on programming done
	OTG1_HS_DEVICE_OTG_HS_DCTL_CGONAK = 1UL<<10, // Clear global OUT NAK
	OTG1_HS_DEVICE_OTG_HS_DCTL_SGONAK = 1UL<<9, // Set global OUT NAK
	OTG1_HS_DEVICE_OTG_HS_DCTL_CGINAK = 1UL<<8, // Clear global IN NAK
	OTG1_HS_DEVICE_OTG_HS_DCTL_SGINAK = 1UL<<7, // Set global IN NAK
	OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL = ((1UL<<3)-1) << 4, // Test control
	OTG1_HS_DEVICE_OTG_HS_DCTL_GONSTS = 1UL<<3, // Global OUT NAK status
	OTG1_HS_DEVICE_OTG_HS_DCTL_GINSTS = 1UL<<2, // Global IN NAK status
	OTG1_HS_DEVICE_OTG_HS_DCTL_SDIS = 1UL<<1, // Soft disconnect
	OTG1_HS_DEVICE_OTG_HS_DCTL_RWUSIG = 1UL<<0, // Remote wakeup signaling		
};
inline void otg1_hs_device_otg_hs_dctl_set_tctl(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DCTL = (p->OTG_HS_DCTL & ~OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL) | ((val<<4) & OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL); }
inline uint32_t otg1_hs_device_otg_hs_dctl_get_tctl(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DCTL & OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL) >> 4 ; }

// OTG1_HS_DEVICE->OTG_HS_DSTS OTG_HS device status register
enum {
	OTG1_HS_DEVICE_OTG_HS_DSTS_FNSOF = ((1UL<<14)-1) << 8, // Frame number of the received SOF
	OTG1_HS_DEVICE_OTG_HS_DSTS_EERR = 1UL<<3, // Erratic error
	OTG1_HS_DEVICE_OTG_HS_DSTS_ENUMSPD = ((1UL<<2)-1) << 1, // Enumerated speed
	OTG1_HS_DEVICE_OTG_HS_DSTS_SUSPSTS = 1UL<<0, // Suspend status		
};
inline uint32_t otg1_hs_device_otg_hs_dsts_get_fnsof(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DSTS & OTG1_HS_DEVICE_OTG_HS_DSTS_FNSOF) >> 8 ; }
inline uint32_t otg1_hs_device_otg_hs_dsts_get_enumspd(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DSTS & OTG1_HS_DEVICE_OTG_HS_DSTS_ENUMSPD) >> 1 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPMSK OTG_HS device IN endpoint common interrupt mask register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_BIM = 1UL<<9, // BNA interrupt mask
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM = 1UL<<8, // FIFO underrun mask
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM = 1UL<<6, // IN endpoint NAK effective mask
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM = 1UL<<5, // IN token received with EP mismatch mask
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK = 1UL<<4, // IN token received when TxFIFO empty mask
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TOM = 1UL<<3, // Timeout condition mask (nonisochronous endpoints)
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_EPDM = 1UL<<1, // Endpoint disabled interrupt mask
	OTG1_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM = 1UL<<0, // Transfer completed interrupt mask		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPMSK OTG_HS device OUT endpoint common interrupt mask register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_BOIM = 1UL<<9, // BNA interrupt mask
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OPEM = 1UL<<8, // OUT packet error mask
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received mask
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM = 1UL<<4, // OUT token received when endpoint disabled mask
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_STUPM = 1UL<<3, // SETUP phase done mask
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_EPDM = 1UL<<1, // Endpoint disabled interrupt mask
	OTG1_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM = 1UL<<0, // Transfer completed interrupt mask		
};

// OTG1_HS_DEVICE->OTG_HS_DAINT OTG_HS device all endpoints interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DAINT_OEPINT = ((1UL<<16)-1) << 16, // OUT endpoint interrupt bits
	OTG1_HS_DEVICE_OTG_HS_DAINT_IEPINT = ((1UL<<16)-1) << 0, // IN endpoint interrupt bits		
};
inline uint32_t otg1_hs_device_otg_hs_daint_get_oepint(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINT & OTG1_HS_DEVICE_OTG_HS_DAINT_OEPINT) >> 16 ; }
inline uint32_t otg1_hs_device_otg_hs_daint_get_iepint(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINT & OTG1_HS_DEVICE_OTG_HS_DAINT_IEPINT) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DAINTMSK OTG_HS all endpoints interrupt mask register
enum {
	OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM = ((1UL<<16)-1) << 16, // OUT EP interrupt mask bits
	OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM = ((1UL<<16)-1) << 0, // IN EP interrupt mask bits		
};
inline void otg1_hs_device_otg_hs_daintmsk_set_oepm(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DAINTMSK = (p->OTG_HS_DAINTMSK & ~OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM) | ((val<<16) & OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM); }
inline void otg1_hs_device_otg_hs_daintmsk_set_iepm(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DAINTMSK = (p->OTG_HS_DAINTMSK & ~OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM); }
inline uint32_t otg1_hs_device_otg_hs_daintmsk_get_oepm(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINTMSK & OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM) >> 16 ; }
inline uint32_t otg1_hs_device_otg_hs_daintmsk_get_iepm(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DAINTMSK & OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DVBUSPULSE OTG_HS device VBUS pulsing time register
enum {
	OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP = ((1UL<<12)-1) << 0, // Device VBUS pulsing time		
};
inline void otg1_hs_device_otg_hs_dvbuspulse_set_dvbusp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DVBUSPULSE = (p->OTG_HS_DVBUSPULSE & ~OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP); }
inline uint32_t otg1_hs_device_otg_hs_dvbuspulse_get_dvbusp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DVBUSPULSE & OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DTHRCTL OTG_HS Device threshold control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN = 1UL<<27, // Arbiter parking enable
	OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN = ((1UL<<9)-1) << 17, // Receive threshold length
	OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN = 1UL<<16, // Receive threshold enable
	OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN = ((1UL<<9)-1) << 2, // Transmit threshold length
	OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN = 1UL<<1, // ISO IN endpoint threshold enable
	OTG1_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN = 1UL<<0, // Nonisochronous IN endpoints threshold enable		
};
inline void otg1_hs_device_otg_hs_dthrctl_set_rxthrlen(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DTHRCTL = (p->OTG_HS_DTHRCTL & ~OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN) | ((val<<17) & OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN); }
inline void otg1_hs_device_otg_hs_dthrctl_set_txthrlen(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DTHRCTL = (p->OTG_HS_DTHRCTL & ~OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN) | ((val<<2) & OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN); }
inline uint32_t otg1_hs_device_otg_hs_dthrctl_get_rxthrlen(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DTHRCTL & OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN) >> 17 ; }
inline uint32_t otg1_hs_device_otg_hs_dthrctl_get_txthrlen(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DTHRCTL & OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN) >> 2 ; }

// OTG1_HS_DEVICE->OTG_HS_DEACHINT OTG_HS device each endpoint interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT = 1UL<<17, // OUT endpoint 1 interrupt bit
	OTG1_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT = 1UL<<1, // IN endpoint 1interrupt bit		
};

// OTG1_HS_DEVICE->OTG_HS_DEACHINTMSK OTG_HS device each endpoint interrupt register mask
enum {
	OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM = 1UL<<17, // OUT Endpoint 1 interrupt mask bit
	OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM = 1UL<<1, // IN Endpoint 1 interrupt mask bit		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL0 OTG device endpoint-0 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl0_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL0 = (p->OTG_HS_DIEPCTL0 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl0_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL0 = (p->OTG_HS_DIEPCTL0 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl0_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL0 = (p->OTG_HS_DIEPCTL0 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl0_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL0 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl0_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL0 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl0_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL0 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT0 OTG device endpoint-0 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT0_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ0 OTG_HS device IN endpoint 0 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT = ((1UL<<2)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ = ((1UL<<7)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz0_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ0 = (p->OTG_HS_DIEPTSIZ0 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz0_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ0 = (p->OTG_HS_DIEPTSIZ0 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz0_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ0 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz0_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ0 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL1 OTG device endpoint-1 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl1_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL1 = (p->OTG_HS_DIEPCTL1 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl1_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL1 = (p->OTG_HS_DIEPCTL1 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl1_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL1 = (p->OTG_HS_DIEPCTL1 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl1_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL1 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl1_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL1 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl1_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL1 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT1 OTG device endpoint-1 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT1_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ1 OTG_HS device endpoint transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz1_set_mcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ1 = (p->OTG_HS_DIEPTSIZ1 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz1_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ1 = (p->OTG_HS_DIEPTSIZ1 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz1_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ1 = (p->OTG_HS_DIEPTSIZ1 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz1_get_mcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ1 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz1_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ1 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz1_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ1 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL2 OTG device endpoint-2 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl2_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL2 = (p->OTG_HS_DIEPCTL2 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl2_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL2 = (p->OTG_HS_DIEPCTL2 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl2_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL2 = (p->OTG_HS_DIEPCTL2 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl2_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL2 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl2_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL2 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl2_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL2 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT2 OTG device endpoint-2 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT2_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ2 OTG_HS device endpoint transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz2_set_mcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ2 = (p->OTG_HS_DIEPTSIZ2 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz2_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ2 = (p->OTG_HS_DIEPTSIZ2 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz2_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ2 = (p->OTG_HS_DIEPTSIZ2 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz2_get_mcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ2 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz2_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ2 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz2_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ2 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL3 OTG device endpoint-3 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl3_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL3 = (p->OTG_HS_DIEPCTL3 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl3_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL3 = (p->OTG_HS_DIEPCTL3 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl3_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL3 = (p->OTG_HS_DIEPCTL3 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl3_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL3 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl3_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL3 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl3_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL3 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT3 OTG device endpoint-3 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT3_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ3 OTG_HS device endpoint transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz3_set_mcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ3 = (p->OTG_HS_DIEPTSIZ3 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz3_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ3 = (p->OTG_HS_DIEPTSIZ3 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz3_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ3 = (p->OTG_HS_DIEPTSIZ3 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz3_get_mcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ3 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz3_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ3 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz3_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ3 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL4 OTG device endpoint-4 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl4_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL4 = (p->OTG_HS_DIEPCTL4 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl4_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL4 = (p->OTG_HS_DIEPCTL4 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl4_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL4 = (p->OTG_HS_DIEPCTL4 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl4_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL4 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl4_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL4 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl4_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL4 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT4 OTG device endpoint-4 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT4_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ4 OTG_HS device endpoint transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz4_set_mcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ4 = (p->OTG_HS_DIEPTSIZ4 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz4_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ4 = (p->OTG_HS_DIEPTSIZ4 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz4_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ4 = (p->OTG_HS_DIEPTSIZ4 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz4_get_mcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ4 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz4_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ4 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz4_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ4 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL5 OTG device endpoint-5 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl5_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL5 = (p->OTG_HS_DIEPCTL5 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl5_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL5 = (p->OTG_HS_DIEPCTL5 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl5_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL5 = (p->OTG_HS_DIEPCTL5 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl5_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL5 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl5_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL5 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl5_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL5 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ7 OTG_HS device endpoint transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz7_set_mcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ7 = (p->OTG_HS_DIEPTSIZ7 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz7_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ7 = (p->OTG_HS_DIEPTSIZ7 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz7_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ7 = (p->OTG_HS_DIEPTSIZ7 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz7_get_mcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ7 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz7_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ7 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz7_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ7 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPTSIZ5 OTG_HS device endpoint transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT = ((1UL<<2)-1) << 29, // Multi count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_dieptsiz5_set_mcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ5 = (p->OTG_HS_DIEPTSIZ5 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz5_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ5 = (p->OTG_HS_DIEPTSIZ5 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT); }
inline void otg1_hs_device_otg_hs_dieptsiz5_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPTSIZ5 = (p->OTG_HS_DIEPTSIZ5 & ~OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz5_get_mcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ5 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz5_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ5 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_dieptsiz5_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPTSIZ5 & OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL6 OTG device endpoint-6 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl6_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL6 = (p->OTG_HS_DIEPCTL6 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl6_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL6 = (p->OTG_HS_DIEPCTL6 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl6_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL6 = (p->OTG_HS_DIEPCTL6 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl6_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL6 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl6_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL6 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl6_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL6 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT6 OTG device endpoint-6 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT6_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DIEPCTL7 OTG device endpoint-7 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM = ((1UL<<4)-1) << 22, // TxFIFO number
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EONUM_DPID = 1UL<<16, // Even/odd frame
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_diepctl7_set_txfnum(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL7 = (p->OTG_HS_DIEPCTL7 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM) | ((val<<22) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM); }
inline void otg1_hs_device_otg_hs_diepctl7_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL7 = (p->OTG_HS_DIEPCTL7 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP); }
inline void otg1_hs_device_otg_hs_diepctl7_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DIEPCTL7 = (p->OTG_HS_DIEPCTL7 & ~OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_diepctl7_get_txfnum(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL7 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM) >> 22 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl7_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL7 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_diepctl7_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DIEPCTL7 & OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DIEPINT7 OTG device endpoint-7 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_NAK = 1UL<<13, // NAK interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_BERR = 1UL<<12, // Babble error interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_PKTDRPSTS = 1UL<<11, // Packet dropped status
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_BNA = 1UL<<9, // Buffer not available interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TXFIFOUDRN = 1UL<<8, // Transmit Fifo Underrun
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TXFE = 1UL<<7, // Transmit FIFO empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_INEPNE = 1UL<<6, // IN endpoint NAK effective
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_ITTXFE = 1UL<<4, // IN token received when TxFIFO is empty
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TOC = 1UL<<3, // Timeout condition
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DIEPINT7_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL0 OTG_HS device control OUT endpoint 0 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ = ((1UL<<2)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl0_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL0 = (p->OTG_HS_DOEPCTL0 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl0_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL0 = (p->OTG_HS_DOEPCTL0 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl0_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL0 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl0_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL0 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT0 OTG_HS device endpoint-0 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT0_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT0_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT0_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT0_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT0_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT0_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ0 OTG_HS device endpoint-0 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT = ((1UL<<2)-1) << 29, // SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT = 1UL<<19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ = ((1UL<<7)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz0_set_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ0 = (p->OTG_HS_DOEPTSIZ0 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz0_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ0 = (p->OTG_HS_DOEPTSIZ0 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz0_get_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ0 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz0_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ0 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL1 OTG device endpoint-1 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl1_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL1 = (p->OTG_HS_DOEPCTL1 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl1_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL1 = (p->OTG_HS_DOEPCTL1 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl1_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL1 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl1_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL1 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT1 OTG_HS device endpoint-1 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT1_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT1_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT1_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT1_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT1_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT1_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ1 OTG_HS device endpoint-1 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz1_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ1 = (p->OTG_HS_DOEPTSIZ1 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz1_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ1 = (p->OTG_HS_DOEPTSIZ1 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz1_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ1 = (p->OTG_HS_DOEPTSIZ1 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz1_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ1 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz1_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ1 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz1_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ1 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL2 OTG device endpoint-2 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl2_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL2 = (p->OTG_HS_DOEPCTL2 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl2_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL2 = (p->OTG_HS_DOEPCTL2 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl2_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL2 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl2_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL2 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT2 OTG_HS device endpoint-2 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT2_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT2_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT2_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT2_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT2_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT2_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ2 OTG_HS device endpoint-2 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz2_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ2 = (p->OTG_HS_DOEPTSIZ2 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz2_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ2 = (p->OTG_HS_DOEPTSIZ2 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz2_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ2 = (p->OTG_HS_DOEPTSIZ2 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz2_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ2 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz2_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ2 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz2_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ2 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL3 OTG device endpoint-3 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl3_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL3 = (p->OTG_HS_DOEPCTL3 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl3_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL3 = (p->OTG_HS_DOEPCTL3 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl3_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL3 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl3_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL3 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT3 OTG_HS device endpoint-3 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT3_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT3_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT3_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT3_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT3_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT3_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ3 OTG_HS device endpoint-3 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz3_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ3 = (p->OTG_HS_DOEPTSIZ3 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz3_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ3 = (p->OTG_HS_DOEPTSIZ3 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz3_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ3 = (p->OTG_HS_DOEPTSIZ3 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz3_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ3 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz3_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ3 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz3_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ3 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL4 OTG device endpoint-4 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl4_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL4 = (p->OTG_HS_DOEPCTL4 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl4_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL4 = (p->OTG_HS_DOEPCTL4 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl4_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL4 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl4_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL4 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT4 OTG_HS device endpoint-4 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT4_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT4_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT4_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT4_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT4_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT4_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ4 OTG_HS device endpoint-4 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz4_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ4 = (p->OTG_HS_DOEPTSIZ4 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz4_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ4 = (p->OTG_HS_DOEPTSIZ4 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz4_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ4 = (p->OTG_HS_DOEPTSIZ4 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz4_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ4 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz4_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ4 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz4_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ4 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL5 OTG device endpoint-5 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl5_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL5 = (p->OTG_HS_DOEPCTL5 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl5_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL5 = (p->OTG_HS_DOEPCTL5 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl5_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL5 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl5_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL5 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT5 OTG_HS device endpoint-5 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT5_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT5_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT5_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT5_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT5_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT5_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ5 OTG_HS device endpoint-5 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz5_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ5 = (p->OTG_HS_DOEPTSIZ5 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz5_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ5 = (p->OTG_HS_DOEPTSIZ5 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz5_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ5 = (p->OTG_HS_DOEPTSIZ5 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz5_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ5 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz5_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ5 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz5_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ5 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL6 OTG device endpoint-6 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl6_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL6 = (p->OTG_HS_DOEPCTL6 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl6_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL6 = (p->OTG_HS_DOEPCTL6 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl6_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL6 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl6_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL6 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT6 OTG_HS device endpoint-6 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT6_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT6_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT6_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT6_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT6_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT6_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ6 OTG_HS device endpoint-6 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz6_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ6 = (p->OTG_HS_DOEPTSIZ6 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz6_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ6 = (p->OTG_HS_DOEPTSIZ6 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz6_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ6 = (p->OTG_HS_DOEPTSIZ6 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz6_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ6 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz6_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ6 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz6_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ6 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPCTL7 OTG device endpoint-7 control register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA = 1UL<<31, // Endpoint enable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS = 1UL<<30, // Endpoint disable
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM = 1UL<<29, // Set odd frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 1UL<<28, // Set DATA0 PID/Set even frame
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK = 1UL<<27, // Set NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK = 1UL<<26, // Clear NAK
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_STALL = 1UL<<21, // STALL handshake
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM = 1UL<<20, // Snoop mode
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS = 1UL<<17, // NAK status
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID = 1UL<<16, // Even odd frame/Endpoint data PID
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP = 1UL<<15, // USB active endpoint
	OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_device_otg_hs_doepctl7_set_eptyp(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL7 = (p->OTG_HS_DOEPCTL7 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP) | ((val<<18) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP); }
inline void otg1_hs_device_otg_hs_doepctl7_set_mpsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPCTL7 = (p->OTG_HS_DOEPCTL7 & ~OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doepctl7_get_eptyp(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL7 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_device_otg_hs_doepctl7_get_mpsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPCTL7 & OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ) >> 0 ; }

// OTG1_HS_DEVICE->OTG_HS_DOEPINT7 OTG_HS device endpoint-7 interrupt register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPINT7_NYET = 1UL<<14, // NYET interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT7_B2BSTUP = 1UL<<6, // Back-to-back SETUP packets received
	OTG1_HS_DEVICE_OTG_HS_DOEPINT7_OTEPDIS = 1UL<<4, // OUT token received when endpoint disabled
	OTG1_HS_DEVICE_OTG_HS_DOEPINT7_STUP = 1UL<<3, // SETUP phase done
	OTG1_HS_DEVICE_OTG_HS_DOEPINT7_EPDISD = 1UL<<1, // Endpoint disabled interrupt
	OTG1_HS_DEVICE_OTG_HS_DOEPINT7_XFRC = 1UL<<0, // Transfer completed interrupt		
};

// OTG1_HS_DEVICE->OTG_HS_DOEPTSIZ7 OTG_HS device endpoint-7 transfer size register
enum {
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT = ((1UL<<2)-1) << 29, // Received data PID/SETUP packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_device_otg_hs_doeptsiz7_set_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ7 = (p->OTG_HS_DOEPTSIZ7 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT) | ((val<<29) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz7_set_pktcnt(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ7 = (p->OTG_HS_DOEPTSIZ7 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT) | ((val<<19) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT); }
inline void otg1_hs_device_otg_hs_doeptsiz7_set_xfrsiz(struct OTG1_HS_DEVICE_Type* p, uint32_t val) { p->OTG_HS_DOEPTSIZ7 = (p->OTG_HS_DOEPTSIZ7 & ~OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ) | ((val<<0) & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ); }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz7_get_rxdpid_stupcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ7 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT) >> 29 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz7_get_pktcnt(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ7 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_device_otg_hs_doeptsiz7_get_xfrsiz(struct OTG1_HS_DEVICE_Type* p) { return (p->OTG_HS_DOEPTSIZ7 & OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ) >> 0 ; }

/* USB 1 on the go high speed */
struct OTG1_HS_GLOBAL_Type {
	__IO uint32_t OTG_HS_GOTGCTL; // @0 OTG_HS control and status register
	__IO uint32_t OTG_HS_GOTGINT; // @4 OTG_HS interrupt register
	__IO uint16_t OTG_HS_GAHBCFG; // @8 OTG_HS AHB configuration register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint32_t OTG_HS_GUSBCFG; // @12 OTG_HS USB configuration register
	__IO uint32_t OTG_HS_GRSTCTL; // @16 OTG_HS reset register
	__IO uint32_t OTG_HS_GINTSTS; // @20 OTG_HS core interrupt register
	__IO uint32_t OTG_HS_GINTMSK; // @24 OTG_HS interrupt mask register
	union {  // @28
		__I uint32_t OTG_HS_GRXSTSR_Host; // OTG_HS Receive status debug read register (host mode)
		__I uint32_t OTG_HS_GRXSTSR_Device; // OTG_HS Receive status debug read register (peripheral mode mode)
	};
	union {  // @32
		__I uint32_t OTG_HS_GRXSTSP_Host; // OTG_HS status read and pop register (host mode)
		__I uint32_t OTG_HS_GRXSTSP_Device; // OTG_HS status read and pop register (peripheral mode)
	};
	__IO uint16_t OTG_HS_GRXFSIZ; // @36 OTG_HS Receive FIFO size register
	 uint8_t RESERVED1[2]; // @38 
	union {  // @40
		__IO uint32_t OTG_HS_HNPTXFSIZ_Host; // OTG_HS nonperiodic transmit FIFO size register (host mode)
		__IO uint32_t OTG_HS_DIEPTXF0_Device; // Endpoint 0 transmit FIFO size (peripheral mode)
	};
	__I uint32_t OTG_HS_GNPTXSTS; // @44 OTG_HS nonperiodic transmit FIFO/queue status register
	 uint8_t RESERVED2[8]; // @48 
	__IO uint32_t OTG_HS_GCCFG; // @56 OTG_HS general core configuration register
	__IO uint32_t OTG_HS_CID; // @60 OTG_HS core ID register
	 uint8_t RESERVED3[20]; // @64 
	__IO uint32_t OTG_HS_GLPMCFG; // @84 OTG core LPM configuration register
	 uint8_t RESERVED4[168]; // @88 
	__IO uint32_t OTG_HS_HPTXFSIZ; // @256 OTG_HS Host periodic transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF1; // @260 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF2; // @264 OTG_HS device IN endpoint transmit FIFO size register
	 uint8_t RESERVED5[16]; // @268 
	__IO uint32_t OTG_HS_DIEPTXF3; // @284 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF4; // @288 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF5; // @292 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF6; // @296 OTG_HS device IN endpoint transmit FIFO size register
	__IO uint32_t OTG_HS_DIEPTXF7; // @300 OTG_HS device IN endpoint transmit FIFO size register
};

// OTG1_HS_GLOBAL->OTG_HS_GOTGCTL OTG_HS control and status register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD = 1UL<<19, // B-session valid
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD = 1UL<<18, // A-session valid
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT = 1UL<<17, // Long/short debounce time
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS = 1UL<<16, // Connector ID status
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN = 1UL<<12, // Embedded host enable
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN = 1UL<<11, // Device HNP enabled
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN = 1UL<<10, // Host set HNP enable
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ = 1UL<<9, // HNP request
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS = 1UL<<8, // Host negotiation success
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ = 1UL<<1, // Session request
	OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS = 1UL<<0, // Session request success		
};

// OTG1_HS_GLOBAL->OTG_HS_GOTGINT OTG_HS interrupt register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG = 1UL<<20, // ID input pin changed
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE = 1UL<<19, // Debounce done
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG = 1UL<<18, // A-device timeout change
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET = 1UL<<17, // Host negotiation detected
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG = 1UL<<9, // Host negotiation success status change
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG = 1UL<<8, // Session request success status change
	OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SEDET = 1UL<<2, // Session end detected		
};

// OTG1_HS_GLOBAL->OTG_HS_GAHBCFG OTG_HS AHB configuration register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL = 1UL<<8, // Periodic TxFIFO empty level
	OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL = 1UL<<7, // TxFIFO empty level
	OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN = 1UL<<5, // DMA enable
	OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN = ((1UL<<4)-1) << 1, // Burst length/type
	OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_GINT = 1UL<<0, // Global interrupt mask		
};
inline void otg1_hs_global_otg_hs_gahbcfg_set_hbstlen(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GAHBCFG = (p->OTG_HS_GAHBCFG & ~OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN) | ((val<<1) & OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN); }
inline uint32_t otg1_hs_global_otg_hs_gahbcfg_get_hbstlen(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GAHBCFG & OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN) >> 1 ; }

// OTG1_HS_GLOBAL->OTG_HS_GUSBCFG OTG_HS USB configuration register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD = 1UL<<30, // Forced peripheral mode
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD = 1UL<<29, // Forced host mode
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD = 1UL<<25, // ULPI interface protect disable
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI = 1UL<<24, // Indicator pass through
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI = 1UL<<23, // Indicator complement
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS = 1UL<<22, // TermSel DLine pulsing selection
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI = 1UL<<21, // ULPI external VBUS indicator
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD = 1UL<<20, // ULPI External VBUS Drive
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM = 1UL<<19, // ULPI Clock SuspendM
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR = 1UL<<18, // ULPI Auto-resume
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS = 1UL<<17, // ULPI FS/LS select
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS = 1UL<<15, // PHY Low-power clock select
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT = ((1UL<<4)-1) << 10, // USB turnaround time
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP = 1UL<<9, // HNP-capable
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP = 1UL<<8, // SRP-capable
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL = 1UL<<6, // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
	OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL = ((1UL<<3)-1) << 0, // FS timeout calibration		
};
inline void otg1_hs_global_otg_hs_gusbcfg_set_trdt(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GUSBCFG = (p->OTG_HS_GUSBCFG & ~OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT) | ((val<<10) & OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT); }
inline void otg1_hs_global_otg_hs_gusbcfg_set_tocal(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GUSBCFG = (p->OTG_HS_GUSBCFG & ~OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL); }
inline uint32_t otg1_hs_global_otg_hs_gusbcfg_get_trdt(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GUSBCFG & OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT) >> 10 ; }
inline uint32_t otg1_hs_global_otg_hs_gusbcfg_get_tocal(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GUSBCFG & OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_GRSTCTL OTG_HS reset register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL = 1UL<<31, // AHB master idle
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ = 1UL<<30, // DMA request signal enabled for USB OTG HS
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM = ((1UL<<5)-1) << 6, // TxFIFO number
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH = 1UL<<5, // TxFIFO flush
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH = 1UL<<4, // RxFIFO flush
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST = 1UL<<2, // Host frame counter reset
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST = 1UL<<1, // HCLK soft reset
	OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST = 1UL<<0, // Core soft reset		
};
inline void otg1_hs_global_otg_hs_grstctl_set_txfnum(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GRSTCTL = (p->OTG_HS_GRSTCTL & ~OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM) | ((val<<6) & OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM); }
inline uint32_t otg1_hs_global_otg_hs_grstctl_get_txfnum(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRSTCTL & OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM) >> 6 ; }

// OTG1_HS_GLOBAL->OTG_HS_GINTSTS OTG_HS core interrupt register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT = 1UL<<31, // Resume/remote wakeup detected interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT = 1UL<<30, // Session request/new session detected interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT = 1UL<<29, // Disconnect detected interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG = 1UL<<28, // Connector ID status change
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE = 1UL<<26, // Periodic TxFIFO empty
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HCINT = 1UL<<25, // Host channels interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT = 1UL<<24, // Host port interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP = 1UL<<22, // Data fetch suspended
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 1UL<<21, // Incomplete periodic transfer
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR = 1UL<<20, // Incomplete isochronous IN transfer
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT = 1UL<<19, // OUT endpoint interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT = 1UL<<18, // IN endpoint interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_EOPF = 1UL<<15, // End of periodic frame interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP = 1UL<<14, // Isochronous OUT packet dropped interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE = 1UL<<13, // Enumeration done
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBRST = 1UL<<12, // USB reset
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP = 1UL<<11, // USB suspend
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP = 1UL<<10, // Early suspend
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF = 1UL<<7, // Global OUT NAK effective
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF = 1UL<<6, // Global IN nonperiodic NAK effective
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE = 1UL<<5, // Nonperiodic TxFIFO empty
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL = 1UL<<4, // RxFIFO nonempty
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SOF = 1UL<<3, // Start of frame
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT = 1UL<<2, // OTG interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_MMIS = 1UL<<1, // Mode mismatch interrupt
	OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CMOD = 1UL<<0, // Current mode of operation		
};

// OTG1_HS_GLOBAL->OTG_HS_GINTMSK OTG_HS interrupt mask register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_WUIM = 1UL<<31, // Resume/remote wakeup detected interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM = 1UL<<30, // Session request/new session detected interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT = 1UL<<29, // Disconnect detected interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM = 1UL<<28, // Connector ID status change mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM = 1UL<<27, // LPM interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM = 1UL<<26, // Periodic TxFIFO empty mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_HCIM = 1UL<<25, // Host channels interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM = 1UL<<24, // Host port interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE = 1UL<<23, // Reset detected interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM = 1UL<<22, // Data fetch suspended mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 1UL<<21, // Incomplete periodic transfer mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM = 1UL<<20, // Incomplete isochronous IN transfer mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT = 1UL<<19, // OUT endpoints interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT = 1UL<<18, // IN endpoints interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM = 1UL<<15, // End of periodic frame interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM = 1UL<<14, // Isochronous OUT packet dropped interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM = 1UL<<13, // Enumeration done mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBRST = 1UL<<12, // USB reset mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM = 1UL<<11, // USB suspend mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM = 1UL<<10, // Early suspend mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM = 1UL<<7, // Global OUT NAK effective mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM = 1UL<<6, // Global nonperiodic IN NAK effective mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM = 1UL<<5, // Nonperiodic TxFIFO empty mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM = 1UL<<4, // Receive FIFO nonempty mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SOFM = 1UL<<3, // Start of frame mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT = 1UL<<2, // OTG interrupt mask
	OTG1_HS_GLOBAL_OTG_HS_GINTMSK_MMISM = 1UL<<1, // Mode mismatch interrupt mask		
};

// OTG1_HS_GLOBAL->OTG_HS_GRXSTSR_Host OTG_HS Receive status debug read register (host mode)
enum {
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS = ((1UL<<4)-1) << 17, // Packet status
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID = ((1UL<<2)-1) << 15, // Data PID
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT = ((1UL<<11)-1) << 4, // Byte count
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM = ((1UL<<4)-1) << 0, // Channel number		
};
inline uint32_t otg1_hs_global_otg_hs_grxstsr_host_get_pktsts(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS) >> 17 ; }
inline uint32_t otg1_hs_global_otg_hs_grxstsr_host_get_dpid(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID) >> 15 ; }
inline uint32_t otg1_hs_global_otg_hs_grxstsr_host_get_bcnt(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT) >> 4 ; }
inline uint32_t otg1_hs_global_otg_hs_grxstsr_host_get_chnum(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSR_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_GRXSTSP_Host OTG_HS status read and pop register (host mode)
enum {
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS = ((1UL<<4)-1) << 17, // Packet status
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID = ((1UL<<2)-1) << 15, // Data PID
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT = ((1UL<<11)-1) << 4, // Byte count
	OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM = ((1UL<<4)-1) << 0, // Channel number		
};
inline uint32_t otg1_hs_global_otg_hs_grxstsp_host_get_pktsts(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS) >> 17 ; }
inline uint32_t otg1_hs_global_otg_hs_grxstsp_host_get_dpid(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID) >> 15 ; }
inline uint32_t otg1_hs_global_otg_hs_grxstsp_host_get_bcnt(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT) >> 4 ; }
inline uint32_t otg1_hs_global_otg_hs_grxstsp_host_get_chnum(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GRXSTSP_Host & OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_HNPTXFSIZ_Host OTG_HS nonperiodic transmit FIFO size register (host mode)
enum {
	OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD = ((1UL<<16)-1) << 16, // Nonperiodic TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA = ((1UL<<16)-1) << 0, // Nonperiodic transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_hnptxfsiz_host_set_nptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HNPTXFSIZ_Host = (p->OTG_HS_HNPTXFSIZ_Host & ~OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD); }
inline void otg1_hs_global_otg_hs_hnptxfsiz_host_set_nptxfsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HNPTXFSIZ_Host = (p->OTG_HS_HNPTXFSIZ_Host & ~OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA); }
inline uint32_t otg1_hs_global_otg_hs_hnptxfsiz_host_get_nptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_HNPTXFSIZ_Host & OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_hnptxfsiz_host_get_nptxfsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_HNPTXFSIZ_Host & OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_GNPTXSTS OTG_HS nonperiodic transmit FIFO/queue status register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP = ((1UL<<7)-1) << 24, // Top of the nonperiodic transmit request queue
	OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV = ((1UL<<8)-1) << 16, // Nonperiodic transmit request queue space available
	OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV = ((1UL<<16)-1) << 0, // Nonperiodic TxFIFO space available		
};
inline uint32_t otg1_hs_global_otg_hs_gnptxsts_get_nptxqtop(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GNPTXSTS & OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP) >> 24 ; }
inline uint32_t otg1_hs_global_otg_hs_gnptxsts_get_nptqxsav(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GNPTXSTS & OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_gnptxsts_get_nptxfsav(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GNPTXSTS & OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_GCCFG OTG_HS general core configuration register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_VBDEN = 1UL<<21, // USB VBUS detection enable
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDEN = 1UL<<20, // Secondary detection (SD) mode enable
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDEN = 1UL<<19, // Primary detection (PD) mode enable
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDEN = 1UL<<18, // Data contact detection (DCD) mode enable
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_BCDEN = 1UL<<17, // Battery charging detector (BCD) enable
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN = 1UL<<16, // Power down
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_PS2DET = 1UL<<3, // DM pull-up detection status
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDET = 1UL<<2, // Secondary detection (SD) status
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDET = 1UL<<1, // Primary detection (PD) status
	OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDET = 1UL<<0, // Data contact detection (DCD) status		
};

// OTG1_HS_GLOBAL->OTG_HS_GLPMCFG OTG core LPM configuration register
enum {
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL = 1UL<<28, // Enable best effort service latency
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS = ((1UL<<3)-1) << 25, // LPM retry count status
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM = 1UL<<24, // Send LPM transaction
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT = ((1UL<<3)-1) << 21, // LPM retry count
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX = ((1UL<<4)-1) << 17, // LPM Channel Index
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK = 1UL<<16, // Sleep State Resume OK
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS = 1UL<<15, // Port sleep status
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST = ((1UL<<2)-1) << 13, // LPM response
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN = 1UL<<12, // L1 deep sleep enable
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS = ((1UL<<4)-1) << 8, // BESL threshold
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN = 1UL<<7, // L1 Shallow Sleep enable
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE = 1UL<<6, // bRemoteWake value
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL = ((1UL<<4)-1) << 2, // Best effort service latency
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK = 1UL<<1, // LPM token acknowledge enable
	OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN = 1UL<<0, // LPM support enable		
};
inline void otg1_hs_global_otg_hs_glpmcfg_set_lpmrcntsts(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS) | ((val<<25) & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS); }
inline void otg1_hs_global_otg_hs_glpmcfg_set_lpmrcnt(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT) | ((val<<21) & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT); }
inline void otg1_hs_global_otg_hs_glpmcfg_set_lpmchidx(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX) | ((val<<17) & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX); }
inline void otg1_hs_global_otg_hs_glpmcfg_set_lpmrst(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST) | ((val<<13) & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST); }
inline void otg1_hs_global_otg_hs_glpmcfg_set_beslthrs(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS) | ((val<<8) & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS); }
inline void otg1_hs_global_otg_hs_glpmcfg_set_besl(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_GLPMCFG = (p->OTG_HS_GLPMCFG & ~OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL) | ((val<<2) & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL); }
inline uint32_t otg1_hs_global_otg_hs_glpmcfg_get_lpmrcntsts(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS) >> 25 ; }
inline uint32_t otg1_hs_global_otg_hs_glpmcfg_get_lpmrcnt(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT) >> 21 ; }
inline uint32_t otg1_hs_global_otg_hs_glpmcfg_get_lpmchidx(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX) >> 17 ; }
inline uint32_t otg1_hs_global_otg_hs_glpmcfg_get_lpmrst(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST) >> 13 ; }
inline uint32_t otg1_hs_global_otg_hs_glpmcfg_get_beslthrs(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS) >> 8 ; }
inline uint32_t otg1_hs_global_otg_hs_glpmcfg_get_besl(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_GLPMCFG & OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL) >> 2 ; }

// OTG1_HS_GLOBAL->OTG_HS_HPTXFSIZ OTG_HS Host periodic transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD = ((1UL<<16)-1) << 16, // Host periodic TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA = ((1UL<<16)-1) << 0, // Host periodic TxFIFO start address		
};
inline void otg1_hs_global_otg_hs_hptxfsiz_set_ptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HPTXFSIZ = (p->OTG_HS_HPTXFSIZ & ~OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD); }
inline void otg1_hs_global_otg_hs_hptxfsiz_set_ptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_HPTXFSIZ = (p->OTG_HS_HPTXFSIZ & ~OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA); }
inline uint32_t otg1_hs_global_otg_hs_hptxfsiz_get_ptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_HPTXFSIZ & OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_hptxfsiz_get_ptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_HPTXFSIZ & OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF1 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf1_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF1 = (p->OTG_HS_DIEPTXF1 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf1_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF1 = (p->OTG_HS_DIEPTXF1 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf1_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF1 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf1_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF1 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF2 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf2_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF2 = (p->OTG_HS_DIEPTXF2 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf2_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF2 = (p->OTG_HS_DIEPTXF2 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf2_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF2 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf2_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF2 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF3 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf3_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF3 = (p->OTG_HS_DIEPTXF3 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf3_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF3 = (p->OTG_HS_DIEPTXF3 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf3_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF3 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf3_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF3 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF4 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf4_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF4 = (p->OTG_HS_DIEPTXF4 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf4_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF4 = (p->OTG_HS_DIEPTXF4 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf4_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF4 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf4_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF4 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF5 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf5_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF5 = (p->OTG_HS_DIEPTXF5 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf5_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF5 = (p->OTG_HS_DIEPTXF5 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf5_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF5 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf5_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF5 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF6 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf6_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF6 = (p->OTG_HS_DIEPTXF6 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf6_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF6 = (p->OTG_HS_DIEPTXF6 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf6_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF6 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf6_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF6 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA) >> 0 ; }

// OTG1_HS_GLOBAL->OTG_HS_DIEPTXF7 OTG_HS device IN endpoint transmit FIFO size register
enum {
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD = ((1UL<<16)-1) << 16, // IN endpoint TxFIFO depth
	OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA = ((1UL<<16)-1) << 0, // IN endpoint FIFOx transmit RAM start address		
};
inline void otg1_hs_global_otg_hs_dieptxf7_set_ineptxfd(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF7 = (p->OTG_HS_DIEPTXF7 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD) | ((val<<16) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD); }
inline void otg1_hs_global_otg_hs_dieptxf7_set_ineptxsa(struct OTG1_HS_GLOBAL_Type* p, uint32_t val) { p->OTG_HS_DIEPTXF7 = (p->OTG_HS_DIEPTXF7 & ~OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA) | ((val<<0) & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA); }
inline uint32_t otg1_hs_global_otg_hs_dieptxf7_get_ineptxfd(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF7 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD) >> 16 ; }
inline uint32_t otg1_hs_global_otg_hs_dieptxf7_get_ineptxsa(struct OTG1_HS_GLOBAL_Type* p) { return (p->OTG_HS_DIEPTXF7 & OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA) >> 0 ; }

/* USB 1 on the go high speed */
struct OTG1_HS_HOST_Type {
	__IO uint8_t OTG_HS_HCFG; // @0 OTG_HS host configuration register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t OTG_HS_HFIR; // @4 OTG_HS Host frame interval register
	 uint8_t RESERVED1[2]; // @6 
	__I uint32_t OTG_HS_HFNUM; // @8 OTG_HS host frame number/frame time remaining register
	 uint8_t RESERVED2[4]; // @12 
	__IO uint32_t OTG_HS_HPTXSTS; // @16 OTG_HS_Host periodic transmit FIFO/queue status register
	__I uint16_t OTG_HS_HAINT; // @20 OTG_HS Host all channels interrupt register
	 uint8_t RESERVED3[2]; // @22 
	__IO uint16_t OTG_HS_HAINTMSK; // @24 OTG_HS host all channels interrupt mask register
	 uint8_t RESERVED4[38]; // @26 
	__IO uint32_t OTG_HS_HPRT; // @64 OTG_HS host port control and status register
	 uint8_t RESERVED5[188]; // @68 
	__IO uint32_t OTG_HS_HCCHAR0; // @256 OTG_HS host channel-0 characteristics register
	__IO uint32_t OTG_HS_HCSPLT0; // @260 OTG_HS host channel-0 split control register
	__IO uint16_t OTG_HS_HCINT0; // @264 OTG_HS host channel-11 interrupt register
	 uint8_t RESERVED6[2]; // @266 
	__IO uint16_t OTG_HS_HCINTMSK0; // @268 OTG_HS host channel-11 interrupt mask register
	 uint8_t RESERVED7[2]; // @270 
	__IO uint32_t OTG_HS_HCTSIZ0; // @272 OTG_HS host channel-11 transfer size register
	__IO uint32_t OTG_HS_HCDMA0; // @276 OTG_HS host channel-0 DMA address register
	 uint8_t RESERVED8[8]; // @280 
	__IO uint32_t OTG_HS_HCCHAR1; // @288 OTG_HS host channel-1 characteristics register
	__IO uint32_t OTG_HS_HCSPLT1; // @292 OTG_HS host channel-1 split control register
	__IO uint16_t OTG_HS_HCINT1; // @296 OTG_HS host channel-1 interrupt register
	 uint8_t RESERVED9[2]; // @298 
	__IO uint16_t OTG_HS_HCINTMSK1; // @300 OTG_HS host channel-1 interrupt mask register
	 uint8_t RESERVED10[2]; // @302 
	__IO uint32_t OTG_HS_HCTSIZ1; // @304 OTG_HS host channel-1 transfer size register
	__IO uint32_t OTG_HS_HCDMA1; // @308 OTG_HS host channel-1 DMA address register
	 uint8_t RESERVED11[8]; // @312 
	__IO uint32_t OTG_HS_HCCHAR2; // @320 OTG_HS host channel-2 characteristics register
	__IO uint32_t OTG_HS_HCSPLT2; // @324 OTG_HS host channel-2 split control register
	__IO uint16_t OTG_HS_HCINT2; // @328 OTG_HS host channel-2 interrupt register
	 uint8_t RESERVED12[2]; // @330 
	__IO uint16_t OTG_HS_HCINTMSK2; // @332 OTG_HS host channel-2 interrupt mask register
	 uint8_t RESERVED13[2]; // @334 
	__IO uint32_t OTG_HS_HCTSIZ2; // @336 OTG_HS host channel-2 transfer size register
	__IO uint32_t OTG_HS_HCDMA2; // @340 OTG_HS host channel-2 DMA address register
	 uint8_t RESERVED14[8]; // @344 
	__IO uint32_t OTG_HS_HCCHAR3; // @352 OTG_HS host channel-3 characteristics register
	__IO uint32_t OTG_HS_HCSPLT3; // @356 OTG_HS host channel-3 split control register
	__IO uint16_t OTG_HS_HCINT3; // @360 OTG_HS host channel-3 interrupt register
	 uint8_t RESERVED15[2]; // @362 
	__IO uint16_t OTG_HS_HCINTMSK3; // @364 OTG_HS host channel-3 interrupt mask register
	 uint8_t RESERVED16[2]; // @366 
	__IO uint32_t OTG_HS_HCTSIZ3; // @368 OTG_HS host channel-3 transfer size register
	__IO uint32_t OTG_HS_HCDMA3; // @372 OTG_HS host channel-3 DMA address register
	 uint8_t RESERVED17[8]; // @376 
	__IO uint32_t OTG_HS_HCCHAR4; // @384 OTG_HS host channel-4 characteristics register
	__IO uint32_t OTG_HS_HCSPLT4; // @388 OTG_HS host channel-4 split control register
	__IO uint16_t OTG_HS_HCINT4; // @392 OTG_HS host channel-4 interrupt register
	 uint8_t RESERVED18[2]; // @394 
	__IO uint16_t OTG_HS_HCINTMSK4; // @396 OTG_HS host channel-4 interrupt mask register
	 uint8_t RESERVED19[2]; // @398 
	__IO uint32_t OTG_HS_HCTSIZ4; // @400 OTG_HS host channel-4 transfer size register
	__IO uint32_t OTG_HS_HCDMA4; // @404 OTG_HS host channel-4 DMA address register
	 uint8_t RESERVED20[8]; // @408 
	__IO uint32_t OTG_HS_HCCHAR5; // @416 OTG_HS host channel-5 characteristics register
	__IO uint32_t OTG_HS_HCSPLT5; // @420 OTG_HS host channel-5 split control register
	__IO uint16_t OTG_HS_HCINT5; // @424 OTG_HS host channel-5 interrupt register
	 uint8_t RESERVED21[2]; // @426 
	__IO uint16_t OTG_HS_HCINTMSK5; // @428 OTG_HS host channel-5 interrupt mask register
	 uint8_t RESERVED22[2]; // @430 
	__IO uint32_t OTG_HS_HCTSIZ5; // @432 OTG_HS host channel-5 transfer size register
	__IO uint32_t OTG_HS_HCDMA5; // @436 OTG_HS host channel-5 DMA address register
	 uint8_t RESERVED23[8]; // @440 
	__IO uint32_t OTG_HS_HCCHAR6; // @448 OTG_HS host channel-6 characteristics register
	__IO uint32_t OTG_HS_HCSPLT6; // @452 OTG_HS host channel-6 split control register
	__IO uint16_t OTG_HS_HCINT6; // @456 OTG_HS host channel-6 interrupt register
	 uint8_t RESERVED24[2]; // @458 
	__IO uint16_t OTG_HS_HCINTMSK6; // @460 OTG_HS host channel-6 interrupt mask register
	 uint8_t RESERVED25[2]; // @462 
	__IO uint32_t OTG_HS_HCTSIZ6; // @464 OTG_HS host channel-6 transfer size register
	__IO uint32_t OTG_HS_HCDMA6; // @468 OTG_HS host channel-6 DMA address register
	 uint8_t RESERVED26[8]; // @472 
	__IO uint32_t OTG_HS_HCCHAR7; // @480 OTG_HS host channel-7 characteristics register
	__IO uint32_t OTG_HS_HCSPLT7; // @484 OTG_HS host channel-7 split control register
	__IO uint16_t OTG_HS_HCINT7; // @488 OTG_HS host channel-7 interrupt register
	 uint8_t RESERVED27[2]; // @490 
	__IO uint16_t OTG_HS_HCINTMSK7; // @492 OTG_HS host channel-7 interrupt mask register
	 uint8_t RESERVED28[2]; // @494 
	__IO uint32_t OTG_HS_HCTSIZ7; // @496 OTG_HS host channel-7 transfer size register
	__IO uint32_t OTG_HS_HCDMA7; // @500 OTG_HS host channel-7 DMA address register
	 uint8_t RESERVED29[8]; // @504 
	__IO uint32_t OTG_HS_HCCHAR8; // @512 OTG_HS host channel-8 characteristics register
	__IO uint32_t OTG_HS_HCSPLT8; // @516 OTG_HS host channel-8 split control register
	__IO uint16_t OTG_HS_HCINT8; // @520 OTG_HS host channel-8 interrupt register
	 uint8_t RESERVED30[2]; // @522 
	__IO uint16_t OTG_HS_HCINTMSK8; // @524 OTG_HS host channel-8 interrupt mask register
	 uint8_t RESERVED31[2]; // @526 
	__IO uint32_t OTG_HS_HCTSIZ8; // @528 OTG_HS host channel-8 transfer size register
	__IO uint32_t OTG_HS_HCDMA8; // @532 OTG_HS host channel-8 DMA address register
	 uint8_t RESERVED32[8]; // @536 
	__IO uint32_t OTG_HS_HCCHAR9; // @544 OTG_HS host channel-9 characteristics register
	__IO uint32_t OTG_HS_HCSPLT9; // @548 OTG_HS host channel-9 split control register
	__IO uint16_t OTG_HS_HCINT9; // @552 OTG_HS host channel-9 interrupt register
	 uint8_t RESERVED33[2]; // @554 
	__IO uint16_t OTG_HS_HCINTMSK9; // @556 OTG_HS host channel-9 interrupt mask register
	 uint8_t RESERVED34[2]; // @558 
	__IO uint32_t OTG_HS_HCTSIZ9; // @560 OTG_HS host channel-9 transfer size register
	__IO uint32_t OTG_HS_HCDMA9; // @564 OTG_HS host channel-9 DMA address register
	 uint8_t RESERVED35[8]; // @568 
	__IO uint32_t OTG_HS_HCCHAR10; // @576 OTG_HS host channel-10 characteristics register
	__IO uint32_t OTG_HS_HCSPLT10; // @580 OTG_HS host channel-10 split control register
	__IO uint16_t OTG_HS_HCINT10; // @584 OTG_HS host channel-10 interrupt register
	 uint8_t RESERVED36[2]; // @586 
	__IO uint16_t OTG_HS_HCINTMSK10; // @588 OTG_HS host channel-10 interrupt mask register
	 uint8_t RESERVED37[2]; // @590 
	__IO uint32_t OTG_HS_HCTSIZ10; // @592 OTG_HS host channel-10 transfer size register
	__IO uint32_t OTG_HS_HCDMA10; // @596 OTG_HS host channel-10 DMA address register
	 uint8_t RESERVED38[8]; // @600 
	__IO uint32_t OTG_HS_HCCHAR11; // @608 OTG_HS host channel-11 characteristics register
	__IO uint32_t OTG_HS_HCSPLT11; // @612 OTG_HS host channel-11 split control register
	__IO uint16_t OTG_HS_HCINT11; // @616 OTG_HS host channel-11 interrupt register
	 uint8_t RESERVED39[2]; // @618 
	__IO uint16_t OTG_HS_HCINTMSK11; // @620 OTG_HS host channel-11 interrupt mask register
	 uint8_t RESERVED40[2]; // @622 
	__IO uint32_t OTG_HS_HCTSIZ11; // @624 OTG_HS host channel-11 transfer size register
	__IO uint32_t OTG_HS_HCDMA11; // @628 OTG_HS host channel-11 DMA address register
	__IO uint32_t OTG_HS_HCCHAR12; // @632 OTG_HS host channel-12 characteristics register
	__IO uint32_t OTG_HS_HCSPLT12; // @636 OTG_HS host channel-12 split control register
	__IO uint16_t OTG_HS_HCINT12; // @640 OTG_HS host channel-12 interrupt register
	 uint8_t RESERVED41[2]; // @642 
	__IO uint16_t OTG_HS_HCINTMSK12; // @644 OTG_HS host channel-12 interrupt mask register
	 uint8_t RESERVED42[2]; // @646 
	__IO uint32_t OTG_HS_HCTSIZ12; // @648 OTG_HS host channel-12 transfer size register
	__IO uint32_t OTG_HS_HCDMA12; // @652 OTG_HS host channel-12 DMA address register
	__IO uint32_t OTG_HS_HCCHAR13; // @656 OTG_HS host channel-13 characteristics register
	__IO uint32_t OTG_HS_HCSPLT13; // @660 OTG_HS host channel-13 split control register
	__IO uint16_t OTG_HS_HCINT13; // @664 OTG_HS host channel-13 interrupt register
	 uint8_t RESERVED43[2]; // @666 
	__IO uint16_t OTG_HS_HCINTMSK13; // @668 OTG_HS host channel-13 interrupt mask register
	 uint8_t RESERVED44[2]; // @670 
	__IO uint32_t OTG_HS_HCTSIZ13; // @672 OTG_HS host channel-13 transfer size register
	__IO uint32_t OTG_HS_HCDMA13; // @676 OTG_HS host channel-13 DMA address register
	__IO uint32_t OTG_HS_HCCHAR14; // @680 OTG_HS host channel-14 characteristics register
	__IO uint32_t OTG_HS_HCSPLT14; // @684 OTG_HS host channel-14 split control register
	__IO uint16_t OTG_HS_HCINT14; // @688 OTG_HS host channel-14 interrupt register
	 uint8_t RESERVED45[2]; // @690 
	__IO uint16_t OTG_HS_HCINTMSK14; // @692 OTG_HS host channel-14 interrupt mask register
	 uint8_t RESERVED46[2]; // @694 
	__IO uint32_t OTG_HS_HCTSIZ14; // @696 OTG_HS host channel-14 transfer size register
	__IO uint32_t OTG_HS_HCDMA14; // @700 OTG_HS host channel-14 DMA address register
	__IO uint32_t OTG_HS_HCCHAR15; // @704 OTG_HS host channel-15 characteristics register
	__IO uint32_t OTG_HS_HCSPLT15; // @708 OTG_HS host channel-15 split control register
	__IO uint16_t OTG_HS_HCINT15; // @712 OTG_HS host channel-15 interrupt register
	 uint8_t RESERVED47[2]; // @714 
	__IO uint16_t OTG_HS_HCINTMSK15; // @716 OTG_HS host channel-15 interrupt mask register
	 uint8_t RESERVED48[2]; // @718 
	__IO uint32_t OTG_HS_HCTSIZ15; // @720 OTG_HS host channel-15 transfer size register
	__IO uint32_t OTG_HS_HCDMA15; // @724 OTG_HS host channel-15 DMA address register
};

// OTG1_HS_HOST->OTG_HS_HCFG OTG_HS host configuration register
enum {
	OTG1_HS_HOST_OTG_HS_HCFG_FSLSS = 1UL<<2, // FS- and LS-only support
	OTG1_HS_HOST_OTG_HS_HCFG_FSLSPCS = ((1UL<<2)-1) << 0, // FS/LS PHY clock select		
};
inline void otg1_hs_host_otg_hs_hcfg_set_fslspcs(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCFG = (p->OTG_HS_HCFG & ~OTG1_HS_HOST_OTG_HS_HCFG_FSLSPCS) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCFG_FSLSPCS); }
inline uint32_t otg1_hs_host_otg_hs_hcfg_get_fslspcs(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCFG & OTG1_HS_HOST_OTG_HS_HCFG_FSLSPCS) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HFNUM OTG_HS host frame number/frame time remaining register
enum {
	OTG1_HS_HOST_OTG_HS_HFNUM_FTREM = ((1UL<<16)-1) << 16, // Frame time remaining
	OTG1_HS_HOST_OTG_HS_HFNUM_FRNUM = ((1UL<<16)-1) << 0, // Frame number		
};
inline uint32_t otg1_hs_host_otg_hs_hfnum_get_ftrem(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HFNUM & OTG1_HS_HOST_OTG_HS_HFNUM_FTREM) >> 16 ; }
inline uint32_t otg1_hs_host_otg_hs_hfnum_get_frnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HFNUM & OTG1_HS_HOST_OTG_HS_HFNUM_FRNUM) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HPTXSTS OTG_HS_Host periodic transmit FIFO/queue status register
enum {
	OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP = ((1UL<<8)-1) << 24, // Top of the periodic transmit request queue
	OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV = ((1UL<<8)-1) << 16, // Periodic transmit request queue space available
	OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL = ((1UL<<16)-1) << 0, // Periodic transmit data FIFO space available		
};
inline void otg1_hs_host_otg_hs_hptxsts_set_ptxqtop(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPTXSTS = (p->OTG_HS_HPTXSTS & ~OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP) | ((val<<24) & OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP); }
inline void otg1_hs_host_otg_hs_hptxsts_set_ptxqsav(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPTXSTS = (p->OTG_HS_HPTXSTS & ~OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV) | ((val<<16) & OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV); }
inline void otg1_hs_host_otg_hs_hptxsts_set_ptxfsavl(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPTXSTS = (p->OTG_HS_HPTXSTS & ~OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL); }
inline uint32_t otg1_hs_host_otg_hs_hptxsts_get_ptxqtop(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HPTXSTS & OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP) >> 24 ; }
inline uint32_t otg1_hs_host_otg_hs_hptxsts_get_ptxqsav(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HPTXSTS & OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV) >> 16 ; }
inline uint32_t otg1_hs_host_otg_hs_hptxsts_get_ptxfsavl(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HPTXSTS & OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HPRT OTG_HS host port control and status register
enum {
	OTG1_HS_HOST_OTG_HS_HPRT_PSPD = ((1UL<<2)-1) << 17, // Port speed
	OTG1_HS_HOST_OTG_HS_HPRT_PTCTL = ((1UL<<4)-1) << 13, // Port test control
	OTG1_HS_HOST_OTG_HS_HPRT_PPWR = 1UL<<12, // Port power
	OTG1_HS_HOST_OTG_HS_HPRT_PLSTS = ((1UL<<2)-1) << 10, // Port line status
	OTG1_HS_HOST_OTG_HS_HPRT_PRST = 1UL<<8, // Port reset
	OTG1_HS_HOST_OTG_HS_HPRT_PSUSP = 1UL<<7, // Port suspend
	OTG1_HS_HOST_OTG_HS_HPRT_PRES = 1UL<<6, // Port resume
	OTG1_HS_HOST_OTG_HS_HPRT_POCCHNG = 1UL<<5, // Port overcurrent change
	OTG1_HS_HOST_OTG_HS_HPRT_POCA = 1UL<<4, // Port overcurrent active
	OTG1_HS_HOST_OTG_HS_HPRT_PENCHNG = 1UL<<3, // Port enable/disable change
	OTG1_HS_HOST_OTG_HS_HPRT_PENA = 1UL<<2, // Port enable
	OTG1_HS_HOST_OTG_HS_HPRT_PCDET = 1UL<<1, // Port connect detected
	OTG1_HS_HOST_OTG_HS_HPRT_PCSTS = 1UL<<0, // Port connect status		
};
inline void otg1_hs_host_otg_hs_hprt_set_pspd(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPRT = (p->OTG_HS_HPRT & ~OTG1_HS_HOST_OTG_HS_HPRT_PSPD) | ((val<<17) & OTG1_HS_HOST_OTG_HS_HPRT_PSPD); }
inline void otg1_hs_host_otg_hs_hprt_set_ptctl(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPRT = (p->OTG_HS_HPRT & ~OTG1_HS_HOST_OTG_HS_HPRT_PTCTL) | ((val<<13) & OTG1_HS_HOST_OTG_HS_HPRT_PTCTL); }
inline void otg1_hs_host_otg_hs_hprt_set_plsts(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HPRT = (p->OTG_HS_HPRT & ~OTG1_HS_HOST_OTG_HS_HPRT_PLSTS) | ((val<<10) & OTG1_HS_HOST_OTG_HS_HPRT_PLSTS); }
inline uint32_t otg1_hs_host_otg_hs_hprt_get_pspd(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HPRT & OTG1_HS_HOST_OTG_HS_HPRT_PSPD) >> 17 ; }
inline uint32_t otg1_hs_host_otg_hs_hprt_get_ptctl(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HPRT & OTG1_HS_HOST_OTG_HS_HPRT_PTCTL) >> 13 ; }
inline uint32_t otg1_hs_host_otg_hs_hprt_get_plsts(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HPRT & OTG1_HS_HOST_OTG_HS_HPRT_PLSTS) >> 10 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR0 OTG_HS host channel-0 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR0_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR0_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR0_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR0_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR0_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR0_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR0_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR0_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR0_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR0_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar0_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG1_HS_HOST_OTG_HS_HCCHAR0_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR0_DAD); }
inline void otg1_hs_host_otg_hs_hcchar0_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG1_HS_HOST_OTG_HS_HCCHAR0_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR0_MC); }
inline void otg1_hs_host_otg_hs_hcchar0_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG1_HS_HOST_OTG_HS_HCCHAR0_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR0_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar0_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG1_HS_HOST_OTG_HS_HCCHAR0_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR0_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar0_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR0 = (p->OTG_HS_HCCHAR0 & ~OTG1_HS_HOST_OTG_HS_HCCHAR0_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR0_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar0_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG1_HS_HOST_OTG_HS_HCCHAR0_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar0_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG1_HS_HOST_OTG_HS_HCCHAR0_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar0_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG1_HS_HOST_OTG_HS_HCCHAR0_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar0_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG1_HS_HOST_OTG_HS_HCCHAR0_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar0_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR0 & OTG1_HS_HOST_OTG_HS_HCCHAR0_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT0 OTG_HS host channel-0 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT0_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT0_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT0_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT0_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT0_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt0_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT0 = (p->OTG_HS_HCSPLT0 & ~OTG1_HS_HOST_OTG_HS_HCSPLT0_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT0_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt0_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT0 = (p->OTG_HS_HCSPLT0 & ~OTG1_HS_HOST_OTG_HS_HCSPLT0_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT0_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt0_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT0 = (p->OTG_HS_HCSPLT0 & ~OTG1_HS_HOST_OTG_HS_HCSPLT0_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT0_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt0_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT0 & OTG1_HS_HOST_OTG_HS_HCSPLT0_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt0_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT0 & OTG1_HS_HOST_OTG_HS_HCSPLT0_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt0_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT0 & OTG1_HS_HOST_OTG_HS_HCSPLT0_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT0 OTG_HS host channel-11 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT0_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT0_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT0_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT0_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT0_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT0_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT0_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT0_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT0_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT0_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT0_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK0 OTG_HS host channel-11 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK0_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ0 OTG_HS host channel-11 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ0_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz0_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ0 = (p->OTG_HS_HCTSIZ0 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ0_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ0_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz0_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ0 = (p->OTG_HS_HCTSIZ0 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz0_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ0 = (p->OTG_HS_HCTSIZ0 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz0_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ0 & OTG1_HS_HOST_OTG_HS_HCTSIZ0_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz0_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ0 & OTG1_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz0_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ0 & OTG1_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR1 OTG_HS host channel-1 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR1_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR1_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR1_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR1_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR1_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR1_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR1_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR1_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR1_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR1_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar1_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG1_HS_HOST_OTG_HS_HCCHAR1_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR1_DAD); }
inline void otg1_hs_host_otg_hs_hcchar1_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG1_HS_HOST_OTG_HS_HCCHAR1_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR1_MC); }
inline void otg1_hs_host_otg_hs_hcchar1_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG1_HS_HOST_OTG_HS_HCCHAR1_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR1_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar1_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG1_HS_HOST_OTG_HS_HCCHAR1_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR1_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar1_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR1 = (p->OTG_HS_HCCHAR1 & ~OTG1_HS_HOST_OTG_HS_HCCHAR1_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR1_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar1_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG1_HS_HOST_OTG_HS_HCCHAR1_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar1_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG1_HS_HOST_OTG_HS_HCCHAR1_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar1_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG1_HS_HOST_OTG_HS_HCCHAR1_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar1_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG1_HS_HOST_OTG_HS_HCCHAR1_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar1_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR1 & OTG1_HS_HOST_OTG_HS_HCCHAR1_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT1 OTG_HS host channel-1 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT1_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT1_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT1_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT1_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT1_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt1_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT1 = (p->OTG_HS_HCSPLT1 & ~OTG1_HS_HOST_OTG_HS_HCSPLT1_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT1_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt1_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT1 = (p->OTG_HS_HCSPLT1 & ~OTG1_HS_HOST_OTG_HS_HCSPLT1_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT1_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt1_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT1 = (p->OTG_HS_HCSPLT1 & ~OTG1_HS_HOST_OTG_HS_HCSPLT1_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT1_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt1_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT1 & OTG1_HS_HOST_OTG_HS_HCSPLT1_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt1_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT1 & OTG1_HS_HOST_OTG_HS_HCSPLT1_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt1_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT1 & OTG1_HS_HOST_OTG_HS_HCSPLT1_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT1 OTG_HS host channel-1 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT1_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT1_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT1_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT1_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT1_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT1_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT1_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT1_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT1_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT1_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT1_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK1 OTG_HS host channel-1 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK1_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ1 OTG_HS host channel-1 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ1_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz1_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ1 = (p->OTG_HS_HCTSIZ1 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ1_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ1_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz1_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ1 = (p->OTG_HS_HCTSIZ1 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz1_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ1 = (p->OTG_HS_HCTSIZ1 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz1_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ1 & OTG1_HS_HOST_OTG_HS_HCTSIZ1_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz1_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ1 & OTG1_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz1_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ1 & OTG1_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR2 OTG_HS host channel-2 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR2_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR2_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR2_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR2_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR2_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR2_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR2_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR2_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR2_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR2_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar2_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG1_HS_HOST_OTG_HS_HCCHAR2_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR2_DAD); }
inline void otg1_hs_host_otg_hs_hcchar2_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG1_HS_HOST_OTG_HS_HCCHAR2_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR2_MC); }
inline void otg1_hs_host_otg_hs_hcchar2_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG1_HS_HOST_OTG_HS_HCCHAR2_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR2_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar2_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG1_HS_HOST_OTG_HS_HCCHAR2_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR2_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar2_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR2 = (p->OTG_HS_HCCHAR2 & ~OTG1_HS_HOST_OTG_HS_HCCHAR2_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR2_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar2_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG1_HS_HOST_OTG_HS_HCCHAR2_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar2_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG1_HS_HOST_OTG_HS_HCCHAR2_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar2_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG1_HS_HOST_OTG_HS_HCCHAR2_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar2_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG1_HS_HOST_OTG_HS_HCCHAR2_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar2_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR2 & OTG1_HS_HOST_OTG_HS_HCCHAR2_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT2 OTG_HS host channel-2 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT2_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT2_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT2_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT2_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT2_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt2_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT2 = (p->OTG_HS_HCSPLT2 & ~OTG1_HS_HOST_OTG_HS_HCSPLT2_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT2_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt2_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT2 = (p->OTG_HS_HCSPLT2 & ~OTG1_HS_HOST_OTG_HS_HCSPLT2_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT2_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt2_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT2 = (p->OTG_HS_HCSPLT2 & ~OTG1_HS_HOST_OTG_HS_HCSPLT2_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT2_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt2_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT2 & OTG1_HS_HOST_OTG_HS_HCSPLT2_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt2_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT2 & OTG1_HS_HOST_OTG_HS_HCSPLT2_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt2_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT2 & OTG1_HS_HOST_OTG_HS_HCSPLT2_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT2 OTG_HS host channel-2 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT2_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT2_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT2_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT2_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT2_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT2_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT2_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT2_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT2_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT2_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT2_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK2 OTG_HS host channel-2 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK2_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ2 OTG_HS host channel-2 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ2_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz2_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ2 = (p->OTG_HS_HCTSIZ2 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ2_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ2_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz2_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ2 = (p->OTG_HS_HCTSIZ2 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz2_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ2 = (p->OTG_HS_HCTSIZ2 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz2_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ2 & OTG1_HS_HOST_OTG_HS_HCTSIZ2_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz2_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ2 & OTG1_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz2_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ2 & OTG1_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR3 OTG_HS host channel-3 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR3_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR3_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR3_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR3_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR3_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR3_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR3_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR3_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR3_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR3_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar3_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG1_HS_HOST_OTG_HS_HCCHAR3_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR3_DAD); }
inline void otg1_hs_host_otg_hs_hcchar3_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG1_HS_HOST_OTG_HS_HCCHAR3_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR3_MC); }
inline void otg1_hs_host_otg_hs_hcchar3_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG1_HS_HOST_OTG_HS_HCCHAR3_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR3_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar3_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG1_HS_HOST_OTG_HS_HCCHAR3_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR3_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar3_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR3 = (p->OTG_HS_HCCHAR3 & ~OTG1_HS_HOST_OTG_HS_HCCHAR3_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR3_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar3_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG1_HS_HOST_OTG_HS_HCCHAR3_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar3_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG1_HS_HOST_OTG_HS_HCCHAR3_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar3_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG1_HS_HOST_OTG_HS_HCCHAR3_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar3_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG1_HS_HOST_OTG_HS_HCCHAR3_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar3_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR3 & OTG1_HS_HOST_OTG_HS_HCCHAR3_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT3 OTG_HS host channel-3 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT3_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT3_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT3_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT3_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT3_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt3_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT3 = (p->OTG_HS_HCSPLT3 & ~OTG1_HS_HOST_OTG_HS_HCSPLT3_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT3_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt3_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT3 = (p->OTG_HS_HCSPLT3 & ~OTG1_HS_HOST_OTG_HS_HCSPLT3_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT3_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt3_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT3 = (p->OTG_HS_HCSPLT3 & ~OTG1_HS_HOST_OTG_HS_HCSPLT3_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT3_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt3_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT3 & OTG1_HS_HOST_OTG_HS_HCSPLT3_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt3_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT3 & OTG1_HS_HOST_OTG_HS_HCSPLT3_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt3_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT3 & OTG1_HS_HOST_OTG_HS_HCSPLT3_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT3 OTG_HS host channel-3 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT3_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT3_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT3_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT3_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT3_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT3_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT3_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT3_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT3_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT3_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT3_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK3 OTG_HS host channel-3 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK3_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ3 OTG_HS host channel-3 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ3_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz3_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ3 = (p->OTG_HS_HCTSIZ3 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ3_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ3_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz3_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ3 = (p->OTG_HS_HCTSIZ3 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz3_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ3 = (p->OTG_HS_HCTSIZ3 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz3_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ3 & OTG1_HS_HOST_OTG_HS_HCTSIZ3_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz3_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ3 & OTG1_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz3_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ3 & OTG1_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR4 OTG_HS host channel-4 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR4_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR4_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR4_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR4_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR4_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR4_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR4_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR4_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR4_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR4_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar4_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG1_HS_HOST_OTG_HS_HCCHAR4_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR4_DAD); }
inline void otg1_hs_host_otg_hs_hcchar4_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG1_HS_HOST_OTG_HS_HCCHAR4_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR4_MC); }
inline void otg1_hs_host_otg_hs_hcchar4_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG1_HS_HOST_OTG_HS_HCCHAR4_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR4_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar4_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG1_HS_HOST_OTG_HS_HCCHAR4_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR4_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar4_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR4 = (p->OTG_HS_HCCHAR4 & ~OTG1_HS_HOST_OTG_HS_HCCHAR4_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR4_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar4_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG1_HS_HOST_OTG_HS_HCCHAR4_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar4_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG1_HS_HOST_OTG_HS_HCCHAR4_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar4_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG1_HS_HOST_OTG_HS_HCCHAR4_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar4_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG1_HS_HOST_OTG_HS_HCCHAR4_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar4_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR4 & OTG1_HS_HOST_OTG_HS_HCCHAR4_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT4 OTG_HS host channel-4 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT4_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT4_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT4_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT4_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT4_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt4_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT4 = (p->OTG_HS_HCSPLT4 & ~OTG1_HS_HOST_OTG_HS_HCSPLT4_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT4_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt4_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT4 = (p->OTG_HS_HCSPLT4 & ~OTG1_HS_HOST_OTG_HS_HCSPLT4_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT4_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt4_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT4 = (p->OTG_HS_HCSPLT4 & ~OTG1_HS_HOST_OTG_HS_HCSPLT4_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT4_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt4_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT4 & OTG1_HS_HOST_OTG_HS_HCSPLT4_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt4_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT4 & OTG1_HS_HOST_OTG_HS_HCSPLT4_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt4_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT4 & OTG1_HS_HOST_OTG_HS_HCSPLT4_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT4 OTG_HS host channel-4 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT4_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT4_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT4_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT4_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT4_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT4_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT4_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT4_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT4_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT4_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT4_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK4 OTG_HS host channel-4 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK4_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ4 OTG_HS host channel-4 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ4_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz4_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ4 = (p->OTG_HS_HCTSIZ4 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ4_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ4_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz4_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ4 = (p->OTG_HS_HCTSIZ4 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz4_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ4 = (p->OTG_HS_HCTSIZ4 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz4_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ4 & OTG1_HS_HOST_OTG_HS_HCTSIZ4_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz4_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ4 & OTG1_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz4_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ4 & OTG1_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR5 OTG_HS host channel-5 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR5_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR5_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR5_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR5_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR5_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR5_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR5_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR5_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR5_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR5_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar5_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG1_HS_HOST_OTG_HS_HCCHAR5_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR5_DAD); }
inline void otg1_hs_host_otg_hs_hcchar5_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG1_HS_HOST_OTG_HS_HCCHAR5_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR5_MC); }
inline void otg1_hs_host_otg_hs_hcchar5_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG1_HS_HOST_OTG_HS_HCCHAR5_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR5_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar5_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG1_HS_HOST_OTG_HS_HCCHAR5_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR5_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar5_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR5 = (p->OTG_HS_HCCHAR5 & ~OTG1_HS_HOST_OTG_HS_HCCHAR5_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR5_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar5_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG1_HS_HOST_OTG_HS_HCCHAR5_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar5_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG1_HS_HOST_OTG_HS_HCCHAR5_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar5_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG1_HS_HOST_OTG_HS_HCCHAR5_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar5_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG1_HS_HOST_OTG_HS_HCCHAR5_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar5_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR5 & OTG1_HS_HOST_OTG_HS_HCCHAR5_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT5 OTG_HS host channel-5 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT5_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT5_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT5_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT5_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT5_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt5_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT5 = (p->OTG_HS_HCSPLT5 & ~OTG1_HS_HOST_OTG_HS_HCSPLT5_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT5_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt5_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT5 = (p->OTG_HS_HCSPLT5 & ~OTG1_HS_HOST_OTG_HS_HCSPLT5_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT5_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt5_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT5 = (p->OTG_HS_HCSPLT5 & ~OTG1_HS_HOST_OTG_HS_HCSPLT5_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT5_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt5_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT5 & OTG1_HS_HOST_OTG_HS_HCSPLT5_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt5_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT5 & OTG1_HS_HOST_OTG_HS_HCSPLT5_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt5_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT5 & OTG1_HS_HOST_OTG_HS_HCSPLT5_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT5 OTG_HS host channel-5 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT5_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT5_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT5_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT5_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT5_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT5_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT5_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT5_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT5_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT5_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT5_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK5 OTG_HS host channel-5 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK5_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ5 OTG_HS host channel-5 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ5_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz5_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ5 = (p->OTG_HS_HCTSIZ5 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ5_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ5_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz5_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ5 = (p->OTG_HS_HCTSIZ5 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz5_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ5 = (p->OTG_HS_HCTSIZ5 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz5_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ5 & OTG1_HS_HOST_OTG_HS_HCTSIZ5_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz5_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ5 & OTG1_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz5_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ5 & OTG1_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR6 OTG_HS host channel-6 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR6_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR6_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR6_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR6_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR6_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR6_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR6_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR6_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR6_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR6_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar6_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG1_HS_HOST_OTG_HS_HCCHAR6_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR6_DAD); }
inline void otg1_hs_host_otg_hs_hcchar6_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG1_HS_HOST_OTG_HS_HCCHAR6_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR6_MC); }
inline void otg1_hs_host_otg_hs_hcchar6_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG1_HS_HOST_OTG_HS_HCCHAR6_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR6_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar6_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG1_HS_HOST_OTG_HS_HCCHAR6_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR6_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar6_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR6 = (p->OTG_HS_HCCHAR6 & ~OTG1_HS_HOST_OTG_HS_HCCHAR6_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR6_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar6_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG1_HS_HOST_OTG_HS_HCCHAR6_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar6_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG1_HS_HOST_OTG_HS_HCCHAR6_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar6_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG1_HS_HOST_OTG_HS_HCCHAR6_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar6_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG1_HS_HOST_OTG_HS_HCCHAR6_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar6_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR6 & OTG1_HS_HOST_OTG_HS_HCCHAR6_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT6 OTG_HS host channel-6 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT6_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT6_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT6_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT6_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT6_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt6_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT6 = (p->OTG_HS_HCSPLT6 & ~OTG1_HS_HOST_OTG_HS_HCSPLT6_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT6_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt6_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT6 = (p->OTG_HS_HCSPLT6 & ~OTG1_HS_HOST_OTG_HS_HCSPLT6_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT6_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt6_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT6 = (p->OTG_HS_HCSPLT6 & ~OTG1_HS_HOST_OTG_HS_HCSPLT6_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT6_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt6_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT6 & OTG1_HS_HOST_OTG_HS_HCSPLT6_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt6_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT6 & OTG1_HS_HOST_OTG_HS_HCSPLT6_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt6_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT6 & OTG1_HS_HOST_OTG_HS_HCSPLT6_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT6 OTG_HS host channel-6 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT6_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT6_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT6_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT6_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT6_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT6_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT6_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT6_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT6_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT6_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT6_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK6 OTG_HS host channel-6 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK6_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ6 OTG_HS host channel-6 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ6_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz6_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ6 = (p->OTG_HS_HCTSIZ6 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ6_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ6_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz6_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ6 = (p->OTG_HS_HCTSIZ6 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz6_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ6 = (p->OTG_HS_HCTSIZ6 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz6_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ6 & OTG1_HS_HOST_OTG_HS_HCTSIZ6_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz6_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ6 & OTG1_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz6_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ6 & OTG1_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR7 OTG_HS host channel-7 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR7_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR7_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR7_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR7_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR7_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR7_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR7_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR7_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR7_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR7_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar7_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG1_HS_HOST_OTG_HS_HCCHAR7_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR7_DAD); }
inline void otg1_hs_host_otg_hs_hcchar7_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG1_HS_HOST_OTG_HS_HCCHAR7_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR7_MC); }
inline void otg1_hs_host_otg_hs_hcchar7_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG1_HS_HOST_OTG_HS_HCCHAR7_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR7_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar7_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG1_HS_HOST_OTG_HS_HCCHAR7_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR7_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar7_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR7 = (p->OTG_HS_HCCHAR7 & ~OTG1_HS_HOST_OTG_HS_HCCHAR7_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR7_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar7_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG1_HS_HOST_OTG_HS_HCCHAR7_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar7_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG1_HS_HOST_OTG_HS_HCCHAR7_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar7_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG1_HS_HOST_OTG_HS_HCCHAR7_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar7_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG1_HS_HOST_OTG_HS_HCCHAR7_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar7_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR7 & OTG1_HS_HOST_OTG_HS_HCCHAR7_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT7 OTG_HS host channel-7 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT7_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT7_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT7_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT7_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT7_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt7_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT7 = (p->OTG_HS_HCSPLT7 & ~OTG1_HS_HOST_OTG_HS_HCSPLT7_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT7_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt7_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT7 = (p->OTG_HS_HCSPLT7 & ~OTG1_HS_HOST_OTG_HS_HCSPLT7_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT7_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt7_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT7 = (p->OTG_HS_HCSPLT7 & ~OTG1_HS_HOST_OTG_HS_HCSPLT7_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT7_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt7_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT7 & OTG1_HS_HOST_OTG_HS_HCSPLT7_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt7_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT7 & OTG1_HS_HOST_OTG_HS_HCSPLT7_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt7_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT7 & OTG1_HS_HOST_OTG_HS_HCSPLT7_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT7 OTG_HS host channel-7 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT7_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT7_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT7_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT7_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT7_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT7_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT7_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT7_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT7_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT7_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT7_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK7 OTG_HS host channel-7 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK7_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ7 OTG_HS host channel-7 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ7_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz7_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ7 = (p->OTG_HS_HCTSIZ7 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ7_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ7_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz7_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ7 = (p->OTG_HS_HCTSIZ7 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz7_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ7 = (p->OTG_HS_HCTSIZ7 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz7_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ7 & OTG1_HS_HOST_OTG_HS_HCTSIZ7_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz7_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ7 & OTG1_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz7_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ7 & OTG1_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR8 OTG_HS host channel-8 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR8_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR8_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR8_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR8_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR8_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR8_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR8_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR8_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR8_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR8_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar8_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG1_HS_HOST_OTG_HS_HCCHAR8_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR8_DAD); }
inline void otg1_hs_host_otg_hs_hcchar8_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG1_HS_HOST_OTG_HS_HCCHAR8_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR8_MC); }
inline void otg1_hs_host_otg_hs_hcchar8_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG1_HS_HOST_OTG_HS_HCCHAR8_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR8_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar8_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG1_HS_HOST_OTG_HS_HCCHAR8_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR8_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar8_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR8 = (p->OTG_HS_HCCHAR8 & ~OTG1_HS_HOST_OTG_HS_HCCHAR8_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR8_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar8_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG1_HS_HOST_OTG_HS_HCCHAR8_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar8_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG1_HS_HOST_OTG_HS_HCCHAR8_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar8_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG1_HS_HOST_OTG_HS_HCCHAR8_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar8_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG1_HS_HOST_OTG_HS_HCCHAR8_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar8_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR8 & OTG1_HS_HOST_OTG_HS_HCCHAR8_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT8 OTG_HS host channel-8 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT8_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT8_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT8_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT8_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT8_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt8_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT8 = (p->OTG_HS_HCSPLT8 & ~OTG1_HS_HOST_OTG_HS_HCSPLT8_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT8_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt8_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT8 = (p->OTG_HS_HCSPLT8 & ~OTG1_HS_HOST_OTG_HS_HCSPLT8_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT8_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt8_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT8 = (p->OTG_HS_HCSPLT8 & ~OTG1_HS_HOST_OTG_HS_HCSPLT8_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT8_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt8_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT8 & OTG1_HS_HOST_OTG_HS_HCSPLT8_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt8_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT8 & OTG1_HS_HOST_OTG_HS_HCSPLT8_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt8_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT8 & OTG1_HS_HOST_OTG_HS_HCSPLT8_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT8 OTG_HS host channel-8 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT8_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT8_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT8_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT8_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT8_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT8_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT8_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT8_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT8_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT8_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT8_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK8 OTG_HS host channel-8 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK8_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ8 OTG_HS host channel-8 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ8_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz8_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ8 = (p->OTG_HS_HCTSIZ8 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ8_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ8_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz8_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ8 = (p->OTG_HS_HCTSIZ8 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz8_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ8 = (p->OTG_HS_HCTSIZ8 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz8_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ8 & OTG1_HS_HOST_OTG_HS_HCTSIZ8_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz8_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ8 & OTG1_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz8_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ8 & OTG1_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR9 OTG_HS host channel-9 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR9_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR9_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR9_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR9_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR9_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR9_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR9_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR9_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR9_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR9_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar9_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG1_HS_HOST_OTG_HS_HCCHAR9_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR9_DAD); }
inline void otg1_hs_host_otg_hs_hcchar9_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG1_HS_HOST_OTG_HS_HCCHAR9_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR9_MC); }
inline void otg1_hs_host_otg_hs_hcchar9_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG1_HS_HOST_OTG_HS_HCCHAR9_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR9_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar9_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG1_HS_HOST_OTG_HS_HCCHAR9_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR9_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar9_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR9 = (p->OTG_HS_HCCHAR9 & ~OTG1_HS_HOST_OTG_HS_HCCHAR9_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR9_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar9_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG1_HS_HOST_OTG_HS_HCCHAR9_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar9_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG1_HS_HOST_OTG_HS_HCCHAR9_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar9_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG1_HS_HOST_OTG_HS_HCCHAR9_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar9_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG1_HS_HOST_OTG_HS_HCCHAR9_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar9_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR9 & OTG1_HS_HOST_OTG_HS_HCCHAR9_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT9 OTG_HS host channel-9 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT9_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT9_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT9_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT9_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT9_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt9_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT9 = (p->OTG_HS_HCSPLT9 & ~OTG1_HS_HOST_OTG_HS_HCSPLT9_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT9_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt9_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT9 = (p->OTG_HS_HCSPLT9 & ~OTG1_HS_HOST_OTG_HS_HCSPLT9_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT9_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt9_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT9 = (p->OTG_HS_HCSPLT9 & ~OTG1_HS_HOST_OTG_HS_HCSPLT9_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT9_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt9_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT9 & OTG1_HS_HOST_OTG_HS_HCSPLT9_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt9_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT9 & OTG1_HS_HOST_OTG_HS_HCSPLT9_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt9_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT9 & OTG1_HS_HOST_OTG_HS_HCSPLT9_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT9 OTG_HS host channel-9 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT9_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT9_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT9_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT9_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT9_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT9_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT9_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT9_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT9_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT9_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT9_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK9 OTG_HS host channel-9 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK9_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ9 OTG_HS host channel-9 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ9_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz9_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ9 = (p->OTG_HS_HCTSIZ9 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ9_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ9_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz9_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ9 = (p->OTG_HS_HCTSIZ9 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz9_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ9 = (p->OTG_HS_HCTSIZ9 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz9_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ9 & OTG1_HS_HOST_OTG_HS_HCTSIZ9_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz9_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ9 & OTG1_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz9_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ9 & OTG1_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR10 OTG_HS host channel-10 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR10_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR10_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR10_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR10_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR10_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR10_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR10_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR10_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR10_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR10_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar10_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG1_HS_HOST_OTG_HS_HCCHAR10_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR10_DAD); }
inline void otg1_hs_host_otg_hs_hcchar10_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG1_HS_HOST_OTG_HS_HCCHAR10_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR10_MC); }
inline void otg1_hs_host_otg_hs_hcchar10_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG1_HS_HOST_OTG_HS_HCCHAR10_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR10_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar10_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG1_HS_HOST_OTG_HS_HCCHAR10_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR10_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar10_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR10 = (p->OTG_HS_HCCHAR10 & ~OTG1_HS_HOST_OTG_HS_HCCHAR10_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR10_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar10_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG1_HS_HOST_OTG_HS_HCCHAR10_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar10_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG1_HS_HOST_OTG_HS_HCCHAR10_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar10_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG1_HS_HOST_OTG_HS_HCCHAR10_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar10_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG1_HS_HOST_OTG_HS_HCCHAR10_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar10_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR10 & OTG1_HS_HOST_OTG_HS_HCCHAR10_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT10 OTG_HS host channel-10 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT10_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT10_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT10_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT10_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT10_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt10_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT10 = (p->OTG_HS_HCSPLT10 & ~OTG1_HS_HOST_OTG_HS_HCSPLT10_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT10_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt10_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT10 = (p->OTG_HS_HCSPLT10 & ~OTG1_HS_HOST_OTG_HS_HCSPLT10_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT10_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt10_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT10 = (p->OTG_HS_HCSPLT10 & ~OTG1_HS_HOST_OTG_HS_HCSPLT10_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT10_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt10_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT10 & OTG1_HS_HOST_OTG_HS_HCSPLT10_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt10_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT10 & OTG1_HS_HOST_OTG_HS_HCSPLT10_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt10_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT10 & OTG1_HS_HOST_OTG_HS_HCSPLT10_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT10 OTG_HS host channel-10 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT10_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT10_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT10_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT10_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT10_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT10_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT10_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT10_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT10_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT10_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT10_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK10 OTG_HS host channel-10 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK10_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ10 OTG_HS host channel-10 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ10_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz10_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ10 = (p->OTG_HS_HCTSIZ10 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ10_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ10_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz10_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ10 = (p->OTG_HS_HCTSIZ10 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz10_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ10 = (p->OTG_HS_HCTSIZ10 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz10_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ10 & OTG1_HS_HOST_OTG_HS_HCTSIZ10_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz10_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ10 & OTG1_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz10_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ10 & OTG1_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR11 OTG_HS host channel-11 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR11_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR11_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR11_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR11_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR11_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR11_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR11_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR11_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR11_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR11_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar11_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG1_HS_HOST_OTG_HS_HCCHAR11_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR11_DAD); }
inline void otg1_hs_host_otg_hs_hcchar11_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG1_HS_HOST_OTG_HS_HCCHAR11_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR11_MC); }
inline void otg1_hs_host_otg_hs_hcchar11_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG1_HS_HOST_OTG_HS_HCCHAR11_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR11_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar11_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG1_HS_HOST_OTG_HS_HCCHAR11_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR11_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar11_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR11 = (p->OTG_HS_HCCHAR11 & ~OTG1_HS_HOST_OTG_HS_HCCHAR11_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR11_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar11_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG1_HS_HOST_OTG_HS_HCCHAR11_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar11_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG1_HS_HOST_OTG_HS_HCCHAR11_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar11_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG1_HS_HOST_OTG_HS_HCCHAR11_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar11_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG1_HS_HOST_OTG_HS_HCCHAR11_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar11_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR11 & OTG1_HS_HOST_OTG_HS_HCCHAR11_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT11 OTG_HS host channel-11 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT11_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT11_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT11_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT11_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT11_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt11_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT11 = (p->OTG_HS_HCSPLT11 & ~OTG1_HS_HOST_OTG_HS_HCSPLT11_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT11_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt11_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT11 = (p->OTG_HS_HCSPLT11 & ~OTG1_HS_HOST_OTG_HS_HCSPLT11_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT11_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt11_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT11 = (p->OTG_HS_HCSPLT11 & ~OTG1_HS_HOST_OTG_HS_HCSPLT11_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT11_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt11_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT11 & OTG1_HS_HOST_OTG_HS_HCSPLT11_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt11_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT11 & OTG1_HS_HOST_OTG_HS_HCSPLT11_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt11_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT11 & OTG1_HS_HOST_OTG_HS_HCSPLT11_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT11 OTG_HS host channel-11 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT11_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT11_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT11_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT11_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT11_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT11_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT11_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT11_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT11_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT11_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT11_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK11 OTG_HS host channel-11 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_BBERRM = 1UL<<8, // Babble error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_TXERRM = 1UL<<7, // Transaction error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_NYET = 1UL<<6, // response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK11_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ11 OTG_HS host channel-11 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ11_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz11_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ11 = (p->OTG_HS_HCTSIZ11 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ11_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ11_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz11_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ11 = (p->OTG_HS_HCTSIZ11 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz11_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ11 = (p->OTG_HS_HCTSIZ11 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz11_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ11 & OTG1_HS_HOST_OTG_HS_HCTSIZ11_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz11_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ11 & OTG1_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz11_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ11 & OTG1_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR12 OTG_HS host channel-12 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR12_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR12_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR12_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR12_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR12_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR12_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR12_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR12_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR12_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR12_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar12_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG1_HS_HOST_OTG_HS_HCCHAR12_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR12_DAD); }
inline void otg1_hs_host_otg_hs_hcchar12_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG1_HS_HOST_OTG_HS_HCCHAR12_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR12_MC); }
inline void otg1_hs_host_otg_hs_hcchar12_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG1_HS_HOST_OTG_HS_HCCHAR12_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR12_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar12_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG1_HS_HOST_OTG_HS_HCCHAR12_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR12_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar12_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR12 = (p->OTG_HS_HCCHAR12 & ~OTG1_HS_HOST_OTG_HS_HCCHAR12_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR12_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar12_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG1_HS_HOST_OTG_HS_HCCHAR12_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar12_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG1_HS_HOST_OTG_HS_HCCHAR12_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar12_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG1_HS_HOST_OTG_HS_HCCHAR12_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar12_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG1_HS_HOST_OTG_HS_HCCHAR12_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar12_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR12 & OTG1_HS_HOST_OTG_HS_HCCHAR12_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT12 OTG_HS host channel-12 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT12_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT12_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT12_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT12_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT12_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt12_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT12 = (p->OTG_HS_HCSPLT12 & ~OTG1_HS_HOST_OTG_HS_HCSPLT12_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT12_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt12_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT12 = (p->OTG_HS_HCSPLT12 & ~OTG1_HS_HOST_OTG_HS_HCSPLT12_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT12_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt12_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT12 = (p->OTG_HS_HCSPLT12 & ~OTG1_HS_HOST_OTG_HS_HCSPLT12_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT12_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt12_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT12 & OTG1_HS_HOST_OTG_HS_HCSPLT12_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt12_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT12 & OTG1_HS_HOST_OTG_HS_HCSPLT12_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt12_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT12 & OTG1_HS_HOST_OTG_HS_HCSPLT12_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT12 OTG_HS host channel-12 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT12_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT12_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT12_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT12_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT12_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT12_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT12_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT12_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT12_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT12_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT12_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK12 OTG_HS host channel-12 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_BBERRM = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_TXERRM = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK12_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ12 OTG_HS host channel-12 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ12_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz12_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ12 = (p->OTG_HS_HCTSIZ12 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ12_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ12_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz12_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ12 = (p->OTG_HS_HCTSIZ12 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz12_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ12 = (p->OTG_HS_HCTSIZ12 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz12_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ12 & OTG1_HS_HOST_OTG_HS_HCTSIZ12_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz12_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ12 & OTG1_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz12_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ12 & OTG1_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR13 OTG_HS host channel-13 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR13_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR13_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR13_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR13_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR13_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR13_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR13_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR13_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR13_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR13_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar13_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG1_HS_HOST_OTG_HS_HCCHAR13_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR13_DAD); }
inline void otg1_hs_host_otg_hs_hcchar13_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG1_HS_HOST_OTG_HS_HCCHAR13_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR13_MC); }
inline void otg1_hs_host_otg_hs_hcchar13_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG1_HS_HOST_OTG_HS_HCCHAR13_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR13_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar13_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG1_HS_HOST_OTG_HS_HCCHAR13_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR13_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar13_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR13 = (p->OTG_HS_HCCHAR13 & ~OTG1_HS_HOST_OTG_HS_HCCHAR13_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR13_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar13_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG1_HS_HOST_OTG_HS_HCCHAR13_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar13_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG1_HS_HOST_OTG_HS_HCCHAR13_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar13_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG1_HS_HOST_OTG_HS_HCCHAR13_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar13_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG1_HS_HOST_OTG_HS_HCCHAR13_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar13_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR13 & OTG1_HS_HOST_OTG_HS_HCCHAR13_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT13 OTG_HS host channel-13 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT13_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT13_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT13_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT13_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT13_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt13_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT13 = (p->OTG_HS_HCSPLT13 & ~OTG1_HS_HOST_OTG_HS_HCSPLT13_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT13_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt13_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT13 = (p->OTG_HS_HCSPLT13 & ~OTG1_HS_HOST_OTG_HS_HCSPLT13_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT13_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt13_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT13 = (p->OTG_HS_HCSPLT13 & ~OTG1_HS_HOST_OTG_HS_HCSPLT13_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT13_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt13_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT13 & OTG1_HS_HOST_OTG_HS_HCSPLT13_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt13_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT13 & OTG1_HS_HOST_OTG_HS_HCSPLT13_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt13_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT13 & OTG1_HS_HOST_OTG_HS_HCSPLT13_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT13 OTG_HS host channel-13 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT13_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT13_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT13_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT13_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT13_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT13_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT13_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT13_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT13_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT13_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT13_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK13 OTG_HS host channel-13 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_BBERRM = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_TXERRM = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_STALLM = 1UL<<3, // STALLM response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK13_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ13 OTG_HS host channel-13 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ13_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz13_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ13 = (p->OTG_HS_HCTSIZ13 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ13_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ13_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz13_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ13 = (p->OTG_HS_HCTSIZ13 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz13_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ13 = (p->OTG_HS_HCTSIZ13 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz13_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ13 & OTG1_HS_HOST_OTG_HS_HCTSIZ13_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz13_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ13 & OTG1_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz13_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ13 & OTG1_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR14 OTG_HS host channel-14 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR14_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR14_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR14_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR14_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR14_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR14_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR14_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR14_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR14_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR14_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar14_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG1_HS_HOST_OTG_HS_HCCHAR14_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR14_DAD); }
inline void otg1_hs_host_otg_hs_hcchar14_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG1_HS_HOST_OTG_HS_HCCHAR14_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR14_MC); }
inline void otg1_hs_host_otg_hs_hcchar14_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG1_HS_HOST_OTG_HS_HCCHAR14_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR14_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar14_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG1_HS_HOST_OTG_HS_HCCHAR14_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR14_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar14_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR14 = (p->OTG_HS_HCCHAR14 & ~OTG1_HS_HOST_OTG_HS_HCCHAR14_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR14_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar14_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG1_HS_HOST_OTG_HS_HCCHAR14_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar14_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG1_HS_HOST_OTG_HS_HCCHAR14_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar14_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG1_HS_HOST_OTG_HS_HCCHAR14_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar14_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG1_HS_HOST_OTG_HS_HCCHAR14_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar14_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR14 & OTG1_HS_HOST_OTG_HS_HCCHAR14_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT14 OTG_HS host channel-14 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT14_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT14_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT14_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT14_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT14_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt14_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT14 = (p->OTG_HS_HCSPLT14 & ~OTG1_HS_HOST_OTG_HS_HCSPLT14_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT14_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt14_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT14 = (p->OTG_HS_HCSPLT14 & ~OTG1_HS_HOST_OTG_HS_HCSPLT14_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT14_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt14_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT14 = (p->OTG_HS_HCSPLT14 & ~OTG1_HS_HOST_OTG_HS_HCSPLT14_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT14_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt14_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT14 & OTG1_HS_HOST_OTG_HS_HCSPLT14_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt14_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT14 & OTG1_HS_HOST_OTG_HS_HCSPLT14_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt14_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT14 & OTG1_HS_HOST_OTG_HS_HCSPLT14_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT14 OTG_HS host channel-14 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT14_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT14_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT14_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT14_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT14_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT14_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT14_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT14_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT14_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT14_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT14_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK14 OTG_HS host channel-14 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_BBERRM = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_TXERRM = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_ACKM = 1UL<<5, // ACKM response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_NAKM = 1UL<<4, // NAKM response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_STALLM = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK14_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ14 OTG_HS host channel-14 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ14_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz14_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ14 = (p->OTG_HS_HCTSIZ14 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ14_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ14_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz14_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ14 = (p->OTG_HS_HCTSIZ14 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz14_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ14 = (p->OTG_HS_HCTSIZ14 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz14_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ14 & OTG1_HS_HOST_OTG_HS_HCTSIZ14_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz14_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ14 & OTG1_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz14_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ14 & OTG1_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCCHAR15 OTG_HS host channel-15 characteristics register
enum {
	OTG1_HS_HOST_OTG_HS_HCCHAR15_CHENA = 1UL<<31, // Channel enable
	OTG1_HS_HOST_OTG_HS_HCCHAR15_CHDIS = 1UL<<30, // Channel disable
	OTG1_HS_HOST_OTG_HS_HCCHAR15_ODDFRM = 1UL<<29, // Odd frame
	OTG1_HS_HOST_OTG_HS_HCCHAR15_DAD = ((1UL<<7)-1) << 22, // Device address
	OTG1_HS_HOST_OTG_HS_HCCHAR15_MC = ((1UL<<2)-1) << 20, // Multi Count (MC) / Error Count (EC)
	OTG1_HS_HOST_OTG_HS_HCCHAR15_EPTYP = ((1UL<<2)-1) << 18, // Endpoint type
	OTG1_HS_HOST_OTG_HS_HCCHAR15_LSDEV = 1UL<<17, // Low-speed device
	OTG1_HS_HOST_OTG_HS_HCCHAR15_EPDIR = 1UL<<15, // Endpoint direction
	OTG1_HS_HOST_OTG_HS_HCCHAR15_EPNUM = ((1UL<<4)-1) << 11, // Endpoint number
	OTG1_HS_HOST_OTG_HS_HCCHAR15_MPSIZ = ((1UL<<11)-1) << 0, // Maximum packet size		
};
inline void otg1_hs_host_otg_hs_hcchar15_set_dad(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG1_HS_HOST_OTG_HS_HCCHAR15_DAD) | ((val<<22) & OTG1_HS_HOST_OTG_HS_HCCHAR15_DAD); }
inline void otg1_hs_host_otg_hs_hcchar15_set_mc(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG1_HS_HOST_OTG_HS_HCCHAR15_MC) | ((val<<20) & OTG1_HS_HOST_OTG_HS_HCCHAR15_MC); }
inline void otg1_hs_host_otg_hs_hcchar15_set_eptyp(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG1_HS_HOST_OTG_HS_HCCHAR15_EPTYP) | ((val<<18) & OTG1_HS_HOST_OTG_HS_HCCHAR15_EPTYP); }
inline void otg1_hs_host_otg_hs_hcchar15_set_epnum(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG1_HS_HOST_OTG_HS_HCCHAR15_EPNUM) | ((val<<11) & OTG1_HS_HOST_OTG_HS_HCCHAR15_EPNUM); }
inline void otg1_hs_host_otg_hs_hcchar15_set_mpsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCCHAR15 = (p->OTG_HS_HCCHAR15 & ~OTG1_HS_HOST_OTG_HS_HCCHAR15_MPSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCCHAR15_MPSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hcchar15_get_dad(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG1_HS_HOST_OTG_HS_HCCHAR15_DAD) >> 22 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar15_get_mc(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG1_HS_HOST_OTG_HS_HCCHAR15_MC) >> 20 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar15_get_eptyp(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG1_HS_HOST_OTG_HS_HCCHAR15_EPTYP) >> 18 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar15_get_epnum(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG1_HS_HOST_OTG_HS_HCCHAR15_EPNUM) >> 11 ; }
inline uint32_t otg1_hs_host_otg_hs_hcchar15_get_mpsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCCHAR15 & OTG1_HS_HOST_OTG_HS_HCCHAR15_MPSIZ) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCSPLT15 OTG_HS host channel-15 split control register
enum {
	OTG1_HS_HOST_OTG_HS_HCSPLT15_SPLITEN = 1UL<<31, // Split enable
	OTG1_HS_HOST_OTG_HS_HCSPLT15_COMPLSPLT = 1UL<<16, // Do complete split
	OTG1_HS_HOST_OTG_HS_HCSPLT15_XACTPOS = ((1UL<<2)-1) << 14, // XACTPOS
	OTG1_HS_HOST_OTG_HS_HCSPLT15_HUBADDR = ((1UL<<7)-1) << 7, // Hub address
	OTG1_HS_HOST_OTG_HS_HCSPLT15_PRTADDR = ((1UL<<7)-1) << 0, // Port address		
};
inline void otg1_hs_host_otg_hs_hcsplt15_set_xactpos(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT15 = (p->OTG_HS_HCSPLT15 & ~OTG1_HS_HOST_OTG_HS_HCSPLT15_XACTPOS) | ((val<<14) & OTG1_HS_HOST_OTG_HS_HCSPLT15_XACTPOS); }
inline void otg1_hs_host_otg_hs_hcsplt15_set_hubaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT15 = (p->OTG_HS_HCSPLT15 & ~OTG1_HS_HOST_OTG_HS_HCSPLT15_HUBADDR) | ((val<<7) & OTG1_HS_HOST_OTG_HS_HCSPLT15_HUBADDR); }
inline void otg1_hs_host_otg_hs_hcsplt15_set_prtaddr(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCSPLT15 = (p->OTG_HS_HCSPLT15 & ~OTG1_HS_HOST_OTG_HS_HCSPLT15_PRTADDR) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCSPLT15_PRTADDR); }
inline uint32_t otg1_hs_host_otg_hs_hcsplt15_get_xactpos(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT15 & OTG1_HS_HOST_OTG_HS_HCSPLT15_XACTPOS) >> 14 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt15_get_hubaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT15 & OTG1_HS_HOST_OTG_HS_HCSPLT15_HUBADDR) >> 7 ; }
inline uint32_t otg1_hs_host_otg_hs_hcsplt15_get_prtaddr(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCSPLT15 & OTG1_HS_HOST_OTG_HS_HCSPLT15_PRTADDR) >> 0 ; }

// OTG1_HS_HOST->OTG_HS_HCINT15 OTG_HS host channel-15 interrupt register
enum {
	OTG1_HS_HOST_OTG_HS_HCINT15_DTERR = 1UL<<10, // Data toggle error
	OTG1_HS_HOST_OTG_HS_HCINT15_FRMOR = 1UL<<9, // Frame overrun
	OTG1_HS_HOST_OTG_HS_HCINT15_BBERR = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINT15_TXERR = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINT15_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT15_ACK = 1UL<<5, // ACK response received/transmitted interrupt
	OTG1_HS_HOST_OTG_HS_HCINT15_NAK = 1UL<<4, // NAK response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT15_STALL = 1UL<<3, // STALL response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINT15_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINT15_CHH = 1UL<<1, // Channel halted
	OTG1_HS_HOST_OTG_HS_HCINT15_XFRC = 1UL<<0, // Transfer completed		
};

// OTG1_HS_HOST->OTG_HS_HCINTMSK15 OTG_HS host channel-15 interrupt mask register
enum {
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_DTERRM = 1UL<<10, // Data toggle error mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_FRMORM = 1UL<<9, // Frame overrun mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_BBERRM = 1UL<<8, // Babble error
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_TXERRM = 1UL<<7, // Transaction error
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_NYET = 1UL<<6, // Response received interrupt
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_ACKM = 1UL<<5, // ACK response received/transmitted interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_NAKM = 1UL<<4, // NAK response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_STALL = 1UL<<3, // STALL response received interrupt mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_AHBERR = 1UL<<2, // AHB error
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_CHHM = 1UL<<1, // Channel halted mask
	OTG1_HS_HOST_OTG_HS_HCINTMSK15_XFRCM = 1UL<<0, // Transfer completed mask		
};

// OTG1_HS_HOST->OTG_HS_HCTSIZ15 OTG_HS host channel-15 transfer size register
enum {
	OTG1_HS_HOST_OTG_HS_HCTSIZ15_DPID = ((1UL<<2)-1) << 29, // Data PID
	OTG1_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT = ((1UL<<10)-1) << 19, // Packet count
	OTG1_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ = ((1UL<<19)-1) << 0, // Transfer size		
};
inline void otg1_hs_host_otg_hs_hctsiz15_set_dpid(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ15 = (p->OTG_HS_HCTSIZ15 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ15_DPID) | ((val<<29) & OTG1_HS_HOST_OTG_HS_HCTSIZ15_DPID); }
inline void otg1_hs_host_otg_hs_hctsiz15_set_pktcnt(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ15 = (p->OTG_HS_HCTSIZ15 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT) | ((val<<19) & OTG1_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT); }
inline void otg1_hs_host_otg_hs_hctsiz15_set_xfrsiz(struct OTG1_HS_HOST_Type* p, uint32_t val) { p->OTG_HS_HCTSIZ15 = (p->OTG_HS_HCTSIZ15 & ~OTG1_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ) | ((val<<0) & OTG1_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ); }
inline uint32_t otg1_hs_host_otg_hs_hctsiz15_get_dpid(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ15 & OTG1_HS_HOST_OTG_HS_HCTSIZ15_DPID) >> 29 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz15_get_pktcnt(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ15 & OTG1_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT) >> 19 ; }
inline uint32_t otg1_hs_host_otg_hs_hctsiz15_get_xfrsiz(struct OTG1_HS_HOST_Type* p) { return (p->OTG_HS_HCTSIZ15 & OTG1_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ) >> 0 ; }

/* USB 1 on the go high speed */
struct OTG1_HS_PWRCLK_Type {
	__IO uint8_t OTG_HS_PCGCR; // @0 Power and clock gating control register
};

// OTG1_HS_PWRCLK->OTG_HS_PCGCR Power and clock gating control register
enum {
	OTG1_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP = 1UL<<4, // PHY suspended
	OTG1_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK = 1UL<<1, // Gate HCLK
	OTG1_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK = 1UL<<0, // Stop PHY clock		
};





/* Processor features */
struct PF_Type {
	__I uint32_t CLIDR; // @0 Cache Level ID register
	__I uint32_t CTR; // @4 Cache Type register
	__I uint32_t CCSIDR; // @8 Cache Size ID register
};

// PF->CLIDR Cache Level ID register
enum {
	PF_CLIDR_LOU = ((1UL<<3)-1) << 27, // LoU
	PF_CLIDR_LOC = ((1UL<<3)-1) << 24, // LoC
	PF_CLIDR_LOUIS = ((1UL<<3)-1) << 21, // LoUIS
	PF_CLIDR_CL7 = ((1UL<<3)-1) << 18, // CL7
	PF_CLIDR_CL6 = ((1UL<<3)-1) << 15, // CL6
	PF_CLIDR_CL5 = ((1UL<<3)-1) << 12, // CL5
	PF_CLIDR_CL4 = ((1UL<<3)-1) << 9, // CL4
	PF_CLIDR_CL3 = ((1UL<<3)-1) << 6, // CL3
	PF_CLIDR_CL2 = ((1UL<<3)-1) << 3, // CL2
	PF_CLIDR_CL1 = ((1UL<<3)-1) << 0, // CL1		
};
inline uint32_t pf_clidr_get_lou(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_LOU) >> 27 ; }
inline uint32_t pf_clidr_get_loc(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_LOC) >> 24 ; }
inline uint32_t pf_clidr_get_louis(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_LOUIS) >> 21 ; }
inline uint32_t pf_clidr_get_cl7(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL7) >> 18 ; }
inline uint32_t pf_clidr_get_cl6(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL6) >> 15 ; }
inline uint32_t pf_clidr_get_cl5(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL5) >> 12 ; }
inline uint32_t pf_clidr_get_cl4(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL4) >> 9 ; }
inline uint32_t pf_clidr_get_cl3(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL3) >> 6 ; }
inline uint32_t pf_clidr_get_cl2(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL2) >> 3 ; }
inline uint32_t pf_clidr_get_cl1(struct PF_Type* p) { return (p->CLIDR & PF_CLIDR_CL1) >> 0 ; }

// PF->CTR Cache Type register
enum {
	PF_CTR_FORMAT = ((1UL<<3)-1) << 29, // Format
	PF_CTR_CWG = ((1UL<<4)-1) << 24, // CWG
	PF_CTR_ERG = ((1UL<<4)-1) << 20, // ERG
	PF_CTR_DMINLINE = ((1UL<<4)-1) << 16, // DMinLine
	PF_CTR__IMINLINE = ((1UL<<4)-1) << 0, // IminLine		
};
inline uint32_t pf_ctr_get_format(struct PF_Type* p) { return (p->CTR & PF_CTR_FORMAT) >> 29 ; }
inline uint32_t pf_ctr_get_cwg(struct PF_Type* p) { return (p->CTR & PF_CTR_CWG) >> 24 ; }
inline uint32_t pf_ctr_get_erg(struct PF_Type* p) { return (p->CTR & PF_CTR_ERG) >> 20 ; }
inline uint32_t pf_ctr_get_dminline(struct PF_Type* p) { return (p->CTR & PF_CTR_DMINLINE) >> 16 ; }
inline uint32_t pf_ctr_get__iminline(struct PF_Type* p) { return (p->CTR & PF_CTR__IMINLINE) >> 0 ; }

// PF->CCSIDR Cache Size ID register
enum {
	PF_CCSIDR_WT = 1UL<<31, // WT
	PF_CCSIDR_WB = 1UL<<30, // WB
	PF_CCSIDR_RA = 1UL<<29, // RA
	PF_CCSIDR_WA = 1UL<<28, // WA
	PF_CCSIDR_NUMSETS = ((1UL<<15)-1) << 13, // NumSets
	PF_CCSIDR_ASSOCIATIVITY = ((1UL<<10)-1) << 3, // Associativity
	PF_CCSIDR_LINESIZE = ((1UL<<3)-1) << 0, // LineSize		
};
inline uint32_t pf_ccsidr_get_numsets(struct PF_Type* p) { return (p->CCSIDR & PF_CCSIDR_NUMSETS) >> 13 ; }
inline uint32_t pf_ccsidr_get_associativity(struct PF_Type* p) { return (p->CCSIDR & PF_CCSIDR_ASSOCIATIVITY) >> 3 ; }
inline uint32_t pf_ccsidr_get_linesize(struct PF_Type* p) { return (p->CCSIDR & PF_CCSIDR_LINESIZE) >> 0 ; }

/* PWR */
struct PWR_Type {
	__IO uint32_t CR1; // @0 PWR control register 1
	__I uint32_t CSR1; // @4 PWR control status register 1
	__IO uint32_t CR2; // @8 This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
	__IO uint32_t CR3; // @12 Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
	__IO uint16_t CPUCR; // @16 This register allows controlling CPU1 power.
	 uint8_t RESERVED0[6]; // @18 
	__IO uint16_t D3CR; // @24 This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
	 uint8_t RESERVED1[6]; // @26 
	__IO uint8_t WKUPCR; // @32 reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
	 uint8_t RESERVED2[3]; // @33 
	__IO uint8_t WKUPFR; // @36 reset only by system reset, not reset by wakeup from Standby mode
	 uint8_t RESERVED3[3]; // @37 
	__IO uint32_t WKUPEPR; // @40 Reset only by system reset, not reset by wakeup from Standby mode
};

// PWR->CR1 PWR control register 1
enum {
	PWR_CR1_ALS = ((1UL<<2)-1) << 17, // Analog voltage detector level selection These bits select the voltage threshold detected by the AVD.
	PWR_CR1_AVDEN = 1UL<<16, // Peripheral voltage monitor on VDDA enable
	PWR_CR1_SVOS = ((1UL<<2)-1) << 14, // System Stop mode voltage scaling selection These bits control the VCORE voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance.
	PWR_CR1_FLPS = 1UL<<9, // Flash low-power mode in DStop mode This bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from DStop mode. When it is set, the Flash memory enters low-power mode when D1 domain is in DStop mode.
	PWR_CR1_DBP = 1UL<<8, // Disable backup domain write protection In reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers.
	PWR_CR1_PLS = ((1UL<<3)-1) << 5, // Programmable voltage detector level selection These bits select the voltage threshold detected by the PVD. Note: Refer to Section Electrical characteristics of the product datasheet for more details.
	PWR_CR1_PVDE = 1UL<<4, // Programmable voltage detector enable
	PWR_CR1_LPDS = 1UL<<0, // Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit)		
};
inline void pwr_cr1_set_als(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_ALS) | ((val<<17) & PWR_CR1_ALS); }
inline void pwr_cr1_set_svos(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_SVOS) | ((val<<14) & PWR_CR1_SVOS); }
inline void pwr_cr1_set_pls(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_PLS) | ((val<<5) & PWR_CR1_PLS); }
inline uint32_t pwr_cr1_get_als(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_ALS) >> 17 ; }
inline uint32_t pwr_cr1_get_svos(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_SVOS) >> 14 ; }
inline uint32_t pwr_cr1_get_pls(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_PLS) >> 5 ; }

// PWR->CSR1 PWR control status register 1
enum {
	PWR_CSR1_AVDO = 1UL<<16, // Analog voltage detector output on VDDA This bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: Since the AVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the AVDEN bit is set.
	PWR_CSR1_ACTVOS = ((1UL<<2)-1) << 14, // VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU.
	PWR_CSR1_ACTVOSRDY = 1UL<<13, // Voltage levels ready bit for currently used VOS and SDLEVEL This bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and Bypass mode is selected in PWR control register 3 (PWR_CR3).
	PWR_CSR1_PVDO = 1UL<<4, // Programmable voltage detect output This bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set.		
};
inline uint32_t pwr_csr1_get_actvos(struct PWR_Type* p) { return (p->CSR1 & PWR_CSR1_ACTVOS) >> 14 ; }

// PWR->CR2 This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
enum {
	PWR_CR2_TEMPH = 1UL<<23, // Temperature level monitoring versus high threshold
	PWR_CR2_TEMPL = 1UL<<22, // Temperature level monitoring versus low threshold
	PWR_CR2_VBATH = 1UL<<21, // VBAT level monitoring versus high threshold
	PWR_CR2_VBATL = 1UL<<20, // VBAT level monitoring versus low threshold
	PWR_CR2_BRRDY = 1UL<<16, // Backup regulator ready This bit is set by hardware to indicate that the Backup regulator is ready.
	PWR_CR2_MONEN = 1UL<<4, // VBAT and temperature monitoring enable When set, the VBAT supply and temperature monitoring is enabled.
	PWR_CR2_BREN = 1UL<<0, // Backup regulator enable When set, the Backup regulator (used to maintain the backup RAM content in Standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in Run and Stop modes. However, its content will be lost in Standby and VBAT modes. If BREN is set, the application must wait till the Backup Regulator Ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in Standby and VBAT modes.		
};

// PWR->CR3 Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
enum {
	PWR_CR3_USB33RDY = 1UL<<26, // USB supply ready.
	PWR_CR3_USBREGEN = 1UL<<25, // USB regulator enable.
	PWR_CR3_USB33DEN = 1UL<<24, // VDD33USB voltage level detector enable.
	PWR_CR3_VBRS = 1UL<<9, // VBAT charging resistor selection
	PWR_CR3_VBE = 1UL<<8, // VBAT charging enable
	PWR_CR3_SDEN = 1UL<<2, // SD converter Enable
	PWR_CR3_LDOEN = 1UL<<1, // Low drop-out regulator enable
	PWR_CR3_BYPASS = 1UL<<0, // Power management unit bypass		
};

// PWR->CPUCR This register allows controlling CPU1 power.
enum {
	PWR_CPUCR_RUN_D3 = 1UL<<11, // Keep system D3 domain in Run mode regardless of the CPU sub-systems modes
	PWR_CPUCR_CSSF = 1UL<<9, // Clear D1 domain CPU1 Standby, Stop and HOLD flags (always read as 0) This bit is cleared to 0 by hardware.
	PWR_CPUCR_SBF_D2 = 1UL<<8, // D2 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in DStandby mode.
	PWR_CPUCR_SBF_D1 = 1UL<<7, // D1 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in DStandby mode.
	PWR_CPUCR_SBF = 1UL<<6, // System Standby flag This bit is set by hardware and cleared only by a POR (Power-on Reset) or by setting the CPU1 CSSF bit
	PWR_CPUCR_STOPF = 1UL<<5, // STOP flag This bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit.
	PWR_CPUCR_PDDS_D3 = 1UL<<2, // System D3 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for System D3 domain.
	PWR_CPUCR_PDDS_D2 = 1UL<<1, // D2 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for D2 domain.
	PWR_CPUCR_PDDS_D1 = 1UL<<0, // D1 domain Power Down Deepsleep selection. This bit allows CPU1 to define the Deepsleep mode for D1 domain.		
};

// PWR->D3CR This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
enum {
	PWR_D3CR_VOS = ((1UL<<2)-1) << 14, // Voltage scaling selection according to performance These bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: When increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling.
	PWR_D3CR_VOSRDY = 1UL<<13, // VOS Ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when Bypass mode is selected in PWR control register 3 (PWR_CR3).		
};
inline void pwr_d3cr_set_vos(struct PWR_Type* p, uint32_t val) { p->D3CR = (p->D3CR & ~PWR_D3CR_VOS) | ((val<<14) & PWR_D3CR_VOS); }
inline uint32_t pwr_d3cr_get_vos(struct PWR_Type* p) { return (p->D3CR & PWR_D3CR_VOS) >> 14 ; }

// PWR->WKUPCR reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
enum {
	PWR_WKUPCR_WKUPC = ((1UL<<6)-1) << 0, // Clear Wakeup pin flag for WKUP. These bits are always read as 0.		
};
inline void pwr_wkupcr_set_wkupc(struct PWR_Type* p, uint32_t val) { p->WKUPCR = (p->WKUPCR & ~PWR_WKUPCR_WKUPC) | ((val<<0) & PWR_WKUPCR_WKUPC); }
inline uint32_t pwr_wkupcr_get_wkupc(struct PWR_Type* p) { return (p->WKUPCR & PWR_WKUPCR_WKUPC) >> 0 ; }

// PWR->WKUPFR reset only by system reset, not reset by wakeup from Standby mode
enum {
	PWR_WKUPFR_WKUPFX  = ((1UL<<6)-1) << 0, // Merged Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).		
};
inline void pwr_wkupfr_set_wkupfx (struct PWR_Type* p, uint32_t val) { p->WKUPFR = (p->WKUPFR & ~PWR_WKUPFR_WKUPFX ) | ((val<<0) & PWR_WKUPFR_WKUPFX ); }
inline uint32_t pwr_wkupfr_get_wkupfx (struct PWR_Type* p) { return (p->WKUPFR & PWR_WKUPFR_WKUPFX ) >> 0 ; }

// PWR->WKUPEPR Reset only by system reset, not reset by wakeup from Standby mode
enum {
	PWR_WKUPEPR_WKUPPUPD6 = ((1UL<<2)-1) << 26, // Wakeup pin pull configuration for WKUP(truncate(n/2)-7) These bits define the I/O pad pull configuration used when WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The Wakeup pin pull configuration is kept in Standby mode.
	PWR_WKUPEPR_WKUPPUPD5 = ((1UL<<2)-1) << 24, // Wakeup pin pull configuration
	PWR_WKUPEPR_WKUPPUPD4 = ((1UL<<2)-1) << 22, // Wakeup pin pull configuration
	PWR_WKUPEPR_WKUPPUPD3 = ((1UL<<2)-1) << 20, // Wakeup pin pull configuration
	PWR_WKUPEPR_WKUPPUPD2 = ((1UL<<2)-1) << 18, // Wakeup pin pull configuration
	PWR_WKUPEPR_WKUPPUPD1 = ((1UL<<2)-1) << 16, // Wakeup pin pull configuration
	PWR_WKUPEPR_WKUPP6 = 1UL<<13, // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
	PWR_WKUPEPR_WKUPP5 = 1UL<<12, // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
	PWR_WKUPEPR_WKUPP4 = 1UL<<11, // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
	PWR_WKUPEPR_WKUPP3 = 1UL<<10, // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
	PWR_WKUPEPR_WKUPP2 = 1UL<<9, // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
	PWR_WKUPEPR_WKUPP1 = 1UL<<8, // Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
	PWR_WKUPEPR_WKUPEN6 = 1UL<<5, // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
	PWR_WKUPEPR_WKUPEN5 = 1UL<<4, // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
	PWR_WKUPEPR_WKUPEN4 = 1UL<<3, // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
	PWR_WKUPEPR_WKUPEN3 = 1UL<<2, // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
	PWR_WKUPEPR_WKUPEN2 = 1UL<<1, // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
	PWR_WKUPEPR_WKUPEN1 = 1UL<<0, // Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.		
};
inline void pwr_wkupepr_set_wkuppupd6(struct PWR_Type* p, uint32_t val) { p->WKUPEPR = (p->WKUPEPR & ~PWR_WKUPEPR_WKUPPUPD6) | ((val<<26) & PWR_WKUPEPR_WKUPPUPD6); }
inline void pwr_wkupepr_set_wkuppupd5(struct PWR_Type* p, uint32_t val) { p->WKUPEPR = (p->WKUPEPR & ~PWR_WKUPEPR_WKUPPUPD5) | ((val<<24) & PWR_WKUPEPR_WKUPPUPD5); }
inline void pwr_wkupepr_set_wkuppupd4(struct PWR_Type* p, uint32_t val) { p->WKUPEPR = (p->WKUPEPR & ~PWR_WKUPEPR_WKUPPUPD4) | ((val<<22) & PWR_WKUPEPR_WKUPPUPD4); }
inline void pwr_wkupepr_set_wkuppupd3(struct PWR_Type* p, uint32_t val) { p->WKUPEPR = (p->WKUPEPR & ~PWR_WKUPEPR_WKUPPUPD3) | ((val<<20) & PWR_WKUPEPR_WKUPPUPD3); }
inline void pwr_wkupepr_set_wkuppupd2(struct PWR_Type* p, uint32_t val) { p->WKUPEPR = (p->WKUPEPR & ~PWR_WKUPEPR_WKUPPUPD2) | ((val<<18) & PWR_WKUPEPR_WKUPPUPD2); }
inline void pwr_wkupepr_set_wkuppupd1(struct PWR_Type* p, uint32_t val) { p->WKUPEPR = (p->WKUPEPR & ~PWR_WKUPEPR_WKUPPUPD1) | ((val<<16) & PWR_WKUPEPR_WKUPPUPD1); }
inline uint32_t pwr_wkupepr_get_wkuppupd6(struct PWR_Type* p) { return (p->WKUPEPR & PWR_WKUPEPR_WKUPPUPD6) >> 26 ; }
inline uint32_t pwr_wkupepr_get_wkuppupd5(struct PWR_Type* p) { return (p->WKUPEPR & PWR_WKUPEPR_WKUPPUPD5) >> 24 ; }
inline uint32_t pwr_wkupepr_get_wkuppupd4(struct PWR_Type* p) { return (p->WKUPEPR & PWR_WKUPEPR_WKUPPUPD4) >> 22 ; }
inline uint32_t pwr_wkupepr_get_wkuppupd3(struct PWR_Type* p) { return (p->WKUPEPR & PWR_WKUPEPR_WKUPPUPD3) >> 20 ; }
inline uint32_t pwr_wkupepr_get_wkuppupd2(struct PWR_Type* p) { return (p->WKUPEPR & PWR_WKUPEPR_WKUPPUPD2) >> 18 ; }
inline uint32_t pwr_wkupepr_get_wkuppupd1(struct PWR_Type* p) { return (p->WKUPEPR & PWR_WKUPEPR_WKUPPUPD1) >> 16 ; }

/* QUADSPI */
struct QUADSPI_Type {
	__IO uint32_t CR; // @0 QUADSPI control register
	__IO uint32_t DCR; // @4 QUADSPI device configuration register
	__I uint16_t SR; // @8 QUADSPI status register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint8_t FCR; // @12 QUADSPI flag clear register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint32_t DLR; // @16 QUADSPI data length register
	__IO uint32_t CCR; // @20 QUADSPI communication configuration register
	__IO uint32_t AR; // @24 QUADSPI address register
	__IO uint32_t ABR; // @28 QUADSPI alternate bytes registers
	__IO uint32_t DR; // @32 QUADSPI data register
	__IO uint32_t PSMKR; // @36 QUADSPI polling status mask register
	__IO uint32_t PSMAR; // @40 QUADSPI polling status match register
	__IO uint16_t PIR; // @44 QUADSPI polling interval register
	 uint8_t RESERVED2[2]; // @46 
	__IO uint16_t LPTR; // @48 QUADSPI low-power timeout register
};

// QUADSPI->CR QUADSPI control register
enum {
	QUADSPI_CR_PRESCALER = ((1UL<<8)-1) << 24, // clock prescaler
	QUADSPI_CR_PMM = 1UL<<23, // Polling match mode This bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0.
	QUADSPI_CR_APMS = 1UL<<22, // Automatic poll mode stop This bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0.
	QUADSPI_CR_TOIE = 1UL<<20, // TimeOut interrupt enable This bit enables the TimeOut interrupt.
	QUADSPI_CR_SMIE = 1UL<<19, // Status match interrupt enable This bit enables the status match interrupt.
	QUADSPI_CR_FTIE = 1UL<<18, // FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
	QUADSPI_CR_TCIE = 1UL<<17, // Transfer complete interrupt enable This bit enables the transfer complete interrupt.
	QUADSPI_CR_TEIE = 1UL<<16, // Transfer error interrupt enable This bit enables the transfer error interrupt.
	QUADSPI_CR_FTHRES = ((1UL<<5)-1) << 8, // FIFO threshold level Defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value.
	QUADSPI_CR_FSEL = 1UL<<7, // Flash memory selection This bit selects the Flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1.
	QUADSPI_CR_DFM = 1UL<<6, // Dual-flash mode This bit activates dual-flash mode, where two external Flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0.
	QUADSPI_CR_SSHIFT = 1UL<<4, // Sample shift By default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the Flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0.
	QUADSPI_CR_TCEN = 1UL<<3, // Timeout counter enable This bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (nCS) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with nCS maintained low, even if no access to the Flash memory occurs for a long time. Since Flash memories tend to consume more when nCS is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that nCS is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0.
	QUADSPI_CR_DMAEN = 1UL<<2, // DMA enable In indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set.
	QUADSPI_CR_ABORT = 1UL<<1, // Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit.
	QUADSPI_CR_EN = 1UL<<0, // Enable Enable the QUADSPI.		
};
inline void quadspi_cr_set_prescaler(struct QUADSPI_Type* p, uint32_t val) { p->CR = (p->CR & ~QUADSPI_CR_PRESCALER) | ((val<<24) & QUADSPI_CR_PRESCALER); }
inline void quadspi_cr_set_fthres(struct QUADSPI_Type* p, uint32_t val) { p->CR = (p->CR & ~QUADSPI_CR_FTHRES) | ((val<<8) & QUADSPI_CR_FTHRES); }
inline uint32_t quadspi_cr_get_prescaler(struct QUADSPI_Type* p) { return (p->CR & QUADSPI_CR_PRESCALER) >> 24 ; }
inline uint32_t quadspi_cr_get_fthres(struct QUADSPI_Type* p) { return (p->CR & QUADSPI_CR_FTHRES) >> 8 ; }

// QUADSPI->DCR QUADSPI device configuration register
enum {
	QUADSPI_DCR_FSIZE = ((1UL<<5)-1) << 16, // Flash memory size This field defines the size of external memory using the following formula: Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the Flash memory. The Flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two Flash memories together. This field can be modified only when BUSY = 0.
	QUADSPI_DCR_CSHT = ((1UL<<3)-1) << 8, // Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (nCS) must remain high between commands issued to the Flash memory. ... This field can be modified only when BUSY = 0.
	QUADSPI_DCR_CKMODE = 1UL<<0, // indicates the level that clk takes between command		
};
inline void quadspi_dcr_set_fsize(struct QUADSPI_Type* p, uint32_t val) { p->DCR = (p->DCR & ~QUADSPI_DCR_FSIZE) | ((val<<16) & QUADSPI_DCR_FSIZE); }
inline void quadspi_dcr_set_csht(struct QUADSPI_Type* p, uint32_t val) { p->DCR = (p->DCR & ~QUADSPI_DCR_CSHT) | ((val<<8) & QUADSPI_DCR_CSHT); }
inline uint32_t quadspi_dcr_get_fsize(struct QUADSPI_Type* p) { return (p->DCR & QUADSPI_DCR_FSIZE) >> 16 ; }
inline uint32_t quadspi_dcr_get_csht(struct QUADSPI_Type* p) { return (p->DCR & QUADSPI_DCR_CSHT) >> 8 ; }

// QUADSPI->SR QUADSPI status register
enum {
	QUADSPI_SR_FLEVEL = ((1UL<<6)-1) << 8, // FIFO level This field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero.
	QUADSPI_SR_BUSY = 1UL<<5, // Busy This bit is set when an operation is on going. This bit clears automatically when the operation with the Flash memory is finished and the FIFO is empty.
	QUADSPI_SR_TOF = 1UL<<4, // Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
	QUADSPI_SR_SMF = 1UL<<3, // Status match flag This bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF.
	QUADSPI_SR_FTF = 1UL<<2, // FIFO threshold flag In indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the Flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
	QUADSPI_SR_TCF = 1UL<<1, // Transfer complete flag This bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
	QUADSPI_SR_TEF = 1UL<<0, // Transfer error flag This bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF.		
};
inline uint32_t quadspi_sr_get_flevel(struct QUADSPI_Type* p) { return (p->SR & QUADSPI_SR_FLEVEL) >> 8 ; }

// QUADSPI->FCR QUADSPI flag clear register
enum {
	QUADSPI_FCR_CTOF = 1UL<<4, // Clear timeout flag Writing 1 clears the TOF flag in the QUADSPI_SR register
	QUADSPI_FCR_CSMF = 1UL<<3, // Clear status match flag Writing 1 clears the SMF flag in the QUADSPI_SR register
	QUADSPI_FCR_CTCF = 1UL<<1, // Clear transfer complete flag Writing 1 clears the TCF flag in the QUADSPI_SR register
	QUADSPI_FCR_CTEF = 1UL<<0, // Clear transfer error flag Writing 1 clears the TEF flag in the QUADSPI_SR register		
};

// QUADSPI->CCR QUADSPI communication configuration register
enum {
	QUADSPI_CCR_DDRM = 1UL<<31, // Double data rate mode This bit sets the DDR mode for the address, alternate byte and data phase: This field can be written only when BUSY = 0.
	QUADSPI_CCR_DHHC = 1UL<<30, // DDR hold Delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: This feature is only active in DDR mode. This field can be written only when BUSY = 0.
	QUADSPI_CCR_SIOO = 1UL<<28, // Send instruction only once mode See Section15.3.11: Sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0.
	QUADSPI_CCR_FMODE = ((1UL<<2)-1) << 26, // Functional mode This field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0.
	QUADSPI_CCR_DMODE = ((1UL<<2)-1) << 24, // Data mode This field defines the data phases mode of operation: This field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0.
	QUADSPI_CCR_DCYC = ((1UL<<5)-1) << 18, // Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0.
	QUADSPI_CCR_ABSIZE = ((1UL<<2)-1) << 16, // Alternate bytes size This bit defines alternate bytes size: This field can be written only when BUSY = 0.
	QUADSPI_CCR_ABMODE = ((1UL<<2)-1) << 14, // Alternate bytes mode This field defines the alternate-bytes phase mode of operation: This field can be written only when BUSY = 0.
	QUADSPI_CCR_ADSIZE = ((1UL<<2)-1) << 12, // Address size This bit defines address size: This field can be written only when BUSY = 0.
	QUADSPI_CCR_ADMODE = ((1UL<<2)-1) << 10, // Address mode This field defines the address phase mode of operation: This field can be written only when BUSY = 0.
	QUADSPI_CCR_IMODE = ((1UL<<2)-1) << 8, // Instruction mode This field defines the instruction phase mode of operation: This field can be written only when BUSY = 0.
	QUADSPI_CCR_INSTRUCTION = ((1UL<<8)-1) << 0, // Instruction Instruction to be send to the external SPI device. This field can be written only when BUSY = 0.		
};
inline void quadspi_ccr_set_fmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_FMODE) | ((val<<26) & QUADSPI_CCR_FMODE); }
inline void quadspi_ccr_set_dmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_DMODE) | ((val<<24) & QUADSPI_CCR_DMODE); }
inline void quadspi_ccr_set_dcyc(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_DCYC) | ((val<<18) & QUADSPI_CCR_DCYC); }
inline void quadspi_ccr_set_absize(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ABSIZE) | ((val<<16) & QUADSPI_CCR_ABSIZE); }
inline void quadspi_ccr_set_abmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ABMODE) | ((val<<14) & QUADSPI_CCR_ABMODE); }
inline void quadspi_ccr_set_adsize(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ADSIZE) | ((val<<12) & QUADSPI_CCR_ADSIZE); }
inline void quadspi_ccr_set_admode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ADMODE) | ((val<<10) & QUADSPI_CCR_ADMODE); }
inline void quadspi_ccr_set_imode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_IMODE) | ((val<<8) & QUADSPI_CCR_IMODE); }
inline void quadspi_ccr_set_instruction(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_INSTRUCTION) | ((val<<0) & QUADSPI_CCR_INSTRUCTION); }
inline uint32_t quadspi_ccr_get_fmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_FMODE) >> 26 ; }
inline uint32_t quadspi_ccr_get_dmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_DMODE) >> 24 ; }
inline uint32_t quadspi_ccr_get_dcyc(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_DCYC) >> 18 ; }
inline uint32_t quadspi_ccr_get_absize(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ABSIZE) >> 16 ; }
inline uint32_t quadspi_ccr_get_abmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ABMODE) >> 14 ; }
inline uint32_t quadspi_ccr_get_adsize(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ADSIZE) >> 12 ; }
inline uint32_t quadspi_ccr_get_admode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ADMODE) >> 10 ; }
inline uint32_t quadspi_ccr_get_imode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_IMODE) >> 8 ; }
inline uint32_t quadspi_ccr_get_instruction(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_INSTRUCTION) >> 0 ; }

/* ECC controller is associated to each RAM area */
struct RAMECC1_Type {
	__IO uint8_t IER; // @0 RAMECC interrupt enable register
	 uint8_t RESERVED0[31]; // @1 
	__IO uint8_t M1CR; // @32 RAMECC monitor x configuration register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t M1SR; // @36 RAMECC monitor x status register
	 uint8_t RESERVED2[3]; // @37 
	__IO uint8_t M1FAR; // @40 RAMECC monitor x failing address register
	 uint8_t RESERVED3[3]; // @41 
	__IO uint8_t M1FDRL; // @44 RAMECC monitor x failing data low register
	 uint8_t RESERVED4[3]; // @45 
	__IO uint8_t M1FDRH; // @48 RAMECC monitor x failing data high register
	 uint8_t RESERVED5[3]; // @49 
	__IO uint8_t M1FECR; // @52 RAMECC monitor x failing ECC error code register
	 uint8_t RESERVED6[11]; // @53 
	__IO uint8_t M2CR; // @64 RAMECC monitor x configuration register
	 uint8_t RESERVED7[3]; // @65 
	__IO uint8_t M2SR; // @68 RAMECC monitor x status register
	 uint8_t RESERVED8[3]; // @69 
	__IO uint8_t M2FAR; // @72 RAMECC monitor x failing address register
	 uint8_t RESERVED9[3]; // @73 
	__IO uint8_t M2FDRL; // @76 RAMECC monitor x failing data low register
	 uint8_t RESERVED10[3]; // @77 
	__I uint32_t M2FDRH; // @80 RAMECC monitor x failing data high register
	 uint8_t RESERVED11[4]; // @84 
	__I uint32_t M2FECR; // @88 RAMECC monitor x failing ECC error code register
	 uint8_t RESERVED12[4]; // @92 
	__I uint32_t M3CR; // @96 RAMECC monitor x configuration register
	__I uint32_t M3SR; // @100 RAMECC monitor x status register
	__IO uint32_t M3FAR; // @104 RAMECC monitor x failing address register
	__I uint32_t M3FDRL; // @108 RAMECC monitor x failing data low register
	__I uint32_t M3FDRH; // @112 RAMECC monitor x failing data high register
	 uint8_t RESERVED13[8]; // @116 
	__I uint32_t M3FECR; // @124 RAMECC monitor x failing ECC error code register
	__I uint32_t M4CR; // @128 RAMECC monitor x configuration register
	__I uint32_t M4SR; // @132 RAMECC monitor x status register
	__I uint32_t M4FAR; // @136 RAMECC monitor x failing address register
	__IO uint32_t M4FDRL; // @140 RAMECC monitor x failing data low register
	union {  // @144
		__I uint32_t M4FECR; // RAMECC monitor x failing ECC error code register
		__I uint32_t M4FDRH; // RAMECC monitor x failing data high register
	};
	 uint8_t RESERVED14[12]; // @148 
	__I uint32_t M5CR; // @160 RAMECC monitor x configuration register
	__IO uint32_t M5SR; // @164 RAMECC monitor x status register
	__IO uint32_t M5FAR; // @168 RAMECC monitor x failing address register
	__I uint32_t M5FDRL; // @172 RAMECC monitor x failing data low register
	__I uint32_t M5FDRH; // @176 RAMECC monitor x failing data high register
	__I uint32_t M5FECR; // @180 RAMECC monitor x failing ECC error code register
};

// RAMECC1->IER RAMECC interrupt enable register
enum {
	RAMECC1_IER_GECCDEBWIE = 1UL<<3, // Global ECC double error on byte write (BW) interrupt enable
	RAMECC1_IER_GECCDEIE = 1UL<<2, // Global ECC double error interrupt enable
	RAMECC1_IER_GECCSEIE_ = 1UL<<1, // Global ECC single error interrupt enable
	RAMECC1_IER_GIE = 1UL<<0, // Global interrupt enable		
};

// RAMECC1->M1CR RAMECC monitor x configuration register
enum {
	RAMECC1_M1CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC1_M1CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC1_M1CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC1_M1CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC1->M1SR RAMECC monitor x status register
enum {
	RAMECC1_M1SR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC1_M1SR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC1_M1SR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC1_M1SR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC1->M1FAR RAMECC monitor x failing address register
enum {
	RAMECC1_M1FAR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC1_M1FAR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC1_M1FAR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC1_M1FAR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC1->M1FDRL RAMECC monitor x failing data low register
enum {
	RAMECC1_M1FDRL_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC1_M1FDRL_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC1_M1FDRL_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC1_M1FDRL_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC1->M1FDRH RAMECC monitor x failing data high register
enum {
	RAMECC1_M1FDRH_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC1_M1FDRH_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC1_M1FDRH_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC1_M1FDRH_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC1->M1FECR RAMECC monitor x failing ECC error code register
enum {
	RAMECC1_M1FECR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC1_M1FECR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC1_M1FECR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC1->M2CR RAMECC monitor x configuration register
enum {
	RAMECC1_M2CR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC1_M2CR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC1_M2CR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC1->M2SR RAMECC monitor x status register
enum {
	RAMECC1_M2SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC1_M2SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC1_M2SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC1->M2FAR RAMECC monitor x failing address register
enum {
	RAMECC1_M2FAR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC1_M2FAR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC1_M2FAR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC1->M2FDRL RAMECC monitor x failing data low register
enum {
	RAMECC1_M2FDRL_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC1_M2FDRL_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC1_M2FDRL_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

/* ECC controller is associated to each RAM area */
struct RAMECC2_Type {
	__IO uint8_t IER; // @0 RAMECC interrupt enable register
	 uint8_t RESERVED0[31]; // @1 
	__IO uint8_t M1CR; // @32 RAMECC monitor x configuration register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t M1SR; // @36 RAMECC monitor x status register
	 uint8_t RESERVED2[3]; // @37 
	__I uint32_t M1FAR; // @40 RAMECC monitor x failing address register
	__I uint32_t M1FDRL; // @44 RAMECC monitor x failing data low register
	__I uint32_t M1FDRH; // @48 RAMECC monitor x failing data high register
	__IO uint32_t M1FECR; // @52 RAMECC monitor x failing ECC error code register
	 uint8_t RESERVED3[8]; // @56 
	__IO uint8_t M2CR; // @64 RAMECC monitor x configuration register
	 uint8_t RESERVED4[3]; // @65 
	__IO uint8_t M2SR; // @68 RAMECC monitor x status register
	 uint8_t RESERVED5[3]; // @69 
	__I uint32_t M2FAR; // @72 RAMECC monitor x failing address register
	__I uint32_t M2FDRL; // @76 RAMECC monitor x failing data low register
	__IO uint32_t M2FDRH; // @80 RAMECC monitor x failing data high register
	 uint8_t RESERVED6[4]; // @84 
	__IO uint32_t M2FECR; // @88 RAMECC monitor x failing ECC error code register
	 uint8_t RESERVED7[4]; // @92 
	__IO uint8_t M3CR; // @96 RAMECC monitor x configuration register
	 uint8_t RESERVED8[3]; // @97 
	__IO uint8_t M3SR; // @100 RAMECC monitor x status register
	 uint8_t RESERVED9[3]; // @101 
	__I uint32_t M3FAR; // @104 RAMECC monitor x failing address register
	__I uint32_t M3FDRL; // @108 RAMECC monitor x failing data low register
	__I uint32_t M3FDRH; // @112 RAMECC monitor x failing data high register
	 uint8_t RESERVED10[8]; // @116 
	__I uint32_t M3FECR; // @124 RAMECC monitor x failing ECC error code register
	__IO uint8_t M4CR; // @128 RAMECC monitor x configuration register
	 uint8_t RESERVED11[3]; // @129 
	__IO uint8_t M4SR; // @132 RAMECC monitor x status register
	 uint8_t RESERVED12[3]; // @133 
	__I uint32_t M4FAR; // @136 RAMECC monitor x failing address register
	__I uint32_t M4FDRL; // @140 RAMECC monitor x failing data low register
	union {  // @144
		__I uint32_t M4FECR; // RAMECC monitor x failing ECC error code register
		__I uint32_t M4FDRH; // RAMECC monitor x failing data high register
	};
	 uint8_t RESERVED13[12]; // @148 
	__IO uint8_t M5CR; // @160 RAMECC monitor x configuration register
	 uint8_t RESERVED14[3]; // @161 
	__IO uint8_t M5SR; // @164 RAMECC monitor x status register
	 uint8_t RESERVED15[3]; // @165 
	__IO uint32_t M5FAR; // @168 RAMECC monitor x failing address register
	__I uint32_t M5FDRL; // @172 RAMECC monitor x failing data low register
	__I uint32_t M5FDRH; // @176 RAMECC monitor x failing data high register
	__I uint32_t M5FECR; // @180 RAMECC monitor x failing ECC error code register
};

// RAMECC2->IER RAMECC interrupt enable register
enum {
	RAMECC2_IER_GECCDEBWIE = 1UL<<3, // Global ECC double error on byte write (BW) interrupt enable
	RAMECC2_IER_GECCDEIE = 1UL<<2, // Global ECC double error interrupt enable
	RAMECC2_IER_GECCSEIE_ = 1UL<<1, // Global ECC single error interrupt enable
	RAMECC2_IER_GIE = 1UL<<0, // Global interrupt enable		
};

// RAMECC2->M1CR RAMECC monitor x configuration register
enum {
	RAMECC2_M1CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC2_M1CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC2_M1CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC2_M1CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC2->M1SR RAMECC monitor x status register
enum {
	RAMECC2_M1SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC2_M1SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC2_M1SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC2->M2CR RAMECC monitor x configuration register
enum {
	RAMECC2_M2CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC2_M2CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC2_M2CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC2_M2CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC2->M2SR RAMECC monitor x status register
enum {
	RAMECC2_M2SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC2_M2SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC2_M2SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC2->M3CR RAMECC monitor x configuration register
enum {
	RAMECC2_M3CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC2_M3CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC2_M3CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC2_M3CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC2->M3SR RAMECC monitor x status register
enum {
	RAMECC2_M3SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC2_M3SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC2_M3SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC2->M4CR RAMECC monitor x configuration register
enum {
	RAMECC2_M4CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC2_M4CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC2_M4CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC2_M4CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC2->M4SR RAMECC monitor x status register
enum {
	RAMECC2_M4SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC2_M4SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC2_M4SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC2->M5CR RAMECC monitor x configuration register
enum {
	RAMECC2_M5CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC2_M5CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC2_M5CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC2_M5CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC2->M5SR RAMECC monitor x status register
enum {
	RAMECC2_M5SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC2_M5SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC2_M5SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// Valid Casts:
 
inline struct RAMECC3_Type* RAMECC2_as_RAMECC3_Type(struct RAMECC2_Type* p) { return (struct RAMECC3_Type*)p; }


/* ECC controller is associated to each RAM area */
struct RAMECC3_Type {
	__IO uint8_t IER; // @0 RAMECC interrupt enable register
	 uint8_t RESERVED0[31]; // @1 
	__IO uint8_t M1CR; // @32 RAMECC monitor x configuration register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t M1SR; // @36 RAMECC monitor x status register
	 uint8_t RESERVED2[3]; // @37 
	__I uint32_t M1FAR; // @40 RAMECC monitor x failing address register
	__I uint32_t M1FDRL; // @44 RAMECC monitor x failing data low register
	__I uint32_t M1FDRH; // @48 RAMECC monitor x failing data high register
	__IO uint32_t M1FECR; // @52 RAMECC monitor x failing ECC error code register
	 uint8_t RESERVED3[8]; // @56 
	__IO uint8_t M2CR; // @64 RAMECC monitor x configuration register
	 uint8_t RESERVED4[3]; // @65 
	__IO uint8_t M2SR; // @68 RAMECC monitor x status register
	 uint8_t RESERVED5[3]; // @69 
	__I uint32_t M2FAR; // @72 RAMECC monitor x failing address register
	__I uint32_t M2FDRL; // @76 RAMECC monitor x failing data low register
	__IO uint32_t M2FDRH; // @80 RAMECC monitor x failing data high register
	 uint8_t RESERVED6[4]; // @84 
	__IO uint32_t M2FECR; // @88 RAMECC monitor x failing ECC error code register
};

// RAMECC3->IER RAMECC interrupt enable register
enum {
	RAMECC3_IER_GECCDEBWIE = 1UL<<3, // Global ECC double error on byte write (BW) interrupt enable
	RAMECC3_IER_GECCDEIE = 1UL<<2, // Global ECC double error interrupt enable
	RAMECC3_IER_GECCSEIE_ = 1UL<<1, // Global ECC single error interrupt enable
	RAMECC3_IER_GIE = 1UL<<0, // Global interrupt enable		
};

// RAMECC3->M1CR RAMECC monitor x configuration register
enum {
	RAMECC3_M1CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC3_M1CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC3_M1CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC3_M1CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC3->M1SR RAMECC monitor x status register
enum {
	RAMECC3_M1SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC3_M1SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC3_M1SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

// RAMECC3->M2CR RAMECC monitor x configuration register
enum {
	RAMECC3_M2CR_ECCELEN = 1UL<<5, // ECC error latching enable
	RAMECC3_M2CR_ECCDEBWIE = 1UL<<4, // ECC double error on byte write (BW) interrupt enable
	RAMECC3_M2CR_ECCDEIE = 1UL<<3, // ECC double error interrupt enable
	RAMECC3_M2CR_ECCSEIE = 1UL<<2, // ECC single error interrupt enable		
};

// RAMECC3->M2SR RAMECC monitor x status register
enum {
	RAMECC3_M2SR_DEBWDF = 1UL<<2, // ECC double error on byte write (BW) detected flag
	RAMECC3_M2SR_DEDF = 1UL<<1, // ECC double error detected flag
	RAMECC3_M2SR_SEDCF = 1UL<<0, // ECC single error detected and corrected flag		
};

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR; // @0 clock control register
	__IO uint32_t ICSCR; // @4 RCC Internal Clock Source Calibration Register
	__I uint16_t CRRCR; // @8 RCC Clock Recovery RC Register
	 uint8_t RESERVED0[6]; // @10 
	__IO uint32_t CFGR; // @16 RCC Clock Configuration Register
	 uint8_t RESERVED1[4]; // @20 
	__IO uint16_t D1CFGR; // @24 RCC Domain 1 Clock Configuration Register
	 uint8_t RESERVED2[2]; // @26 
	__IO uint16_t D2CFGR; // @28 RCC Domain 2 Clock Configuration Register
	 uint8_t RESERVED3[2]; // @30 
	__IO uint8_t D3CFGR; // @32 RCC Domain 3 Clock Configuration Register
	 uint8_t RESERVED4[7]; // @33 
	__IO uint32_t PLLCKSELR; // @40 RCC PLLs Clock Source Selection Register
	__IO uint32_t PLLCFGR; // @44 RCC PLLs Configuration Register
	__IO uint32_t PLL1DIVR; // @48 RCC PLL1 Dividers Configuration Register
	__IO uint16_t PLL1FRACR; // @52 RCC PLL1 Fractional Divider Register
	 uint8_t RESERVED5[2]; // @54 
	__IO uint32_t PLL2DIVR; // @56 RCC PLL2 Dividers Configuration Register
	__IO uint16_t PLL2FRACR; // @60 RCC PLL2 Fractional Divider Register
	 uint8_t RESERVED6[2]; // @62 
	__IO uint32_t PLL3DIVR; // @64 RCC PLL3 Dividers Configuration Register
	__IO uint16_t PLL3FRACR; // @68 RCC PLL3 Fractional Divider Register
	 uint8_t RESERVED7[6]; // @70 
	__IO uint32_t D1CCIPR; // @76 RCC Domain 1 Kernel Clock Configuration Register
	__IO uint32_t D2CCIP1R; // @80 RCC Domain 2 Kernel Clock Configuration Register
	__IO uint32_t D2CCIP2R; // @84 RCC Domain 2 Kernel Clock Configuration Register
	__IO uint32_t D3CCIPR; // @88 RCC Domain 3 Kernel Clock Configuration Register
	 uint8_t RESERVED8[4]; // @92 
	__IO uint16_t CIER; // @96 RCC Clock Source Interrupt Enable Register
	 uint8_t RESERVED9[2]; // @98 
	__IO uint16_t CIFR; // @100 RCC Clock Source Interrupt Flag Register
	 uint8_t RESERVED10[2]; // @102 
	__IO uint16_t CICR; // @104 RCC Clock Source Interrupt Clear Register
	 uint8_t RESERVED11[6]; // @106 
	__IO uint32_t BDCR; // @112 RCC Backup Domain Control Register
	__IO uint8_t CSR; // @116 RCC Clock Control and Status Register
	 uint8_t RESERVED12[7]; // @117 
	__IO uint32_t AHB3RSTR; // @124 RCC AHB3 Reset Register
	__IO uint32_t AHB1RSTR; // @128 RCC AHB1 Peripheral Reset Register
	__IO uint16_t AHB2RSTR; // @132 RCC AHB2 Peripheral Reset Register
	 uint8_t RESERVED13[2]; // @134 
	__IO uint32_t AHB4RSTR; // @136 RCC AHB4 Peripheral Reset Register
	__IO uint8_t APB3RSTR; // @140 RCC APB3 Peripheral Reset Register
	 uint8_t RESERVED14[3]; // @141 
	__IO uint32_t APB1LRSTR; // @144 RCC APB1 Peripheral Reset Register
	__IO uint16_t APB1HRSTR; // @148 RCC APB1 Peripheral Reset Register
	 uint8_t RESERVED15[2]; // @150 
	__IO uint32_t APB2RSTR; // @152 RCC APB2 Peripheral Reset Register
	__IO uint32_t APB4RSTR; // @156 RCC APB4 Peripheral Reset Register
	__IO uint8_t GCR; // @160 RCC Global Control Register
	 uint8_t RESERVED16[7]; // @161 
	__IO uint32_t D3AMR; // @168 RCC D3 Autonomous mode Register
	 uint8_t RESERVED17[36]; // @172 
	__IO uint32_t RSR; // @208 RCC Reset Status Register
	__IO uint32_t AHB3ENR; // @212 RCC AHB3 Clock Register
	__IO uint32_t AHB1ENR; // @216 RCC AHB1 Clock Register
	__IO uint32_t AHB2ENR; // @220 RCC AHB2 Clock Register
	__IO uint32_t AHB4ENR; // @224 RCC AHB4 Clock Register
	__IO uint8_t APB3ENR; // @228 RCC APB3 Clock Register
	 uint8_t RESERVED18[3]; // @229 
	__IO uint32_t APB1LENR; // @232 RCC APB1 Clock Register
	__IO uint16_t APB1HENR; // @236 RCC APB1 Clock Register
	 uint8_t RESERVED19[2]; // @238 
	__IO uint32_t APB2ENR; // @240 RCC APB2 Clock Register
	__IO uint32_t APB4ENR; // @244 RCC APB4 Clock Register
	 uint8_t RESERVED20[4]; // @248 
	__IO uint32_t AHB3LPENR; // @252 RCC AHB3 Sleep Clock Register
	__IO uint32_t AHB1LPENR; // @256 RCC AHB1 Sleep Clock Register
	__IO uint32_t AHB2LPENR; // @260 RCC AHB2 Sleep Clock Register
	__IO uint32_t AHB4LPENR; // @264 RCC AHB4 Sleep Clock Register
	__IO uint8_t APB3LPENR; // @268 RCC APB3 Sleep Clock Register
	 uint8_t RESERVED21[3]; // @269 
	__IO uint32_t APB1LLPENR; // @272 RCC APB1 Low Sleep Clock Register
	__IO uint16_t APB1HLPENR; // @276 RCC APB1 High Sleep Clock Register
	 uint8_t RESERVED22[2]; // @278 
	__IO uint32_t APB2LPENR; // @280 RCC APB2 Sleep Clock Register
	__IO uint32_t APB4LPENR; // @284 RCC APB4 Sleep Clock Register
	 uint8_t RESERVED23[16]; // @288 
	__IO uint32_t C1_RSR; // @304 RCC Reset Status Register
	__IO uint32_t C1_AHB3ENR; // @308 RCC AHB3 Clock Register
	__IO uint32_t C1_AHB1ENR; // @312 RCC AHB1 Clock Register
	__IO uint32_t C1_AHB2ENR; // @316 RCC AHB2 Clock Register
	__IO uint32_t C1_AHB4ENR; // @320 RCC AHB4 Clock Register
	__IO uint8_t C1_APB3ENR; // @324 RCC APB3 Clock Register
	 uint8_t RESERVED24[3]; // @325 
	__IO uint32_t C1_APB1LENR; // @328 RCC APB1 Clock Register
	__IO uint16_t C1_APB1HENR; // @332 RCC APB1 Clock Register
	 uint8_t RESERVED25[2]; // @334 
	__IO uint32_t C1_APB2ENR; // @336 RCC APB2 Clock Register
	__IO uint32_t C1_APB4ENR; // @340 RCC APB4 Clock Register
	 uint8_t RESERVED26[4]; // @344 
	__IO uint32_t C1_AHB3LPENR; // @348 RCC AHB3 Sleep Clock Register
	__IO uint32_t C1_AHB1LPENR; // @352 RCC AHB1 Sleep Clock Register
	__IO uint32_t C1_AHB2LPENR; // @356 RCC AHB2 Sleep Clock Register
	__IO uint32_t C1_AHB4LPENR; // @360 RCC AHB4 Sleep Clock Register
	__IO uint8_t C1_APB3LPENR; // @364 RCC APB3 Sleep Clock Register
	 uint8_t RESERVED27[3]; // @365 
	__IO uint32_t C1_APB1LLPENR; // @368 RCC APB1 Low Sleep Clock Register
	__IO uint16_t C1_APB1HLPENR; // @372 RCC APB1 High Sleep Clock Register
	 uint8_t RESERVED28[2]; // @374 
	__IO uint32_t C1_APB2LPENR; // @376 RCC APB2 Sleep Clock Register
	__IO uint32_t C1_APB4LPENR; // @380 RCC APB4 Sleep Clock Register
};

// RCC->CR clock control register
enum {
	RCC_CR_PLL3RDY = 1UL<<29, // PLL3 clock ready flag
	RCC_CR_PLL3ON = 1UL<<28, // PLL3 enable
	RCC_CR_PLL2RDY = 1UL<<27, // PLL2 clock ready flag
	RCC_CR_PLL2ON = 1UL<<26, // PLL2 enable
	RCC_CR_PLL1RDY = 1UL<<25, // PLL1 clock ready flag
	RCC_CR_PLL1ON = 1UL<<24, // PLL1 enable
	RCC_CR_HSECSSON = 1UL<<19, // HSE Clock Security System enable
	RCC_CR_HSEBYP = 1UL<<18, // HSE clock bypass
	RCC_CR_HSERDY = 1UL<<17, // HSE clock ready flag
	RCC_CR_HSEON = 1UL<<16, // HSE clock enable
	RCC_CR_D2CKRDY = 1UL<<15, // D2 domain clocks ready flag
	RCC_CR_D1CKRDY = 1UL<<14, // D1 domain clocks ready flag
	RCC_CR_RC48RDY = 1UL<<13, // RC48 clock ready flag
	RCC_CR_RC48ON = 1UL<<12, // RC48 clock enable
	RCC_CR_CSIKERON = 1UL<<9, // CSI clock enable in Stop mode
	RCC_CR_CSIRDY = 1UL<<8, // CSI clock ready flag
	RCC_CR_CSION = 1UL<<7, // CSI clock enable
	RCC_CR_HSIDIVF = 1UL<<5, // HSI divider flag
	RCC_CR_HSIDIV = ((1UL<<2)-1) << 3, // HSI clock divider
	RCC_CR_HSIRDY = 1UL<<2, // HSI clock ready flag
	RCC_CR_HSIKERON = 1UL<<1, // High Speed Internal clock enable in Stop mode
	RCC_CR_HSION = 1UL<<0, // Internal high-speed clock enable		
};
inline void rcc_cr_set_hsidiv(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_HSIDIV) | ((val<<3) & RCC_CR_HSIDIV); }
inline uint32_t rcc_cr_get_hsidiv(struct RCC_Type* p) { return (p->CR & RCC_CR_HSIDIV) >> 3 ; }

// RCC->ICSCR RCC Internal Clock Source Calibration Register
enum {
	RCC_ICSCR_CSITRIM = ((1UL<<5)-1) << 26, // CSI clock trimming
	RCC_ICSCR_CSICAL = ((1UL<<8)-1) << 18, // CSI clock calibration
	RCC_ICSCR_HSITRIM = ((1UL<<6)-1) << 12, // HSI clock trimming
	RCC_ICSCR_HSICAL = ((1UL<<12)-1) << 0, // HSI clock calibration		
};
inline void rcc_icscr_set_csitrim(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_CSITRIM) | ((val<<26) & RCC_ICSCR_CSITRIM); }
inline void rcc_icscr_set_csical(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_CSICAL) | ((val<<18) & RCC_ICSCR_CSICAL); }
inline void rcc_icscr_set_hsitrim(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSITRIM) | ((val<<12) & RCC_ICSCR_HSITRIM); }
inline void rcc_icscr_set_hsical(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSICAL) | ((val<<0) & RCC_ICSCR_HSICAL); }
inline uint32_t rcc_icscr_get_csitrim(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_CSITRIM) >> 26 ; }
inline uint32_t rcc_icscr_get_csical(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_CSICAL) >> 18 ; }
inline uint32_t rcc_icscr_get_hsitrim(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSITRIM) >> 12 ; }
inline uint32_t rcc_icscr_get_hsical(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSICAL) >> 0 ; }

// RCC->CRRCR RCC Clock Recovery RC Register
enum {
	RCC_CRRCR_RC48CAL = ((1UL<<10)-1) << 0, // Internal RC 48 MHz clock calibration		
};
inline uint32_t rcc_crrcr_get_rc48cal(struct RCC_Type* p) { return (p->CRRCR & RCC_CRRCR_RC48CAL) >> 0 ; }

// RCC->CFGR RCC Clock Configuration Register
enum {
	RCC_CFGR_MCO2SEL = ((1UL<<3)-1) << 29, // Micro-controller clock output 2
	RCC_CFGR_MCO2PRE = ((1UL<<4)-1) << 25, // MCO2 prescaler
	RCC_CFGR_MCO1SEL = ((1UL<<3)-1) << 22, // Micro-controller clock output 1
	RCC_CFGR_MCO1PRE = ((1UL<<4)-1) << 18, // MCO1 prescaler
	RCC_CFGR_TIMPRE = 1UL<<15, // Timers clocks prescaler selection
	RCC_CFGR_HRTIMSEL = 1UL<<14, // High Resolution Timer clock prescaler selection
	RCC_CFGR_RTCPRE = ((1UL<<6)-1) << 8, // HSE division factor for RTC clock
	RCC_CFGR_STOPKERWUCK = 1UL<<7, // Kernel clock selection after a wake up from system Stop
	RCC_CFGR_STOPWUCK = 1UL<<6, // System clock selection after a wake up from system Stop
	RCC_CFGR_SWS = ((1UL<<3)-1) << 3, // System clock switch status
	RCC_CFGR_SW = ((1UL<<3)-1) << 0, // System clock switch		
};
inline void rcc_cfgr_set_mco2sel(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO2SEL) | ((val<<29) & RCC_CFGR_MCO2SEL); }
inline void rcc_cfgr_set_mco2pre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO2PRE) | ((val<<25) & RCC_CFGR_MCO2PRE); }
inline void rcc_cfgr_set_mco1sel(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO1SEL) | ((val<<22) & RCC_CFGR_MCO1SEL); }
inline void rcc_cfgr_set_mco1pre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCO1PRE) | ((val<<18) & RCC_CFGR_MCO1PRE); }
inline void rcc_cfgr_set_rtcpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_RTCPRE) | ((val<<8) & RCC_CFGR_RTCPRE); }
inline void rcc_cfgr_set_sws(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val<<3) & RCC_CFGR_SWS); }
inline void rcc_cfgr_set_sw(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val<<0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mco2sel(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO2SEL) >> 29 ; }
inline uint32_t rcc_cfgr_get_mco2pre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO2PRE) >> 25 ; }
inline uint32_t rcc_cfgr_get_mco1sel(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO1SEL) >> 22 ; }
inline uint32_t rcc_cfgr_get_mco1pre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCO1PRE) >> 18 ; }
inline uint32_t rcc_cfgr_get_rtcpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_RTCPRE) >> 8 ; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SWS) >> 3 ; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SW) >> 0 ; }

// RCC->D1CFGR RCC Domain 1 Clock Configuration Register
enum {
	RCC_D1CFGR_D1CPRE = ((1UL<<4)-1) << 8, // D1 domain Core prescaler
	RCC_D1CFGR_D1PPRE = ((1UL<<3)-1) << 4, // D1 domain APB3 prescaler
	RCC_D1CFGR_HPRE = ((1UL<<4)-1) << 0, // D1 domain AHB prescaler		
};
inline void rcc_d1cfgr_set_d1cpre(struct RCC_Type* p, uint32_t val) { p->D1CFGR = (p->D1CFGR & ~RCC_D1CFGR_D1CPRE) | ((val<<8) & RCC_D1CFGR_D1CPRE); }
inline void rcc_d1cfgr_set_d1ppre(struct RCC_Type* p, uint32_t val) { p->D1CFGR = (p->D1CFGR & ~RCC_D1CFGR_D1PPRE) | ((val<<4) & RCC_D1CFGR_D1PPRE); }
inline void rcc_d1cfgr_set_hpre(struct RCC_Type* p, uint32_t val) { p->D1CFGR = (p->D1CFGR & ~RCC_D1CFGR_HPRE) | ((val<<0) & RCC_D1CFGR_HPRE); }
inline uint32_t rcc_d1cfgr_get_d1cpre(struct RCC_Type* p) { return (p->D1CFGR & RCC_D1CFGR_D1CPRE) >> 8 ; }
inline uint32_t rcc_d1cfgr_get_d1ppre(struct RCC_Type* p) { return (p->D1CFGR & RCC_D1CFGR_D1PPRE) >> 4 ; }
inline uint32_t rcc_d1cfgr_get_hpre(struct RCC_Type* p) { return (p->D1CFGR & RCC_D1CFGR_HPRE) >> 0 ; }

// RCC->D2CFGR RCC Domain 2 Clock Configuration Register
enum {
	RCC_D2CFGR_D2PPRE2 = ((1UL<<3)-1) << 8, // D2 domain APB2 prescaler
	RCC_D2CFGR_D2PPRE1 = ((1UL<<3)-1) << 4, // D2 domain APB1 prescaler		
};
inline void rcc_d2cfgr_set_d2ppre2(struct RCC_Type* p, uint32_t val) { p->D2CFGR = (p->D2CFGR & ~RCC_D2CFGR_D2PPRE2) | ((val<<8) & RCC_D2CFGR_D2PPRE2); }
inline void rcc_d2cfgr_set_d2ppre1(struct RCC_Type* p, uint32_t val) { p->D2CFGR = (p->D2CFGR & ~RCC_D2CFGR_D2PPRE1) | ((val<<4) & RCC_D2CFGR_D2PPRE1); }
inline uint32_t rcc_d2cfgr_get_d2ppre2(struct RCC_Type* p) { return (p->D2CFGR & RCC_D2CFGR_D2PPRE2) >> 8 ; }
inline uint32_t rcc_d2cfgr_get_d2ppre1(struct RCC_Type* p) { return (p->D2CFGR & RCC_D2CFGR_D2PPRE1) >> 4 ; }

// RCC->D3CFGR RCC Domain 3 Clock Configuration Register
enum {
	RCC_D3CFGR_D3PPRE = ((1UL<<3)-1) << 4, // D3 domain APB4 prescaler		
};
inline void rcc_d3cfgr_set_d3ppre(struct RCC_Type* p, uint32_t val) { p->D3CFGR = (p->D3CFGR & ~RCC_D3CFGR_D3PPRE) | ((val<<4) & RCC_D3CFGR_D3PPRE); }
inline uint32_t rcc_d3cfgr_get_d3ppre(struct RCC_Type* p) { return (p->D3CFGR & RCC_D3CFGR_D3PPRE) >> 4 ; }

// RCC->PLLCKSELR RCC PLLs Clock Source Selection Register
enum {
	RCC_PLLCKSELR_DIVM3 = ((1UL<<6)-1) << 20, // Prescaler for PLL3
	RCC_PLLCKSELR_DIVM2 = ((1UL<<6)-1) << 12, // Prescaler for PLL2
	RCC_PLLCKSELR_DIVM1 = ((1UL<<6)-1) << 4, // Prescaler for PLL1
	RCC_PLLCKSELR_PLLSRC = ((1UL<<2)-1) << 0, // DIVMx and PLLs clock source selection		
};
inline void rcc_pllckselr_set_divm3(struct RCC_Type* p, uint32_t val) { p->PLLCKSELR = (p->PLLCKSELR & ~RCC_PLLCKSELR_DIVM3) | ((val<<20) & RCC_PLLCKSELR_DIVM3); }
inline void rcc_pllckselr_set_divm2(struct RCC_Type* p, uint32_t val) { p->PLLCKSELR = (p->PLLCKSELR & ~RCC_PLLCKSELR_DIVM2) | ((val<<12) & RCC_PLLCKSELR_DIVM2); }
inline void rcc_pllckselr_set_divm1(struct RCC_Type* p, uint32_t val) { p->PLLCKSELR = (p->PLLCKSELR & ~RCC_PLLCKSELR_DIVM1) | ((val<<4) & RCC_PLLCKSELR_DIVM1); }
inline void rcc_pllckselr_set_pllsrc(struct RCC_Type* p, uint32_t val) { p->PLLCKSELR = (p->PLLCKSELR & ~RCC_PLLCKSELR_PLLSRC) | ((val<<0) & RCC_PLLCKSELR_PLLSRC); }
inline uint32_t rcc_pllckselr_get_divm3(struct RCC_Type* p) { return (p->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20 ; }
inline uint32_t rcc_pllckselr_get_divm2(struct RCC_Type* p) { return (p->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12 ; }
inline uint32_t rcc_pllckselr_get_divm1(struct RCC_Type* p) { return (p->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4 ; }
inline uint32_t rcc_pllckselr_get_pllsrc(struct RCC_Type* p) { return (p->PLLCKSELR & RCC_PLLCKSELR_PLLSRC) >> 0 ; }

// RCC->PLLCFGR RCC PLLs Configuration Register
enum {
	RCC_PLLCFGR_DIVR3EN = 1UL<<24, // PLL3 DIVR divider output enable
	RCC_PLLCFGR_DIVQ3EN = 1UL<<23, // PLL3 DIVQ divider output enable
	RCC_PLLCFGR_DIVP3EN = 1UL<<22, // PLL3 DIVP divider output enable
	RCC_PLLCFGR_DIVR2EN = 1UL<<21, // PLL2 DIVR divider output enable
	RCC_PLLCFGR_DIVQ2EN = 1UL<<20, // PLL2 DIVQ divider output enable
	RCC_PLLCFGR_DIVP2EN = 1UL<<19, // PLL2 DIVP divider output enable
	RCC_PLLCFGR_DIVR1EN = 1UL<<18, // PLL1 DIVR divider output enable
	RCC_PLLCFGR_DIVQ1EN = 1UL<<17, // PLL1 DIVQ divider output enable
	RCC_PLLCFGR_DIVP1EN = 1UL<<16, // PLL1 DIVP divider output enable
	RCC_PLLCFGR_PLL3RGE = ((1UL<<2)-1) << 10, // PLL3 input frequency range
	RCC_PLLCFGR_PLL3VCOSEL = 1UL<<9, // PLL3 VCO selection
	RCC_PLLCFGR_PLL3FRACEN = 1UL<<8, // PLL3 fractional latch enable
	RCC_PLLCFGR_PLL2RGE = ((1UL<<2)-1) << 6, // PLL2 input frequency range
	RCC_PLLCFGR_PLL2VCOSEL = 1UL<<5, // PLL2 VCO selection
	RCC_PLLCFGR_PLL2FRACEN = 1UL<<4, // PLL2 fractional latch enable
	RCC_PLLCFGR_PLL1RGE = ((1UL<<2)-1) << 2, // PLL1 input frequency range
	RCC_PLLCFGR_PLL1VCOSEL = 1UL<<1, // PLL1 VCO selection
	RCC_PLLCFGR_PLL1FRACEN = 1UL<<0, // PLL1 fractional latch enable		
};
inline void rcc_pllcfgr_set_pll3rge(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLL3RGE) | ((val<<10) & RCC_PLLCFGR_PLL3RGE); }
inline void rcc_pllcfgr_set_pll2rge(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLL2RGE) | ((val<<6) & RCC_PLLCFGR_PLL2RGE); }
inline void rcc_pllcfgr_set_pll1rge(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLL1RGE) | ((val<<2) & RCC_PLLCFGR_PLL1RGE); }
inline uint32_t rcc_pllcfgr_get_pll3rge(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> 10 ; }
inline uint32_t rcc_pllcfgr_get_pll2rge(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> 6 ; }
inline uint32_t rcc_pllcfgr_get_pll1rge(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLL1RGE) >> 2 ; }

// RCC->PLL1DIVR RCC PLL1 Dividers Configuration Register
enum {
	RCC_PLL1DIVR_DIVR1 = ((1UL<<7)-1) << 24, // PLL1 DIVR division factor
	RCC_PLL1DIVR_DIVQ1 = ((1UL<<7)-1) << 16, // PLL1 DIVQ division factor
	RCC_PLL1DIVR_DIVP1 = ((1UL<<7)-1) << 9, // PLL1 DIVP division factor
	RCC_PLL1DIVR_DIVN1 = ((1UL<<9)-1) << 0, // Multiplication factor for PLL1 VCO		
};
inline void rcc_pll1divr_set_divr1(struct RCC_Type* p, uint32_t val) { p->PLL1DIVR = (p->PLL1DIVR & ~RCC_PLL1DIVR_DIVR1) | ((val<<24) & RCC_PLL1DIVR_DIVR1); }
inline void rcc_pll1divr_set_divq1(struct RCC_Type* p, uint32_t val) { p->PLL1DIVR = (p->PLL1DIVR & ~RCC_PLL1DIVR_DIVQ1) | ((val<<16) & RCC_PLL1DIVR_DIVQ1); }
inline void rcc_pll1divr_set_divp1(struct RCC_Type* p, uint32_t val) { p->PLL1DIVR = (p->PLL1DIVR & ~RCC_PLL1DIVR_DIVP1) | ((val<<9) & RCC_PLL1DIVR_DIVP1); }
inline void rcc_pll1divr_set_divn1(struct RCC_Type* p, uint32_t val) { p->PLL1DIVR = (p->PLL1DIVR & ~RCC_PLL1DIVR_DIVN1) | ((val<<0) & RCC_PLL1DIVR_DIVN1); }
inline uint32_t rcc_pll1divr_get_divr1(struct RCC_Type* p) { return (p->PLL1DIVR & RCC_PLL1DIVR_DIVR1) >> 24 ; }
inline uint32_t rcc_pll1divr_get_divq1(struct RCC_Type* p) { return (p->PLL1DIVR & RCC_PLL1DIVR_DIVQ1) >> 16 ; }
inline uint32_t rcc_pll1divr_get_divp1(struct RCC_Type* p) { return (p->PLL1DIVR & RCC_PLL1DIVR_DIVP1) >> 9 ; }
inline uint32_t rcc_pll1divr_get_divn1(struct RCC_Type* p) { return (p->PLL1DIVR & RCC_PLL1DIVR_DIVN1) >> 0 ; }

// RCC->PLL1FRACR RCC PLL1 Fractional Divider Register
enum {
	RCC_PLL1FRACR_FRACN1 = ((1UL<<13)-1) << 3, // Fractional part of the multiplication factor for PLL1 VCO		
};
inline void rcc_pll1fracr_set_fracn1(struct RCC_Type* p, uint32_t val) { p->PLL1FRACR = (p->PLL1FRACR & ~RCC_PLL1FRACR_FRACN1) | ((val<<3) & RCC_PLL1FRACR_FRACN1); }
inline uint32_t rcc_pll1fracr_get_fracn1(struct RCC_Type* p) { return (p->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3 ; }

// RCC->PLL2DIVR RCC PLL2 Dividers Configuration Register
enum {
	RCC_PLL2DIVR_DIVR1 = ((1UL<<7)-1) << 24, // PLL1 DIVR division factor
	RCC_PLL2DIVR_DIVQ1 = ((1UL<<7)-1) << 16, // PLL1 DIVQ division factor
	RCC_PLL2DIVR_DIVP1 = ((1UL<<7)-1) << 9, // PLL1 DIVP division factor
	RCC_PLL2DIVR_DIVN1 = ((1UL<<9)-1) << 0, // Multiplication factor for PLL1 VCO		
};
inline void rcc_pll2divr_set_divr1(struct RCC_Type* p, uint32_t val) { p->PLL2DIVR = (p->PLL2DIVR & ~RCC_PLL2DIVR_DIVR1) | ((val<<24) & RCC_PLL2DIVR_DIVR1); }
inline void rcc_pll2divr_set_divq1(struct RCC_Type* p, uint32_t val) { p->PLL2DIVR = (p->PLL2DIVR & ~RCC_PLL2DIVR_DIVQ1) | ((val<<16) & RCC_PLL2DIVR_DIVQ1); }
inline void rcc_pll2divr_set_divp1(struct RCC_Type* p, uint32_t val) { p->PLL2DIVR = (p->PLL2DIVR & ~RCC_PLL2DIVR_DIVP1) | ((val<<9) & RCC_PLL2DIVR_DIVP1); }
inline void rcc_pll2divr_set_divn1(struct RCC_Type* p, uint32_t val) { p->PLL2DIVR = (p->PLL2DIVR & ~RCC_PLL2DIVR_DIVN1) | ((val<<0) & RCC_PLL2DIVR_DIVN1); }
inline uint32_t rcc_pll2divr_get_divr1(struct RCC_Type* p) { return (p->PLL2DIVR & RCC_PLL2DIVR_DIVR1) >> 24 ; }
inline uint32_t rcc_pll2divr_get_divq1(struct RCC_Type* p) { return (p->PLL2DIVR & RCC_PLL2DIVR_DIVQ1) >> 16 ; }
inline uint32_t rcc_pll2divr_get_divp1(struct RCC_Type* p) { return (p->PLL2DIVR & RCC_PLL2DIVR_DIVP1) >> 9 ; }
inline uint32_t rcc_pll2divr_get_divn1(struct RCC_Type* p) { return (p->PLL2DIVR & RCC_PLL2DIVR_DIVN1) >> 0 ; }

// RCC->PLL2FRACR RCC PLL2 Fractional Divider Register
enum {
	RCC_PLL2FRACR_FRACN2 = ((1UL<<13)-1) << 3, // Fractional part of the multiplication factor for PLL VCO		
};
inline void rcc_pll2fracr_set_fracn2(struct RCC_Type* p, uint32_t val) { p->PLL2FRACR = (p->PLL2FRACR & ~RCC_PLL2FRACR_FRACN2) | ((val<<3) & RCC_PLL2FRACR_FRACN2); }
inline uint32_t rcc_pll2fracr_get_fracn2(struct RCC_Type* p) { return (p->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3 ; }

// RCC->PLL3DIVR RCC PLL3 Dividers Configuration Register
enum {
	RCC_PLL3DIVR_DIVR3 = ((1UL<<7)-1) << 24, // PLL DIVR division factor
	RCC_PLL3DIVR_DIVQ3 = ((1UL<<7)-1) << 16, // PLL DIVQ division factor
	RCC_PLL3DIVR_DIVP3 = ((1UL<<7)-1) << 9, // PLL DIVP division factor
	RCC_PLL3DIVR_DIVN3 = ((1UL<<9)-1) << 0, // Multiplication factor for PLL1 VCO		
};
inline void rcc_pll3divr_set_divr3(struct RCC_Type* p, uint32_t val) { p->PLL3DIVR = (p->PLL3DIVR & ~RCC_PLL3DIVR_DIVR3) | ((val<<24) & RCC_PLL3DIVR_DIVR3); }
inline void rcc_pll3divr_set_divq3(struct RCC_Type* p, uint32_t val) { p->PLL3DIVR = (p->PLL3DIVR & ~RCC_PLL3DIVR_DIVQ3) | ((val<<16) & RCC_PLL3DIVR_DIVQ3); }
inline void rcc_pll3divr_set_divp3(struct RCC_Type* p, uint32_t val) { p->PLL3DIVR = (p->PLL3DIVR & ~RCC_PLL3DIVR_DIVP3) | ((val<<9) & RCC_PLL3DIVR_DIVP3); }
inline void rcc_pll3divr_set_divn3(struct RCC_Type* p, uint32_t val) { p->PLL3DIVR = (p->PLL3DIVR & ~RCC_PLL3DIVR_DIVN3) | ((val<<0) & RCC_PLL3DIVR_DIVN3); }
inline uint32_t rcc_pll3divr_get_divr3(struct RCC_Type* p) { return (p->PLL3DIVR & RCC_PLL3DIVR_DIVR3) >> 24 ; }
inline uint32_t rcc_pll3divr_get_divq3(struct RCC_Type* p) { return (p->PLL3DIVR & RCC_PLL3DIVR_DIVQ3) >> 16 ; }
inline uint32_t rcc_pll3divr_get_divp3(struct RCC_Type* p) { return (p->PLL3DIVR & RCC_PLL3DIVR_DIVP3) >> 9 ; }
inline uint32_t rcc_pll3divr_get_divn3(struct RCC_Type* p) { return (p->PLL3DIVR & RCC_PLL3DIVR_DIVN3) >> 0 ; }

// RCC->PLL3FRACR RCC PLL3 Fractional Divider Register
enum {
	RCC_PLL3FRACR_FRACN3 = ((1UL<<13)-1) << 3, // Fractional part of the multiplication factor for PLL3 VCO		
};
inline void rcc_pll3fracr_set_fracn3(struct RCC_Type* p, uint32_t val) { p->PLL3FRACR = (p->PLL3FRACR & ~RCC_PLL3FRACR_FRACN3) | ((val<<3) & RCC_PLL3FRACR_FRACN3); }
inline uint32_t rcc_pll3fracr_get_fracn3(struct RCC_Type* p) { return (p->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3 ; }

// RCC->D1CCIPR RCC Domain 1 Kernel Clock Configuration Register
enum {
	RCC_D1CCIPR_CKPERSRC = ((1UL<<2)-1) << 28, // per_ck clock source selection
	RCC_D1CCIPR_SDMMCSRC = 1UL<<16, // SDMMC kernel clock source selection
	RCC_D1CCIPR_QSPISRC = ((1UL<<2)-1) << 4, // QUADSPI kernel clock source selection
	RCC_D1CCIPR_FMCSRC = ((1UL<<2)-1) << 0, // FMC kernel clock source selection		
};
inline void rcc_d1ccipr_set_ckpersrc(struct RCC_Type* p, uint32_t val) { p->D1CCIPR = (p->D1CCIPR & ~RCC_D1CCIPR_CKPERSRC) | ((val<<28) & RCC_D1CCIPR_CKPERSRC); }
inline void rcc_d1ccipr_set_qspisrc(struct RCC_Type* p, uint32_t val) { p->D1CCIPR = (p->D1CCIPR & ~RCC_D1CCIPR_QSPISRC) | ((val<<4) & RCC_D1CCIPR_QSPISRC); }
inline void rcc_d1ccipr_set_fmcsrc(struct RCC_Type* p, uint32_t val) { p->D1CCIPR = (p->D1CCIPR & ~RCC_D1CCIPR_FMCSRC) | ((val<<0) & RCC_D1CCIPR_FMCSRC); }
inline uint32_t rcc_d1ccipr_get_ckpersrc(struct RCC_Type* p) { return (p->D1CCIPR & RCC_D1CCIPR_CKPERSRC) >> 28 ; }
inline uint32_t rcc_d1ccipr_get_qspisrc(struct RCC_Type* p) { return (p->D1CCIPR & RCC_D1CCIPR_QSPISRC) >> 4 ; }
inline uint32_t rcc_d1ccipr_get_fmcsrc(struct RCC_Type* p) { return (p->D1CCIPR & RCC_D1CCIPR_FMCSRC) >> 0 ; }

// RCC->D2CCIP1R RCC Domain 2 Kernel Clock Configuration Register
enum {
	RCC_D2CCIP1R_SWPSRC = 1UL<<31, // SWPMI kernel clock source selection
	RCC_D2CCIP1R_FDCANSRC = ((1UL<<2)-1) << 28, // FDCAN kernel clock source selection
	RCC_D2CCIP1R_DFSDM1SRC = 1UL<<24, // DFSDM1 kernel Clk clock source selection
	RCC_D2CCIP1R_SPDIFSRC = ((1UL<<2)-1) << 20, // SPDIFRX kernel clock source selection
	RCC_D2CCIP1R_SPI45SRC = ((1UL<<3)-1) << 16, // SPI4 and 5 kernel clock source selection
	RCC_D2CCIP1R_SPI123SRC = ((1UL<<3)-1) << 12, // SPI/I2S1,2 and 3 kernel clock source selection
	RCC_D2CCIP1R_SAI23SRC = ((1UL<<3)-1) << 6, // SAI2 and SAI3 kernel clock source selection
	RCC_D2CCIP1R_SAI1SRC = ((1UL<<3)-1) << 0, // SAI1 and DFSDM1 kernel Aclk clock source selection		
};
inline void rcc_d2ccip1r_set_fdcansrc(struct RCC_Type* p, uint32_t val) { p->D2CCIP1R = (p->D2CCIP1R & ~RCC_D2CCIP1R_FDCANSRC) | ((val<<28) & RCC_D2CCIP1R_FDCANSRC); }
inline void rcc_d2ccip1r_set_spdifsrc(struct RCC_Type* p, uint32_t val) { p->D2CCIP1R = (p->D2CCIP1R & ~RCC_D2CCIP1R_SPDIFSRC) | ((val<<20) & RCC_D2CCIP1R_SPDIFSRC); }
inline void rcc_d2ccip1r_set_spi45src(struct RCC_Type* p, uint32_t val) { p->D2CCIP1R = (p->D2CCIP1R & ~RCC_D2CCIP1R_SPI45SRC) | ((val<<16) & RCC_D2CCIP1R_SPI45SRC); }
inline void rcc_d2ccip1r_set_spi123src(struct RCC_Type* p, uint32_t val) { p->D2CCIP1R = (p->D2CCIP1R & ~RCC_D2CCIP1R_SPI123SRC) | ((val<<12) & RCC_D2CCIP1R_SPI123SRC); }
inline void rcc_d2ccip1r_set_sai23src(struct RCC_Type* p, uint32_t val) { p->D2CCIP1R = (p->D2CCIP1R & ~RCC_D2CCIP1R_SAI23SRC) | ((val<<6) & RCC_D2CCIP1R_SAI23SRC); }
inline void rcc_d2ccip1r_set_sai1src(struct RCC_Type* p, uint32_t val) { p->D2CCIP1R = (p->D2CCIP1R & ~RCC_D2CCIP1R_SAI1SRC) | ((val<<0) & RCC_D2CCIP1R_SAI1SRC); }
inline uint32_t rcc_d2ccip1r_get_fdcansrc(struct RCC_Type* p) { return (p->D2CCIP1R & RCC_D2CCIP1R_FDCANSRC) >> 28 ; }
inline uint32_t rcc_d2ccip1r_get_spdifsrc(struct RCC_Type* p) { return (p->D2CCIP1R & RCC_D2CCIP1R_SPDIFSRC) >> 20 ; }
inline uint32_t rcc_d2ccip1r_get_spi45src(struct RCC_Type* p) { return (p->D2CCIP1R & RCC_D2CCIP1R_SPI45SRC) >> 16 ; }
inline uint32_t rcc_d2ccip1r_get_spi123src(struct RCC_Type* p) { return (p->D2CCIP1R & RCC_D2CCIP1R_SPI123SRC) >> 12 ; }
inline uint32_t rcc_d2ccip1r_get_sai23src(struct RCC_Type* p) { return (p->D2CCIP1R & RCC_D2CCIP1R_SAI23SRC) >> 6 ; }
inline uint32_t rcc_d2ccip1r_get_sai1src(struct RCC_Type* p) { return (p->D2CCIP1R & RCC_D2CCIP1R_SAI1SRC) >> 0 ; }

// RCC->D2CCIP2R RCC Domain 2 Kernel Clock Configuration Register
enum {
	RCC_D2CCIP2R_LPTIM1SRC = ((1UL<<3)-1) << 28, // LPTIM1 kernel clock source selection
	RCC_D2CCIP2R_CECSRC = ((1UL<<2)-1) << 22, // HDMI-CEC kernel clock source selection
	RCC_D2CCIP2R_USBSRC = ((1UL<<2)-1) << 20, // USBOTG 1 and 2 kernel clock source selection
	RCC_D2CCIP2R_I2C123SRC = ((1UL<<2)-1) << 12, // I2C1,2,3 kernel clock source selection
	RCC_D2CCIP2R_RNGSRC = ((1UL<<2)-1) << 8, // RNG kernel clock source selection
	RCC_D2CCIP2R_USART16SRC = ((1UL<<3)-1) << 3, // USART1 and 6 kernel clock source selection
	RCC_D2CCIP2R_USART234578SRC = ((1UL<<3)-1) << 0, // USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection		
};
inline void rcc_d2ccip2r_set_lptim1src(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_LPTIM1SRC) | ((val<<28) & RCC_D2CCIP2R_LPTIM1SRC); }
inline void rcc_d2ccip2r_set_cecsrc(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_CECSRC) | ((val<<22) & RCC_D2CCIP2R_CECSRC); }
inline void rcc_d2ccip2r_set_usbsrc(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_USBSRC) | ((val<<20) & RCC_D2CCIP2R_USBSRC); }
inline void rcc_d2ccip2r_set_i2c123src(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_I2C123SRC) | ((val<<12) & RCC_D2CCIP2R_I2C123SRC); }
inline void rcc_d2ccip2r_set_rngsrc(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_RNGSRC) | ((val<<8) & RCC_D2CCIP2R_RNGSRC); }
inline void rcc_d2ccip2r_set_usart16src(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_USART16SRC) | ((val<<3) & RCC_D2CCIP2R_USART16SRC); }
inline void rcc_d2ccip2r_set_usart234578src(struct RCC_Type* p, uint32_t val) { p->D2CCIP2R = (p->D2CCIP2R & ~RCC_D2CCIP2R_USART234578SRC) | ((val<<0) & RCC_D2CCIP2R_USART234578SRC); }
inline uint32_t rcc_d2ccip2r_get_lptim1src(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_LPTIM1SRC) >> 28 ; }
inline uint32_t rcc_d2ccip2r_get_cecsrc(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_CECSRC) >> 22 ; }
inline uint32_t rcc_d2ccip2r_get_usbsrc(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_USBSRC) >> 20 ; }
inline uint32_t rcc_d2ccip2r_get_i2c123src(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_I2C123SRC) >> 12 ; }
inline uint32_t rcc_d2ccip2r_get_rngsrc(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_RNGSRC) >> 8 ; }
inline uint32_t rcc_d2ccip2r_get_usart16src(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_USART16SRC) >> 3 ; }
inline uint32_t rcc_d2ccip2r_get_usart234578src(struct RCC_Type* p) { return (p->D2CCIP2R & RCC_D2CCIP2R_USART234578SRC) >> 0 ; }

// RCC->D3CCIPR RCC Domain 3 Kernel Clock Configuration Register
enum {
	RCC_D3CCIPR_SPI6SRC = ((1UL<<3)-1) << 28, // SPI6 kernel clock source selection
	RCC_D3CCIPR_SAI4BSRC = ((1UL<<3)-1) << 24, // Sub-Block B of SAI4 kernel clock source selection
	RCC_D3CCIPR_SAI4ASRC = ((1UL<<3)-1) << 21, // Sub-Block A of SAI4 kernel clock source selection
	RCC_D3CCIPR_ADCSRC = ((1UL<<2)-1) << 16, // SAR ADC kernel clock source selection
	RCC_D3CCIPR_LPTIM345SRC = ((1UL<<3)-1) << 13, // LPTIM3,4,5 kernel clock source selection
	RCC_D3CCIPR_LPTIM2SRC = ((1UL<<3)-1) << 10, // LPTIM2 kernel clock source selection
	RCC_D3CCIPR_I2C4SRC = ((1UL<<2)-1) << 8, // I2C4 kernel clock source selection
	RCC_D3CCIPR_LPUART1SRC = ((1UL<<3)-1) << 0, // LPUART1 kernel clock source selection		
};
inline void rcc_d3ccipr_set_spi6src(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_SPI6SRC) | ((val<<28) & RCC_D3CCIPR_SPI6SRC); }
inline void rcc_d3ccipr_set_sai4bsrc(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_SAI4BSRC) | ((val<<24) & RCC_D3CCIPR_SAI4BSRC); }
inline void rcc_d3ccipr_set_sai4asrc(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_SAI4ASRC) | ((val<<21) & RCC_D3CCIPR_SAI4ASRC); }
inline void rcc_d3ccipr_set_adcsrc(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_ADCSRC) | ((val<<16) & RCC_D3CCIPR_ADCSRC); }
inline void rcc_d3ccipr_set_lptim345src(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_LPTIM345SRC) | ((val<<13) & RCC_D3CCIPR_LPTIM345SRC); }
inline void rcc_d3ccipr_set_lptim2src(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_LPTIM2SRC) | ((val<<10) & RCC_D3CCIPR_LPTIM2SRC); }
inline void rcc_d3ccipr_set_i2c4src(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_I2C4SRC) | ((val<<8) & RCC_D3CCIPR_I2C4SRC); }
inline void rcc_d3ccipr_set_lpuart1src(struct RCC_Type* p, uint32_t val) { p->D3CCIPR = (p->D3CCIPR & ~RCC_D3CCIPR_LPUART1SRC) | ((val<<0) & RCC_D3CCIPR_LPUART1SRC); }
inline uint32_t rcc_d3ccipr_get_spi6src(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_SPI6SRC) >> 28 ; }
inline uint32_t rcc_d3ccipr_get_sai4bsrc(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_SAI4BSRC) >> 24 ; }
inline uint32_t rcc_d3ccipr_get_sai4asrc(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_SAI4ASRC) >> 21 ; }
inline uint32_t rcc_d3ccipr_get_adcsrc(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_ADCSRC) >> 16 ; }
inline uint32_t rcc_d3ccipr_get_lptim345src(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_LPTIM345SRC) >> 13 ; }
inline uint32_t rcc_d3ccipr_get_lptim2src(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_LPTIM2SRC) >> 10 ; }
inline uint32_t rcc_d3ccipr_get_i2c4src(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_I2C4SRC) >> 8 ; }
inline uint32_t rcc_d3ccipr_get_lpuart1src(struct RCC_Type* p) { return (p->D3CCIPR & RCC_D3CCIPR_LPUART1SRC) >> 0 ; }

// RCC->CIER RCC Clock Source Interrupt Enable Register
enum {
	RCC_CIER_LSECSSIE = 1UL<<9, // LSE clock security system Interrupt Enable
	RCC_CIER_PLL3RDYIE = 1UL<<8, // PLL3 ready Interrupt Enable
	RCC_CIER_PLL2RDYIE = 1UL<<7, // PLL2 ready Interrupt Enable
	RCC_CIER_PLL1RDYIE = 1UL<<6, // PLL1 ready Interrupt Enable
	RCC_CIER_RC48RDYIE = 1UL<<5, // RC48 ready Interrupt Enable
	RCC_CIER_CSIRDYIE = 1UL<<4, // CSI ready Interrupt Enable
	RCC_CIER_HSERDYIE = 1UL<<3, // HSE ready Interrupt Enable
	RCC_CIER_HSIRDYIE = 1UL<<2, // HSI ready Interrupt Enable
	RCC_CIER_LSERDYIE = 1UL<<1, // LSE ready Interrupt Enable
	RCC_CIER_LSIRDYIE = 1UL<<0, // LSI ready Interrupt Enable		
};

// RCC->CIFR RCC Clock Source Interrupt Flag Register
enum {
	RCC_CIFR_HSECSSF = 1UL<<10, // HSE clock security system Interrupt Flag
	RCC_CIFR_LSECSSF = 1UL<<9, // LSE clock security system Interrupt Flag
	RCC_CIFR_PLL3RDYF = 1UL<<8, // PLL3 ready Interrupt Flag
	RCC_CIFR_PLL2RDYF = 1UL<<7, // PLL2 ready Interrupt Flag
	RCC_CIFR_PLL1RDYF = 1UL<<6, // PLL1 ready Interrupt Flag
	RCC_CIFR_RC48RDYF = 1UL<<5, // RC48 ready Interrupt Flag
	RCC_CIFR_CSIRDY = 1UL<<4, // CSI ready Interrupt Flag
	RCC_CIFR_HSERDYF = 1UL<<3, // HSE ready Interrupt Flag
	RCC_CIFR_HSIRDYF = 1UL<<2, // HSI ready Interrupt Flag
	RCC_CIFR_LSERDYF = 1UL<<1, // LSE ready Interrupt Flag
	RCC_CIFR_LSIRDYF = 1UL<<0, // LSI ready Interrupt Flag		
};

// RCC->CICR RCC Clock Source Interrupt Clear Register
enum {
	RCC_CICR_HSECSSC = 1UL<<10, // HSE clock security system Interrupt Clear
	RCC_CICR_LSECSSC = 1UL<<9, // LSE clock security system Interrupt Clear
	RCC_CICR_PLL3RDYC = 1UL<<8, // PLL3 ready Interrupt Clear
	RCC_CICR_PLL2RDYC = 1UL<<7, // PLL2 ready Interrupt Clear
	RCC_CICR_PLL1RDYC = 1UL<<6, // PLL1 ready Interrupt Clear
	RCC_CICR_RC48RDYC = 1UL<<5, // RC48 ready Interrupt Clear
	RCC_CICR_HSE_READY_INTERRUPT_CLEAR = 1UL<<4, // CSI ready Interrupt Clear
	RCC_CICR_HSERDYC = 1UL<<3, // HSE ready Interrupt Clear
	RCC_CICR_HSIRDYC = 1UL<<2, // HSI ready Interrupt Clear
	RCC_CICR_LSERDYC = 1UL<<1, // LSE ready Interrupt Clear
	RCC_CICR_LSIRDYC = 1UL<<0, // LSI ready Interrupt Clear		
};

// RCC->BDCR RCC Backup Domain Control Register
enum {
	RCC_BDCR_VSWRST = 1UL<<16, // VSwitch domain software reset
	RCC_BDCR_RTCEN = 1UL<<15, // RTC clock enable
	RCC_BDCR_RTCSRC = ((1UL<<2)-1) << 8, // RTC clock source selection
	RCC_BDCR_LSECSSD = 1UL<<6, // LSE clock security system failure detection
	RCC_BDCR_LSECSSON = 1UL<<5, // LSE clock security system enable
	RCC_BDCR_LSEDRV = ((1UL<<2)-1) << 3, // LSE oscillator driving capability
	RCC_BDCR_LSEBYP = 1UL<<2, // LSE oscillator bypass
	RCC_BDCR_LSERDY = 1UL<<1, // LSE oscillator ready
	RCC_BDCR_LSEON = 1UL<<0, // LSE oscillator enabled		
};
inline void rcc_bdcr_set_rtcsrc(struct RCC_Type* p, uint32_t val) { p->BDCR = (p->BDCR & ~RCC_BDCR_RTCSRC) | ((val<<8) & RCC_BDCR_RTCSRC); }
inline void rcc_bdcr_set_lsedrv(struct RCC_Type* p, uint32_t val) { p->BDCR = (p->BDCR & ~RCC_BDCR_LSEDRV) | ((val<<3) & RCC_BDCR_LSEDRV); }
inline uint32_t rcc_bdcr_get_rtcsrc(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_RTCSRC) >> 8 ; }
inline uint32_t rcc_bdcr_get_lsedrv(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_LSEDRV) >> 3 ; }

// RCC->CSR RCC Clock Control and Status Register
enum {
	RCC_CSR_LSIRDY = 1UL<<1, // LSI oscillator ready
	RCC_CSR_LSION = 1UL<<0, // LSI oscillator enable		
};

// RCC->AHB3RSTR RCC AHB3 Reset Register
enum {
	RCC_AHB3RSTR_CPURST = 1UL<<31, // CPU reset
	RCC_AHB3RSTR_SDMMC1RST = 1UL<<16, // SDMMC1 and SDMMC1 delay block reset
	RCC_AHB3RSTR_QSPIRST = 1UL<<14, // QUADSPI and QUADSPI delay block reset
	RCC_AHB3RSTR_FMCRST = 1UL<<12, // FMC block reset
	RCC_AHB3RSTR_JPGDECRST = 1UL<<5, // JPGDEC block reset
	RCC_AHB3RSTR_DMA2DRST = 1UL<<4, // DMA2D block reset
	RCC_AHB3RSTR_MDMARST = 1UL<<0, // MDMA block reset		
};

// RCC->AHB1RSTR RCC AHB1 Peripheral Reset Register
enum {
	RCC_AHB1RSTR_USB2OTGRST = 1UL<<27, // USB2OTG block reset
	RCC_AHB1RSTR_USB1OTGRST = 1UL<<25, // USB1OTG block reset
	RCC_AHB1RSTR_ETH1MACRST = 1UL<<15, // ETH1MAC block reset
	RCC_AHB1RSTR_ADC12RST = 1UL<<5, // ADC1&2 block reset
	RCC_AHB1RSTR_DMA2RST = 1UL<<1, // DMA2 block reset
	RCC_AHB1RSTR_DMA1RST = 1UL<<0, // DMA1 block reset		
};

// RCC->AHB2RSTR RCC AHB2 Peripheral Reset Register
enum {
	RCC_AHB2RSTR_SDMMC2RST = 1UL<<9, // SDMMC2 and SDMMC2 Delay block reset
	RCC_AHB2RSTR_RNGRST = 1UL<<6, // Random Number Generator block reset
	RCC_AHB2RSTR_HASHRST = 1UL<<5, // Hash block reset
	RCC_AHB2RSTR_CRYPTRST = 1UL<<4, // Cryptography block reset
	RCC_AHB2RSTR_CAMITFRST = 1UL<<0, // CAMITF block reset		
};

// RCC->AHB4RSTR RCC AHB4 Peripheral Reset Register
enum {
	RCC_AHB4RSTR_HSEMRST = 1UL<<25, // HSEM block reset
	RCC_AHB4RSTR_ADC3RST = 1UL<<24, // ADC3 block reset
	RCC_AHB4RSTR_BDMARST = 1UL<<21, // BDMA block reset
	RCC_AHB4RSTR_CRCRST = 1UL<<19, // CRC block reset
	RCC_AHB4RSTR_GPIOKRST = 1UL<<10, // GPIO block reset
	RCC_AHB4RSTR_GPIOJRST = 1UL<<9, // GPIO block reset
	RCC_AHB4RSTR_GPIOIRST = 1UL<<8, // GPIO block reset
	RCC_AHB4RSTR_GPIOHRST = 1UL<<7, // GPIO block reset
	RCC_AHB4RSTR_GPIOGRST = 1UL<<6, // GPIO block reset
	RCC_AHB4RSTR_GPIOFRST = 1UL<<5, // GPIO block reset
	RCC_AHB4RSTR_GPIOERST = 1UL<<4, // GPIO block reset
	RCC_AHB4RSTR_GPIODRST = 1UL<<3, // GPIO block reset
	RCC_AHB4RSTR_GPIOCRST = 1UL<<2, // GPIO block reset
	RCC_AHB4RSTR_GPIOBRST = 1UL<<1, // GPIO block reset
	RCC_AHB4RSTR_GPIOARST = 1UL<<0, // GPIO block reset		
};

// RCC->APB3RSTR RCC APB3 Peripheral Reset Register
enum {
	RCC_APB3RSTR_LTDCRST = 1UL<<3, // LTDC block reset		
};

// RCC->APB1LRSTR RCC APB1 Peripheral Reset Register
enum {
	RCC_APB1LRSTR_USART8RST = 1UL<<31, // USART8 block reset
	RCC_APB1LRSTR_USART7RST = 1UL<<30, // USART7 block reset
	RCC_APB1LRSTR_DAC12RST = 1UL<<29, // DAC1 and 2 Blocks Reset
	RCC_APB1LRSTR_HDMICECRST = 1UL<<27, // HDMI-CEC block reset
	RCC_APB1LRSTR_I2C3RST = 1UL<<23, // I2C3 block reset
	RCC_APB1LRSTR_I2C2RST = 1UL<<22, // I2C2 block reset
	RCC_APB1LRSTR_I2C1RST = 1UL<<21, // I2C1 block reset
	RCC_APB1LRSTR_UART5RST = 1UL<<20, // UART5 block reset
	RCC_APB1LRSTR_UART4RST = 1UL<<19, // UART4 block reset
	RCC_APB1LRSTR_USART3RST = 1UL<<18, // USART3 block reset
	RCC_APB1LRSTR_USART2RST = 1UL<<17, // USART2 block reset
	RCC_APB1LRSTR_SPDIFRXRST = 1UL<<16, // SPDIFRX block reset
	RCC_APB1LRSTR_SPI3RST = 1UL<<15, // SPI3 block reset
	RCC_APB1LRSTR_SPI2RST = 1UL<<14, // SPI2 block reset
	RCC_APB1LRSTR_LPTIM1RST = 1UL<<9, // TIM block reset
	RCC_APB1LRSTR_TIM14RST = 1UL<<8, // TIM block reset
	RCC_APB1LRSTR_TIM13RST = 1UL<<7, // TIM block reset
	RCC_APB1LRSTR_TIM12RST = 1UL<<6, // TIM block reset
	RCC_APB1LRSTR_TIM7RST = 1UL<<5, // TIM block reset
	RCC_APB1LRSTR_TIM6RST = 1UL<<4, // TIM block reset
	RCC_APB1LRSTR_TIM5RST = 1UL<<3, // TIM block reset
	RCC_APB1LRSTR_TIM4RST = 1UL<<2, // TIM block reset
	RCC_APB1LRSTR_TIM3RST = 1UL<<1, // TIM block reset
	RCC_APB1LRSTR_TIM2RST = 1UL<<0, // TIM block reset		
};

// RCC->APB1HRSTR RCC APB1 Peripheral Reset Register
enum {
	RCC_APB1HRSTR_FDCANRST = 1UL<<8, // FDCAN block reset
	RCC_APB1HRSTR_MDIOSRST = 1UL<<5, // MDIOS block reset
	RCC_APB1HRSTR_OPAMPRST = 1UL<<4, // OPAMP block reset
	RCC_APB1HRSTR_SWPRST = 1UL<<2, // SWPMI block reset
	RCC_APB1HRSTR_CRSRST = 1UL<<1, // Clock Recovery System reset		
};

// RCC->APB2RSTR RCC APB2 Peripheral Reset Register
enum {
	RCC_APB2RSTR_HRTIMRST = 1UL<<29, // HRTIM block reset
	RCC_APB2RSTR_DFSDM1RST = 1UL<<28, // DFSDM1 block reset
	RCC_APB2RSTR_SAI3RST = 1UL<<24, // SAI3 block reset
	RCC_APB2RSTR_SAI2RST = 1UL<<23, // SAI2 block reset
	RCC_APB2RSTR_SAI1RST = 1UL<<22, // SAI1 block reset
	RCC_APB2RSTR_SPI5RST = 1UL<<20, // SPI5 block reset
	RCC_APB2RSTR_TIM17RST = 1UL<<18, // TIM17 block reset
	RCC_APB2RSTR_TIM16RST = 1UL<<17, // TIM16 block reset
	RCC_APB2RSTR_TIM15RST = 1UL<<16, // TIM15 block reset
	RCC_APB2RSTR_SPI4RST = 1UL<<13, // SPI4 block reset
	RCC_APB2RSTR_SPI1RST = 1UL<<12, // SPI1 block reset
	RCC_APB2RSTR_USART6RST = 1UL<<5, // USART6 block reset
	RCC_APB2RSTR_USART1RST = 1UL<<4, // USART1 block reset
	RCC_APB2RSTR_TIM8RST = 1UL<<1, // TIM8 block reset
	RCC_APB2RSTR_TIM1RST = 1UL<<0, // TIM1 block reset		
};

// RCC->APB4RSTR RCC APB4 Peripheral Reset Register
enum {
	RCC_APB4RSTR_SAI4RST = 1UL<<21, // SAI4 block reset
	RCC_APB4RSTR_VREFRST = 1UL<<15, // VREF block reset
	RCC_APB4RSTR_COMP12RST = 1UL<<14, // COMP12 Blocks Reset
	RCC_APB4RSTR_LPTIM5RST = 1UL<<12, // LPTIM5 block reset
	RCC_APB4RSTR_LPTIM4RST = 1UL<<11, // LPTIM4 block reset
	RCC_APB4RSTR_LPTIM3RST = 1UL<<10, // LPTIM3 block reset
	RCC_APB4RSTR_LPTIM2RST = 1UL<<9, // LPTIM2 block reset
	RCC_APB4RSTR_I2C4RST = 1UL<<7, // I2C4 block reset
	RCC_APB4RSTR_SPI6RST = 1UL<<5, // SPI6 block reset
	RCC_APB4RSTR_LPUART1RST = 1UL<<3, // LPUART1 block reset
	RCC_APB4RSTR_SYSCFGRST = 1UL<<1, // SYSCFG block reset		
};

// RCC->GCR RCC Global Control Register
enum {
	RCC_GCR_WW1RSC = 1UL<<0, // WWDG1 reset scope control		
};

// RCC->D3AMR RCC D3 Autonomous mode Register
enum {
	RCC_D3AMR_SRAM4AMEN = 1UL<<29, // SRAM4 Autonomous mode enable
	RCC_D3AMR_BKPSRAMAMEN = 1UL<<28, // Backup RAM Autonomous mode enable
	RCC_D3AMR_ADC3AMEN = 1UL<<24, // ADC3 Autonomous mode enable
	RCC_D3AMR_SAI4AMEN = 1UL<<21, // SAI4 Autonomous mode enable
	RCC_D3AMR_CRCAMEN = 1UL<<19, // CRC Autonomous mode enable
	RCC_D3AMR_RTCAMEN = 1UL<<16, // RTC Autonomous mode enable
	RCC_D3AMR_VREFAMEN = 1UL<<15, // VREF Autonomous mode enable
	RCC_D3AMR_COMP12AMEN = 1UL<<14, // COMP12 Autonomous mode enable
	RCC_D3AMR_LPTIM5AMEN = 1UL<<12, // LPTIM5 Autonomous mode enable
	RCC_D3AMR_LPTIM4AMEN = 1UL<<11, // LPTIM4 Autonomous mode enable
	RCC_D3AMR_LPTIM3AMEN = 1UL<<10, // LPTIM3 Autonomous mode enable
	RCC_D3AMR_LPTIM2AMEN = 1UL<<9, // LPTIM2 Autonomous mode enable
	RCC_D3AMR_I2C4AMEN = 1UL<<7, // I2C4 Autonomous mode enable
	RCC_D3AMR_SPI6AMEN = 1UL<<5, // SPI6 Autonomous mode enable
	RCC_D3AMR_LPUART1AMEN = 1UL<<3, // LPUART1 Autonomous mode enable
	RCC_D3AMR_BDMAAMEN = 1UL<<0, // BDMA and DMAMUX Autonomous mode enable		
};

// RCC->RSR RCC Reset Status Register
enum {
	RCC_RSR_LPWRRSTF = 1UL<<30, // Reset due to illegal D1 DStandby or CPU CStop flag
	RCC_RSR_WWDG1RSTF = 1UL<<28, // Window Watchdog reset flag
	RCC_RSR_IWDG1RSTF = 1UL<<26, // Independent Watchdog reset flag
	RCC_RSR_SFTRSTF = 1UL<<24, // System reset from CPU reset flag
	RCC_RSR_PORRSTF = 1UL<<23, // POR/PDR reset flag
	RCC_RSR_PINRSTF = 1UL<<22, // Pin reset flag (NRST)
	RCC_RSR_BORRSTF = 1UL<<21, // BOR reset flag
	RCC_RSR_D2RSTF = 1UL<<20, // D2 domain power switch reset flag
	RCC_RSR_D1RSTF = 1UL<<19, // D1 domain power switch reset flag
	RCC_RSR_CPURSTF = 1UL<<17, // CPU reset flag
	RCC_RSR_RMVF = 1UL<<16, // Remove reset flag		
};

// RCC->AHB3ENR RCC AHB3 Clock Register
enum {
	RCC_AHB3ENR_SDMMC1EN = 1UL<<16, // SDMMC1 and SDMMC1 Delay Clock Enable
	RCC_AHB3ENR_QSPIEN = 1UL<<14, // QUADSPI and QUADSPI Delay Clock Enable
	RCC_AHB3ENR_FMCEN = 1UL<<12, // FMC Peripheral Clocks Enable
	RCC_AHB3ENR_JPGDECEN = 1UL<<5, // JPGDEC Peripheral Clock Enable
	RCC_AHB3ENR_DMA2DEN = 1UL<<4, // DMA2D Peripheral Clock Enable
	RCC_AHB3ENR_MDMAEN = 1UL<<0, // MDMA Peripheral Clock Enable		
};

// RCC->AHB1ENR RCC AHB1 Clock Register
enum {
	RCC_AHB1ENR_USB2ULPIEN = 1UL<<28, // USB_PHY2 Clocks Enable
	RCC_AHB1ENR_USB2OTGEN = 1UL<<27, // USB2OTG Peripheral Clocks Enable
	RCC_AHB1ENR_USB1ULPIEN = 1UL<<26, // USB_PHY1 Clocks Enable
	RCC_AHB1ENR_USB1OTGEN = 1UL<<25, // USB1OTG Peripheral Clocks Enable
	RCC_AHB1ENR_ETH1RXEN = 1UL<<17, // Ethernet Reception Clock Enable
	RCC_AHB1ENR_ETH1TXEN = 1UL<<16, // Ethernet Transmission Clock Enable
	RCC_AHB1ENR_ETH1MACEN = 1UL<<15, // Ethernet MAC bus interface Clock Enable
	RCC_AHB1ENR_ADC12EN = 1UL<<5, // ADC1/2 Peripheral Clocks Enable
	RCC_AHB1ENR_DMA2EN = 1UL<<1, // DMA2 Clock Enable
	RCC_AHB1ENR_DMA1EN = 1UL<<0, // DMA1 Clock Enable		
};

// RCC->AHB2ENR RCC AHB2 Clock Register
enum {
	RCC_AHB2ENR_SRAM3EN = 1UL<<31, // SRAM3 block enable
	RCC_AHB2ENR_SRAM2EN = 1UL<<30, // SRAM2 block enable
	RCC_AHB2ENR_SRAM1EN = 1UL<<29, // SRAM1 block enable
	RCC_AHB2ENR_SDMMC2EN = 1UL<<9, // SDMMC2 and SDMMC2 delay clock enable
	RCC_AHB2ENR_RNGEN = 1UL<<6, // RNG peripheral clocks enable
	RCC_AHB2ENR_HASHEN = 1UL<<5, // HASH peripheral clock enable
	RCC_AHB2ENR_CRYPTEN = 1UL<<4, // CRYPT peripheral clock enable
	RCC_AHB2ENR_CAMITFEN = 1UL<<0, // CAMITF peripheral clock enable		
};

// RCC->AHB4ENR RCC AHB4 Clock Register
enum {
	RCC_AHB4ENR_BKPRAMEN = 1UL<<28, // Backup RAM Clock Enable
	RCC_AHB4ENR_HSEMEN = 1UL<<25, // HSEM peripheral clock enable
	RCC_AHB4ENR_ADC3EN = 1UL<<24, // ADC3 Peripheral Clocks Enable
	RCC_AHB4ENR_BDMAEN = 1UL<<21, // BDMA and DMAMUX2 Clock Enable
	RCC_AHB4ENR_CRCEN = 1UL<<19, // CRC peripheral clock enable
	RCC_AHB4ENR_GPIOKEN = 1UL<<10, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOJEN = 1UL<<9, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOIEN = 1UL<<8, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOHEN = 1UL<<7, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOGEN = 1UL<<6, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOFEN = 1UL<<5, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOEEN = 1UL<<4, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIODEN = 1UL<<3, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOCEN = 1UL<<2, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOBEN = 1UL<<1, // 0GPIO peripheral clock enable
	RCC_AHB4ENR_GPIOAEN = 1UL<<0, // 0GPIO peripheral clock enable		
};

// RCC->APB3ENR RCC APB3 Clock Register
enum {
	RCC_APB3ENR_WWDG1EN = 1UL<<6, // WWDG1 Clock Enable
	RCC_APB3ENR_LTDCEN = 1UL<<3, // LTDC peripheral clock enable		
};

// RCC->APB1LENR RCC APB1 Clock Register
enum {
	RCC_APB1LENR_USART8EN = 1UL<<31, // USART8 Peripheral Clocks Enable
	RCC_APB1LENR_USART7EN = 1UL<<30, // USART7 Peripheral Clocks Enable
	RCC_APB1LENR_DAC12EN = 1UL<<29, // DAC1&2 peripheral clock enable
	RCC_APB1LENR_HDMICECEN = 1UL<<27, // HDMI-CEC peripheral clock enable
	RCC_APB1LENR_I2C3EN = 1UL<<23, // I2C3 Peripheral Clocks Enable
	RCC_APB1LENR_I2C2EN = 1UL<<22, // I2C2 Peripheral Clocks Enable
	RCC_APB1LENR_I2C1EN = 1UL<<21, // I2C1 Peripheral Clocks Enable
	RCC_APB1LENR_UART5EN = 1UL<<20, // UART5 Peripheral Clocks Enable
	RCC_APB1LENR_UART4EN = 1UL<<19, // UART4 Peripheral Clocks Enable
	RCC_APB1LENR_USART3EN = 1UL<<18, // USART3 Peripheral Clocks Enable
	RCC_APB1LENR_USART2EN = 1UL<<17, // USART2 Peripheral Clocks Enable
	RCC_APB1LENR_SPDIFRXEN = 1UL<<16, // SPDIFRX Peripheral Clocks Enable
	RCC_APB1LENR_SPI3EN = 1UL<<15, // SPI3 Peripheral Clocks Enable
	RCC_APB1LENR_SPI2EN = 1UL<<14, // SPI2 Peripheral Clocks Enable
	RCC_APB1LENR_LPTIM1EN = 1UL<<9, // LPTIM1 Peripheral Clocks Enable
	RCC_APB1LENR_TIM14EN = 1UL<<8, // TIM peripheral clock enable
	RCC_APB1LENR_TIM13EN = 1UL<<7, // TIM peripheral clock enable
	RCC_APB1LENR_TIM12EN = 1UL<<6, // TIM peripheral clock enable
	RCC_APB1LENR_TIM7EN = 1UL<<5, // TIM peripheral clock enable
	RCC_APB1LENR_TIM6EN = 1UL<<4, // TIM peripheral clock enable
	RCC_APB1LENR_TIM5EN = 1UL<<3, // TIM peripheral clock enable
	RCC_APB1LENR_TIM4EN = 1UL<<2, // TIM peripheral clock enable
	RCC_APB1LENR_TIM3EN = 1UL<<1, // TIM peripheral clock enable
	RCC_APB1LENR_TIM2EN = 1UL<<0, // TIM peripheral clock enable		
};

// RCC->APB1HENR RCC APB1 Clock Register
enum {
	RCC_APB1HENR_FDCANEN = 1UL<<8, // FDCAN Peripheral Clocks Enable
	RCC_APB1HENR_MDIOSEN = 1UL<<5, // MDIOS peripheral clock enable
	RCC_APB1HENR_OPAMPEN = 1UL<<4, // OPAMP peripheral clock enable
	RCC_APB1HENR_SWPEN = 1UL<<2, // SWPMI Peripheral Clocks Enable
	RCC_APB1HENR_CRSEN = 1UL<<1, // Clock Recovery System peripheral clock enable		
};

// RCC->APB2ENR RCC APB2 Clock Register
enum {
	RCC_APB2ENR_HRTIMEN = 1UL<<29, // HRTIM peripheral clock enable
	RCC_APB2ENR_DFSDM1EN = 1UL<<28, // DFSDM1 Peripheral Clocks Enable
	RCC_APB2ENR_SAI3EN = 1UL<<24, // SAI3 Peripheral Clocks Enable
	RCC_APB2ENR_SAI2EN = 1UL<<23, // SAI2 Peripheral Clocks Enable
	RCC_APB2ENR_SAI1EN = 1UL<<22, // SAI1 Peripheral Clocks Enable
	RCC_APB2ENR_SPI5EN = 1UL<<20, // SPI5 Peripheral Clocks Enable
	RCC_APB2ENR_TIM17EN = 1UL<<18, // TIM17 peripheral clock enable
	RCC_APB2ENR_TIM16EN = 1UL<<17, // TIM16 peripheral clock enable
	RCC_APB2ENR_TIM15EN = 1UL<<16, // TIM15 peripheral clock enable
	RCC_APB2ENR_SPI4EN = 1UL<<13, // SPI4 Peripheral Clocks Enable
	RCC_APB2ENR_SPI1EN = 1UL<<12, // SPI1 Peripheral Clocks Enable
	RCC_APB2ENR_USART6EN = 1UL<<5, // USART6 Peripheral Clocks Enable
	RCC_APB2ENR_USART1EN = 1UL<<4, // USART1 Peripheral Clocks Enable
	RCC_APB2ENR_TIM8EN = 1UL<<1, // TIM8 peripheral clock enable
	RCC_APB2ENR_TIM1EN = 1UL<<0, // TIM1 peripheral clock enable		
};

// RCC->APB4ENR RCC APB4 Clock Register
enum {
	RCC_APB4ENR_SAI4EN = 1UL<<21, // SAI4 Peripheral Clocks Enable
	RCC_APB4ENR_RTCAPBEN = 1UL<<16, // RTC APB Clock Enable
	RCC_APB4ENR_VREFEN = 1UL<<15, // VREF peripheral clock enable
	RCC_APB4ENR_COMP12EN = 1UL<<14, // COMP1/2 peripheral clock enable
	RCC_APB4ENR_LPTIM5EN = 1UL<<12, // LPTIM5 Peripheral Clocks Enable
	RCC_APB4ENR_LPTIM4EN = 1UL<<11, // LPTIM4 Peripheral Clocks Enable
	RCC_APB4ENR_LPTIM3EN = 1UL<<10, // LPTIM3 Peripheral Clocks Enable
	RCC_APB4ENR_LPTIM2EN = 1UL<<9, // LPTIM2 Peripheral Clocks Enable
	RCC_APB4ENR_I2C4EN = 1UL<<7, // I2C4 Peripheral Clocks Enable
	RCC_APB4ENR_SPI6EN = 1UL<<5, // SPI6 Peripheral Clocks Enable
	RCC_APB4ENR_LPUART1EN = 1UL<<3, // LPUART1 Peripheral Clocks Enable
	RCC_APB4ENR_SYSCFGEN = 1UL<<1, // SYSCFG peripheral clock enable		
};

// RCC->AHB3LPENR RCC AHB3 Sleep Clock Register
enum {
	RCC_AHB3LPENR_AXISRAMLPEN = 1UL<<31, // AXISRAM Block Clock Enable During CSleep mode
	RCC_AHB3LPENR_ITCMLPEN = 1UL<<30, // D1ITCM Block Clock Enable During CSleep mode
	RCC_AHB3LPENR_DTCM2LPEN = 1UL<<29, // D1 DTCM2 Block Clock Enable During CSleep mode
	RCC_AHB3LPENR_D1DTCM1LPEN = 1UL<<28, // D1DTCM1 Block Clock Enable During CSleep mode
	RCC_AHB3LPENR_SDMMC1LPEN = 1UL<<16, // SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
	RCC_AHB3LPENR_QSPILPEN = 1UL<<14, // QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
	RCC_AHB3LPENR_FMCLPEN = 1UL<<12, // FMC Peripheral Clocks Enable During CSleep Mode
	RCC_AHB3LPENR_FLITFLPEN = 1UL<<8, // FLITF Clock Enable During CSleep Mode
	RCC_AHB3LPENR_JPGDECLPEN = 1UL<<5, // JPGDEC Clock Enable During CSleep Mode
	RCC_AHB3LPENR_DMA2DLPEN = 1UL<<4, // DMA2D Clock Enable During CSleep Mode
	RCC_AHB3LPENR_MDMALPEN = 1UL<<0, // MDMA Clock Enable During CSleep Mode		
};

// RCC->AHB1LPENR RCC AHB1 Sleep Clock Register
enum {
	RCC_AHB1LPENR_USB2ULPILPEN = 1UL<<28, // USB_PHY2 clocks enable during CSleep mode
	RCC_AHB1LPENR_USB2OTGLPEN = 1UL<<27, // USB2OTG peripheral clock enable during CSleep mode
	RCC_AHB1LPENR_USB1ULPILPEN = 1UL<<26, // USB_PHY1 clock enable during CSleep mode
	RCC_AHB1LPENR_USB1OTGLPEN = 1UL<<25, // USB1OTG peripheral clock enable during CSleep mode
	RCC_AHB1LPENR_ETH1RXLPEN = 1UL<<17, // Ethernet Reception Clock Enable During CSleep Mode
	RCC_AHB1LPENR_ETH1TXLPEN = 1UL<<16, // Ethernet Transmission Clock Enable During CSleep Mode
	RCC_AHB1LPENR_ETH1MACLPEN = 1UL<<15, // Ethernet MAC bus interface Clock Enable During CSleep Mode
	RCC_AHB1LPENR_ADC12LPEN = 1UL<<5, // ADC1/2 Peripheral Clocks Enable During CSleep Mode
	RCC_AHB1LPENR_DMA2LPEN = 1UL<<1, // DMA2 Clock Enable During CSleep Mode
	RCC_AHB1LPENR_DMA1LPEN = 1UL<<0, // DMA1 Clock Enable During CSleep Mode		
};

// RCC->AHB2LPENR RCC AHB2 Sleep Clock Register
enum {
	RCC_AHB2LPENR_SRAM3LPEN = 1UL<<31, // SRAM3 Clock Enable During CSleep Mode
	RCC_AHB2LPENR_SRAM2LPEN = 1UL<<30, // SRAM2 Clock Enable During CSleep Mode
	RCC_AHB2LPENR_SRAM1LPEN = 1UL<<29, // SRAM1 Clock Enable During CSleep Mode
	RCC_AHB2LPENR_SDMMC2LPEN = 1UL<<9, // SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
	RCC_AHB2LPENR_RNGLPEN = 1UL<<6, // RNG peripheral clock enable during CSleep mode
	RCC_AHB2LPENR_HASHLPEN = 1UL<<5, // HASH peripheral clock enable during CSleep mode
	RCC_AHB2LPENR_CRYPTLPEN = 1UL<<4, // CRYPT peripheral clock enable during CSleep mode
	RCC_AHB2LPENR_CAMITFLPEN = 1UL<<0, // CAMITF peripheral clock enable during CSleep mode		
};

// RCC->AHB4LPENR RCC AHB4 Sleep Clock Register
enum {
	RCC_AHB4LPENR_SRAM4LPEN = 1UL<<29, // SRAM4 Clock Enable During CSleep Mode
	RCC_AHB4LPENR_BKPRAMLPEN = 1UL<<28, // Backup RAM Clock Enable During CSleep Mode
	RCC_AHB4LPENR_ADC3LPEN = 1UL<<24, // ADC3 Peripheral Clocks Enable During CSleep Mode
	RCC_AHB4LPENR_BDMALPEN = 1UL<<21, // BDMA Clock Enable During CSleep Mode
	RCC_AHB4LPENR_CRCLPEN = 1UL<<19, // CRC peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOKLPEN = 1UL<<10, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOJLPEN = 1UL<<9, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOILPEN = 1UL<<8, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOHLPEN = 1UL<<7, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOGLPEN = 1UL<<6, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOFLPEN = 1UL<<5, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOELPEN = 1UL<<4, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIODLPEN = 1UL<<3, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOCLPEN = 1UL<<2, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOBLPEN = 1UL<<1, // GPIO peripheral clock enable during CSleep mode
	RCC_AHB4LPENR_GPIOALPEN = 1UL<<0, // GPIO peripheral clock enable during CSleep mode		
};

// RCC->APB3LPENR RCC APB3 Sleep Clock Register
enum {
	RCC_APB3LPENR_WWDG1LPEN = 1UL<<6, // WWDG1 Clock Enable During CSleep Mode
	RCC_APB3LPENR_LTDCLPEN = 1UL<<3, // LTDC peripheral clock enable during CSleep mode		
};

// RCC->APB1LLPENR RCC APB1 Low Sleep Clock Register
enum {
	RCC_APB1LLPENR_USART8LPEN = 1UL<<31, // USART8 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_USART7LPEN = 1UL<<30, // USART7 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_DAC12LPEN = 1UL<<29, // DAC1/2 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_HDMICECLPEN = 1UL<<27, // HDMI-CEC Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_I2C3LPEN = 1UL<<23, // I2C3 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_I2C2LPEN = 1UL<<22, // I2C2 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_I2C1LPEN = 1UL<<21, // I2C1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_UART5LPEN = 1UL<<20, // UART5 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_UART4LPEN = 1UL<<19, // UART4 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_USART3LPEN = 1UL<<18, // USART3 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_USART2LPEN = 1UL<<17, // USART2 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_SPDIFRXLPEN = 1UL<<16, // SPDIFRX Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_SPI3LPEN = 1UL<<15, // SPI3 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_SPI2LPEN = 1UL<<14, // SPI2 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_LPTIM1LPEN = 1UL<<9, // LPTIM1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB1LLPENR_TIM14LPEN = 1UL<<8, // TIM14 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM13LPEN = 1UL<<7, // TIM13 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM12LPEN = 1UL<<6, // TIM12 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM7LPEN = 1UL<<5, // TIM7 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM6LPEN = 1UL<<4, // TIM6 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM5LPEN = 1UL<<3, // TIM5 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM4LPEN = 1UL<<2, // TIM4 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM3LPEN = 1UL<<1, // TIM3 peripheral clock enable during CSleep mode
	RCC_APB1LLPENR_TIM2LPEN = 1UL<<0, // TIM2 peripheral clock enable during CSleep mode		
};

// RCC->APB1HLPENR RCC APB1 High Sleep Clock Register
enum {
	RCC_APB1HLPENR_FDCANLPEN = 1UL<<8, // FDCAN Peripheral Clocks Enable During CSleep Mode
	RCC_APB1HLPENR_MDIOSLPEN = 1UL<<5, // MDIOS peripheral clock enable during CSleep mode
	RCC_APB1HLPENR_OPAMPLPEN = 1UL<<4, // OPAMP peripheral clock enable during CSleep mode
	RCC_APB1HLPENR_SWPLPEN = 1UL<<2, // SWPMI Peripheral Clocks Enable During CSleep Mode
	RCC_APB1HLPENR_CRSLPEN = 1UL<<1, // Clock Recovery System peripheral clock enable during CSleep mode		
};

// RCC->APB2LPENR RCC APB2 Sleep Clock Register
enum {
	RCC_APB2LPENR_HRTIMLPEN = 1UL<<29, // HRTIM peripheral clock enable during CSleep mode
	RCC_APB2LPENR_DFSDM1LPEN = 1UL<<28, // DFSDM1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_SAI3LPEN = 1UL<<24, // SAI3 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_SAI2LPEN = 1UL<<23, // SAI2 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_SAI1LPEN = 1UL<<22, // SAI1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_SPI5LPEN = 1UL<<20, // SPI5 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_TIM17LPEN = 1UL<<18, // TIM17 peripheral clock enable during CSleep mode
	RCC_APB2LPENR_TIM16LPEN = 1UL<<17, // TIM16 peripheral clock enable during CSleep mode
	RCC_APB2LPENR_TIM15LPEN = 1UL<<16, // TIM15 peripheral clock enable during CSleep mode
	RCC_APB2LPENR_SPI4LPEN = 1UL<<13, // SPI4 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_SPI1LPEN = 1UL<<12, // SPI1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_USART6LPEN = 1UL<<5, // USART6 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_USART1LPEN = 1UL<<4, // USART1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB2LPENR_TIM8LPEN = 1UL<<1, // TIM8 peripheral clock enable during CSleep mode
	RCC_APB2LPENR_TIM1LPEN = 1UL<<0, // TIM1 peripheral clock enable during CSleep mode		
};

// RCC->APB4LPENR RCC APB4 Sleep Clock Register
enum {
	RCC_APB4LPENR_SAI4LPEN = 1UL<<21, // SAI4 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_RTCAPBLPEN = 1UL<<16, // RTC APB Clock Enable During CSleep Mode
	RCC_APB4LPENR_VREFLPEN = 1UL<<15, // VREF peripheral clock enable during CSleep mode
	RCC_APB4LPENR_COMP12LPEN = 1UL<<14, // COMP1/2 peripheral clock enable during CSleep mode
	RCC_APB4LPENR_LPTIM5LPEN = 1UL<<12, // LPTIM5 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_LPTIM4LPEN = 1UL<<11, // LPTIM4 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_LPTIM3LPEN = 1UL<<10, // LPTIM3 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_LPTIM2LPEN = 1UL<<9, // LPTIM2 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_I2C4LPEN = 1UL<<7, // I2C4 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_SPI6LPEN = 1UL<<5, // SPI6 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_LPUART1LPEN = 1UL<<3, // LPUART1 Peripheral Clocks Enable During CSleep Mode
	RCC_APB4LPENR_SYSCFGLPEN = 1UL<<1, // SYSCFG peripheral clock enable during CSleep mode		
};

// RCC->C1_RSR RCC Reset Status Register
enum {
	RCC_C1_RSR_LPWRRSTF = 1UL<<30, // Reset due to illegal D1 DStandby or CPU CStop flag
	RCC_C1_RSR_WWDG1RSTF = 1UL<<28, // Window Watchdog reset flag
	RCC_C1_RSR_IWDG1RSTF = 1UL<<26, // Independent Watchdog reset flag
	RCC_C1_RSR_SFTRSTF = 1UL<<24, // System reset from CPU reset flag
	RCC_C1_RSR_PORRSTF = 1UL<<23, // POR/PDR reset flag
	RCC_C1_RSR_PINRSTF = 1UL<<22, // Pin reset flag (NRST)
	RCC_C1_RSR_BORRSTF = 1UL<<21, // BOR reset flag
	RCC_C1_RSR_D2RSTF = 1UL<<20, // D2 domain power switch reset flag
	RCC_C1_RSR_D1RSTF = 1UL<<19, // D1 domain power switch reset flag
	RCC_C1_RSR_CPURSTF = 1UL<<17, // CPU reset flag
	RCC_C1_RSR_RMVF = 1UL<<16, // Remove reset flag		
};

// RCC->C1_AHB3ENR RCC AHB3 Clock Register
enum {
	RCC_C1_AHB3ENR_SDMMC1EN = 1UL<<16, // SDMMC1 and SDMMC1 Delay Clock Enable
	RCC_C1_AHB3ENR_QSPIEN = 1UL<<14, // QUADSPI and QUADSPI Delay Clock Enable
	RCC_C1_AHB3ENR_FMCEN = 1UL<<12, // FMC Peripheral Clocks Enable
	RCC_C1_AHB3ENR_JPGDECEN = 1UL<<5, // JPGDEC Peripheral Clock Enable
	RCC_C1_AHB3ENR_DMA2DEN = 1UL<<4, // DMA2D Peripheral Clock Enable
	RCC_C1_AHB3ENR_MDMAEN = 1UL<<0, // MDMA Peripheral Clock Enable		
};

// RCC->C1_AHB1ENR RCC AHB1 Clock Register
enum {
	RCC_C1_AHB1ENR_USB2ULPIEN = 1UL<<28, // USB_PHY2 Clocks Enable
	RCC_C1_AHB1ENR_USB2OTGEN = 1UL<<27, // USB2OTG Peripheral Clocks Enable
	RCC_C1_AHB1ENR_USB1ULPIEN = 1UL<<26, // USB_PHY1 Clocks Enable
	RCC_C1_AHB1ENR_USB1OTGEN = 1UL<<25, // USB1OTG Peripheral Clocks Enable
	RCC_C1_AHB1ENR_ETH1RXEN = 1UL<<17, // Ethernet Reception Clock Enable
	RCC_C1_AHB1ENR_ETH1TXEN = 1UL<<16, // Ethernet Transmission Clock Enable
	RCC_C1_AHB1ENR_ETH1MACEN = 1UL<<15, // Ethernet MAC bus interface Clock Enable
	RCC_C1_AHB1ENR_ADC12EN = 1UL<<5, // ADC1/2 Peripheral Clocks Enable
	RCC_C1_AHB1ENR_DMA2EN = 1UL<<1, // DMA2 Clock Enable
	RCC_C1_AHB1ENR_DMA1EN = 1UL<<0, // DMA1 Clock Enable		
};

// RCC->C1_AHB2ENR RCC AHB2 Clock Register
enum {
	RCC_C1_AHB2ENR_SRAM3EN = 1UL<<31, // SRAM3 block enable
	RCC_C1_AHB2ENR_SRAM2EN = 1UL<<30, // SRAM2 block enable
	RCC_C1_AHB2ENR_SRAM1EN = 1UL<<29, // SRAM1 block enable
	RCC_C1_AHB2ENR_SDMMC2EN = 1UL<<9, // SDMMC2 and SDMMC2 delay clock enable
	RCC_C1_AHB2ENR_RNGEN = 1UL<<6, // RNG peripheral clocks enable
	RCC_C1_AHB2ENR_HASHEN = 1UL<<5, // HASH peripheral clock enable
	RCC_C1_AHB2ENR_CRYPTEN = 1UL<<4, // CRYPT peripheral clock enable
	RCC_C1_AHB2ENR_CAMITFEN = 1UL<<0, // CAMITF peripheral clock enable		
};

// RCC->C1_AHB4ENR RCC AHB4 Clock Register
enum {
	RCC_C1_AHB4ENR_BKPRAMEN = 1UL<<28, // Backup RAM Clock Enable
	RCC_C1_AHB4ENR_HSEMEN = 1UL<<25, // HSEM peripheral clock enable
	RCC_C1_AHB4ENR_ADC3EN = 1UL<<24, // ADC3 Peripheral Clocks Enable
	RCC_C1_AHB4ENR_BDMAEN = 1UL<<21, // BDMA and DMAMUX2 Clock Enable
	RCC_C1_AHB4ENR_CRCEN = 1UL<<19, // CRC peripheral clock enable
	RCC_C1_AHB4ENR_GPIOKEN = 1UL<<10, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOJEN = 1UL<<9, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOIEN = 1UL<<8, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOHEN = 1UL<<7, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOGEN = 1UL<<6, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOFEN = 1UL<<5, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOEEN = 1UL<<4, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIODEN = 1UL<<3, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOCEN = 1UL<<2, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOBEN = 1UL<<1, // 0GPIO peripheral clock enable
	RCC_C1_AHB4ENR_GPIOAEN = 1UL<<0, // 0GPIO peripheral clock enable		
};

// RCC->C1_APB3ENR RCC APB3 Clock Register
enum {
	RCC_C1_APB3ENR_WWDG1EN = 1UL<<6, // WWDG1 Clock Enable
	RCC_C1_APB3ENR_LTDCEN = 1UL<<3, // LTDC peripheral clock enable		
};

// RCC->C1_APB1LENR RCC APB1 Clock Register
enum {
	RCC_C1_APB1LENR_USART8EN = 1UL<<31, // USART8 Peripheral Clocks Enable
	RCC_C1_APB1LENR_USART7EN = 1UL<<30, // USART7 Peripheral Clocks Enable
	RCC_C1_APB1LENR_DAC12EN = 1UL<<29, // DAC1&2 peripheral clock enable
	RCC_C1_APB1LENR_HDMICECEN = 1UL<<27, // HDMI-CEC peripheral clock enable
	RCC_C1_APB1LENR_I2C3EN = 1UL<<23, // I2C3 Peripheral Clocks Enable
	RCC_C1_APB1LENR_I2C2EN = 1UL<<22, // I2C2 Peripheral Clocks Enable
	RCC_C1_APB1LENR_I2C1EN = 1UL<<21, // I2C1 Peripheral Clocks Enable
	RCC_C1_APB1LENR_UART5EN = 1UL<<20, // UART5 Peripheral Clocks Enable
	RCC_C1_APB1LENR_UART4EN = 1UL<<19, // UART4 Peripheral Clocks Enable
	RCC_C1_APB1LENR_USART3EN = 1UL<<18, // USART3 Peripheral Clocks Enable
	RCC_C1_APB1LENR_USART2EN = 1UL<<17, // USART2 Peripheral Clocks Enable
	RCC_C1_APB1LENR_SPDIFRXEN = 1UL<<16, // SPDIFRX Peripheral Clocks Enable
	RCC_C1_APB1LENR_SPI3EN = 1UL<<15, // SPI3 Peripheral Clocks Enable
	RCC_C1_APB1LENR_SPI2EN = 1UL<<14, // SPI2 Peripheral Clocks Enable
	RCC_C1_APB1LENR_LPTIM1EN = 1UL<<9, // LPTIM1 Peripheral Clocks Enable
	RCC_C1_APB1LENR_TIM14EN = 1UL<<8, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM13EN = 1UL<<7, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM12EN = 1UL<<6, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM7EN = 1UL<<5, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM6EN = 1UL<<4, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM5EN = 1UL<<3, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM4EN = 1UL<<2, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM3EN = 1UL<<1, // TIM peripheral clock enable
	RCC_C1_APB1LENR_TIM2EN = 1UL<<0, // TIM peripheral clock enable		
};

// RCC->C1_APB1HENR RCC APB1 Clock Register
enum {
	RCC_C1_APB1HENR_FDCANEN = 1UL<<8, // FDCAN Peripheral Clocks Enable
	RCC_C1_APB1HENR_MDIOSEN = 1UL<<5, // MDIOS peripheral clock enable
	RCC_C1_APB1HENR_OPAMPEN = 1UL<<4, // OPAMP peripheral clock enable
	RCC_C1_APB1HENR_SWPEN = 1UL<<2, // SWPMI Peripheral Clocks Enable
	RCC_C1_APB1HENR_CRSEN = 1UL<<1, // Clock Recovery System peripheral clock enable		
};

// RCC->C1_APB2ENR RCC APB2 Clock Register
enum {
	RCC_C1_APB2ENR_HRTIMEN = 1UL<<29, // HRTIM peripheral clock enable
	RCC_C1_APB2ENR_DFSDM1EN = 1UL<<28, // DFSDM1 Peripheral Clocks Enable
	RCC_C1_APB2ENR_SAI3EN = 1UL<<24, // SAI3 Peripheral Clocks Enable
	RCC_C1_APB2ENR_SAI2EN = 1UL<<23, // SAI2 Peripheral Clocks Enable
	RCC_C1_APB2ENR_SAI1EN = 1UL<<22, // SAI1 Peripheral Clocks Enable
	RCC_C1_APB2ENR_SPI5EN = 1UL<<20, // SPI5 Peripheral Clocks Enable
	RCC_C1_APB2ENR_TIM17EN = 1UL<<18, // TIM17 peripheral clock enable
	RCC_C1_APB2ENR_TIM16EN = 1UL<<17, // TIM16 peripheral clock enable
	RCC_C1_APB2ENR_TIM15EN = 1UL<<16, // TIM15 peripheral clock enable
	RCC_C1_APB2ENR_SPI4EN = 1UL<<13, // SPI4 Peripheral Clocks Enable
	RCC_C1_APB2ENR_SPI1EN = 1UL<<12, // SPI1 Peripheral Clocks Enable
	RCC_C1_APB2ENR_USART6EN = 1UL<<5, // USART6 Peripheral Clocks Enable
	RCC_C1_APB2ENR_USART1EN = 1UL<<4, // USART1 Peripheral Clocks Enable
	RCC_C1_APB2ENR_TIM8EN = 1UL<<1, // TIM8 peripheral clock enable
	RCC_C1_APB2ENR_TIM1EN = 1UL<<0, // TIM1 peripheral clock enable		
};

// RCC->C1_APB4ENR RCC APB4 Clock Register
enum {
	RCC_C1_APB4ENR_SAI4EN = 1UL<<21, // SAI4 Peripheral Clocks Enable
	RCC_C1_APB4ENR_RTCAPBEN = 1UL<<16, // RTC APB Clock Enable
	RCC_C1_APB4ENR_VREFEN = 1UL<<15, // VREF peripheral clock enable
	RCC_C1_APB4ENR_COMP12EN = 1UL<<14, // COMP1/2 peripheral clock enable
	RCC_C1_APB4ENR_LPTIM5EN = 1UL<<12, // LPTIM5 Peripheral Clocks Enable
	RCC_C1_APB4ENR_LPTIM4EN = 1UL<<11, // LPTIM4 Peripheral Clocks Enable
	RCC_C1_APB4ENR_LPTIM3EN = 1UL<<10, // LPTIM3 Peripheral Clocks Enable
	RCC_C1_APB4ENR_LPTIM2EN = 1UL<<9, // LPTIM2 Peripheral Clocks Enable
	RCC_C1_APB4ENR_I2C4EN = 1UL<<7, // I2C4 Peripheral Clocks Enable
	RCC_C1_APB4ENR_SPI6EN = 1UL<<5, // SPI6 Peripheral Clocks Enable
	RCC_C1_APB4ENR_LPUART1EN = 1UL<<3, // LPUART1 Peripheral Clocks Enable
	RCC_C1_APB4ENR_SYSCFGEN = 1UL<<1, // SYSCFG peripheral clock enable		
};

// RCC->C1_AHB3LPENR RCC AHB3 Sleep Clock Register
enum {
	RCC_C1_AHB3LPENR_AXISRAMLPEN = 1UL<<31, // AXISRAM Block Clock Enable During CSleep mode
	RCC_C1_AHB3LPENR_ITCMLPEN = 1UL<<30, // D1ITCM Block Clock Enable During CSleep mode
	RCC_C1_AHB3LPENR_DTCM2LPEN = 1UL<<29, // D1 DTCM2 Block Clock Enable During CSleep mode
	RCC_C1_AHB3LPENR_D1DTCM1LPEN = 1UL<<28, // D1DTCM1 Block Clock Enable During CSleep mode
	RCC_C1_AHB3LPENR_SDMMC1LPEN = 1UL<<16, // SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
	RCC_C1_AHB3LPENR_QSPILPEN = 1UL<<14, // QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
	RCC_C1_AHB3LPENR_FMCLPEN = 1UL<<12, // FMC Peripheral Clocks Enable During CSleep Mode
	RCC_C1_AHB3LPENR_FLITFLPEN = 1UL<<8, // FLITF Clock Enable During CSleep Mode
	RCC_C1_AHB3LPENR_JPGDECLPEN = 1UL<<5, // JPGDEC Clock Enable During CSleep Mode
	RCC_C1_AHB3LPENR_DMA2DLPEN = 1UL<<4, // DMA2D Clock Enable During CSleep Mode
	RCC_C1_AHB3LPENR_MDMALPEN = 1UL<<0, // MDMA Clock Enable During CSleep Mode		
};

// RCC->C1_AHB1LPENR RCC AHB1 Sleep Clock Register
enum {
	RCC_C1_AHB1LPENR_USB2ULPILPEN = 1UL<<28, // USB_PHY2 clocks enable during CSleep mode
	RCC_C1_AHB1LPENR_USB2OTGLPEN = 1UL<<27, // USB2OTG peripheral clock enable during CSleep mode
	RCC_C1_AHB1LPENR_USB1ULPILPEN = 1UL<<26, // USB_PHY1 clock enable during CSleep mode
	RCC_C1_AHB1LPENR_USB1OTGLPEN = 1UL<<25, // USB1OTG peripheral clock enable during CSleep mode
	RCC_C1_AHB1LPENR_ETH1RXLPEN = 1UL<<17, // Ethernet Reception Clock Enable During CSleep Mode
	RCC_C1_AHB1LPENR_ETH1TXLPEN = 1UL<<16, // Ethernet Transmission Clock Enable During CSleep Mode
	RCC_C1_AHB1LPENR_ETH1MACLPEN = 1UL<<15, // Ethernet MAC bus interface Clock Enable During CSleep Mode
	RCC_C1_AHB1LPENR_ADC12LPEN = 1UL<<5, // ADC1/2 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_AHB1LPENR_DMA2LPEN = 1UL<<1, // DMA2 Clock Enable During CSleep Mode
	RCC_C1_AHB1LPENR_DMA1LPEN = 1UL<<0, // DMA1 Clock Enable During CSleep Mode		
};

// RCC->C1_AHB2LPENR RCC AHB2 Sleep Clock Register
enum {
	RCC_C1_AHB2LPENR_SRAM3LPEN = 1UL<<31, // SRAM3 Clock Enable During CSleep Mode
	RCC_C1_AHB2LPENR_SRAM2LPEN = 1UL<<30, // SRAM2 Clock Enable During CSleep Mode
	RCC_C1_AHB2LPENR_SRAM1LPEN = 1UL<<29, // SRAM1 Clock Enable During CSleep Mode
	RCC_C1_AHB2LPENR_SDMMC2LPEN = 1UL<<9, // SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
	RCC_C1_AHB2LPENR_RNGLPEN = 1UL<<6, // RNG peripheral clock enable during CSleep mode
	RCC_C1_AHB2LPENR_HASHLPEN = 1UL<<5, // HASH peripheral clock enable during CSleep mode
	RCC_C1_AHB2LPENR_CRYPTLPEN = 1UL<<4, // CRYPT peripheral clock enable during CSleep mode
	RCC_C1_AHB2LPENR_CAMITFLPEN = 1UL<<0, // CAMITF peripheral clock enable during CSleep mode		
};

// RCC->C1_AHB4LPENR RCC AHB4 Sleep Clock Register
enum {
	RCC_C1_AHB4LPENR_SRAM4LPEN = 1UL<<29, // SRAM4 Clock Enable During CSleep Mode
	RCC_C1_AHB4LPENR_BKPRAMLPEN = 1UL<<28, // Backup RAM Clock Enable During CSleep Mode
	RCC_C1_AHB4LPENR_ADC3LPEN = 1UL<<24, // ADC3 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_AHB4LPENR_BDMALPEN = 1UL<<21, // BDMA Clock Enable During CSleep Mode
	RCC_C1_AHB4LPENR_CRCLPEN = 1UL<<19, // CRC peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOKLPEN = 1UL<<10, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOJLPEN = 1UL<<9, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOILPEN = 1UL<<8, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOHLPEN = 1UL<<7, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOGLPEN = 1UL<<6, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOFLPEN = 1UL<<5, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOELPEN = 1UL<<4, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIODLPEN = 1UL<<3, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOCLPEN = 1UL<<2, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOBLPEN = 1UL<<1, // GPIO peripheral clock enable during CSleep mode
	RCC_C1_AHB4LPENR_GPIOALPEN = 1UL<<0, // GPIO peripheral clock enable during CSleep mode		
};

// RCC->C1_APB3LPENR RCC APB3 Sleep Clock Register
enum {
	RCC_C1_APB3LPENR_WWDG1LPEN = 1UL<<6, // WWDG1 Clock Enable During CSleep Mode
	RCC_C1_APB3LPENR_LTDCLPEN = 1UL<<3, // LTDC peripheral clock enable during CSleep mode		
};

// RCC->C1_APB1LLPENR RCC APB1 Low Sleep Clock Register
enum {
	RCC_C1_APB1LLPENR_USART8LPEN = 1UL<<31, // USART8 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_USART7LPEN = 1UL<<30, // USART7 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_DAC12LPEN = 1UL<<29, // DAC1/2 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_HDMICECLPEN = 1UL<<27, // HDMI-CEC Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_I2C3LPEN = 1UL<<23, // I2C3 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_I2C2LPEN = 1UL<<22, // I2C2 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_I2C1LPEN = 1UL<<21, // I2C1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_UART5LPEN = 1UL<<20, // UART5 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_UART4LPEN = 1UL<<19, // UART4 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_USART3LPEN = 1UL<<18, // USART3 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_USART2LPEN = 1UL<<17, // USART2 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_SPDIFRXLPEN = 1UL<<16, // SPDIFRX Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_SPI3LPEN = 1UL<<15, // SPI3 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_SPI2LPEN = 1UL<<14, // SPI2 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_LPTIM1LPEN = 1UL<<9, // LPTIM1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1LLPENR_TIM14LPEN = 1UL<<8, // TIM14 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM13LPEN = 1UL<<7, // TIM13 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM12LPEN = 1UL<<6, // TIM12 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM7LPEN = 1UL<<5, // TIM7 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM6LPEN = 1UL<<4, // TIM6 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM5LPEN = 1UL<<3, // TIM5 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM4LPEN = 1UL<<2, // TIM4 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM3LPEN = 1UL<<1, // TIM3 peripheral clock enable during CSleep mode
	RCC_C1_APB1LLPENR_TIM2LPEN = 1UL<<0, // TIM2 peripheral clock enable during CSleep mode		
};

// RCC->C1_APB1HLPENR RCC APB1 High Sleep Clock Register
enum {
	RCC_C1_APB1HLPENR_FDCANLPEN = 1UL<<8, // FDCAN Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1HLPENR_MDIOSLPEN = 1UL<<5, // MDIOS peripheral clock enable during CSleep mode
	RCC_C1_APB1HLPENR_OPAMPLPEN = 1UL<<4, // OPAMP peripheral clock enable during CSleep mode
	RCC_C1_APB1HLPENR_SWPLPEN = 1UL<<2, // SWPMI Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB1HLPENR_CRSLPEN = 1UL<<1, // Clock Recovery System peripheral clock enable during CSleep mode		
};

// RCC->C1_APB2LPENR RCC APB2 Sleep Clock Register
enum {
	RCC_C1_APB2LPENR_HRTIMLPEN = 1UL<<29, // HRTIM peripheral clock enable during CSleep mode
	RCC_C1_APB2LPENR_DFSDM1LPEN = 1UL<<28, // DFSDM1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_SAI3LPEN = 1UL<<24, // SAI3 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_SAI2LPEN = 1UL<<23, // SAI2 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_SAI1LPEN = 1UL<<22, // SAI1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_SPI5LPEN = 1UL<<20, // SPI5 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_TIM17LPEN = 1UL<<18, // TIM17 peripheral clock enable during CSleep mode
	RCC_C1_APB2LPENR_TIM16LPEN = 1UL<<17, // TIM16 peripheral clock enable during CSleep mode
	RCC_C1_APB2LPENR_TIM15LPEN = 1UL<<16, // TIM15 peripheral clock enable during CSleep mode
	RCC_C1_APB2LPENR_SPI4LPEN = 1UL<<13, // SPI4 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_SPI1LPEN = 1UL<<12, // SPI1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_USART6LPEN = 1UL<<5, // USART6 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_USART1LPEN = 1UL<<4, // USART1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB2LPENR_TIM8LPEN = 1UL<<1, // TIM8 peripheral clock enable during CSleep mode
	RCC_C1_APB2LPENR_TIM1LPEN = 1UL<<0, // TIM1 peripheral clock enable during CSleep mode		
};

// RCC->C1_APB4LPENR RCC APB4 Sleep Clock Register
enum {
	RCC_C1_APB4LPENR_SAI4LPEN = 1UL<<21, // SAI4 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_RTCAPBLPEN = 1UL<<16, // RTC APB Clock Enable During CSleep Mode
	RCC_C1_APB4LPENR_VREFLPEN = 1UL<<15, // VREF peripheral clock enable during CSleep mode
	RCC_C1_APB4LPENR_COMP12LPEN = 1UL<<14, // COMP1/2 peripheral clock enable during CSleep mode
	RCC_C1_APB4LPENR_LPTIM5LPEN = 1UL<<12, // LPTIM5 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_LPTIM4LPEN = 1UL<<11, // LPTIM4 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_LPTIM3LPEN = 1UL<<10, // LPTIM3 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_LPTIM2LPEN = 1UL<<9, // LPTIM2 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_I2C4LPEN = 1UL<<7, // I2C4 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_SPI6LPEN = 1UL<<5, // SPI6 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_LPUART1LPEN = 1UL<<3, // LPUART1 Peripheral Clocks Enable During CSleep Mode
	RCC_C1_APB4LPENR_SYSCFGLPEN = 1UL<<1, // SYSCFG peripheral clock enable during CSleep mode		
};

/* RNG */
struct RNG_Type {
	__IO uint8_t CR; // @0 RNG control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t SR; // @4 RNG status register
	 uint8_t RESERVED1[3]; // @5 
	__I uint32_t DR; // @8 The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.
};

// RNG->CR RNG control register
enum {
	RNG_CR_CED = 1UL<<5, // Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
	RNG_CR_IE = 1UL<<3, // Interrupt enable
	RNG_CR_RNGEN = 1UL<<2, // Random number generator enable		
};

// RNG->SR RNG status register
enum {
	RNG_SR_SEIS = 1UL<<6, // Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register.
	RNG_SR_CEIS = 1UL<<5, // Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
	RNG_SR_SECS = 1UL<<2, // Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01)
	RNG_SR_CECS = 1UL<<1, // Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
	RNG_SR_DRDY = 1UL<<0, // Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated.		
};

/* RTC */
struct RTC_Type {
	__IO uint32_t RTC_TR; // @0 The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	__IO uint32_t RTC_DR; // @4 The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	__IO uint32_t RTC_CR; // @8 RTC control register
	__IO uint32_t RTC_ISR; // @12 This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
	__IO uint32_t RTC_PRER; // @16 This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	__IO uint16_t RTC_WUTR; // @20 This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	 uint8_t RESERVED0[6]; // @22 
	__IO uint32_t RTC_ALRMAR; // @28 This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	__IO uint32_t RTC_ALRMBR; // @32 This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
	__O uint8_t RTC_WPR; // @36 RTC write protection register
	 uint8_t RESERVED1[3]; // @37 
	__I uint16_t RTC_SSR; // @40 RTC sub second register
	 uint8_t RESERVED2[2]; // @42 
	__O uint32_t RTC_SHIFTR; // @44 This register is write protected. The write access procedure is described in RTC register write protection on page9.
	__I uint32_t RTC_TSTR; // @48 The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
	__I uint16_t RTC_TSDR; // @52 The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
	 uint8_t RESERVED3[2]; // @54 
	__I uint16_t RTC_TSSSR; // @56 The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
	 uint8_t RESERVED4[2]; // @58 
	__IO uint16_t RTC_CALR; // @60 This register is write protected. The write access procedure is described in RTC register write protection on page9.
	 uint8_t RESERVED5[2]; // @62 
	__IO uint32_t RTC_TAMPCR; // @64 RTC tamper and alternate function configuration register
	__IO uint32_t RTC_ALRMASSR; // @68 This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
	__IO uint32_t RTC_ALRMBSSR; // @72 This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
	__IO uint8_t RTC_OR; // @76 RTC option register
	 uint8_t RESERVED6[3]; // @77 
	__IO uint32_t RTC_BKP0R; // @80 RTC backup registers
	__IO uint32_t RTC_BKP1R; // @84 RTC backup registers
	__IO uint32_t RTC_BKP2R; // @88 RTC backup registers
	__IO uint32_t RTC_BKP3R; // @92 RTC backup registers
	__IO uint32_t RTC_BKP4R; // @96 RTC backup registers
	__IO uint32_t RTC_BKP5R; // @100 RTC backup registers
	__IO uint32_t RTC_BKP6R; // @104 RTC backup registers
	__IO uint32_t RTC_BKP7R; // @108 RTC backup registers
	__IO uint32_t RTC_BKP8R; // @112 RTC backup registers
	__IO uint32_t RTC_BKP9R; // @116 RTC backup registers
	__IO uint32_t RTC_BKP10R; // @120 RTC backup registers
	__IO uint32_t RTC_BKP11R; // @124 RTC backup registers
	__IO uint32_t RTC_BKP12R; // @128 RTC backup registers
	__IO uint32_t RTC_BKP13R; // @132 RTC backup registers
	__IO uint32_t RTC_BKP14R; // @136 RTC backup registers
	__IO uint32_t RTC_BKP15R; // @140 RTC backup registers
	__IO uint32_t RTC_BKP16R; // @144 RTC backup registers
	__IO uint32_t RTC_BKP17R; // @148 RTC backup registers
	__IO uint32_t RTC_BKP18R; // @152 RTC backup registers
	__IO uint32_t RTC_BKP19R; // @156 RTC backup registers
	__IO uint32_t RTC_BKP20R; // @160 RTC backup registers
	__IO uint32_t RTC_BKP21R; // @164 RTC backup registers
	__IO uint32_t RTC_BKP22R; // @168 RTC backup registers
	__IO uint32_t RTC_BKP23R; // @172 RTC backup registers
	__IO uint32_t RTC_BKP24R; // @176 RTC backup registers
	__IO uint32_t RTC_BKP25R; // @180 RTC backup registers
	__IO uint32_t RTC_BKP26R; // @184 RTC backup registers
	__IO uint32_t RTC_BKP27R; // @188 RTC backup registers
	__IO uint32_t RTC_BKP28R; // @192 RTC backup registers
	__IO uint32_t RTC_BKP29R; // @196 RTC backup registers
	__IO uint32_t RTC_BKP30R; // @200 RTC backup registers
	__IO uint32_t RTC_BKP31R; // @204 RTC backup registers
};

// RTC->RTC_TR The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_TR_PM = 1UL<<22, // AM/PM notation
	RTC_RTC_TR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_RTC_TR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_RTC_TR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_RTC_TR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_RTC_TR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_RTC_TR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_rtc_tr_set_ht(struct RTC_Type* p, uint32_t val) { p->RTC_TR = (p->RTC_TR & ~RTC_RTC_TR_HT) | ((val<<20) & RTC_RTC_TR_HT); }
inline void rtc_rtc_tr_set_hu(struct RTC_Type* p, uint32_t val) { p->RTC_TR = (p->RTC_TR & ~RTC_RTC_TR_HU) | ((val<<16) & RTC_RTC_TR_HU); }
inline void rtc_rtc_tr_set_mnt(struct RTC_Type* p, uint32_t val) { p->RTC_TR = (p->RTC_TR & ~RTC_RTC_TR_MNT) | ((val<<12) & RTC_RTC_TR_MNT); }
inline void rtc_rtc_tr_set_mnu(struct RTC_Type* p, uint32_t val) { p->RTC_TR = (p->RTC_TR & ~RTC_RTC_TR_MNU) | ((val<<8) & RTC_RTC_TR_MNU); }
inline void rtc_rtc_tr_set_st(struct RTC_Type* p, uint32_t val) { p->RTC_TR = (p->RTC_TR & ~RTC_RTC_TR_ST) | ((val<<4) & RTC_RTC_TR_ST); }
inline void rtc_rtc_tr_set_su(struct RTC_Type* p, uint32_t val) { p->RTC_TR = (p->RTC_TR & ~RTC_RTC_TR_SU) | ((val<<0) & RTC_RTC_TR_SU); }
inline uint32_t rtc_rtc_tr_get_ht(struct RTC_Type* p) { return (p->RTC_TR & RTC_RTC_TR_HT) >> 20 ; }
inline uint32_t rtc_rtc_tr_get_hu(struct RTC_Type* p) { return (p->RTC_TR & RTC_RTC_TR_HU) >> 16 ; }
inline uint32_t rtc_rtc_tr_get_mnt(struct RTC_Type* p) { return (p->RTC_TR & RTC_RTC_TR_MNT) >> 12 ; }
inline uint32_t rtc_rtc_tr_get_mnu(struct RTC_Type* p) { return (p->RTC_TR & RTC_RTC_TR_MNU) >> 8 ; }
inline uint32_t rtc_rtc_tr_get_st(struct RTC_Type* p) { return (p->RTC_TR & RTC_RTC_TR_ST) >> 4 ; }
inline uint32_t rtc_rtc_tr_get_su(struct RTC_Type* p) { return (p->RTC_TR & RTC_RTC_TR_SU) >> 0 ; }

// RTC->RTC_DR The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_DR_YT = ((1UL<<4)-1) << 20, // Year tens in BCD format
	RTC_RTC_DR_YU = ((1UL<<4)-1) << 16, // Year units in BCD format
	RTC_RTC_DR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_RTC_DR_MT = 1UL<<12, // Month tens in BCD format
	RTC_RTC_DR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_RTC_DR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_RTC_DR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline void rtc_rtc_dr_set_yt(struct RTC_Type* p, uint32_t val) { p->RTC_DR = (p->RTC_DR & ~RTC_RTC_DR_YT) | ((val<<20) & RTC_RTC_DR_YT); }
inline void rtc_rtc_dr_set_yu(struct RTC_Type* p, uint32_t val) { p->RTC_DR = (p->RTC_DR & ~RTC_RTC_DR_YU) | ((val<<16) & RTC_RTC_DR_YU); }
inline void rtc_rtc_dr_set_wdu(struct RTC_Type* p, uint32_t val) { p->RTC_DR = (p->RTC_DR & ~RTC_RTC_DR_WDU) | ((val<<13) & RTC_RTC_DR_WDU); }
inline void rtc_rtc_dr_set_mu(struct RTC_Type* p, uint32_t val) { p->RTC_DR = (p->RTC_DR & ~RTC_RTC_DR_MU) | ((val<<8) & RTC_RTC_DR_MU); }
inline void rtc_rtc_dr_set_dt(struct RTC_Type* p, uint32_t val) { p->RTC_DR = (p->RTC_DR & ~RTC_RTC_DR_DT) | ((val<<4) & RTC_RTC_DR_DT); }
inline void rtc_rtc_dr_set_du(struct RTC_Type* p, uint32_t val) { p->RTC_DR = (p->RTC_DR & ~RTC_RTC_DR_DU) | ((val<<0) & RTC_RTC_DR_DU); }
inline uint32_t rtc_rtc_dr_get_yt(struct RTC_Type* p) { return (p->RTC_DR & RTC_RTC_DR_YT) >> 20 ; }
inline uint32_t rtc_rtc_dr_get_yu(struct RTC_Type* p) { return (p->RTC_DR & RTC_RTC_DR_YU) >> 16 ; }
inline uint32_t rtc_rtc_dr_get_wdu(struct RTC_Type* p) { return (p->RTC_DR & RTC_RTC_DR_WDU) >> 13 ; }
inline uint32_t rtc_rtc_dr_get_mu(struct RTC_Type* p) { return (p->RTC_DR & RTC_RTC_DR_MU) >> 8 ; }
inline uint32_t rtc_rtc_dr_get_dt(struct RTC_Type* p) { return (p->RTC_DR & RTC_RTC_DR_DT) >> 4 ; }
inline uint32_t rtc_rtc_dr_get_du(struct RTC_Type* p) { return (p->RTC_DR & RTC_RTC_DR_DU) >> 0 ; }

// RTC->RTC_CR RTC control register
enum {
	RTC_RTC_CR_ITSE = 1UL<<24, // timestamp on internal event enable
	RTC_RTC_CR_COE = 1UL<<23, // Calibration output enable This bit enables the RTC_CALIB output
	RTC_RTC_CR_OSEL = ((1UL<<2)-1) << 21, // Output selection These bits are used to select the flag to be routed to RTC_ALARM output
	RTC_RTC_CR_POL = 1UL<<20, // Output polarity This bit is used to configure the polarity of RTC_ALARM output
	RTC_RTC_CR_COSEL = 1UL<<19, // Calibration output selection When COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to Section24.3.15: Calibration clock output
	RTC_RTC_CR_BKP = 1UL<<18, // Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
	RTC_RTC_CR_SUB1H = 1UL<<17, // Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
	RTC_RTC_CR_ADD1H = 1UL<<16, // Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
	RTC_RTC_CR_TSIE = 1UL<<15, // Time-stamp interrupt enable
	RTC_RTC_CR_WUTIE = 1UL<<14, // Wakeup timer interrupt enable
	RTC_RTC_CR_ALRBIE = 1UL<<13, // Alarm B interrupt enable
	RTC_RTC_CR_ALRAIE = 1UL<<12, // Alarm A interrupt enable
	RTC_RTC_CR_TSE = 1UL<<11, // timestamp enable
	RTC_RTC_CR_WUTE = 1UL<<10, // Wakeup timer enable
	RTC_RTC_CR_ALRBE = 1UL<<9, // Alarm B enable
	RTC_RTC_CR_ALRAE = 1UL<<8, // Alarm A enable
	RTC_RTC_CR_FMT = 1UL<<6, // Hour format
	RTC_RTC_CR_BYPSHAD = 1UL<<5, // Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
	RTC_RTC_CR_REFCKON = 1UL<<4, // RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
	RTC_RTC_CR_TSEDGE = 1UL<<3, // Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
	RTC_RTC_CR_WUCKSEL = ((1UL<<3)-1) << 0, // Wakeup clock selection		
};
inline void rtc_rtc_cr_set_osel(struct RTC_Type* p, uint32_t val) { p->RTC_CR = (p->RTC_CR & ~RTC_RTC_CR_OSEL) | ((val<<21) & RTC_RTC_CR_OSEL); }
inline void rtc_rtc_cr_set_wucksel(struct RTC_Type* p, uint32_t val) { p->RTC_CR = (p->RTC_CR & ~RTC_RTC_CR_WUCKSEL) | ((val<<0) & RTC_RTC_CR_WUCKSEL); }
inline uint32_t rtc_rtc_cr_get_osel(struct RTC_Type* p) { return (p->RTC_CR & RTC_RTC_CR_OSEL) >> 21 ; }
inline uint32_t rtc_rtc_cr_get_wucksel(struct RTC_Type* p) { return (p->RTC_CR & RTC_RTC_CR_WUCKSEL) >> 0 ; }

// RTC->RTC_ISR This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_ISR_ITSF = 1UL<<17, // Internal tTime-stamp flag
	RTC_RTC_ISR_RECALPF = 1UL<<16, // Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
	RTC_RTC_ISR_TAMP3F = 1UL<<15, // RTC_TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0
	RTC_RTC_ISR_TAMP2F = 1UL<<14, // RTC_TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0
	RTC_RTC_ISR_TAMP1F = 1UL<<13, // RTC_TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0
	RTC_RTC_ISR_TSOVF = 1UL<<12, // Time-stamp overflow flag This flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared.
	RTC_RTC_ISR_TSF = 1UL<<11, // Time-stamp flag This flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0.
	RTC_RTC_ISR_WUTF = 1UL<<10, // Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
	RTC_RTC_ISR_ALRBF = 1UL<<9, // Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0.
	RTC_RTC_ISR_ALRAF = 1UL<<8, // Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0.
	RTC_RTC_ISR_INIT = 1UL<<7, // Initialization mode
	RTC_RTC_ISR_INITF = 1UL<<6, // Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
	RTC_RTC_ISR_RSF = 1UL<<5, // Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
	RTC_RTC_ISR_INITS = 1UL<<4, // Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
	RTC_RTC_ISR_SHPF = 1UL<<3, // Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
	RTC_RTC_ISR_WUTWF = 1UL<<2, // Wakeup timer write flag This bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set.
	RTC_RTC_ISR_ALRBWF = 1UL<<1, // Alarm B write flag This bit is set by hardware when Alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
	RTC_RTC_ISR_ALRAWF = 1UL<<0, // Alarm A write flag This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.		
};

// RTC->RTC_PRER This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_PRER_PREDIV_A = ((1UL<<7)-1) << 16, // Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
	RTC_RTC_PRER_PREDIV_S = ((1UL<<15)-1) << 0, // Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)		
};
inline void rtc_rtc_prer_set_prediv_a(struct RTC_Type* p, uint32_t val) { p->RTC_PRER = (p->RTC_PRER & ~RTC_RTC_PRER_PREDIV_A) | ((val<<16) & RTC_RTC_PRER_PREDIV_A); }
inline void rtc_rtc_prer_set_prediv_s(struct RTC_Type* p, uint32_t val) { p->RTC_PRER = (p->RTC_PRER & ~RTC_RTC_PRER_PREDIV_S) | ((val<<0) & RTC_RTC_PRER_PREDIV_S); }
inline uint32_t rtc_rtc_prer_get_prediv_a(struct RTC_Type* p) { return (p->RTC_PRER & RTC_RTC_PRER_PREDIV_A) >> 16 ; }
inline uint32_t rtc_rtc_prer_get_prediv_s(struct RTC_Type* p) { return (p->RTC_PRER & RTC_RTC_PRER_PREDIV_S) >> 0 ; }

// RTC->RTC_ALRMAR This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_ALRMAR_MSK4 = 1UL<<31, // Alarm A date mask
	RTC_RTC_ALRMAR_WDSEL = 1UL<<30, // Week day selection
	RTC_RTC_ALRMAR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format.
	RTC_RTC_ALRMAR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format.
	RTC_RTC_ALRMAR_MSK3 = 1UL<<23, // Alarm A hours mask
	RTC_RTC_ALRMAR_PM = 1UL<<22, // AM/PM notation
	RTC_RTC_ALRMAR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format.
	RTC_RTC_ALRMAR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format.
	RTC_RTC_ALRMAR_MSK2 = 1UL<<15, // Alarm A minutes mask
	RTC_RTC_ALRMAR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format.
	RTC_RTC_ALRMAR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format.
	RTC_RTC_ALRMAR_MSK1 = 1UL<<7, // Alarm A seconds mask
	RTC_RTC_ALRMAR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format.
	RTC_RTC_ALRMAR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format.		
};
inline void rtc_rtc_alrmar_set_dt(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_DT) | ((val<<28) & RTC_RTC_ALRMAR_DT); }
inline void rtc_rtc_alrmar_set_du(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_DU) | ((val<<24) & RTC_RTC_ALRMAR_DU); }
inline void rtc_rtc_alrmar_set_ht(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_HT) | ((val<<20) & RTC_RTC_ALRMAR_HT); }
inline void rtc_rtc_alrmar_set_hu(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_HU) | ((val<<16) & RTC_RTC_ALRMAR_HU); }
inline void rtc_rtc_alrmar_set_mnt(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_MNT) | ((val<<12) & RTC_RTC_ALRMAR_MNT); }
inline void rtc_rtc_alrmar_set_mnu(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_MNU) | ((val<<8) & RTC_RTC_ALRMAR_MNU); }
inline void rtc_rtc_alrmar_set_st(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_ST) | ((val<<4) & RTC_RTC_ALRMAR_ST); }
inline void rtc_rtc_alrmar_set_su(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMAR = (p->RTC_ALRMAR & ~RTC_RTC_ALRMAR_SU) | ((val<<0) & RTC_RTC_ALRMAR_SU); }
inline uint32_t rtc_rtc_alrmar_get_dt(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_DT) >> 28 ; }
inline uint32_t rtc_rtc_alrmar_get_du(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_DU) >> 24 ; }
inline uint32_t rtc_rtc_alrmar_get_ht(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_HT) >> 20 ; }
inline uint32_t rtc_rtc_alrmar_get_hu(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_HU) >> 16 ; }
inline uint32_t rtc_rtc_alrmar_get_mnt(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_MNT) >> 12 ; }
inline uint32_t rtc_rtc_alrmar_get_mnu(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_MNU) >> 8 ; }
inline uint32_t rtc_rtc_alrmar_get_st(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_ST) >> 4 ; }
inline uint32_t rtc_rtc_alrmar_get_su(struct RTC_Type* p) { return (p->RTC_ALRMAR & RTC_RTC_ALRMAR_SU) >> 0 ; }

// RTC->RTC_ALRMBR This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_ALRMBR_MSK4 = 1UL<<31, // Alarm B date mask
	RTC_RTC_ALRMBR_WDSEL = 1UL<<30, // Week day selection
	RTC_RTC_ALRMBR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_RTC_ALRMBR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_RTC_ALRMBR_MSK3 = 1UL<<23, // Alarm B hours mask
	RTC_RTC_ALRMBR_PM = 1UL<<22, // AM/PM notation
	RTC_RTC_ALRMBR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_RTC_ALRMBR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_RTC_ALRMBR_MSK2 = 1UL<<15, // Alarm B minutes mask
	RTC_RTC_ALRMBR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_RTC_ALRMBR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_RTC_ALRMBR_MSK1 = 1UL<<7, // Alarm B seconds mask
	RTC_RTC_ALRMBR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_RTC_ALRMBR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_rtc_alrmbr_set_dt(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_DT) | ((val<<28) & RTC_RTC_ALRMBR_DT); }
inline void rtc_rtc_alrmbr_set_du(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_DU) | ((val<<24) & RTC_RTC_ALRMBR_DU); }
inline void rtc_rtc_alrmbr_set_ht(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_HT) | ((val<<20) & RTC_RTC_ALRMBR_HT); }
inline void rtc_rtc_alrmbr_set_hu(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_HU) | ((val<<16) & RTC_RTC_ALRMBR_HU); }
inline void rtc_rtc_alrmbr_set_mnt(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_MNT) | ((val<<12) & RTC_RTC_ALRMBR_MNT); }
inline void rtc_rtc_alrmbr_set_mnu(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_MNU) | ((val<<8) & RTC_RTC_ALRMBR_MNU); }
inline void rtc_rtc_alrmbr_set_st(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_ST) | ((val<<4) & RTC_RTC_ALRMBR_ST); }
inline void rtc_rtc_alrmbr_set_su(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBR = (p->RTC_ALRMBR & ~RTC_RTC_ALRMBR_SU) | ((val<<0) & RTC_RTC_ALRMBR_SU); }
inline uint32_t rtc_rtc_alrmbr_get_dt(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_DT) >> 28 ; }
inline uint32_t rtc_rtc_alrmbr_get_du(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_DU) >> 24 ; }
inline uint32_t rtc_rtc_alrmbr_get_ht(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_HT) >> 20 ; }
inline uint32_t rtc_rtc_alrmbr_get_hu(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_HU) >> 16 ; }
inline uint32_t rtc_rtc_alrmbr_get_mnt(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_MNT) >> 12 ; }
inline uint32_t rtc_rtc_alrmbr_get_mnu(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_MNU) >> 8 ; }
inline uint32_t rtc_rtc_alrmbr_get_st(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_ST) >> 4 ; }
inline uint32_t rtc_rtc_alrmbr_get_su(struct RTC_Type* p) { return (p->RTC_ALRMBR & RTC_RTC_ALRMBR_SU) >> 0 ; }

// RTC->RTC_SHIFTR This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_SHIFTR_ADD1S = 1UL<<31, // Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
	RTC_RTC_SHIFTR_SUBFS = ((1UL<<15)-1) << 0, // Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time.		
};
inline void rtc_rtc_shiftr_set_subfs(struct RTC_Type* p, uint32_t val) { p->RTC_SHIFTR = (p->RTC_SHIFTR & ~RTC_RTC_SHIFTR_SUBFS) | ((val<<0) & RTC_RTC_SHIFTR_SUBFS); }
inline uint32_t rtc_rtc_shiftr_get_subfs(struct RTC_Type* p) { return (p->RTC_SHIFTR & RTC_RTC_SHIFTR_SUBFS) >> 0 ; }

// RTC->RTC_TSTR The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
enum {
	RTC_RTC_TSTR_PM = 1UL<<22, // AM/PM notation
	RTC_RTC_TSTR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format.
	RTC_RTC_TSTR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format.
	RTC_RTC_TSTR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format.
	RTC_RTC_TSTR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format.
	RTC_RTC_TSTR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format.
	RTC_RTC_TSTR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format.		
};
inline uint32_t rtc_rtc_tstr_get_ht(struct RTC_Type* p) { return (p->RTC_TSTR & RTC_RTC_TSTR_HT) >> 20 ; }
inline uint32_t rtc_rtc_tstr_get_hu(struct RTC_Type* p) { return (p->RTC_TSTR & RTC_RTC_TSTR_HU) >> 16 ; }
inline uint32_t rtc_rtc_tstr_get_mnt(struct RTC_Type* p) { return (p->RTC_TSTR & RTC_RTC_TSTR_MNT) >> 12 ; }
inline uint32_t rtc_rtc_tstr_get_mnu(struct RTC_Type* p) { return (p->RTC_TSTR & RTC_RTC_TSTR_MNU) >> 8 ; }
inline uint32_t rtc_rtc_tstr_get_st(struct RTC_Type* p) { return (p->RTC_TSTR & RTC_RTC_TSTR_ST) >> 4 ; }
inline uint32_t rtc_rtc_tstr_get_su(struct RTC_Type* p) { return (p->RTC_TSTR & RTC_RTC_TSTR_SU) >> 0 ; }

// RTC->RTC_TSDR The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
enum {
	RTC_RTC_TSDR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_RTC_TSDR_MT = 1UL<<12, // Month tens in BCD format
	RTC_RTC_TSDR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_RTC_TSDR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_RTC_TSDR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline uint32_t rtc_rtc_tsdr_get_wdu(struct RTC_Type* p) { return (p->RTC_TSDR & RTC_RTC_TSDR_WDU) >> 13 ; }
inline uint32_t rtc_rtc_tsdr_get_mu(struct RTC_Type* p) { return (p->RTC_TSDR & RTC_RTC_TSDR_MU) >> 8 ; }
inline uint32_t rtc_rtc_tsdr_get_dt(struct RTC_Type* p) { return (p->RTC_TSDR & RTC_RTC_TSDR_DT) >> 4 ; }
inline uint32_t rtc_rtc_tsdr_get_du(struct RTC_Type* p) { return (p->RTC_TSDR & RTC_RTC_TSDR_DU) >> 0 ; }

// RTC->RTC_CALR This register is write protected. The write access procedure is described in RTC register write protection on page9.
enum {
	RTC_RTC_CALR_CALP = 1UL<<15, // Increase frequency of RTC by 488.5 ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to Section24.3.12: RTC smooth digital calibration.
	RTC_RTC_CALR_CALW8 = 1UL<<14, // Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to Section24.3.12: RTC smooth digital calibration.
	RTC_RTC_CALR_CALW16 = 1UL<<13, // Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12: RTC smooth digital calibration.
	RTC_RTC_CALR_CALM = ((1UL<<9)-1) << 0, // Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section24.3.12: RTC smooth digital calibration on page13.		
};
inline void rtc_rtc_calr_set_calm(struct RTC_Type* p, uint32_t val) { p->RTC_CALR = (p->RTC_CALR & ~RTC_RTC_CALR_CALM) | ((val<<0) & RTC_RTC_CALR_CALM); }
inline uint32_t rtc_rtc_calr_get_calm(struct RTC_Type* p) { return (p->RTC_CALR & RTC_RTC_CALR_CALM) >> 0 ; }

// RTC->RTC_TAMPCR RTC tamper and alternate function configuration register
enum {
	RTC_RTC_TAMPCR_TAMP3MF = 1UL<<24, // Tamper 3 mask flag
	RTC_RTC_TAMPCR_TAMP3NOERASE = 1UL<<23, // Tamper 3 no erase
	RTC_RTC_TAMPCR_TAMP3IE = 1UL<<22, // Tamper 3 interrupt enable
	RTC_RTC_TAMPCR_TAMP2MF = 1UL<<21, // Tamper 2 mask flag
	RTC_RTC_TAMPCR_TAMP2NOERASE = 1UL<<20, // Tamper 2 no erase
	RTC_RTC_TAMPCR_TAMP2IE = 1UL<<19, // Tamper 2 interrupt enable
	RTC_RTC_TAMPCR_TAMP1MF = 1UL<<18, // Tamper 1 mask flag
	RTC_RTC_TAMPCR_TAMP1NOERASE = 1UL<<17, // Tamper 1 no erase
	RTC_RTC_TAMPCR_TAMP1IE = 1UL<<16, // Tamper 1 interrupt enable
	RTC_RTC_TAMPCR_TAMPPUDIS = 1UL<<15, // RTC_TAMPx pull-up disable This bit determines if each of the RTC_TAMPx pins are pre-charged before each sample.
	RTC_RTC_TAMPCR_TAMPPRCH = ((1UL<<2)-1) << 13, // RTC_TAMPx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the RTC_TAMPx inputs.
	RTC_RTC_TAMPCR_TAMPFLT = ((1UL<<2)-1) << 11, // RTC_TAMPx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a Tamper event. TAMPFLT is valid for each of the RTC_TAMPx inputs.
	RTC_RTC_TAMPCR_TAMPFREQ = ((1UL<<3)-1) << 8, // Tamper sampling frequency Determines the frequency at which each of the RTC_TAMPx inputs are sampled.
	RTC_RTC_TAMPCR_TAMPTS = 1UL<<7, // Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register.
	RTC_RTC_TAMPCR_TAMP3TRG = 1UL<<6, // Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:
	RTC_RTC_TAMPCR_TAMP3E = 1UL<<5, // RTC_TAMP3 detection enable
	RTC_RTC_TAMPCR_TAMP2TRG = 1UL<<4, // Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:
	RTC_RTC_TAMPCR_TAMP2E = 1UL<<3, // RTC_TAMP2 input detection enable
	RTC_RTC_TAMPCR_TAMPIE = 1UL<<2, // Tamper interrupt enable
	RTC_RTC_TAMPCR_TAMP1TRG = 1UL<<1, // Active level for RTC_TAMP1 input If TAMPFLT != 00 if TAMPFLT = 00:
	RTC_RTC_TAMPCR_TAMP1E = 1UL<<0, // RTC_TAMP1 input detection enable		
};
inline void rtc_rtc_tampcr_set_tampprch(struct RTC_Type* p, uint32_t val) { p->RTC_TAMPCR = (p->RTC_TAMPCR & ~RTC_RTC_TAMPCR_TAMPPRCH) | ((val<<13) & RTC_RTC_TAMPCR_TAMPPRCH); }
inline void rtc_rtc_tampcr_set_tampflt(struct RTC_Type* p, uint32_t val) { p->RTC_TAMPCR = (p->RTC_TAMPCR & ~RTC_RTC_TAMPCR_TAMPFLT) | ((val<<11) & RTC_RTC_TAMPCR_TAMPFLT); }
inline void rtc_rtc_tampcr_set_tampfreq(struct RTC_Type* p, uint32_t val) { p->RTC_TAMPCR = (p->RTC_TAMPCR & ~RTC_RTC_TAMPCR_TAMPFREQ) | ((val<<8) & RTC_RTC_TAMPCR_TAMPFREQ); }
inline uint32_t rtc_rtc_tampcr_get_tampprch(struct RTC_Type* p) { return (p->RTC_TAMPCR & RTC_RTC_TAMPCR_TAMPPRCH) >> 13 ; }
inline uint32_t rtc_rtc_tampcr_get_tampflt(struct RTC_Type* p) { return (p->RTC_TAMPCR & RTC_RTC_TAMPCR_TAMPFLT) >> 11 ; }
inline uint32_t rtc_rtc_tampcr_get_tampfreq(struct RTC_Type* p) { return (p->RTC_TAMPCR & RTC_RTC_TAMPCR_TAMPFREQ) >> 8 ; }

// RTC->RTC_ALRMASSR This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
enum {
	RTC_RTC_ALRMASSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
	RTC_RTC_ALRMASSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.		
};
inline void rtc_rtc_alrmassr_set_maskss(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMASSR = (p->RTC_ALRMASSR & ~RTC_RTC_ALRMASSR_MASKSS) | ((val<<24) & RTC_RTC_ALRMASSR_MASKSS); }
inline void rtc_rtc_alrmassr_set_ss(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMASSR = (p->RTC_ALRMASSR & ~RTC_RTC_ALRMASSR_SS) | ((val<<0) & RTC_RTC_ALRMASSR_SS); }
inline uint32_t rtc_rtc_alrmassr_get_maskss(struct RTC_Type* p) { return (p->RTC_ALRMASSR & RTC_RTC_ALRMASSR_MASKSS) >> 24 ; }
inline uint32_t rtc_rtc_alrmassr_get_ss(struct RTC_Type* p) { return (p->RTC_ALRMASSR & RTC_RTC_ALRMASSR_SS) >> 0 ; }

// RTC->RTC_ALRMBSSR This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
enum {
	RTC_RTC_ALRMBSSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
	RTC_RTC_ALRMBSSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.		
};
inline void rtc_rtc_alrmbssr_set_maskss(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBSSR = (p->RTC_ALRMBSSR & ~RTC_RTC_ALRMBSSR_MASKSS) | ((val<<24) & RTC_RTC_ALRMBSSR_MASKSS); }
inline void rtc_rtc_alrmbssr_set_ss(struct RTC_Type* p, uint32_t val) { p->RTC_ALRMBSSR = (p->RTC_ALRMBSSR & ~RTC_RTC_ALRMBSSR_SS) | ((val<<0) & RTC_RTC_ALRMBSSR_SS); }
inline uint32_t rtc_rtc_alrmbssr_get_maskss(struct RTC_Type* p) { return (p->RTC_ALRMBSSR & RTC_RTC_ALRMBSSR_MASKSS) >> 24 ; }
inline uint32_t rtc_rtc_alrmbssr_get_ss(struct RTC_Type* p) { return (p->RTC_ALRMBSSR & RTC_RTC_ALRMBSSR_SS) >> 0 ; }

// RTC->RTC_OR RTC option register
enum {
	RTC_RTC_OR_RTC_OUT_RMP = 1UL<<1, // RTC_OUT remap
	RTC_RTC_OR_RTC_ALARM_TYPE = 1UL<<0, // RTC_ALARM output type on PC13		
};




/* SAI */
struct SAI4_Type {
	__IO uint8_t SAI_GCR; // @0 Global configuration register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t SAI_ACR1; // @4 Configuration register 1
	__IO uint16_t SAI_ACR2; // @8 Configuration register 2
	 uint8_t RESERVED1[2]; // @10 
	__IO uint32_t SAI_AFRCR; // @12 This register has no meaning in AC97 and SPDIF audio protocol
	__IO uint32_t SAI_ASLOTR; // @16 This register has no meaning in AC97 and SPDIF audio protocol
	__IO uint8_t SAI_AIM; // @20 Interrupt mask register 2
	 uint8_t RESERVED2[3]; // @21 
	__I uint32_t SAI_ASR; // @24 Status register
	__O uint8_t SAI_ACLRFR; // @28 Clear flag register
	 uint8_t RESERVED3[3]; // @29 
	__IO uint32_t SAI_ADR; // @32 Data register
	__IO uint32_t SAI_BCR1; // @36 Configuration register 1
	__IO uint16_t SAI_BCR2; // @40 Configuration register 2
	 uint8_t RESERVED4[2]; // @42 
	__IO uint32_t SAI_BFRCR; // @44 This register has no meaning in AC97 and SPDIF audio protocol
	__IO uint32_t SAI_BSLOTR; // @48 This register has no meaning in AC97 and SPDIF audio protocol
	__IO uint8_t SAI_BIM; // @52 Interrupt mask register 2
	 uint8_t RESERVED5[3]; // @53 
	__I uint32_t SAI_BSR; // @56 Status register
	__O uint8_t SAI_BCLRFR; // @60 Clear flag register
	 uint8_t RESERVED6[3]; // @61 
	__IO uint32_t SAI_BDR; // @64 Data register
	__IO uint16_t SAI_PDMCR; // @68 PDM control register
	 uint8_t RESERVED7[2]; // @70 
	__IO uint32_t SAI_PDMDLY; // @72 PDM delay register
};

// SAI4->SAI_GCR Global configuration register
enum {
	SAI4_SAI_GCR_SYNCOUT = ((1UL<<2)-1) << 4, // Synchronization outputs These bits are set and cleared by software.
	SAI4_SAI_GCR_SYNCIN = ((1UL<<2)-1) << 0, // Synchronization inputs		
};
inline void sai4_sai_gcr_set_syncout(struct SAI4_Type* p, uint32_t val) { p->SAI_GCR = (p->SAI_GCR & ~SAI4_SAI_GCR_SYNCOUT) | ((val<<4) & SAI4_SAI_GCR_SYNCOUT); }
inline void sai4_sai_gcr_set_syncin(struct SAI4_Type* p, uint32_t val) { p->SAI_GCR = (p->SAI_GCR & ~SAI4_SAI_GCR_SYNCIN) | ((val<<0) & SAI4_SAI_GCR_SYNCIN); }
inline uint32_t sai4_sai_gcr_get_syncout(struct SAI4_Type* p) { return (p->SAI_GCR & SAI4_SAI_GCR_SYNCOUT) >> 4 ; }
inline uint32_t sai4_sai_gcr_get_syncin(struct SAI4_Type* p) { return (p->SAI_GCR & SAI4_SAI_GCR_SYNCIN) >> 0 ; }

// SAI4->SAI_ACR1 Configuration register 1
enum {
	SAI4_SAI_ACR1_OSR = 1UL<<26, // Oversampling ratio for master clock
	SAI4_SAI_ACR1_MCKDIV = ((1UL<<4)-1) << 20, // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
	SAI4_SAI_ACR1_NOMCK = 1UL<<19, // No divider
	SAI4_SAI_ACR1_DMAEN = 1UL<<17, // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
	SAI4_SAI_ACR1_SAIXEN = 1UL<<16, // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
	SAI4_SAI_ACR1_OUTDRIV = 1UL<<13, // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
	SAI4_SAI_ACR1_MONO = 1UL<<12, // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
	SAI4_SAI_ACR1_SYNCEN = ((1UL<<2)-1) << 10, // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
	SAI4_SAI_ACR1_CKSTR = 1UL<<9, // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
	SAI4_SAI_ACR1_LSBFIRST = 1UL<<8, // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
	SAI4_SAI_ACR1_DS = ((1UL<<3)-1) << 5, // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
	SAI4_SAI_ACR1_PRTCFG = ((1UL<<2)-1) << 2, // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
	SAI4_SAI_ACR1_MODE = ((1UL<<2)-1) << 0, // SAIx audio block mode immediately		
};
inline void sai4_sai_acr1_set_mckdiv(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR1 = (p->SAI_ACR1 & ~SAI4_SAI_ACR1_MCKDIV) | ((val<<20) & SAI4_SAI_ACR1_MCKDIV); }
inline void sai4_sai_acr1_set_syncen(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR1 = (p->SAI_ACR1 & ~SAI4_SAI_ACR1_SYNCEN) | ((val<<10) & SAI4_SAI_ACR1_SYNCEN); }
inline void sai4_sai_acr1_set_ds(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR1 = (p->SAI_ACR1 & ~SAI4_SAI_ACR1_DS) | ((val<<5) & SAI4_SAI_ACR1_DS); }
inline void sai4_sai_acr1_set_prtcfg(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR1 = (p->SAI_ACR1 & ~SAI4_SAI_ACR1_PRTCFG) | ((val<<2) & SAI4_SAI_ACR1_PRTCFG); }
inline void sai4_sai_acr1_set_mode(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR1 = (p->SAI_ACR1 & ~SAI4_SAI_ACR1_MODE) | ((val<<0) & SAI4_SAI_ACR1_MODE); }
inline uint32_t sai4_sai_acr1_get_mckdiv(struct SAI4_Type* p) { return (p->SAI_ACR1 & SAI4_SAI_ACR1_MCKDIV) >> 20 ; }
inline uint32_t sai4_sai_acr1_get_syncen(struct SAI4_Type* p) { return (p->SAI_ACR1 & SAI4_SAI_ACR1_SYNCEN) >> 10 ; }
inline uint32_t sai4_sai_acr1_get_ds(struct SAI4_Type* p) { return (p->SAI_ACR1 & SAI4_SAI_ACR1_DS) >> 5 ; }
inline uint32_t sai4_sai_acr1_get_prtcfg(struct SAI4_Type* p) { return (p->SAI_ACR1 & SAI4_SAI_ACR1_PRTCFG) >> 2 ; }
inline uint32_t sai4_sai_acr1_get_mode(struct SAI4_Type* p) { return (p->SAI_ACR1 & SAI4_SAI_ACR1_MODE) >> 0 ; }

// SAI4->SAI_ACR2 Configuration register 2
enum {
	SAI4_SAI_ACR2_COMP = ((1UL<<2)-1) << 14, // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
	SAI4_SAI_ACR2_CPL = 1UL<<13, // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
	SAI4_SAI_ACR2_MUTECNT = ((1UL<<6)-1) << 7, // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
	SAI4_SAI_ACR2_MUTEVAL = 1UL<<6, // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
	SAI4_SAI_ACR2_MUTE = 1UL<<5, // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
	SAI4_SAI_ACR2_TRIS = 1UL<<4, // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
	SAI4_SAI_ACR2_FFLUSH = 1UL<<3, // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
	SAI4_SAI_ACR2_FTH = ((1UL<<3)-1) << 0, // FIFO threshold. This bit is set and cleared by software.		
};
inline void sai4_sai_acr2_set_comp(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR2 = (p->SAI_ACR2 & ~SAI4_SAI_ACR2_COMP) | ((val<<14) & SAI4_SAI_ACR2_COMP); }
inline void sai4_sai_acr2_set_mutecnt(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR2 = (p->SAI_ACR2 & ~SAI4_SAI_ACR2_MUTECNT) | ((val<<7) & SAI4_SAI_ACR2_MUTECNT); }
inline void sai4_sai_acr2_set_fth(struct SAI4_Type* p, uint32_t val) { p->SAI_ACR2 = (p->SAI_ACR2 & ~SAI4_SAI_ACR2_FTH) | ((val<<0) & SAI4_SAI_ACR2_FTH); }
inline uint32_t sai4_sai_acr2_get_comp(struct SAI4_Type* p) { return (p->SAI_ACR2 & SAI4_SAI_ACR2_COMP) >> 14 ; }
inline uint32_t sai4_sai_acr2_get_mutecnt(struct SAI4_Type* p) { return (p->SAI_ACR2 & SAI4_SAI_ACR2_MUTECNT) >> 7 ; }
inline uint32_t sai4_sai_acr2_get_fth(struct SAI4_Type* p) { return (p->SAI_ACR2 & SAI4_SAI_ACR2_FTH) >> 0 ; }

// SAI4->SAI_AFRCR This register has no meaning in AC97 and SPDIF audio protocol
enum {
	SAI4_SAI_AFRCR_FSOFF = 1UL<<18, // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
	SAI4_SAI_AFRCR_FSPOL = 1UL<<17, // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
	SAI4_SAI_AFRCR_FSDEF = 1UL<<16, // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
	SAI4_SAI_AFRCR_FSALL = ((1UL<<7)-1) << 8, // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
	SAI4_SAI_AFRCR_FRL = ((1UL<<8)-1) << 0, // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.		
};
inline void sai4_sai_afrcr_set_fsall(struct SAI4_Type* p, uint32_t val) { p->SAI_AFRCR = (p->SAI_AFRCR & ~SAI4_SAI_AFRCR_FSALL) | ((val<<8) & SAI4_SAI_AFRCR_FSALL); }
inline void sai4_sai_afrcr_set_frl(struct SAI4_Type* p, uint32_t val) { p->SAI_AFRCR = (p->SAI_AFRCR & ~SAI4_SAI_AFRCR_FRL) | ((val<<0) & SAI4_SAI_AFRCR_FRL); }
inline uint32_t sai4_sai_afrcr_get_fsall(struct SAI4_Type* p) { return (p->SAI_AFRCR & SAI4_SAI_AFRCR_FSALL) >> 8 ; }
inline uint32_t sai4_sai_afrcr_get_frl(struct SAI4_Type* p) { return (p->SAI_AFRCR & SAI4_SAI_AFRCR_FRL) >> 0 ; }

// SAI4->SAI_ASLOTR This register has no meaning in AC97 and SPDIF audio protocol
enum {
	SAI4_SAI_ASLOTR_SLOTEN = ((1UL<<16)-1) << 16, // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
	SAI4_SAI_ASLOTR_NBSLOT = ((1UL<<4)-1) << 8, // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
	SAI4_SAI_ASLOTR_SLOTSZ = ((1UL<<2)-1) << 6, // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
	SAI4_SAI_ASLOTR_FBOFF = ((1UL<<5)-1) << 0, // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.		
};
inline void sai4_sai_aslotr_set_sloten(struct SAI4_Type* p, uint32_t val) { p->SAI_ASLOTR = (p->SAI_ASLOTR & ~SAI4_SAI_ASLOTR_SLOTEN) | ((val<<16) & SAI4_SAI_ASLOTR_SLOTEN); }
inline void sai4_sai_aslotr_set_nbslot(struct SAI4_Type* p, uint32_t val) { p->SAI_ASLOTR = (p->SAI_ASLOTR & ~SAI4_SAI_ASLOTR_NBSLOT) | ((val<<8) & SAI4_SAI_ASLOTR_NBSLOT); }
inline void sai4_sai_aslotr_set_slotsz(struct SAI4_Type* p, uint32_t val) { p->SAI_ASLOTR = (p->SAI_ASLOTR & ~SAI4_SAI_ASLOTR_SLOTSZ) | ((val<<6) & SAI4_SAI_ASLOTR_SLOTSZ); }
inline void sai4_sai_aslotr_set_fboff(struct SAI4_Type* p, uint32_t val) { p->SAI_ASLOTR = (p->SAI_ASLOTR & ~SAI4_SAI_ASLOTR_FBOFF) | ((val<<0) & SAI4_SAI_ASLOTR_FBOFF); }
inline uint32_t sai4_sai_aslotr_get_sloten(struct SAI4_Type* p) { return (p->SAI_ASLOTR & SAI4_SAI_ASLOTR_SLOTEN) >> 16 ; }
inline uint32_t sai4_sai_aslotr_get_nbslot(struct SAI4_Type* p) { return (p->SAI_ASLOTR & SAI4_SAI_ASLOTR_NBSLOT) >> 8 ; }
inline uint32_t sai4_sai_aslotr_get_slotsz(struct SAI4_Type* p) { return (p->SAI_ASLOTR & SAI4_SAI_ASLOTR_SLOTSZ) >> 6 ; }
inline uint32_t sai4_sai_aslotr_get_fboff(struct SAI4_Type* p) { return (p->SAI_ASLOTR & SAI4_SAI_ASLOTR_FBOFF) >> 0 ; }

// SAI4->SAI_AIM Interrupt mask register 2
enum {
	SAI4_SAI_AIM_LFSDETIE = 1UL<<6, // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
	SAI4_SAI_AIM_AFSDETIE = 1UL<<5, // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
	SAI4_SAI_AIM_CNRDYIE = 1UL<<4, // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
	SAI4_SAI_AIM_FREQIE = 1UL<<3, // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
	SAI4_SAI_AIM_WCKCFGIE = 1UL<<2, // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
	SAI4_SAI_AIM_MUTEDETIE = 1UL<<1, // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
	SAI4_SAI_AIM_OVRUDRIE = 1UL<<0, // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.		
};

// SAI4->SAI_ASR Status register
enum {
	SAI4_SAI_ASR_FLVL = ((1UL<<3)-1) << 16, // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
	SAI4_SAI_ASR_LFSDET = 1UL<<6, // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
	SAI4_SAI_ASR_AFSDET = 1UL<<5, // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
	SAI4_SAI_ASR_CNRDY = 1UL<<4, // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
	SAI4_SAI_ASR_FREQ = 1UL<<3, // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
	SAI4_SAI_ASR_WCKCFG = 1UL<<2, // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
	SAI4_SAI_ASR_MUTEDET = 1UL<<1, // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
	SAI4_SAI_ASR_OVRUDR = 1UL<<0, // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.		
};
inline uint32_t sai4_sai_asr_get_flvl(struct SAI4_Type* p) { return (p->SAI_ASR & SAI4_SAI_ASR_FLVL) >> 16 ; }

// SAI4->SAI_ACLRFR Clear flag register
enum {
	SAI4_SAI_ACLRFR_CLFSDET = 1UL<<6, // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
	SAI4_SAI_ACLRFR_CAFSDET = 1UL<<5, // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
	SAI4_SAI_ACLRFR_CCNRDY = 1UL<<4, // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
	SAI4_SAI_ACLRFR_CWCKCFG = 1UL<<2, // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
	SAI4_SAI_ACLRFR_CMUTEDET = 1UL<<1, // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
	SAI4_SAI_ACLRFR_COVRUDR = 1UL<<0, // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.		
};

// SAI4->SAI_BCR1 Configuration register 1
enum {
	SAI4_SAI_BCR1_OSR = 1UL<<26, // Oversampling ratio for master clock
	SAI4_SAI_BCR1_MCKDIV = ((1UL<<4)-1) << 20, // Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
	SAI4_SAI_BCR1_NOMCK = 1UL<<19, // No divider
	SAI4_SAI_BCR1_DMAEN = 1UL<<17, // DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
	SAI4_SAI_BCR1_SAIXEN = 1UL<<16, // Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
	SAI4_SAI_BCR1_OUTDRIV = 1UL<<13, // Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
	SAI4_SAI_BCR1_MONO = 1UL<<12, // Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
	SAI4_SAI_BCR1_SYNCEN = ((1UL<<2)-1) << 10, // Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
	SAI4_SAI_BCR1_CKSTR = 1UL<<9, // Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
	SAI4_SAI_BCR1_LSBFIRST = 1UL<<8, // Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
	SAI4_SAI_BCR1_DS = ((1UL<<3)-1) << 5, // Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
	SAI4_SAI_BCR1_PRTCFG = ((1UL<<2)-1) << 2, // Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
	SAI4_SAI_BCR1_MODE = ((1UL<<2)-1) << 0, // SAIx audio block mode immediately		
};
inline void sai4_sai_bcr1_set_mckdiv(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR1 = (p->SAI_BCR1 & ~SAI4_SAI_BCR1_MCKDIV) | ((val<<20) & SAI4_SAI_BCR1_MCKDIV); }
inline void sai4_sai_bcr1_set_syncen(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR1 = (p->SAI_BCR1 & ~SAI4_SAI_BCR1_SYNCEN) | ((val<<10) & SAI4_SAI_BCR1_SYNCEN); }
inline void sai4_sai_bcr1_set_ds(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR1 = (p->SAI_BCR1 & ~SAI4_SAI_BCR1_DS) | ((val<<5) & SAI4_SAI_BCR1_DS); }
inline void sai4_sai_bcr1_set_prtcfg(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR1 = (p->SAI_BCR1 & ~SAI4_SAI_BCR1_PRTCFG) | ((val<<2) & SAI4_SAI_BCR1_PRTCFG); }
inline void sai4_sai_bcr1_set_mode(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR1 = (p->SAI_BCR1 & ~SAI4_SAI_BCR1_MODE) | ((val<<0) & SAI4_SAI_BCR1_MODE); }
inline uint32_t sai4_sai_bcr1_get_mckdiv(struct SAI4_Type* p) { return (p->SAI_BCR1 & SAI4_SAI_BCR1_MCKDIV) >> 20 ; }
inline uint32_t sai4_sai_bcr1_get_syncen(struct SAI4_Type* p) { return (p->SAI_BCR1 & SAI4_SAI_BCR1_SYNCEN) >> 10 ; }
inline uint32_t sai4_sai_bcr1_get_ds(struct SAI4_Type* p) { return (p->SAI_BCR1 & SAI4_SAI_BCR1_DS) >> 5 ; }
inline uint32_t sai4_sai_bcr1_get_prtcfg(struct SAI4_Type* p) { return (p->SAI_BCR1 & SAI4_SAI_BCR1_PRTCFG) >> 2 ; }
inline uint32_t sai4_sai_bcr1_get_mode(struct SAI4_Type* p) { return (p->SAI_BCR1 & SAI4_SAI_BCR1_MODE) >> 0 ; }

// SAI4->SAI_BCR2 Configuration register 2
enum {
	SAI4_SAI_BCR2_COMP = ((1UL<<2)-1) << 14, // Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
	SAI4_SAI_BCR2_CPL = 1UL<<13, // Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
	SAI4_SAI_BCR2_MUTECNT = ((1UL<<6)-1) << 7, // Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
	SAI4_SAI_BCR2_MUTEVAL = 1UL<<6, // Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
	SAI4_SAI_BCR2_MUTE = 1UL<<5, // Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
	SAI4_SAI_BCR2_TRIS = 1UL<<4, // Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
	SAI4_SAI_BCR2_FFLUSH = 1UL<<3, // FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
	SAI4_SAI_BCR2_FTH = ((1UL<<3)-1) << 0, // FIFO threshold. This bit is set and cleared by software.		
};
inline void sai4_sai_bcr2_set_comp(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR2 = (p->SAI_BCR2 & ~SAI4_SAI_BCR2_COMP) | ((val<<14) & SAI4_SAI_BCR2_COMP); }
inline void sai4_sai_bcr2_set_mutecnt(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR2 = (p->SAI_BCR2 & ~SAI4_SAI_BCR2_MUTECNT) | ((val<<7) & SAI4_SAI_BCR2_MUTECNT); }
inline void sai4_sai_bcr2_set_fth(struct SAI4_Type* p, uint32_t val) { p->SAI_BCR2 = (p->SAI_BCR2 & ~SAI4_SAI_BCR2_FTH) | ((val<<0) & SAI4_SAI_BCR2_FTH); }
inline uint32_t sai4_sai_bcr2_get_comp(struct SAI4_Type* p) { return (p->SAI_BCR2 & SAI4_SAI_BCR2_COMP) >> 14 ; }
inline uint32_t sai4_sai_bcr2_get_mutecnt(struct SAI4_Type* p) { return (p->SAI_BCR2 & SAI4_SAI_BCR2_MUTECNT) >> 7 ; }
inline uint32_t sai4_sai_bcr2_get_fth(struct SAI4_Type* p) { return (p->SAI_BCR2 & SAI4_SAI_BCR2_FTH) >> 0 ; }

// SAI4->SAI_BFRCR This register has no meaning in AC97 and SPDIF audio protocol
enum {
	SAI4_SAI_BFRCR_FSOFF = 1UL<<18, // Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
	SAI4_SAI_BFRCR_FSPOL = 1UL<<17, // Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
	SAI4_SAI_BFRCR_FSDEF = 1UL<<16, // Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
	SAI4_SAI_BFRCR_FSALL = ((1UL<<7)-1) << 8, // Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
	SAI4_SAI_BFRCR_FRL = ((1UL<<8)-1) << 0, // Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.		
};
inline void sai4_sai_bfrcr_set_fsall(struct SAI4_Type* p, uint32_t val) { p->SAI_BFRCR = (p->SAI_BFRCR & ~SAI4_SAI_BFRCR_FSALL) | ((val<<8) & SAI4_SAI_BFRCR_FSALL); }
inline void sai4_sai_bfrcr_set_frl(struct SAI4_Type* p, uint32_t val) { p->SAI_BFRCR = (p->SAI_BFRCR & ~SAI4_SAI_BFRCR_FRL) | ((val<<0) & SAI4_SAI_BFRCR_FRL); }
inline uint32_t sai4_sai_bfrcr_get_fsall(struct SAI4_Type* p) { return (p->SAI_BFRCR & SAI4_SAI_BFRCR_FSALL) >> 8 ; }
inline uint32_t sai4_sai_bfrcr_get_frl(struct SAI4_Type* p) { return (p->SAI_BFRCR & SAI4_SAI_BFRCR_FRL) >> 0 ; }

// SAI4->SAI_BSLOTR This register has no meaning in AC97 and SPDIF audio protocol
enum {
	SAI4_SAI_BSLOTR_SLOTEN = ((1UL<<16)-1) << 16, // Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
	SAI4_SAI_BSLOTR_NBSLOT = ((1UL<<4)-1) << 8, // Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
	SAI4_SAI_BSLOTR_SLOTSZ = ((1UL<<2)-1) << 6, // Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
	SAI4_SAI_BSLOTR_FBOFF = ((1UL<<5)-1) << 0, // First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.		
};
inline void sai4_sai_bslotr_set_sloten(struct SAI4_Type* p, uint32_t val) { p->SAI_BSLOTR = (p->SAI_BSLOTR & ~SAI4_SAI_BSLOTR_SLOTEN) | ((val<<16) & SAI4_SAI_BSLOTR_SLOTEN); }
inline void sai4_sai_bslotr_set_nbslot(struct SAI4_Type* p, uint32_t val) { p->SAI_BSLOTR = (p->SAI_BSLOTR & ~SAI4_SAI_BSLOTR_NBSLOT) | ((val<<8) & SAI4_SAI_BSLOTR_NBSLOT); }
inline void sai4_sai_bslotr_set_slotsz(struct SAI4_Type* p, uint32_t val) { p->SAI_BSLOTR = (p->SAI_BSLOTR & ~SAI4_SAI_BSLOTR_SLOTSZ) | ((val<<6) & SAI4_SAI_BSLOTR_SLOTSZ); }
inline void sai4_sai_bslotr_set_fboff(struct SAI4_Type* p, uint32_t val) { p->SAI_BSLOTR = (p->SAI_BSLOTR & ~SAI4_SAI_BSLOTR_FBOFF) | ((val<<0) & SAI4_SAI_BSLOTR_FBOFF); }
inline uint32_t sai4_sai_bslotr_get_sloten(struct SAI4_Type* p) { return (p->SAI_BSLOTR & SAI4_SAI_BSLOTR_SLOTEN) >> 16 ; }
inline uint32_t sai4_sai_bslotr_get_nbslot(struct SAI4_Type* p) { return (p->SAI_BSLOTR & SAI4_SAI_BSLOTR_NBSLOT) >> 8 ; }
inline uint32_t sai4_sai_bslotr_get_slotsz(struct SAI4_Type* p) { return (p->SAI_BSLOTR & SAI4_SAI_BSLOTR_SLOTSZ) >> 6 ; }
inline uint32_t sai4_sai_bslotr_get_fboff(struct SAI4_Type* p) { return (p->SAI_BSLOTR & SAI4_SAI_BSLOTR_FBOFF) >> 0 ; }

// SAI4->SAI_BIM Interrupt mask register 2
enum {
	SAI4_SAI_BIM_LFSDETIE = 1UL<<6, // Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
	SAI4_SAI_BIM_AFSDETIE = 1UL<<5, // Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
	SAI4_SAI_BIM_CNRDYIE = 1UL<<4, // Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
	SAI4_SAI_BIM_FREQIE = 1UL<<3, // FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
	SAI4_SAI_BIM_WCKCFGIE = 1UL<<2, // Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
	SAI4_SAI_BIM_MUTEDETIE = 1UL<<1, // Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
	SAI4_SAI_BIM_OVRUDRIE = 1UL<<0, // Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.		
};

// SAI4->SAI_BSR Status register
enum {
	SAI4_SAI_BSR_FLVL = ((1UL<<3)-1) << 16, // FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
	SAI4_SAI_BSR_LFSDET = 1UL<<6, // Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
	SAI4_SAI_BSR_AFSDET = 1UL<<5, // Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
	SAI4_SAI_BSR_CNRDY = 1UL<<4, // Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
	SAI4_SAI_BSR_FREQ = 1UL<<3, // FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
	SAI4_SAI_BSR_WCKCFG = 1UL<<2, // Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
	SAI4_SAI_BSR_MUTEDET = 1UL<<1, // Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
	SAI4_SAI_BSR_OVRUDR = 1UL<<0, // Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.		
};
inline uint32_t sai4_sai_bsr_get_flvl(struct SAI4_Type* p) { return (p->SAI_BSR & SAI4_SAI_BSR_FLVL) >> 16 ; }

// SAI4->SAI_BCLRFR Clear flag register
enum {
	SAI4_SAI_BCLRFR_CLFSDET = 1UL<<6, // Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
	SAI4_SAI_BCLRFR_CAFSDET = 1UL<<5, // Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
	SAI4_SAI_BCLRFR_CCNRDY = 1UL<<4, // Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
	SAI4_SAI_BCLRFR_CWCKCFG = 1UL<<2, // Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
	SAI4_SAI_BCLRFR_CMUTEDET = 1UL<<1, // Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
	SAI4_SAI_BCLRFR_COVRUDR = 1UL<<0, // Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.		
};

// SAI4->SAI_PDMCR PDM control register
enum {
	SAI4_SAI_PDMCR_CKEN4 = 1UL<<11, // Clock enable of bitstream clock number 4
	SAI4_SAI_PDMCR_CKEN3 = 1UL<<10, // Clock enable of bitstream clock number 3
	SAI4_SAI_PDMCR_CKEN2 = 1UL<<9, // Clock enable of bitstream clock number 2
	SAI4_SAI_PDMCR_CKEN1 = 1UL<<8, // Clock enable of bitstream clock number 1
	SAI4_SAI_PDMCR_MICNBR = ((1UL<<2)-1) << 4, // Number of microphones
	SAI4_SAI_PDMCR_PDMEN = 1UL<<0, // PDM enable		
};
inline void sai4_sai_pdmcr_set_micnbr(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMCR = (p->SAI_PDMCR & ~SAI4_SAI_PDMCR_MICNBR) | ((val<<4) & SAI4_SAI_PDMCR_MICNBR); }
inline uint32_t sai4_sai_pdmcr_get_micnbr(struct SAI4_Type* p) { return (p->SAI_PDMCR & SAI4_SAI_PDMCR_MICNBR) >> 4 ; }

// SAI4->SAI_PDMDLY PDM delay register
enum {
	SAI4_SAI_PDMDLY_DLYM4R = ((1UL<<3)-1) << 28, // Delay line for second microphone of pair 4
	SAI4_SAI_PDMDLY_DLYM4L = ((1UL<<3)-1) << 24, // Delay line for first microphone of pair 4
	SAI4_SAI_PDMDLY_DLYM3R = ((1UL<<3)-1) << 20, // Delay line for second microphone of pair 3
	SAI4_SAI_PDMDLY_DLYM3L = ((1UL<<3)-1) << 16, // Delay line for first microphone of pair 3
	SAI4_SAI_PDMDLY_DLYM2R = ((1UL<<3)-1) << 12, // Delay line for second microphone of pair 2
	SAI4_SAI_PDMDLY_DLYM2L = ((1UL<<3)-1) << 8, // Delay line for first microphone of pair 2
	SAI4_SAI_PDMDLY_DLYM1R = ((1UL<<3)-1) << 4, // Delay line adjust for second microphone of pair 1
	SAI4_SAI_PDMDLY_DLYM1L = ((1UL<<3)-1) << 0, // Delay line adjust for first microphone of pair 1		
};
inline void sai4_sai_pdmdly_set_dlym4r(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM4R) | ((val<<28) & SAI4_SAI_PDMDLY_DLYM4R); }
inline void sai4_sai_pdmdly_set_dlym4l(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM4L) | ((val<<24) & SAI4_SAI_PDMDLY_DLYM4L); }
inline void sai4_sai_pdmdly_set_dlym3r(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM3R) | ((val<<20) & SAI4_SAI_PDMDLY_DLYM3R); }
inline void sai4_sai_pdmdly_set_dlym3l(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM3L) | ((val<<16) & SAI4_SAI_PDMDLY_DLYM3L); }
inline void sai4_sai_pdmdly_set_dlym2r(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM2R) | ((val<<12) & SAI4_SAI_PDMDLY_DLYM2R); }
inline void sai4_sai_pdmdly_set_dlym2l(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM2L) | ((val<<8) & SAI4_SAI_PDMDLY_DLYM2L); }
inline void sai4_sai_pdmdly_set_dlym1r(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM1R) | ((val<<4) & SAI4_SAI_PDMDLY_DLYM1R); }
inline void sai4_sai_pdmdly_set_dlym1l(struct SAI4_Type* p, uint32_t val) { p->SAI_PDMDLY = (p->SAI_PDMDLY & ~SAI4_SAI_PDMDLY_DLYM1L) | ((val<<0) & SAI4_SAI_PDMDLY_DLYM1L); }
inline uint32_t sai4_sai_pdmdly_get_dlym4r(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM4R) >> 28 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym4l(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM4L) >> 24 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym3r(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM3R) >> 20 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym3l(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM3L) >> 16 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym2r(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM2R) >> 12 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym2l(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM2L) >> 8 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym1r(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM1R) >> 4 ; }
inline uint32_t sai4_sai_pdmdly_get_dlym1l(struct SAI4_Type* p) { return (p->SAI_PDMDLY & SAI4_SAI_PDMDLY_DLYM1L) >> 0 ; }

/* System control block */
struct SCB_Type {
	__I uint32_t CPUID; // @0 CPUID base register
	__IO uint32_t ICSR; // @4 Interrupt control and state register
	__IO uint32_t VTOR; // @8 Vector table offset register
	__IO uint32_t AIRCR; // @12 Application interrupt and reset control register
	__IO uint8_t SCR; // @16 System control register
	 uint8_t RESERVED0[3]; // @17 
	__IO uint32_t CCR; // @20 Configuration and control register
	__IO uint32_t SHPR1; // @24 System handler priority registers
	__IO uint32_t SHPR2; // @28 System handler priority registers
	__IO uint32_t SHPR3; // @32 System handler priority registers
	__IO uint32_t SHCRS; // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR; // @44 Hard fault status register
	 uint8_t RESERVED1[4]; // @48 
	__IO uint32_t MMFAR; // @52 Memory management fault address register
	__IO uint32_t BFAR; // @56 Bus fault address register
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL<<8)-1) << 24, // Implementer code
	SCB_CPUID_VARIANT = ((1UL<<4)-1) << 20, // Variant number
	SCB_CPUID_CONSTANT = ((1UL<<4)-1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO = ((1UL<<12)-1) << 4, // Part number of the processor
	SCB_CPUID_REVISION = ((1UL<<4)-1) << 0, // Revision number		
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24 ; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20 ; }
inline uint32_t scb_cpuid_get_constant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_CONSTANT) >> 16 ; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4 ; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0 ; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET = 1UL<<31, // NMI set-pending bit.
	SCB_ICSR_PENDSVSET = 1UL<<28, // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR = 1UL<<27, // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET = 1UL<<26, // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR = 1UL<<25, // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING = 1UL<<22, // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL<<7)-1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE = 1UL<<11, // Return to base level
	SCB_ICSR_VECTACTIVE = ((1UL<<9)-1) << 0, // Active vector		
};
inline void scb_icsr_set_vectpending(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val<<12) & SCB_ICSR_VECTPENDING); }
inline void scb_icsr_set_vectactive(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val<<0) & SCB_ICSR_VECTACTIVE); }
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12 ; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0 ; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL<<21)-1) << 9, // Vector table base offset field		
};
inline void scb_vtor_set_tbloff(struct SCB_Type* p, uint32_t val) { p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val<<9) & SCB_VTOR_TBLOFF); }
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type* p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 9 ; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT = ((1UL<<16)-1) << 16, // Register key
	SCB_AIRCR_ENDIANESS = 1UL<<15, // ENDIANESS
	SCB_AIRCR_PRIGROUP = ((1UL<<3)-1) << 8, // PRIGROUP
	SCB_AIRCR_SYSRESETREQ = 1UL<<2, // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL<<1, // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET = 1UL<<0, // VECTRESET		
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val<<16) & SCB_AIRCR_VECTKEYSTAT); }
inline void scb_aircr_set_prigroup(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val<<8) & SCB_AIRCR_PRIGROUP); }
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16 ; }
inline uint32_t scb_aircr_get_prigroup(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_PRIGROUP) >> 8 ; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND = 1UL<<4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP = 1UL<<2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL<<1, // SLEEPONEXIT		
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_BP = 1UL<<18, // BP
	SCB_CCR_IC = 1UL<<17, // IC
	SCB_CCR_DC = 1UL<<16, // DC
	SCB_CCR_STKALIGN = 1UL<<9, // STKALIGN
	SCB_CCR_BFHFNMIGN = 1UL<<8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP = 1UL<<4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP = 1UL<<3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND = 1UL<<1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL<<0, // Configures how the processor enters Thread mode		
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL<<8)-1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL<<8)-1) << 8, // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL<<8)-1) << 0, // Priority of system handler 4		
};
inline void scb_shpr1_set_pri_6(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_6) | ((val<<16) & SCB_SHPR1_PRI_6); }
inline void scb_shpr1_set_pri_5(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_5) | ((val<<8) & SCB_SHPR1_PRI_5); }
inline void scb_shpr1_set_pri_4(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_4) | ((val<<0) & SCB_SHPR1_PRI_4); }
inline uint32_t scb_shpr1_get_pri_6(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_6) >> 16 ; }
inline uint32_t scb_shpr1_get_pri_5(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_5) >> 8 ; }
inline uint32_t scb_shpr1_get_pri_4(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_4) >> 0 ; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL<<8)-1) << 24, // Priority of system handler 11		
};
inline void scb_shpr2_set_pri_11(struct SCB_Type* p, uint32_t val) { p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val<<24) & SCB_SHPR2_PRI_11); }
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type* p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24 ; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL<<8)-1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL<<8)-1) << 16, // Priority of system handler 14		
};
inline void scb_shpr3_set_pri_15(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val<<24) & SCB_SHPR3_PRI_15); }
inline void scb_shpr3_set_pri_14(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val<<16) & SCB_SHPR3_PRI_14); }
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24 ; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16 ; }

// SCB->SHCRS System handler control and state register
enum {
	SCB_SHCRS_USGFAULTENA = 1UL<<18, // Usage fault enable bit
	SCB_SHCRS_BUSFAULTENA = 1UL<<17, // Bus fault enable bit
	SCB_SHCRS_MEMFAULTENA = 1UL<<16, // Memory management fault enable bit
	SCB_SHCRS_SVCALLPENDED = 1UL<<15, // SVC call pending bit
	SCB_SHCRS_BUSFAULTPENDED = 1UL<<14, // Bus fault exception pending bit
	SCB_SHCRS_MEMFAULTPENDED = 1UL<<13, // Memory management fault exception pending bit
	SCB_SHCRS_USGFAULTPENDED = 1UL<<12, // Usage fault exception pending bit
	SCB_SHCRS_SYSTICKACT = 1UL<<11, // SysTick exception active bit
	SCB_SHCRS_PENDSVACT = 1UL<<10, // PendSV exception active bit
	SCB_SHCRS_MONITORACT = 1UL<<8, // Debug monitor active bit
	SCB_SHCRS_SVCALLACT = 1UL<<7, // SVC call active bit
	SCB_SHCRS_USGFAULTACT = 1UL<<3, // Usage fault exception active bit
	SCB_SHCRS_BUSFAULTACT = 1UL<<1, // Bus fault exception active bit
	SCB_SHCRS_MEMFAULTACT = 1UL<<0, // Memory management fault exception active bit		
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 1UL<<25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 1UL<<24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 1UL<<19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 1UL<<18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 1UL<<17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 1UL<<16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 1UL<<15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 1UL<<13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 1UL<<12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 1UL<<11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL<<10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 1UL<<9, // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 1UL<<8, // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 1UL<<7, // MMARVALID
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 1UL<<5, // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 1UL<<4, // MSTKERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 1UL<<3, // MUNSTKERR
	SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL = 1UL<<1, // DACCVIOL
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 1UL<<0, // IACCVIOL		
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL<<31, // Reserved for Debug use
	SCB_HFSR_FORCED = 1UL<<30, // Forced hard fault
	SCB_HFSR_VECTTBL = 1UL<<1, // Vector table hard fault		
};

/* System control block ACTLR */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISITMATBFLUSH = 1UL<<12, // DISITMATBFLUSH
	SCB_ACTRL_ACTRL_DISRAMODE = 1UL<<11, // DISRAMODE
	SCB_ACTRL_ACTRL_FPEXCODIS = 1UL<<10, // FPEXCODIS
	SCB_ACTRL_ACTRL_DISFOLD = 1UL<<2, // DISFOLD		
};

/* SDMMC1 */
struct SDMMC1_Type {
	__IO uint8_t POWER; // @0 SDMMC power control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint32_t CLKCR; // @4 The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
	__IO uint32_t ARGR; // @8 The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
	__IO uint32_t CMDR; // @12 The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
	__I uint8_t RESPCMDR; // @16 SDMMC command response register
	 uint8_t RESERVED1[3]; // @17 
	__I uint32_t RESP1R; // @20 The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	__I uint32_t RESP2R; // @24 The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	__I uint32_t RESP3R; // @28 The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	__I uint32_t RESP4R; // @32 The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
	__IO uint32_t DTIMER; // @36 The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
	__IO uint32_t DLENR; // @40 The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
	__IO uint16_t DCTRL; // @44 The SDMMC_DCTRL register control the data path state machine (DPSM).
	 uint8_t RESERVED2[2]; // @46 
	__I uint32_t DCNTR; // @48 The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
	__I uint32_t STAR; // @52 The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
	__IO uint32_t ICR; // @56 The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
	__IO uint32_t MASKR; // @60 The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
	__IO uint32_t ACKTIMER; // @64 The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
	 uint8_t RESERVED3[12]; // @68 
	__IO uint8_t IDMACTRLR; // @80 The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
	 uint8_t RESERVED4[3]; // @81 
	__IO uint16_t IDMABSIZER; // @84 The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
	 uint8_t RESERVED5[2]; // @86 
	__IO uint32_t IDMABASE0R; // @88 The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
	__IO uint32_t IDMABASE1R; // @92 The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
	 uint8_t RESERVED6[32]; // @96 
	__IO uint32_t FIFOR; // @128 The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
};

// SDMMC1->POWER SDMMC power control register
enum {
	SDMMC1_POWER_DIRPOL = 1UL<<4, // Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
	SDMMC1_POWER_VSWITCHEN = 1UL<<3, // Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
	SDMMC1_POWER_VSWITCH = 1UL<<2, // Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
	SDMMC1_POWER_PWRCTRL = ((1UL<<2)-1) << 0, // SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.		
};
inline void sdmmc1_power_set_pwrctrl(struct SDMMC1_Type* p, uint32_t val) { p->POWER = (p->POWER & ~SDMMC1_POWER_PWRCTRL) | ((val<<0) & SDMMC1_POWER_PWRCTRL); }
inline uint32_t sdmmc1_power_get_pwrctrl(struct SDMMC1_Type* p) { return (p->POWER & SDMMC1_POWER_PWRCTRL) >> 0 ; }

// SDMMC1->CLKCR The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
enum {
	SDMMC1_CLKCR_SELCLKRX = ((1UL<<2)-1) << 20, // Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
	SDMMC1_CLKCR_BUSSPEED = 1UL<<19, // Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
	SDMMC1_CLKCR_DDR = 1UL<<18, // Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
	SDMMC1_CLKCR_HWFC_EN = 1UL<<17, // Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
	SDMMC1_CLKCR_NEGEDGE = 1UL<<16, // SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
	SDMMC1_CLKCR_WIDBUS = ((1UL<<2)-1) << 14, // Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
	SDMMC1_CLKCR_PWRSAV = 1UL<<12, // Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
	SDMMC1_CLKCR_CLKDIV = ((1UL<<10)-1) << 0, // Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..		
};
inline void sdmmc1_clkcr_set_selclkrx(struct SDMMC1_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC1_CLKCR_SELCLKRX) | ((val<<20) & SDMMC1_CLKCR_SELCLKRX); }
inline void sdmmc1_clkcr_set_widbus(struct SDMMC1_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC1_CLKCR_WIDBUS) | ((val<<14) & SDMMC1_CLKCR_WIDBUS); }
inline void sdmmc1_clkcr_set_clkdiv(struct SDMMC1_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC1_CLKCR_CLKDIV) | ((val<<0) & SDMMC1_CLKCR_CLKDIV); }
inline uint32_t sdmmc1_clkcr_get_selclkrx(struct SDMMC1_Type* p) { return (p->CLKCR & SDMMC1_CLKCR_SELCLKRX) >> 20 ; }
inline uint32_t sdmmc1_clkcr_get_widbus(struct SDMMC1_Type* p) { return (p->CLKCR & SDMMC1_CLKCR_WIDBUS) >> 14 ; }
inline uint32_t sdmmc1_clkcr_get_clkdiv(struct SDMMC1_Type* p) { return (p->CLKCR & SDMMC1_CLKCR_CLKDIV) >> 0 ; }

// SDMMC1->CMDR The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
enum {
	SDMMC1_CMDR_CMDSUSPEND = 1UL<<16, // The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
	SDMMC1_CMDR_BOOTEN = 1UL<<15, // Enable boot mode procedure.
	SDMMC1_CMDR_BOOTMODE = 1UL<<14, // Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
	SDMMC1_CMDR_DTHOLD = 1UL<<13, // Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
	SDMMC1_CMDR_CPSMEN = 1UL<<12, // Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
	SDMMC1_CMDR_WAITPEND = 1UL<<11, // CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
	SDMMC1_CMDR_WAITINT = 1UL<<10, // CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
	SDMMC1_CMDR_WAITRESP = ((1UL<<2)-1) << 8, // Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
	SDMMC1_CMDR_CMDSTOP = 1UL<<7, // The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
	SDMMC1_CMDR_CMDTRANS = 1UL<<6, // The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
	SDMMC1_CMDR_CMDINDEX = ((1UL<<6)-1) << 0, // Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.		
};
inline void sdmmc1_cmdr_set_waitresp(struct SDMMC1_Type* p, uint32_t val) { p->CMDR = (p->CMDR & ~SDMMC1_CMDR_WAITRESP) | ((val<<8) & SDMMC1_CMDR_WAITRESP); }
inline void sdmmc1_cmdr_set_cmdindex(struct SDMMC1_Type* p, uint32_t val) { p->CMDR = (p->CMDR & ~SDMMC1_CMDR_CMDINDEX) | ((val<<0) & SDMMC1_CMDR_CMDINDEX); }
inline uint32_t sdmmc1_cmdr_get_waitresp(struct SDMMC1_Type* p) { return (p->CMDR & SDMMC1_CMDR_WAITRESP) >> 8 ; }
inline uint32_t sdmmc1_cmdr_get_cmdindex(struct SDMMC1_Type* p) { return (p->CMDR & SDMMC1_CMDR_CMDINDEX) >> 0 ; }

// SDMMC1->RESPCMDR SDMMC command response register
enum {
	SDMMC1_RESPCMDR_RESPCMD = ((1UL<<6)-1) << 0, // Response command index		
};
inline uint32_t sdmmc1_respcmdr_get_respcmd(struct SDMMC1_Type* p) { return (p->RESPCMDR & SDMMC1_RESPCMDR_RESPCMD) >> 0 ; }

// SDMMC1->DLENR The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
enum {
	SDMMC1_DLENR_DATALENGTH = ((1UL<<25)-1) << 0, // Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.		
};
inline void sdmmc1_dlenr_set_datalength(struct SDMMC1_Type* p, uint32_t val) { p->DLENR = (p->DLENR & ~SDMMC1_DLENR_DATALENGTH) | ((val<<0) & SDMMC1_DLENR_DATALENGTH); }
inline uint32_t sdmmc1_dlenr_get_datalength(struct SDMMC1_Type* p) { return (p->DLENR & SDMMC1_DLENR_DATALENGTH) >> 0 ; }

// SDMMC1->DCTRL The SDMMC_DCTRL register control the data path state machine (DPSM).
enum {
	SDMMC1_DCTRL_FIFORST = 1UL<<13, // FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
	SDMMC1_DCTRL_BOOTACKEN = 1UL<<12, // Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
	SDMMC1_DCTRL_SDIOEN = 1UL<<11, // SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
	SDMMC1_DCTRL_RWMOD = 1UL<<10, // Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
	SDMMC1_DCTRL_RWSTOP = 1UL<<9, // Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
	SDMMC1_DCTRL_RWSTART = 1UL<<8, // Read wait start. If this bit is set, read wait operation starts.
	SDMMC1_DCTRL_DBLOCKSIZE = ((1UL<<4)-1) << 4, // Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
	SDMMC1_DCTRL_DTMODE = ((1UL<<2)-1) << 2, // Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
	SDMMC1_DCTRL_DTDIR = 1UL<<1, // Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
	SDMMC1_DCTRL_DTEN = 1UL<<0, // Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.		
};
inline void sdmmc1_dctrl_set_dblocksize(struct SDMMC1_Type* p, uint32_t val) { p->DCTRL = (p->DCTRL & ~SDMMC1_DCTRL_DBLOCKSIZE) | ((val<<4) & SDMMC1_DCTRL_DBLOCKSIZE); }
inline void sdmmc1_dctrl_set_dtmode(struct SDMMC1_Type* p, uint32_t val) { p->DCTRL = (p->DCTRL & ~SDMMC1_DCTRL_DTMODE) | ((val<<2) & SDMMC1_DCTRL_DTMODE); }
inline uint32_t sdmmc1_dctrl_get_dblocksize(struct SDMMC1_Type* p) { return (p->DCTRL & SDMMC1_DCTRL_DBLOCKSIZE) >> 4 ; }
inline uint32_t sdmmc1_dctrl_get_dtmode(struct SDMMC1_Type* p) { return (p->DCTRL & SDMMC1_DCTRL_DTMODE) >> 2 ; }

// SDMMC1->DCNTR The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
enum {
	SDMMC1_DCNTR_DATACOUNT = ((1UL<<25)-1) << 0, // Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.		
};
inline uint32_t sdmmc1_dcntr_get_datacount(struct SDMMC1_Type* p) { return (p->DCNTR & SDMMC1_DCNTR_DATACOUNT) >> 0 ; }

// SDMMC1->STAR The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
enum {
	SDMMC1_STAR_IDMABTC = 1UL<<28, // IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_IDMATE = 1UL<<27, // IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_CKSTOP = 1UL<<26, // SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_VSWEND = 1UL<<25, // Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_ACKTIMEOUT = 1UL<<24, // Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_ACKFAIL = 1UL<<23, // Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_SDIOIT = 1UL<<22, // SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_BUSYD0END = 1UL<<21, // end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_BUSYD0 = 1UL<<20, // Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
	SDMMC1_STAR_RXFIFOE = 1UL<<19, // Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
	SDMMC1_STAR_TXFIFOE = 1UL<<18, // Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
	SDMMC1_STAR_RXFIFOF = 1UL<<17, // Receive FIFO full This bit is cleared when one FIFO location becomes empty.
	SDMMC1_STAR_TXFIFOF = 1UL<<16, // Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
	SDMMC1_STAR_RXFIFOHF = 1UL<<15, // Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
	SDMMC1_STAR_TXFIFOHE = 1UL<<14, // Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
	SDMMC1_STAR_CPSMACT = 1UL<<13, // Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
	SDMMC1_STAR_DPSMACT = 1UL<<12, // Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
	SDMMC1_STAR_DABORT = 1UL<<11, // Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_DBCKEND = 1UL<<10, // Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_DHOLD = 1UL<<9, // Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_DATAEND = 1UL<<8, // Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_CMDSENT = 1UL<<7, // Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_CMDREND = 1UL<<6, // Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_RXOVERR = 1UL<<5, // Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_TXUNDERR = 1UL<<4, // Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_DTIMEOUT = 1UL<<3, // Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_CTIMEOUT = 1UL<<2, // Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
	SDMMC1_STAR_DCRCFAIL = 1UL<<1, // Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
	SDMMC1_STAR_CCRCFAIL = 1UL<<0, // Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.		
};

// SDMMC1->ICR The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
enum {
	SDMMC1_ICR_IDMABTCC = 1UL<<28, // IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
	SDMMC1_ICR_IDMATEC = 1UL<<27, // IDMA transfer error clear bit Set by software to clear the IDMATE flag.
	SDMMC1_ICR_CKSTOPC = 1UL<<26, // CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
	SDMMC1_ICR_VSWENDC = 1UL<<25, // VSWEND flag clear bit Set by software to clear the VSWEND flag.
	SDMMC1_ICR_ACKTIMEOUTC = 1UL<<24, // ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
	SDMMC1_ICR_ACKFAILC = 1UL<<23, // ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
	SDMMC1_ICR_SDIOITC = 1UL<<22, // SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
	SDMMC1_ICR_BUSYD0ENDC = 1UL<<21, // BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
	SDMMC1_ICR_DABORTC = 1UL<<11, // DABORT flag clear bit Set by software to clear the DABORT flag.
	SDMMC1_ICR_DBCKENDC = 1UL<<10, // DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
	SDMMC1_ICR_DHOLDC = 1UL<<9, // DHOLD flag clear bit Set by software to clear the DHOLD flag.
	SDMMC1_ICR_DATAENDC = 1UL<<8, // DATAEND flag clear bit Set by software to clear the DATAEND flag.
	SDMMC1_ICR_CMDSENTC = 1UL<<7, // CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
	SDMMC1_ICR_CMDRENDC = 1UL<<6, // CMDREND flag clear bit Set by software to clear the CMDREND flag.
	SDMMC1_ICR_RXOVERRC = 1UL<<5, // RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
	SDMMC1_ICR_TXUNDERRC = 1UL<<4, // TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
	SDMMC1_ICR_DTIMEOUTC = 1UL<<3, // DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
	SDMMC1_ICR_CTIMEOUTC = 1UL<<2, // CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
	SDMMC1_ICR_DCRCFAILC = 1UL<<1, // DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
	SDMMC1_ICR_CCRCFAILC = 1UL<<0, // CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.		
};

// SDMMC1->MASKR The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
enum {
	SDMMC1_MASKR_IDMABTCIE = 1UL<<28, // IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
	SDMMC1_MASKR_CKSTOPIE = 1UL<<26, // Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
	SDMMC1_MASKR_VSWENDIE = 1UL<<25, // Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
	SDMMC1_MASKR_ACKTIMEOUTIE = 1UL<<24, // Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
	SDMMC1_MASKR_ACKFAILIE = 1UL<<23, // Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
	SDMMC1_MASKR_SDIOITIE = 1UL<<22, // SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
	SDMMC1_MASKR_BUSYD0ENDIE = 1UL<<21, // BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
	SDMMC1_MASKR_TXFIFOEIE = 1UL<<18, // Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
	SDMMC1_MASKR_RXFIFOFIE = 1UL<<17, // Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
	SDMMC1_MASKR_RXFIFOHFIE = 1UL<<15, // Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
	SDMMC1_MASKR_TXFIFOHEIE = 1UL<<14, // Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
	SDMMC1_MASKR_DABORTIE = 1UL<<11, // Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
	SDMMC1_MASKR_DBCKENDIE = 1UL<<10, // Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
	SDMMC1_MASKR_DHOLDIE = 1UL<<9, // Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
	SDMMC1_MASKR_DATAENDIE = 1UL<<8, // Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
	SDMMC1_MASKR_CMDSENTIE = 1UL<<7, // Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
	SDMMC1_MASKR_CMDRENDIE = 1UL<<6, // Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
	SDMMC1_MASKR_RXOVERRIE = 1UL<<5, // Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
	SDMMC1_MASKR_TXUNDERRIE = 1UL<<4, // Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
	SDMMC1_MASKR_DTIMEOUTIE = 1UL<<3, // Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
	SDMMC1_MASKR_CTIMEOUTIE = 1UL<<2, // Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
	SDMMC1_MASKR_DCRCFAILIE = 1UL<<1, // Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
	SDMMC1_MASKR_CCRCFAILIE = 1UL<<0, // Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.		
};

// SDMMC1->ACKTIMER The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
enum {
	SDMMC1_ACKTIMER_ACKTIME = ((1UL<<25)-1) << 0, // Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.		
};
inline void sdmmc1_acktimer_set_acktime(struct SDMMC1_Type* p, uint32_t val) { p->ACKTIMER = (p->ACKTIMER & ~SDMMC1_ACKTIMER_ACKTIME) | ((val<<0) & SDMMC1_ACKTIMER_ACKTIME); }
inline uint32_t sdmmc1_acktimer_get_acktime(struct SDMMC1_Type* p) { return (p->ACKTIMER & SDMMC1_ACKTIMER_ACKTIME) >> 0 ; }

// SDMMC1->IDMACTRLR The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
enum {
	SDMMC1_IDMACTRLR_IDMABACT = 1UL<<2, // Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
	SDMMC1_IDMACTRLR_IDMABMODE = 1UL<<1, // Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
	SDMMC1_IDMACTRLR_IDMAEN = 1UL<<0, // IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).		
};

// SDMMC1->IDMABSIZER The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
enum {
	SDMMC1_IDMABSIZER_IDMABNDT = ((1UL<<8)-1) << 5, // Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).		
};
inline void sdmmc1_idmabsizer_set_idmabndt(struct SDMMC1_Type* p, uint32_t val) { p->IDMABSIZER = (p->IDMABSIZER & ~SDMMC1_IDMABSIZER_IDMABNDT) | ((val<<5) & SDMMC1_IDMABSIZER_IDMABNDT); }
inline uint32_t sdmmc1_idmabsizer_get_idmabndt(struct SDMMC1_Type* p) { return (p->IDMABSIZER & SDMMC1_IDMABSIZER_IDMABNDT) >> 5 ; }


/* Receiver Interface */
struct SPDIFRX_Type {
	__IO uint32_t CR; // @0 Control register
	__IO uint8_t IMR; // @4 Interrupt mask register
	 uint8_t RESERVED0[3]; // @5 
	__I uint32_t SR; // @8 Status register
	__O uint8_t IFCR; // @12 Interrupt Flag Clear register
	 uint8_t RESERVED1[3]; // @13 
	union {  // @16
		__I uint32_t DR_00; // Data input register
		__I uint32_t DR_10; // Data input register
		__I uint32_t DR_01; // Data input register
	};
	__I uint32_t CSR; // @20 Channel Status register
	__I uint32_t DIR; // @24 Debug Information register
	 uint8_t RESERVED2[984]; // @28 
	__I uint8_t VERR; // @1012 SPDIFRX version register
	 uint8_t RESERVED3[3]; // @1013 
	__I uint32_t IDR; // @1016 SPDIFRX identification register
	__I uint32_t SIDR; // @1020 SPDIFRX size identification register
};

// SPDIFRX->CR Control register
enum {
	SPDIFRX_CR_CKSBKPEN = 1UL<<21, // Backup Symbol Clock Enable
	SPDIFRX_CR_CKSEN = 1UL<<20, // Symbol Clock Enable
	SPDIFRX_CR_INSEL = ((1UL<<3)-1) << 16, // input selection
	SPDIFRX_CR_WFA = 1UL<<14, // Wait For Activity
	SPDIFRX_CR_NBTR = ((1UL<<2)-1) << 12, // Maximum allowed re-tries during synchronization phase
	SPDIFRX_CR_CHSEL = 1UL<<11, // Channel Selection
	SPDIFRX_CR_CBDMAEN = 1UL<<10, // Control Buffer DMA ENable for control flow
	SPDIFRX_CR_PTMSK = 1UL<<9, // Mask of Preamble Type bits
	SPDIFRX_CR_CUMSK = 1UL<<8, // Mask of channel status and user bits
	SPDIFRX_CR_VMSK = 1UL<<7, // Mask of Validity bit
	SPDIFRX_CR_PMSK = 1UL<<6, // Mask Parity error bit
	SPDIFRX_CR_DRFMT = ((1UL<<2)-1) << 4, // RX Data format
	SPDIFRX_CR_RXSTEO = 1UL<<3, // STerEO Mode
	SPDIFRX_CR_RXDMAEN = 1UL<<2, // Receiver DMA ENable for data flow
	SPDIFRX_CR_SPDIFRXEN = ((1UL<<2)-1) << 0, // Peripheral Block Enable		
};
inline void spdifrx_cr_set_insel(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_INSEL) | ((val<<16) & SPDIFRX_CR_INSEL); }
inline void spdifrx_cr_set_nbtr(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_NBTR) | ((val<<12) & SPDIFRX_CR_NBTR); }
inline void spdifrx_cr_set_drfmt(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_DRFMT) | ((val<<4) & SPDIFRX_CR_DRFMT); }
inline void spdifrx_cr_set_spdifrxen(struct SPDIFRX_Type* p, uint32_t val) { p->CR = (p->CR & ~SPDIFRX_CR_SPDIFRXEN) | ((val<<0) & SPDIFRX_CR_SPDIFRXEN); }
inline uint32_t spdifrx_cr_get_insel(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_INSEL) >> 16 ; }
inline uint32_t spdifrx_cr_get_nbtr(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_NBTR) >> 12 ; }
inline uint32_t spdifrx_cr_get_drfmt(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_DRFMT) >> 4 ; }
inline uint32_t spdifrx_cr_get_spdifrxen(struct SPDIFRX_Type* p) { return (p->CR & SPDIFRX_CR_SPDIFRXEN) >> 0 ; }

// SPDIFRX->IMR Interrupt mask register
enum {
	SPDIFRX_IMR_IFEIE = 1UL<<6, // Serial Interface Error Interrupt Enable
	SPDIFRX_IMR_SYNCDIE = 1UL<<5, // Synchronization Done
	SPDIFRX_IMR_SBLKIE = 1UL<<4, // Synchronization Block Detected Interrupt Enable
	SPDIFRX_IMR_OVRIE = 1UL<<3, // Overrun error Interrupt Enable
	SPDIFRX_IMR_PERRIE = 1UL<<2, // Parity error interrupt enable
	SPDIFRX_IMR_CSRNEIE = 1UL<<1, // Control Buffer Ready Interrupt Enable
	SPDIFRX_IMR_RXNEIE = 1UL<<0, // RXNE interrupt enable		
};

// SPDIFRX->SR Status register
enum {
	SPDIFRX_SR_WIDTH5 = ((1UL<<15)-1) << 16, // Duration of 5 symbols counted with SPDIF_CLK
	SPDIFRX_SR_TERR = 1UL<<8, // Time-out error
	SPDIFRX_SR_SERR = 1UL<<7, // Synchronization error
	SPDIFRX_SR_FERR = 1UL<<6, // Framing error
	SPDIFRX_SR_SYNCD = 1UL<<5, // Synchronization Done
	SPDIFRX_SR_SBD = 1UL<<4, // Synchronization Block Detected
	SPDIFRX_SR_OVR = 1UL<<3, // Overrun error
	SPDIFRX_SR_PERR = 1UL<<2, // Parity error
	SPDIFRX_SR_CSRNE = 1UL<<1, // Control Buffer register is not empty
	SPDIFRX_SR_RXNE = 1UL<<0, // Read data register not empty		
};
inline uint32_t spdifrx_sr_get_width5(struct SPDIFRX_Type* p) { return (p->SR & SPDIFRX_SR_WIDTH5) >> 16 ; }

// SPDIFRX->IFCR Interrupt Flag Clear register
enum {
	SPDIFRX_IFCR_SYNCDCF = 1UL<<5, // Clears the Synchronization Done flag
	SPDIFRX_IFCR_SBDCF = 1UL<<4, // Clears the Synchronization Block Detected flag
	SPDIFRX_IFCR_OVRCF = 1UL<<3, // Clears the Overrun error flag
	SPDIFRX_IFCR_PERRCF = 1UL<<2, // Clears the Parity error flag		
};

// SPDIFRX->DR_00 Data input register
enum {
	SPDIFRX_DR_00_PT = ((1UL<<2)-1) << 28, // Preamble Type
	SPDIFRX_DR_00_C = 1UL<<27, // Channel Status bit
	SPDIFRX_DR_00_U = 1UL<<26, // User bit
	SPDIFRX_DR_00_V = 1UL<<25, // Validity bit
	SPDIFRX_DR_00_PE = 1UL<<24, // Parity Error bit
	SPDIFRX_DR_00_DR = ((1UL<<24)-1) << 0, // Parity Error bit		
};
inline uint32_t spdifrx_dr_00_get_pt(struct SPDIFRX_Type* p) { return (p->DR_00 & SPDIFRX_DR_00_PT) >> 28 ; }
inline uint32_t spdifrx_dr_00_get_dr(struct SPDIFRX_Type* p) { return (p->DR_00 & SPDIFRX_DR_00_DR) >> 0 ; }

// SPDIFRX->CSR Channel Status register
enum {
	SPDIFRX_CSR_SOB = 1UL<<24, // Start Of Block
	SPDIFRX_CSR_CS = ((1UL<<8)-1) << 16, // Channel A status information
	SPDIFRX_CSR_USR = ((1UL<<16)-1) << 0, // User data information		
};
inline uint32_t spdifrx_csr_get_cs(struct SPDIFRX_Type* p) { return (p->CSR & SPDIFRX_CSR_CS) >> 16 ; }
inline uint32_t spdifrx_csr_get_usr(struct SPDIFRX_Type* p) { return (p->CSR & SPDIFRX_CSR_USR) >> 0 ; }

// SPDIFRX->DIR Debug Information register
enum {
	SPDIFRX_DIR_TLO = ((1UL<<13)-1) << 16, // Threshold LOW
	SPDIFRX_DIR_THI = ((1UL<<13)-1) << 0, // Threshold HIGH		
};
inline uint32_t spdifrx_dir_get_tlo(struct SPDIFRX_Type* p) { return (p->DIR & SPDIFRX_DIR_TLO) >> 16 ; }
inline uint32_t spdifrx_dir_get_thi(struct SPDIFRX_Type* p) { return (p->DIR & SPDIFRX_DIR_THI) >> 0 ; }

// SPDIFRX->VERR SPDIFRX version register
enum {
	SPDIFRX_VERR_MAJREV = ((1UL<<4)-1) << 4, // Major revision
	SPDIFRX_VERR_MINREV = ((1UL<<4)-1) << 0, // Minor revision		
};
inline uint32_t spdifrx_verr_get_majrev(struct SPDIFRX_Type* p) { return (p->VERR & SPDIFRX_VERR_MAJREV) >> 4 ; }
inline uint32_t spdifrx_verr_get_minrev(struct SPDIFRX_Type* p) { return (p->VERR & SPDIFRX_VERR_MINREV) >> 0 ; }

/* Serial peripheral interface */
struct SPI1_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	__IO uint32_t CFG1; // @8 configuration register 1
	__IO uint32_t CFG2; // @12 configuration register 2
	__IO uint16_t IER; // @16 Interrupt Enable Register
	 uint8_t RESERVED0[2]; // @18 
	__I uint32_t SR; // @20 Status Register
	__O uint16_t IFCR; // @24 Interrupt/Status Flags Clear Register
	 uint8_t RESERVED1[6]; // @26 
	__O uint32_t TXDR; // @32 Transmit Data Register
	 uint8_t RESERVED2[12]; // @36 
	__I uint32_t RXDR; // @48 Receive Data Register
	 uint8_t RESERVED3[12]; // @52 
	__IO uint32_t CRCPOLY; // @64 Polynomial Register
	__IO uint32_t TXCRC; // @68 Transmitter CRC Register
	__IO uint32_t RXCRC; // @72 Receiver CRC Register
	__IO uint32_t UDRDR; // @76 Underrun Data Register
	__IO uint32_t CGFR; // @80 configuration register
};

// SPI1->CR1 control register 1
enum {
	SPI1_CR1_IOLOCK = 1UL<<16, // Locking the AF configuration of associated IOs
	SPI1_CR1_TCRCI = 1UL<<15, // CRC calculation initialization pattern control for transmitter
	SPI1_CR1_RCRCI = 1UL<<14, // CRC calculation initialization pattern control for receiver
	SPI1_CR1_CRC33_17 = 1UL<<13, // 32-bit CRC polynomial configuration
	SPI1_CR1_SSI = 1UL<<12, // Internal SS signal input level
	SPI1_CR1_HDDIR = 1UL<<11, // Rx/Tx direction at Half-duplex mode
	SPI1_CR1_CSUSP = 1UL<<10, // Master SUSPend request
	SPI1_CR1_CSTART = 1UL<<9, // Master transfer start
	SPI1_CR1_MASRX = 1UL<<8, // Master automatic SUSP in Receive mode
	SPI1_CR1_SPE = 1UL<<0, // Serial Peripheral Enable		
};

// SPI1->CR2 control register 2
enum {
	SPI1_CR2_TSER = ((1UL<<16)-1) << 16, // Number of data transfer extension to be reload into TSIZE just when a previous
	SPI1_CR2_TSIZE = ((1UL<<16)-1) << 0, // Number of data at current transfer		
};
inline void spi1_cr2_set_tser(struct SPI1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_TSER) | ((val<<16) & SPI1_CR2_TSER); }
inline void spi1_cr2_set_tsize(struct SPI1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_TSIZE) | ((val<<0) & SPI1_CR2_TSIZE); }
inline uint32_t spi1_cr2_get_tser(struct SPI1_Type* p) { return (p->CR2 & SPI1_CR2_TSER) >> 16 ; }
inline uint32_t spi1_cr2_get_tsize(struct SPI1_Type* p) { return (p->CR2 & SPI1_CR2_TSIZE) >> 0 ; }

// SPI1->CFG1 configuration register 1
enum {
	SPI1_CFG1_MBR = ((1UL<<3)-1) << 28, // Master baud rate
	SPI1_CFG1_CRCEN = 1UL<<22, // Hardware CRC computation enable
	SPI1_CFG1_CRCSIZE = ((1UL<<5)-1) << 16, // Length of CRC frame to be transacted and compared
	SPI1_CFG1_TXDMAEN = 1UL<<15, // Tx DMA stream enable
	SPI1_CFG1_RXDMAEN = 1UL<<14, // Rx DMA stream enable
	SPI1_CFG1_UDRDET = ((1UL<<2)-1) << 11, // Detection of underrun condition at slave transmitter
	SPI1_CFG1_UDRCFG = ((1UL<<2)-1) << 9, // Behavior of slave transmitter at underrun condition
	SPI1_CFG1_FTHVL = ((1UL<<4)-1) << 5, // threshold level
	SPI1_CFG1_DSIZE = ((1UL<<5)-1) << 0, // Number of bits in at single SPI data frame		
};
inline void spi1_cfg1_set_mbr(struct SPI1_Type* p, uint32_t val) { p->CFG1 = (p->CFG1 & ~SPI1_CFG1_MBR) | ((val<<28) & SPI1_CFG1_MBR); }
inline void spi1_cfg1_set_crcsize(struct SPI1_Type* p, uint32_t val) { p->CFG1 = (p->CFG1 & ~SPI1_CFG1_CRCSIZE) | ((val<<16) & SPI1_CFG1_CRCSIZE); }
inline void spi1_cfg1_set_udrdet(struct SPI1_Type* p, uint32_t val) { p->CFG1 = (p->CFG1 & ~SPI1_CFG1_UDRDET) | ((val<<11) & SPI1_CFG1_UDRDET); }
inline void spi1_cfg1_set_udrcfg(struct SPI1_Type* p, uint32_t val) { p->CFG1 = (p->CFG1 & ~SPI1_CFG1_UDRCFG) | ((val<<9) & SPI1_CFG1_UDRCFG); }
inline void spi1_cfg1_set_fthvl(struct SPI1_Type* p, uint32_t val) { p->CFG1 = (p->CFG1 & ~SPI1_CFG1_FTHVL) | ((val<<5) & SPI1_CFG1_FTHVL); }
inline void spi1_cfg1_set_dsize(struct SPI1_Type* p, uint32_t val) { p->CFG1 = (p->CFG1 & ~SPI1_CFG1_DSIZE) | ((val<<0) & SPI1_CFG1_DSIZE); }
inline uint32_t spi1_cfg1_get_mbr(struct SPI1_Type* p) { return (p->CFG1 & SPI1_CFG1_MBR) >> 28 ; }
inline uint32_t spi1_cfg1_get_crcsize(struct SPI1_Type* p) { return (p->CFG1 & SPI1_CFG1_CRCSIZE) >> 16 ; }
inline uint32_t spi1_cfg1_get_udrdet(struct SPI1_Type* p) { return (p->CFG1 & SPI1_CFG1_UDRDET) >> 11 ; }
inline uint32_t spi1_cfg1_get_udrcfg(struct SPI1_Type* p) { return (p->CFG1 & SPI1_CFG1_UDRCFG) >> 9 ; }
inline uint32_t spi1_cfg1_get_fthvl(struct SPI1_Type* p) { return (p->CFG1 & SPI1_CFG1_FTHVL) >> 5 ; }
inline uint32_t spi1_cfg1_get_dsize(struct SPI1_Type* p) { return (p->CFG1 & SPI1_CFG1_DSIZE) >> 0 ; }

// SPI1->CFG2 configuration register 2
enum {
	SPI1_CFG2_AFCNTR = 1UL<<31, // Alternate function GPIOs control
	SPI1_CFG2_SSOM = 1UL<<30, // SS output management in master mode
	SPI1_CFG2_SSOE = 1UL<<29, // SS output enable
	SPI1_CFG2_SSIOP = 1UL<<28, // SS input/output polarity
	SPI1_CFG2_SSM = 1UL<<26, // Software management of SS signal input
	SPI1_CFG2_CPOL = 1UL<<25, // Clock polarity
	SPI1_CFG2_CPHA = 1UL<<24, // Clock phase
	SPI1_CFG2_LSBFRST = 1UL<<23, // Data frame format
	SPI1_CFG2_MASTER = 1UL<<22, // SPI Master
	SPI1_CFG2_SP = ((1UL<<3)-1) << 19, // Serial Protocol
	SPI1_CFG2_COMM = ((1UL<<2)-1) << 17, // SPI Communication Mode
	SPI1_CFG2_IOSWP = 1UL<<15, // Swap functionality of MISO and MOSI pins
	SPI1_CFG2_MIDI = ((1UL<<4)-1) << 4, // Master Inter-Data Idleness
	SPI1_CFG2_MSSI = ((1UL<<4)-1) << 0, // Master SS Idleness		
};
inline void spi1_cfg2_set_sp(struct SPI1_Type* p, uint32_t val) { p->CFG2 = (p->CFG2 & ~SPI1_CFG2_SP) | ((val<<19) & SPI1_CFG2_SP); }
inline void spi1_cfg2_set_comm(struct SPI1_Type* p, uint32_t val) { p->CFG2 = (p->CFG2 & ~SPI1_CFG2_COMM) | ((val<<17) & SPI1_CFG2_COMM); }
inline void spi1_cfg2_set_midi(struct SPI1_Type* p, uint32_t val) { p->CFG2 = (p->CFG2 & ~SPI1_CFG2_MIDI) | ((val<<4) & SPI1_CFG2_MIDI); }
inline void spi1_cfg2_set_mssi(struct SPI1_Type* p, uint32_t val) { p->CFG2 = (p->CFG2 & ~SPI1_CFG2_MSSI) | ((val<<0) & SPI1_CFG2_MSSI); }
inline uint32_t spi1_cfg2_get_sp(struct SPI1_Type* p) { return (p->CFG2 & SPI1_CFG2_SP) >> 19 ; }
inline uint32_t spi1_cfg2_get_comm(struct SPI1_Type* p) { return (p->CFG2 & SPI1_CFG2_COMM) >> 17 ; }
inline uint32_t spi1_cfg2_get_midi(struct SPI1_Type* p) { return (p->CFG2 & SPI1_CFG2_MIDI) >> 4 ; }
inline uint32_t spi1_cfg2_get_mssi(struct SPI1_Type* p) { return (p->CFG2 & SPI1_CFG2_MSSI) >> 0 ; }

// SPI1->IER Interrupt Enable Register
enum {
	SPI1_IER_TSERFIE = 1UL<<10, // Additional number of transactions reload interrupt enable
	SPI1_IER_MODFIE = 1UL<<9, // Mode Fault interrupt enable
	SPI1_IER_TIFREIE = 1UL<<8, // TIFRE interrupt enable
	SPI1_IER_CRCEIE = 1UL<<7, // CRC Interrupt enable
	SPI1_IER_OVRIE = 1UL<<6, // OVR interrupt enable
	SPI1_IER_UDRIE = 1UL<<5, // UDR interrupt enable
	SPI1_IER_TXTFIE = 1UL<<4, // TXTFIE interrupt enable
	SPI1_IER_EOTIE = 1UL<<3, // EOT, SUSP and TXC interrupt enable
	SPI1_IER_DPXPIE = 1UL<<2, // DXP interrupt enabled
	SPI1_IER_TXPIE = 1UL<<1, // TXP interrupt enable
	SPI1_IER_RXPIE = 1UL<<0, // RXP Interrupt Enable		
};

// SPI1->SR Status Register
enum {
	SPI1_SR_CTSIZE = ((1UL<<16)-1) << 16, // Number of data frames remaining in current TSIZE session
	SPI1_SR_RXWNE = 1UL<<15, // RxFIFO Word Not Empty
	SPI1_SR_RXPLVL = ((1UL<<2)-1) << 13, // RxFIFO Packing LeVeL
	SPI1_SR_TXC = 1UL<<12, // TxFIFO transmission complete
	SPI1_SR_SUSP = 1UL<<11, // SUSPend
	SPI1_SR_TSERF = 1UL<<10, // Additional number of SPI data to be transacted was reload
	SPI1_SR_MODF = 1UL<<9, // Mode Fault
	SPI1_SR_TIFRE = 1UL<<8, // TI frame format error
	SPI1_SR_CRCE = 1UL<<7, // CRC Error
	SPI1_SR_OVR = 1UL<<6, // Overrun
	SPI1_SR_UDR = 1UL<<5, // Underrun at slave transmission mode
	SPI1_SR_TXTF = 1UL<<4, // Transmission Transfer Filled
	SPI1_SR_EOT = 1UL<<3, // End Of Transfer
	SPI1_SR_DXP = 1UL<<2, // Duplex Packet
	SPI1_SR_TXP = 1UL<<1, // Tx-Packet space available
	SPI1_SR_RXP = 1UL<<0, // Rx-Packet available		
};
inline uint32_t spi1_sr_get_ctsize(struct SPI1_Type* p) { return (p->SR & SPI1_SR_CTSIZE) >> 16 ; }
inline uint32_t spi1_sr_get_rxplvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_RXPLVL) >> 13 ; }

// SPI1->IFCR Interrupt/Status Flags Clear Register
enum {
	SPI1_IFCR_SUSPC = 1UL<<11, // SUSPend flag clear
	SPI1_IFCR_TSERFC = 1UL<<10, // TSERFC flag clear
	SPI1_IFCR_MODFC = 1UL<<9, // Mode Fault flag clear
	SPI1_IFCR_TIFREC = 1UL<<8, // TI frame format error flag clear
	SPI1_IFCR_CRCEC = 1UL<<7, // CRC Error flag clear
	SPI1_IFCR_OVRC = 1UL<<6, // Overrun flag clear
	SPI1_IFCR_UDRC = 1UL<<5, // Underrun flag clear
	SPI1_IFCR_TXTFC = 1UL<<4, // Transmission Transfer Filled flag clear
	SPI1_IFCR_EOTC = 1UL<<3, // End Of Transfer flag clear		
};

// SPI1->CGFR configuration register
enum {
	SPI1_CGFR_MCKOE = 1UL<<25, // Master clock output enable
	SPI1_CGFR_ODD = 1UL<<24, // Odd factor for the prescaler
	SPI1_CGFR_I2SDIV = ((1UL<<8)-1) << 16, // I2S linear prescaler
	SPI1_CGFR_DATFMT = 1UL<<14, // Data format
	SPI1_CGFR_WSINV = 1UL<<13, // Fixed channel length in SLAVE
	SPI1_CGFR_FIXCH = 1UL<<12, // Word select inversion
	SPI1_CGFR_CKPOL = 1UL<<11, // Serial audio clock polarity
	SPI1_CGFR_CHLEN = 1UL<<10, // Channel length (number of bits per audio channel)
	SPI1_CGFR_DATLEN = ((1UL<<2)-1) << 8, // Data length to be transferred
	SPI1_CGFR_PCMSYNC = 1UL<<7, // PCM frame synchronization
	SPI1_CGFR_I2SSTD = ((1UL<<2)-1) << 4, // I2S standard selection
	SPI1_CGFR_I2SCFG = ((1UL<<3)-1) << 1, // I2S configuration mode
	SPI1_CGFR_I2SMOD = 1UL<<0, // I2S mode selection		
};
inline void spi1_cgfr_set_i2sdiv(struct SPI1_Type* p, uint32_t val) { p->CGFR = (p->CGFR & ~SPI1_CGFR_I2SDIV) | ((val<<16) & SPI1_CGFR_I2SDIV); }
inline void spi1_cgfr_set_datlen(struct SPI1_Type* p, uint32_t val) { p->CGFR = (p->CGFR & ~SPI1_CGFR_DATLEN) | ((val<<8) & SPI1_CGFR_DATLEN); }
inline void spi1_cgfr_set_i2sstd(struct SPI1_Type* p, uint32_t val) { p->CGFR = (p->CGFR & ~SPI1_CGFR_I2SSTD) | ((val<<4) & SPI1_CGFR_I2SSTD); }
inline void spi1_cgfr_set_i2scfg(struct SPI1_Type* p, uint32_t val) { p->CGFR = (p->CGFR & ~SPI1_CGFR_I2SCFG) | ((val<<1) & SPI1_CGFR_I2SCFG); }
inline uint32_t spi1_cgfr_get_i2sdiv(struct SPI1_Type* p) { return (p->CGFR & SPI1_CGFR_I2SDIV) >> 16 ; }
inline uint32_t spi1_cgfr_get_datlen(struct SPI1_Type* p) { return (p->CGFR & SPI1_CGFR_DATLEN) >> 8 ; }
inline uint32_t spi1_cgfr_get_i2sstd(struct SPI1_Type* p) { return (p->CGFR & SPI1_CGFR_I2SSTD) >> 4 ; }
inline uint32_t spi1_cgfr_get_i2scfg(struct SPI1_Type* p) { return (p->CGFR & SPI1_CGFR_I2SCFG) >> 1 ; }






/* SysTick timer */
struct STK_Type {
	__IO uint32_t CSR; // @0 SysTick control and status register
	__IO uint32_t RVR; // @4 SysTick reload value register
	__IO uint32_t CVR; // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};

// STK->CSR SysTick control and status register
enum {
	STK_CSR_COUNTFLAG = 1UL<<16, // COUNTFLAG
	STK_CSR_CLKSOURCE = 1UL<<2, // Clock source selection
	STK_CSR_TICKINT = 1UL<<1, // SysTick exception request enable
	STK_CSR_ENABLE = 1UL<<0, // Counter enable		
};

// STK->RVR SysTick reload value register
enum {
	STK_RVR_RELOAD = ((1UL<<24)-1) << 0, // RELOAD value		
};
inline void stk_rvr_set_reload(struct STK_Type* p, uint32_t val) { p->RVR = (p->RVR & ~STK_RVR_RELOAD) | ((val<<0) & STK_RVR_RELOAD); }
inline uint32_t stk_rvr_get_reload(struct STK_Type* p) { return (p->RVR & STK_RVR_RELOAD) >> 0 ; }

// STK->CVR SysTick current value register
enum {
	STK_CVR_CURRENT = ((1UL<<24)-1) << 0, // Current counter value		
};
inline void stk_cvr_set_current(struct STK_Type* p, uint32_t val) { p->CVR = (p->CVR & ~STK_CVR_CURRENT) | ((val<<0) & STK_CVR_CURRENT); }
inline uint32_t stk_cvr_get_current(struct STK_Type* p) { return (p->CVR & STK_CVR_CURRENT) >> 0 ; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL<<31, // NOREF flag. Reads as zero
	STK_CALIB_SKEW = 1UL<<30, // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL<<24)-1) << 0, // Calibration value		
};
inline void stk_calib_set_tenms(struct STK_Type* p, uint32_t val) { p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val<<0) & STK_CALIB_TENMS); }
inline uint32_t stk_calib_get_tenms(struct STK_Type* p) { return (p->CALIB & STK_CALIB_TENMS) >> 0 ; }

/* Single Wire Protocol Master Interface */
struct SWPMI_Type {
	__IO uint16_t CR; // @0 SWPMI Configuration/Control register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t BRR; // @4 SWPMI Bitrate register
	 uint8_t RESERVED1[7]; // @5 
	__I uint16_t ISR; // @12 SWPMI Interrupt and Status register
	 uint8_t RESERVED2[2]; // @14 
	__O uint16_t ICR; // @16 SWPMI Interrupt Flag Clear register
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t IER; // @20 SWPMI Interrupt Enable register
	 uint8_t RESERVED4[2]; // @22 
	__I uint8_t RFL; // @24 SWPMI Receive Frame Length register
	 uint8_t RESERVED5[3]; // @25 
	__O uint32_t TDR; // @28 SWPMI Transmit data register
	__I uint32_t RDR; // @32 SWPMI Receive data register
	__IO uint8_t OR; // @36 SWPMI Option register
};

// SWPMI->CR SWPMI Configuration/Control register
enum {
	SWPMI_CR_SWPTEN = 1UL<<11, // Single wire protocol master transceiver enable
	SWPMI_CR_DEACT = 1UL<<10, // Single wire protocol master interface deactivate
	SWPMI_CR_SWPACT = 1UL<<5, // Single wire protocol master interface activate
	SWPMI_CR_LPBK = 1UL<<4, // Loopback mode enable
	SWPMI_CR_TXMODE = 1UL<<3, // Transmission buffering mode
	SWPMI_CR_RXMODE = 1UL<<2, // Reception buffering mode
	SWPMI_CR_TXDMA = 1UL<<1, // Transmission DMA enable
	SWPMI_CR_RXDMA = 1UL<<0, // Reception DMA enable		
};

// SWPMI->ISR SWPMI Interrupt and Status register
enum {
	SWPMI_ISR_RDYF = 1UL<<11, // transceiver ready flag
	SWPMI_ISR_DEACTF = 1UL<<10, // DEACTIVATED flag
	SWPMI_ISR_SUSP = 1UL<<9, // SUSPEND flag
	SWPMI_ISR_SRF = 1UL<<8, // Slave resume flag
	SWPMI_ISR_TCF = 1UL<<7, // Transfer complete flag
	SWPMI_ISR_TXE = 1UL<<6, // Transmit data register empty
	SWPMI_ISR_RXNE = 1UL<<5, // Receive data register not empty
	SWPMI_ISR_TXUNRF = 1UL<<4, // Transmit underrun error flag
	SWPMI_ISR_RXOVRF = 1UL<<3, // Receive overrun error flag
	SWPMI_ISR_RXBERF = 1UL<<2, // Receive CRC error flag
	SWPMI_ISR_TXBEF = 1UL<<1, // Transmit buffer empty flag
	SWPMI_ISR_RXBFF = 1UL<<0, // Receive buffer full flag		
};

// SWPMI->ICR SWPMI Interrupt Flag Clear register
enum {
	SWPMI_ICR_CRDYF = 1UL<<11, // Clear transceiver ready flag
	SWPMI_ICR_CSRF = 1UL<<8, // Clear slave resume flag
	SWPMI_ICR_CTCF = 1UL<<7, // Clear transfer complete flag
	SWPMI_ICR_CTXUNRF = 1UL<<4, // Clear transmit underrun error flag
	SWPMI_ICR_CRXOVRF = 1UL<<3, // Clear receive overrun error flag
	SWPMI_ICR_CRXBERF = 1UL<<2, // Clear receive CRC error flag
	SWPMI_ICR_CTXBEF = 1UL<<1, // Clear transmit buffer empty flag
	SWPMI_ICR_CRXBFF = 1UL<<0, // Clear receive buffer full flag		
};

// SWPMI->IER SWPMI Interrupt Enable register
enum {
	SWPMI_IER_RDYIE = 1UL<<11, // Transceiver ready interrupt enable
	SWPMI_IER_SRIE = 1UL<<8, // Slave resume interrupt enable
	SWPMI_IER_TCIE = 1UL<<7, // Transmit complete interrupt enable
	SWPMI_IER_TIE = 1UL<<6, // Transmit interrupt enable
	SWPMI_IER_RIE = 1UL<<5, // Receive interrupt enable
	SWPMI_IER_TXUNRIE = 1UL<<4, // Transmit underrun error interrupt enable
	SWPMI_IER_RXOVRIE = 1UL<<3, // Receive overrun error interrupt enable
	SWPMI_IER_RXBERIE = 1UL<<2, // Receive CRC error interrupt enable
	SWPMI_IER_TXBEIE = 1UL<<1, // Transmit buffer empty interrupt enable
	SWPMI_IER_RXBFIE = 1UL<<0, // Receive buffer full interrupt enable		
};

// SWPMI->RFL SWPMI Receive Frame Length register
enum {
	SWPMI_RFL_RFL = ((1UL<<5)-1) << 0, // Receive frame length		
};
inline uint32_t swpmi_rfl_get_rfl(struct SWPMI_Type* p) { return (p->RFL & SWPMI_RFL_RFL) >> 0 ; }

// SWPMI->OR SWPMI Option register
enum {
	SWPMI_OR_SWP_CLASS = 1UL<<1, // SWP class selection
	SWPMI_OR_SWP_TBYP = 1UL<<0, // SWP transceiver bypass		
};

/* System configuration controller */
struct SYSCFG_Type {
	 uint8_t RESERVED0[4]; // @0 
	__IO uint32_t PMCR; // @4 peripheral mode configuration register
	__IO uint16_t EXTICR1; // @8 external interrupt configuration register 1
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t EXTICR2; // @12 external interrupt configuration register 2
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t EXTICR3; // @16 external interrupt configuration register 3
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t EXTICR4; // @20 external interrupt configuration register 4
	 uint8_t RESERVED4[10]; // @22 
	__IO uint32_t CCCSR; // @32 compensation cell control/status register
	__I uint8_t CCVR; // @36 SYSCFG compensation cell value register
	 uint8_t RESERVED5[3]; // @37 
	__IO uint8_t CCCR; // @40 SYSCFG compensation cell code register
	 uint8_t RESERVED6[251]; // @41 
	__I uint8_t PKGR; // @292 SYSCFG package register
	 uint8_t RESERVED7[475]; // @293 
	__I uint32_t UR0; // @768 SYSCFG user register 0
	 uint8_t RESERVED8[4]; // @772 
	__IO uint32_t UR2; // @776 SYSCFG user register 2
	__IO uint32_t UR3; // @780 SYSCFG user register 3
	__I uint32_t UR4; // @784 SYSCFG user register 4
	__I uint32_t UR5; // @788 SYSCFG user register 5
	__I uint32_t UR6; // @792 SYSCFG user register 6
	__I uint32_t UR7; // @796 SYSCFG user register 7
	__I uint32_t UR8; // @800 SYSCFG user register 8
	__I uint32_t UR9; // @804 SYSCFG user register 9
	__I uint32_t UR10; // @808 SYSCFG user register 10
	__I uint32_t UR11; // @812 SYSCFG user register 11
	__I uint32_t UR12; // @816 SYSCFG user register 12
	__I uint32_t UR13; // @820 SYSCFG user register 13
	__IO uint8_t UR14; // @824 SYSCFG user register 14
	 uint8_t RESERVED9[3]; // @825 
	__I uint32_t UR15; // @828 SYSCFG user register 15
	__I uint32_t UR16; // @832 SYSCFG user register 16
	__I uint8_t UR17; // @836 SYSCFG user register 17
};

// SYSCFG->PMCR peripheral mode configuration register
enum {
	SYSCFG_PMCR_PC3SO = 1UL<<27, // PC3 Switch Open
	SYSCFG_PMCR_PC2SO = 1UL<<26, // PC2 Switch Open
	SYSCFG_PMCR_PA1SO = 1UL<<25, // PA1 Switch Open
	SYSCFG_PMCR_PA0SO = 1UL<<24, // PA0 Switch Open
	SYSCFG_PMCR_EPIS = ((1UL<<3)-1) << 21, // Ethernet PHY Interface Selection
	SYSCFG_PMCR_BOOSTE = 1UL<<8, // Booster Enable
	SYSCFG_PMCR_PB9FMP = 1UL<<7, // PB(9) Fm+
	SYSCFG_PMCR_PB8FMP = 1UL<<6, // PB(8) Fast Mode Plus
	SYSCFG_PMCR_PB7FMP = 1UL<<5, // PB(7) Fast Mode Plus
	SYSCFG_PMCR_PB6FMP = 1UL<<4, // PB(6) Fm+
	SYSCFG_PMCR_I2C4FMP = 1UL<<3, // I2C4 Fm+
	SYSCFG_PMCR_I2C3FMP = 1UL<<2, // I2C3 Fm+
	SYSCFG_PMCR_I2C2FMP = 1UL<<1, // I2C2 Fm+
	SYSCFG_PMCR_I2C1FMP = 1UL<<0, // I2C1 Fm+		
};
inline void syscfg_pmcr_set_epis(struct SYSCFG_Type* p, uint32_t val) { p->PMCR = (p->PMCR & ~SYSCFG_PMCR_EPIS) | ((val<<21) & SYSCFG_PMCR_EPIS); }
inline uint32_t syscfg_pmcr_get_epis(struct SYSCFG_Type* p) { return (p->PMCR & SYSCFG_PMCR_EPIS) >> 21 ; }

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI2 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI1 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI0 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 0 to 3)		
};
inline void syscfg_exticr1_set_exti3(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val<<12) & SYSCFG_EXTICR1_EXTI3); }
inline void syscfg_exticr1_set_exti2(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val<<8) & SYSCFG_EXTICR1_EXTI2); }
inline void syscfg_exticr1_set_exti1(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val<<4) & SYSCFG_EXTICR1_EXTI1); }
inline void syscfg_exticr1_set_exti0(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val<<0) & SYSCFG_EXTICR1_EXTI0); }
inline uint32_t syscfg_exticr1_get_exti3(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12 ; }
inline uint32_t syscfg_exticr1_get_exti2(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8 ; }
inline uint32_t syscfg_exticr1_get_exti1(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4 ; }
inline uint32_t syscfg_exticr1_get_exti0(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0 ; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI6 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI5 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI4 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 4 to 7)		
};
inline void syscfg_exticr2_set_exti7(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val<<12) & SYSCFG_EXTICR2_EXTI7); }
inline void syscfg_exticr2_set_exti6(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val<<8) & SYSCFG_EXTICR2_EXTI6); }
inline void syscfg_exticr2_set_exti5(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val<<4) & SYSCFG_EXTICR2_EXTI5); }
inline void syscfg_exticr2_set_exti4(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val<<0) & SYSCFG_EXTICR2_EXTI4); }
inline uint32_t syscfg_exticr2_get_exti7(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12 ; }
inline uint32_t syscfg_exticr2_get_exti6(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8 ; }
inline uint32_t syscfg_exticr2_get_exti5(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4 ; }
inline uint32_t syscfg_exticr2_get_exti4(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0 ; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI10 = ((1UL<<4)-1) << 8, // EXTI10
	SYSCFG_EXTICR3_EXTI9 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI8 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 8 to 11)		
};
inline void syscfg_exticr3_set_exti11(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val<<12) & SYSCFG_EXTICR3_EXTI11); }
inline void syscfg_exticr3_set_exti10(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val<<8) & SYSCFG_EXTICR3_EXTI10); }
inline void syscfg_exticr3_set_exti9(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val<<4) & SYSCFG_EXTICR3_EXTI9); }
inline void syscfg_exticr3_set_exti8(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val<<0) & SYSCFG_EXTICR3_EXTI8); }
inline uint32_t syscfg_exticr3_get_exti11(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12 ; }
inline uint32_t syscfg_exticr3_get_exti10(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8 ; }
inline uint32_t syscfg_exticr3_get_exti9(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4 ; }
inline uint32_t syscfg_exticr3_get_exti8(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0 ; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI14 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI13 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI12 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 12 to 15)		
};
inline void syscfg_exticr4_set_exti15(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val<<12) & SYSCFG_EXTICR4_EXTI15); }
inline void syscfg_exticr4_set_exti14(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val<<8) & SYSCFG_EXTICR4_EXTI14); }
inline void syscfg_exticr4_set_exti13(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val<<4) & SYSCFG_EXTICR4_EXTI13); }
inline void syscfg_exticr4_set_exti12(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val<<0) & SYSCFG_EXTICR4_EXTI12); }
inline uint32_t syscfg_exticr4_get_exti15(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12 ; }
inline uint32_t syscfg_exticr4_get_exti14(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8 ; }
inline uint32_t syscfg_exticr4_get_exti13(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4 ; }
inline uint32_t syscfg_exticr4_get_exti12(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0 ; }

// SYSCFG->CCCSR compensation cell control/status register
enum {
	SYSCFG_CCCSR_HSLV = 1UL<<16, // High-speed at low-voltage
	SYSCFG_CCCSR_READY = 1UL<<8, // Compensation cell ready flag
	SYSCFG_CCCSR_CS = 1UL<<1, // Code selection
	SYSCFG_CCCSR_EN = 1UL<<0, // enable		
};

// SYSCFG->CCVR SYSCFG compensation cell value register
enum {
	SYSCFG_CCVR_PCV = ((1UL<<4)-1) << 4, // PMOS compensation value
	SYSCFG_CCVR_NCV = ((1UL<<4)-1) << 0, // NMOS compensation value		
};
inline uint32_t syscfg_ccvr_get_pcv(struct SYSCFG_Type* p) { return (p->CCVR & SYSCFG_CCVR_PCV) >> 4 ; }
inline uint32_t syscfg_ccvr_get_ncv(struct SYSCFG_Type* p) { return (p->CCVR & SYSCFG_CCVR_NCV) >> 0 ; }

// SYSCFG->CCCR SYSCFG compensation cell code register
enum {
	SYSCFG_CCCR_PCC = ((1UL<<4)-1) << 4, // PMOS compensation code
	SYSCFG_CCCR_NCC = ((1UL<<4)-1) << 0, // NMOS compensation code		
};
inline void syscfg_cccr_set_pcc(struct SYSCFG_Type* p, uint32_t val) { p->CCCR = (p->CCCR & ~SYSCFG_CCCR_PCC) | ((val<<4) & SYSCFG_CCCR_PCC); }
inline void syscfg_cccr_set_ncc(struct SYSCFG_Type* p, uint32_t val) { p->CCCR = (p->CCCR & ~SYSCFG_CCCR_NCC) | ((val<<0) & SYSCFG_CCCR_NCC); }
inline uint32_t syscfg_cccr_get_pcc(struct SYSCFG_Type* p) { return (p->CCCR & SYSCFG_CCCR_PCC) >> 4 ; }
inline uint32_t syscfg_cccr_get_ncc(struct SYSCFG_Type* p) { return (p->CCCR & SYSCFG_CCCR_NCC) >> 0 ; }

// SYSCFG->PKGR SYSCFG package register
enum {
	SYSCFG_PKGR_PKG = ((1UL<<4)-1) << 0, // Package		
};
inline uint32_t syscfg_pkgr_get_pkg(struct SYSCFG_Type* p) { return (p->PKGR & SYSCFG_PKGR_PKG) >> 0 ; }

// SYSCFG->UR0 SYSCFG user register 0
enum {
	SYSCFG_UR0_RDP = ((1UL<<8)-1) << 16, // Readout protection
	SYSCFG_UR0_BKS = 1UL<<0, // Bank Swap		
};
inline uint32_t syscfg_ur0_get_rdp(struct SYSCFG_Type* p) { return (p->UR0 & SYSCFG_UR0_RDP) >> 16 ; }

// SYSCFG->UR2 SYSCFG user register 2
enum {
	SYSCFG_UR2_BOOT_ADD0 = ((1UL<<16)-1) << 16, // Boot Address 0
	SYSCFG_UR2_BORH = ((1UL<<2)-1) << 0, // BOR_LVL Brownout Reset Threshold Level		
};
inline void syscfg_ur2_set_boot_add0(struct SYSCFG_Type* p, uint32_t val) { p->UR2 = (p->UR2 & ~SYSCFG_UR2_BOOT_ADD0) | ((val<<16) & SYSCFG_UR2_BOOT_ADD0); }
inline void syscfg_ur2_set_borh(struct SYSCFG_Type* p, uint32_t val) { p->UR2 = (p->UR2 & ~SYSCFG_UR2_BORH) | ((val<<0) & SYSCFG_UR2_BORH); }
inline uint32_t syscfg_ur2_get_boot_add0(struct SYSCFG_Type* p) { return (p->UR2 & SYSCFG_UR2_BOOT_ADD0) >> 16 ; }
inline uint32_t syscfg_ur2_get_borh(struct SYSCFG_Type* p) { return (p->UR2 & SYSCFG_UR2_BORH) >> 0 ; }

// SYSCFG->UR3 SYSCFG user register 3
enum {
	SYSCFG_UR3_BOOT_ADD1 = ((1UL<<16)-1) << 16, // Boot Address 1		
};
inline void syscfg_ur3_set_boot_add1(struct SYSCFG_Type* p, uint32_t val) { p->UR3 = (p->UR3 & ~SYSCFG_UR3_BOOT_ADD1) | ((val<<16) & SYSCFG_UR3_BOOT_ADD1); }
inline uint32_t syscfg_ur3_get_boot_add1(struct SYSCFG_Type* p) { return (p->UR3 & SYSCFG_UR3_BOOT_ADD1) >> 16 ; }

// SYSCFG->UR4 SYSCFG user register 4
enum {
	SYSCFG_UR4_MEPAD_1 = 1UL<<16, // Mass Erase Protected Area Disabled for bank 1		
};

// SYSCFG->UR5 SYSCFG user register 5
enum {
	SYSCFG_UR5_WRPN_1 = ((1UL<<8)-1) << 16, // Write protection for flash bank 1
	SYSCFG_UR5_MESAD_1 = 1UL<<0, // Mass erase secured area disabled for bank 1		
};
inline uint32_t syscfg_ur5_get_wrpn_1(struct SYSCFG_Type* p) { return (p->UR5 & SYSCFG_UR5_WRPN_1) >> 16 ; }

// SYSCFG->UR6 SYSCFG user register 6
enum {
	SYSCFG_UR6_PA_END_1 = ((1UL<<12)-1) << 16, // Protected area end address for bank 1
	SYSCFG_UR6_PA_BEG_1 = ((1UL<<12)-1) << 0, // Protected area start address for bank 1		
};
inline uint32_t syscfg_ur6_get_pa_end_1(struct SYSCFG_Type* p) { return (p->UR6 & SYSCFG_UR6_PA_END_1) >> 16 ; }
inline uint32_t syscfg_ur6_get_pa_beg_1(struct SYSCFG_Type* p) { return (p->UR6 & SYSCFG_UR6_PA_BEG_1) >> 0 ; }

// SYSCFG->UR7 SYSCFG user register 7
enum {
	SYSCFG_UR7_SA_END_1 = ((1UL<<12)-1) << 16, // Secured area end address for bank 1
	SYSCFG_UR7_SA_BEG_1 = ((1UL<<12)-1) << 0, // Secured area start address for bank 1		
};
inline uint32_t syscfg_ur7_get_sa_end_1(struct SYSCFG_Type* p) { return (p->UR7 & SYSCFG_UR7_SA_END_1) >> 16 ; }
inline uint32_t syscfg_ur7_get_sa_beg_1(struct SYSCFG_Type* p) { return (p->UR7 & SYSCFG_UR7_SA_BEG_1) >> 0 ; }

// SYSCFG->UR8 SYSCFG user register 8
enum {
	SYSCFG_UR8_MESAD_2 = 1UL<<16, // Mass erase secured area disabled for bank 2
	SYSCFG_UR8_MEPAD_2 = 1UL<<0, // Mass erase protected area disabled for bank 2		
};

// SYSCFG->UR9 SYSCFG user register 9
enum {
	SYSCFG_UR9_PA_BEG_2 = ((1UL<<12)-1) << 16, // Protected area start address for bank 2
	SYSCFG_UR9_WRPN_2 = ((1UL<<8)-1) << 0, // Write protection for flash bank 2		
};
inline uint32_t syscfg_ur9_get_pa_beg_2(struct SYSCFG_Type* p) { return (p->UR9 & SYSCFG_UR9_PA_BEG_2) >> 16 ; }
inline uint32_t syscfg_ur9_get_wrpn_2(struct SYSCFG_Type* p) { return (p->UR9 & SYSCFG_UR9_WRPN_2) >> 0 ; }

// SYSCFG->UR10 SYSCFG user register 10
enum {
	SYSCFG_UR10_SA_BEG_2 = ((1UL<<12)-1) << 16, // Secured area start address for bank 2
	SYSCFG_UR10_PA_END_2 = ((1UL<<12)-1) << 0, // Protected area end address for bank 2		
};
inline uint32_t syscfg_ur10_get_sa_beg_2(struct SYSCFG_Type* p) { return (p->UR10 & SYSCFG_UR10_SA_BEG_2) >> 16 ; }
inline uint32_t syscfg_ur10_get_pa_end_2(struct SYSCFG_Type* p) { return (p->UR10 & SYSCFG_UR10_PA_END_2) >> 0 ; }

// SYSCFG->UR11 SYSCFG user register 11
enum {
	SYSCFG_UR11_IWDG1M = 1UL<<16, // Independent Watchdog 1 mode
	SYSCFG_UR11_SA_END_2 = ((1UL<<12)-1) << 0, // Secured area end address for bank 2		
};
inline uint32_t syscfg_ur11_get_sa_end_2(struct SYSCFG_Type* p) { return (p->UR11 & SYSCFG_UR11_SA_END_2) >> 0 ; }

// SYSCFG->UR12 SYSCFG user register 12
enum {
	SYSCFG_UR12_SECURE = 1UL<<16, // Secure mode		
};

// SYSCFG->UR13 SYSCFG user register 13
enum {
	SYSCFG_UR13_D1SBRST = 1UL<<16, // D1 Standby reset
	SYSCFG_UR13_SDRS = ((1UL<<2)-1) << 0, // Secured DTCM RAM Size		
};
inline uint32_t syscfg_ur13_get_sdrs(struct SYSCFG_Type* p) { return (p->UR13 & SYSCFG_UR13_SDRS) >> 0 ; }

// SYSCFG->UR14 SYSCFG user register 14
enum {
	SYSCFG_UR14_D1STPRST = 1UL<<0, // D1 Stop Reset		
};

// SYSCFG->UR15 SYSCFG user register 15
enum {
	SYSCFG_UR15_FZIWDGSTB = 1UL<<16, // Freeze independent watchdog in Standby mode		
};

// SYSCFG->UR16 SYSCFG user register 16
enum {
	SYSCFG_UR16_PKP = 1UL<<16, // Private key programmed
	SYSCFG_UR16_FZIWDGSTP = 1UL<<0, // Freeze independent watchdog in Stop mode		
};

// SYSCFG->UR17 SYSCFG user register 17
enum {
	SYSCFG_UR17_IO_HSLV = 1UL<<0, // I/O high speed / low voltage		
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CR2; // @4 control register 2
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t SR; // @16 status register
	__O uint16_t EGR; // @20 event generation register
	 uint8_t RESERVED2[2]; // @22 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	union {  // @28
		__IO uint32_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	__IO uint32_t CCER; // @32 capture/compare enable register
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED3[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED4[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED5[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED6[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED7[2]; // @58 
	__IO uint16_t CCR3; // @60 capture/compare register 3
	 uint8_t RESERVED8[2]; // @62 
	__IO uint16_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED9[2]; // @66 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED11[6]; // @78 
	__IO uint32_t CCMR3_Output; // @84 capture/compare mode register 3 (output mode)
	__IO uint32_t CCR5; // @88 capture/compare register 5
	__IO uint16_t CRR6; // @92 capture/compare register 6
	 uint8_t RESERVED12[2]; // @94 
	__IO uint32_t AF1; // @96 TIM1 alternate function option register 1
	__IO uint16_t AF2; // @100 TIM1 Alternate function odfsdm1_breakster 2
	 uint8_t RESERVED13[2]; // @102 
	__IO uint32_t TISEL; // @104 TIM1 timer input selection register
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM1_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM1_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR = 1UL<<4, // Direction
	TIM1_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM1_CR1_URS = 1UL<<2, // Update request source
	TIM1_CR1_UDIS = 1UL<<1, // Update disable
	TIM1_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val<<8) & TIM1_CR1_CKD); }
inline void tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val<<5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8 ; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5 ; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_MMS2 = ((1UL<<4)-1) << 20, // Master mode selection 2
	TIM1_CR2_OIS6 = 1UL<<18, // Output Idle state 6
	TIM1_CR2_OIS5 = 1UL<<16, // Output Idle state 5
	TIM1_CR2_OIS4 = 1UL<<14, // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL<<13, // Output Idle state 3
	TIM1_CR2_OIS3 = 1UL<<12, // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL<<11, // Output Idle state 2
	TIM1_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM1_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM1_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM1_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM1_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM1_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM1_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
inline void tim1_cr2_set_mms2(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS2) | ((val<<20) & TIM1_CR2_MMS2); }
inline void tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val<<4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms2(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS2) >> 20 ; }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4 ; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_TS_4_3 = ((1UL<<2)-1) << 20, // Trigger selection - bit 4:3
	TIM1_SMCR_SMS_3 = 1UL<<16, // Slave mode selection - bit 3
	TIM1_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM1_SMCR_ECE = 1UL<<14, // External clock enable
	TIM1_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM1_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM1_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM1_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim1_smcr_set_ts_4_3(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS_4_3) | ((val<<20) & TIM1_SMCR_TS_4_3); }
inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val<<12) & TIM1_SMCR_ETPS); }
inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val<<8) & TIM1_SMCR_ETF); }
inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val<<4) & TIM1_SMCR_TS); }
inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val<<0) & TIM1_SMCR_SMS); }
inline uint32_t tim1_smcr_get_ts_4_3(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS_4_3) >> 20 ; }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12 ; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8 ; }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 4 ; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0 ; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM1_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM1_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM1->SR status register
enum {
	TIM1_SR_CC6IF = 1UL<<17, // Compare 6 interrupt flag
	TIM1_SR_CC5IF = 1UL<<16, // Compare 5 interrupt flag
	TIM1_SR_SBIF = 1UL<<13, // System Break interrupt flag
	TIM1_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM1_SR_B2IF = 1UL<<8, // Break 2 interrupt flag
	TIM1_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM1_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM1_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM1_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_B2G = 1UL<<8, // Break 2 generation
	TIM1_EGR_BG = 1UL<<7, // Break generation
	TIM1_EGR_TG = 1UL<<6, // Trigger generation
	TIM1_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM1_EGR_UG = 1UL<<0, // Update generation		
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM1_CCMR1_OUTPUT_OC2M); }
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM1_CCMR1_OUTPUT_CC2S); }
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM1_CCMR1_OUTPUT_OC1M); }
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM1_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4M_4 = 1UL<<24, // Output Compare 4 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC3M_3 = 1UL<<16, // Output Compare 3 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM1_CCMR2_OUTPUT_OC4M); }
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM1_CCMR2_OUTPUT_CC4S); }
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM1_CCMR2_OUTPUT_OC3M); }
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM1_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC6P = 1UL<<21, // Capture/Compare 6 output polarity
	TIM1_CCER_CC6E = 1UL<<20, // Capture/Compare 6 output enable
	TIM1_CCER_CC5P = 1UL<<17, // Capture/Compare 5 output polarity
	TIM1_CCER_CC5E = 1UL<<16, // Capture/Compare 5 output enable
	TIM1_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 complementary output polarity
	TIM1_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL<<10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL<<6, // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM1->CNT counter
enum {
	TIM1_CNT_UIFCPY = 1UL<<31, // UIF copy
	TIM1_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim1_cnt_set_cnt(struct TIM1_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM1_CNT_CNT) | ((val<<0) & TIM1_CNT_CNT); }
inline uint32_t tim1_cnt_get_cnt(struct TIM1_Type* p) { return (p->CNT & TIM1_CNT_CNT) >> 0 ; }

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_BK2P = 1UL<<25, // Break 2 polarity
	TIM1_BDTR_BK2E = 1UL<<24, // Break 2 enable
	TIM1_BDTR_BK2F = ((1UL<<4)-1) << 20, // Break 2 filter
	TIM1_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM1_BDTR_MOE = 1UL<<15, // Main output enable
	TIM1_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM1_BDTR_BKP = 1UL<<13, // Break polarity
	TIM1_BDTR_BKE = 1UL<<12, // Break enable
	TIM1_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM1_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim1_bdtr_set_bk2f(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BK2F) | ((val<<20) & TIM1_BDTR_BK2F); }
inline void tim1_bdtr_set_bkf(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BKF) | ((val<<16) & TIM1_BDTR_BKF); }
inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val<<8) & TIM1_BDTR_LOCK); }
inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val<<0) & TIM1_BDTR_DTG); }
inline uint32_t tim1_bdtr_get_bk2f(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BK2F) >> 20 ; }
inline uint32_t tim1_bdtr_get_bkf(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BKF) >> 16 ; }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8 ; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0 ; }

// TIM1->DCR DMA control register
enum {
	TIM1_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val<<8) & TIM1_DCR_DBL); }
inline void tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val<<0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8 ; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0 ; }

// TIM1->CCMR3_Output capture/compare mode register 3 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M3 = 1UL<<24, // Output Compare 6 mode
	TIM1_CCMR3_OUTPUT_OC5M3 = 1UL<<16, // Output Compare 5 mode
	TIM1_CCMR3_OUTPUT_OC6CE = 1UL<<15, // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M = ((1UL<<3)-1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE = 1UL<<11, // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE = 1UL<<10, // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE = 1UL<<7, // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M = ((1UL<<3)-1) << 4, // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE = 1UL<<3, // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE = 1UL<<2, // Output compare 5 fast enable		
};
inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val<<12) & TIM1_CCMR3_OUTPUT_OC6M); }
inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val<<4) & TIM1_CCMR3_OUTPUT_OC5M); }
inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12 ; }
inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4 ; }

// TIM1->CCR5 capture/compare register 5
enum {
	TIM1_CCR5_GC5C3 = 1UL<<31, // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL<<30, // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL<<29, // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5 = ((1UL<<16)-1) << 0, // Capture/Compare 5 value		
};
inline void tim1_ccr5_set_ccr5(struct TIM1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val<<0) & TIM1_CCR5_CCR5); }
inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type* p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0 ; }

// TIM1->AF1 TIM1 alternate function option register 1
enum {
	TIM1_AF1_ETRSEL = ((1UL<<4)-1) << 14, // ETR source selection
	TIM1_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM1_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM1_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM1_AF1_BKDF1BK0E = 1UL<<8, // BRK dfsdm1_break[0] enable
	TIM1_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM1_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM1_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};
inline void tim1_af1_set_etrsel(struct TIM1_Type* p, uint32_t val) { p->AF1 = (p->AF1 & ~TIM1_AF1_ETRSEL) | ((val<<14) & TIM1_AF1_ETRSEL); }
inline uint32_t tim1_af1_get_etrsel(struct TIM1_Type* p) { return (p->AF1 & TIM1_AF1_ETRSEL) >> 14 ; }

// TIM1->AF2 TIM1 Alternate function odfsdm1_breakster 2
enum {
	TIM1_AF2_BK2CMP2P = 1UL<<11, // BRK2 COMP2 input polarity
	TIM1_AF2_BK2CMP1P = 1UL<<10, // BRK2 COMP1 input polarit
	TIM1_AF2_BK2INP = 1UL<<9, // BRK2 BKIN2 input polarity
	TIM1_AF2_BK2DF1BK1E = 1UL<<8, // BRK2 dfsdm1_break[1] enable
	TIM1_AF2_BK2CMP2E = 1UL<<2, // BRK2 COMP2 enable
	TIM1_AF2_BK2CMP1E = 1UL<<1, // BRK2 COMP1 enable
	TIM1_AF2_BK2INE = 1UL<<0, // BRK2 BKIN input enable		
};

// TIM1->TISEL TIM1 timer input selection register
enum {
	TIM1_TISEL_TI4SEL = ((1UL<<4)-1) << 24, // selects TI4[0] to TI4[15] input
	TIM1_TISEL_TI3SEL = ((1UL<<4)-1) << 16, // selects TI3[0] to TI3[15] input
	TIM1_TISEL_TI2SEL = ((1UL<<4)-1) << 8, // selects TI2[0] to TI2[15] input
	TIM1_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // selects TI1[0] to TI1[15] input		
};
inline void tim1_tisel_set_ti4sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI4SEL) | ((val<<24) & TIM1_TISEL_TI4SEL); }
inline void tim1_tisel_set_ti3sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI3SEL) | ((val<<16) & TIM1_TISEL_TI3SEL); }
inline void tim1_tisel_set_ti2sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI2SEL) | ((val<<8) & TIM1_TISEL_TI2SEL); }
inline void tim1_tisel_set_ti1sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI1SEL) | ((val<<0) & TIM1_TISEL_TI1SEL); }
inline uint32_t tim1_tisel_get_ti4sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI4SEL) >> 24 ; }
inline uint32_t tim1_tisel_get_ti3sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI3SEL) >> 16 ; }
inline uint32_t tim1_tisel_get_ti2sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI2SEL) >> 8 ; }
inline uint32_t tim1_tisel_get_ti1sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI1SEL) >> 0 ; }

// Valid Casts:
 
inline struct TIM6_Type* TIM1_as_TIM6_Type(struct TIM1_Type* p) { return (struct TIM6_Type*)p; }





/* General purpose timers */
struct TIM15_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED11[10]; // @58 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED13[18]; // @78 
	__IO uint16_t AF1; // @96 TIM15 alternate fdfsdm1_breakon register 1
	 uint8_t RESERVED14[6]; // @98 
	__IO uint16_t TISEL; // @104 TIM15 input selection register
};

// TIM15->CR1 control register 1
enum {
	TIM15_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM15_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM15_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM15_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM15_CR1_URS = 1UL<<2, // Update request source
	TIM15_CR1_UDIS = 1UL<<1, // Update disable
	TIM15_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim15_cr1_set_ckd(struct TIM15_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM15_CR1_CKD) | ((val<<8) & TIM15_CR1_CKD); }
inline uint32_t tim15_cr1_get_ckd(struct TIM15_Type* p) { return (p->CR1 & TIM15_CR1_CKD) >> 8 ; }

// TIM15->CR2 control register 2
enum {
	TIM15_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM15_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM15_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM15_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM15_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM15_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM15_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM15_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
inline void tim15_cr2_set_mms(struct TIM15_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM15_CR2_MMS) | ((val<<4) & TIM15_CR2_MMS); }
inline uint32_t tim15_cr2_get_mms(struct TIM15_Type* p) { return (p->CR2 & TIM15_CR2_MMS) >> 4 ; }

// TIM15->SMCR slave mode control register
enum {
	TIM15_SMCR_TS_4_3 = ((1UL<<2)-1) << 20, // Trigger selection - bit 4:3
	TIM15_SMCR_SMS_3 = 1UL<<16, // Slave mode selection bit 3
	TIM15_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM15_SMCR_TS_2_0 = ((1UL<<3)-1) << 4, // Trigger selection
	TIM15_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim15_smcr_set_ts_4_3(struct TIM15_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM15_SMCR_TS_4_3) | ((val<<20) & TIM15_SMCR_TS_4_3); }
inline void tim15_smcr_set_ts_2_0(struct TIM15_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM15_SMCR_TS_2_0) | ((val<<4) & TIM15_SMCR_TS_2_0); }
inline void tim15_smcr_set_sms(struct TIM15_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM15_SMCR_SMS) | ((val<<0) & TIM15_SMCR_SMS); }
inline uint32_t tim15_smcr_get_ts_4_3(struct TIM15_Type* p) { return (p->SMCR & TIM15_SMCR_TS_4_3) >> 20 ; }
inline uint32_t tim15_smcr_get_ts_2_0(struct TIM15_Type* p) { return (p->SMCR & TIM15_SMCR_TS_2_0) >> 4 ; }
inline uint32_t tim15_smcr_get_sms(struct TIM15_Type* p) { return (p->SMCR & TIM15_SMCR_SMS) >> 0 ; }

// TIM15->DIER DMA/Interrupt enable register
enum {
	TIM15_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM15_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM15_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM15_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM15_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM15_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM15_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM15_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM15_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM15_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM15_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM15->SR status register
enum {
	TIM15_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM15_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM15_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM15_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM15_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM15_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM15_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM15_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM15->EGR event generation register
enum {
	TIM15_EGR_BG = 1UL<<7, // Break generation
	TIM15_EGR_TG = 1UL<<6, // Trigger generation
	TIM15_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM15_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM15_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM15_EGR_UG = 1UL<<0, // Update generation		
};

// TIM15->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM15_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode bit 3
	TIM15_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode bit 3
	TIM15_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM15_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM15_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM15_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM15_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM15_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM15_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim15_ccmr1_output_set_oc2m(struct TIM15_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM15_CCMR1_OUTPUT_OC2M); }
inline void tim15_ccmr1_output_set_cc2s(struct TIM15_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM15_CCMR1_OUTPUT_CC2S); }
inline void tim15_ccmr1_output_set_oc1m(struct TIM15_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM15_CCMR1_OUTPUT_OC1M); }
inline void tim15_ccmr1_output_set_cc1s(struct TIM15_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM15_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim15_ccmr1_output_get_oc2m(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim15_ccmr1_output_get_cc2s(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim15_ccmr1_output_get_oc1m(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim15_ccmr1_output_get_cc1s(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM15->CCER capture/compare enable register
enum {
	TIM15_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM15_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM15_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM15_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM15_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM15->CNT counter
enum {
	TIM15_CNT_UIFCPY = 1UL<<31, // UIF copy
	TIM15_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim15_cnt_set_cnt(struct TIM15_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM15_CNT_CNT) | ((val<<0) & TIM15_CNT_CNT); }
inline uint32_t tim15_cnt_get_cnt(struct TIM15_Type* p) { return (p->CNT & TIM15_CNT_CNT) >> 0 ; }

// TIM15->BDTR break and dead-time register
enum {
	TIM15_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM15_BDTR_MOE = 1UL<<15, // Main output enable
	TIM15_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM15_BDTR_BKP = 1UL<<13, // Break polarity
	TIM15_BDTR_BKE = 1UL<<12, // Break enable
	TIM15_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM15_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM15_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM15_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim15_bdtr_set_bkf(struct TIM15_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM15_BDTR_BKF) | ((val<<16) & TIM15_BDTR_BKF); }
inline void tim15_bdtr_set_lock(struct TIM15_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM15_BDTR_LOCK) | ((val<<8) & TIM15_BDTR_LOCK); }
inline void tim15_bdtr_set_dtg(struct TIM15_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM15_BDTR_DTG) | ((val<<0) & TIM15_BDTR_DTG); }
inline uint32_t tim15_bdtr_get_bkf(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_BKF) >> 16 ; }
inline uint32_t tim15_bdtr_get_lock(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_LOCK) >> 8 ; }
inline uint32_t tim15_bdtr_get_dtg(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_DTG) >> 0 ; }

// TIM15->DCR DMA control register
enum {
	TIM15_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM15_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim15_dcr_set_dbl(struct TIM15_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM15_DCR_DBL) | ((val<<8) & TIM15_DCR_DBL); }
inline void tim15_dcr_set_dba(struct TIM15_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM15_DCR_DBA) | ((val<<0) & TIM15_DCR_DBA); }
inline uint32_t tim15_dcr_get_dbl(struct TIM15_Type* p) { return (p->DCR & TIM15_DCR_DBL) >> 8 ; }
inline uint32_t tim15_dcr_get_dba(struct TIM15_Type* p) { return (p->DCR & TIM15_DCR_DBA) >> 0 ; }

// TIM15->AF1 TIM15 alternate fdfsdm1_breakon register 1
enum {
	TIM15_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM15_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM15_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM15_AF1_BKDF1BK0E = 1UL<<8, // BRK dfsdm1_break[0] enable
	TIM15_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM15_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM15_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM15->TISEL TIM15 input selection register
enum {
	TIM15_TISEL_TI2SEL = ((1UL<<4)-1) << 8, // selects TI2[0] to TI2[15] input
	TIM15_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // selects TI1[0] to TI1[15] input		
};
inline void tim15_tisel_set_ti2sel(struct TIM15_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM15_TISEL_TI2SEL) | ((val<<8) & TIM15_TISEL_TI2SEL); }
inline void tim15_tisel_set_ti1sel(struct TIM15_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM15_TISEL_TI1SEL) | ((val<<0) & TIM15_TISEL_TI1SEL); }
inline uint32_t tim15_tisel_get_ti2sel(struct TIM15_Type* p) { return (p->TISEL & TIM15_TISEL_TI2SEL) >> 8 ; }
inline uint32_t tim15_tisel_get_ti1sel(struct TIM15_Type* p) { return (p->TISEL & TIM15_TISEL_TI1SEL) >> 0 ; }

// Valid Casts:
 
inline struct TIM6_Type* TIM15_as_TIM6_Type(struct TIM15_Type* p) { return (struct TIM6_Type*)p; }


/* General-purpose-timers */
struct TIM16_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED12[18]; // @78 
	__IO uint16_t TIM16_AF1; // @96 TIM16 alternate function register 1
	 uint8_t RESERVED13[6]; // @98 
	__IO uint8_t TIM16_TISEL; // @104 TIM16 input selection register
};

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM16_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM16_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM16_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM16_CR1_URS = 1UL<<2, // Update request source
	TIM16_CR1_UDIS = 1UL<<1, // Update disable
	TIM16_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim16_cr1_set_ckd(struct TIM16_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM16_CR1_CKD) | ((val<<8) & TIM16_CR1_CKD); }
inline uint32_t tim16_cr1_get_ckd(struct TIM16_Type* p) { return (p->CR1 & TIM16_CR1_CKD) >> 8 ; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM16_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM16_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM16_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM16_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM16_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM16_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM16_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM16_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM16_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM16_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG = 1UL<<7, // Break generation
	TIM16_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM16_EGR_UG = 1UL<<0, // Update generation		
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim16_ccmr1_output_set_oc1m(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM16_CCMR1_OUTPUT_OC1M); }
inline void tim16_ccmr1_output_set_cc1s(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM16_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim16_ccmr1_output_get_oc1m(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim16_ccmr1_output_get_cc1s(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM16_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim16_cnt_set_cnt(struct TIM16_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM16_CNT_CNT) | ((val<<0) & TIM16_CNT_CNT); }
inline uint32_t tim16_cnt_get_cnt(struct TIM16_Type* p) { return (p->CNT & TIM16_CNT_CNT) >> 0 ; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM16_BDTR_MOE = 1UL<<15, // Main output enable
	TIM16_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM16_BDTR_BKP = 1UL<<13, // Break polarity
	TIM16_BDTR_BKE = 1UL<<12, // Break enable
	TIM16_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM16_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM16_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM16_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim16_bdtr_set_bkf(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_BKF) | ((val<<16) & TIM16_BDTR_BKF); }
inline void tim16_bdtr_set_lock(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_LOCK) | ((val<<8) & TIM16_BDTR_LOCK); }
inline void tim16_bdtr_set_dtg(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_DTG) | ((val<<0) & TIM16_BDTR_DTG); }
inline uint32_t tim16_bdtr_get_bkf(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_BKF) >> 16 ; }
inline uint32_t tim16_bdtr_get_lock(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_LOCK) >> 8 ; }
inline uint32_t tim16_bdtr_get_dtg(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_DTG) >> 0 ; }

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM16_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim16_dcr_set_dbl(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBL) | ((val<<8) & TIM16_DCR_DBL); }
inline void tim16_dcr_set_dba(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBA) | ((val<<0) & TIM16_DCR_DBA); }
inline uint32_t tim16_dcr_get_dbl(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBL) >> 8 ; }
inline uint32_t tim16_dcr_get_dba(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBA) >> 0 ; }

// TIM16->TIM16_AF1 TIM16 alternate function register 1
enum {
	TIM16_TIM16_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM16_TIM16_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM16_TIM16_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM16_TIM16_AF1_BKDFBK1E = 1UL<<8, // BRK dfsdm1_break[1] enable
	TIM16_TIM16_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM16_TIM16_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM16_TIM16_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM16->TIM16_TISEL TIM16 input selection register
enum {
	TIM16_TIM16_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // selects TI1[0] to TI1[15] input		
};
inline void tim16_tim16_tisel_set_ti1sel(struct TIM16_Type* p, uint32_t val) { p->TIM16_TISEL = (p->TIM16_TISEL & ~TIM16_TIM16_TISEL_TI1SEL) | ((val<<0) & TIM16_TIM16_TISEL_TI1SEL); }
inline uint32_t tim16_tim16_tisel_get_ti1sel(struct TIM16_Type* p) { return (p->TIM16_TISEL & TIM16_TIM16_TISEL_TI1SEL) >> 0 ; }

/* General-purpose-timers */
struct TIM17_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED12[18]; // @78 
	__IO uint16_t TIM17_AF1; // @96 TIM17 alternate function register 1
	 uint8_t RESERVED13[6]; // @98 
	__IO uint8_t TIM17_TISEL; // @104 TIM17 input selection register
};

// TIM17->CR1 control register 1
enum {
	TIM17_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM17_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM17_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM17_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM17_CR1_URS = 1UL<<2, // Update request source
	TIM17_CR1_UDIS = 1UL<<1, // Update disable
	TIM17_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim17_cr1_set_ckd(struct TIM17_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM17_CR1_CKD) | ((val<<8) & TIM17_CR1_CKD); }
inline uint32_t tim17_cr1_get_ckd(struct TIM17_Type* p) { return (p->CR1 & TIM17_CR1_CKD) >> 8 ; }

// TIM17->CR2 control register 2
enum {
	TIM17_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM17_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM17_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM17_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM17_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM17->DIER DMA/Interrupt enable register
enum {
	TIM17_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM17_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM17_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM17_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM17_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM17_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM17_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM17->SR status register
enum {
	TIM17_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM17_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM17_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM17_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM17_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM17->EGR event generation register
enum {
	TIM17_EGR_BG = 1UL<<7, // Break generation
	TIM17_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM17_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM17_EGR_UG = 1UL<<0, // Update generation		
};

// TIM17->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM17_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode
	TIM17_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM17_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM17_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM17_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim17_ccmr1_output_set_oc1m(struct TIM17_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM17_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM17_CCMR1_OUTPUT_OC1M); }
inline void tim17_ccmr1_output_set_cc1s(struct TIM17_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM17_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM17_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim17_ccmr1_output_get_oc1m(struct TIM17_Type* p) { return (p->CCMR1_Output & TIM17_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim17_ccmr1_output_get_cc1s(struct TIM17_Type* p) { return (p->CCMR1_Output & TIM17_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM17->CCER capture/compare enable register
enum {
	TIM17_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM17_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM17_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM17_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM17->CNT counter
enum {
	TIM17_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM17_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim17_cnt_set_cnt(struct TIM17_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM17_CNT_CNT) | ((val<<0) & TIM17_CNT_CNT); }
inline uint32_t tim17_cnt_get_cnt(struct TIM17_Type* p) { return (p->CNT & TIM17_CNT_CNT) >> 0 ; }

// TIM17->BDTR break and dead-time register
enum {
	TIM17_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM17_BDTR_MOE = 1UL<<15, // Main output enable
	TIM17_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM17_BDTR_BKP = 1UL<<13, // Break polarity
	TIM17_BDTR_BKE = 1UL<<12, // Break enable
	TIM17_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM17_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM17_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM17_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim17_bdtr_set_bkf(struct TIM17_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM17_BDTR_BKF) | ((val<<16) & TIM17_BDTR_BKF); }
inline void tim17_bdtr_set_lock(struct TIM17_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM17_BDTR_LOCK) | ((val<<8) & TIM17_BDTR_LOCK); }
inline void tim17_bdtr_set_dtg(struct TIM17_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM17_BDTR_DTG) | ((val<<0) & TIM17_BDTR_DTG); }
inline uint32_t tim17_bdtr_get_bkf(struct TIM17_Type* p) { return (p->BDTR & TIM17_BDTR_BKF) >> 16 ; }
inline uint32_t tim17_bdtr_get_lock(struct TIM17_Type* p) { return (p->BDTR & TIM17_BDTR_LOCK) >> 8 ; }
inline uint32_t tim17_bdtr_get_dtg(struct TIM17_Type* p) { return (p->BDTR & TIM17_BDTR_DTG) >> 0 ; }

// TIM17->DCR DMA control register
enum {
	TIM17_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM17_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim17_dcr_set_dbl(struct TIM17_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM17_DCR_DBL) | ((val<<8) & TIM17_DCR_DBL); }
inline void tim17_dcr_set_dba(struct TIM17_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM17_DCR_DBA) | ((val<<0) & TIM17_DCR_DBA); }
inline uint32_t tim17_dcr_get_dbl(struct TIM17_Type* p) { return (p->DCR & TIM17_DCR_DBL) >> 8 ; }
inline uint32_t tim17_dcr_get_dba(struct TIM17_Type* p) { return (p->DCR & TIM17_DCR_DBA) >> 0 ; }

// TIM17->TIM17_AF1 TIM17 alternate function register 1
enum {
	TIM17_TIM17_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM17_TIM17_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM17_TIM17_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM17_TIM17_AF1_BKDFBK1E = 1UL<<8, // BRK dfsdm1_break[1] enable
	TIM17_TIM17_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM17_TIM17_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM17_TIM17_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM17->TIM17_TISEL TIM17 input selection register
enum {
	TIM17_TIM17_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // selects TI1[0] to TI1[15] input		
};
inline void tim17_tim17_tisel_set_ti1sel(struct TIM17_Type* p, uint32_t val) { p->TIM17_TISEL = (p->TIM17_TISEL & ~TIM17_TIM17_TISEL_TI1SEL) | ((val<<0) & TIM17_TIM17_TISEL_TI1SEL); }
inline uint32_t tim17_tim17_tisel_get_ti1sel(struct TIM17_Type* p) { return (p->TIM17_TISEL & TIM17_TIM17_TISEL_TI1SEL) >> 0 ; }

/* General purpose timers */
struct TIM2_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	union {  // @28
		__IO uint32_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED5[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED6[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED7[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED8[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED9[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED10[18]; // @78 
	__IO uint32_t AF1; // @96 TIM alternate function option register 1
	 uint8_t RESERVED11[4]; // @100 
	__IO uint32_t TISEL; // @104 TIM timer input selection register
};

// TIM2->CR1 control register 1
enum {
	TIM2_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM2_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM2_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM2_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM2_CR1_DIR = 1UL<<4, // Direction
	TIM2_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM2_CR1_URS = 1UL<<2, // Update request source
	TIM2_CR1_UDIS = 1UL<<1, // Update disable
	TIM2_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim2_cr1_set_ckd(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CKD) | ((val<<8) & TIM2_CR1_CKD); }
inline void tim2_cr1_set_cms(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CMS) | ((val<<5) & TIM2_CR1_CMS); }
inline uint32_t tim2_cr1_get_ckd(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CKD) >> 8 ; }
inline uint32_t tim2_cr1_get_cms(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CMS) >> 5 ; }

// TIM2->CR2 control register 2
enum {
	TIM2_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM2_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM2_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
inline void tim2_cr2_set_mms(struct TIM2_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM2_CR2_MMS) | ((val<<4) & TIM2_CR2_MMS); }
inline uint32_t tim2_cr2_get_mms(struct TIM2_Type* p) { return (p->CR2 & TIM2_CR2_MMS) >> 4 ; }

// TIM2->SMCR slave mode control register
enum {
	TIM2_SMCR_TS_4_3 = ((1UL<<2)-1) << 20, // Trigger selection
	TIM2_SMCR_SMS_3 = 1UL<<16, // Slave mode selection - bit 3
	TIM2_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM2_SMCR_ECE = 1UL<<14, // External clock enable
	TIM2_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM2_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM2_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM2_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM2_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim2_smcr_set_ts_4_3(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS_4_3) | ((val<<20) & TIM2_SMCR_TS_4_3); }
inline void tim2_smcr_set_etps(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETPS) | ((val<<12) & TIM2_SMCR_ETPS); }
inline void tim2_smcr_set_etf(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETF) | ((val<<8) & TIM2_SMCR_ETF); }
inline void tim2_smcr_set_ts(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS) | ((val<<4) & TIM2_SMCR_TS); }
inline void tim2_smcr_set_sms(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_SMS) | ((val<<0) & TIM2_SMCR_SMS); }
inline uint32_t tim2_smcr_get_ts_4_3(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS_4_3) >> 20 ; }
inline uint32_t tim2_smcr_get_etps(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETPS) >> 12 ; }
inline uint32_t tim2_smcr_get_etf(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETF) >> 8 ; }
inline uint32_t tim2_smcr_get_ts(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS) >> 4 ; }
inline uint32_t tim2_smcr_get_sms(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_SMS) >> 0 ; }

// TIM2->DIER DMA/Interrupt enable register
enum {
	TIM2_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM2_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM2_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM2_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM2_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM2_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM2_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM2_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM2_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM2_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM2_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM2_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM2->SR status register
enum {
	TIM2_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM2_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM2_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM2_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM2_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM2_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM2_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM2_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM2_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM2_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM2->EGR event generation register
enum {
	TIM2_EGR_TG = 1UL<<6, // Trigger generation
	TIM2_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM2_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM2_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM2_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM2_EGR_UG = 1UL<<0, // Update generation		
};

// TIM2->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM2_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM2_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM2_CCMR1_OUTPUT_OC2CE = 1UL<<15, // OC2CE
	TIM2_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // OC2M
	TIM2_CCMR1_OUTPUT_OC2PE = 1UL<<11, // OC2PE
	TIM2_CCMR1_OUTPUT_OC2FE = 1UL<<10, // OC2FE
	TIM2_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // CC2S
	TIM2_CCMR1_OUTPUT_OC1CE = 1UL<<7, // OC1CE
	TIM2_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // OC1M
	TIM2_CCMR1_OUTPUT_OC1PE = 1UL<<3, // OC1PE
	TIM2_CCMR1_OUTPUT_OC1FE = 1UL<<2, // OC1FE
	TIM2_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // CC1S		
};
inline void tim2_ccmr1_output_set_oc2m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM2_CCMR1_OUTPUT_OC2M); }
inline void tim2_ccmr1_output_set_cc2s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM2_CCMR1_OUTPUT_CC2S); }
inline void tim2_ccmr1_output_set_oc1m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM2_CCMR1_OUTPUT_OC1M); }
inline void tim2_ccmr1_output_set_cc1s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM2_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim2_ccmr1_output_get_oc2m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim2_ccmr1_output_get_cc2s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim2_ccmr1_output_get_oc1m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim2_ccmr1_output_get_cc1s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM2->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM2_CCMR2_OUTPUT_OC4M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM2_CCMR2_OUTPUT_OC3M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM2_CCMR2_OUTPUT_O24CE = 1UL<<15, // O24CE
	TIM2_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // OC4M
	TIM2_CCMR2_OUTPUT_OC4PE = 1UL<<11, // OC4PE
	TIM2_CCMR2_OUTPUT_OC4FE = 1UL<<10, // OC4FE
	TIM2_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // CC4S
	TIM2_CCMR2_OUTPUT_OC3CE = 1UL<<7, // OC3CE
	TIM2_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // OC3M
	TIM2_CCMR2_OUTPUT_OC3PE = 1UL<<3, // OC3PE
	TIM2_CCMR2_OUTPUT_OC3FE = 1UL<<2, // OC3FE
	TIM2_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // CC3S		
};
inline void tim2_ccmr2_output_set_oc4m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM2_CCMR2_OUTPUT_OC4M); }
inline void tim2_ccmr2_output_set_cc4s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM2_CCMR2_OUTPUT_CC4S); }
inline void tim2_ccmr2_output_set_oc3m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM2_CCMR2_OUTPUT_OC3M); }
inline void tim2_ccmr2_output_set_cc3s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM2_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim2_ccmr2_output_get_oc4m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim2_ccmr2_output_get_cc4s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim2_ccmr2_output_get_oc3m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim2_ccmr2_output_get_cc3s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM2->CCER capture/compare enable register
enum {
	TIM2_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM2_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM2_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM2_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM2_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM2->CNT counter
enum {
	TIM2_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value
	TIM2_CNT_CNT_L = ((1UL<<16)-1) << 0, // low counter value		
};
inline void tim2_cnt_set_cnt_h(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_H) | ((val<<16) & TIM2_CNT_CNT_H); }
inline void tim2_cnt_set_cnt_l(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_L) | ((val<<0) & TIM2_CNT_CNT_L); }
inline uint32_t tim2_cnt_get_cnt_h(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_H) >> 16 ; }
inline uint32_t tim2_cnt_get_cnt_l(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_L) >> 0 ; }

// TIM2->ARR auto-reload register
enum {
	TIM2_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value
	TIM2_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
inline void tim2_arr_set_arr_h(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_H) | ((val<<16) & TIM2_ARR_ARR_H); }
inline void tim2_arr_set_arr_l(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_L) | ((val<<0) & TIM2_ARR_ARR_L); }
inline uint32_t tim2_arr_get_arr_h(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_H) >> 16 ; }
inline uint32_t tim2_arr_get_arr_l(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_L) >> 0 ; }

// TIM2->CCR1 capture/compare register 1
enum {
	TIM2_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value
	TIM2_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
inline void tim2_ccr1_set_ccr1_h(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_H) | ((val<<16) & TIM2_CCR1_CCR1_H); }
inline void tim2_ccr1_set_ccr1_l(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_L) | ((val<<0) & TIM2_CCR1_CCR1_L); }
inline uint32_t tim2_ccr1_get_ccr1_h(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_H) >> 16 ; }
inline uint32_t tim2_ccr1_get_ccr1_l(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_L) >> 0 ; }

// TIM2->CCR2 capture/compare register 2
enum {
	TIM2_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value
	TIM2_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
inline void tim2_ccr2_set_ccr2_h(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_H) | ((val<<16) & TIM2_CCR2_CCR2_H); }
inline void tim2_ccr2_set_ccr2_l(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_L) | ((val<<0) & TIM2_CCR2_CCR2_L); }
inline uint32_t tim2_ccr2_get_ccr2_h(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_H) >> 16 ; }
inline uint32_t tim2_ccr2_get_ccr2_l(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_L) >> 0 ; }

// TIM2->CCR3 capture/compare register 3
enum {
	TIM2_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM2_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr3_set_ccr3_h(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_H) | ((val<<16) & TIM2_CCR3_CCR3_H); }
inline void tim2_ccr3_set_ccr3_l(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_L) | ((val<<0) & TIM2_CCR3_CCR3_L); }
inline uint32_t tim2_ccr3_get_ccr3_h(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_H) >> 16 ; }
inline uint32_t tim2_ccr3_get_ccr3_l(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_L) >> 0 ; }

// TIM2->CCR4 capture/compare register 4
enum {
	TIM2_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value
	TIM2_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr4_set_ccr4_h(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_H) | ((val<<16) & TIM2_CCR4_CCR4_H); }
inline void tim2_ccr4_set_ccr4_l(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_L) | ((val<<0) & TIM2_CCR4_CCR4_L); }
inline uint32_t tim2_ccr4_get_ccr4_h(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_H) >> 16 ; }
inline uint32_t tim2_ccr4_get_ccr4_l(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_L) >> 0 ; }

// TIM2->DCR DMA control register
enum {
	TIM2_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM2_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim2_dcr_set_dbl(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBL) | ((val<<8) & TIM2_DCR_DBL); }
inline void tim2_dcr_set_dba(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBA) | ((val<<0) & TIM2_DCR_DBA); }
inline uint32_t tim2_dcr_get_dbl(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBL) >> 8 ; }
inline uint32_t tim2_dcr_get_dba(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBA) >> 0 ; }

// TIM2->AF1 TIM alternate function option register 1
enum {
	TIM2_AF1_ETRSEL = ((1UL<<4)-1) << 14, // ETR source selection		
};
inline void tim2_af1_set_etrsel(struct TIM2_Type* p, uint32_t val) { p->AF1 = (p->AF1 & ~TIM2_AF1_ETRSEL) | ((val<<14) & TIM2_AF1_ETRSEL); }
inline uint32_t tim2_af1_get_etrsel(struct TIM2_Type* p) { return (p->AF1 & TIM2_AF1_ETRSEL) >> 14 ; }

// TIM2->TISEL TIM timer input selection register
enum {
	TIM2_TISEL_TI4SEL = ((1UL<<4)-1) << 24, // TI4[0] to TI4[15] input selection
	TIM2_TISEL_TI3SEL = ((1UL<<4)-1) << 16, // TI3[0] to TI3[15] input selection
	TIM2_TISEL_TI2SEL = ((1UL<<4)-1) << 8, // TI2[0] to TI2[15] input selection
	TIM2_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // TI1[0] to TI1[15] input selection		
};
inline void tim2_tisel_set_ti4sel(struct TIM2_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM2_TISEL_TI4SEL) | ((val<<24) & TIM2_TISEL_TI4SEL); }
inline void tim2_tisel_set_ti3sel(struct TIM2_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM2_TISEL_TI3SEL) | ((val<<16) & TIM2_TISEL_TI3SEL); }
inline void tim2_tisel_set_ti2sel(struct TIM2_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM2_TISEL_TI2SEL) | ((val<<8) & TIM2_TISEL_TI2SEL); }
inline void tim2_tisel_set_ti1sel(struct TIM2_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM2_TISEL_TI1SEL) | ((val<<0) & TIM2_TISEL_TI1SEL); }
inline uint32_t tim2_tisel_get_ti4sel(struct TIM2_Type* p) { return (p->TISEL & TIM2_TISEL_TI4SEL) >> 24 ; }
inline uint32_t tim2_tisel_get_ti3sel(struct TIM2_Type* p) { return (p->TISEL & TIM2_TISEL_TI3SEL) >> 16 ; }
inline uint32_t tim2_tisel_get_ti2sel(struct TIM2_Type* p) { return (p->TISEL & TIM2_TISEL_TI2SEL) >> 8 ; }
inline uint32_t tim2_tisel_get_ti1sel(struct TIM2_Type* p) { return (p->TISEL & TIM2_TISEL_TI1SEL) >> 0 ; }




/* Basic timers */
struct TIM6_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[7]; // @5 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t SR; // @16 status register
	 uint8_t RESERVED3[3]; // @17 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[15]; // @21 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED5[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
};

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM6_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM6_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM6_CR1_URS = 1UL<<2, // Update request source
	TIM6_CR1_UDIS = 1UL<<1, // Update disable
	TIM6_CR1_CEN = 1UL<<0, // Counter enable		
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection		
};
inline void tim6_cr2_set_mms(struct TIM6_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val<<4) & TIM6_CR2_MMS); }
inline uint32_t tim6_cr2_get_mms(struct TIM6_Type* p) { return (p->CR2 & TIM6_CR2_MMS) >> 4 ; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM6_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL<<0, // Update generation		
};

// TIM6->CNT counter
enum {
	TIM6_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM6_CNT_CNT = ((1UL<<16)-1) << 0, // Low counter value		
};
inline void tim6_cnt_set_cnt(struct TIM6_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM6_CNT_CNT) | ((val<<0) & TIM6_CNT_CNT); }
inline uint32_t tim6_cnt_get_cnt(struct TIM6_Type* p) { return (p->CNT & TIM6_CNT_CNT) >> 0 ; }







/* Universal synchronous asynchronous receiver transmitter */
struct USART1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint16_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint16_t GTPR; // @16 Guard time and prescaler register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED2[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED3[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
	 uint8_t RESERVED4[2]; // @42 
	__IO uint8_t PRESC; // @44 USART prescaler register
};

// USART1->CR1 Control register 1
enum {
	USART1_CR1_RXFFIE = 1UL<<31, // RXFIFO Full interrupt enable
	USART1_CR1_TXFEIE = 1UL<<30, // TXFIFO empty interrupt enable
	USART1_CR1_FIFOEN = 1UL<<29, // FIFO mode enable
	USART1_CR1_M1 = 1UL<<28, // Word length
	USART1_CR1_EOBIE = 1UL<<27, // End of Block interrupt enable
	USART1_CR1_RTOIE = 1UL<<26, // Receiver timeout interrupt enable
	USART1_CR1_DEAT4 = 1UL<<25, // Driver Enable assertion time
	USART1_CR1_DEAT3 = 1UL<<24, // DEAT3
	USART1_CR1_DEAT2 = 1UL<<23, // DEAT2
	USART1_CR1_DEAT1 = 1UL<<22, // DEAT1
	USART1_CR1_DEAT0 = 1UL<<21, // DEAT0
	USART1_CR1_DEDT4 = 1UL<<20, // Driver Enable de-assertion time
	USART1_CR1_DEDT3 = 1UL<<19, // DEDT3
	USART1_CR1_DEDT2 = 1UL<<18, // DEDT2
	USART1_CR1_DEDT1 = 1UL<<17, // DEDT1
	USART1_CR1_DEDT0 = 1UL<<16, // DEDT0
	USART1_CR1_OVER8 = 1UL<<15, // Oversampling mode
	USART1_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	USART1_CR1_MME = 1UL<<13, // Mute mode enable
	USART1_CR1_M0 = 1UL<<12, // Word length
	USART1_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	USART1_CR1_PCE = 1UL<<10, // Parity control enable
	USART1_CR1_PS = 1UL<<9, // Parity selection
	USART1_CR1_PEIE = 1UL<<8, // PE interrupt enable
	USART1_CR1_TXEIE = 1UL<<7, // interrupt enable
	USART1_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	USART1_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	USART1_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	USART1_CR1_TE = 1UL<<3, // Transmitter enable
	USART1_CR1_RE = 1UL<<2, // Receiver enable
	USART1_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	USART1_CR1_UE = 1UL<<0, // USART enable		
};

// USART1->CR2 Control register 2
enum {
	USART1_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	USART1_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	USART1_CR2_RTOEN = 1UL<<23, // Receiver timeout enable
	USART1_CR2_ABRMOD1 = 1UL<<22, // Auto baud rate mode
	USART1_CR2_ABRMOD0 = 1UL<<21, // ABRMOD0
	USART1_CR2_ABREN = 1UL<<20, // Auto baud rate enable
	USART1_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	USART1_CR2_TAINV = 1UL<<18, // Binary data inversion
	USART1_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	USART1_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	USART1_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	USART1_CR2_LINEN = 1UL<<14, // LIN mode enable
	USART1_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	USART1_CR2_CLKEN = 1UL<<11, // Clock enable
	USART1_CR2_CPOL = 1UL<<10, // Clock polarity
	USART1_CR2_CPHA = 1UL<<9, // Clock phase
	USART1_CR2_LBCL = 1UL<<8, // Last bit clock pulse
	USART1_CR2_LBDIE = 1UL<<6, // LIN break detection interrupt enable
	USART1_CR2_LBDL = 1UL<<5, // LIN break detection length
	USART1_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection
	USART1_CR2_DIS_NSS = 1UL<<3, // When the DSI_NSS bit is set, the NSS pin input is ignored
	USART1_CR2_SLVEN = 1UL<<0, // Synchronous Slave mode enable		
};
inline void usart1_cr2_set_add4_7(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD4_7) | ((val<<28) & USART1_CR2_ADD4_7); }
inline void usart1_cr2_set_add0_3(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD0_3) | ((val<<24) & USART1_CR2_ADD0_3); }
inline void usart1_cr2_set_stop(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_STOP) | ((val<<12) & USART1_CR2_STOP); }
inline uint32_t usart1_cr2_get_add4_7(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD4_7) >> 28 ; }
inline uint32_t usart1_cr2_get_add0_3(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD0_3) >> 24 ; }
inline uint32_t usart1_cr2_get_stop(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_STOP) >> 12 ; }

// USART1->CR3 Control register 3
enum {
	USART1_CR3_TXFTCFG = ((1UL<<3)-1) << 29, // TXFIFO threshold configuration
	USART1_CR3_RXFTIE = 1UL<<28, // RXFIFO threshold interrupt enable
	USART1_CR3_RXFTCFG = ((1UL<<3)-1) << 25, // Receive FIFO threshold configuration
	USART1_CR3_TCBGTIE = 1UL<<24, // Transmission Complete before guard time, interrupt enable
	USART1_CR3_TXFTIE = 1UL<<23, // TXFIFO threshold interrupt enable
	USART1_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	USART1_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	USART1_CR3_SCARCNT = ((1UL<<3)-1) << 17, // Smartcard auto-retry count
	USART1_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	USART1_CR3_DEM = 1UL<<14, // Driver enable mode
	USART1_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	USART1_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	USART1_CR3_ONEBIT = 1UL<<11, // One sample bit method enable
	USART1_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	USART1_CR3_CTSE = 1UL<<9, // CTS enable
	USART1_CR3_RTSE = 1UL<<8, // RTS enable
	USART1_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	USART1_CR3_DMAR = 1UL<<6, // DMA enable receiver
	USART1_CR3_SCEN = 1UL<<5, // Smartcard mode enable
	USART1_CR3_NACK = 1UL<<4, // Smartcard NACK enable
	USART1_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	USART1_CR3_IRLP = 1UL<<2, // Ir low-power
	USART1_CR3_IREN = 1UL<<1, // Ir mode enable
	USART1_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void usart1_cr3_set_txftcfg(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_TXFTCFG) | ((val<<29) & USART1_CR3_TXFTCFG); }
inline void usart1_cr3_set_rxftcfg(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_RXFTCFG) | ((val<<25) & USART1_CR3_RXFTCFG); }
inline void usart1_cr3_set_wus(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_WUS) | ((val<<20) & USART1_CR3_WUS); }
inline void usart1_cr3_set_scarcnt(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_SCARCNT) | ((val<<17) & USART1_CR3_SCARCNT); }
inline uint32_t usart1_cr3_get_txftcfg(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_TXFTCFG) >> 29 ; }
inline uint32_t usart1_cr3_get_rxftcfg(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_RXFTCFG) >> 25 ; }
inline uint32_t usart1_cr3_get_wus(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_WUS) >> 20 ; }
inline uint32_t usart1_cr3_get_scarcnt(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_SCARCNT) >> 17 ; }

// USART1->BRR Baud rate register
enum {
	USART1_BRR_BRR_4_15 = ((1UL<<12)-1) << 4, // DIV_Mantissa
	USART1_BRR_BRR_0_3 = ((1UL<<4)-1) << 0, // DIV_Fraction		
};
inline void usart1_brr_set_brr_4_15(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_BRR_4_15) | ((val<<4) & USART1_BRR_BRR_4_15); }
inline void usart1_brr_set_brr_0_3(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_BRR_0_3) | ((val<<0) & USART1_BRR_BRR_0_3); }
inline uint32_t usart1_brr_get_brr_4_15(struct USART1_Type* p) { return (p->BRR & USART1_BRR_BRR_4_15) >> 4 ; }
inline uint32_t usart1_brr_get_brr_0_3(struct USART1_Type* p) { return (p->BRR & USART1_BRR_BRR_0_3) >> 0 ; }

// USART1->GTPR Guard time and prescaler register
enum {
	USART1_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	USART1_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
inline void usart1_gtpr_set_gt(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_GT) | ((val<<8) & USART1_GTPR_GT); }
inline void usart1_gtpr_set_psc(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_PSC) | ((val<<0) & USART1_GTPR_PSC); }
inline uint32_t usart1_gtpr_get_gt(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_GT) >> 8 ; }
inline uint32_t usart1_gtpr_get_psc(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_PSC) >> 0 ; }

// USART1->RTOR Receiver timeout register
enum {
	USART1_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	USART1_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
inline void usart1_rtor_set_blen(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_BLEN) | ((val<<24) & USART1_RTOR_BLEN); }
inline void usart1_rtor_set_rto(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_RTO) | ((val<<0) & USART1_RTOR_RTO); }
inline uint32_t usart1_rtor_get_blen(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_BLEN) >> 24 ; }
inline uint32_t usart1_rtor_get_rto(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_RTO) >> 0 ; }

// USART1->RQR Request register
enum {
	USART1_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	USART1_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	USART1_RQR_MMRQ = 1UL<<2, // Mute mode request
	USART1_RQR_SBKRQ = 1UL<<1, // Send break request
	USART1_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// USART1->ISR Interrupt & status register
enum {
	USART1_ISR_TXFT = 1UL<<27, // TXFIFO threshold flag
	USART1_ISR_RXFT = 1UL<<26, // RXFIFO threshold flag
	USART1_ISR_TCBGT = 1UL<<25, // Transmission complete before guard time flag
	USART1_ISR_RXFF = 1UL<<24, // RXFIFO Full
	USART1_ISR_TXFE = 1UL<<23, // TXFIFO Empty
	USART1_ISR_REACK = 1UL<<22, // REACK
	USART1_ISR_TEACK = 1UL<<21, // TEACK
	USART1_ISR_WUF = 1UL<<20, // WUF
	USART1_ISR_RWU = 1UL<<19, // RWU
	USART1_ISR_SBKF = 1UL<<18, // SBKF
	USART1_ISR_CMF = 1UL<<17, // CMF
	USART1_ISR_BUSY = 1UL<<16, // BUSY
	USART1_ISR_ABRF = 1UL<<15, // ABRF
	USART1_ISR_ABRE = 1UL<<14, // ABRE
	USART1_ISR_UDR = 1UL<<13, // SPI slave underrun error flag
	USART1_ISR_EOBF = 1UL<<12, // EOBF
	USART1_ISR_RTOF = 1UL<<11, // RTOF
	USART1_ISR_CTS = 1UL<<10, // CTS
	USART1_ISR_CTSIF = 1UL<<9, // CTSIF
	USART1_ISR_LBDF = 1UL<<8, // LBDF
	USART1_ISR_TXE = 1UL<<7, // TXE
	USART1_ISR_TC = 1UL<<6, // TC
	USART1_ISR_RXNE = 1UL<<5, // RXNE
	USART1_ISR_IDLE = 1UL<<4, // IDLE
	USART1_ISR_ORE = 1UL<<3, // ORE
	USART1_ISR_NF = 1UL<<2, // NF
	USART1_ISR_FE = 1UL<<1, // FE
	USART1_ISR_PE = 1UL<<0, // PE		
};

// USART1->ICR Interrupt flag clear register
enum {
	USART1_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	USART1_ICR_CMCF = 1UL<<17, // Character match clear flag
	USART1_ICR_UDRCF = 1UL<<13, // SPI slave underrun clear flag
	USART1_ICR_EOBCF = 1UL<<12, // End of block clear flag
	USART1_ICR_RTOCF = 1UL<<11, // Receiver timeout clear flag
	USART1_ICR_CTSCF = 1UL<<9, // CTS clear flag
	USART1_ICR_LBDCF = 1UL<<8, // LIN break detection clear flag
	USART1_ICR_TCBGTC = 1UL<<7, // Transmission complete before Guard time clear flag
	USART1_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	USART1_ICR_TXFECF = 1UL<<5, // TXFIFO empty clear flag
	USART1_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	USART1_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	USART1_ICR_NCF = 1UL<<2, // Noise detected clear flag
	USART1_ICR_FECF = 1UL<<1, // Framing error clear flag
	USART1_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// USART1->RDR Receive data register
enum {
	USART1_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t usart1_rdr_get_rdr(struct USART1_Type* p) { return (p->RDR & USART1_RDR_RDR) >> 0 ; }

// USART1->TDR Transmit data register
enum {
	USART1_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void usart1_tdr_set_tdr(struct USART1_Type* p, uint32_t val) { p->TDR = (p->TDR & ~USART1_TDR_TDR) | ((val<<0) & USART1_TDR_TDR); }
inline uint32_t usart1_tdr_get_tdr(struct USART1_Type* p) { return (p->TDR & USART1_TDR_TDR) >> 0 ; }

// USART1->PRESC USART prescaler register
enum {
	USART1_PRESC_PRESCALER = ((1UL<<4)-1) << 0, // Clock prescaler		
};
inline void usart1_presc_set_prescaler(struct USART1_Type* p, uint32_t val) { p->PRESC = (p->PRESC & ~USART1_PRESC_PRESCALER) | ((val<<0) & USART1_PRESC_PRESCALER); }
inline uint32_t usart1_presc_get_prescaler(struct USART1_Type* p) { return (p->PRESC & USART1_PRESC_PRESCALER) >> 0 ; }




/* VREFBUF */
struct VREFBUF_Type {
	__IO uint8_t CSR; // @0 VREFBUF control and status register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CCR; // @4 VREFBUF calibration control register
};

// VREFBUF->CSR VREFBUF control and status register
enum {
	VREFBUF_CSR_VRS = ((1UL<<3)-1) << 4, // Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
	VREFBUF_CSR_VRR = 1UL<<3, // Voltage reference buffer ready
	VREFBUF_CSR_HIZ = 1UL<<1, // High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
	VREFBUF_CSR_ENVR = 1UL<<0, // Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.		
};
inline void vrefbuf_csr_set_vrs(struct VREFBUF_Type* p, uint32_t val) { p->CSR = (p->CSR & ~VREFBUF_CSR_VRS) | ((val<<4) & VREFBUF_CSR_VRS); }
inline uint32_t vrefbuf_csr_get_vrs(struct VREFBUF_Type* p) { return (p->CSR & VREFBUF_CSR_VRS) >> 4 ; }

// VREFBUF->CCR VREFBUF calibration control register
enum {
	VREFBUF_CCR_TRIM = ((1UL<<6)-1) << 0, // Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.		
};
inline void vrefbuf_ccr_set_trim(struct VREFBUF_Type* p, uint32_t val) { p->CCR = (p->CCR & ~VREFBUF_CCR_TRIM) | ((val<<0) & VREFBUF_CCR_TRIM); }
inline uint32_t vrefbuf_ccr_get_trim(struct VREFBUF_Type* p) { return (p->CCR & VREFBUF_CCR_TRIM) >> 0 ; }

/* WWDG */
struct WWDG1_Type {
	__IO uint8_t CR; // @0 Control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CFR; // @4 Configuration register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint8_t SR; // @8 Status register
};

// WWDG1->CR Control register
enum {
	WWDG1_CR_WDGA = 1UL<<7, // Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.
	WWDG1_CR_T = ((1UL<<7)-1) << 0, // 7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).		
};
inline void wwdg1_cr_set_t(struct WWDG1_Type* p, uint32_t val) { p->CR = (p->CR & ~WWDG1_CR_T) | ((val<<0) & WWDG1_CR_T); }
inline uint32_t wwdg1_cr_get_t(struct WWDG1_Type* p) { return (p->CR & WWDG1_CR_T) >> 0 ; }

// WWDG1->CFR Configuration register
enum {
	WWDG1_CFR_WDGTB = ((1UL<<2)-1) << 11, // Timer base The time base of the prescaler can be modified as follows:
	WWDG1_CFR_EWI = 1UL<<9, // Early wakeup interrupt When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.
	WWDG1_CFR_W = ((1UL<<7)-1) << 0, // 7-bit window value These bits contain the window value to be compared to the downcounter.		
};
inline void wwdg1_cfr_set_wdgtb(struct WWDG1_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG1_CFR_WDGTB) | ((val<<11) & WWDG1_CFR_WDGTB); }
inline void wwdg1_cfr_set_w(struct WWDG1_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG1_CFR_W) | ((val<<0) & WWDG1_CFR_W); }
inline uint32_t wwdg1_cfr_get_wdgtb(struct WWDG1_Type* p) { return (p->CFR & WWDG1_CFR_WDGTB) >> 11 ; }
inline uint32_t wwdg1_cfr_get_w(struct WWDG1_Type* p) { return (p->CFR & WWDG1_CFR_W) >> 0 ; }

// WWDG1->SR Status register
enum {
	WWDG1_SR_EWIF = 1UL<<0, // Early wakeup interrupt flag This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled.		
};



#undef __I
#undef __O
#undef __IO


struct AC_Type	AC;	// @0xE000EF90 
struct ADC3_Type 	ADC1;	// @0x40022000
struct ADC3_Common_Type 	ADC12_Common;	// @0x40022300
struct ADC3_Type 	ADC2;	// @0x40022100
struct ADC3_Type	ADC3;	// @0x58026000 
struct ADC3_Common_Type	ADC3_Common;	// @0x58026300 
struct ART_Type	ART;	// @0x40024400 
struct AXI_Type	AXI;	// @0x51000000 
struct BDMA_Type	BDMA;	// @0x58025400 
struct CAN_CCU_Type	CAN_CCU;	// @0x4000A800 
struct CEC_Type	CEC;	// @0x40006C00 
struct COMP1_Type	COMP1;	// @0x58003800 
struct CRC_Type	CRC;	// @0x58024C00 
struct CRS_Type	CRS;	// @0x40008400 
struct CRYP_Type	CRYP;	// @0x48021000 
struct DAC_Type	DAC;	// @0x40007400 
struct DCMI_Type	DCMI;	// @0x48020000 
struct DELAY_Block_SDMMC1_Type 	DELAY_Block_QUADSPI;	// @0x52006000
struct DELAY_Block_SDMMC1_Type	DELAY_Block_SDMMC1;	// @0x52008000 
struct DELAY_Block_SDMMC1_Type 	DELAY_Block_SDMMC2;	// @0x48022800
struct DFSDM_Type	DFSDM;	// @0x40017000 
struct DMA1_Type	DMA1;	// @0x40020000 
struct DMA1_Type 	DMA2;	// @0x40020400
struct DMA2D_Type	DMA2D;	// @0x52001000 
struct DMAMUX1_Type	DMAMUX1;	// @0x40020800 Also: DMAMUX2_Type
struct DMAMUX2_Type	DMAMUX2;	// @0x58025800 
struct EXTI_Type	EXTI;	// @0x58000000 
struct Ethernet_MAC_Type	Ethernet_MAC;	// @0x40028000 
struct FDCAN1_Type	FDCAN1;	// @0x4000A000 
struct FDCAN1_Type 	FDCAN2;	// @0x4000A400
struct FMC_Type	FMC;	// @0x52004000 
struct FPU_Type	FPU;	// @0xE000EF34 
struct FPU_CPACR_Type	FPU_CPACR;	// @0xE000ED88 
struct Flash_Type	Flash;	// @0x52002000 
struct GPIOA_Type	GPIOA;	// @0x58020000 
struct GPIOA_Type 	GPIOB;	// @0x58020400
struct GPIOA_Type 	GPIOC;	// @0x58020800
struct GPIOA_Type 	GPIOD;	// @0x58020C00
struct GPIOA_Type 	GPIOE;	// @0x58021000
struct GPIOA_Type 	GPIOF;	// @0x58021400
struct GPIOA_Type 	GPIOG;	// @0x58021800
struct GPIOA_Type 	GPIOH;	// @0x58021C00
struct GPIOA_Type 	GPIOI;	// @0x58022000
struct GPIOA_Type 	GPIOJ;	// @0x58022400
struct GPIOA_Type 	GPIOK;	// @0x58022800
struct HASH_Type	HASH;	// @0x48021400 
struct HRTIM_Common_Type	HRTIM_Common;	// @0x40017780 
struct HRTIM_Master_Type	HRTIM_Master;	// @0x40017400 
struct HRTIM_TIMA_Type	HRTIM_TIMA;	// @0x40017480 
struct HRTIM_TIMB_Type	HRTIM_TIMB;	// @0x40017500 
struct HRTIM_TIMC_Type	HRTIM_TIMC;	// @0x40017580 
struct HRTIM_TIMD_Type	HRTIM_TIMD;	// @0x40017600 
struct HRTIM_TIME_Type	HRTIM_TIME;	// @0x40017680 
struct HSEM_Type	HSEM;	// @0x58026400 
struct I2C1_Type	I2C1;	// @0x40005400 
struct I2C1_Type 	I2C2;	// @0x40005800
struct I2C1_Type 	I2C3;	// @0x40005C00
struct I2C1_Type 	I2C4;	// @0x58001C00
struct IWDG1_Type	IWDG1;	// @0x58004800 
struct IWDG1_Type 	IWDG2;	// @0x58004C00
struct JPEG_Type	JPEG;	// @0x52003000 
struct LPTIM1_Type	LPTIM1;	// @0x40002400 Also: LPTIM3_Type
struct LPTIM1_Type 	LPTIM2;	// @0x58002400
struct LPTIM3_Type	LPTIM3;	// @0x58002800 
struct LPTIM3_Type 	LPTIM4;	// @0x58002C00
struct LPTIM3_Type 	LPTIM5;	// @0x58003000
struct LPUART1_Type	LPUART1;	// @0x58000C00 
struct LTDC_Type	LTDC;	// @0x50001000 
struct MDIOS_Type	MDIOS;	// @0x40009400 
struct MDMA_Type	MDMA;	// @0x52000000 
struct MPU_Type	MPU;	// @0xE000ED90 
struct NVIC_Type	NVIC;	// @0xE000E100 
struct NVIC_STIR_Type	NVIC_STIR;	// @0xE000EF00 
struct OPAMP_Type	OPAMP;	// @0x40009000 
struct OTG1_HS_DEVICE_Type	OTG1_HS_DEVICE;	// @0x40040800 
struct OTG1_HS_GLOBAL_Type	OTG1_HS_GLOBAL;	// @0x40040000 
struct OTG1_HS_HOST_Type	OTG1_HS_HOST;	// @0x40040400 
struct OTG1_HS_PWRCLK_Type	OTG1_HS_PWRCLK;	// @0x40040E00 
struct OTG1_HS_DEVICE_Type 	OTG2_HS_DEVICE;	// @0x40080800
struct OTG1_HS_GLOBAL_Type 	OTG2_HS_GLOBAL;	// @0x40080000
struct OTG1_HS_HOST_Type 	OTG2_HS_HOST;	// @0x40080400
struct OTG1_HS_PWRCLK_Type 	OTG2_HS_PWRCLK;	// @0x40080E00
struct PF_Type	PF;	// @0xE000ED78 
struct PWR_Type	PWR;	// @0x58024800 
struct QUADSPI_Type	QUADSPI;	// @0x52005000 
struct RAMECC1_Type	RAMECC1;	// @0x52009000 
struct RAMECC2_Type	RAMECC2;	// @0x48023000 Also: RAMECC3_Type
struct RAMECC3_Type	RAMECC3;	// @0x58027000 
struct RCC_Type	RCC;	// @0x58024400 
struct RNG_Type	RNG;	// @0x48021800 
struct RTC_Type	RTC;	// @0x58004000 
struct SAI4_Type 	SAI1;	// @0x40015800
struct SAI4_Type 	SAI2;	// @0x40015C00
struct SAI4_Type 	SAI3;	// @0x40016000
struct SAI4_Type	SAI4;	// @0x58005400 
struct SCB_Type	SCB;	// @0xE000ED00 
struct SCB_ACTRL_Type	SCB_ACTRL;	// @0xE000E008 
struct SDMMC1_Type	SDMMC1;	// @0x52007000 
struct SDMMC1_Type 	SDMMC2;	// @0x48022400
struct SPDIFRX_Type	SPDIFRX;	// @0x40004000 
struct SPI1_Type	SPI1;	// @0x40013000 
struct SPI1_Type 	SPI2;	// @0x40003800
struct SPI1_Type 	SPI3;	// @0x40003C00
struct SPI1_Type 	SPI4;	// @0x40013400
struct SPI1_Type 	SPI5;	// @0x40015000
struct SPI1_Type 	SPI6;	// @0x58001400
struct STK_Type	STK;	// @0xE000E010 
struct SWPMI_Type	SWPMI;	// @0x40008800 
struct SYSCFG_Type	SYSCFG;	// @0x58000400 
struct TIM1_Type	TIM1;	// @0x40010000 Also: TIM6_Type
struct TIM2_Type 	TIM12;	// @0x40001800
struct TIM2_Type 	TIM13;	// @0x40001C00
struct TIM2_Type 	TIM14;	// @0x40002000
struct TIM15_Type	TIM15;	// @0x40014000 Also: TIM6_Type
struct TIM16_Type	TIM16;	// @0x40014400 
struct TIM17_Type	TIM17;	// @0x40014800 
struct TIM2_Type	TIM2;	// @0x40000000 
struct TIM2_Type 	TIM3;	// @0x40000400
struct TIM2_Type 	TIM4;	// @0x40000800
struct TIM2_Type 	TIM5;	// @0x40000C00
struct TIM6_Type	TIM6;	// @0x40001000 
struct TIM6_Type 	TIM7;	// @0x40001400
struct TIM1_Type 	TIM8;	// @0x40010400
struct USART1_Type 	UART4;	// @0x40004C00
struct USART1_Type 	UART5;	// @0x40005000
struct USART1_Type 	UART7;	// @0x40007800
struct USART1_Type 	UART8;	// @0x40007C00
struct USART1_Type	USART1;	// @0x40011000 
struct USART1_Type 	USART2;	// @0x40004400
struct USART1_Type 	USART3;	// @0x40004800
struct USART1_Type 	USART6;	// @0x40011400
struct VREFBUF_Type	VREFBUF;	// @0x58003C00 
struct WWDG1_Type	WWDG1;	// @0x50003000 
struct WWDG1_Type 	WWDG2;	// @0x40002C00

