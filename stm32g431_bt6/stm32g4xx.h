#pragma once

// Generated enums and structures for device STM32G4xx version 2.0
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16,  // 0 position of estack reset pointer
	Reset_IRQn = -15,  // 1 Reset, not a real IRQ

	//  Cortex-CM4 Processor Exceptions Numbers
	NonMaskableInt_IRQn	  = -14,  // 2 Non Maskable Interrupt
	Reserved_3_IRQn		  = -13,
	MemoryManagement_IRQn = -12,  // 4 Memory Management Interrupt
	BusFault_IRQn		  = -11,  // 5 Bus Fault Interrupt
	UsageFault_IRQn		  = -10,  // 6 Usage Fault Interrupt
	Reserved_7_IRQn		  = -9,
	Reserved_8_IRQn		  = -8,
	Reserved_9_IRQn		  = -7,
	Reserved_10_IRQn	  = -6,
	SVCall_IRQn			  = -5,	 // 11 SV Call Interrupt
	DebugMonitor_IRQn	  = -4,	 // 12 Debug Monitor Interrupt
	Reserved_13_IRQn	  = -3,
	PendSV_IRQn			  = -2,	 // 14 Pend SV Interrupt
	SysTick_IRQn		  = -1,	 // 15 System Tick Interrupt

	//  Device specific Interrupt Numbers
	WWDG_IRQn				= 0,	// Window Watchdog interrupt
	PVD_PVM_IRQn			= 1,	// PVD through EXTI line detection
	RTC_TAMP_CSS_LSE_IRQn	= 2,	// RTC_TAMP_CSS_LSE
	RTC_WKUP_IRQn			= 3,	// RTC Wakeup timer
	FLASH_IRQn				= 4,	// FLASH
	RCC_IRQn				= 5,	// RCC global interrupt
	EXTI0_IRQn				= 6,	// EXTI Line0 interrupt
	EXTI1_IRQn				= 7,	// EXTI Line1 interrupt
	EXTI2_IRQn				= 8,	// EXTI Line2 interrupt
	EXTI3_IRQn				= 9,	// EXTI Line3 interrupt
	EXTI4_IRQn				= 10,	// EXTI Line4 interrupt
	DMA1_CH1_IRQn			= 11,	// DMA1 channel 1 interrupt
	DMA1_CH2_IRQn			= 12,	// DMA1 channel 2 interrupt
	DMA1_CH3_IRQn			= 13,	// DMA1 channel 3 interrupt
	DMA1_CH4_IRQn			= 14,	// DMA1 channel 4 interrupt
	DMA1_CH5_IRQn			= 15,	// DMA1 channel 5 interrupt
	DMA1_CH6_IRQn			= 16,	// DMA1 channel 6 interrupt
	DMA1_CH7_IRQn			= 17,	// DMA1 channel 7 interrupt
	ADC1_2_IRQn				= 18,	// ADC1 and ADC2 global interrupt
	USB_HP_IRQn				= 19,	// USB_HP
	USB_LP_IRQn				= 20,	// USB_LP
	FDCAN1_IT0_IRQn			= 21,	// FDCAN1 interrupt 0
	FDCAN1_IT1_IRQn			= 22,	// FDCAN1 interrupt 1
	EXTI9_5_IRQn			= 23,	// EXTI9_5
	TIM1_BRK_TIM15_IRQn		= 24,	// TIM1_BRK_TIM15
	TIM1_UP_TIM16_IRQn		= 25,	// TIM1_UP_TIM16
	TIM1_TRG_COM_IRQn		= 26,	// TIM1_TRG_COM/
	TIM1_CC_IRQn			= 27,	// TIM1 capture compare interrupt
	TIM2_IRQn				= 28,	// TIM2
	TIM3_IRQn				= 29,	// TIM3
	TIM4_IRQn				= 30,	// TIM4
	I2C1_EV_IRQn			= 31,	// I2C1_EV
	I2C1_ER_IRQn			= 32,	// I2C1_ER
	I2C2_EV_IRQn			= 33,	// I2C2_EV
	I2C2_ER_IRQn			= 34,	// I2C2_ER
	SPI1_IRQn				= 35,	// SPI1
	SPI2_IRQn				= 36,	// SPI2
	USART1_IRQn				= 37,	// USART1
	USART2_IRQn				= 38,	// USART2
	USART3_IRQn				= 39,	// USART3
	EXTI15_10_IRQn			= 40,	// EXTI15_10
	RTC_ALARM_IRQn			= 41,	// RTC_ALARM
	USBWakeUP_IRQn			= 42,	// USBWakeUP
	TIM8_BRK_IRQn			= 43,	// TIM8_BRK
	TIM8_UP_IRQn			= 44,	// TIM8_UP
	TIM8_TRG_COM_IRQn		= 45,	// TIM8_TRG_COM
	TIM8_CC_IRQn			= 46,	// TIM8_CC
	ADC3_IRQn				= 47,	// ADC3
	FMC_IRQn				= 48,	// FMC
	LPTIM1_IRQn				= 49,	// LPTIM1
	TIM5_IRQn				= 50,	// TIM5
	SPI3_IRQn				= 51,	// SPI3
	UART4_IRQn				= 52,	// UART4
	UART5_IRQn				= 53,	// UART5
	TIM6_DACUNDER_IRQn		= 54,	// TIM6_DACUNDER
	TIM7_IRQn				= 55,	// TIM7
	DMA2_CH1_IRQn			= 56,	// DMA2_CH1
	DMA2_CH2_IRQn			= 57,	// DMA2_CH2
	DMA2_CH3_IRQn			= 58,	// DMA2_CH3
	DMA2_CH4_IRQn			= 59,	// DMA2_CH4
	DMA2_CH5_IRQn			= 60,	// DMA2_CH5
	ADC4_IRQn				= 61,	// ADC4
	ADC5_IRQn				= 62,	// ADC5
	UCPD1_IRQn				= 63,	// UCPD1
	COMP1_2_3_IRQn			= 64,	// COMP1_2_3
	COMP4_5_6_IRQn			= 65,	// COMP4_5_6
	COMP7_IRQn				= 66,	// COMP7
	HRTIM_Master_IRQn_IRQn	= 67,	// HRTIM_Master_IRQn
	HRTIM_TIMA_IRQn_IRQn	= 68,	// HRTIM_TIMA_IRQn
	HRTIM_TIMB_IRQn_IRQn	= 69,	// HRTIM_TIMB_IRQn
	HRTIM_TIMC_IRQn_IRQn	= 70,	// HRTIM_TIMC_IRQn
	HRTIM_TIMD_IRQn_IRQn	= 71,	// HRTIM_TIMD_IRQn
	HRTIM_TIME_IRQn_IRQn	= 72,	// HRTIM_TIME_IRQn
	HRTIM_TIM_FLT_IRQn_IRQn = 73,	// HRTIM_TIM_FLT_IRQn
	HRTIM_TIMF_IRQn_IRQn	= 74,	// HRTIM_TIMF_IRQn
	CRS_IRQn				= 75,	// CRS
	SAI_IRQn				= 76,	// SAI
	TIM20_BRK_IRQn			= 77,	// TIM20_BRK
	TIM20_UP_IRQn			= 78,	// TIM20_UP
	TIM20_TRG_COM_IRQn		= 79,	// TIM20_TRG_COM
	TIM20_CC_IRQn			= 80,	// TIM20_CC
	FPU_IRQn				= 81,	// Floating point unit interrupt
	I2C4_EV_IRQn			= 82,	// I2C4_EV
	I2C4_ER_IRQn			= 83,	// I2C4_ER
	SPI4_IRQn				= 84,	// SPI4
	AES_IRQn				= 85,	// AES
	FDCAN2_IT0_IRQn			= 86,	// FDCAN2 interrupt 0
	FDCAN2_IT1_IRQn			= 87,	// FDCAN2 interrupt 1
	FDCAN3_IT0_IRQn			= 88,	// FDCAN3 interrupt 0
	FDCAN3_IT1_IRQn			= 89,	// FDCAN3 interrupt 1
	RNG_IRQn				= 90,	// RNG
	LPUART_IRQn				= 91,	// LPUART
	I2C3_EV_IRQn			= 92,	// I2C3_EV
	I2C3_ER_IRQn			= 93,	// I2C3_ER
	DMAMUX_OVR_IRQn			= 94,	// DMAMUX_OVR
	QUADSPI_IRQn			= 95,	// QUADSPI
	DMA1_CH8_IRQn			= 96,	// DMA1_CH8
	DMA2_CH6_IRQn			= 97,	// DMA2_CH6
	DMA2_CH7_IRQn			= 98,	// DMA2_CH7
	DMA2_CH8_IRQn			= 99,	// DMA2_CH8
	Cordic_IRQn				= 100,	// Cordic
	FMAC_IRQn				= 101,	// FMAC
};

#define __I volatile const	// 'read only' permissions
#define __O volatile		// 'write only' permissions
#define __IO volatile		// 'read / write' permissions

/* Analog-to-Digital Converter */
struct ADC1_Type {
	__IO uint16_t ISR;			   // @0 interrupt and status register
	uint8_t		  RESERVED0[2];	   // @2
	__IO uint16_t IER;			   // @4 interrupt enable register
	uint8_t		  RESERVED1[2];	   // @6
	__IO uint32_t CR;			   // @8 control register
	__IO uint32_t CFGR;			   // @12 configuration register
	__IO uint32_t CFGR2;		   // @16 configuration register
	__IO uint32_t SMPR1;		   // @20 sample time register 1
	__IO uint32_t SMPR2;		   // @24 sample time register 2
	uint8_t		  RESERVED2[4];	   // @28
	__IO uint32_t TR1;			   // @32 watchdog threshold register 1
	__IO uint32_t TR2;			   // @36 watchdog threshold register
	__IO uint32_t TR3;			   // @40 watchdog threshold register 3
	uint8_t		  RESERVED3[4];	   // @44
	__IO uint32_t SQR1;			   // @48 regular sequence register 1
	__IO uint32_t SQR2;			   // @52 regular sequence register 2
	__IO uint32_t SQR3;			   // @56 regular sequence register 3
	__IO uint16_t SQR4;			   // @60 regular sequence register 4
	uint8_t		  RESERVED4[2];	   // @62
	__I uint16_t  DR;			   // @64 regular Data Register
	uint8_t		  RESERVED5[10];   // @66
	__IO uint32_t JSQR;			   // @76 injected sequence register
	uint8_t		  RESERVED6[16];   // @80
	__IO uint32_t OFR1;			   // @96 offset register 1
	__IO uint32_t OFR2;			   // @100 offset register 2
	__IO uint32_t OFR3;			   // @104 offset register 3
	__IO uint32_t OFR4;			   // @108 offset register 4
	uint8_t		  RESERVED7[16];   // @112
	__I uint16_t  JDR1;			   // @128 injected data register 1
	uint8_t		  RESERVED8[2];	   // @130
	__I uint16_t  JDR2;			   // @132 injected data register 2
	uint8_t		  RESERVED9[2];	   // @134
	__I uint16_t  JDR3;			   // @136 injected data register 3
	uint8_t		  RESERVED10[2];   // @138
	__I uint16_t  JDR4;			   // @140 injected data register 4
	uint8_t		  RESERVED11[18];  // @142
	__IO uint32_t AWD2CR;		   // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR;		   // @164 Analog Watchdog 3 Configuration Register
	uint8_t		  RESERVED12[8];   // @168
	__IO uint32_t DIFSEL;		   // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT;		   // @180 Calibration Factors
	uint8_t		  RESERVED13[8];   // @184
	__IO uint16_t GCOMP;		   // @192 Gain compensation Register
};

// ADC1->ISR interrupt and status register
enum {
	ADC1_ISR_JQOVF = 1UL << 10,	 // JQOVF
	ADC1_ISR_AWD3  = 1UL << 9,	 // AWD3
	ADC1_ISR_AWD2  = 1UL << 8,	 // AWD2
	ADC1_ISR_AWD1  = 1UL << 7,	 // AWD1
	ADC1_ISR_JEOS  = 1UL << 6,	 // JEOS
	ADC1_ISR_JEOC  = 1UL << 5,	 // JEOC
	ADC1_ISR_OVR   = 1UL << 4,	 // OVR
	ADC1_ISR_EOS   = 1UL << 3,	 // EOS
	ADC1_ISR_EOC   = 1UL << 2,	 // EOC
	ADC1_ISR_EOSMP = 1UL << 1,	 // EOSMP
	ADC1_ISR_ADRDY = 1UL << 0,	 // ADRDY
};

// ADC1->IER interrupt enable register
enum {
	ADC1_IER_JQOVFIE = 1UL << 10,  // JQOVFIE
	ADC1_IER_AWD3IE	 = 1UL << 9,   // AWD3IE
	ADC1_IER_AWD2IE	 = 1UL << 8,   // AWD2IE
	ADC1_IER_AWD1IE	 = 1UL << 7,   // AWD1IE
	ADC1_IER_JEOSIE	 = 1UL << 6,   // JEOSIE
	ADC1_IER_JEOCIE	 = 1UL << 5,   // JEOCIE
	ADC1_IER_OVRIE	 = 1UL << 4,   // OVRIE
	ADC1_IER_EOSIE	 = 1UL << 3,   // EOSIE
	ADC1_IER_EOCIE	 = 1UL << 2,   // EOCIE
	ADC1_IER_EOSMPIE = 1UL << 1,   // EOSMPIE
	ADC1_IER_ADRDYIE = 1UL << 0,   // ADRDYIE
};

// ADC1->CR control register
enum {
	ADC1_CR_ADCAL	 = 1UL << 31,  // ADCAL
	ADC1_CR_ADCALDIF = 1UL << 30,  // ADCALDIF
	ADC1_CR_DEEPPWD	 = 1UL << 29,  // DEEPPWD
	ADC1_CR_ADVREGEN = 1UL << 28,  // ADVREGEN
	ADC1_CR_JADSTP	 = 1UL << 5,   // JADSTP
	ADC1_CR_ADSTP	 = 1UL << 4,   // ADSTP
	ADC1_CR_JADSTART = 1UL << 3,   // JADSTART
	ADC1_CR_ADSTART	 = 1UL << 2,   // ADSTART
	ADC1_CR_ADDIS	 = 1UL << 1,   // ADDIS
	ADC1_CR_ADEN	 = 1UL << 0,   // ADEN
};

// ADC1->CFGR configuration register
enum {
	ADC1_CFGR_JQDIS	  = 1UL << 31,				 // Injected Queue disable
	ADC1_CFGR_AWD1CH  = ((1UL << 5) - 1) << 26,	 // Analog watchdog 1 channel selection
	ADC1_CFGR_JAUTO	  = 1UL << 25,				 // JAUTO
	ADC1_CFGR_JAWD1EN = 1UL << 24,				 // JAWD1EN
	ADC1_CFGR_AWD1EN  = 1UL << 23,				 // AWD1EN
	ADC1_CFGR_AWD1SGL = 1UL << 22,				 // AWD1SGL
	ADC1_CFGR_JQM	  = 1UL << 21,				 // JQM
	ADC1_CFGR_JDISCEN = 1UL << 20,				 // JDISCEN
	ADC1_CFGR_DISCNUM = ((1UL << 3) - 1) << 17,	 // DISCNUM
	ADC1_CFGR_DISCEN  = 1UL << 16,				 // DISCEN
	ADC1_CFGR_ALIGN	  = 1UL << 15,				 // ALIGN
	ADC1_CFGR_AUTDLY  = 1UL << 14,				 // AUTDLY
	ADC1_CFGR_CONT	  = 1UL << 13,				 // CONT
	ADC1_CFGR_OVRMOD  = 1UL << 12,				 // OVRMOD
	ADC1_CFGR_EXTEN	  = ((1UL << 2) - 1) << 10,	 // EXTEN
	ADC1_CFGR_EXTSEL  = ((1UL << 5) - 1) << 5,	 // External trigger selection for regular group
	ADC1_CFGR_RES	  = ((1UL << 2) - 1) << 3,	 // RES
	ADC1_CFGR_DMACFG  = 1UL << 1,				 // DMACFG
	ADC1_CFGR_DMAEN	  = 1UL << 0,				 // DMAEN
};
inline void adc1_cfgr_set_awd1ch(struct ADC1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_AWD1CH) | ((val << 26) & ADC1_CFGR_AWD1CH);
}
inline void adc1_cfgr_set_discnum(struct ADC1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_DISCNUM) | ((val << 17) & ADC1_CFGR_DISCNUM);
}
inline void adc1_cfgr_set_exten(struct ADC1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_EXTEN) | ((val << 10) & ADC1_CFGR_EXTEN);
}
inline void adc1_cfgr_set_extsel(struct ADC1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_EXTSEL) | ((val << 5) & ADC1_CFGR_EXTSEL);
}
inline void adc1_cfgr_set_res(struct ADC1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_RES) | ((val << 3) & ADC1_CFGR_RES);
}
inline uint32_t adc1_cfgr_get_awd1ch(struct ADC1_Type *p) { return (p->CFGR & ADC1_CFGR_AWD1CH) >> 26; }
inline uint32_t adc1_cfgr_get_discnum(struct ADC1_Type *p) { return (p->CFGR & ADC1_CFGR_DISCNUM) >> 17; }
inline uint32_t adc1_cfgr_get_exten(struct ADC1_Type *p) { return (p->CFGR & ADC1_CFGR_EXTEN) >> 10; }
inline uint32_t adc1_cfgr_get_extsel(struct ADC1_Type *p) { return (p->CFGR & ADC1_CFGR_EXTSEL) >> 5; }
inline uint32_t adc1_cfgr_get_res(struct ADC1_Type *p) { return (p->CFGR & ADC1_CFGR_RES) >> 3; }

// ADC1->CFGR2 configuration register
enum {
	ADC1_CFGR2_SMPTRIG = 1UL << 27,				 // SMPTRIG
	ADC1_CFGR2_BULB	   = 1UL << 26,				 // BULB
	ADC1_CFGR2_SWTRIG  = 1UL << 25,				 // SWTRIG
	ADC1_CFGR2_GCOMP   = 1UL << 16,				 // GCOMP
	ADC1_CFGR2_ROVSM   = 1UL << 10,				 // EXTEN
	ADC1_CFGR2_TROVS   = 1UL << 9,				 // Triggered Regular Oversampling
	ADC1_CFGR2_OVSS	   = ((1UL << 4) - 1) << 5,	 // ALIGN
	ADC1_CFGR2_OVSR	   = ((1UL << 3) - 1) << 2,	 // RES
	ADC1_CFGR2_JOVSE   = 1UL << 1,				 // DMACFG
	ADC1_CFGR2_ROVSE   = 1UL << 0,				 // DMAEN
};
inline void adc1_cfgr2_set_ovss(struct ADC1_Type *p, uint32_t val) {
	p->CFGR2 = (p->CFGR2 & ~ADC1_CFGR2_OVSS) | ((val << 5) & ADC1_CFGR2_OVSS);
}
inline void adc1_cfgr2_set_ovsr(struct ADC1_Type *p, uint32_t val) {
	p->CFGR2 = (p->CFGR2 & ~ADC1_CFGR2_OVSR) | ((val << 2) & ADC1_CFGR2_OVSR);
}
inline uint32_t adc1_cfgr2_get_ovss(struct ADC1_Type *p) { return (p->CFGR2 & ADC1_CFGR2_OVSS) >> 5; }
inline uint32_t adc1_cfgr2_get_ovsr(struct ADC1_Type *p) { return (p->CFGR2 & ADC1_CFGR2_OVSR) >> 2; }

// ADC1->SMPR1 sample time register 1
enum {
	ADC1_SMPR1_SMPPLUS = 1UL << 31,				  // Addition of one clock cycle to the sampling time
	ADC1_SMPR1_SMP9	   = ((1UL << 3) - 1) << 27,  // SMP9
	ADC1_SMPR1_SMP8	   = ((1UL << 3) - 1) << 24,  // SMP8
	ADC1_SMPR1_SMP7	   = ((1UL << 3) - 1) << 21,  // SMP7
	ADC1_SMPR1_SMP6	   = ((1UL << 3) - 1) << 18,  // SMP6
	ADC1_SMPR1_SMP5	   = ((1UL << 3) - 1) << 15,  // SMP5
	ADC1_SMPR1_SMP4	   = ((1UL << 3) - 1) << 12,  // SMP4
	ADC1_SMPR1_SMP3	   = ((1UL << 3) - 1) << 9,	  // SMP3
	ADC1_SMPR1_SMP2	   = ((1UL << 3) - 1) << 6,	  // SMP2
	ADC1_SMPR1_SMP1	   = ((1UL << 3) - 1) << 3,	  // SMP1
	ADC1_SMPR1_SMP0	   = ((1UL << 3) - 1) << 0,	  // SMP0
};
inline void adc1_smpr1_set_smp9(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP9) | ((val << 27) & ADC1_SMPR1_SMP9);
}
inline void adc1_smpr1_set_smp8(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP8) | ((val << 24) & ADC1_SMPR1_SMP8);
}
inline void adc1_smpr1_set_smp7(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP7) | ((val << 21) & ADC1_SMPR1_SMP7);
}
inline void adc1_smpr1_set_smp6(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP6) | ((val << 18) & ADC1_SMPR1_SMP6);
}
inline void adc1_smpr1_set_smp5(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP5) | ((val << 15) & ADC1_SMPR1_SMP5);
}
inline void adc1_smpr1_set_smp4(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP4) | ((val << 12) & ADC1_SMPR1_SMP4);
}
inline void adc1_smpr1_set_smp3(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP3) | ((val << 9) & ADC1_SMPR1_SMP3);
}
inline void adc1_smpr1_set_smp2(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP2) | ((val << 6) & ADC1_SMPR1_SMP2);
}
inline void adc1_smpr1_set_smp1(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP1) | ((val << 3) & ADC1_SMPR1_SMP1);
}
inline void adc1_smpr1_set_smp0(struct ADC1_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP0) | ((val << 0) & ADC1_SMPR1_SMP0);
}
inline uint32_t adc1_smpr1_get_smp9(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP9) >> 27; }
inline uint32_t adc1_smpr1_get_smp8(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP8) >> 24; }
inline uint32_t adc1_smpr1_get_smp7(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP7) >> 21; }
inline uint32_t adc1_smpr1_get_smp6(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP6) >> 18; }
inline uint32_t adc1_smpr1_get_smp5(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP5) >> 15; }
inline uint32_t adc1_smpr1_get_smp4(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP4) >> 12; }
inline uint32_t adc1_smpr1_get_smp3(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP3) >> 9; }
inline uint32_t adc1_smpr1_get_smp2(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP2) >> 6; }
inline uint32_t adc1_smpr1_get_smp1(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP1) >> 3; }
inline uint32_t adc1_smpr1_get_smp0(struct ADC1_Type *p) { return (p->SMPR1 & ADC1_SMPR1_SMP0) >> 0; }

// ADC1->SMPR2 sample time register 2
enum {
	ADC1_SMPR2_SMP18 = ((1UL << 3) - 1) << 24,	// SMP18
	ADC1_SMPR2_SMP17 = ((1UL << 3) - 1) << 21,	// SMP17
	ADC1_SMPR2_SMP16 = ((1UL << 3) - 1) << 18,	// SMP16
	ADC1_SMPR2_SMP15 = ((1UL << 3) - 1) << 15,	// SMP15
	ADC1_SMPR2_SMP14 = ((1UL << 3) - 1) << 12,	// SMP14
	ADC1_SMPR2_SMP13 = ((1UL << 3) - 1) << 9,	// SMP13
	ADC1_SMPR2_SMP12 = ((1UL << 3) - 1) << 6,	// SMP12
	ADC1_SMPR2_SMP11 = ((1UL << 3) - 1) << 3,	// SMP11
	ADC1_SMPR2_SMP10 = ((1UL << 3) - 1) << 0,	// SMP10
};
inline void adc1_smpr2_set_smp18(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP18) | ((val << 24) & ADC1_SMPR2_SMP18);
}
inline void adc1_smpr2_set_smp17(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP17) | ((val << 21) & ADC1_SMPR2_SMP17);
}
inline void adc1_smpr2_set_smp16(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP16) | ((val << 18) & ADC1_SMPR2_SMP16);
}
inline void adc1_smpr2_set_smp15(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP15) | ((val << 15) & ADC1_SMPR2_SMP15);
}
inline void adc1_smpr2_set_smp14(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP14) | ((val << 12) & ADC1_SMPR2_SMP14);
}
inline void adc1_smpr2_set_smp13(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP13) | ((val << 9) & ADC1_SMPR2_SMP13);
}
inline void adc1_smpr2_set_smp12(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP12) | ((val << 6) & ADC1_SMPR2_SMP12);
}
inline void adc1_smpr2_set_smp11(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP11) | ((val << 3) & ADC1_SMPR2_SMP11);
}
inline void adc1_smpr2_set_smp10(struct ADC1_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP10) | ((val << 0) & ADC1_SMPR2_SMP10);
}
inline uint32_t adc1_smpr2_get_smp18(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP18) >> 24; }
inline uint32_t adc1_smpr2_get_smp17(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP17) >> 21; }
inline uint32_t adc1_smpr2_get_smp16(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP16) >> 18; }
inline uint32_t adc1_smpr2_get_smp15(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP15) >> 15; }
inline uint32_t adc1_smpr2_get_smp14(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP14) >> 12; }
inline uint32_t adc1_smpr2_get_smp13(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP13) >> 9; }
inline uint32_t adc1_smpr2_get_smp12(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP12) >> 6; }
inline uint32_t adc1_smpr2_get_smp11(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP11) >> 3; }
inline uint32_t adc1_smpr2_get_smp10(struct ADC1_Type *p) { return (p->SMPR2 & ADC1_SMPR2_SMP10) >> 0; }

// ADC1->TR1 watchdog threshold register 1
enum {
	ADC1_TR1_HT1	 = ((1UL << 12) - 1) << 16,	 // HT1
	ADC1_TR1_AWDFILT = ((1UL << 3) - 1) << 12,	 // AWDFILT
	ADC1_TR1_LT1	 = ((1UL << 12) - 1) << 0,	 // LT1
};
inline void adc1_tr1_set_ht1(struct ADC1_Type *p, uint32_t val) {
	p->TR1 = (p->TR1 & ~ADC1_TR1_HT1) | ((val << 16) & ADC1_TR1_HT1);
}
inline void adc1_tr1_set_awdfilt(struct ADC1_Type *p, uint32_t val) {
	p->TR1 = (p->TR1 & ~ADC1_TR1_AWDFILT) | ((val << 12) & ADC1_TR1_AWDFILT);
}
inline void adc1_tr1_set_lt1(struct ADC1_Type *p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC1_TR1_LT1) | ((val << 0) & ADC1_TR1_LT1); }
inline uint32_t adc1_tr1_get_ht1(struct ADC1_Type *p) { return (p->TR1 & ADC1_TR1_HT1) >> 16; }
inline uint32_t adc1_tr1_get_awdfilt(struct ADC1_Type *p) { return (p->TR1 & ADC1_TR1_AWDFILT) >> 12; }
inline uint32_t adc1_tr1_get_lt1(struct ADC1_Type *p) { return (p->TR1 & ADC1_TR1_LT1) >> 0; }

// ADC1->TR2 watchdog threshold register
enum {
	ADC1_TR2_HT2 = ((1UL << 8) - 1) << 16,	// HT2
	ADC1_TR2_LT2 = ((1UL << 8) - 1) << 0,	// LT2
};
inline void adc1_tr2_set_ht2(struct ADC1_Type *p, uint32_t val) {
	p->TR2 = (p->TR2 & ~ADC1_TR2_HT2) | ((val << 16) & ADC1_TR2_HT2);
}
inline void adc1_tr2_set_lt2(struct ADC1_Type *p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC1_TR2_LT2) | ((val << 0) & ADC1_TR2_LT2); }
inline uint32_t adc1_tr2_get_ht2(struct ADC1_Type *p) { return (p->TR2 & ADC1_TR2_HT2) >> 16; }
inline uint32_t adc1_tr2_get_lt2(struct ADC1_Type *p) { return (p->TR2 & ADC1_TR2_LT2) >> 0; }

// ADC1->TR3 watchdog threshold register 3
enum {
	ADC1_TR3_HT3 = ((1UL << 8) - 1) << 16,	// HT3
	ADC1_TR3_LT3 = ((1UL << 8) - 1) << 0,	// LT3
};
inline void adc1_tr3_set_ht3(struct ADC1_Type *p, uint32_t val) {
	p->TR3 = (p->TR3 & ~ADC1_TR3_HT3) | ((val << 16) & ADC1_TR3_HT3);
}
inline void adc1_tr3_set_lt3(struct ADC1_Type *p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC1_TR3_LT3) | ((val << 0) & ADC1_TR3_LT3); }
inline uint32_t adc1_tr3_get_ht3(struct ADC1_Type *p) { return (p->TR3 & ADC1_TR3_HT3) >> 16; }
inline uint32_t adc1_tr3_get_lt3(struct ADC1_Type *p) { return (p->TR3 & ADC1_TR3_LT3) >> 0; }

// ADC1->SQR1 regular sequence register 1
enum {
	ADC1_SQR1_SQ4 = ((1UL << 5) - 1) << 24,	 // SQ4
	ADC1_SQR1_SQ3 = ((1UL << 5) - 1) << 18,	 // SQ3
	ADC1_SQR1_SQ2 = ((1UL << 5) - 1) << 12,	 // SQ2
	ADC1_SQR1_SQ1 = ((1UL << 5) - 1) << 6,	 // SQ1
	ADC1_SQR1_L	  = ((1UL << 4) - 1) << 0,	 // Regular channel sequence length
};
inline void adc1_sqr1_set_sq4(struct ADC1_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ4) | ((val << 24) & ADC1_SQR1_SQ4);
}
inline void adc1_sqr1_set_sq3(struct ADC1_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ3) | ((val << 18) & ADC1_SQR1_SQ3);
}
inline void adc1_sqr1_set_sq2(struct ADC1_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ2) | ((val << 12) & ADC1_SQR1_SQ2);
}
inline void adc1_sqr1_set_sq1(struct ADC1_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ1) | ((val << 6) & ADC1_SQR1_SQ1);
}
inline void adc1_sqr1_set_l(struct ADC1_Type *p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_L) | ((val << 0) & ADC1_SQR1_L); }
inline uint32_t adc1_sqr1_get_sq4(struct ADC1_Type *p) { return (p->SQR1 & ADC1_SQR1_SQ4) >> 24; }
inline uint32_t adc1_sqr1_get_sq3(struct ADC1_Type *p) { return (p->SQR1 & ADC1_SQR1_SQ3) >> 18; }
inline uint32_t adc1_sqr1_get_sq2(struct ADC1_Type *p) { return (p->SQR1 & ADC1_SQR1_SQ2) >> 12; }
inline uint32_t adc1_sqr1_get_sq1(struct ADC1_Type *p) { return (p->SQR1 & ADC1_SQR1_SQ1) >> 6; }
inline uint32_t adc1_sqr1_get_l(struct ADC1_Type *p) { return (p->SQR1 & ADC1_SQR1_L) >> 0; }

// ADC1->SQR2 regular sequence register 2
enum {
	ADC1_SQR2_SQ9 = ((1UL << 5) - 1) << 24,	 // SQ9
	ADC1_SQR2_SQ8 = ((1UL << 5) - 1) << 18,	 // SQ8
	ADC1_SQR2_SQ7 = ((1UL << 5) - 1) << 12,	 // SQ7
	ADC1_SQR2_SQ6 = ((1UL << 5) - 1) << 6,	 // SQ6
	ADC1_SQR2_SQ5 = ((1UL << 5) - 1) << 0,	 // SQ5
};
inline void adc1_sqr2_set_sq9(struct ADC1_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ9) | ((val << 24) & ADC1_SQR2_SQ9);
}
inline void adc1_sqr2_set_sq8(struct ADC1_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ8) | ((val << 18) & ADC1_SQR2_SQ8);
}
inline void adc1_sqr2_set_sq7(struct ADC1_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ7) | ((val << 12) & ADC1_SQR2_SQ7);
}
inline void adc1_sqr2_set_sq6(struct ADC1_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ6) | ((val << 6) & ADC1_SQR2_SQ6);
}
inline void adc1_sqr2_set_sq5(struct ADC1_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ5) | ((val << 0) & ADC1_SQR2_SQ5);
}
inline uint32_t adc1_sqr2_get_sq9(struct ADC1_Type *p) { return (p->SQR2 & ADC1_SQR2_SQ9) >> 24; }
inline uint32_t adc1_sqr2_get_sq8(struct ADC1_Type *p) { return (p->SQR2 & ADC1_SQR2_SQ8) >> 18; }
inline uint32_t adc1_sqr2_get_sq7(struct ADC1_Type *p) { return (p->SQR2 & ADC1_SQR2_SQ7) >> 12; }
inline uint32_t adc1_sqr2_get_sq6(struct ADC1_Type *p) { return (p->SQR2 & ADC1_SQR2_SQ6) >> 6; }
inline uint32_t adc1_sqr2_get_sq5(struct ADC1_Type *p) { return (p->SQR2 & ADC1_SQR2_SQ5) >> 0; }

// ADC1->SQR3 regular sequence register 3
enum {
	ADC1_SQR3_SQ14 = ((1UL << 5) - 1) << 24,  // SQ14
	ADC1_SQR3_SQ13 = ((1UL << 5) - 1) << 18,  // SQ13
	ADC1_SQR3_SQ12 = ((1UL << 5) - 1) << 12,  // SQ12
	ADC1_SQR3_SQ11 = ((1UL << 5) - 1) << 6,	  // SQ11
	ADC1_SQR3_SQ10 = ((1UL << 5) - 1) << 0,	  // SQ10
};
inline void adc1_sqr3_set_sq14(struct ADC1_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ14) | ((val << 24) & ADC1_SQR3_SQ14);
}
inline void adc1_sqr3_set_sq13(struct ADC1_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ13) | ((val << 18) & ADC1_SQR3_SQ13);
}
inline void adc1_sqr3_set_sq12(struct ADC1_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ12) | ((val << 12) & ADC1_SQR3_SQ12);
}
inline void adc1_sqr3_set_sq11(struct ADC1_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ11) | ((val << 6) & ADC1_SQR3_SQ11);
}
inline void adc1_sqr3_set_sq10(struct ADC1_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ10) | ((val << 0) & ADC1_SQR3_SQ10);
}
inline uint32_t adc1_sqr3_get_sq14(struct ADC1_Type *p) { return (p->SQR3 & ADC1_SQR3_SQ14) >> 24; }
inline uint32_t adc1_sqr3_get_sq13(struct ADC1_Type *p) { return (p->SQR3 & ADC1_SQR3_SQ13) >> 18; }
inline uint32_t adc1_sqr3_get_sq12(struct ADC1_Type *p) { return (p->SQR3 & ADC1_SQR3_SQ12) >> 12; }
inline uint32_t adc1_sqr3_get_sq11(struct ADC1_Type *p) { return (p->SQR3 & ADC1_SQR3_SQ11) >> 6; }
inline uint32_t adc1_sqr3_get_sq10(struct ADC1_Type *p) { return (p->SQR3 & ADC1_SQR3_SQ10) >> 0; }

// ADC1->SQR4 regular sequence register 4
enum {
	ADC1_SQR4_SQ16 = ((1UL << 5) - 1) << 6,	 // SQ16
	ADC1_SQR4_SQ15 = ((1UL << 5) - 1) << 0,	 // SQ15
};
inline void adc1_sqr4_set_sq16(struct ADC1_Type *p, uint32_t val) {
	p->SQR4 = (p->SQR4 & ~ADC1_SQR4_SQ16) | ((val << 6) & ADC1_SQR4_SQ16);
}
inline void adc1_sqr4_set_sq15(struct ADC1_Type *p, uint32_t val) {
	p->SQR4 = (p->SQR4 & ~ADC1_SQR4_SQ15) | ((val << 0) & ADC1_SQR4_SQ15);
}
inline uint32_t adc1_sqr4_get_sq16(struct ADC1_Type *p) { return (p->SQR4 & ADC1_SQR4_SQ16) >> 6; }
inline uint32_t adc1_sqr4_get_sq15(struct ADC1_Type *p) { return (p->SQR4 & ADC1_SQR4_SQ15) >> 0; }

// ADC1->JSQR injected sequence register
enum {
	ADC1_JSQR_JSQ4	  = ((1UL << 5) - 1) << 27,	 // JSQ4
	ADC1_JSQR_JSQ3	  = ((1UL << 5) - 1) << 21,	 // JSQ3
	ADC1_JSQR_JSQ2	  = ((1UL << 5) - 1) << 15,	 // JSQ2
	ADC1_JSQR_JSQ1	  = ((1UL << 5) - 1) << 9,	 // JSQ1
	ADC1_JSQR_JEXTEN  = ((1UL << 2) - 1) << 7,	 // JEXTEN
	ADC1_JSQR_JEXTSEL = ((1UL << 5) - 1) << 2,	 // JEXTSEL
	ADC1_JSQR_JL	  = ((1UL << 2) - 1) << 0,	 // JL
};
inline void adc1_jsqr_set_jsq4(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ4) | ((val << 27) & ADC1_JSQR_JSQ4);
}
inline void adc1_jsqr_set_jsq3(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ3) | ((val << 21) & ADC1_JSQR_JSQ3);
}
inline void adc1_jsqr_set_jsq2(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ2) | ((val << 15) & ADC1_JSQR_JSQ2);
}
inline void adc1_jsqr_set_jsq1(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ1) | ((val << 9) & ADC1_JSQR_JSQ1);
}
inline void adc1_jsqr_set_jexten(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JEXTEN) | ((val << 7) & ADC1_JSQR_JEXTEN);
}
inline void adc1_jsqr_set_jextsel(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JEXTSEL) | ((val << 2) & ADC1_JSQR_JEXTSEL);
}
inline void adc1_jsqr_set_jl(struct ADC1_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JL) | ((val << 0) & ADC1_JSQR_JL);
}
inline uint32_t adc1_jsqr_get_jsq4(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JSQ4) >> 27; }
inline uint32_t adc1_jsqr_get_jsq3(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JSQ3) >> 21; }
inline uint32_t adc1_jsqr_get_jsq2(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JSQ2) >> 15; }
inline uint32_t adc1_jsqr_get_jsq1(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JSQ1) >> 9; }
inline uint32_t adc1_jsqr_get_jexten(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JEXTEN) >> 7; }
inline uint32_t adc1_jsqr_get_jextsel(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JEXTSEL) >> 2; }
inline uint32_t adc1_jsqr_get_jl(struct ADC1_Type *p) { return (p->JSQR & ADC1_JSQR_JL) >> 0; }

// ADC1->OFR1 offset register 1
enum {
	ADC1_OFR1_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC1_OFR1_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC1_OFR1_SATEN		 = 1UL << 25,				// SATEN
	ADC1_OFR1_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC1_OFR1_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc1_ofr1_set_offset1_ch(struct ADC1_Type *p, uint32_t val) {
	p->OFR1 = (p->OFR1 & ~ADC1_OFR1_OFFSET1_CH) | ((val << 26) & ADC1_OFR1_OFFSET1_CH);
}
inline void adc1_ofr1_set_offset1(struct ADC1_Type *p, uint32_t val) {
	p->OFR1 = (p->OFR1 & ~ADC1_OFR1_OFFSET1) | ((val << 0) & ADC1_OFR1_OFFSET1);
}
inline uint32_t adc1_ofr1_get_offset1_ch(struct ADC1_Type *p) { return (p->OFR1 & ADC1_OFR1_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr1_get_offset1(struct ADC1_Type *p) { return (p->OFR1 & ADC1_OFR1_OFFSET1) >> 0; }

// ADC1->OFR2 offset register 2
enum {
	ADC1_OFR2_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC1_OFR2_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC1_OFR2_SATEN		 = 1UL << 25,				// SATEN
	ADC1_OFR2_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC1_OFR2_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc1_ofr2_set_offset1_ch(struct ADC1_Type *p, uint32_t val) {
	p->OFR2 = (p->OFR2 & ~ADC1_OFR2_OFFSET1_CH) | ((val << 26) & ADC1_OFR2_OFFSET1_CH);
}
inline void adc1_ofr2_set_offset1(struct ADC1_Type *p, uint32_t val) {
	p->OFR2 = (p->OFR2 & ~ADC1_OFR2_OFFSET1) | ((val << 0) & ADC1_OFR2_OFFSET1);
}
inline uint32_t adc1_ofr2_get_offset1_ch(struct ADC1_Type *p) { return (p->OFR2 & ADC1_OFR2_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr2_get_offset1(struct ADC1_Type *p) { return (p->OFR2 & ADC1_OFR2_OFFSET1) >> 0; }

// ADC1->OFR3 offset register 3
enum {
	ADC1_OFR3_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC1_OFR3_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC1_OFR3_SATEN		 = 1UL << 25,				// SATEN
	ADC1_OFR3_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC1_OFR3_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc1_ofr3_set_offset1_ch(struct ADC1_Type *p, uint32_t val) {
	p->OFR3 = (p->OFR3 & ~ADC1_OFR3_OFFSET1_CH) | ((val << 26) & ADC1_OFR3_OFFSET1_CH);
}
inline void adc1_ofr3_set_offset1(struct ADC1_Type *p, uint32_t val) {
	p->OFR3 = (p->OFR3 & ~ADC1_OFR3_OFFSET1) | ((val << 0) & ADC1_OFR3_OFFSET1);
}
inline uint32_t adc1_ofr3_get_offset1_ch(struct ADC1_Type *p) { return (p->OFR3 & ADC1_OFR3_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr3_get_offset1(struct ADC1_Type *p) { return (p->OFR3 & ADC1_OFR3_OFFSET1) >> 0; }

// ADC1->OFR4 offset register 4
enum {
	ADC1_OFR4_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC1_OFR4_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC1_OFR4_SATEN		 = 1UL << 25,				// SATEN
	ADC1_OFR4_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC1_OFR4_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc1_ofr4_set_offset1_ch(struct ADC1_Type *p, uint32_t val) {
	p->OFR4 = (p->OFR4 & ~ADC1_OFR4_OFFSET1_CH) | ((val << 26) & ADC1_OFR4_OFFSET1_CH);
}
inline void adc1_ofr4_set_offset1(struct ADC1_Type *p, uint32_t val) {
	p->OFR4 = (p->OFR4 & ~ADC1_OFR4_OFFSET1) | ((val << 0) & ADC1_OFR4_OFFSET1);
}
inline uint32_t adc1_ofr4_get_offset1_ch(struct ADC1_Type *p) { return (p->OFR4 & ADC1_OFR4_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr4_get_offset1(struct ADC1_Type *p) { return (p->OFR4 & ADC1_OFR4_OFFSET1) >> 0; }

// ADC1->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC1_AWD2CR_AWD2CH = ((1UL << 19) - 1) << 0,  // AWD2CH
};
inline void adc1_awd2cr_set_awd2ch(struct ADC1_Type *p, uint32_t val) {
	p->AWD2CR = (p->AWD2CR & ~ADC1_AWD2CR_AWD2CH) | ((val << 0) & ADC1_AWD2CR_AWD2CH);
}
inline uint32_t adc1_awd2cr_get_awd2ch(struct ADC1_Type *p) { return (p->AWD2CR & ADC1_AWD2CR_AWD2CH) >> 0; }

// ADC1->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC1_AWD3CR_AWD3CH = ((1UL << 19) - 1) << 0,  // AWD3CH
};
inline void adc1_awd3cr_set_awd3ch(struct ADC1_Type *p, uint32_t val) {
	p->AWD3CR = (p->AWD3CR & ~ADC1_AWD3CR_AWD3CH) | ((val << 0) & ADC1_AWD3CR_AWD3CH);
}
inline uint32_t adc1_awd3cr_get_awd3ch(struct ADC1_Type *p) { return (p->AWD3CR & ADC1_AWD3CR_AWD3CH) >> 0; }

// ADC1->DIFSEL Differential Mode Selection Register 2
enum {
	ADC1_DIFSEL_DIFSEL_1_18 = ((1UL << 18) - 1) << 1,  // Differential mode for channels 15 to 1
	ADC1_DIFSEL_DIFSEL_0	= 1UL << 0,				   // Differential mode for channels 0
};
inline void adc1_difsel_set_difsel_1_18(struct ADC1_Type *p, uint32_t val) {
	p->DIFSEL = (p->DIFSEL & ~ADC1_DIFSEL_DIFSEL_1_18) | ((val << 1) & ADC1_DIFSEL_DIFSEL_1_18);
}
inline uint32_t adc1_difsel_get_difsel_1_18(struct ADC1_Type *p) { return (p->DIFSEL & ADC1_DIFSEL_DIFSEL_1_18) >> 1; }

// ADC1->CALFACT Calibration Factors
enum {
	ADC1_CALFACT_CALFACT_D = ((1UL << 7) - 1) << 16,  // CALFACT_D
	ADC1_CALFACT_CALFACT_S = ((1UL << 7) - 1) << 0,	  // CALFACT_S
};
inline void adc1_calfact_set_calfact_d(struct ADC1_Type *p, uint32_t val) {
	p->CALFACT = (p->CALFACT & ~ADC1_CALFACT_CALFACT_D) | ((val << 16) & ADC1_CALFACT_CALFACT_D);
}
inline void adc1_calfact_set_calfact_s(struct ADC1_Type *p, uint32_t val) {
	p->CALFACT = (p->CALFACT & ~ADC1_CALFACT_CALFACT_S) | ((val << 0) & ADC1_CALFACT_CALFACT_S);
}
inline uint32_t adc1_calfact_get_calfact_d(struct ADC1_Type *p) { return (p->CALFACT & ADC1_CALFACT_CALFACT_D) >> 16; }
inline uint32_t adc1_calfact_get_calfact_s(struct ADC1_Type *p) { return (p->CALFACT & ADC1_CALFACT_CALFACT_S) >> 0; }

// ADC1->GCOMP Gain compensation Register
enum {
	ADC1_GCOMP_GCOMPCOEFF = ((1UL << 14) - 1) << 0,	 // GCOMPCOEFF
};
inline void adc1_gcomp_set_gcompcoeff(struct ADC1_Type *p, uint32_t val) {
	p->GCOMP = (p->GCOMP & ~ADC1_GCOMP_GCOMPCOEFF) | ((val << 0) & ADC1_GCOMP_GCOMPCOEFF);
}
inline uint32_t adc1_gcomp_get_gcompcoeff(struct ADC1_Type *p) { return (p->GCOMP & ADC1_GCOMP_GCOMPCOEFF) >> 0; }

/* Analog-to-Digital Converter */
struct ADC12_Common_Type {
	__I uint32_t  CSR;			 // @0 ADC Common status register
	uint8_t		  RESERVED0[4];	 // @4
	__IO uint32_t CCR;			 // @8 ADC common control register
	__I uint32_t  CDR;			 // @12 ADC common regular data register for dual and triple modes
};

// ADC12_Common->CSR ADC Common status register
enum {
	ADC12_COMMON_CSR_JQOVF_SLV	= 1UL << 26,  // Injected Context Queue Overflow flag of the slave ADC
	ADC12_COMMON_CSR_AWD3_SLV	= 1UL << 25,  // Analog watchdog 3 flag of the slave ADC
	ADC12_COMMON_CSR_AWD2_SLV	= 1UL << 24,  // Analog watchdog 2 flag of the slave ADC
	ADC12_COMMON_CSR_AWD1_SLV	= 1UL << 23,  // Analog watchdog 1 flag of the slave ADC
	ADC12_COMMON_CSR_JEOS_SLV	= 1UL << 22,  // End of injected sequence flag of the slave ADC
	ADC12_COMMON_CSR_JEOC_SLV	= 1UL << 21,  // End of injected conversion flag of the slave ADC
	ADC12_COMMON_CSR_OVR_SLV	= 1UL << 20,  // Overrun flag of the slave ADC
	ADC12_COMMON_CSR_EOS_SLV	= 1UL << 19,  // End of regular sequence flag of the slave ADC
	ADC12_COMMON_CSR_EOC_SLV	= 1UL << 18,  // End of regular conversion of the slave ADC
	ADC12_COMMON_CSR_EOSMP_SLV	= 1UL << 17,  // EOSMP_SLV
	ADC12_COMMON_CSR_ADRDY_SLV	= 1UL << 16,  // ADRDY_SLV
	ADC12_COMMON_CSR_JQOVF_MST	= 1UL << 10,  // JQOVF_MST
	ADC12_COMMON_CSR_AWD3_MST	= 1UL << 9,	  // AWD3_MST
	ADC12_COMMON_CSR_AWD2_MST	= 1UL << 8,	  // AWD2_MST
	ADC12_COMMON_CSR_AWD1_MST	= 1UL << 7,	  // AWD1_MST
	ADC12_COMMON_CSR_JEOS_MST	= 1UL << 6,	  // JEOS_MST
	ADC12_COMMON_CSR_JEOC_MST	= 1UL << 5,	  // JEOC_MST
	ADC12_COMMON_CSR_OVR_MST	= 1UL << 4,	  // OVR_MST
	ADC12_COMMON_CSR_EOS_MST	= 1UL << 3,	  // EOS_MST
	ADC12_COMMON_CSR_EOC_MST	= 1UL << 2,	  // EOC_MST
	ADC12_COMMON_CSR_EOSMP_MST	= 1UL << 1,	  // EOSMP_MST
	ADC12_COMMON_CSR_ADDRDY_MST = 1UL << 0,	  // ADDRDY_MST
};

// ADC12_Common->CCR ADC common control register
enum {
	ADC12_COMMON_CCR_VBATSEL   = 1UL << 24,				  // VBAT selection
	ADC12_COMMON_CCR_VSENSESEL = 1UL << 23,				  // VTS selection
	ADC12_COMMON_CCR_VREFEN	   = 1UL << 22,				  // VREFINT enable
	ADC12_COMMON_CCR_PRESC	   = ((1UL << 4) - 1) << 18,  // ADC prescaler
	ADC12_COMMON_CCR_CKMODE	   = ((1UL << 2) - 1) << 16,  // ADC clock mode
	ADC12_COMMON_CCR_MDMA	   = ((1UL << 2) - 1) << 14,  // Direct memory access mode for multi ADC mode
	ADC12_COMMON_CCR_DMACFG	   = 1UL << 13,				  // DMA configuration (for multi-ADC mode)
	ADC12_COMMON_CCR_DELAY	   = ((1UL << 4) - 1) << 8,	  // Delay between 2 sampling phases
	ADC12_COMMON_CCR_DUAL	   = ((1UL << 5) - 1) << 0,	  // Dual ADC mode selection
};
inline void adc12_common_ccr_set_presc(struct ADC12_Common_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_PRESC) | ((val << 18) & ADC12_COMMON_CCR_PRESC);
}
inline void adc12_common_ccr_set_ckmode(struct ADC12_Common_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_CKMODE) | ((val << 16) & ADC12_COMMON_CCR_CKMODE);
}
inline void adc12_common_ccr_set_mdma(struct ADC12_Common_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_MDMA) | ((val << 14) & ADC12_COMMON_CCR_MDMA);
}
inline void adc12_common_ccr_set_delay(struct ADC12_Common_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_DELAY) | ((val << 8) & ADC12_COMMON_CCR_DELAY);
}
inline void adc12_common_ccr_set_dual(struct ADC12_Common_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_DUAL) | ((val << 0) & ADC12_COMMON_CCR_DUAL);
}
inline uint32_t adc12_common_ccr_get_presc(struct ADC12_Common_Type *p) { return (p->CCR & ADC12_COMMON_CCR_PRESC) >> 18; }
inline uint32_t adc12_common_ccr_get_ckmode(struct ADC12_Common_Type *p) { return (p->CCR & ADC12_COMMON_CCR_CKMODE) >> 16; }
inline uint32_t adc12_common_ccr_get_mdma(struct ADC12_Common_Type *p) { return (p->CCR & ADC12_COMMON_CCR_MDMA) >> 14; }
inline uint32_t adc12_common_ccr_get_delay(struct ADC12_Common_Type *p) { return (p->CCR & ADC12_COMMON_CCR_DELAY) >> 8; }
inline uint32_t adc12_common_ccr_get_dual(struct ADC12_Common_Type *p) { return (p->CCR & ADC12_COMMON_CCR_DUAL) >> 0; }

// ADC12_Common->CDR ADC common regular data register for dual and triple modes
enum {
	ADC12_COMMON_CDR_RDATA_SLV = ((1UL << 16) - 1) << 16,  // Regular data of the slave ADC
	ADC12_COMMON_CDR_RDATA_MST = ((1UL << 16) - 1) << 0,   // Regular data of the master ADC
};
inline uint32_t adc12_common_cdr_get_rdata_slv(struct ADC12_Common_Type *p) { return (p->CDR & ADC12_COMMON_CDR_RDATA_SLV) >> 16; }
inline uint32_t adc12_common_cdr_get_rdata_mst(struct ADC12_Common_Type *p) { return (p->CDR & ADC12_COMMON_CDR_RDATA_MST) >> 0; }

/* Analog-to-Digital Converter */
struct ADC3_Type {
	__IO uint16_t ISR;			   // @0 interrupt and status register
	uint8_t		  RESERVED0[2];	   // @2
	__IO uint16_t IER;			   // @4 interrupt enable register
	uint8_t		  RESERVED1[2];	   // @6
	__IO uint32_t CR;			   // @8 control register
	__IO uint32_t CFGR;			   // @12 configuration register
	__IO uint32_t CFGR2;		   // @16 configuration register
	__IO uint32_t SMPR1;		   // @20 sample time register 1
	__IO uint32_t SMPR2;		   // @24 sample time register 2
	uint8_t		  RESERVED2[4];	   // @28
	__IO uint32_t TR1;			   // @32 watchdog threshold register 1
	__IO uint32_t TR2;			   // @36 watchdog threshold register
	__IO uint32_t TR3;			   // @40 watchdog threshold register 3
	uint8_t		  RESERVED3[4];	   // @44
	__IO uint32_t SQR1;			   // @48 regular sequence register 1
	__IO uint32_t SQR2;			   // @52 regular sequence register 2
	__IO uint32_t SQR3;			   // @56 regular sequence register 3
	__IO uint16_t SQR4;			   // @60 regular sequence register 4
	uint8_t		  RESERVED4[2];	   // @62
	__I uint16_t  DR;			   // @64 regular Data Register
	uint8_t		  RESERVED5[10];   // @66
	__IO uint32_t JSQR;			   // @76 injected sequence register
	uint8_t		  RESERVED6[16];   // @80
	__IO uint32_t OFR1;			   // @96 offset register 1
	__IO uint32_t OFR2;			   // @100 offset register 2
	__IO uint32_t OFR3;			   // @104 offset register 3
	__IO uint32_t OFR4;			   // @108 offset register 4
	uint8_t		  RESERVED7[16];   // @112
	__I uint16_t  JDR1;			   // @128 injected data register 1
	uint8_t		  RESERVED8[2];	   // @130
	__I uint16_t  JDR2;			   // @132 injected data register 2
	uint8_t		  RESERVED9[2];	   // @134
	__I uint16_t  JDR3;			   // @136 injected data register 3
	uint8_t		  RESERVED10[2];   // @138
	__I uint16_t  JDR4;			   // @140 injected data register 4
	uint8_t		  RESERVED11[18];  // @142
	__IO uint32_t AWD2CR;		   // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR;		   // @164 Analog Watchdog 3 Configuration Register
	uint8_t		  RESERVED12[8];   // @168
	__IO uint32_t DIFSEL;		   // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT;		   // @180 Calibration Factors
	uint8_t		  RESERVED13[8];   // @184
	__IO uint16_t GCOMP;		   // @192 Gain compensation Register
};

// ADC3->ISR interrupt and status register
enum {
	ADC3_ISR_JQOVF = 1UL << 10,	 // JQOVF
	ADC3_ISR_AWD3  = 1UL << 9,	 // AWD3
	ADC3_ISR_AWD2  = 1UL << 8,	 // AWD2
	ADC3_ISR_AWD1  = 1UL << 7,	 // AWD1
	ADC3_ISR_JEOS  = 1UL << 6,	 // JEOS
	ADC3_ISR_JEOC  = 1UL << 5,	 // JEOC
	ADC3_ISR_OVR   = 1UL << 4,	 // OVR
	ADC3_ISR_EOS   = 1UL << 3,	 // EOS
	ADC3_ISR_EOC   = 1UL << 2,	 // EOC
	ADC3_ISR_EOSMP = 1UL << 1,	 // EOSMP
	ADC3_ISR_ADRDY = 1UL << 0,	 // ADRDY
};

// ADC3->IER interrupt enable register
enum {
	ADC3_IER_JQOVFIE = 1UL << 10,  // JQOVFIE
	ADC3_IER_AWD3IE	 = 1UL << 9,   // AWD3IE
	ADC3_IER_AWD2IE	 = 1UL << 8,   // AWD2IE
	ADC3_IER_AWD1IE	 = 1UL << 7,   // AWD1IE
	ADC3_IER_JEOSIE	 = 1UL << 6,   // JEOSIE
	ADC3_IER_JEOCIE	 = 1UL << 5,   // JEOCIE
	ADC3_IER_OVRIE	 = 1UL << 4,   // OVRIE
	ADC3_IER_EOSIE	 = 1UL << 3,   // EOSIE
	ADC3_IER_EOCIE	 = 1UL << 2,   // EOCIE
	ADC3_IER_EOSMPIE = 1UL << 1,   // EOSMPIE
	ADC3_IER_ADRDYIE = 1UL << 0,   // ADRDYIE
};

// ADC3->CR control register
enum {
	ADC3_CR_ADCAL	 = 1UL << 31,  // ADCAL
	ADC3_CR_ADCALDIF = 1UL << 30,  // ADCALDIF
	ADC3_CR_DEEPPWD	 = 1UL << 29,  // DEEPPWD
	ADC3_CR_ADVREGEN = 1UL << 28,  // ADVREGEN
	ADC3_CR_JADSTP	 = 1UL << 5,   // JADSTP
	ADC3_CR_ADSTP	 = 1UL << 4,   // ADSTP
	ADC3_CR_JADSTART = 1UL << 3,   // JADSTART
	ADC3_CR_ADSTART	 = 1UL << 2,   // ADSTART
	ADC3_CR_ADDIS	 = 1UL << 1,   // ADDIS
	ADC3_CR_ADEN	 = 1UL << 0,   // ADEN
};

// ADC3->CFGR configuration register
enum {
	ADC3_CFGR_JQDIS	   = 1UL << 31,				  // Injected Queue disable
	ADC3_CFGR_AWDCH1CH = ((1UL << 5) - 1) << 26,  // AWDCH1CH
	ADC3_CFGR_JAUTO	   = 1UL << 25,				  // JAUTO
	ADC3_CFGR_JAWD1EN  = 1UL << 24,				  // JAWD1EN
	ADC3_CFGR_AWD1EN   = 1UL << 23,				  // AWD1EN
	ADC3_CFGR_AWD1SGL  = 1UL << 22,				  // AWD1SGL
	ADC3_CFGR_JQM	   = 1UL << 21,				  // JQM
	ADC3_CFGR_JDISCEN  = 1UL << 20,				  // JDISCEN
	ADC3_CFGR_DISCNUM  = ((1UL << 3) - 1) << 17,  // DISCNUM
	ADC3_CFGR_DISCEN   = 1UL << 16,				  // DISCEN
	ADC3_CFGR_ALIGN	   = 1UL << 15,				  // ALIGN
	ADC3_CFGR_AUTDLY   = 1UL << 14,				  // AUTDLY
	ADC3_CFGR_CONT	   = 1UL << 13,				  // CONT
	ADC3_CFGR_OVRMOD   = 1UL << 12,				  // OVRMOD
	ADC3_CFGR_EXTEN	   = ((1UL << 2) - 1) << 10,  // EXTEN
	ADC3_CFGR_EXTSEL   = ((1UL << 4) - 1) << 6,	  // EXTSEL
	ADC3_CFGR_ALIGN_5  = 1UL << 5,				  // ALIGN_5
	ADC3_CFGR_RES	   = ((1UL << 2) - 1) << 3,	  // RES
	ADC3_CFGR_DMACFG   = 1UL << 1,				  // DMACFG
	ADC3_CFGR_DMAEN	   = 1UL << 0,				  // DMAEN
};
inline void adc3_cfgr_set_awdch1ch(struct ADC3_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC3_CFGR_AWDCH1CH) | ((val << 26) & ADC3_CFGR_AWDCH1CH);
}
inline void adc3_cfgr_set_discnum(struct ADC3_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC3_CFGR_DISCNUM) | ((val << 17) & ADC3_CFGR_DISCNUM);
}
inline void adc3_cfgr_set_exten(struct ADC3_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC3_CFGR_EXTEN) | ((val << 10) & ADC3_CFGR_EXTEN);
}
inline void adc3_cfgr_set_extsel(struct ADC3_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC3_CFGR_EXTSEL) | ((val << 6) & ADC3_CFGR_EXTSEL);
}
inline void adc3_cfgr_set_res(struct ADC3_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC3_CFGR_RES) | ((val << 3) & ADC3_CFGR_RES);
}
inline uint32_t adc3_cfgr_get_awdch1ch(struct ADC3_Type *p) { return (p->CFGR & ADC3_CFGR_AWDCH1CH) >> 26; }
inline uint32_t adc3_cfgr_get_discnum(struct ADC3_Type *p) { return (p->CFGR & ADC3_CFGR_DISCNUM) >> 17; }
inline uint32_t adc3_cfgr_get_exten(struct ADC3_Type *p) { return (p->CFGR & ADC3_CFGR_EXTEN) >> 10; }
inline uint32_t adc3_cfgr_get_extsel(struct ADC3_Type *p) { return (p->CFGR & ADC3_CFGR_EXTSEL) >> 6; }
inline uint32_t adc3_cfgr_get_res(struct ADC3_Type *p) { return (p->CFGR & ADC3_CFGR_RES) >> 3; }

// ADC3->CFGR2 configuration register
enum {
	ADC3_CFGR2_SMPTRIG = 1UL << 27,				 // SMPTRIG
	ADC3_CFGR2_BULB	   = 1UL << 26,				 // BULB
	ADC3_CFGR2_SWTRIG  = 1UL << 25,				 // SWTRIG
	ADC3_CFGR2_GCOMP   = 1UL << 16,				 // GCOMP
	ADC3_CFGR2_ROVSM   = 1UL << 10,				 // EXTEN
	ADC3_CFGR2_TROVS   = 1UL << 9,				 // Triggered Regular Oversampling
	ADC3_CFGR2_OVSS	   = ((1UL << 4) - 1) << 5,	 // ALIGN
	ADC3_CFGR2_OVSR	   = ((1UL << 3) - 1) << 2,	 // RES
	ADC3_CFGR2_JOVSE   = 1UL << 1,				 // DMACFG
	ADC3_CFGR2_ROVSE   = 1UL << 0,				 // DMAEN
};
inline void adc3_cfgr2_set_ovss(struct ADC3_Type *p, uint32_t val) {
	p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_OVSS) | ((val << 5) & ADC3_CFGR2_OVSS);
}
inline void adc3_cfgr2_set_ovsr(struct ADC3_Type *p, uint32_t val) {
	p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_OVSR) | ((val << 2) & ADC3_CFGR2_OVSR);
}
inline uint32_t adc3_cfgr2_get_ovss(struct ADC3_Type *p) { return (p->CFGR2 & ADC3_CFGR2_OVSS) >> 5; }
inline uint32_t adc3_cfgr2_get_ovsr(struct ADC3_Type *p) { return (p->CFGR2 & ADC3_CFGR2_OVSR) >> 2; }

// ADC3->SMPR1 sample time register 1
enum {
	ADC3_SMPR1_SMPPLUS = 1UL << 31,				  // Addition of one clock cycle to the sampling time
	ADC3_SMPR1_SMP9	   = ((1UL << 3) - 1) << 27,  // SMP9
	ADC3_SMPR1_SMP8	   = ((1UL << 3) - 1) << 24,  // SMP8
	ADC3_SMPR1_SMP7	   = ((1UL << 3) - 1) << 21,  // SMP7
	ADC3_SMPR1_SMP6	   = ((1UL << 3) - 1) << 18,  // SMP6
	ADC3_SMPR1_SMP5	   = ((1UL << 3) - 1) << 15,  // SMP5
	ADC3_SMPR1_SMP4	   = ((1UL << 3) - 1) << 12,  // SMP4
	ADC3_SMPR1_SMP3	   = ((1UL << 3) - 1) << 9,	  // SMP3
	ADC3_SMPR1_SMP2	   = ((1UL << 3) - 1) << 6,	  // SMP2
	ADC3_SMPR1_SMP1	   = ((1UL << 3) - 1) << 3,	  // SMP1
	ADC3_SMPR1_SMP0	   = ((1UL << 3) - 1) << 0,	  // SMP0
};
inline void adc3_smpr1_set_smp9(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP9) | ((val << 27) & ADC3_SMPR1_SMP9);
}
inline void adc3_smpr1_set_smp8(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP8) | ((val << 24) & ADC3_SMPR1_SMP8);
}
inline void adc3_smpr1_set_smp7(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP7) | ((val << 21) & ADC3_SMPR1_SMP7);
}
inline void adc3_smpr1_set_smp6(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP6) | ((val << 18) & ADC3_SMPR1_SMP6);
}
inline void adc3_smpr1_set_smp5(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP5) | ((val << 15) & ADC3_SMPR1_SMP5);
}
inline void adc3_smpr1_set_smp4(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP4) | ((val << 12) & ADC3_SMPR1_SMP4);
}
inline void adc3_smpr1_set_smp3(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP3) | ((val << 9) & ADC3_SMPR1_SMP3);
}
inline void adc3_smpr1_set_smp2(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP2) | ((val << 6) & ADC3_SMPR1_SMP2);
}
inline void adc3_smpr1_set_smp1(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP1) | ((val << 3) & ADC3_SMPR1_SMP1);
}
inline void adc3_smpr1_set_smp0(struct ADC3_Type *p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP0) | ((val << 0) & ADC3_SMPR1_SMP0);
}
inline uint32_t adc3_smpr1_get_smp9(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP9) >> 27; }
inline uint32_t adc3_smpr1_get_smp8(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP8) >> 24; }
inline uint32_t adc3_smpr1_get_smp7(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP7) >> 21; }
inline uint32_t adc3_smpr1_get_smp6(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP6) >> 18; }
inline uint32_t adc3_smpr1_get_smp5(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP5) >> 15; }
inline uint32_t adc3_smpr1_get_smp4(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP4) >> 12; }
inline uint32_t adc3_smpr1_get_smp3(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP3) >> 9; }
inline uint32_t adc3_smpr1_get_smp2(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP2) >> 6; }
inline uint32_t adc3_smpr1_get_smp1(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP1) >> 3; }
inline uint32_t adc3_smpr1_get_smp0(struct ADC3_Type *p) { return (p->SMPR1 & ADC3_SMPR1_SMP0) >> 0; }

// ADC3->SMPR2 sample time register 2
enum {
	ADC3_SMPR2_SMP18 = ((1UL << 3) - 1) << 24,	// SMP18
	ADC3_SMPR2_SMP17 = ((1UL << 3) - 1) << 21,	// SMP17
	ADC3_SMPR2_SMP16 = ((1UL << 3) - 1) << 18,	// SMP16
	ADC3_SMPR2_SMP15 = ((1UL << 3) - 1) << 15,	// SMP15
	ADC3_SMPR2_SMP14 = ((1UL << 3) - 1) << 12,	// SMP14
	ADC3_SMPR2_SMP13 = ((1UL << 3) - 1) << 9,	// SMP13
	ADC3_SMPR2_SMP12 = ((1UL << 3) - 1) << 6,	// SMP12
	ADC3_SMPR2_SMP11 = ((1UL << 3) - 1) << 3,	// SMP11
	ADC3_SMPR2_SMP10 = ((1UL << 3) - 1) << 0,	// SMP10
};
inline void adc3_smpr2_set_smp18(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP18) | ((val << 24) & ADC3_SMPR2_SMP18);
}
inline void adc3_smpr2_set_smp17(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP17) | ((val << 21) & ADC3_SMPR2_SMP17);
}
inline void adc3_smpr2_set_smp16(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP16) | ((val << 18) & ADC3_SMPR2_SMP16);
}
inline void adc3_smpr2_set_smp15(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP15) | ((val << 15) & ADC3_SMPR2_SMP15);
}
inline void adc3_smpr2_set_smp14(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP14) | ((val << 12) & ADC3_SMPR2_SMP14);
}
inline void adc3_smpr2_set_smp13(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP13) | ((val << 9) & ADC3_SMPR2_SMP13);
}
inline void adc3_smpr2_set_smp12(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP12) | ((val << 6) & ADC3_SMPR2_SMP12);
}
inline void adc3_smpr2_set_smp11(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP11) | ((val << 3) & ADC3_SMPR2_SMP11);
}
inline void adc3_smpr2_set_smp10(struct ADC3_Type *p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP10) | ((val << 0) & ADC3_SMPR2_SMP10);
}
inline uint32_t adc3_smpr2_get_smp18(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP18) >> 24; }
inline uint32_t adc3_smpr2_get_smp17(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP17) >> 21; }
inline uint32_t adc3_smpr2_get_smp16(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP16) >> 18; }
inline uint32_t adc3_smpr2_get_smp15(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP15) >> 15; }
inline uint32_t adc3_smpr2_get_smp14(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP14) >> 12; }
inline uint32_t adc3_smpr2_get_smp13(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP13) >> 9; }
inline uint32_t adc3_smpr2_get_smp12(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP12) >> 6; }
inline uint32_t adc3_smpr2_get_smp11(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP11) >> 3; }
inline uint32_t adc3_smpr2_get_smp10(struct ADC3_Type *p) { return (p->SMPR2 & ADC3_SMPR2_SMP10) >> 0; }

// ADC3->TR1 watchdog threshold register 1
enum {
	ADC3_TR1_HT1	 = ((1UL << 12) - 1) << 16,	 // HT1
	ADC3_TR1_AWDFILT = ((1UL << 3) - 1) << 12,	 // AWDFILT
	ADC3_TR1_LT1	 = ((1UL << 12) - 1) << 0,	 // LT1
};
inline void adc3_tr1_set_ht1(struct ADC3_Type *p, uint32_t val) {
	p->TR1 = (p->TR1 & ~ADC3_TR1_HT1) | ((val << 16) & ADC3_TR1_HT1);
}
inline void adc3_tr1_set_awdfilt(struct ADC3_Type *p, uint32_t val) {
	p->TR1 = (p->TR1 & ~ADC3_TR1_AWDFILT) | ((val << 12) & ADC3_TR1_AWDFILT);
}
inline void adc3_tr1_set_lt1(struct ADC3_Type *p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC3_TR1_LT1) | ((val << 0) & ADC3_TR1_LT1); }
inline uint32_t adc3_tr1_get_ht1(struct ADC3_Type *p) { return (p->TR1 & ADC3_TR1_HT1) >> 16; }
inline uint32_t adc3_tr1_get_awdfilt(struct ADC3_Type *p) { return (p->TR1 & ADC3_TR1_AWDFILT) >> 12; }
inline uint32_t adc3_tr1_get_lt1(struct ADC3_Type *p) { return (p->TR1 & ADC3_TR1_LT1) >> 0; }

// ADC3->TR2 watchdog threshold register
enum {
	ADC3_TR2_HT2 = ((1UL << 8) - 1) << 16,	// HT2
	ADC3_TR2_LT2 = ((1UL << 8) - 1) << 0,	// LT2
};
inline void adc3_tr2_set_ht2(struct ADC3_Type *p, uint32_t val) {
	p->TR2 = (p->TR2 & ~ADC3_TR2_HT2) | ((val << 16) & ADC3_TR2_HT2);
}
inline void adc3_tr2_set_lt2(struct ADC3_Type *p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC3_TR2_LT2) | ((val << 0) & ADC3_TR2_LT2); }
inline uint32_t adc3_tr2_get_ht2(struct ADC3_Type *p) { return (p->TR2 & ADC3_TR2_HT2) >> 16; }
inline uint32_t adc3_tr2_get_lt2(struct ADC3_Type *p) { return (p->TR2 & ADC3_TR2_LT2) >> 0; }

// ADC3->TR3 watchdog threshold register 3
enum {
	ADC3_TR3_HT3 = ((1UL << 8) - 1) << 16,	// HT3
	ADC3_TR3_LT3 = ((1UL << 8) - 1) << 0,	// LT3
};
inline void adc3_tr3_set_ht3(struct ADC3_Type *p, uint32_t val) {
	p->TR3 = (p->TR3 & ~ADC3_TR3_HT3) | ((val << 16) & ADC3_TR3_HT3);
}
inline void adc3_tr3_set_lt3(struct ADC3_Type *p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC3_TR3_LT3) | ((val << 0) & ADC3_TR3_LT3); }
inline uint32_t adc3_tr3_get_ht3(struct ADC3_Type *p) { return (p->TR3 & ADC3_TR3_HT3) >> 16; }
inline uint32_t adc3_tr3_get_lt3(struct ADC3_Type *p) { return (p->TR3 & ADC3_TR3_LT3) >> 0; }

// ADC3->SQR1 regular sequence register 1
enum {
	ADC3_SQR1_SQ4 = ((1UL << 5) - 1) << 24,	 // SQ4
	ADC3_SQR1_SQ3 = ((1UL << 5) - 1) << 18,	 // SQ3
	ADC3_SQR1_SQ2 = ((1UL << 5) - 1) << 12,	 // SQ2
	ADC3_SQR1_SQ1 = ((1UL << 5) - 1) << 6,	 // SQ1
	ADC3_SQR1_L	  = ((1UL << 4) - 1) << 0,	 // Regular channel sequence length
};
inline void adc3_sqr1_set_sq4(struct ADC3_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ4) | ((val << 24) & ADC3_SQR1_SQ4);
}
inline void adc3_sqr1_set_sq3(struct ADC3_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ3) | ((val << 18) & ADC3_SQR1_SQ3);
}
inline void adc3_sqr1_set_sq2(struct ADC3_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ2) | ((val << 12) & ADC3_SQR1_SQ2);
}
inline void adc3_sqr1_set_sq1(struct ADC3_Type *p, uint32_t val) {
	p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ1) | ((val << 6) & ADC3_SQR1_SQ1);
}
inline void adc3_sqr1_set_l(struct ADC3_Type *p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_L) | ((val << 0) & ADC3_SQR1_L); }
inline uint32_t adc3_sqr1_get_sq4(struct ADC3_Type *p) { return (p->SQR1 & ADC3_SQR1_SQ4) >> 24; }
inline uint32_t adc3_sqr1_get_sq3(struct ADC3_Type *p) { return (p->SQR1 & ADC3_SQR1_SQ3) >> 18; }
inline uint32_t adc3_sqr1_get_sq2(struct ADC3_Type *p) { return (p->SQR1 & ADC3_SQR1_SQ2) >> 12; }
inline uint32_t adc3_sqr1_get_sq1(struct ADC3_Type *p) { return (p->SQR1 & ADC3_SQR1_SQ1) >> 6; }
inline uint32_t adc3_sqr1_get_l(struct ADC3_Type *p) { return (p->SQR1 & ADC3_SQR1_L) >> 0; }

// ADC3->SQR2 regular sequence register 2
enum {
	ADC3_SQR2_SQ9 = ((1UL << 5) - 1) << 24,	 // SQ9
	ADC3_SQR2_SQ8 = ((1UL << 5) - 1) << 18,	 // SQ8
	ADC3_SQR2_SQ7 = ((1UL << 5) - 1) << 12,	 // SQ7
	ADC3_SQR2_SQ6 = ((1UL << 5) - 1) << 6,	 // SQ6
	ADC3_SQR2_SQ5 = ((1UL << 5) - 1) << 0,	 // SQ5
};
inline void adc3_sqr2_set_sq9(struct ADC3_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ9) | ((val << 24) & ADC3_SQR2_SQ9);
}
inline void adc3_sqr2_set_sq8(struct ADC3_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ8) | ((val << 18) & ADC3_SQR2_SQ8);
}
inline void adc3_sqr2_set_sq7(struct ADC3_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ7) | ((val << 12) & ADC3_SQR2_SQ7);
}
inline void adc3_sqr2_set_sq6(struct ADC3_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ6) | ((val << 6) & ADC3_SQR2_SQ6);
}
inline void adc3_sqr2_set_sq5(struct ADC3_Type *p, uint32_t val) {
	p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ5) | ((val << 0) & ADC3_SQR2_SQ5);
}
inline uint32_t adc3_sqr2_get_sq9(struct ADC3_Type *p) { return (p->SQR2 & ADC3_SQR2_SQ9) >> 24; }
inline uint32_t adc3_sqr2_get_sq8(struct ADC3_Type *p) { return (p->SQR2 & ADC3_SQR2_SQ8) >> 18; }
inline uint32_t adc3_sqr2_get_sq7(struct ADC3_Type *p) { return (p->SQR2 & ADC3_SQR2_SQ7) >> 12; }
inline uint32_t adc3_sqr2_get_sq6(struct ADC3_Type *p) { return (p->SQR2 & ADC3_SQR2_SQ6) >> 6; }
inline uint32_t adc3_sqr2_get_sq5(struct ADC3_Type *p) { return (p->SQR2 & ADC3_SQR2_SQ5) >> 0; }

// ADC3->SQR3 regular sequence register 3
enum {
	ADC3_SQR3_SQ14 = ((1UL << 5) - 1) << 24,  // SQ14
	ADC3_SQR3_SQ13 = ((1UL << 5) - 1) << 18,  // SQ13
	ADC3_SQR3_SQ12 = ((1UL << 5) - 1) << 12,  // SQ12
	ADC3_SQR3_SQ11 = ((1UL << 5) - 1) << 6,	  // SQ11
	ADC3_SQR3_SQ10 = ((1UL << 5) - 1) << 0,	  // SQ10
};
inline void adc3_sqr3_set_sq14(struct ADC3_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ14) | ((val << 24) & ADC3_SQR3_SQ14);
}
inline void adc3_sqr3_set_sq13(struct ADC3_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ13) | ((val << 18) & ADC3_SQR3_SQ13);
}
inline void adc3_sqr3_set_sq12(struct ADC3_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ12) | ((val << 12) & ADC3_SQR3_SQ12);
}
inline void adc3_sqr3_set_sq11(struct ADC3_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ11) | ((val << 6) & ADC3_SQR3_SQ11);
}
inline void adc3_sqr3_set_sq10(struct ADC3_Type *p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ10) | ((val << 0) & ADC3_SQR3_SQ10);
}
inline uint32_t adc3_sqr3_get_sq14(struct ADC3_Type *p) { return (p->SQR3 & ADC3_SQR3_SQ14) >> 24; }
inline uint32_t adc3_sqr3_get_sq13(struct ADC3_Type *p) { return (p->SQR3 & ADC3_SQR3_SQ13) >> 18; }
inline uint32_t adc3_sqr3_get_sq12(struct ADC3_Type *p) { return (p->SQR3 & ADC3_SQR3_SQ12) >> 12; }
inline uint32_t adc3_sqr3_get_sq11(struct ADC3_Type *p) { return (p->SQR3 & ADC3_SQR3_SQ11) >> 6; }
inline uint32_t adc3_sqr3_get_sq10(struct ADC3_Type *p) { return (p->SQR3 & ADC3_SQR3_SQ10) >> 0; }

// ADC3->SQR4 regular sequence register 4
enum {
	ADC3_SQR4_SQ16 = ((1UL << 5) - 1) << 6,	 // SQ16
	ADC3_SQR4_SQ15 = ((1UL << 5) - 1) << 0,	 // SQ15
};
inline void adc3_sqr4_set_sq16(struct ADC3_Type *p, uint32_t val) {
	p->SQR4 = (p->SQR4 & ~ADC3_SQR4_SQ16) | ((val << 6) & ADC3_SQR4_SQ16);
}
inline void adc3_sqr4_set_sq15(struct ADC3_Type *p, uint32_t val) {
	p->SQR4 = (p->SQR4 & ~ADC3_SQR4_SQ15) | ((val << 0) & ADC3_SQR4_SQ15);
}
inline uint32_t adc3_sqr4_get_sq16(struct ADC3_Type *p) { return (p->SQR4 & ADC3_SQR4_SQ16) >> 6; }
inline uint32_t adc3_sqr4_get_sq15(struct ADC3_Type *p) { return (p->SQR4 & ADC3_SQR4_SQ15) >> 0; }

// ADC3->JSQR injected sequence register
enum {
	ADC3_JSQR_JSQ4	  = ((1UL << 5) - 1) << 27,	 // JSQ4
	ADC3_JSQR_JSQ3	  = ((1UL << 5) - 1) << 21,	 // JSQ3
	ADC3_JSQR_JSQ2	  = ((1UL << 5) - 1) << 15,	 // JSQ2
	ADC3_JSQR_JSQ1	  = ((1UL << 5) - 1) << 9,	 // JSQ1
	ADC3_JSQR_JEXTEN  = ((1UL << 2) - 1) << 7,	 // JEXTEN
	ADC3_JSQR_JEXTSEL = ((1UL << 5) - 1) << 2,	 // JEXTSEL
	ADC3_JSQR_JL	  = ((1UL << 2) - 1) << 0,	 // JL
};
inline void adc3_jsqr_set_jsq4(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ4) | ((val << 27) & ADC3_JSQR_JSQ4);
}
inline void adc3_jsqr_set_jsq3(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ3) | ((val << 21) & ADC3_JSQR_JSQ3);
}
inline void adc3_jsqr_set_jsq2(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ2) | ((val << 15) & ADC3_JSQR_JSQ2);
}
inline void adc3_jsqr_set_jsq1(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ1) | ((val << 9) & ADC3_JSQR_JSQ1);
}
inline void adc3_jsqr_set_jexten(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JEXTEN) | ((val << 7) & ADC3_JSQR_JEXTEN);
}
inline void adc3_jsqr_set_jextsel(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JEXTSEL) | ((val << 2) & ADC3_JSQR_JEXTSEL);
}
inline void adc3_jsqr_set_jl(struct ADC3_Type *p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC3_JSQR_JL) | ((val << 0) & ADC3_JSQR_JL);
}
inline uint32_t adc3_jsqr_get_jsq4(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JSQ4) >> 27; }
inline uint32_t adc3_jsqr_get_jsq3(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JSQ3) >> 21; }
inline uint32_t adc3_jsqr_get_jsq2(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JSQ2) >> 15; }
inline uint32_t adc3_jsqr_get_jsq1(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JSQ1) >> 9; }
inline uint32_t adc3_jsqr_get_jexten(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JEXTEN) >> 7; }
inline uint32_t adc3_jsqr_get_jextsel(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JEXTSEL) >> 2; }
inline uint32_t adc3_jsqr_get_jl(struct ADC3_Type *p) { return (p->JSQR & ADC3_JSQR_JL) >> 0; }

// ADC3->OFR1 offset register 1
enum {
	ADC3_OFR1_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC3_OFR1_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC3_OFR1_SATEN		 = 1UL << 25,				// SATEN
	ADC3_OFR1_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC3_OFR1_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc3_ofr1_set_offset1_ch(struct ADC3_Type *p, uint32_t val) {
	p->OFR1 = (p->OFR1 & ~ADC3_OFR1_OFFSET1_CH) | ((val << 26) & ADC3_OFR1_OFFSET1_CH);
}
inline void adc3_ofr1_set_offset1(struct ADC3_Type *p, uint32_t val) {
	p->OFR1 = (p->OFR1 & ~ADC3_OFR1_OFFSET1) | ((val << 0) & ADC3_OFR1_OFFSET1);
}
inline uint32_t adc3_ofr1_get_offset1_ch(struct ADC3_Type *p) { return (p->OFR1 & ADC3_OFR1_OFFSET1_CH) >> 26; }
inline uint32_t adc3_ofr1_get_offset1(struct ADC3_Type *p) { return (p->OFR1 & ADC3_OFR1_OFFSET1) >> 0; }

// ADC3->OFR2 offset register 2
enum {
	ADC3_OFR2_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC3_OFR2_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC3_OFR2_SATEN		 = 1UL << 25,				// SATEN
	ADC3_OFR2_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC3_OFR2_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc3_ofr2_set_offset1_ch(struct ADC3_Type *p, uint32_t val) {
	p->OFR2 = (p->OFR2 & ~ADC3_OFR2_OFFSET1_CH) | ((val << 26) & ADC3_OFR2_OFFSET1_CH);
}
inline void adc3_ofr2_set_offset1(struct ADC3_Type *p, uint32_t val) {
	p->OFR2 = (p->OFR2 & ~ADC3_OFR2_OFFSET1) | ((val << 0) & ADC3_OFR2_OFFSET1);
}
inline uint32_t adc3_ofr2_get_offset1_ch(struct ADC3_Type *p) { return (p->OFR2 & ADC3_OFR2_OFFSET1_CH) >> 26; }
inline uint32_t adc3_ofr2_get_offset1(struct ADC3_Type *p) { return (p->OFR2 & ADC3_OFR2_OFFSET1) >> 0; }

// ADC3->OFR3 offset register 3
enum {
	ADC3_OFR3_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC3_OFR3_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC3_OFR3_SATEN		 = 1UL << 25,				// SATEN
	ADC3_OFR3_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC3_OFR3_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc3_ofr3_set_offset1_ch(struct ADC3_Type *p, uint32_t val) {
	p->OFR3 = (p->OFR3 & ~ADC3_OFR3_OFFSET1_CH) | ((val << 26) & ADC3_OFR3_OFFSET1_CH);
}
inline void adc3_ofr3_set_offset1(struct ADC3_Type *p, uint32_t val) {
	p->OFR3 = (p->OFR3 & ~ADC3_OFR3_OFFSET1) | ((val << 0) & ADC3_OFR3_OFFSET1);
}
inline uint32_t adc3_ofr3_get_offset1_ch(struct ADC3_Type *p) { return (p->OFR3 & ADC3_OFR3_OFFSET1_CH) >> 26; }
inline uint32_t adc3_ofr3_get_offset1(struct ADC3_Type *p) { return (p->OFR3 & ADC3_OFR3_OFFSET1) >> 0; }

// ADC3->OFR4 offset register 4
enum {
	ADC3_OFR4_OFFSET1_EN = 1UL << 31,				// OFFSET1_EN
	ADC3_OFR4_OFFSET1_CH = ((1UL << 5) - 1) << 26,	// OFFSET1_CH
	ADC3_OFR4_SATEN		 = 1UL << 25,				// SATEN
	ADC3_OFR4_OFFSETPOS	 = 1UL << 24,				// OFFSETPOS
	ADC3_OFR4_OFFSET1	 = ((1UL << 12) - 1) << 0,	// OFFSET1
};
inline void adc3_ofr4_set_offset1_ch(struct ADC3_Type *p, uint32_t val) {
	p->OFR4 = (p->OFR4 & ~ADC3_OFR4_OFFSET1_CH) | ((val << 26) & ADC3_OFR4_OFFSET1_CH);
}
inline void adc3_ofr4_set_offset1(struct ADC3_Type *p, uint32_t val) {
	p->OFR4 = (p->OFR4 & ~ADC3_OFR4_OFFSET1) | ((val << 0) & ADC3_OFR4_OFFSET1);
}
inline uint32_t adc3_ofr4_get_offset1_ch(struct ADC3_Type *p) { return (p->OFR4 & ADC3_OFR4_OFFSET1_CH) >> 26; }
inline uint32_t adc3_ofr4_get_offset1(struct ADC3_Type *p) { return (p->OFR4 & ADC3_OFR4_OFFSET1) >> 0; }

// ADC3->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC3_AWD2CR_AWD2CH = ((1UL << 19) - 1) << 0,  // AWD2CH
};
inline void adc3_awd2cr_set_awd2ch(struct ADC3_Type *p, uint32_t val) {
	p->AWD2CR = (p->AWD2CR & ~ADC3_AWD2CR_AWD2CH) | ((val << 0) & ADC3_AWD2CR_AWD2CH);
}
inline uint32_t adc3_awd2cr_get_awd2ch(struct ADC3_Type *p) { return (p->AWD2CR & ADC3_AWD2CR_AWD2CH) >> 0; }

// ADC3->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC3_AWD3CR_AWD3CH = ((1UL << 19) - 1) << 0,  // AWD3CH
};
inline void adc3_awd3cr_set_awd3ch(struct ADC3_Type *p, uint32_t val) {
	p->AWD3CR = (p->AWD3CR & ~ADC3_AWD3CR_AWD3CH) | ((val << 0) & ADC3_AWD3CR_AWD3CH);
}
inline uint32_t adc3_awd3cr_get_awd3ch(struct ADC3_Type *p) { return (p->AWD3CR & ADC3_AWD3CR_AWD3CH) >> 0; }

// ADC3->DIFSEL Differential Mode Selection Register 2
enum {
	ADC3_DIFSEL_DIFSEL_1_18 = ((1UL << 18) - 1) << 1,  // Differential mode for channels 15 to 1
	ADC3_DIFSEL_DIFSEL_0	= 1UL << 0,				   // Differential mode for channels 0
};
inline void adc3_difsel_set_difsel_1_18(struct ADC3_Type *p, uint32_t val) {
	p->DIFSEL = (p->DIFSEL & ~ADC3_DIFSEL_DIFSEL_1_18) | ((val << 1) & ADC3_DIFSEL_DIFSEL_1_18);
}
inline uint32_t adc3_difsel_get_difsel_1_18(struct ADC3_Type *p) { return (p->DIFSEL & ADC3_DIFSEL_DIFSEL_1_18) >> 1; }

// ADC3->CALFACT Calibration Factors
enum {
	ADC3_CALFACT_CALFACT_D = ((1UL << 7) - 1) << 16,  // CALFACT_D
	ADC3_CALFACT_CALFACT_S = ((1UL << 7) - 1) << 0,	  // CALFACT_S
};
inline void adc3_calfact_set_calfact_d(struct ADC3_Type *p, uint32_t val) {
	p->CALFACT = (p->CALFACT & ~ADC3_CALFACT_CALFACT_D) | ((val << 16) & ADC3_CALFACT_CALFACT_D);
}
inline void adc3_calfact_set_calfact_s(struct ADC3_Type *p, uint32_t val) {
	p->CALFACT = (p->CALFACT & ~ADC3_CALFACT_CALFACT_S) | ((val << 0) & ADC3_CALFACT_CALFACT_S);
}
inline uint32_t adc3_calfact_get_calfact_d(struct ADC3_Type *p) { return (p->CALFACT & ADC3_CALFACT_CALFACT_D) >> 16; }
inline uint32_t adc3_calfact_get_calfact_s(struct ADC3_Type *p) { return (p->CALFACT & ADC3_CALFACT_CALFACT_S) >> 0; }

// ADC3->GCOMP Gain compensation Register
enum {
	ADC3_GCOMP_GCOMPCOEFF = ((1UL << 14) - 1) << 0,	 // GCOMPCOEFF
};
inline void adc3_gcomp_set_gcompcoeff(struct ADC3_Type *p, uint32_t val) {
	p->GCOMP = (p->GCOMP & ~ADC3_GCOMP_GCOMPCOEFF) | ((val << 0) & ADC3_GCOMP_GCOMPCOEFF);
}
inline uint32_t adc3_gcomp_get_gcompcoeff(struct ADC3_Type *p) { return (p->GCOMP & ADC3_GCOMP_GCOMPCOEFF) >> 0; }

/* Advanced encryption standard hardware accelerator */
struct AES_Type {
	__IO uint32_t CR;			 // @0 control register
	__I uint8_t	  SR;			 // @4 status register
	uint8_t		  RESERVED0[3];	 // @5
	__IO uint32_t DINR;			 // @8 data input register
	__I uint32_t  DOUTR;		 // @12 data output register
	__IO uint32_t KEYR0;		 // @16 key register 0
	__IO uint32_t KEYR1;		 // @20 key register 1
	__IO uint32_t KEYR2;		 // @24 key register 2
	__IO uint32_t KEYR3;		 // @28 key register 3
	__IO uint32_t IVR0;			 // @32 initialization vector register 0
	__IO uint32_t IVR1;			 // @36 initialization vector register 1
	__IO uint32_t IVR2;			 // @40 initialization vector register 2
	__IO uint32_t IVR3;			 // @44 initialization vector register 3
	__IO uint32_t KEYR4;		 // @48 key register 4
	__IO uint32_t KEYR5;		 // @52 key register 5
	__IO uint32_t KEYR6;		 // @56 key register 6
	__IO uint32_t KEYR7;		 // @60 key register 7
	__IO uint32_t SUSP0R;		 // @64 suspend registers
	__IO uint32_t SUSP1R;		 // @68 suspend registers
	__IO uint32_t SUSP2R;		 // @72 suspend registers
	__IO uint32_t SUSP3R;		 // @76 suspend registers
	__IO uint32_t SUSP4R;		 // @80 suspend registers
	__IO uint32_t SUSP5R;		 // @84 suspend registers
	__IO uint32_t SUSP6R;		 // @88 suspend registers
	__IO uint32_t SUSP7R;		 // @92 suspend registers
};

// AES->CR control register
enum {
	AES_CR_NPBLB	= ((1UL << 4) - 1) << 20,  // NPBLB
	AES_CR_KEYSIZE	= 1UL << 18,			   // KEYSIZE
	AES_CR_CHMOD_2	= 1UL << 16,			   // CHMOD_2
	AES_CR_GCMPH	= ((1UL << 2) - 1) << 13,  // GCMPH
	AES_CR_DMAOUTEN = 1UL << 12,			   // Enable DMA management of data output phase
	AES_CR_DMAINEN	= 1UL << 11,			   // Enable DMA management of data input phase
	AES_CR_ERRIE	= 1UL << 10,			   // Error interrupt enable
	AES_CR_CCFIE	= 1UL << 9,				   // CCF flag interrupt enable
	AES_CR_ERRC		= 1UL << 8,				   // Error clear
	AES_CR_CCFC		= 1UL << 7,				   // Computation Complete Flag Clear
	AES_CR_CHMOD	= ((1UL << 2) - 1) << 5,   // AES chaining mode
	AES_CR_MODE		= ((1UL << 2) - 1) << 3,   // AES operating mode
	AES_CR_DATATYPE = ((1UL << 2) - 1) << 1,   // Data type selection (for data in and data out to/from the cryptographic block)
	AES_CR_EN		= 1UL << 0,				   // AES enable
};
inline void aes_cr_set_npblb(struct AES_Type *p, uint32_t val) { p->CR = (p->CR & ~AES_CR_NPBLB) | ((val << 20) & AES_CR_NPBLB); }
inline void aes_cr_set_gcmph(struct AES_Type *p, uint32_t val) { p->CR = (p->CR & ~AES_CR_GCMPH) | ((val << 13) & AES_CR_GCMPH); }
inline void aes_cr_set_chmod(struct AES_Type *p, uint32_t val) { p->CR = (p->CR & ~AES_CR_CHMOD) | ((val << 5) & AES_CR_CHMOD); }
inline void aes_cr_set_mode(struct AES_Type *p, uint32_t val) { p->CR = (p->CR & ~AES_CR_MODE) | ((val << 3) & AES_CR_MODE); }
inline void aes_cr_set_datatype(struct AES_Type *p, uint32_t val) {
	p->CR = (p->CR & ~AES_CR_DATATYPE) | ((val << 1) & AES_CR_DATATYPE);
}
inline uint32_t aes_cr_get_npblb(struct AES_Type *p) { return (p->CR & AES_CR_NPBLB) >> 20; }
inline uint32_t aes_cr_get_gcmph(struct AES_Type *p) { return (p->CR & AES_CR_GCMPH) >> 13; }
inline uint32_t aes_cr_get_chmod(struct AES_Type *p) { return (p->CR & AES_CR_CHMOD) >> 5; }
inline uint32_t aes_cr_get_mode(struct AES_Type *p) { return (p->CR & AES_CR_MODE) >> 3; }
inline uint32_t aes_cr_get_datatype(struct AES_Type *p) { return (p->CR & AES_CR_DATATYPE) >> 1; }

// AES->SR status register
enum {
	AES_SR_BUSY	 = 1UL << 3,  // BUSY
	AES_SR_WRERR = 1UL << 2,  // Write error flag
	AES_SR_RDERR = 1UL << 1,  // Read error flag
	AES_SR_CCF	 = 1UL << 0,  // Computation complete flag
};

/* Comparator control and status register */
struct COMP_Type {
	__IO uint32_t C1CSR;  // @0 Comparator control/status register
	__IO uint32_t C2CSR;  // @4 Comparator control/status register
	__IO uint32_t C3CSR;  // @8 Comparator control/status register
	__IO uint32_t C4CSR;  // @12 Comparator control/status register
	__IO uint32_t C5CSR;  // @16 Comparator control/status register
	__IO uint32_t C6CSR;  // @20 Comparator control/status register
	__IO uint32_t C7CSR;  // @24 Comparator control/status register
};

// COMP->C1CSR Comparator control/status register
enum {
	COMP_C1CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C1CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C1CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C1CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C1CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C1CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C1CSR_POL		= 1UL << 15,			   // POL
	COMP_C1CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C1CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C1CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c1csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C1CSR = (p->C1CSR & ~COMP_C1CSR_BLANKSEL) | ((val << 19) & COMP_C1CSR_BLANKSEL);
}
inline void comp_c1csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C1CSR = (p->C1CSR & ~COMP_C1CSR_HYST) | ((val << 16) & COMP_C1CSR_HYST);
}
inline void comp_c1csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C1CSR = (p->C1CSR & ~COMP_C1CSR_INMSEL) | ((val << 4) & COMP_C1CSR_INMSEL);
}
inline uint32_t comp_c1csr_get_blanksel(struct COMP_Type *p) { return (p->C1CSR & COMP_C1CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c1csr_get_hyst(struct COMP_Type *p) { return (p->C1CSR & COMP_C1CSR_HYST) >> 16; }
inline uint32_t comp_c1csr_get_inmsel(struct COMP_Type *p) { return (p->C1CSR & COMP_C1CSR_INMSEL) >> 4; }

// COMP->C2CSR Comparator control/status register
enum {
	COMP_C2CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C2CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C2CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C2CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C2CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C2CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C2CSR_POL		= 1UL << 15,			   // POL
	COMP_C2CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C2CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C2CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c2csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C2CSR = (p->C2CSR & ~COMP_C2CSR_BLANKSEL) | ((val << 19) & COMP_C2CSR_BLANKSEL);
}
inline void comp_c2csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C2CSR = (p->C2CSR & ~COMP_C2CSR_HYST) | ((val << 16) & COMP_C2CSR_HYST);
}
inline void comp_c2csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C2CSR = (p->C2CSR & ~COMP_C2CSR_INMSEL) | ((val << 4) & COMP_C2CSR_INMSEL);
}
inline uint32_t comp_c2csr_get_blanksel(struct COMP_Type *p) { return (p->C2CSR & COMP_C2CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c2csr_get_hyst(struct COMP_Type *p) { return (p->C2CSR & COMP_C2CSR_HYST) >> 16; }
inline uint32_t comp_c2csr_get_inmsel(struct COMP_Type *p) { return (p->C2CSR & COMP_C2CSR_INMSEL) >> 4; }

// COMP->C3CSR Comparator control/status register
enum {
	COMP_C3CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C3CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C3CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C3CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C3CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C3CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C3CSR_POL		= 1UL << 15,			   // POL
	COMP_C3CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C3CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C3CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c3csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C3CSR = (p->C3CSR & ~COMP_C3CSR_BLANKSEL) | ((val << 19) & COMP_C3CSR_BLANKSEL);
}
inline void comp_c3csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C3CSR = (p->C3CSR & ~COMP_C3CSR_HYST) | ((val << 16) & COMP_C3CSR_HYST);
}
inline void comp_c3csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C3CSR = (p->C3CSR & ~COMP_C3CSR_INMSEL) | ((val << 4) & COMP_C3CSR_INMSEL);
}
inline uint32_t comp_c3csr_get_blanksel(struct COMP_Type *p) { return (p->C3CSR & COMP_C3CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c3csr_get_hyst(struct COMP_Type *p) { return (p->C3CSR & COMP_C3CSR_HYST) >> 16; }
inline uint32_t comp_c3csr_get_inmsel(struct COMP_Type *p) { return (p->C3CSR & COMP_C3CSR_INMSEL) >> 4; }

// COMP->C4CSR Comparator control/status register
enum {
	COMP_C4CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C4CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C4CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C4CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C4CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C4CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C4CSR_POL		= 1UL << 15,			   // POL
	COMP_C4CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C4CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C4CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c4csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C4CSR = (p->C4CSR & ~COMP_C4CSR_BLANKSEL) | ((val << 19) & COMP_C4CSR_BLANKSEL);
}
inline void comp_c4csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C4CSR = (p->C4CSR & ~COMP_C4CSR_HYST) | ((val << 16) & COMP_C4CSR_HYST);
}
inline void comp_c4csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C4CSR = (p->C4CSR & ~COMP_C4CSR_INMSEL) | ((val << 4) & COMP_C4CSR_INMSEL);
}
inline uint32_t comp_c4csr_get_blanksel(struct COMP_Type *p) { return (p->C4CSR & COMP_C4CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c4csr_get_hyst(struct COMP_Type *p) { return (p->C4CSR & COMP_C4CSR_HYST) >> 16; }
inline uint32_t comp_c4csr_get_inmsel(struct COMP_Type *p) { return (p->C4CSR & COMP_C4CSR_INMSEL) >> 4; }

// COMP->C5CSR Comparator control/status register
enum {
	COMP_C5CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C5CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C5CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C5CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C5CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C5CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C5CSR_POL		= 1UL << 15,			   // POL
	COMP_C5CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C5CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C5CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c5csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C5CSR = (p->C5CSR & ~COMP_C5CSR_BLANKSEL) | ((val << 19) & COMP_C5CSR_BLANKSEL);
}
inline void comp_c5csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C5CSR = (p->C5CSR & ~COMP_C5CSR_HYST) | ((val << 16) & COMP_C5CSR_HYST);
}
inline void comp_c5csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C5CSR = (p->C5CSR & ~COMP_C5CSR_INMSEL) | ((val << 4) & COMP_C5CSR_INMSEL);
}
inline uint32_t comp_c5csr_get_blanksel(struct COMP_Type *p) { return (p->C5CSR & COMP_C5CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c5csr_get_hyst(struct COMP_Type *p) { return (p->C5CSR & COMP_C5CSR_HYST) >> 16; }
inline uint32_t comp_c5csr_get_inmsel(struct COMP_Type *p) { return (p->C5CSR & COMP_C5CSR_INMSEL) >> 4; }

// COMP->C6CSR Comparator control/status register
enum {
	COMP_C6CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C6CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C6CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C6CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C6CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C6CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C6CSR_POL		= 1UL << 15,			   // POL
	COMP_C6CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C6CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C6CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c6csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C6CSR = (p->C6CSR & ~COMP_C6CSR_BLANKSEL) | ((val << 19) & COMP_C6CSR_BLANKSEL);
}
inline void comp_c6csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C6CSR = (p->C6CSR & ~COMP_C6CSR_HYST) | ((val << 16) & COMP_C6CSR_HYST);
}
inline void comp_c6csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C6CSR = (p->C6CSR & ~COMP_C6CSR_INMSEL) | ((val << 4) & COMP_C6CSR_INMSEL);
}
inline uint32_t comp_c6csr_get_blanksel(struct COMP_Type *p) { return (p->C6CSR & COMP_C6CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c6csr_get_hyst(struct COMP_Type *p) { return (p->C6CSR & COMP_C6CSR_HYST) >> 16; }
inline uint32_t comp_c6csr_get_inmsel(struct COMP_Type *p) { return (p->C6CSR & COMP_C6CSR_INMSEL) >> 4; }

// COMP->C7CSR Comparator control/status register
enum {
	COMP_C7CSR_LOCK		= 1UL << 31,			   // LOCK
	COMP_C7CSR_VALUE	= 1UL << 30,			   // VALUE
	COMP_C7CSR_SCALEN	= 1UL << 23,			   // SCALEN
	COMP_C7CSR_BRGEN	= 1UL << 22,			   // BRGEN
	COMP_C7CSR_BLANKSEL = ((1UL << 3) - 1) << 19,  // BLANKSEL
	COMP_C7CSR_HYST		= ((1UL << 3) - 1) << 16,  // HYST
	COMP_C7CSR_POL		= 1UL << 15,			   // POL
	COMP_C7CSR_INPSEL	= 1UL << 8,				   // INPSEL
	COMP_C7CSR_INMSEL	= ((1UL << 3) - 1) << 4,   // INMSEL
	COMP_C7CSR_EN		= 1UL << 0,				   // EN
};
inline void comp_c7csr_set_blanksel(struct COMP_Type *p, uint32_t val) {
	p->C7CSR = (p->C7CSR & ~COMP_C7CSR_BLANKSEL) | ((val << 19) & COMP_C7CSR_BLANKSEL);
}
inline void comp_c7csr_set_hyst(struct COMP_Type *p, uint32_t val) {
	p->C7CSR = (p->C7CSR & ~COMP_C7CSR_HYST) | ((val << 16) & COMP_C7CSR_HYST);
}
inline void comp_c7csr_set_inmsel(struct COMP_Type *p, uint32_t val) {
	p->C7CSR = (p->C7CSR & ~COMP_C7CSR_INMSEL) | ((val << 4) & COMP_C7CSR_INMSEL);
}
inline uint32_t comp_c7csr_get_blanksel(struct COMP_Type *p) { return (p->C7CSR & COMP_C7CSR_BLANKSEL) >> 19; }
inline uint32_t comp_c7csr_get_hyst(struct COMP_Type *p) { return (p->C7CSR & COMP_C7CSR_HYST) >> 16; }
inline uint32_t comp_c7csr_get_inmsel(struct COMP_Type *p) { return (p->C7CSR & COMP_C7CSR_INMSEL) >> 4; }

/* CORDIC Co-processor */
struct CORDIC_Type {
	__IO uint32_t CSR;	  // @0 CORDIC Control Status register
	__IO uint32_t WDATA;  // @4 FMAC Write Data register
	__I uint32_t  RDATA;  // @8 FMAC Read Data register
};

// CORDIC->CSR CORDIC Control Status register
enum {
	CORDIC_CSR_RRDY		 = 1UL << 31,			   // RRDY
	CORDIC_CSR_ARGSIZE	 = 1UL << 22,			   // ARGSIZE
	CORDIC_CSR_RESSIZE	 = 1UL << 21,			   // RESSIZE
	CORDIC_CSR_NARGS	 = 1UL << 20,			   // NARGS
	CORDIC_CSR_NRES		 = 1UL << 19,			   // NRES
	CORDIC_CSR_DMAWEN	 = 1UL << 18,			   // DMAWEN
	CORDIC_CSR_DMAREN	 = 1UL << 17,			   // DMAREN
	CORDIC_CSR_IEN		 = 1UL << 16,			   // IEN
	CORDIC_CSR_SCALE	 = ((1UL << 3) - 1) << 8,  // SCALE
	CORDIC_CSR_PRECISION = ((1UL << 4) - 1) << 4,  // PRECISION
	CORDIC_CSR_FUNC		 = ((1UL << 4) - 1) << 0,  // FUNC
};
inline void cordic_csr_set_scale(struct CORDIC_Type *p, uint32_t val) {
	p->CSR = (p->CSR & ~CORDIC_CSR_SCALE) | ((val << 8) & CORDIC_CSR_SCALE);
}
inline void cordic_csr_set_precision(struct CORDIC_Type *p, uint32_t val) {
	p->CSR = (p->CSR & ~CORDIC_CSR_PRECISION) | ((val << 4) & CORDIC_CSR_PRECISION);
}
inline void cordic_csr_set_func(struct CORDIC_Type *p, uint32_t val) {
	p->CSR = (p->CSR & ~CORDIC_CSR_FUNC) | ((val << 0) & CORDIC_CSR_FUNC);
}
inline uint32_t cordic_csr_get_scale(struct CORDIC_Type *p) { return (p->CSR & CORDIC_CSR_SCALE) >> 8; }
inline uint32_t cordic_csr_get_precision(struct CORDIC_Type *p) { return (p->CSR & CORDIC_CSR_PRECISION) >> 4; }
inline uint32_t cordic_csr_get_func(struct CORDIC_Type *p) { return (p->CSR & CORDIC_CSR_FUNC) >> 0; }

/* Cyclic redundancy check calculation unit */
struct CRC_Type {
	__IO uint32_t DR;			 // @0 Data register
	__IO uint32_t IDR;			 // @4 Independent data register
	__IO uint8_t  CR;			 // @8 Control register
	uint8_t		  RESERVED0[7];	 // @9
	__IO uint32_t INIT;			 // @16 Initial CRC value
	__IO uint32_t POL;			 // @20 polynomial
};

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT	= 1UL << 7,				  // Reverse output data
	CRC_CR_REV_IN	= ((1UL << 2) - 1) << 5,  // Reverse input data
	CRC_CR_POLYSIZE = ((1UL << 2) - 1) << 3,  // Polynomial size
	CRC_CR_RESET	= 1UL << 0,				  // RESET bit
};
inline void crc_cr_set_rev_in(struct CRC_Type *p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_REV_IN) | ((val << 5) & CRC_CR_REV_IN); }
inline void crc_cr_set_polysize(struct CRC_Type *p, uint32_t val) {
	p->CR = (p->CR & ~CRC_CR_POLYSIZE) | ((val << 3) & CRC_CR_POLYSIZE);
}
inline uint32_t crc_cr_get_rev_in(struct CRC_Type *p) { return (p->CR & CRC_CR_REV_IN) >> 5; }
inline uint32_t crc_cr_get_polysize(struct CRC_Type *p) { return (p->CR & CRC_CR_POLYSIZE) >> 3; }

/* CRS */
struct CRS_Type {
	__IO uint16_t CR;			 // @0 CRS control register
	uint8_t		  RESERVED0[2];	 // @2
	__IO uint32_t CFGR;	 // @4 This register can be written only when the frequency error counter is disabled (CEN bit is cleared in
						 // CRS_CR). When the counter is enabled, this register is write-protected.
	__I uint32_t ISR;	 // @8 CRS interrupt and status register
	__IO uint8_t ICR;	 // @12 CRS interrupt flag clear register
};

// CRS->CR CRS control register
enum {
	CRS_CR_TRIM =
			((1UL << 7) - 1)
			<< 8,  // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48
				   // oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the
				   // frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The
				   // trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher
				   // output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
	CRS_CR_SWSYNC = 1UL << 7,  // Generate software SYNC event This bit is set by software in order to generate a software SYNC
							   // event. It is automatically cleared by hardware.
	CRS_CR_AUTOTRIMEN =
			1UL << 6,  // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the
					   // measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The
					   // TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency
					   // error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
	CRS_CR_CEN = 1UL << 5,	// Frequency error counter enable This bit enables the oscillator clock for the frequency error counter.
							// When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
	CRS_CR_ESYNCIE	  = 1UL << 3,  // Expected SYNC interrupt enable
	CRS_CR_ERRIE	  = 1UL << 2,  // Synchronization or trimming error interrupt enable
	CRS_CR_SYNCWARNIE = 1UL << 1,  // SYNC warning interrupt enable
	CRS_CR_SYNCOKIE	  = 1UL << 0,  // SYNC event OK interrupt enable
};
inline void		crs_cr_set_trim(struct CRS_Type *p, uint32_t val) { p->CR = (p->CR & ~CRS_CR_TRIM) | ((val << 8) & CRS_CR_TRIM); }
inline uint32_t crs_cr_get_trim(struct CRS_Type *p) { return (p->CR & CRS_CR_TRIM) >> 8; }

// CRS->CFGR This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the
// counter is enabled, this register is write-protected.
enum {
	CRS_CFGR_SYNCPOL = 1UL << 31,  // SYNC polarity selection This bit is set and cleared by software to select the input polarity
								   // for the SYNC signal source.
	CRS_CFGR_SYNCSRC = ((1UL << 2) - 1)
					   << 28,  // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal
							   // source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the
							   // periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to
							   // the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking
							   // up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
	CRS_CFGR_SYNCDIV =
			((1UL << 3) - 1)
			<< 24,	// SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
	CRS_CFGR_FELIM =
			((1UL << 8) - 1) << 16,	 // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency
									 // error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4:
									 // Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
	CRS_CFGR_RELOAD = ((1UL << 16) - 1)
					  << 0,	 // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC
							 // event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
};
inline void crs_cfgr_set_syncsrc(struct CRS_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCSRC) | ((val << 28) & CRS_CFGR_SYNCSRC);
}
inline void crs_cfgr_set_syncdiv(struct CRS_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCDIV) | ((val << 24) & CRS_CFGR_SYNCDIV);
}
inline void crs_cfgr_set_felim(struct CRS_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_FELIM) | ((val << 16) & CRS_CFGR_FELIM);
}
inline void crs_cfgr_set_reload(struct CRS_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_RELOAD) | ((val << 0) & CRS_CFGR_RELOAD);
}
inline uint32_t crs_cfgr_get_syncsrc(struct CRS_Type *p) { return (p->CFGR & CRS_CFGR_SYNCSRC) >> 28; }
inline uint32_t crs_cfgr_get_syncdiv(struct CRS_Type *p) { return (p->CFGR & CRS_CFGR_SYNCDIV) >> 24; }
inline uint32_t crs_cfgr_get_felim(struct CRS_Type *p) { return (p->CFGR & CRS_CFGR_FELIM) >> 16; }
inline uint32_t crs_cfgr_get_reload(struct CRS_Type *p) { return (p->CFGR & CRS_CFGR_RELOAD) >> 0; }

// CRS->ISR CRS interrupt and status register
enum {
	CRS_ISR_FECAP =
			((1UL << 16) - 1)
			<< 16,	// Frequency error capture FECAP is the frequency error counter value latched in the time ofthe last SYNC event.
					// Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
	CRS_ISR_FEDIR =
			1UL << 15,	// Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the
						// time of the last SYNC event. It shows whether the actual frequency is below or above the target.
	CRS_ISR_TRIMOVF = 1UL << 10,  // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries
								  // to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the
								  // CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCMISS = 1UL << 9,  // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM *
								  // 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency
								  // error is too big (internal frequency too high) to be compensated by adjusting the TRIM value,
								  // and that some other action should be taken. At this point, the frequency error counter is
								  // stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the
								  // CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCERR =
			1UL << 8,  // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the
					   // measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is
					   // too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other
					   // action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is
					   // cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_ESYNCF = 1UL << 3,	// Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero
								// value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared
								// by software by setting the ESYNCC bit in the CRS_ICR register.
	CRS_ISR_ERRF = 1UL << 2,  // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the
							  // logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is
							  // set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the
							  // CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
	CRS_ISR_SYNCWARNF =
			1UL << 1,  // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal
					   // to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM
					   // value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the
					   // CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
	CRS_ISR_SYNCOKF =
			1UL
			<< 0,  // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3.
				   // This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is
				   // enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR
				   // register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
};
inline uint32_t crs_isr_get_fecap(struct CRS_Type *p) { return (p->ISR & CRS_ISR_FECAP) >> 16; }

// CRS->ICR CRS interrupt flag clear register
enum {
	CRS_ICR_ESYNCC = 1UL << 3,	// Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
	CRS_ICR_ERRC   = 1UL << 2,	// Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently
								// also the ERRF flag in the CRS_ISR register.
	CRS_ICR_SYNCWARNC =
			1UL << 1,			 // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
	CRS_ICR_SYNCOKC = 1UL << 0,	 // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
};

/* Digital-to-analog converter */
struct DAC1_Type {
	__IO uint32_t DAC_CR;		 // @0 DAC control register
	__O uint32_t  DAC_SWTRGR;	 // @4 DAC software trigger register
	__IO uint32_t DAC_DHR12R1;	 // @8 DAC channel1 12-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12L1;	 // @12 DAC channel1 12-bit left aligned data holding register
	__IO uint16_t DAC_DHR8R1;	 // @16 DAC channel1 8-bit right aligned data holding register
	uint8_t		  RESERVED0[2];	 // @18
	__IO uint32_t DAC_DHR12R2;	 // @20 DAC channel2 12-bit right aligned data holding register
	__IO uint32_t DAC_DHR12L2;	 // @24 DAC channel2 12-bit left aligned data holding register
	__IO uint16_t DAC_DHR8R2;	 // @28 DAC channel2 8-bit right-aligned data holding register
	uint8_t		  RESERVED1[2];	 // @30
	__IO uint32_t DAC_DHR12RD;	 // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12LD;	 // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint16_t DAC_DHR8RD;	 // @40 DUAL DAC 8-bit right aligned data holding register
	uint8_t		  RESERVED2[2];	 // @42
	__I uint32_t  DAC_DOR1;		 // @44 DAC channel1 data output register
	__I uint32_t  DAC_DOR2;		 // @48 DAC channel2 data output register
	__IO uint32_t DAC_SR;		 // @52 DAC status register
	__IO uint32_t DAC_CCR;		 // @56 DAC calibration control register
	__IO uint32_t DAC_MCR;		 // @60 DAC mode control register
	__IO uint16_t DAC_SHSR1;	 // @64 DAC Sample and Hold sample time register 1
	uint8_t		  RESERVED3[2];	 // @66
	__IO uint16_t DAC_SHSR2;	 // @68 DAC Sample and Hold sample time register 2
	uint8_t		  RESERVED4[2];	 // @70
	__IO uint32_t DAC_SHHR;		 // @72 DAC Sample and Hold hold time register
	__IO uint32_t DAC_SHRR;		 // @76 DAC Sample and Hold refresh time register
	uint8_t		  RESERVED5[8];	 // @80
	__IO uint32_t DAC_STR1;		 // @88 Sawtooth register
	__IO uint32_t DAC_STR2;		 // @92 Sawtooth register
	__IO uint32_t DAC_STMODR;	 // @96 Sawtooth Mode register
};

// DAC1->DAC_CR DAC control register
enum {
	DAC1_DAC_CR_CEN2 =
			1UL << 30,	// DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2
						// calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit
						// only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC1_DAC_CR_DMAUDRIE2 = 1UL << 29,	// DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
	DAC1_DAC_CR_DMAEN2	  = 1UL << 28,	// DAC channel2 DMA enable This bit is set and cleared by software.
	DAC1_DAC_CR_MAMP2	  = ((1UL << 4) - 1) << 24,	 // DAC channel2 mask/amplitude selector These bits are written by software to
												 // select mask in wave generation mode or amplitude in triangle generation mode. =
												 // 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC1_DAC_CR_WAVE2 = ((1UL << 2) - 1)
						<< 22,	// DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x:
								// Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
	DAC1_DAC_CR_TSEL2 =
			((1UL << 4) - 1) << 18,	 // DAC channel2 trigger selection These bits select the external event used to trigger DAC
									 // channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
	DAC1_DAC_CR_TEN2 = 1UL << 17,	 // DAC channel2 trigger enable
	DAC1_DAC_CR_EN2	 = 1UL << 16,	 // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
	DAC1_DAC_CR_CEN1 =
			1UL << 14,	// DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1
						// calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit
						// only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC1_DAC_CR_DMAUDRIE1 = 1UL << 13,	// DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
	DAC1_DAC_CR_DMAEN1	  = 1UL << 12,	// DAC channel1 DMA enable This bit is set and cleared by software.
	DAC1_DAC_CR_MAMP1 =
			((1UL << 4) - 1)
			<< 8,  // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode
				   // or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC1_DAC_CR_WAVE1 = ((1UL << 2) - 1) << 6,	// DAC channel1 noise/triangle wave generation enable These bits are set and cleared
												// by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC1_DAC_CR_TSEL1 =
			((1UL << 4) - 1) << 2,	// DAC channel1 trigger selection These bits select the external event used to trigger DAC
									// channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC1_DAC_CR_TEN1 = 1UL << 1,	// DAC channel1 trigger enable
	DAC1_DAC_CR_EN1	 = 1UL << 0,	// DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
};
inline void dac1_dac_cr_set_mamp2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_MAMP2) | ((val << 24) & DAC1_DAC_CR_MAMP2);
}
inline void dac1_dac_cr_set_wave2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_WAVE2) | ((val << 22) & DAC1_DAC_CR_WAVE2);
}
inline void dac1_dac_cr_set_tsel2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_TSEL2) | ((val << 18) & DAC1_DAC_CR_TSEL2);
}
inline void dac1_dac_cr_set_mamp1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_MAMP1) | ((val << 8) & DAC1_DAC_CR_MAMP1);
}
inline void dac1_dac_cr_set_wave1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_WAVE1) | ((val << 6) & DAC1_DAC_CR_WAVE1);
}
inline void dac1_dac_cr_set_tsel1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_TSEL1) | ((val << 2) & DAC1_DAC_CR_TSEL1);
}
inline uint32_t dac1_dac_cr_get_mamp2(struct DAC1_Type *p) { return (p->DAC_CR & DAC1_DAC_CR_MAMP2) >> 24; }
inline uint32_t dac1_dac_cr_get_wave2(struct DAC1_Type *p) { return (p->DAC_CR & DAC1_DAC_CR_WAVE2) >> 22; }
inline uint32_t dac1_dac_cr_get_tsel2(struct DAC1_Type *p) { return (p->DAC_CR & DAC1_DAC_CR_TSEL2) >> 18; }
inline uint32_t dac1_dac_cr_get_mamp1(struct DAC1_Type *p) { return (p->DAC_CR & DAC1_DAC_CR_MAMP1) >> 8; }
inline uint32_t dac1_dac_cr_get_wave1(struct DAC1_Type *p) { return (p->DAC_CR & DAC1_DAC_CR_WAVE1) >> 6; }
inline uint32_t dac1_dac_cr_get_tsel1(struct DAC1_Type *p) { return (p->DAC_CR & DAC1_DAC_CR_TSEL1) >> 2; }

// DAC1->DAC_SWTRGR DAC software trigger register
enum {
	DAC1_DAC_SWTRGR_SWTRIGB2 = 1UL << 17,  // DAC channel2 software trigger B
	DAC1_DAC_SWTRGR_SWTRIGB1 = 1UL << 16,  // DAC channel1 software trigger B
	DAC1_DAC_SWTRGR_SWTRIG2 = 1UL << 1,	 // DAC channel2 software trigger This bit is set by software to trigger the DAC in software
										 // trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once
										 // the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
	DAC1_DAC_SWTRGR_SWTRIG1 = 1UL << 0,	 // DAC channel1 software trigger This bit is set by software to trigger the DAC in software
										 // trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once
										 // the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
};

// DAC1->DAC_DHR12R1 DAC channel1 12-bit right-aligned data holding register
enum {
	DAC1_DAC_DHR12R1_DACC1DHRB = ((1UL << 12) - 1) << 16,  // DAC channel1 12-bit right-aligned data B
	DAC1_DAC_DHR12R1_DACC1DHR  = ((1UL << 12) - 1) << 0,   // DAC channel1 12-bit right-aligned data These bits are written by
														   // software which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12r1_set_dacc1dhrb(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12R1 = (p->DAC_DHR12R1 & ~DAC1_DAC_DHR12R1_DACC1DHRB) | ((val << 16) & DAC1_DAC_DHR12R1_DACC1DHRB);
}
inline void dac1_dac_dhr12r1_set_dacc1dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12R1 = (p->DAC_DHR12R1 & ~DAC1_DAC_DHR12R1_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR12R1_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12r1_get_dacc1dhrb(struct DAC1_Type *p) { return (p->DAC_DHR12R1 & DAC1_DAC_DHR12R1_DACC1DHRB) >> 16; }
inline uint32_t dac1_dac_dhr12r1_get_dacc1dhr(struct DAC1_Type *p) { return (p->DAC_DHR12R1 & DAC1_DAC_DHR12R1_DACC1DHR) >> 0; }

// DAC1->DAC_DHR12L1 DAC channel1 12-bit left aligned data holding register
enum {
	DAC1_DAC_DHR12L1_DACC1DHRB = ((1UL << 12) - 1) << 20,  // DAC channel1 12-bit left-aligned data B
	DAC1_DAC_DHR12L1_DACC1DHR = ((1UL << 12) - 1) << 4,	 // DAC channel1 12-bit left-aligned data These bits are written by software
														 // which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12l1_set_dacc1dhrb(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12L1 = (p->DAC_DHR12L1 & ~DAC1_DAC_DHR12L1_DACC1DHRB) | ((val << 20) & DAC1_DAC_DHR12L1_DACC1DHRB);
}
inline void dac1_dac_dhr12l1_set_dacc1dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12L1 = (p->DAC_DHR12L1 & ~DAC1_DAC_DHR12L1_DACC1DHR) | ((val << 4) & DAC1_DAC_DHR12L1_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12l1_get_dacc1dhrb(struct DAC1_Type *p) { return (p->DAC_DHR12L1 & DAC1_DAC_DHR12L1_DACC1DHRB) >> 20; }
inline uint32_t dac1_dac_dhr12l1_get_dacc1dhr(struct DAC1_Type *p) { return (p->DAC_DHR12L1 & DAC1_DAC_DHR12L1_DACC1DHR) >> 4; }

// DAC1->DAC_DHR8R1 DAC channel1 8-bit right aligned data holding register
enum {
	DAC1_DAC_DHR8R1_DACC1DHRB = ((1UL << 8) - 1) << 8,	// DAC channel1 8-bit right-aligned data
	DAC1_DAC_DHR8R1_DACC1DHR  = ((1UL << 8) - 1) << 0,	// DAC channel1 8-bit right-aligned data These bits are written by software
														// which specifies 8-bit data for DAC channel1.
};
inline void dac1_dac_dhr8r1_set_dacc1dhrb(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR8R1 = (p->DAC_DHR8R1 & ~DAC1_DAC_DHR8R1_DACC1DHRB) | ((val << 8) & DAC1_DAC_DHR8R1_DACC1DHRB);
}
inline void dac1_dac_dhr8r1_set_dacc1dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR8R1 = (p->DAC_DHR8R1 & ~DAC1_DAC_DHR8R1_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR8R1_DACC1DHR);
}
inline uint32_t dac1_dac_dhr8r1_get_dacc1dhrb(struct DAC1_Type *p) { return (p->DAC_DHR8R1 & DAC1_DAC_DHR8R1_DACC1DHRB) >> 8; }
inline uint32_t dac1_dac_dhr8r1_get_dacc1dhr(struct DAC1_Type *p) { return (p->DAC_DHR8R1 & DAC1_DAC_DHR8R1_DACC1DHR) >> 0; }

// DAC1->DAC_DHR12R2 DAC channel2 12-bit right aligned data holding register
enum {
	DAC1_DAC_DHR12R2_DACC2DHRB = ((1UL << 12) - 1) << 16,  // DAC channel2 12-bit right-aligned data
	DAC1_DAC_DHR12R2_DACC2DHR  = ((1UL << 12) - 1) << 0,   // DAC channel2 12-bit right-aligned data These bits are written by
														   // software which specifies 12-bit data for DAC channel2.
};
inline void dac1_dac_dhr12r2_set_dacc2dhrb(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12R2 = (p->DAC_DHR12R2 & ~DAC1_DAC_DHR12R2_DACC2DHRB) | ((val << 16) & DAC1_DAC_DHR12R2_DACC2DHRB);
}
inline void dac1_dac_dhr12r2_set_dacc2dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12R2 = (p->DAC_DHR12R2 & ~DAC1_DAC_DHR12R2_DACC2DHR) | ((val << 0) & DAC1_DAC_DHR12R2_DACC2DHR);
}
inline uint32_t dac1_dac_dhr12r2_get_dacc2dhrb(struct DAC1_Type *p) { return (p->DAC_DHR12R2 & DAC1_DAC_DHR12R2_DACC2DHRB) >> 16; }
inline uint32_t dac1_dac_dhr12r2_get_dacc2dhr(struct DAC1_Type *p) { return (p->DAC_DHR12R2 & DAC1_DAC_DHR12R2_DACC2DHR) >> 0; }

// DAC1->DAC_DHR12L2 DAC channel2 12-bit left aligned data holding register
enum {
	DAC1_DAC_DHR12L2_DACC2DHRB = ((1UL << 12) - 1) << 20,  // DAC channel2 12-bit left-aligned data B
	DAC1_DAC_DHR12L2_DACC2DHR = ((1UL << 12) - 1) << 4,	 // DAC channel2 12-bit left-aligned data These bits are written by software
														 // which specify 12-bit data for DAC channel2.
};
inline void dac1_dac_dhr12l2_set_dacc2dhrb(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12L2 = (p->DAC_DHR12L2 & ~DAC1_DAC_DHR12L2_DACC2DHRB) | ((val << 20) & DAC1_DAC_DHR12L2_DACC2DHRB);
}
inline void dac1_dac_dhr12l2_set_dacc2dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12L2 = (p->DAC_DHR12L2 & ~DAC1_DAC_DHR12L2_DACC2DHR) | ((val << 4) & DAC1_DAC_DHR12L2_DACC2DHR);
}
inline uint32_t dac1_dac_dhr12l2_get_dacc2dhrb(struct DAC1_Type *p) { return (p->DAC_DHR12L2 & DAC1_DAC_DHR12L2_DACC2DHRB) >> 20; }
inline uint32_t dac1_dac_dhr12l2_get_dacc2dhr(struct DAC1_Type *p) { return (p->DAC_DHR12L2 & DAC1_DAC_DHR12L2_DACC2DHR) >> 4; }

// DAC1->DAC_DHR8R2 DAC channel2 8-bit right-aligned data holding register
enum {
	DAC1_DAC_DHR8R2_DACC2DHRB = ((1UL << 8) - 1) << 8,	// DAC channel2 8-bit right-aligned data
	DAC1_DAC_DHR8R2_DACC2DHR  = ((1UL << 8) - 1) << 0,	// DAC channel2 8-bit right-aligned data These bits are written by software
														// which specifies 8-bit data for DAC channel2.
};
inline void dac1_dac_dhr8r2_set_dacc2dhrb(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR8R2 = (p->DAC_DHR8R2 & ~DAC1_DAC_DHR8R2_DACC2DHRB) | ((val << 8) & DAC1_DAC_DHR8R2_DACC2DHRB);
}
inline void dac1_dac_dhr8r2_set_dacc2dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR8R2 = (p->DAC_DHR8R2 & ~DAC1_DAC_DHR8R2_DACC2DHR) | ((val << 0) & DAC1_DAC_DHR8R2_DACC2DHR);
}
inline uint32_t dac1_dac_dhr8r2_get_dacc2dhrb(struct DAC1_Type *p) { return (p->DAC_DHR8R2 & DAC1_DAC_DHR8R2_DACC2DHRB) >> 8; }
inline uint32_t dac1_dac_dhr8r2_get_dacc2dhr(struct DAC1_Type *p) { return (p->DAC_DHR8R2 & DAC1_DAC_DHR8R2_DACC2DHR) >> 0; }

// DAC1->DAC_DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC1_DAC_DHR12RD_DACC2DHR = ((1UL << 12) - 1) << 16,  // DAC channel2 12-bit right-aligned data These bits are written by
														  // software which specifies 12-bit data for DAC channel2.
	DAC1_DAC_DHR12RD_DACC1DHR = ((1UL << 12) - 1) << 0,	  // DAC channel1 12-bit right-aligned data These bits are written by
														  // software which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12rd_set_dacc2dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12RD = (p->DAC_DHR12RD & ~DAC1_DAC_DHR12RD_DACC2DHR) | ((val << 16) & DAC1_DAC_DHR12RD_DACC2DHR);
}
inline void dac1_dac_dhr12rd_set_dacc1dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12RD = (p->DAC_DHR12RD & ~DAC1_DAC_DHR12RD_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR12RD_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12rd_get_dacc2dhr(struct DAC1_Type *p) { return (p->DAC_DHR12RD & DAC1_DAC_DHR12RD_DACC2DHR) >> 16; }
inline uint32_t dac1_dac_dhr12rd_get_dacc1dhr(struct DAC1_Type *p) { return (p->DAC_DHR12RD & DAC1_DAC_DHR12RD_DACC1DHR) >> 0; }

// DAC1->DAC_DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC1_DAC_DHR12LD_DACC2DHR = ((1UL << 12) - 1) << 20,  // DAC channel2 12-bit left-aligned data These bits are written by
														  // software which specifies 12-bit data for DAC channel2.
	DAC1_DAC_DHR12LD_DACC1DHR = ((1UL << 12) - 1) << 4,	 // DAC channel1 12-bit left-aligned data These bits are written by software
														 // which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12ld_set_dacc2dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12LD = (p->DAC_DHR12LD & ~DAC1_DAC_DHR12LD_DACC2DHR) | ((val << 20) & DAC1_DAC_DHR12LD_DACC2DHR);
}
inline void dac1_dac_dhr12ld_set_dacc1dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR12LD = (p->DAC_DHR12LD & ~DAC1_DAC_DHR12LD_DACC1DHR) | ((val << 4) & DAC1_DAC_DHR12LD_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12ld_get_dacc2dhr(struct DAC1_Type *p) { return (p->DAC_DHR12LD & DAC1_DAC_DHR12LD_DACC2DHR) >> 20; }
inline uint32_t dac1_dac_dhr12ld_get_dacc1dhr(struct DAC1_Type *p) { return (p->DAC_DHR12LD & DAC1_DAC_DHR12LD_DACC1DHR) >> 4; }

// DAC1->DAC_DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC1_DAC_DHR8RD_DACC2DHR = ((1UL << 8) - 1) << 8,  // DAC channel2 8-bit right-aligned data These bits are written by software
													   // which specifies 8-bit data for DAC channel2.
	DAC1_DAC_DHR8RD_DACC1DHR = ((1UL << 8) - 1) << 0,  // DAC channel1 8-bit right-aligned data These bits are written by software
													   // which specifies 8-bit data for DAC channel1.
};
inline void dac1_dac_dhr8rd_set_dacc2dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR8RD = (p->DAC_DHR8RD & ~DAC1_DAC_DHR8RD_DACC2DHR) | ((val << 8) & DAC1_DAC_DHR8RD_DACC2DHR);
}
inline void dac1_dac_dhr8rd_set_dacc1dhr(struct DAC1_Type *p, uint32_t val) {
	p->DAC_DHR8RD = (p->DAC_DHR8RD & ~DAC1_DAC_DHR8RD_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR8RD_DACC1DHR);
}
inline uint32_t dac1_dac_dhr8rd_get_dacc2dhr(struct DAC1_Type *p) { return (p->DAC_DHR8RD & DAC1_DAC_DHR8RD_DACC2DHR) >> 8; }
inline uint32_t dac1_dac_dhr8rd_get_dacc1dhr(struct DAC1_Type *p) { return (p->DAC_DHR8RD & DAC1_DAC_DHR8RD_DACC1DHR) >> 0; }

// DAC1->DAC_DOR1 DAC channel1 data output register
enum {
	DAC1_DAC_DOR1_DACC1DORB = ((1UL << 12) - 1) << 16,	// DAC channel1 data output
	DAC1_DAC_DOR1_DACC1DOR	= ((1UL << 12) - 1)
							 << 0,	// DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
};
inline uint32_t dac1_dac_dor1_get_dacc1dorb(struct DAC1_Type *p) { return (p->DAC_DOR1 & DAC1_DAC_DOR1_DACC1DORB) >> 16; }
inline uint32_t dac1_dac_dor1_get_dacc1dor(struct DAC1_Type *p) { return (p->DAC_DOR1 & DAC1_DAC_DOR1_DACC1DOR) >> 0; }

// DAC1->DAC_DOR2 DAC channel2 data output register
enum {
	DAC1_DAC_DOR2_DACC2DORB = ((1UL << 12) - 1) << 16,	// DAC channel2 data output
	DAC1_DAC_DOR2_DACC2DOR	= ((1UL << 12) - 1)
							 << 0,	// DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
};
inline uint32_t dac1_dac_dor2_get_dacc2dorb(struct DAC1_Type *p) { return (p->DAC_DOR2 & DAC1_DAC_DOR2_DACC2DORB) >> 16; }
inline uint32_t dac1_dac_dor2_get_dacc2dor(struct DAC1_Type *p) { return (p->DAC_DOR2 & DAC1_DAC_DOR2_DACC2DOR) >> 0; }

// DAC1->DAC_SR DAC status register
enum {
	DAC1_DAC_SR_BWST2 =
			1UL << 31,	// DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode
						// enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when
						// the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
	DAC1_DAC_SR_CAL_FLAG2 = 1UL << 30,	// DAC Channel 2 calibration offset status This bit is set and cleared by hardware
	DAC1_DAC_SR_DMAUDR2 =
			1UL << 29,	// DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC1_DAC_SR_DORSTAT2 = 1UL << 28,  // DAC channel 2 output register status bit
	DAC1_DAC_SR_DAC2RDY	 = 1UL << 27,  // DAC channel 2 ready status bit
	DAC1_DAC_SR_BWST1 =
			1UL << 15,	// DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode
						// enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when
						// the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
	DAC1_DAC_SR_CAL_FLAG1 = 1UL << 14,	// DAC Channel 1 calibration offset status This bit is set and cleared by hardware
	DAC1_DAC_SR_DMAUDR1 =
			1UL << 13,	// DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC1_DAC_SR_DORSTAT1 = 1UL << 12,  // DAC channel1 output register status bit
	DAC1_DAC_SR_DAC1RDY	 = 1UL << 11,  // DAC channel1 ready status bit
};

// DAC1->DAC_CCR DAC calibration control register
enum {
	DAC1_DAC_CCR_OTRIM2 = ((1UL << 5) - 1) << 16,  // DAC Channel 2 offset trimming value
	DAC1_DAC_CCR_OTRIM1 = ((1UL << 5) - 1) << 0,   // DAC Channel 1 offset trimming value
};
inline void dac1_dac_ccr_set_otrim2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CCR = (p->DAC_CCR & ~DAC1_DAC_CCR_OTRIM2) | ((val << 16) & DAC1_DAC_CCR_OTRIM2);
}
inline void dac1_dac_ccr_set_otrim1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_CCR = (p->DAC_CCR & ~DAC1_DAC_CCR_OTRIM1) | ((val << 0) & DAC1_DAC_CCR_OTRIM1);
}
inline uint32_t dac1_dac_ccr_get_otrim2(struct DAC1_Type *p) { return (p->DAC_CCR & DAC1_DAC_CCR_OTRIM2) >> 16; }
inline uint32_t dac1_dac_ccr_get_otrim1(struct DAC1_Type *p) { return (p->DAC_CCR & DAC1_DAC_CCR_OTRIM1) >> 0; }

// DAC1->DAC_MCR DAC mode control register
enum {
	DAC1_DAC_MCR_SINFORMAT2 = 1UL << 25,  // Enable signed format for DAC channel2
	DAC1_DAC_MCR_DMADOUBLE2 = 1UL << 24,  // DAC Channel2 DMA double data mode
	DAC1_DAC_MCR_MODE2 =
			((1UL << 3) - 1) << 16,	 // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the
									 // calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2
									 // =1 the write operation is ignored. They can be set and cleared by software to select the DAC
									 // Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
	DAC1_DAC_MCR_HFSEL		= ((1UL << 2) - 1) << 14,  // High frequency interface mode selection
	DAC1_DAC_MCR_SINFORMAT1 = 1UL << 9,				   // Enable signed format for DAC channel1
	DAC1_DAC_MCR_DMADOUBLE1 = 1UL << 8,				   // DAC Channel1 DMA double data mode
	DAC1_DAC_MCR_MODE1 =
			((1UL << 3) - 1) << 0,	// DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the
									// calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1
									// the write operation is ignored. They can be set and cleared by software to select the DAC
									// Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
};
inline void dac1_dac_mcr_set_mode2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_MCR = (p->DAC_MCR & ~DAC1_DAC_MCR_MODE2) | ((val << 16) & DAC1_DAC_MCR_MODE2);
}
inline void dac1_dac_mcr_set_hfsel(struct DAC1_Type *p, uint32_t val) {
	p->DAC_MCR = (p->DAC_MCR & ~DAC1_DAC_MCR_HFSEL) | ((val << 14) & DAC1_DAC_MCR_HFSEL);
}
inline void dac1_dac_mcr_set_mode1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_MCR = (p->DAC_MCR & ~DAC1_DAC_MCR_MODE1) | ((val << 0) & DAC1_DAC_MCR_MODE1);
}
inline uint32_t dac1_dac_mcr_get_mode2(struct DAC1_Type *p) { return (p->DAC_MCR & DAC1_DAC_MCR_MODE2) >> 16; }
inline uint32_t dac1_dac_mcr_get_hfsel(struct DAC1_Type *p) { return (p->DAC_MCR & DAC1_DAC_MCR_HFSEL) >> 14; }
inline uint32_t dac1_dac_mcr_get_mode1(struct DAC1_Type *p) { return (p->DAC_MCR & DAC1_DAC_MCR_MODE1) >> 0; }

// DAC1->DAC_SHSR1 DAC Sample and Hold sample time register 1
enum {
	DAC1_DAC_SHSR1_TSAMPLE1 =
			((1UL << 10) - 1)
			<< 0,  // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC
				   // channel1 is disabled or also during normal operation. in the latter case, the write can be done only when
				   // BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
};
inline void dac1_dac_shsr1_set_tsample1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_SHSR1 = (p->DAC_SHSR1 & ~DAC1_DAC_SHSR1_TSAMPLE1) | ((val << 0) & DAC1_DAC_SHSR1_TSAMPLE1);
}
inline uint32_t dac1_dac_shsr1_get_tsample1(struct DAC1_Type *p) { return (p->DAC_SHSR1 & DAC1_DAC_SHSR1_TSAMPLE1) >> 0; }

// DAC1->DAC_SHSR2 DAC Sample and Hold sample time register 2
enum {
	DAC1_DAC_SHSR2_TSAMPLE2 =
			((1UL << 10) - 1)
			<< 0,  // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC
				   // channel2 is disabled or also during normal operation. in the latter case, the write can be done only when
				   // BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
};
inline void dac1_dac_shsr2_set_tsample2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_SHSR2 = (p->DAC_SHSR2 & ~DAC1_DAC_SHSR2_TSAMPLE2) | ((val << 0) & DAC1_DAC_SHSR2_TSAMPLE2);
}
inline uint32_t dac1_dac_shsr2_get_tsample2(struct DAC1_Type *p) { return (p->DAC_SHSR2 & DAC1_DAC_SHSR2_TSAMPLE2) >> 0; }

// DAC1->DAC_SHHR DAC Sample and Hold hold time register
enum {
	DAC1_DAC_SHHR_THOLD2 =
			((1UL << 10) - 1)
			<< 16,	// DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
	DAC1_DAC_SHHR_THOLD1 = ((1UL << 10) - 1)
						   << 0,  // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
};
inline void dac1_dac_shhr_set_thold2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_SHHR = (p->DAC_SHHR & ~DAC1_DAC_SHHR_THOLD2) | ((val << 16) & DAC1_DAC_SHHR_THOLD2);
}
inline void dac1_dac_shhr_set_thold1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_SHHR = (p->DAC_SHHR & ~DAC1_DAC_SHHR_THOLD1) | ((val << 0) & DAC1_DAC_SHHR_THOLD1);
}
inline uint32_t dac1_dac_shhr_get_thold2(struct DAC1_Type *p) { return (p->DAC_SHHR & DAC1_DAC_SHHR_THOLD2) >> 16; }
inline uint32_t dac1_dac_shhr_get_thold1(struct DAC1_Type *p) { return (p->DAC_SHHR & DAC1_DAC_SHHR_THOLD1) >> 0; }

// DAC1->DAC_SHRR DAC Sample and Hold refresh time register
enum {
	DAC1_DAC_SHRR_TREFRESH2 =
			((1UL << 8) - 1)
			<< 16,	// DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
	DAC1_DAC_SHRR_TREFRESH1 =
			((1UL << 8) - 1)
			<< 0,  // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
};
inline void dac1_dac_shrr_set_trefresh2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_SHRR = (p->DAC_SHRR & ~DAC1_DAC_SHRR_TREFRESH2) | ((val << 16) & DAC1_DAC_SHRR_TREFRESH2);
}
inline void dac1_dac_shrr_set_trefresh1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_SHRR = (p->DAC_SHRR & ~DAC1_DAC_SHRR_TREFRESH1) | ((val << 0) & DAC1_DAC_SHRR_TREFRESH1);
}
inline uint32_t dac1_dac_shrr_get_trefresh2(struct DAC1_Type *p) { return (p->DAC_SHRR & DAC1_DAC_SHRR_TREFRESH2) >> 16; }
inline uint32_t dac1_dac_shrr_get_trefresh1(struct DAC1_Type *p) { return (p->DAC_SHRR & DAC1_DAC_SHRR_TREFRESH1) >> 0; }

// DAC1->DAC_STR1 Sawtooth register
enum {
	DAC1_DAC_STR1_STINCDATA1 = ((1UL << 16) - 1) << 16,	 // DAC CH1 Sawtooth increment value (12.4 bit format)
	DAC1_DAC_STR1_STDIR1	 = 1UL << 12,				 // DAC Channel1 Sawtooth direction setting
	DAC1_DAC_STR1_STRSTDATA1 = ((1UL << 12) - 1) << 0,	 // DAC Channel 1 Sawtooth reset value
};
inline void dac1_dac_str1_set_stincdata1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STR1 = (p->DAC_STR1 & ~DAC1_DAC_STR1_STINCDATA1) | ((val << 16) & DAC1_DAC_STR1_STINCDATA1);
}
inline void dac1_dac_str1_set_strstdata1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STR1 = (p->DAC_STR1 & ~DAC1_DAC_STR1_STRSTDATA1) | ((val << 0) & DAC1_DAC_STR1_STRSTDATA1);
}
inline uint32_t dac1_dac_str1_get_stincdata1(struct DAC1_Type *p) { return (p->DAC_STR1 & DAC1_DAC_STR1_STINCDATA1) >> 16; }
inline uint32_t dac1_dac_str1_get_strstdata1(struct DAC1_Type *p) { return (p->DAC_STR1 & DAC1_DAC_STR1_STRSTDATA1) >> 0; }

// DAC1->DAC_STR2 Sawtooth register
enum {
	DAC1_DAC_STR2_STINCDATA2 = ((1UL << 16) - 1) << 16,	 // DAC CH2 Sawtooth increment value (12.4 bit format)
	DAC1_DAC_STR2_STDIR2	 = 1UL << 12,				 // DAC Channel2 Sawtooth direction setting
	DAC1_DAC_STR2_STRSTDATA2 = ((1UL << 12) - 1) << 0,	 // DAC Channel 2 Sawtooth reset value
};
inline void dac1_dac_str2_set_stincdata2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STR2 = (p->DAC_STR2 & ~DAC1_DAC_STR2_STINCDATA2) | ((val << 16) & DAC1_DAC_STR2_STINCDATA2);
}
inline void dac1_dac_str2_set_strstdata2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STR2 = (p->DAC_STR2 & ~DAC1_DAC_STR2_STRSTDATA2) | ((val << 0) & DAC1_DAC_STR2_STRSTDATA2);
}
inline uint32_t dac1_dac_str2_get_stincdata2(struct DAC1_Type *p) { return (p->DAC_STR2 & DAC1_DAC_STR2_STINCDATA2) >> 16; }
inline uint32_t dac1_dac_str2_get_strstdata2(struct DAC1_Type *p) { return (p->DAC_STR2 & DAC1_DAC_STR2_STRSTDATA2) >> 0; }

// DAC1->DAC_STMODR Sawtooth Mode register
enum {
	DAC1_DAC_STMODR_STINCTRIGSEL2 = ((1UL << 4) - 1) << 24,	 // DAC Channel 2 Sawtooth Increment trigger selection
	DAC1_DAC_STMODR_STRSTTRIGSEL2 = ((1UL << 4) - 1) << 16,	 // DAC Channel 1 Sawtooth Reset trigger selection
	DAC1_DAC_STMODR_STINCTRIGSEL1 = ((1UL << 4) - 1) << 8,	 // DAC Channel 1 Sawtooth Increment trigger selection
	DAC1_DAC_STMODR_STRSTTRIGSEL1 = ((1UL << 4) - 1) << 0,	 // DAC Channel 1 Sawtooth Reset trigger selection
};
inline void dac1_dac_stmodr_set_stinctrigsel2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STINCTRIGSEL2) | ((val << 24) & DAC1_DAC_STMODR_STINCTRIGSEL2);
}
inline void dac1_dac_stmodr_set_strsttrigsel2(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STRSTTRIGSEL2) | ((val << 16) & DAC1_DAC_STMODR_STRSTTRIGSEL2);
}
inline void dac1_dac_stmodr_set_stinctrigsel1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STINCTRIGSEL1) | ((val << 8) & DAC1_DAC_STMODR_STINCTRIGSEL1);
}
inline void dac1_dac_stmodr_set_strsttrigsel1(struct DAC1_Type *p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STRSTTRIGSEL1) | ((val << 0) & DAC1_DAC_STMODR_STRSTTRIGSEL1);
}
inline uint32_t dac1_dac_stmodr_get_stinctrigsel2(struct DAC1_Type *p) {
	return (p->DAC_STMODR & DAC1_DAC_STMODR_STINCTRIGSEL2) >> 24;
}
inline uint32_t dac1_dac_stmodr_get_strsttrigsel2(struct DAC1_Type *p) {
	return (p->DAC_STMODR & DAC1_DAC_STMODR_STRSTTRIGSEL2) >> 16;
}
inline uint32_t dac1_dac_stmodr_get_stinctrigsel1(struct DAC1_Type *p) {
	return (p->DAC_STMODR & DAC1_DAC_STMODR_STINCTRIGSEL1) >> 8;
}
inline uint32_t dac1_dac_stmodr_get_strsttrigsel1(struct DAC1_Type *p) {
	return (p->DAC_STMODR & DAC1_DAC_STMODR_STRSTTRIGSEL1) >> 0;
}

/* Debug support */
struct DBGMCU_Type {
	__I uint32_t  IDCODE;		 // @0 MCU Device ID Code Register
	__IO uint8_t  CR;			 // @4 Debug MCU Configuration Register
	uint8_t		  RESERVED0[3];	 // @5
	__IO uint32_t APB1L_FZ;		 // @8 APB Low Freeze Register 1
	__IO uint8_t  APB1H_FZ;		 // @12 APB Low Freeze Register 2
	uint8_t		  RESERVED1[3];	 // @13
	__IO uint32_t APB2_FZ;		 // @16 APB High Freeze Register
};

// DBGMCU->IDCODE MCU Device ID Code Register
enum {
	DBGMCU_IDCODE_REV_ID = ((1UL << 16) - 1) << 16,	 // Revision Identifier
	DBGMCU_IDCODE_DEV_ID = ((1UL << 16) - 1) << 0,	 // Device Identifier
};
inline uint32_t dbgmcu_idcode_get_rev_id(struct DBGMCU_Type *p) { return (p->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16; }
inline uint32_t dbgmcu_idcode_get_dev_id(struct DBGMCU_Type *p) { return (p->IDCODE & DBGMCU_IDCODE_DEV_ID) >> 0; }

// DBGMCU->CR Debug MCU Configuration Register
enum {
	DBGMCU_CR_TRACE_MODE  = ((1UL << 2) - 1) << 6,	// Trace pin assignment control
	DBGMCU_CR_TRACE_IOEN  = 1UL << 5,				// Trace pin assignment control
	DBGMCU_CR_DBG_STANDBY = 1UL << 2,				// Debug Standby Mode
	DBGMCU_CR_DBG_STOP	  = 1UL << 1,				// Debug Stop Mode
	DBGMCU_CR_DBG_SLEEP	  = 1UL << 0,				// Debug Sleep Mode
};
inline void dbgmcu_cr_set_trace_mode(struct DBGMCU_Type *p, uint32_t val) {
	p->CR = (p->CR & ~DBGMCU_CR_TRACE_MODE) | ((val << 6) & DBGMCU_CR_TRACE_MODE);
}
inline uint32_t dbgmcu_cr_get_trace_mode(struct DBGMCU_Type *p) { return (p->CR & DBGMCU_CR_TRACE_MODE) >> 6; }

// DBGMCU->APB1L_FZ APB Low Freeze Register 1
enum {
	DBGMCU_APB1L_FZ_DBG_LPTIMER_STOP = 1UL << 31,  // LPTIM1 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C3_STOP	 = 1UL << 30,  // I2C3 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C2_STOP	 = 1UL << 22,  // I2C2 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C1_STOP	 = 1UL << 21,  // I2C1 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_IWDG_STOP	 = 1UL << 12,  // Debug Independent Wachdog stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_WWDG_STOP	 = 1UL << 11,  // Debug Window Wachdog stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_RTC_STOP	 = 1UL << 10,  // Debug RTC stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_TIM7_STOP	 = 1UL << 5,   // TIM7 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIMER6_STOP	 = 1UL << 4,   // Debug Timer 6 stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_TIM5_STOP	 = 1UL << 3,   // TIM5 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIM4_STOP	 = 1UL << 2,   // TIM4 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIM3_STOP	 = 1UL << 1,   // TIM3 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIMER2_STOP	 = 1UL << 0,   // Debug Timer 2 stopped when Core is halted
};

// DBGMCU->APB1H_FZ APB Low Freeze Register 2
enum {
	DBGMCU_APB1H_FZ_DBG_I2C4_STOP = 1UL << 1,  // DBG_I2C4_STOP
};

// DBGMCU->APB2_FZ APB High Freeze Register
enum {
	DBGMCU_APB2_FZ_DBG_HRTIM3_STOP = 1UL << 29,	 // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM2_STOP = 1UL << 28,	 // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM1_STOP = 1UL << 27,	 // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM0_STOP = 1UL << 26,	 // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_TIM20_STOP  = 1UL << 20,	 // TIM20counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM17_STOP  = 1UL << 18,	 // TIM17 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM16_STOP  = 1UL << 17,	 // TIM16 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM15_STOP  = 1UL << 16,	 // TIM15 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM8_STOP   = 1UL << 13,	 // TIM8 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM1_STOP   = 1UL << 11,	 // TIM1 counter stopped when core is halted
};

/* DMA controller */
struct DMA1_Type {
	__I uint32_t  ISR;			  // @0 interrupt status register
	__O uint32_t  IFCR;			  // @4 DMA interrupt flag clear register
	__IO uint16_t CCR1;			  // @8 DMA channel 1 configuration register
	uint8_t		  RESERVED0[2];	  // @10
	__IO uint16_t CNDTR1;		  // @12 channel x number of data to transfer register
	uint8_t		  RESERVED1[2];	  // @14
	__IO uint32_t CPAR1;		  // @16 DMA channel x peripheral address register
	__IO uint32_t CMAR1;		  // @20 DMA channel x memory address register
	uint8_t		  RESERVED2[4];	  // @24
	__IO uint16_t CCR2;			  // @28 DMA channel 2 configuration register
	uint8_t		  RESERVED3[2];	  // @30
	__IO uint16_t CNDTR2;		  // @32 channel x number of data to transfer register
	uint8_t		  RESERVED4[2];	  // @34
	__IO uint32_t CPAR2;		  // @36 DMA channel x peripheral address register
	__IO uint32_t CMAR2;		  // @40 DMA channel x memory address register
	uint8_t		  RESERVED5[4];	  // @44
	__IO uint16_t CCR3;			  // @48 DMA channel 3 configuration register
	uint8_t		  RESERVED6[2];	  // @50
	__IO uint16_t CNDTR3;		  // @52 channel x number of data to transfer register
	uint8_t		  RESERVED7[2];	  // @54
	__IO uint32_t CPAR3;		  // @56 DMA channel x peripheral address register
	__IO uint32_t CMAR3;		  // @60 DMA channel x memory address register
	uint8_t		  RESERVED8[4];	  // @64
	__IO uint16_t CCR4;			  // @68 DMA channel 3 configuration register
	uint8_t		  RESERVED9[2];	  // @70
	__IO uint16_t CNDTR4;		  // @72 channel x number of data to transfer register
	uint8_t		  RESERVED10[2];  // @74
	__IO uint32_t CPAR4;		  // @76 DMA channel x peripheral address register
	__IO uint32_t CMAR4;		  // @80 DMA channel x memory address register
	uint8_t		  RESERVED11[4];  // @84
	__IO uint16_t CCR5;			  // @88 DMA channel 4 configuration register
	uint8_t		  RESERVED12[2];  // @90
	__IO uint16_t CNDTR5;		  // @92 channel x number of data to transfer register
	uint8_t		  RESERVED13[2];  // @94
	__IO uint32_t CPAR5;		  // @96 DMA channel x peripheral address register
	__IO uint32_t CMAR5;		  // @100 DMA channel x memory address register
	uint8_t		  RESERVED14[4];  // @104
	__IO uint16_t CCR6;			  // @108 DMA channel 5 configuration register
	uint8_t		  RESERVED15[2];  // @110
	__IO uint16_t CNDTR6;		  // @112 channel x number of data to transfer register
	uint8_t		  RESERVED16[2];  // @114
	__IO uint32_t CPAR6;		  // @116 DMA channel x peripheral address register
	__IO uint32_t CMAR6;		  // @120 DMA channel x memory address register
	uint8_t		  RESERVED17[4];  // @124
	__IO uint16_t CCR7;			  // @128 DMA channel 6 configuration register
	uint8_t		  RESERVED18[2];  // @130
	__IO uint16_t CNDTR7;		  // @132 channel x number of data to transfer register
	uint8_t		  RESERVED19[2];  // @134
	__IO uint32_t CPAR7;		  // @136 DMA channel x peripheral address register
	__IO uint32_t CMAR7;		  // @140 DMA channel x memory address register
	uint8_t		  RESERVED20[4];  // @144
	__IO uint16_t CCR8;			  // @148 DMA channel 7 configuration register
	uint8_t		  RESERVED21[2];  // @150
	__IO uint16_t CNDTR8;		  // @152 channel x number of data to transfer register
	uint8_t		  RESERVED22[2];  // @154
	__IO uint32_t CPAR8;		  // @156 DMA channel x peripheral address register
	__IO uint32_t CMAR8;		  // @160 DMA channel x memory address register
};

// DMA1->ISR interrupt status register
enum {
	DMA1_ISR_TEIF8 = 1UL << 31,	 // TEIF8
	DMA1_ISR_HTIF8 = 1UL << 30,	 // HTIF8
	DMA1_ISR_TCIF8 = 1UL << 29,	 // TCIF8
	DMA1_ISR_GIF8  = 1UL << 28,	 // GIF8
	DMA1_ISR_TEIF7 = 1UL << 27,	 // TEIF7
	DMA1_ISR_HTIF7 = 1UL << 26,	 // HTIF7
	DMA1_ISR_TCIF7 = 1UL << 25,	 // TCIF7
	DMA1_ISR_GIF7  = 1UL << 24,	 // GIF7
	DMA1_ISR_TEIF6 = 1UL << 23,	 // TEIF6
	DMA1_ISR_HTIF6 = 1UL << 22,	 // HTIF6
	DMA1_ISR_TCIF6 = 1UL << 21,	 // TCIF6
	DMA1_ISR_GIF6  = 1UL << 20,	 // GIF6
	DMA1_ISR_TEIF5 = 1UL << 19,	 // TEIF5
	DMA1_ISR_HTIF5 = 1UL << 18,	 // HTIF5
	DMA1_ISR_TCIF5 = 1UL << 17,	 // TCIF5
	DMA1_ISR_GIF5  = 1UL << 16,	 // GIF5
	DMA1_ISR_TEIF4 = 1UL << 15,	 // TEIF4
	DMA1_ISR_HTIF4 = 1UL << 14,	 // HTIF4
	DMA1_ISR_TCIF4 = 1UL << 13,	 // TCIF4
	DMA1_ISR_GIF4  = 1UL << 12,	 // GIF4
	DMA1_ISR_TEIF3 = 1UL << 11,	 // TEIF3
	DMA1_ISR_HTIF3 = 1UL << 10,	 // HTIF3
	DMA1_ISR_TCIF3 = 1UL << 9,	 // TCIF3
	DMA1_ISR_GIF3  = 1UL << 8,	 // GIF3
	DMA1_ISR_TEIF2 = 1UL << 7,	 // TEIF2
	DMA1_ISR_HTIF2 = 1UL << 6,	 // HTIF2
	DMA1_ISR_TCIF2 = 1UL << 5,	 // TCIF2
	DMA1_ISR_GIF2  = 1UL << 4,	 // GIF2
	DMA1_ISR_TEIF1 = 1UL << 3,	 // TEIF1
	DMA1_ISR_HTIF1 = 1UL << 2,	 // HTIF1
	DMA1_ISR_TCIF1 = 1UL << 1,	 // TCIF1
	DMA1_ISR_GIF1  = 1UL << 0,	 // GIF1
};

// DMA1->IFCR DMA interrupt flag clear register
enum {
	DMA1_IFCR_TEIF8 = 1UL << 31,  // TEIF8
	DMA1_IFCR_HTIF8 = 1UL << 30,  // HTIF8
	DMA1_IFCR_TCIF8 = 1UL << 29,  // TCIF8
	DMA1_IFCR_GIF8	= 1UL << 28,  // GIF8
	DMA1_IFCR_TEIF7 = 1UL << 27,  // TEIF7
	DMA1_IFCR_HTIF7 = 1UL << 26,  // HTIF7
	DMA1_IFCR_TCIF7 = 1UL << 25,  // TCIF7
	DMA1_IFCR_GIF7	= 1UL << 24,  // GIF7
	DMA1_IFCR_TEIF6 = 1UL << 23,  // TEIF6
	DMA1_IFCR_HTIF6 = 1UL << 22,  // HTIF6
	DMA1_IFCR_TCIF6 = 1UL << 21,  // TCIF6
	DMA1_IFCR_GIF6	= 1UL << 20,  // GIF6
	DMA1_IFCR_TEIF5 = 1UL << 19,  // TEIF5
	DMA1_IFCR_HTIF5 = 1UL << 18,  // HTIF5
	DMA1_IFCR_TCIF5 = 1UL << 17,  // TCIF5
	DMA1_IFCR_GIF5	= 1UL << 16,  // GIF5
	DMA1_IFCR_TEIF4 = 1UL << 15,  // TEIF4
	DMA1_IFCR_HTIF4 = 1UL << 14,  // HTIF4
	DMA1_IFCR_TCIF4 = 1UL << 13,  // TCIF4
	DMA1_IFCR_GIF4	= 1UL << 12,  // GIF4
	DMA1_IFCR_TEIF3 = 1UL << 11,  // TEIF3
	DMA1_IFCR_HTIF3 = 1UL << 10,  // HTIF3
	DMA1_IFCR_TCIF3 = 1UL << 9,	  // TCIF3
	DMA1_IFCR_GIF3	= 1UL << 8,	  // GIF3
	DMA1_IFCR_TEIF2 = 1UL << 7,	  // TEIF2
	DMA1_IFCR_HTIF2 = 1UL << 6,	  // HTIF2
	DMA1_IFCR_TCIF2 = 1UL << 5,	  // TCIF2
	DMA1_IFCR_GIF2	= 1UL << 4,	  // GIF2
	DMA1_IFCR_TEIF1 = 1UL << 3,	  // TEIF1
	DMA1_IFCR_HTIF1 = 1UL << 2,	  // HTIF1
	DMA1_IFCR_TCIF1 = 1UL << 1,	  // TCIF1
	DMA1_IFCR_GIF1	= 1UL << 0,	  // GIF1
};

// DMA1->CCR1 DMA channel 1 configuration register
enum {
	DMA1_CCR1_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR1_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR1_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR1_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR1_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR1_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR1_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR1_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR1_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR1_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR1_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR1_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr1_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~DMA1_CCR1_PL) | ((val << 12) & DMA1_CCR1_PL);
}
inline void dma1_ccr1_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~DMA1_CCR1_MSIZE) | ((val << 10) & DMA1_CCR1_MSIZE);
}
inline void dma1_ccr1_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~DMA1_CCR1_PSIZE) | ((val << 8) & DMA1_CCR1_PSIZE);
}
inline uint32_t dma1_ccr1_get_pl(struct DMA1_Type *p) { return (p->CCR1 & DMA1_CCR1_PL) >> 12; }
inline uint32_t dma1_ccr1_get_msize(struct DMA1_Type *p) { return (p->CCR1 & DMA1_CCR1_MSIZE) >> 10; }
inline uint32_t dma1_ccr1_get_psize(struct DMA1_Type *p) { return (p->CCR1 & DMA1_CCR1_PSIZE) >> 8; }

// DMA1->CCR2 DMA channel 2 configuration register
enum {
	DMA1_CCR2_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR2_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR2_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR2_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR2_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR2_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR2_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR2_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR2_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR2_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR2_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR2_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr2_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~DMA1_CCR2_PL) | ((val << 12) & DMA1_CCR2_PL);
}
inline void dma1_ccr2_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~DMA1_CCR2_MSIZE) | ((val << 10) & DMA1_CCR2_MSIZE);
}
inline void dma1_ccr2_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~DMA1_CCR2_PSIZE) | ((val << 8) & DMA1_CCR2_PSIZE);
}
inline uint32_t dma1_ccr2_get_pl(struct DMA1_Type *p) { return (p->CCR2 & DMA1_CCR2_PL) >> 12; }
inline uint32_t dma1_ccr2_get_msize(struct DMA1_Type *p) { return (p->CCR2 & DMA1_CCR2_MSIZE) >> 10; }
inline uint32_t dma1_ccr2_get_psize(struct DMA1_Type *p) { return (p->CCR2 & DMA1_CCR2_PSIZE) >> 8; }

// DMA1->CCR3 DMA channel 3 configuration register
enum {
	DMA1_CCR3_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR3_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR3_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR3_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR3_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR3_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR3_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR3_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR3_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR3_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR3_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR3_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr3_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~DMA1_CCR3_PL) | ((val << 12) & DMA1_CCR3_PL);
}
inline void dma1_ccr3_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~DMA1_CCR3_MSIZE) | ((val << 10) & DMA1_CCR3_MSIZE);
}
inline void dma1_ccr3_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~DMA1_CCR3_PSIZE) | ((val << 8) & DMA1_CCR3_PSIZE);
}
inline uint32_t dma1_ccr3_get_pl(struct DMA1_Type *p) { return (p->CCR3 & DMA1_CCR3_PL) >> 12; }
inline uint32_t dma1_ccr3_get_msize(struct DMA1_Type *p) { return (p->CCR3 & DMA1_CCR3_MSIZE) >> 10; }
inline uint32_t dma1_ccr3_get_psize(struct DMA1_Type *p) { return (p->CCR3 & DMA1_CCR3_PSIZE) >> 8; }

// DMA1->CCR4 DMA channel 3 configuration register
enum {
	DMA1_CCR4_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR4_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR4_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR4_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR4_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR4_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR4_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR4_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR4_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR4_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR4_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR4_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr4_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~DMA1_CCR4_PL) | ((val << 12) & DMA1_CCR4_PL);
}
inline void dma1_ccr4_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~DMA1_CCR4_MSIZE) | ((val << 10) & DMA1_CCR4_MSIZE);
}
inline void dma1_ccr4_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~DMA1_CCR4_PSIZE) | ((val << 8) & DMA1_CCR4_PSIZE);
}
inline uint32_t dma1_ccr4_get_pl(struct DMA1_Type *p) { return (p->CCR4 & DMA1_CCR4_PL) >> 12; }
inline uint32_t dma1_ccr4_get_msize(struct DMA1_Type *p) { return (p->CCR4 & DMA1_CCR4_MSIZE) >> 10; }
inline uint32_t dma1_ccr4_get_psize(struct DMA1_Type *p) { return (p->CCR4 & DMA1_CCR4_PSIZE) >> 8; }

// DMA1->CCR5 DMA channel 4 configuration register
enum {
	DMA1_CCR5_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR5_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR5_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR5_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR5_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR5_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR5_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR5_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR5_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR5_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR5_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR5_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr5_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR5 = (p->CCR5 & ~DMA1_CCR5_PL) | ((val << 12) & DMA1_CCR5_PL);
}
inline void dma1_ccr5_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR5 = (p->CCR5 & ~DMA1_CCR5_MSIZE) | ((val << 10) & DMA1_CCR5_MSIZE);
}
inline void dma1_ccr5_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR5 = (p->CCR5 & ~DMA1_CCR5_PSIZE) | ((val << 8) & DMA1_CCR5_PSIZE);
}
inline uint32_t dma1_ccr5_get_pl(struct DMA1_Type *p) { return (p->CCR5 & DMA1_CCR5_PL) >> 12; }
inline uint32_t dma1_ccr5_get_msize(struct DMA1_Type *p) { return (p->CCR5 & DMA1_CCR5_MSIZE) >> 10; }
inline uint32_t dma1_ccr5_get_psize(struct DMA1_Type *p) { return (p->CCR5 & DMA1_CCR5_PSIZE) >> 8; }

// DMA1->CCR6 DMA channel 5 configuration register
enum {
	DMA1_CCR6_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR6_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR6_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR6_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR6_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR6_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR6_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR6_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR6_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR6_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR6_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR6_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr6_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR6 = (p->CCR6 & ~DMA1_CCR6_PL) | ((val << 12) & DMA1_CCR6_PL);
}
inline void dma1_ccr6_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR6 = (p->CCR6 & ~DMA1_CCR6_MSIZE) | ((val << 10) & DMA1_CCR6_MSIZE);
}
inline void dma1_ccr6_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR6 = (p->CCR6 & ~DMA1_CCR6_PSIZE) | ((val << 8) & DMA1_CCR6_PSIZE);
}
inline uint32_t dma1_ccr6_get_pl(struct DMA1_Type *p) { return (p->CCR6 & DMA1_CCR6_PL) >> 12; }
inline uint32_t dma1_ccr6_get_msize(struct DMA1_Type *p) { return (p->CCR6 & DMA1_CCR6_MSIZE) >> 10; }
inline uint32_t dma1_ccr6_get_psize(struct DMA1_Type *p) { return (p->CCR6 & DMA1_CCR6_PSIZE) >> 8; }

// DMA1->CCR7 DMA channel 6 configuration register
enum {
	DMA1_CCR7_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR7_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR7_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR7_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR7_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR7_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR7_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR7_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR7_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR7_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR7_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR7_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr7_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR7 = (p->CCR7 & ~DMA1_CCR7_PL) | ((val << 12) & DMA1_CCR7_PL);
}
inline void dma1_ccr7_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR7 = (p->CCR7 & ~DMA1_CCR7_MSIZE) | ((val << 10) & DMA1_CCR7_MSIZE);
}
inline void dma1_ccr7_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR7 = (p->CCR7 & ~DMA1_CCR7_PSIZE) | ((val << 8) & DMA1_CCR7_PSIZE);
}
inline uint32_t dma1_ccr7_get_pl(struct DMA1_Type *p) { return (p->CCR7 & DMA1_CCR7_PL) >> 12; }
inline uint32_t dma1_ccr7_get_msize(struct DMA1_Type *p) { return (p->CCR7 & DMA1_CCR7_MSIZE) >> 10; }
inline uint32_t dma1_ccr7_get_psize(struct DMA1_Type *p) { return (p->CCR7 & DMA1_CCR7_PSIZE) >> 8; }

// DMA1->CCR8 DMA channel 7 configuration register
enum {
	DMA1_CCR8_MEM2MEM = 1UL << 14,				 // MEM2MEM
	DMA1_CCR8_PL	  = ((1UL << 2) - 1) << 12,	 // PL
	DMA1_CCR8_MSIZE	  = ((1UL << 2) - 1) << 10,	 // MSIZE
	DMA1_CCR8_PSIZE	  = ((1UL << 2) - 1) << 8,	 // PSIZE
	DMA1_CCR8_MINC	  = 1UL << 7,				 // MINC
	DMA1_CCR8_PINC	  = 1UL << 6,				 // PINC
	DMA1_CCR8_CIRC	  = 1UL << 5,				 // CIRC
	DMA1_CCR8_DIR	  = 1UL << 4,				 // DIR
	DMA1_CCR8_TEIE	  = 1UL << 3,				 // TEIE
	DMA1_CCR8_HTIE	  = 1UL << 2,				 // HTIE
	DMA1_CCR8_TCIE	  = 1UL << 1,				 // TCIE
	DMA1_CCR8_EN	  = 1UL << 0,				 // channel enable
};
inline void dma1_ccr8_set_pl(struct DMA1_Type *p, uint32_t val) {
	p->CCR8 = (p->CCR8 & ~DMA1_CCR8_PL) | ((val << 12) & DMA1_CCR8_PL);
}
inline void dma1_ccr8_set_msize(struct DMA1_Type *p, uint32_t val) {
	p->CCR8 = (p->CCR8 & ~DMA1_CCR8_MSIZE) | ((val << 10) & DMA1_CCR8_MSIZE);
}
inline void dma1_ccr8_set_psize(struct DMA1_Type *p, uint32_t val) {
	p->CCR8 = (p->CCR8 & ~DMA1_CCR8_PSIZE) | ((val << 8) & DMA1_CCR8_PSIZE);
}
inline uint32_t dma1_ccr8_get_pl(struct DMA1_Type *p) { return (p->CCR8 & DMA1_CCR8_PL) >> 12; }
inline uint32_t dma1_ccr8_get_msize(struct DMA1_Type *p) { return (p->CCR8 & DMA1_CCR8_MSIZE) >> 10; }
inline uint32_t dma1_ccr8_get_psize(struct DMA1_Type *p) { return (p->CCR8 & DMA1_CCR8_PSIZE) >> 8; }

/* DMAMUX */
struct DMAMUX_Type {
	__IO uint32_t C0CR;			   // @0 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C1CR;			   // @4 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C2CR;			   // @8 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C3CR;			   // @12 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C4CR;			   // @16 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C5CR;			   // @20 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C6CR;			   // @24 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C7CR;			   // @28 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C8CR;			   // @32 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C9CR;			   // @36 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C10CR;		   // @40 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C11CR;		   // @44 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C12CR;		   // @48 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C13CR;		   // @52 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C14CR;		   // @56 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C15CR;		   // @60 DMAMux - DMA request line multiplexer channel x control register
	uint8_t		  RESERVED0[64];   // @64
	__I uint16_t  CSR;			   // @128 DMAMUX request line multiplexer interrupt channel status register
	uint8_t		  RESERVED1[2];	   // @130
	__O uint16_t  CFR;			   // @132 DMAMUX request line multiplexer interrupt clear flag register
	uint8_t		  RESERVED2[122];  // @134
	__IO uint32_t RG0CR;		   // @256 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG1CR;		   // @260 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG2CR;		   // @264 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG3CR;		   // @268 DMAMux - DMA request generator channel x control register
	uint8_t		  RESERVED3[48];   // @272
	__I uint8_t	  RGSR;			   // @320 DMAMux - DMA request generator status register
	uint8_t		  RESERVED4[3];	   // @321
	__O uint8_t	  RGCFR;		   // @324 DMAMux - DMA request generator clear flag register
};

// DMAMUX->C0CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C0CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C0CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C0CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C0CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C0CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C0CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C0CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c0cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_SYNC_ID) | ((val << 24) & DMAMUX_C0CR_SYNC_ID);
}
inline void dmamux_c0cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_NBREQ) | ((val << 19) & DMAMUX_C0CR_NBREQ);
}
inline void dmamux_c0cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_SPOL) | ((val << 17) & DMAMUX_C0CR_SPOL);
}
inline void dmamux_c0cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C0CR_DMAREQ_ID);
}
inline uint32_t dmamux_c0cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C0CR & DMAMUX_C0CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c0cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C0CR & DMAMUX_C0CR_NBREQ) >> 19; }
inline uint32_t dmamux_c0cr_get_spol(struct DMAMUX_Type *p) { return (p->C0CR & DMAMUX_C0CR_SPOL) >> 17; }
inline uint32_t dmamux_c0cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C0CR & DMAMUX_C0CR_DMAREQ_ID) >> 0; }

// DMAMUX->C1CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C1CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C1CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C1CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C1CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C1CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C1CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C1CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c1cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_SYNC_ID) | ((val << 24) & DMAMUX_C1CR_SYNC_ID);
}
inline void dmamux_c1cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_NBREQ) | ((val << 19) & DMAMUX_C1CR_NBREQ);
}
inline void dmamux_c1cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_SPOL) | ((val << 17) & DMAMUX_C1CR_SPOL);
}
inline void dmamux_c1cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C1CR_DMAREQ_ID);
}
inline uint32_t dmamux_c1cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C1CR & DMAMUX_C1CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c1cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C1CR & DMAMUX_C1CR_NBREQ) >> 19; }
inline uint32_t dmamux_c1cr_get_spol(struct DMAMUX_Type *p) { return (p->C1CR & DMAMUX_C1CR_SPOL) >> 17; }
inline uint32_t dmamux_c1cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C1CR & DMAMUX_C1CR_DMAREQ_ID) >> 0; }

// DMAMUX->C2CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C2CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C2CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C2CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C2CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C2CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C2CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C2CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c2cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_SYNC_ID) | ((val << 24) & DMAMUX_C2CR_SYNC_ID);
}
inline void dmamux_c2cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_NBREQ) | ((val << 19) & DMAMUX_C2CR_NBREQ);
}
inline void dmamux_c2cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_SPOL) | ((val << 17) & DMAMUX_C2CR_SPOL);
}
inline void dmamux_c2cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C2CR_DMAREQ_ID);
}
inline uint32_t dmamux_c2cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C2CR & DMAMUX_C2CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c2cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C2CR & DMAMUX_C2CR_NBREQ) >> 19; }
inline uint32_t dmamux_c2cr_get_spol(struct DMAMUX_Type *p) { return (p->C2CR & DMAMUX_C2CR_SPOL) >> 17; }
inline uint32_t dmamux_c2cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C2CR & DMAMUX_C2CR_DMAREQ_ID) >> 0; }

// DMAMUX->C3CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C3CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C3CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C3CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C3CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C3CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C3CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C3CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c3cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_SYNC_ID) | ((val << 24) & DMAMUX_C3CR_SYNC_ID);
}
inline void dmamux_c3cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_NBREQ) | ((val << 19) & DMAMUX_C3CR_NBREQ);
}
inline void dmamux_c3cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_SPOL) | ((val << 17) & DMAMUX_C3CR_SPOL);
}
inline void dmamux_c3cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C3CR_DMAREQ_ID);
}
inline uint32_t dmamux_c3cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C3CR & DMAMUX_C3CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c3cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C3CR & DMAMUX_C3CR_NBREQ) >> 19; }
inline uint32_t dmamux_c3cr_get_spol(struct DMAMUX_Type *p) { return (p->C3CR & DMAMUX_C3CR_SPOL) >> 17; }
inline uint32_t dmamux_c3cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C3CR & DMAMUX_C3CR_DMAREQ_ID) >> 0; }

// DMAMUX->C4CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C4CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C4CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C4CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C4CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C4CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C4CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C4CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c4cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_SYNC_ID) | ((val << 24) & DMAMUX_C4CR_SYNC_ID);
}
inline void dmamux_c4cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_NBREQ) | ((val << 19) & DMAMUX_C4CR_NBREQ);
}
inline void dmamux_c4cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_SPOL) | ((val << 17) & DMAMUX_C4CR_SPOL);
}
inline void dmamux_c4cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C4CR_DMAREQ_ID);
}
inline uint32_t dmamux_c4cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C4CR & DMAMUX_C4CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c4cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C4CR & DMAMUX_C4CR_NBREQ) >> 19; }
inline uint32_t dmamux_c4cr_get_spol(struct DMAMUX_Type *p) { return (p->C4CR & DMAMUX_C4CR_SPOL) >> 17; }
inline uint32_t dmamux_c4cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C4CR & DMAMUX_C4CR_DMAREQ_ID) >> 0; }

// DMAMUX->C5CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C5CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C5CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C5CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C5CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C5CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C5CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C5CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c5cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_SYNC_ID) | ((val << 24) & DMAMUX_C5CR_SYNC_ID);
}
inline void dmamux_c5cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_NBREQ) | ((val << 19) & DMAMUX_C5CR_NBREQ);
}
inline void dmamux_c5cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_SPOL) | ((val << 17) & DMAMUX_C5CR_SPOL);
}
inline void dmamux_c5cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C5CR_DMAREQ_ID);
}
inline uint32_t dmamux_c5cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C5CR & DMAMUX_C5CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c5cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C5CR & DMAMUX_C5CR_NBREQ) >> 19; }
inline uint32_t dmamux_c5cr_get_spol(struct DMAMUX_Type *p) { return (p->C5CR & DMAMUX_C5CR_SPOL) >> 17; }
inline uint32_t dmamux_c5cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C5CR & DMAMUX_C5CR_DMAREQ_ID) >> 0; }

// DMAMUX->C6CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C6CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C6CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C6CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C6CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C6CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C6CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C6CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c6cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_SYNC_ID) | ((val << 24) & DMAMUX_C6CR_SYNC_ID);
}
inline void dmamux_c6cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_NBREQ) | ((val << 19) & DMAMUX_C6CR_NBREQ);
}
inline void dmamux_c6cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_SPOL) | ((val << 17) & DMAMUX_C6CR_SPOL);
}
inline void dmamux_c6cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C6CR_DMAREQ_ID);
}
inline uint32_t dmamux_c6cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C6CR & DMAMUX_C6CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c6cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C6CR & DMAMUX_C6CR_NBREQ) >> 19; }
inline uint32_t dmamux_c6cr_get_spol(struct DMAMUX_Type *p) { return (p->C6CR & DMAMUX_C6CR_SPOL) >> 17; }
inline uint32_t dmamux_c6cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C6CR & DMAMUX_C6CR_DMAREQ_ID) >> 0; }

// DMAMUX->C7CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C7CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C7CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C7CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C7CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C7CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C7CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C7CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c7cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_SYNC_ID) | ((val << 24) & DMAMUX_C7CR_SYNC_ID);
}
inline void dmamux_c7cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_NBREQ) | ((val << 19) & DMAMUX_C7CR_NBREQ);
}
inline void dmamux_c7cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_SPOL) | ((val << 17) & DMAMUX_C7CR_SPOL);
}
inline void dmamux_c7cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C7CR_DMAREQ_ID);
}
inline uint32_t dmamux_c7cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C7CR & DMAMUX_C7CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c7cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C7CR & DMAMUX_C7CR_NBREQ) >> 19; }
inline uint32_t dmamux_c7cr_get_spol(struct DMAMUX_Type *p) { return (p->C7CR & DMAMUX_C7CR_SPOL) >> 17; }
inline uint32_t dmamux_c7cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C7CR & DMAMUX_C7CR_DMAREQ_ID) >> 0; }

// DMAMUX->C8CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C8CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C8CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C8CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C8CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C8CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C8CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C8CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c8cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_SYNC_ID) | ((val << 24) & DMAMUX_C8CR_SYNC_ID);
}
inline void dmamux_c8cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_NBREQ) | ((val << 19) & DMAMUX_C8CR_NBREQ);
}
inline void dmamux_c8cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_SPOL) | ((val << 17) & DMAMUX_C8CR_SPOL);
}
inline void dmamux_c8cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C8CR_DMAREQ_ID);
}
inline uint32_t dmamux_c8cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C8CR & DMAMUX_C8CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c8cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C8CR & DMAMUX_C8CR_NBREQ) >> 19; }
inline uint32_t dmamux_c8cr_get_spol(struct DMAMUX_Type *p) { return (p->C8CR & DMAMUX_C8CR_SPOL) >> 17; }
inline uint32_t dmamux_c8cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C8CR & DMAMUX_C8CR_DMAREQ_ID) >> 0; }

// DMAMUX->C9CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C9CR_SYNC_ID = ((1UL << 5) - 1) << 24,  // Synchronization input selected
	DMAMUX_C9CR_NBREQ	= ((1UL << 5) - 1)
						<< 19,	// Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								// event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								// after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								// is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C9CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C9CR_SE		  = 1UL << 16,				// Synchronous operating mode enable/disable
	DMAMUX_C9CR_EGE		  = 1UL << 9,				// Event generation enable/disable
	DMAMUX_C9CR_SOIE	  = 1UL << 8,				// Interrupt enable at synchronization event overrun
	DMAMUX_C9CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	// Input DMA request line selected
};
inline void dmamux_c9cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_SYNC_ID) | ((val << 24) & DMAMUX_C9CR_SYNC_ID);
}
inline void dmamux_c9cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_NBREQ) | ((val << 19) & DMAMUX_C9CR_NBREQ);
}
inline void dmamux_c9cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_SPOL) | ((val << 17) & DMAMUX_C9CR_SPOL);
}
inline void dmamux_c9cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C9CR_DMAREQ_ID);
}
inline uint32_t dmamux_c9cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C9CR & DMAMUX_C9CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c9cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C9CR & DMAMUX_C9CR_NBREQ) >> 19; }
inline uint32_t dmamux_c9cr_get_spol(struct DMAMUX_Type *p) { return (p->C9CR & DMAMUX_C9CR_SPOL) >> 17; }
inline uint32_t dmamux_c9cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C9CR & DMAMUX_C9CR_DMAREQ_ID) >> 0; }

// DMAMUX->C10CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C10CR_SYNC_ID = ((1UL << 5) - 1) << 24,	// Synchronization input selected
	DMAMUX_C10CR_NBREQ	 = ((1UL << 5) - 1)
						 << 19,	 // Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								 // event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								 // after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								 // is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C10CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C10CR_SE		   = 1UL << 16,				 // Synchronous operating mode enable/disable
	DMAMUX_C10CR_EGE	   = 1UL << 9,				 // Event generation enable/disable
	DMAMUX_C10CR_SOIE	   = 1UL << 8,				 // Interrupt enable at synchronization event overrun
	DMAMUX_C10CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	 // Input DMA request line selected
};
inline void dmamux_c10cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_SYNC_ID) | ((val << 24) & DMAMUX_C10CR_SYNC_ID);
}
inline void dmamux_c10cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_NBREQ) | ((val << 19) & DMAMUX_C10CR_NBREQ);
}
inline void dmamux_c10cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_SPOL) | ((val << 17) & DMAMUX_C10CR_SPOL);
}
inline void dmamux_c10cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C10CR_DMAREQ_ID);
}
inline uint32_t dmamux_c10cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C10CR & DMAMUX_C10CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c10cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C10CR & DMAMUX_C10CR_NBREQ) >> 19; }
inline uint32_t dmamux_c10cr_get_spol(struct DMAMUX_Type *p) { return (p->C10CR & DMAMUX_C10CR_SPOL) >> 17; }
inline uint32_t dmamux_c10cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C10CR & DMAMUX_C10CR_DMAREQ_ID) >> 0; }

// DMAMUX->C11CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C11CR_SYNC_ID = ((1UL << 5) - 1) << 24,	// Synchronization input selected
	DMAMUX_C11CR_NBREQ	 = ((1UL << 5) - 1)
						 << 19,	 // Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								 // event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								 // after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								 // is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C11CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C11CR_SE		   = 1UL << 16,				 // Synchronous operating mode enable/disable
	DMAMUX_C11CR_EGE	   = 1UL << 9,				 // Event generation enable/disable
	DMAMUX_C11CR_SOIE	   = 1UL << 8,				 // Interrupt enable at synchronization event overrun
	DMAMUX_C11CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	 // Input DMA request line selected
};
inline void dmamux_c11cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_SYNC_ID) | ((val << 24) & DMAMUX_C11CR_SYNC_ID);
}
inline void dmamux_c11cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_NBREQ) | ((val << 19) & DMAMUX_C11CR_NBREQ);
}
inline void dmamux_c11cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_SPOL) | ((val << 17) & DMAMUX_C11CR_SPOL);
}
inline void dmamux_c11cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C11CR_DMAREQ_ID);
}
inline uint32_t dmamux_c11cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C11CR & DMAMUX_C11CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c11cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C11CR & DMAMUX_C11CR_NBREQ) >> 19; }
inline uint32_t dmamux_c11cr_get_spol(struct DMAMUX_Type *p) { return (p->C11CR & DMAMUX_C11CR_SPOL) >> 17; }
inline uint32_t dmamux_c11cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C11CR & DMAMUX_C11CR_DMAREQ_ID) >> 0; }

// DMAMUX->C12CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C12CR_SYNC_ID = ((1UL << 5) - 1) << 24,	// Synchronization input selected
	DMAMUX_C12CR_NBREQ	 = ((1UL << 5) - 1)
						 << 19,	 // Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								 // event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								 // after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								 // is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C12CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C12CR_SE		   = 1UL << 16,				 // Synchronous operating mode enable/disable
	DMAMUX_C12CR_EGE	   = 1UL << 9,				 // Event generation enable/disable
	DMAMUX_C12CR_SOIE	   = 1UL << 8,				 // Interrupt enable at synchronization event overrun
	DMAMUX_C12CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	 // Input DMA request line selected
};
inline void dmamux_c12cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_SYNC_ID) | ((val << 24) & DMAMUX_C12CR_SYNC_ID);
}
inline void dmamux_c12cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_NBREQ) | ((val << 19) & DMAMUX_C12CR_NBREQ);
}
inline void dmamux_c12cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_SPOL) | ((val << 17) & DMAMUX_C12CR_SPOL);
}
inline void dmamux_c12cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C12CR_DMAREQ_ID);
}
inline uint32_t dmamux_c12cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C12CR & DMAMUX_C12CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c12cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C12CR & DMAMUX_C12CR_NBREQ) >> 19; }
inline uint32_t dmamux_c12cr_get_spol(struct DMAMUX_Type *p) { return (p->C12CR & DMAMUX_C12CR_SPOL) >> 17; }
inline uint32_t dmamux_c12cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C12CR & DMAMUX_C12CR_DMAREQ_ID) >> 0; }

// DMAMUX->C13CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C13CR_SYNC_ID = ((1UL << 5) - 1) << 24,	// Synchronization input selected
	DMAMUX_C13CR_NBREQ	 = ((1UL << 5) - 1)
						 << 19,	 // Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								 // event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								 // after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								 // is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C13CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C13CR_SE		   = 1UL << 16,				 // Synchronous operating mode enable/disable
	DMAMUX_C13CR_EGE	   = 1UL << 9,				 // Event generation enable/disable
	DMAMUX_C13CR_SOIE	   = 1UL << 8,				 // Interrupt enable at synchronization event overrun
	DMAMUX_C13CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	 // Input DMA request line selected
};
inline void dmamux_c13cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_SYNC_ID) | ((val << 24) & DMAMUX_C13CR_SYNC_ID);
}
inline void dmamux_c13cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_NBREQ) | ((val << 19) & DMAMUX_C13CR_NBREQ);
}
inline void dmamux_c13cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_SPOL) | ((val << 17) & DMAMUX_C13CR_SPOL);
}
inline void dmamux_c13cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C13CR_DMAREQ_ID);
}
inline uint32_t dmamux_c13cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C13CR & DMAMUX_C13CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c13cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C13CR & DMAMUX_C13CR_NBREQ) >> 19; }
inline uint32_t dmamux_c13cr_get_spol(struct DMAMUX_Type *p) { return (p->C13CR & DMAMUX_C13CR_SPOL) >> 17; }
inline uint32_t dmamux_c13cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C13CR & DMAMUX_C13CR_DMAREQ_ID) >> 0; }

// DMAMUX->C14CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C14CR_SYNC_ID = ((1UL << 5) - 1) << 24,	// Synchronization input selected
	DMAMUX_C14CR_NBREQ	 = ((1UL << 5) - 1)
						 << 19,	 // Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								 // event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								 // after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								 // is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C14CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C14CR_SE		   = 1UL << 16,				 // Synchronous operating mode enable/disable
	DMAMUX_C14CR_EGE	   = 1UL << 9,				 // Event generation enable/disable
	DMAMUX_C14CR_SOIE	   = 1UL << 8,				 // Interrupt enable at synchronization event overrun
	DMAMUX_C14CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	 // Input DMA request line selected
};
inline void dmamux_c14cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_SYNC_ID) | ((val << 24) & DMAMUX_C14CR_SYNC_ID);
}
inline void dmamux_c14cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_NBREQ) | ((val << 19) & DMAMUX_C14CR_NBREQ);
}
inline void dmamux_c14cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_SPOL) | ((val << 17) & DMAMUX_C14CR_SPOL);
}
inline void dmamux_c14cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C14CR_DMAREQ_ID);
}
inline uint32_t dmamux_c14cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C14CR & DMAMUX_C14CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c14cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C14CR & DMAMUX_C14CR_NBREQ) >> 19; }
inline uint32_t dmamux_c14cr_get_spol(struct DMAMUX_Type *p) { return (p->C14CR & DMAMUX_C14CR_SPOL) >> 17; }
inline uint32_t dmamux_c14cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C14CR & DMAMUX_C14CR_DMAREQ_ID) >> 0; }

// DMAMUX->C15CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C15CR_SYNC_ID = ((1UL << 5) - 1) << 24,	// Synchronization input selected
	DMAMUX_C15CR_NBREQ	 = ((1UL << 5) - 1)
						 << 19,	 // Number of DMA requests to forward Defines the number of DMA requests forwarded before output
								 // event is generated. In synchronous mode, it also defines the number of DMA requests to forward
								 // after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded
								 // is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C15CR_SPOL =
			((1UL << 2) - 1)
			<< 17,	// Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C15CR_SE		   = 1UL << 16,				 // Synchronous operating mode enable/disable
	DMAMUX_C15CR_EGE	   = 1UL << 9,				 // Event generation enable/disable
	DMAMUX_C15CR_SOIE	   = 1UL << 8,				 // Interrupt enable at synchronization event overrun
	DMAMUX_C15CR_DMAREQ_ID = ((1UL << 7) - 1) << 0,	 // Input DMA request line selected
};
inline void dmamux_c15cr_set_sync_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_SYNC_ID) | ((val << 24) & DMAMUX_C15CR_SYNC_ID);
}
inline void dmamux_c15cr_set_nbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_NBREQ) | ((val << 19) & DMAMUX_C15CR_NBREQ);
}
inline void dmamux_c15cr_set_spol(struct DMAMUX_Type *p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_SPOL) | ((val << 17) & DMAMUX_C15CR_SPOL);
}
inline void dmamux_c15cr_set_dmareq_id(struct DMAMUX_Type *p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C15CR_DMAREQ_ID);
}
inline uint32_t dmamux_c15cr_get_sync_id(struct DMAMUX_Type *p) { return (p->C15CR & DMAMUX_C15CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c15cr_get_nbreq(struct DMAMUX_Type *p) { return (p->C15CR & DMAMUX_C15CR_NBREQ) >> 19; }
inline uint32_t dmamux_c15cr_get_spol(struct DMAMUX_Type *p) { return (p->C15CR & DMAMUX_C15CR_SPOL) >> 17; }
inline uint32_t dmamux_c15cr_get_dmareq_id(struct DMAMUX_Type *p) { return (p->C15CR & DMAMUX_C15CR_DMAREQ_ID) >> 0; }

// DMAMUX->RG0CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG0CR_GNBREQ =
			((1UL << 5) - 1) << 19,	 // Number of DMA requests to generate Defines the number of DMA requests generated after a
									 // trigger event, then stop generating. The actual number of generated DMA requests is
									 // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG0CR_GPOL = ((1UL << 2) - 1) << 17,	  // DMA request generator trigger event type selection Defines the trigger event on
												  // the selected DMA request trigger input
	DMAMUX_RG0CR_GE		= 1UL << 16,			  // DMA request generator channel enable/disable
	DMAMUX_RG0CR_OIE	= 1UL << 8,				  // Interrupt enable at trigger event overrun
	DMAMUX_RG0CR_SIG_ID = ((1UL << 5) - 1) << 0,  // DMA request trigger input selected
};
inline void dmamux_rg0cr_set_gnbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_GNBREQ) | ((val << 19) & DMAMUX_RG0CR_GNBREQ);
}
inline void dmamux_rg0cr_set_gpol(struct DMAMUX_Type *p, uint32_t val) {
	p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_GPOL) | ((val << 17) & DMAMUX_RG0CR_GPOL);
}
inline void dmamux_rg0cr_set_sig_id(struct DMAMUX_Type *p, uint32_t val) {
	p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_SIG_ID) | ((val << 0) & DMAMUX_RG0CR_SIG_ID);
}
inline uint32_t dmamux_rg0cr_get_gnbreq(struct DMAMUX_Type *p) { return (p->RG0CR & DMAMUX_RG0CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg0cr_get_gpol(struct DMAMUX_Type *p) { return (p->RG0CR & DMAMUX_RG0CR_GPOL) >> 17; }
inline uint32_t dmamux_rg0cr_get_sig_id(struct DMAMUX_Type *p) { return (p->RG0CR & DMAMUX_RG0CR_SIG_ID) >> 0; }

// DMAMUX->RG1CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG1CR_GNBREQ =
			((1UL << 5) - 1) << 19,	 // Number of DMA requests to generate Defines the number of DMA requests generated after a
									 // trigger event, then stop generating. The actual number of generated DMA requests is
									 // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG1CR_GPOL = ((1UL << 2) - 1) << 17,	  // DMA request generator trigger event type selection Defines the trigger event on
												  // the selected DMA request trigger input
	DMAMUX_RG1CR_GE		= 1UL << 16,			  // DMA request generator channel enable/disable
	DMAMUX_RG1CR_OIE	= 1UL << 8,				  // Interrupt enable at trigger event overrun
	DMAMUX_RG1CR_SIG_ID = ((1UL << 5) - 1) << 0,  // DMA request trigger input selected
};
inline void dmamux_rg1cr_set_gnbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_GNBREQ) | ((val << 19) & DMAMUX_RG1CR_GNBREQ);
}
inline void dmamux_rg1cr_set_gpol(struct DMAMUX_Type *p, uint32_t val) {
	p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_GPOL) | ((val << 17) & DMAMUX_RG1CR_GPOL);
}
inline void dmamux_rg1cr_set_sig_id(struct DMAMUX_Type *p, uint32_t val) {
	p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_SIG_ID) | ((val << 0) & DMAMUX_RG1CR_SIG_ID);
}
inline uint32_t dmamux_rg1cr_get_gnbreq(struct DMAMUX_Type *p) { return (p->RG1CR & DMAMUX_RG1CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg1cr_get_gpol(struct DMAMUX_Type *p) { return (p->RG1CR & DMAMUX_RG1CR_GPOL) >> 17; }
inline uint32_t dmamux_rg1cr_get_sig_id(struct DMAMUX_Type *p) { return (p->RG1CR & DMAMUX_RG1CR_SIG_ID) >> 0; }

// DMAMUX->RG2CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG2CR_GNBREQ =
			((1UL << 5) - 1) << 19,	 // Number of DMA requests to generate Defines the number of DMA requests generated after a
									 // trigger event, then stop generating. The actual number of generated DMA requests is
									 // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG2CR_GPOL = ((1UL << 2) - 1) << 17,	  // DMA request generator trigger event type selection Defines the trigger event on
												  // the selected DMA request trigger input
	DMAMUX_RG2CR_GE		= 1UL << 16,			  // DMA request generator channel enable/disable
	DMAMUX_RG2CR_OIE	= 1UL << 8,				  // Interrupt enable at trigger event overrun
	DMAMUX_RG2CR_SIG_ID = ((1UL << 5) - 1) << 0,  // DMA request trigger input selected
};
inline void dmamux_rg2cr_set_gnbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_GNBREQ) | ((val << 19) & DMAMUX_RG2CR_GNBREQ);
}
inline void dmamux_rg2cr_set_gpol(struct DMAMUX_Type *p, uint32_t val) {
	p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_GPOL) | ((val << 17) & DMAMUX_RG2CR_GPOL);
}
inline void dmamux_rg2cr_set_sig_id(struct DMAMUX_Type *p, uint32_t val) {
	p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_SIG_ID) | ((val << 0) & DMAMUX_RG2CR_SIG_ID);
}
inline uint32_t dmamux_rg2cr_get_gnbreq(struct DMAMUX_Type *p) { return (p->RG2CR & DMAMUX_RG2CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg2cr_get_gpol(struct DMAMUX_Type *p) { return (p->RG2CR & DMAMUX_RG2CR_GPOL) >> 17; }
inline uint32_t dmamux_rg2cr_get_sig_id(struct DMAMUX_Type *p) { return (p->RG2CR & DMAMUX_RG2CR_SIG_ID) >> 0; }

// DMAMUX->RG3CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG3CR_GNBREQ =
			((1UL << 5) - 1) << 19,	 // Number of DMA requests to generate Defines the number of DMA requests generated after a
									 // trigger event, then stop generating. The actual number of generated DMA requests is
									 // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG3CR_GPOL = ((1UL << 2) - 1) << 17,	  // DMA request generator trigger event type selection Defines the trigger event on
												  // the selected DMA request trigger input
	DMAMUX_RG3CR_GE		= 1UL << 16,			  // DMA request generator channel enable/disable
	DMAMUX_RG3CR_OIE	= 1UL << 8,				  // Interrupt enable at trigger event overrun
	DMAMUX_RG3CR_SIG_ID = ((1UL << 5) - 1) << 0,  // DMA request trigger input selected
};
inline void dmamux_rg3cr_set_gnbreq(struct DMAMUX_Type *p, uint32_t val) {
	p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_GNBREQ) | ((val << 19) & DMAMUX_RG3CR_GNBREQ);
}
inline void dmamux_rg3cr_set_gpol(struct DMAMUX_Type *p, uint32_t val) {
	p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_GPOL) | ((val << 17) & DMAMUX_RG3CR_GPOL);
}
inline void dmamux_rg3cr_set_sig_id(struct DMAMUX_Type *p, uint32_t val) {
	p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_SIG_ID) | ((val << 0) & DMAMUX_RG3CR_SIG_ID);
}
inline uint32_t dmamux_rg3cr_get_gnbreq(struct DMAMUX_Type *p) { return (p->RG3CR & DMAMUX_RG3CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg3cr_get_gpol(struct DMAMUX_Type *p) { return (p->RG3CR & DMAMUX_RG3CR_GPOL) >> 17; }
inline uint32_t dmamux_rg3cr_get_sig_id(struct DMAMUX_Type *p) { return (p->RG3CR & DMAMUX_RG3CR_SIG_ID) >> 0; }

// DMAMUX->RGSR DMAMux - DMA request generator status register
enum {
	DMAMUX_RGSR_OF =
			((1UL << 4) - 1) << 0,	// Trigger event overrun flag The flag is set when a trigger event occurs on DMA request
									// generator channel x, while the DMA request generator counter value is lower than GNBREQ. The
									// flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
};
inline uint32_t dmamux_rgsr_get_of(struct DMAMUX_Type *p) { return (p->RGSR & DMAMUX_RGSR_OF) >> 0; }

// DMAMUX->RGCFR DMAMux - DMA request generator clear flag register
enum {
	DMAMUX_RGCFR_COF = ((1UL << 4) - 1) << 0,  // Clear trigger event overrun flag Upon setting, this bit clears the corresponding
											   // overrun flag OFx in the DMAMUX_RGCSR register.
};
inline void dmamux_rgcfr_set_cof(struct DMAMUX_Type *p, uint32_t val) {
	p->RGCFR = (p->RGCFR & ~DMAMUX_RGCFR_COF) | ((val << 0) & DMAMUX_RGCFR_COF);
}
inline uint32_t dmamux_rgcfr_get_cof(struct DMAMUX_Type *p) { return (p->RGCFR & DMAMUX_RGCFR_COF) >> 0; }

/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t IMR1;			 // @0 Interrupt mask register
	__IO uint32_t EMR1;			 // @4 Event mask register
	__IO uint32_t RTSR1;		 // @8 Rising Trigger selection register
	__IO uint32_t FTSR1;		 // @12 Falling Trigger selection register
	__IO uint32_t SWIER1;		 // @16 Software interrupt event register
	__IO uint32_t PR1;			 // @20 Pending register
	uint8_t		  RESERVED0[8];	 // @24
	__IO uint16_t IMR2;			 // @32 Interrupt mask register
	uint8_t		  RESERVED1[2];	 // @34
	__IO uint16_t EMR2;			 // @36 Event mask register
	uint8_t		  RESERVED2[2];	 // @38
	__IO uint16_t RTSR2;		 // @40 Rising Trigger selection register
	uint8_t		  RESERVED3[2];	 // @42
	__IO uint8_t  FTSR2;		 // @44 Falling Trigger selection register
	uint8_t		  RESERVED4[3];	 // @45
	__IO uint8_t  SWIER2;		 // @48 Software interrupt event register
	uint8_t		  RESERVED5[3];	 // @49
	__IO uint8_t  PR2;			 // @52 Pending register
};

// EXTI->RTSR1 Rising Trigger selection register
enum {
	EXTI_RTSR1_RT	= ((1UL << 3) - 1) << 29,  // RT
	EXTI_RTSR1_RT22 = 1UL << 22,			   // Rising trigger event configuration of line 22
	EXTI_RTSR1_RT21 = 1UL << 21,			   // Rising trigger event configuration of line 21
	EXTI_RTSR1_RT20 = 1UL << 20,			   // Rising trigger event configuration of line 20
	EXTI_RTSR1_RT19 = 1UL << 19,			   // Rising trigger event configuration of line 19
	EXTI_RTSR1_RT18 = 1UL << 18,			   // Rising trigger event configuration of line 18
	EXTI_RTSR1_RT16 = 1UL << 16,			   // Rising trigger event configuration of line 16
	EXTI_RTSR1_RT15 = 1UL << 15,			   // Rising trigger event configuration of line 15
	EXTI_RTSR1_RT14 = 1UL << 14,			   // Rising trigger event configuration of line 14
	EXTI_RTSR1_RT13 = 1UL << 13,			   // Rising trigger event configuration of line 13
	EXTI_RTSR1_RT12 = 1UL << 12,			   // Rising trigger event configuration of line 12
	EXTI_RTSR1_RT11 = 1UL << 11,			   // Rising trigger event configuration of line 11
	EXTI_RTSR1_RT10 = 1UL << 10,			   // Rising trigger event configuration of line 10
	EXTI_RTSR1_RT9	= 1UL << 9,				   // Rising trigger event configuration of line 9
	EXTI_RTSR1_RT8	= 1UL << 8,				   // Rising trigger event configuration of line 8
	EXTI_RTSR1_RT7	= 1UL << 7,				   // Rising trigger event configuration of line 7
	EXTI_RTSR1_RT6	= 1UL << 6,				   // Rising trigger event configuration of line 6
	EXTI_RTSR1_RT5	= 1UL << 5,				   // Rising trigger event configuration of line 5
	EXTI_RTSR1_RT4	= 1UL << 4,				   // Rising trigger event configuration of line 4
	EXTI_RTSR1_RT3	= 1UL << 3,				   // Rising trigger event configuration of line 3
	EXTI_RTSR1_RT2	= 1UL << 2,				   // Rising trigger event configuration of line 2
	EXTI_RTSR1_RT1	= 1UL << 1,				   // Rising trigger event configuration of line 1
	EXTI_RTSR1_RT0	= 1UL << 0,				   // Rising trigger event configuration of line 0
};
inline void exti_rtsr1_set_rt(struct EXTI_Type *p, uint32_t val) {
	p->RTSR1 = (p->RTSR1 & ~EXTI_RTSR1_RT) | ((val << 29) & EXTI_RTSR1_RT);
}
inline uint32_t exti_rtsr1_get_rt(struct EXTI_Type *p) { return (p->RTSR1 & EXTI_RTSR1_RT) >> 29; }

// EXTI->FTSR1 Falling Trigger selection register
enum {
	EXTI_FTSR1_FT22 = 1UL << 22,  // Falling trigger event configuration of line 22
	EXTI_FTSR1_FT21 = 1UL << 21,  // Falling trigger event configuration of line 21
	EXTI_FTSR1_FT20 = 1UL << 20,  // Falling trigger event configuration of line 20
	EXTI_FTSR1_FT19 = 1UL << 19,  // Falling trigger event configuration of line 19
	EXTI_FTSR1_FT18 = 1UL << 18,  // Falling trigger event configuration of line 18
	EXTI_FTSR1_FT16 = 1UL << 16,  // Falling trigger event configuration of line 16
	EXTI_FTSR1_FT15 = 1UL << 15,  // Falling trigger event configuration of line 15
	EXTI_FTSR1_FT14 = 1UL << 14,  // Falling trigger event configuration of line 14
	EXTI_FTSR1_FT13 = 1UL << 13,  // Falling trigger event configuration of line 13
	EXTI_FTSR1_FT12 = 1UL << 12,  // Falling trigger event configuration of line 12
	EXTI_FTSR1_FT11 = 1UL << 11,  // Falling trigger event configuration of line 11
	EXTI_FTSR1_FT10 = 1UL << 10,  // Falling trigger event configuration of line 10
	EXTI_FTSR1_FT9	= 1UL << 9,	  // Falling trigger event configuration of line 9
	EXTI_FTSR1_FT8	= 1UL << 8,	  // Falling trigger event configuration of line 8
	EXTI_FTSR1_FT7	= 1UL << 7,	  // Falling trigger event configuration of line 7
	EXTI_FTSR1_FT6	= 1UL << 6,	  // Falling trigger event configuration of line 6
	EXTI_FTSR1_FT5	= 1UL << 5,	  // Falling trigger event configuration of line 5
	EXTI_FTSR1_FT4	= 1UL << 4,	  // Falling trigger event configuration of line 4
	EXTI_FTSR1_FT3	= 1UL << 3,	  // Falling trigger event configuration of line 3
	EXTI_FTSR1_FT2	= 1UL << 2,	  // Falling trigger event configuration of line 2
	EXTI_FTSR1_FT1	= 1UL << 1,	  // Falling trigger event configuration of line 1
	EXTI_FTSR1_FT0	= 1UL << 0,	  // Falling trigger event configuration of line 0
};

// EXTI->SWIER1 Software interrupt event register
enum {
	EXTI_SWIER1_SWI22 = 1UL << 22,	// Software Interrupt on line 22
	EXTI_SWIER1_SWI21 = 1UL << 21,	// Software Interrupt on line 21
	EXTI_SWIER1_SWI20 = 1UL << 20,	// Software Interrupt on line 20
	EXTI_SWIER1_SWI19 = 1UL << 19,	// Software Interrupt on line 19
	EXTI_SWIER1_SWI18 = 1UL << 18,	// Software Interrupt on line 18
	EXTI_SWIER1_SWI16 = 1UL << 16,	// Software Interrupt on line 16
	EXTI_SWIER1_SWI15 = 1UL << 15,	// Software Interrupt on line 15
	EXTI_SWIER1_SWI14 = 1UL << 14,	// Software Interrupt on line 14
	EXTI_SWIER1_SWI13 = 1UL << 13,	// Software Interrupt on line 13
	EXTI_SWIER1_SWI12 = 1UL << 12,	// Software Interrupt on line 12
	EXTI_SWIER1_SWI11 = 1UL << 11,	// Software Interrupt on line 11
	EXTI_SWIER1_SWI10 = 1UL << 10,	// Software Interrupt on line 10
	EXTI_SWIER1_SWI9  = 1UL << 9,	// Software Interrupt on line 9
	EXTI_SWIER1_SWI8  = 1UL << 8,	// Software Interrupt on line 8
	EXTI_SWIER1_SWI7  = 1UL << 7,	// Software Interrupt on line 7
	EXTI_SWIER1_SWI6  = 1UL << 6,	// Software Interrupt on line 6
	EXTI_SWIER1_SWI5  = 1UL << 5,	// Software Interrupt on line 5
	EXTI_SWIER1_SWI4  = 1UL << 4,	// Software Interrupt on line 4
	EXTI_SWIER1_SWI3  = 1UL << 3,	// Software Interrupt on line 3
	EXTI_SWIER1_SWI2  = 1UL << 2,	// Software Interrupt on line 2
	EXTI_SWIER1_SWI1  = 1UL << 1,	// Software Interrupt on line 1
	EXTI_SWIER1_SWI0  = 1UL << 0,	// Software Interrupt on line 0
};

// EXTI->PR1 Pending register
enum {
	EXTI_PR1_PIF22 = 1UL << 22,	 // Pending bit 22
	EXTI_PR1_PIF21 = 1UL << 21,	 // Pending bit 21
	EXTI_PR1_PIF20 = 1UL << 20,	 // Pending bit 20
	EXTI_PR1_PIF19 = 1UL << 19,	 // Pending bit 19
	EXTI_PR1_PIF18 = 1UL << 18,	 // Pending bit 18
	EXTI_PR1_PIF16 = 1UL << 16,	 // Pending bit 16
	EXTI_PR1_PIF15 = 1UL << 15,	 // Pending bit 15
	EXTI_PR1_PIF14 = 1UL << 14,	 // Pending bit 14
	EXTI_PR1_PIF13 = 1UL << 13,	 // Pending bit 13
	EXTI_PR1_PIF12 = 1UL << 12,	 // Pending bit 12
	EXTI_PR1_PIF11 = 1UL << 11,	 // Pending bit 11
	EXTI_PR1_PIF10 = 1UL << 10,	 // Pending bit 10
	EXTI_PR1_PIF9  = 1UL << 9,	 // Pending bit 9
	EXTI_PR1_PIF8  = 1UL << 8,	 // Pending bit 8
	EXTI_PR1_PIF7  = 1UL << 7,	 // Pending bit 7
	EXTI_PR1_PIF6  = 1UL << 6,	 // Pending bit 6
	EXTI_PR1_PIF5  = 1UL << 5,	 // Pending bit 5
	EXTI_PR1_PIF4  = 1UL << 4,	 // Pending bit 4
	EXTI_PR1_PIF3  = 1UL << 3,	 // Pending bit 3
	EXTI_PR1_PIF2  = 1UL << 2,	 // Pending bit 2
	EXTI_PR1_PIF1  = 1UL << 1,	 // Pending bit 1
	EXTI_PR1_PIF0  = 1UL << 0,	 // Pending bit 0
};

// EXTI->IMR2 Interrupt mask register
enum {
	EXTI_IMR2_IMX = ((1UL << 12) - 1) << 0,	 // Merged Interrupt Mask on external/internal line 43
};
inline void exti_imr2_set_imx(struct EXTI_Type *p, uint32_t val) {
	p->IMR2 = (p->IMR2 & ~EXTI_IMR2_IMX) | ((val << 0) & EXTI_IMR2_IMX);
}
inline uint32_t exti_imr2_get_imx(struct EXTI_Type *p) { return (p->IMR2 & EXTI_IMR2_IMX) >> 0; }

// EXTI->EMR2 Event mask register
enum {
	EXTI_EMR2_EMX = ((1UL << 9) - 1) << 0,	// Merged Event mask on external/internal line 40
};
inline void exti_emr2_set_emx(struct EXTI_Type *p, uint32_t val) {
	p->EMR2 = (p->EMR2 & ~EXTI_EMR2_EMX) | ((val << 0) & EXTI_EMR2_EMX);
}
inline uint32_t exti_emr2_get_emx(struct EXTI_Type *p) { return (p->EMR2 & EXTI_EMR2_EMX) >> 0; }

// EXTI->RTSR2 Rising Trigger selection register
enum {
	EXTI_RTSR2_RT41 = 1UL << 9,	 // Rising trigger event configuration bit of line 41
	EXTI_RTSR2_RT40 = 1UL << 8,	 // Rising trigger event configuration bit of line 40
	EXTI_RTSR2_RT39 = 1UL << 7,	 // Rising trigger event configuration bit of line 39
	EXTI_RTSR2_RT38 = 1UL << 6,	 // Rising trigger event configuration bit of line 38
	EXTI_RTSR2_RT33 = 1UL << 1,	 // Rising trigger event configuration bit of line 32
	EXTI_RTSR2_RT32 = 1UL << 0,	 // Rising trigger event configuration bit of line 32
};

// EXTI->FTSR2 Falling Trigger selection register
enum {
	EXTI_FTSR2_FT38 = 1UL << 6,	 // Falling trigger event configuration bit of line 38
	EXTI_FTSR2_FT37 = 1UL << 5,	 // Falling trigger event configuration bit of line 37
	EXTI_FTSR2_FT36 = 1UL << 4,	 // Falling trigger event configuration bit of line 36
	EXTI_FTSR2_FT35 = 1UL << 3,	 // Falling trigger event configuration bit of line 35
};

// EXTI->SWIER2 Software interrupt event register
enum {
	EXTI_SWIER2_SWI38 = 1UL << 6,  // Software interrupt on line 38
	EXTI_SWIER2_SWI37 = 1UL << 5,  // Software interrupt on line 37
	EXTI_SWIER2_SWI36 = 1UL << 4,  // Software interrupt on line 36
	EXTI_SWIER2_SWI35 = 1UL << 3,  // Software interrupt on line 35
};

// EXTI->PR2 Pending register
enum {
	EXTI_PR2_PIF38 = 1UL << 6,	// Pending interrupt flag on line 38
	EXTI_PR2_PIF37 = 1UL << 5,	// Pending interrupt flag on line 37
	EXTI_PR2_PIF36 = 1UL << 4,	// Pending interrupt flag on line 36
	EXTI_PR2_PIF35 = 1UL << 3,	// Pending interrupt flag on line 35
};

/* FDCAN */
struct FDCAN1_Type {
	__I uint32_t CREL;			// @0 FDCAN Core Release Register
	__I uint32_t ENDN;			// @4 FDCAN Core Release Register
	uint8_t		 RESERVED0[4];	// @8
	__IO uint32_t
			DBTP;  // @12 This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed
				   // in the range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN
				   // clock periods. tq = (DBRP + 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is
				   // Phase_Seg2. Therefore the length of the bit time is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or
				   // (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT)
				   // is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
	__IO uint8_t TEST;	// @16 Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test
						// Register functions are set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and
						// software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may
						// disturb the message transfer on the CAN bus.
	uint8_t		  RESERVED1[3];	 // @17
	__IO uint16_t RWD;	// @20 The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the
						// Message RAM Watchdog Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with
						// RWD[WDC] bits when the Message RAM signals successful completion by activating its READY output. In case
						// there is no response from the Message RAM until the counter has counted down to 0, the counter stops and
						// interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
	uint8_t		  RESERVED2[2];	  // @22
	__IO uint16_t CCCR;			  // @24 For details about setting and resetting of single bits see Software initialization.
	uint8_t		  RESERVED3[2];	  // @26
	__IO uint32_t NBTP;			  // @28 FDCAN_NBTP
	__IO uint32_t TSCC;			  // @32 FDCAN Timestamp Counter Configuration Register
	__I uint16_t  TSCV;			  // @36 FDCAN Timestamp Counter Value Register
	uint8_t		  RESERVED4[2];	  // @38
	__IO uint32_t TOCC;			  // @40 FDCAN Timeout Counter Configuration Register
	__I uint16_t  TOCV;			  // @44 FDCAN Timeout Counter Value Register
	uint8_t		  RESERVED5[18];  // @46
	__I uint32_t  ECR;			  // @64 FDCAN Error Counter Register
	__IO uint32_t PSR;			  // @68 FDCAN Protocol Status Register
	__IO uint16_t TDCR;			  // @72 FDCAN Transmitter Delay Compensation Register
	uint8_t		  RESERVED6[6];	  // @74
	__IO uint32_t
			IR;	 // @80 The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until
				 // the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no
				 // effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is
				 // generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
	__IO uint32_t IE;  // @84 The settings in the Interrupt Enable register determine which status changes in the Interrupt Register
					   // will be signaled on an interrupt line.
	__IO uint8_t ILS;  // @88 The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from
					   // the Interrupt Register to one of the two module interrupt lines. For interrupt generation the respective
					   // interrupt line has to be enabled via ILE[EINT0] and ILE[EINT1].
	uint8_t		 RESERVED7[3];	// @89
	__IO uint8_t ILE;  // @92 Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits
					   // EINT0 and EINT1.
	uint8_t		  RESERVED8[35];  // @93
	__IO uint32_t RXGFC;  // @128 Global settings for Message ID filtering. The Global Filter Configuration controls the filter path
						  // for standard and extended messages as described in Figure706: Standard Message ID filter path and
						  // Figure707: Extended Message ID filter path.
	__IO uint32_t XIDAM;  // @132 FDCAN Extended ID and Mask Register
	__I uint16_t  HPMS;	  // @136 This register is updated every time a Message ID filter element configured to generate a priority
						// event match. This can be used to monitor the status of incoming high priority messages and to enable fast
						// access to these messages.
	uint8_t		  RESERVED9[6];	   // @138
	__I uint32_t  RXF0S;		   // @144 FDCAN Rx FIFO 0 Status Register
	__IO uint8_t  RXF0A;		   // @148 CAN Rx FIFO 0 Acknowledge Register
	uint8_t		  RESERVED10[3];   // @149
	__I uint32_t  RXF1S;		   // @152 FDCAN Rx FIFO 1 Status Register
	__IO uint8_t  RXF1A;		   // @156 FDCAN Rx FIFO 1 Acknowledge Register
	uint8_t		  RESERVED11[35];  // @157
	__IO uint32_t TXBC;			   // @192 FDCAN Tx Buffer Configuration Register
	__I uint32_t  TXFQS;  // @196 The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore
						 // the effect of Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
	__I uint8_t	 TXBRP;			  // @200 FDCAN Tx Buffer Request Pending Register
	uint8_t		 RESERVED12[3];	  // @201
	__IO uint8_t TXBAR;			  // @204 FDCAN Tx Buffer Add Request Register
	uint8_t		 RESERVED13[3];	  // @205
	__IO uint8_t TXBCR;			  // @208 FDCAN Tx Buffer Cancellation Request Register
	uint8_t		 RESERVED14[3];	  // @209
	__I uint8_t	 TXBTO;			  // @212 FDCAN Tx Buffer Transmission Occurred Register
	uint8_t		 RESERVED15[3];	  // @213
	__I uint8_t	 TXBCF;			  // @216 FDCAN Tx Buffer Cancellation Finished Register
	uint8_t		 RESERVED16[3];	  // @217
	__IO uint8_t TXBTIE;		  // @220 FDCAN Tx Buffer Transmission Interrupt Enable Register
	uint8_t		 RESERVED17[3];	  // @221
	__IO uint8_t TXBCIE;		  // @224 FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
	uint8_t		 RESERVED18[3];	  // @225
	__I uint32_t TXEFS;			  // @228 FDCAN Tx Event FIFO Status Register
	__IO uint8_t TXEFA;			  // @232 FDCAN Tx Event FIFO Acknowledge Register
	uint8_t		 RESERVED19[23];  // @233
	__IO uint8_t CKDIV;			  // @256 FDCAN CFG clock divider register
};

// FDCAN1->CREL FDCAN Core Release Register
enum {
	FDCAN1_CREL_REL		= ((1UL << 4) - 1) << 28,  // REL
	FDCAN1_CREL_STEP	= ((1UL << 4) - 1) << 24,  // STEP
	FDCAN1_CREL_SUBSTEP = ((1UL << 4) - 1) << 20,  // SUBSTEP
	FDCAN1_CREL_YEAR	= ((1UL << 4) - 1) << 16,  // YEAR
	FDCAN1_CREL_MON		= ((1UL << 8) - 1) << 8,   // MON
	FDCAN1_CREL_DAY		= ((1UL << 8) - 1) << 0,   // DAY
};
inline uint32_t fdcan1_crel_get_rel(struct FDCAN1_Type *p) { return (p->CREL & FDCAN1_CREL_REL) >> 28; }
inline uint32_t fdcan1_crel_get_step(struct FDCAN1_Type *p) { return (p->CREL & FDCAN1_CREL_STEP) >> 24; }
inline uint32_t fdcan1_crel_get_substep(struct FDCAN1_Type *p) { return (p->CREL & FDCAN1_CREL_SUBSTEP) >> 20; }
inline uint32_t fdcan1_crel_get_year(struct FDCAN1_Type *p) { return (p->CREL & FDCAN1_CREL_YEAR) >> 16; }
inline uint32_t fdcan1_crel_get_mon(struct FDCAN1_Type *p) { return (p->CREL & FDCAN1_CREL_MON) >> 8; }
inline uint32_t fdcan1_crel_get_day(struct FDCAN1_Type *p) { return (p->CREL & FDCAN1_CREL_DAY) >> 0; }

// FDCAN1->DBTP This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in the
// range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock periods. tq = (DBRP +
// 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time
// is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The
// Information Processing Time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the
// sample point.
enum {
	FDCAN1_DBTP_TDC	   = 1UL << 23,				  // TDC
	FDCAN1_DBTP_DBRP   = ((1UL << 5) - 1) << 16,  // DBRP
	FDCAN1_DBTP_DTSEG1 = ((1UL << 5) - 1) << 8,	  // DTSEG1
	FDCAN1_DBTP_DTSEG2 = ((1UL << 4) - 1) << 4,	  // DTSEG2
	FDCAN1_DBTP_DSJW   = ((1UL << 4) - 1) << 0,	  // DSJW
};
inline void fdcan1_dbtp_set_dbrp(struct FDCAN1_Type *p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN1_DBTP_DBRP) | ((val << 16) & FDCAN1_DBTP_DBRP);
}
inline void fdcan1_dbtp_set_dtseg1(struct FDCAN1_Type *p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN1_DBTP_DTSEG1) | ((val << 8) & FDCAN1_DBTP_DTSEG1);
}
inline void fdcan1_dbtp_set_dtseg2(struct FDCAN1_Type *p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN1_DBTP_DTSEG2) | ((val << 4) & FDCAN1_DBTP_DTSEG2);
}
inline void fdcan1_dbtp_set_dsjw(struct FDCAN1_Type *p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN1_DBTP_DSJW) | ((val << 0) & FDCAN1_DBTP_DSJW);
}
inline uint32_t fdcan1_dbtp_get_dbrp(struct FDCAN1_Type *p) { return (p->DBTP & FDCAN1_DBTP_DBRP) >> 16; }
inline uint32_t fdcan1_dbtp_get_dtseg1(struct FDCAN1_Type *p) { return (p->DBTP & FDCAN1_DBTP_DTSEG1) >> 8; }
inline uint32_t fdcan1_dbtp_get_dtseg2(struct FDCAN1_Type *p) { return (p->DBTP & FDCAN1_DBTP_DTSEG2) >> 4; }
inline uint32_t fdcan1_dbtp_get_dsjw(struct FDCAN1_Type *p) { return (p->DBTP & FDCAN1_DBTP_DSJW) >> 0; }

// FDCAN1->TEST Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are
// set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are hardware test
// modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
enum {
	FDCAN1_TEST_RX	 = 1UL << 7,			   // RX
	FDCAN1_TEST_TX	 = ((1UL << 2) - 1) << 5,  // TX
	FDCAN1_TEST_LBCK = 1UL << 4,			   // LBCK
};
inline void fdcan1_test_set_tx(struct FDCAN1_Type *p, uint32_t val) {
	p->TEST = (p->TEST & ~FDCAN1_TEST_TX) | ((val << 5) & FDCAN1_TEST_TX);
}
inline uint32_t fdcan1_test_get_tx(struct FDCAN1_Type *p) { return (p->TEST & FDCAN1_TEST_TX) >> 5; }

// FDCAN1->RWD The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM Watchdog
// Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when the Message RAM signals
// successful completion by activating its READY output. In case there is no response from the Message RAM until the counter has
// counted down to 0, the counter stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk
// clock.
enum {
	FDCAN1_RWD_WDV = ((1UL << 8) - 1) << 8,	 // WDV
	FDCAN1_RWD_WDC = ((1UL << 8) - 1) << 0,	 // WDC
};
inline void fdcan1_rwd_set_wdv(struct FDCAN1_Type *p, uint32_t val) {
	p->RWD = (p->RWD & ~FDCAN1_RWD_WDV) | ((val << 8) & FDCAN1_RWD_WDV);
}
inline void fdcan1_rwd_set_wdc(struct FDCAN1_Type *p, uint32_t val) {
	p->RWD = (p->RWD & ~FDCAN1_RWD_WDC) | ((val << 0) & FDCAN1_RWD_WDC);
}
inline uint32_t fdcan1_rwd_get_wdv(struct FDCAN1_Type *p) { return (p->RWD & FDCAN1_RWD_WDV) >> 8; }
inline uint32_t fdcan1_rwd_get_wdc(struct FDCAN1_Type *p) { return (p->RWD & FDCAN1_RWD_WDC) >> 0; }

// FDCAN1->CCCR For details about setting and resetting of single bits see Software initialization.
enum {
	FDCAN1_CCCR_NISO = 1UL << 15,  // NISO
	FDCAN1_CCCR_TXP	 = 1UL << 14,  // TXP
	FDCAN1_CCCR_EFBI = 1UL << 13,  // EFBI
	FDCAN1_CCCR_PXHD = 1UL << 12,  // PXHD
	FDCAN1_CCCR_BRSE = 1UL << 9,   // BRSE
	FDCAN1_CCCR_FDOE = 1UL << 8,   // FDOE
	FDCAN1_CCCR_TEST = 1UL << 7,   // TEST
	FDCAN1_CCCR_DAR	 = 1UL << 6,   // DAR
	FDCAN1_CCCR_MON	 = 1UL << 5,   // MON
	FDCAN1_CCCR_CSR	 = 1UL << 4,   // CSR
	FDCAN1_CCCR_CSA	 = 1UL << 3,   // CSA
	FDCAN1_CCCR_ASM	 = 1UL << 2,   // ASM
	FDCAN1_CCCR_CCE	 = 1UL << 1,   // CCE
	FDCAN1_CCCR_INIT = 1UL << 0,   // INIT
};

// FDCAN1->NBTP FDCAN_NBTP
enum {
	FDCAN1_NBTP_NSJW   = ((1UL << 7) - 1) << 25,  // NSJW
	FDCAN1_NBTP_NBRP   = ((1UL << 9) - 1) << 16,  // NBRP
	FDCAN1_NBTP_NTSEG1 = ((1UL << 8) - 1) << 8,	  // NTSEG1
	FDCAN1_NBTP_NTSEG2 = ((1UL << 7) - 1) << 0,	  // NTSEG2
};
inline void fdcan1_nbtp_set_nsjw(struct FDCAN1_Type *p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN1_NBTP_NSJW) | ((val << 25) & FDCAN1_NBTP_NSJW);
}
inline void fdcan1_nbtp_set_nbrp(struct FDCAN1_Type *p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN1_NBTP_NBRP) | ((val << 16) & FDCAN1_NBTP_NBRP);
}
inline void fdcan1_nbtp_set_ntseg1(struct FDCAN1_Type *p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN1_NBTP_NTSEG1) | ((val << 8) & FDCAN1_NBTP_NTSEG1);
}
inline void fdcan1_nbtp_set_ntseg2(struct FDCAN1_Type *p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN1_NBTP_NTSEG2) | ((val << 0) & FDCAN1_NBTP_NTSEG2);
}
inline uint32_t fdcan1_nbtp_get_nsjw(struct FDCAN1_Type *p) { return (p->NBTP & FDCAN1_NBTP_NSJW) >> 25; }
inline uint32_t fdcan1_nbtp_get_nbrp(struct FDCAN1_Type *p) { return (p->NBTP & FDCAN1_NBTP_NBRP) >> 16; }
inline uint32_t fdcan1_nbtp_get_ntseg1(struct FDCAN1_Type *p) { return (p->NBTP & FDCAN1_NBTP_NTSEG1) >> 8; }
inline uint32_t fdcan1_nbtp_get_ntseg2(struct FDCAN1_Type *p) { return (p->NBTP & FDCAN1_NBTP_NTSEG2) >> 0; }

// FDCAN1->TSCC FDCAN Timestamp Counter Configuration Register
enum {
	FDCAN1_TSCC_TCP = ((1UL << 4) - 1) << 16,  // TCP
	FDCAN1_TSCC_TSS = ((1UL << 2) - 1) << 0,   // TSS
};
inline void fdcan1_tscc_set_tcp(struct FDCAN1_Type *p, uint32_t val) {
	p->TSCC = (p->TSCC & ~FDCAN1_TSCC_TCP) | ((val << 16) & FDCAN1_TSCC_TCP);
}
inline void fdcan1_tscc_set_tss(struct FDCAN1_Type *p, uint32_t val) {
	p->TSCC = (p->TSCC & ~FDCAN1_TSCC_TSS) | ((val << 0) & FDCAN1_TSCC_TSS);
}
inline uint32_t fdcan1_tscc_get_tcp(struct FDCAN1_Type *p) { return (p->TSCC & FDCAN1_TSCC_TCP) >> 16; }
inline uint32_t fdcan1_tscc_get_tss(struct FDCAN1_Type *p) { return (p->TSCC & FDCAN1_TSCC_TSS) >> 0; }

// FDCAN1->TOCC FDCAN Timeout Counter Configuration Register
enum {
	FDCAN1_TOCC_TOP	 = ((1UL << 16) - 1) << 16,	 // TOP
	FDCAN1_TOCC_TOS	 = ((1UL << 2) - 1) << 1,	 // TOS
	FDCAN1_TOCC_ETOC = 1UL << 0,				 // ETOC
};
inline void fdcan1_tocc_set_top(struct FDCAN1_Type *p, uint32_t val) {
	p->TOCC = (p->TOCC & ~FDCAN1_TOCC_TOP) | ((val << 16) & FDCAN1_TOCC_TOP);
}
inline void fdcan1_tocc_set_tos(struct FDCAN1_Type *p, uint32_t val) {
	p->TOCC = (p->TOCC & ~FDCAN1_TOCC_TOS) | ((val << 1) & FDCAN1_TOCC_TOS);
}
inline uint32_t fdcan1_tocc_get_top(struct FDCAN1_Type *p) { return (p->TOCC & FDCAN1_TOCC_TOP) >> 16; }
inline uint32_t fdcan1_tocc_get_tos(struct FDCAN1_Type *p) { return (p->TOCC & FDCAN1_TOCC_TOS) >> 1; }

// FDCAN1->ECR FDCAN Error Counter Register
enum {
	FDCAN1_ECR_CEL = ((1UL << 8) - 1) << 16,  // CEL
	FDCAN1_ECR_RP  = 1UL << 15,				  // RP
	FDCAN1_ECR_REC = ((1UL << 7) - 1) << 8,	  // TREC
	FDCAN1_ECR_TEC = ((1UL << 8) - 1) << 0,	  // TEC
};
inline uint32_t fdcan1_ecr_get_cel(struct FDCAN1_Type *p) { return (p->ECR & FDCAN1_ECR_CEL) >> 16; }
inline uint32_t fdcan1_ecr_get_rec(struct FDCAN1_Type *p) { return (p->ECR & FDCAN1_ECR_REC) >> 8; }
inline uint32_t fdcan1_ecr_get_tec(struct FDCAN1_Type *p) { return (p->ECR & FDCAN1_ECR_TEC) >> 0; }

// FDCAN1->PSR FDCAN Protocol Status Register
enum {
	FDCAN1_PSR_TDCV = ((1UL << 7) - 1) << 16,  // TDCV
	FDCAN1_PSR_PXE	= 1UL << 14,			   // PXE
	FDCAN1_PSR_REDL = 1UL << 13,			   // REDL
	FDCAN1_PSR_RBRS = 1UL << 12,			   // RBRS
	FDCAN1_PSR_RESI = 1UL << 11,			   // RESI
	FDCAN1_PSR_DLEC = ((1UL << 3) - 1) << 8,   // DLEC
	FDCAN1_PSR_BO	= 1UL << 7,				   // BO
	FDCAN1_PSR_EW	= 1UL << 6,				   // EW
	FDCAN1_PSR_EP	= 1UL << 5,				   // EP
	FDCAN1_PSR_ACT	= ((1UL << 2) - 1) << 3,   // ACT
	FDCAN1_PSR_LEC	= ((1UL << 3) - 1) << 0,   // LEC
};
inline void fdcan1_psr_set_tdcv(struct FDCAN1_Type *p, uint32_t val) {
	p->PSR = (p->PSR & ~FDCAN1_PSR_TDCV) | ((val << 16) & FDCAN1_PSR_TDCV);
}
inline void fdcan1_psr_set_dlec(struct FDCAN1_Type *p, uint32_t val) {
	p->PSR = (p->PSR & ~FDCAN1_PSR_DLEC) | ((val << 8) & FDCAN1_PSR_DLEC);
}
inline void fdcan1_psr_set_act(struct FDCAN1_Type *p, uint32_t val) {
	p->PSR = (p->PSR & ~FDCAN1_PSR_ACT) | ((val << 3) & FDCAN1_PSR_ACT);
}
inline void fdcan1_psr_set_lec(struct FDCAN1_Type *p, uint32_t val) {
	p->PSR = (p->PSR & ~FDCAN1_PSR_LEC) | ((val << 0) & FDCAN1_PSR_LEC);
}
inline uint32_t fdcan1_psr_get_tdcv(struct FDCAN1_Type *p) { return (p->PSR & FDCAN1_PSR_TDCV) >> 16; }
inline uint32_t fdcan1_psr_get_dlec(struct FDCAN1_Type *p) { return (p->PSR & FDCAN1_PSR_DLEC) >> 8; }
inline uint32_t fdcan1_psr_get_act(struct FDCAN1_Type *p) { return (p->PSR & FDCAN1_PSR_ACT) >> 3; }
inline uint32_t fdcan1_psr_get_lec(struct FDCAN1_Type *p) { return (p->PSR & FDCAN1_PSR_LEC) >> 0; }

// FDCAN1->TDCR FDCAN Transmitter Delay Compensation Register
enum {
	FDCAN1_TDCR_TDCO = ((1UL << 7) - 1) << 8,  // TDCO
	FDCAN1_TDCR_TDCF = ((1UL << 7) - 1) << 0,  // TDCF
};
inline void fdcan1_tdcr_set_tdco(struct FDCAN1_Type *p, uint32_t val) {
	p->TDCR = (p->TDCR & ~FDCAN1_TDCR_TDCO) | ((val << 8) & FDCAN1_TDCR_TDCO);
}
inline void fdcan1_tdcr_set_tdcf(struct FDCAN1_Type *p, uint32_t val) {
	p->TDCR = (p->TDCR & ~FDCAN1_TDCR_TDCF) | ((val << 0) & FDCAN1_TDCR_TDCF);
}
inline uint32_t fdcan1_tdcr_get_tdco(struct FDCAN1_Type *p) { return (p->TDCR & FDCAN1_TDCR_TDCO) >> 8; }
inline uint32_t fdcan1_tdcr_get_tdcf(struct FDCAN1_Type *p) { return (p->TDCR & FDCAN1_TDCR_TDCF) >> 0; }

// FDCAN1->IR The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host
// clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will
// clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on
// which interrupt line an interrupt is signaled.
enum {
	FDCAN1_IR_ARA  = 1UL << 23,	 // ARA
	FDCAN1_IR_PED  = 1UL << 22,	 // PED
	FDCAN1_IR_PEA  = 1UL << 21,	 // PEA
	FDCAN1_IR_WDI  = 1UL << 20,	 // WDI
	FDCAN1_IR_BO   = 1UL << 19,	 // BO
	FDCAN1_IR_EW   = 1UL << 18,	 // EW
	FDCAN1_IR_EP   = 1UL << 17,	 // EP
	FDCAN1_IR_ELO  = 1UL << 16,	 // ELO
	FDCAN1_IR_TOO  = 1UL << 15,	 // TOO
	FDCAN1_IR_MRAF = 1UL << 14,	 // MRAF
	FDCAN1_IR_TSW  = 1UL << 13,	 // TSW
	FDCAN1_IR_TEFL = 1UL << 12,	 // TEFL
	FDCAN1_IR_TEFF = 1UL << 11,	 // TEFF
	FDCAN1_IR_TEFN = 1UL << 10,	 // TEFN
	FDCAN1_IR_TFE  = 1UL << 9,	 // TFE
	FDCAN1_IR_TCF  = 1UL << 8,	 // TCF
	FDCAN1_IR_TC   = 1UL << 7,	 // TC
	FDCAN1_IR_HPM  = 1UL << 6,	 // HPM
	FDCAN1_IR_RF1L = 1UL << 5,	 // RF1L
	FDCAN1_IR_RF1F = 1UL << 4,	 // RF1F
	FDCAN1_IR_RF1N = 1UL << 3,	 // RF1N
	FDCAN1_IR_RF0L = 1UL << 2,	 // RF0L
	FDCAN1_IR_RF0F = 1UL << 1,	 // RF0F
	FDCAN1_IR_RF0N = 1UL << 0,	 // RF0N
};

// FDCAN1->IE The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be
// signaled on an interrupt line.
enum {
	FDCAN1_IE_ARAE	= 1UL << 23,  // ARAE
	FDCAN1_IE_PEDE	= 1UL << 22,  // PEDE
	FDCAN1_IE_PEAE	= 1UL << 21,  // PEAE
	FDCAN1_IE_WDIE	= 1UL << 20,  // WDIE
	FDCAN1_IE_BOE	= 1UL << 19,  // BOE
	FDCAN1_IE_EWE	= 1UL << 18,  // EWE
	FDCAN1_IE_EPE	= 1UL << 17,  // EPE
	FDCAN1_IE_ELOE	= 1UL << 16,  // ELOE
	FDCAN1_IE_TOOE	= 1UL << 15,  // TOOE
	FDCAN1_IE_MRAFE = 1UL << 14,  // MRAFE
	FDCAN1_IE_TSWE	= 1UL << 13,  // TSWE
	FDCAN1_IE_TEFLE = 1UL << 12,  // TEFLE
	FDCAN1_IE_TEFFE = 1UL << 11,  // TEFFE
	FDCAN1_IE_TEFNE = 1UL << 10,  // TEFNE
	FDCAN1_IE_TFEE	= 1UL << 9,	  // TFEE
	FDCAN1_IE_TCFE	= 1UL << 8,	  // TCFE
	FDCAN1_IE_TCE	= 1UL << 7,	  // TCE
	FDCAN1_IE_HPME	= 1UL << 6,	  // HPME
	FDCAN1_IE_RF1LE = 1UL << 5,	  // RF1LE
	FDCAN1_IE_RF1FE = 1UL << 4,	  // RF1FE
	FDCAN1_IE_RF1NE = 1UL << 3,	  // RF1NE
	FDCAN1_IE_RF0LE = 1UL << 2,	  // RF0LE
	FDCAN1_IE_RF0FE = 1UL << 1,	  // RF0FE
	FDCAN1_IE_RF0NE = 1UL << 0,	  // RF0NE
};

// FDCAN1->ILS The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the Interrupt
// Register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via
// ILE[EINT0] and ILE[EINT1].
enum {
	FDCAN1_ILS_PERR	   = 1UL << 6,	// PERR
	FDCAN1_ILS_BERR	   = 1UL << 5,	// BERR
	FDCAN1_ILS_MISC	   = 1UL << 4,	// MISC
	FDCAN1_ILS_TFERR   = 1UL << 3,	// TFERR
	FDCAN1_ILS_SMSG	   = 1UL << 2,	// SMSG
	FDCAN1_ILS_RXFIFO1 = 1UL << 1,	// RxFIFO1
	FDCAN1_ILS_RXFIFO0 = 1UL << 0,	// RxFIFO0
};

// FDCAN1->ILE Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
enum {
	FDCAN1_ILE_EINTX = ((1UL << 2) - 1) << 0,  // Merged EINT1
};
inline void fdcan1_ile_set_eintx(struct FDCAN1_Type *p, uint32_t val) {
	p->ILE = (p->ILE & ~FDCAN1_ILE_EINTX) | ((val << 0) & FDCAN1_ILE_EINTX);
}
inline uint32_t fdcan1_ile_get_eintx(struct FDCAN1_Type *p) { return (p->ILE & FDCAN1_ILE_EINTX) >> 0; }

// FDCAN1->RXGFC Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for standard and
// extended messages as described in Figure706: Standard Message ID filter path and Figure707: Extended Message ID filter path.
enum {
	FDCAN1_RXGFC_LSE  = ((1UL << 4) - 1) << 24,	 // LSE
	FDCAN1_RXGFC_LSS  = ((1UL << 5) - 1) << 16,	 // LSS
	FDCAN1_RXGFC_F0OM = 1UL << 9,				 // F0OM
	FDCAN1_RXGFC_F1OM = 1UL << 8,				 // F1OM
	FDCAN1_RXGFC_ANFS = ((1UL << 2) - 1) << 4,	 // ANFS
	FDCAN1_RXGFC_ANFE = ((1UL << 2) - 1) << 2,	 // ANFE
	FDCAN1_RXGFC_RRFS = 1UL << 1,				 // RRFS
	FDCAN1_RXGFC_RRFE = 1UL << 0,				 // RRFE
};
inline void fdcan1_rxgfc_set_lse(struct FDCAN1_Type *p, uint32_t val) {
	p->RXGFC = (p->RXGFC & ~FDCAN1_RXGFC_LSE) | ((val << 24) & FDCAN1_RXGFC_LSE);
}
inline void fdcan1_rxgfc_set_lss(struct FDCAN1_Type *p, uint32_t val) {
	p->RXGFC = (p->RXGFC & ~FDCAN1_RXGFC_LSS) | ((val << 16) & FDCAN1_RXGFC_LSS);
}
inline void fdcan1_rxgfc_set_anfs(struct FDCAN1_Type *p, uint32_t val) {
	p->RXGFC = (p->RXGFC & ~FDCAN1_RXGFC_ANFS) | ((val << 4) & FDCAN1_RXGFC_ANFS);
}
inline void fdcan1_rxgfc_set_anfe(struct FDCAN1_Type *p, uint32_t val) {
	p->RXGFC = (p->RXGFC & ~FDCAN1_RXGFC_ANFE) | ((val << 2) & FDCAN1_RXGFC_ANFE);
}
inline uint32_t fdcan1_rxgfc_get_lse(struct FDCAN1_Type *p) { return (p->RXGFC & FDCAN1_RXGFC_LSE) >> 24; }
inline uint32_t fdcan1_rxgfc_get_lss(struct FDCAN1_Type *p) { return (p->RXGFC & FDCAN1_RXGFC_LSS) >> 16; }
inline uint32_t fdcan1_rxgfc_get_anfs(struct FDCAN1_Type *p) { return (p->RXGFC & FDCAN1_RXGFC_ANFS) >> 4; }
inline uint32_t fdcan1_rxgfc_get_anfe(struct FDCAN1_Type *p) { return (p->RXGFC & FDCAN1_RXGFC_ANFE) >> 2; }

// FDCAN1->XIDAM FDCAN Extended ID and Mask Register
enum {
	FDCAN1_XIDAM_EIDM = ((1UL << 29) - 1) << 0,	 // EIDM
};
inline void fdcan1_xidam_set_eidm(struct FDCAN1_Type *p, uint32_t val) {
	p->XIDAM = (p->XIDAM & ~FDCAN1_XIDAM_EIDM) | ((val << 0) & FDCAN1_XIDAM_EIDM);
}
inline uint32_t fdcan1_xidam_get_eidm(struct FDCAN1_Type *p) { return (p->XIDAM & FDCAN1_XIDAM_EIDM) >> 0; }

// FDCAN1->HPMS This register is updated every time a Message ID filter element configured to generate a priority event match. This
// can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
enum {
	FDCAN1_HPMS_FLST = 1UL << 15,			   // FLST
	FDCAN1_HPMS_FIDX = ((1UL << 5) - 1) << 8,  // FIDX
	FDCAN1_HPMS_MSI	 = ((1UL << 2) - 1) << 6,  // MSI
	FDCAN1_HPMS_BIDX = ((1UL << 3) - 1) << 0,  // BIDX
};
inline uint32_t fdcan1_hpms_get_fidx(struct FDCAN1_Type *p) { return (p->HPMS & FDCAN1_HPMS_FIDX) >> 8; }
inline uint32_t fdcan1_hpms_get_msi(struct FDCAN1_Type *p) { return (p->HPMS & FDCAN1_HPMS_MSI) >> 6; }
inline uint32_t fdcan1_hpms_get_bidx(struct FDCAN1_Type *p) { return (p->HPMS & FDCAN1_HPMS_BIDX) >> 0; }

// FDCAN1->RXF0S FDCAN Rx FIFO 0 Status Register
enum {
	FDCAN1_RXF0S_RF0L = 1UL << 25,				 // RF0L
	FDCAN1_RXF0S_F0F  = 1UL << 24,				 // F0F
	FDCAN1_RXF0S_F0PI = ((1UL << 2) - 1) << 16,	 // F0PI
	FDCAN1_RXF0S_F0GI = ((1UL << 2) - 1) << 8,	 // F0GI
	FDCAN1_RXF0S_F0FL = ((1UL << 4) - 1) << 0,	 // F0FL
};
inline uint32_t fdcan1_rxf0s_get_f0pi(struct FDCAN1_Type *p) { return (p->RXF0S & FDCAN1_RXF0S_F0PI) >> 16; }
inline uint32_t fdcan1_rxf0s_get_f0gi(struct FDCAN1_Type *p) { return (p->RXF0S & FDCAN1_RXF0S_F0GI) >> 8; }
inline uint32_t fdcan1_rxf0s_get_f0fl(struct FDCAN1_Type *p) { return (p->RXF0S & FDCAN1_RXF0S_F0FL) >> 0; }

// FDCAN1->RXF0A CAN Rx FIFO 0 Acknowledge Register
enum {
	FDCAN1_RXF0A_F0AI = ((1UL << 3) - 1) << 0,	// F0AI
};
inline void fdcan1_rxf0a_set_f0ai(struct FDCAN1_Type *p, uint32_t val) {
	p->RXF0A = (p->RXF0A & ~FDCAN1_RXF0A_F0AI) | ((val << 0) & FDCAN1_RXF0A_F0AI);
}
inline uint32_t fdcan1_rxf0a_get_f0ai(struct FDCAN1_Type *p) { return (p->RXF0A & FDCAN1_RXF0A_F0AI) >> 0; }

// FDCAN1->RXF1S FDCAN Rx FIFO 1 Status Register
enum {
	FDCAN1_RXF1S_RF1L = 1UL << 25,				 // RF1L
	FDCAN1_RXF1S_F1F  = 1UL << 24,				 // F1F
	FDCAN1_RXF1S_F1PI = ((1UL << 2) - 1) << 16,	 // F1PI
	FDCAN1_RXF1S_F1GI = ((1UL << 2) - 1) << 8,	 // F1GI
	FDCAN1_RXF1S_F1FL = ((1UL << 4) - 1) << 0,	 // F1FL
};
inline uint32_t fdcan1_rxf1s_get_f1pi(struct FDCAN1_Type *p) { return (p->RXF1S & FDCAN1_RXF1S_F1PI) >> 16; }
inline uint32_t fdcan1_rxf1s_get_f1gi(struct FDCAN1_Type *p) { return (p->RXF1S & FDCAN1_RXF1S_F1GI) >> 8; }
inline uint32_t fdcan1_rxf1s_get_f1fl(struct FDCAN1_Type *p) { return (p->RXF1S & FDCAN1_RXF1S_F1FL) >> 0; }

// FDCAN1->RXF1A FDCAN Rx FIFO 1 Acknowledge Register
enum {
	FDCAN1_RXF1A_F1AI = ((1UL << 3) - 1) << 0,	// F1AI
};
inline void fdcan1_rxf1a_set_f1ai(struct FDCAN1_Type *p, uint32_t val) {
	p->RXF1A = (p->RXF1A & ~FDCAN1_RXF1A_F1AI) | ((val << 0) & FDCAN1_RXF1A_F1AI);
}
inline uint32_t fdcan1_rxf1a_get_f1ai(struct FDCAN1_Type *p) { return (p->RXF1A & FDCAN1_RXF1A_F1AI) >> 0; }

// FDCAN1->TXBC FDCAN Tx Buffer Configuration Register
enum {
	FDCAN1_TXBC_TFQM = 1UL << 24,  // TFQM
};

// FDCAN1->TXFQS The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the effect of
// Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
enum {
	FDCAN1_TXFQS_TFQF  = 1UL << 21,				  // TFQF
	FDCAN1_TXFQS_TFQPI = ((1UL << 2) - 1) << 16,  // TFQPI
	FDCAN1_TXFQS_TFGI  = ((1UL << 2) - 1) << 8,	  // TFGI
	FDCAN1_TXFQS_TFFL  = ((1UL << 3) - 1) << 0,	  // TFFL
};
inline uint32_t fdcan1_txfqs_get_tfqpi(struct FDCAN1_Type *p) { return (p->TXFQS & FDCAN1_TXFQS_TFQPI) >> 16; }
inline uint32_t fdcan1_txfqs_get_tfgi(struct FDCAN1_Type *p) { return (p->TXFQS & FDCAN1_TXFQS_TFGI) >> 8; }
inline uint32_t fdcan1_txfqs_get_tffl(struct FDCAN1_Type *p) { return (p->TXFQS & FDCAN1_TXFQS_TFFL) >> 0; }

// FDCAN1->TXBRP FDCAN Tx Buffer Request Pending Register
enum {
	FDCAN1_TXBRP_TRP = ((1UL << 3) - 1) << 0,  // TRP
};
inline uint32_t fdcan1_txbrp_get_trp(struct FDCAN1_Type *p) { return (p->TXBRP & FDCAN1_TXBRP_TRP) >> 0; }

// FDCAN1->TXBAR FDCAN Tx Buffer Add Request Register
enum {
	FDCAN1_TXBAR_AR = ((1UL << 3) - 1) << 0,  // AR
};
inline void fdcan1_txbar_set_ar(struct FDCAN1_Type *p, uint32_t val) {
	p->TXBAR = (p->TXBAR & ~FDCAN1_TXBAR_AR) | ((val << 0) & FDCAN1_TXBAR_AR);
}
inline uint32_t fdcan1_txbar_get_ar(struct FDCAN1_Type *p) { return (p->TXBAR & FDCAN1_TXBAR_AR) >> 0; }

// FDCAN1->TXBCR FDCAN Tx Buffer Cancellation Request Register
enum {
	FDCAN1_TXBCR_CR = ((1UL << 3) - 1) << 0,  // CR
};
inline void fdcan1_txbcr_set_cr(struct FDCAN1_Type *p, uint32_t val) {
	p->TXBCR = (p->TXBCR & ~FDCAN1_TXBCR_CR) | ((val << 0) & FDCAN1_TXBCR_CR);
}
inline uint32_t fdcan1_txbcr_get_cr(struct FDCAN1_Type *p) { return (p->TXBCR & FDCAN1_TXBCR_CR) >> 0; }

// FDCAN1->TXBTO FDCAN Tx Buffer Transmission Occurred Register
enum {
	FDCAN1_TXBTO_TO = ((1UL << 3) - 1) << 0,  // TO
};
inline uint32_t fdcan1_txbto_get_to(struct FDCAN1_Type *p) { return (p->TXBTO & FDCAN1_TXBTO_TO) >> 0; }

// FDCAN1->TXBCF FDCAN Tx Buffer Cancellation Finished Register
enum {
	FDCAN1_TXBCF_CF = ((1UL << 3) - 1) << 0,  // CF
};
inline uint32_t fdcan1_txbcf_get_cf(struct FDCAN1_Type *p) { return (p->TXBCF & FDCAN1_TXBCF_CF) >> 0; }

// FDCAN1->TXBTIE FDCAN Tx Buffer Transmission Interrupt Enable Register
enum {
	FDCAN1_TXBTIE_TIE = ((1UL << 3) - 1) << 0,	// TIE
};
inline void fdcan1_txbtie_set_tie(struct FDCAN1_Type *p, uint32_t val) {
	p->TXBTIE = (p->TXBTIE & ~FDCAN1_TXBTIE_TIE) | ((val << 0) & FDCAN1_TXBTIE_TIE);
}
inline uint32_t fdcan1_txbtie_get_tie(struct FDCAN1_Type *p) { return (p->TXBTIE & FDCAN1_TXBTIE_TIE) >> 0; }

// FDCAN1->TXBCIE FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
enum {
	FDCAN1_TXBCIE_CFIE = ((1UL << 3) - 1) << 0,	 // CFIE
};
inline void fdcan1_txbcie_set_cfie(struct FDCAN1_Type *p, uint32_t val) {
	p->TXBCIE = (p->TXBCIE & ~FDCAN1_TXBCIE_CFIE) | ((val << 0) & FDCAN1_TXBCIE_CFIE);
}
inline uint32_t fdcan1_txbcie_get_cfie(struct FDCAN1_Type *p) { return (p->TXBCIE & FDCAN1_TXBCIE_CFIE) >> 0; }

// FDCAN1->TXEFS FDCAN Tx Event FIFO Status Register
enum {
	FDCAN1_TXEFS_TEFL = 1UL << 25,				 // TEFL
	FDCAN1_TXEFS_EFF  = 1UL << 24,				 // EFF
	FDCAN1_TXEFS_EFPI = ((1UL << 2) - 1) << 16,	 // EFPI
	FDCAN1_TXEFS_EFGI = ((1UL << 2) - 1) << 8,	 // EFGI
	FDCAN1_TXEFS_EFFL = ((1UL << 3) - 1) << 0,	 // EFFL
};
inline uint32_t fdcan1_txefs_get_efpi(struct FDCAN1_Type *p) { return (p->TXEFS & FDCAN1_TXEFS_EFPI) >> 16; }
inline uint32_t fdcan1_txefs_get_efgi(struct FDCAN1_Type *p) { return (p->TXEFS & FDCAN1_TXEFS_EFGI) >> 8; }
inline uint32_t fdcan1_txefs_get_effl(struct FDCAN1_Type *p) { return (p->TXEFS & FDCAN1_TXEFS_EFFL) >> 0; }

// FDCAN1->TXEFA FDCAN Tx Event FIFO Acknowledge Register
enum {
	FDCAN1_TXEFA_EFAI = ((1UL << 2) - 1) << 0,	// EFAI
};
inline void fdcan1_txefa_set_efai(struct FDCAN1_Type *p, uint32_t val) {
	p->TXEFA = (p->TXEFA & ~FDCAN1_TXEFA_EFAI) | ((val << 0) & FDCAN1_TXEFA_EFAI);
}
inline uint32_t fdcan1_txefa_get_efai(struct FDCAN1_Type *p) { return (p->TXEFA & FDCAN1_TXEFA_EFAI) >> 0; }

// FDCAN1->CKDIV FDCAN CFG clock divider register
enum {
	FDCAN1_CKDIV_PDIV =
			((1UL << 4) - 1) << 0,	// input clock divider. the APB clock could be divided prior to be used by the CAN sub
};
inline void fdcan1_ckdiv_set_pdiv(struct FDCAN1_Type *p, uint32_t val) {
	p->CKDIV = (p->CKDIV & ~FDCAN1_CKDIV_PDIV) | ((val << 0) & FDCAN1_CKDIV_PDIV);
}
inline uint32_t fdcan1_ckdiv_get_pdiv(struct FDCAN1_Type *p) { return (p->CKDIV & FDCAN1_CKDIV_PDIV) >> 0; }

struct FDCANs_Message_RAM_Type {
	__IO uint32_t DUM;	// @0 Dummy definition
};

/* Flash */
struct FLASH_Type {
	__IO uint32_t ACR;			  // @0 Access control register
	__O uint32_t  PDKEYR;		  // @4 Power down key register
	__O uint32_t  KEYR;			  // @8 Flash key register
	__O uint32_t  OPTKEYR;		  // @12 Option byte key register
	__IO uint32_t SR;			  // @16 Status register
	__IO uint32_t CR;			  // @20 Flash control register
	__IO uint32_t ECCR;			  // @24 Flash ECC register
	uint8_t		  RESERVED0[4];	  // @28
	__IO uint32_t OPTR;			  // @32 Flash option register
	__IO uint16_t PCROP1SR;		  // @36 Flash Bank 1 PCROP Start address register
	uint8_t		  RESERVED1[2];	  // @38
	__IO uint32_t PCROP1ER;		  // @40 Flash Bank 1 PCROP End address register
	__IO uint32_t WRP1AR;		  // @44 Flash Bank 1 WRP area A address register
	__IO uint32_t WRP1BR;		  // @48 Flash Bank 1 WRP area B address register
	uint8_t		  RESERVED2[60];  // @52
	__IO uint32_t SEC1R;		  // @112 securable area bank1 register
};

// FLASH->ACR Access control register
enum {
	FLASH_ACR_DBG_SWEN = 1UL << 18,				 // Debug software enable
	FLASH_ACR_SLEEP_PD = 1UL << 14,				 // Flash Power-down mode during Low-power sleep mode
	FLASH_ACR_RUN_PD   = 1UL << 13,				 // Flash Power-down mode during Low-power run mode
	FLASH_ACR_DCRST	   = 1UL << 12,				 // Data cache reset
	FLASH_ACR_ICRST	   = 1UL << 11,				 // Instruction cache reset
	FLASH_ACR_DCEN	   = 1UL << 10,				 // Data cache enable
	FLASH_ACR_ICEN	   = 1UL << 9,				 // Instruction cache enable
	FLASH_ACR_PRFTEN   = 1UL << 8,				 // Prefetch enable
	FLASH_ACR_LATENCY  = ((1UL << 4) - 1) << 0,	 // Latency
};
inline void flash_acr_set_latency(struct FLASH_Type *p, uint32_t val) {
	p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val << 0) & FLASH_ACR_LATENCY);
}
inline uint32_t flash_acr_get_latency(struct FLASH_Type *p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY	 = 1UL << 16,  // Busy
	FLASH_SR_OPTVERR = 1UL << 15,  // Option validity error
	FLASH_SR_RDERR	 = 1UL << 14,  // PCROP read error
	FLASH_SR_FASTERR = 1UL << 9,   // Fast programming error
	FLASH_SR_MISERR	 = 1UL << 8,   // Fast programming data miss error
	FLASH_SR_PGSERR	 = 1UL << 7,   // Programming sequence error
	FLASH_SR_SIZERR	 = 1UL << 6,   // Size error
	FLASH_SR_PGAERR	 = 1UL << 5,   // Programming alignment error
	FLASH_SR_WRPERR	 = 1UL << 4,   // Write protected error
	FLASH_SR_PROGERR = 1UL << 3,   // Programming error
	FLASH_SR_OPERR	 = 1UL << 1,   // Operation error
	FLASH_SR_EOP	 = 1UL << 0,   // End of operation
};

// FLASH->CR Flash control register
enum {
	FLASH_CR_LOCK		= 1UL << 31,			  // FLASH_CR Lock
	FLASH_CR_OPTLOCK	= 1UL << 30,			  // Options Lock
	FLASH_CR_SEC_PROT1	= 1UL << 28,			  // SEC_PROT1
	FLASH_CR_OBL_LAUNCH = 1UL << 27,			  // Force the option byte loading
	FLASH_CR_RDERRIE	= 1UL << 26,			  // PCROP read error interrupt enable
	FLASH_CR_ERRIE		= 1UL << 25,			  // Error interrupt enable
	FLASH_CR_EOPIE		= 1UL << 24,			  // End of operation interrupt enable
	FLASH_CR_FSTPG		= 1UL << 18,			  // Fast programming
	FLASH_CR_OPTSTRT	= 1UL << 17,			  // Options modification start
	FLASH_CR_STRT		= 1UL << 16,			  // Start
	FLASH_CR_PNB		= ((1UL << 7) - 1) << 3,  // Page number
	FLASH_CR_MER1		= 1UL << 2,				  // Bank 1 Mass erase
	FLASH_CR_PER		= 1UL << 1,				  // Page erase
	FLASH_CR_PG			= 1UL << 0,				  // Programming
};
inline void flash_cr_set_pnb(struct FLASH_Type *p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_PNB) | ((val << 3) & FLASH_CR_PNB); }
inline uint32_t flash_cr_get_pnb(struct FLASH_Type *p) { return (p->CR & FLASH_CR_PNB) >> 3; }

// FLASH->ECCR Flash ECC register
enum {
	FLASH_ECCR_ECCD		= 1UL << 31,			   // ECC detection
	FLASH_ECCR_ECCC		= 1UL << 30,			   // ECC correction
	FLASH_ECCR_ECCD2	= 1UL << 29,			   // ECC2 detection
	FLASH_ECCR_ECCC2	= 1UL << 28,			   // ECC correction
	FLASH_ECCR_ECCIE	= 1UL << 24,			   // ECCIE
	FLASH_ECCR_SYSF_ECC = 1UL << 22,			   // SYSF_ECC
	FLASH_ECCR_BK_ECC	= 1UL << 21,			   // BK_ECC
	FLASH_ECCR_ADDR_ECC = ((1UL << 19) - 1) << 0,  // ECC fail address
};
inline void flash_eccr_set_addr_ecc(struct FLASH_Type *p, uint32_t val) {
	p->ECCR = (p->ECCR & ~FLASH_ECCR_ADDR_ECC) | ((val << 0) & FLASH_ECCR_ADDR_ECC);
}
inline uint32_t flash_eccr_get_addr_ecc(struct FLASH_Type *p) { return (p->ECCR & FLASH_ECCR_ADDR_ECC) >> 0; }

// FLASH->OPTR Flash option register
enum {
	FLASH_OPTR_IRHEN	   = 1UL << 30,				  // IRHEN
	FLASH_OPTR_NRST_MODE   = ((1UL << 2) - 1) << 28,  // NRST_MODE
	FLASH_OPTR_NBOOT0	   = 1UL << 27,				  // nBOOT0
	FLASH_OPTR_NSWBOOT0	   = 1UL << 26,				  // nSWBOOT0
	FLASH_OPTR_CCMSRAM_RST = 1UL << 25,				  // CCM SRAM Erase when system reset
	FLASH_OPTR_SRAM2_PE	   = 1UL << 24,				  // SRAM2 parity check enable
	FLASH_OPTR_NBOOT1	   = 1UL << 23,				  // Boot configuration
	FLASH_OPTR_DBANK	   = 1UL << 22,				  // DBANK
	FLASH_OPTR_BFB2		   = 1UL << 20,				  // Dual-bank boot
	FLASH_OPTR_WWDG_SW	   = 1UL << 19,				  // Window watchdog selection
	FLASH_OPTR_IWDG_STDBY  = 1UL << 18,				  // Independent watchdog counter freeze in Standby mode
	FLASH_OPTR_IWDG_STOP   = 1UL << 17,				  // Independent watchdog counter freeze in Stop mode
	FLASH_OPTR_IWDG_SW	   = 1UL << 16,				  // Independent watchdog selection
	FLASH_OPTR_NRST_SHDW   = 1UL << 14,				  // nRST_SHDW
	FLASH_OPTR_NRST_STDBY  = 1UL << 13,				  // nRST_STDBY
	FLASH_OPTR_NRST_STOP   = 1UL << 12,				  // nRST_STOP
	FLASH_OPTR_BOR_LEV	   = ((1UL << 3) - 1) << 8,	  // BOR reset Level
	FLASH_OPTR_RDP		   = ((1UL << 8) - 1) << 0,	  // Read protection level
};
inline void flash_optr_set_nrst_mode(struct FLASH_Type *p, uint32_t val) {
	p->OPTR = (p->OPTR & ~FLASH_OPTR_NRST_MODE) | ((val << 28) & FLASH_OPTR_NRST_MODE);
}
inline void flash_optr_set_bor_lev(struct FLASH_Type *p, uint32_t val) {
	p->OPTR = (p->OPTR & ~FLASH_OPTR_BOR_LEV) | ((val << 8) & FLASH_OPTR_BOR_LEV);
}
inline void flash_optr_set_rdp(struct FLASH_Type *p, uint32_t val) {
	p->OPTR = (p->OPTR & ~FLASH_OPTR_RDP) | ((val << 0) & FLASH_OPTR_RDP);
}
inline uint32_t flash_optr_get_nrst_mode(struct FLASH_Type *p) { return (p->OPTR & FLASH_OPTR_NRST_MODE) >> 28; }
inline uint32_t flash_optr_get_bor_lev(struct FLASH_Type *p) { return (p->OPTR & FLASH_OPTR_BOR_LEV) >> 8; }
inline uint32_t flash_optr_get_rdp(struct FLASH_Type *p) { return (p->OPTR & FLASH_OPTR_RDP) >> 0; }

// FLASH->PCROP1SR Flash Bank 1 PCROP Start address register
enum {
	FLASH_PCROP1SR_PCROP1_STRT = ((1UL << 15) - 1) << 0,  // Bank 1 PCROP area start offset
};
inline void flash_pcrop1sr_set_pcrop1_strt(struct FLASH_Type *p, uint32_t val) {
	p->PCROP1SR = (p->PCROP1SR & ~FLASH_PCROP1SR_PCROP1_STRT) | ((val << 0) & FLASH_PCROP1SR_PCROP1_STRT);
}
inline uint32_t flash_pcrop1sr_get_pcrop1_strt(struct FLASH_Type *p) { return (p->PCROP1SR & FLASH_PCROP1SR_PCROP1_STRT) >> 0; }

// FLASH->PCROP1ER Flash Bank 1 PCROP End address register
enum {
	FLASH_PCROP1ER_PCROP_RDP  = 1UL << 31,				 // PCROP area preserved when RDP level decreased
	FLASH_PCROP1ER_PCROP1_END = ((1UL << 15) - 1) << 0,	 // Bank 1 PCROP area end offset
};
inline void flash_pcrop1er_set_pcrop1_end(struct FLASH_Type *p, uint32_t val) {
	p->PCROP1ER = (p->PCROP1ER & ~FLASH_PCROP1ER_PCROP1_END) | ((val << 0) & FLASH_PCROP1ER_PCROP1_END);
}
inline uint32_t flash_pcrop1er_get_pcrop1_end(struct FLASH_Type *p) { return (p->PCROP1ER & FLASH_PCROP1ER_PCROP1_END) >> 0; }

// FLASH->WRP1AR Flash Bank 1 WRP area A address register
enum {
	FLASH_WRP1AR_WRP1A_END	= ((1UL << 7) - 1) << 16,  // Bank 1 WRP first area A end offset
	FLASH_WRP1AR_WRP1A_STRT = ((1UL << 7) - 1) << 0,   // Bank 1 WRP first area start offset
};
inline void flash_wrp1ar_set_wrp1a_end(struct FLASH_Type *p, uint32_t val) {
	p->WRP1AR = (p->WRP1AR & ~FLASH_WRP1AR_WRP1A_END) | ((val << 16) & FLASH_WRP1AR_WRP1A_END);
}
inline void flash_wrp1ar_set_wrp1a_strt(struct FLASH_Type *p, uint32_t val) {
	p->WRP1AR = (p->WRP1AR & ~FLASH_WRP1AR_WRP1A_STRT) | ((val << 0) & FLASH_WRP1AR_WRP1A_STRT);
}
inline uint32_t flash_wrp1ar_get_wrp1a_end(struct FLASH_Type *p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_END) >> 16; }
inline uint32_t flash_wrp1ar_get_wrp1a_strt(struct FLASH_Type *p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_STRT) >> 0; }

// FLASH->WRP1BR Flash Bank 1 WRP area B address register
enum {
	FLASH_WRP1BR_WRP1B_END	= ((1UL << 7) - 1) << 16,  // Bank 1 WRP second area B start offset
	FLASH_WRP1BR_WRP1B_STRT = ((1UL << 7) - 1) << 0,   // Bank 1 WRP second area B end offset
};
inline void flash_wrp1br_set_wrp1b_end(struct FLASH_Type *p, uint32_t val) {
	p->WRP1BR = (p->WRP1BR & ~FLASH_WRP1BR_WRP1B_END) | ((val << 16) & FLASH_WRP1BR_WRP1B_END);
}
inline void flash_wrp1br_set_wrp1b_strt(struct FLASH_Type *p, uint32_t val) {
	p->WRP1BR = (p->WRP1BR & ~FLASH_WRP1BR_WRP1B_STRT) | ((val << 0) & FLASH_WRP1BR_WRP1B_STRT);
}
inline uint32_t flash_wrp1br_get_wrp1b_end(struct FLASH_Type *p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_END) >> 16; }
inline uint32_t flash_wrp1br_get_wrp1b_strt(struct FLASH_Type *p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_STRT) >> 0; }

// FLASH->SEC1R securable area bank1 register
enum {
	FLASH_SEC1R_BOOT_LOCK = 1UL << 16,				// BOOT_LOCK
	FLASH_SEC1R_SEC_SIZE1 = ((1UL << 8) - 1) << 0,	// SEC_SIZE1
};
inline void flash_sec1r_set_sec_size1(struct FLASH_Type *p, uint32_t val) {
	p->SEC1R = (p->SEC1R & ~FLASH_SEC1R_SEC_SIZE1) | ((val << 0) & FLASH_SEC1R_SEC_SIZE1);
}
inline uint32_t flash_sec1r_get_sec_size1(struct FLASH_Type *p) { return (p->SEC1R & FLASH_SEC1R_SEC_SIZE1) >> 0; }

/* Filter Math Accelerator */
struct FMAC_Type {
	__IO uint32_t X1BUFCFG;		 // @0 FMAC X1 Buffer Configuration register
	__IO uint16_t X2BUFCFG;		 // @4 FMAC X2 Buffer Configuration register
	uint8_t		  RESERVED0[2];	 // @6
	__IO uint32_t YBUFCFG;		 // @8 FMAC Y Buffer Configuration register
	__IO uint32_t PARAM;		 // @12 FMAC Parameter register
	__IO uint32_t CR;			 // @16 FMAC Control register
	__I uint16_t  SR;			 // @20 FMAC Status register
	uint8_t		  RESERVED1[2];	 // @22
	__O uint16_t  WDATA;		 // @24 FMAC Write Data register
	uint8_t		  RESERVED2[2];	 // @26
	__I uint16_t  RDATA;		 // @28 FMAC Read Data register
};

// FMAC->X1BUFCFG FMAC X1 Buffer Configuration register
enum {
	FMAC_X1BUFCFG_FULL_WM	  = ((1UL << 2) - 1) << 24,	 // FULL_WM
	FMAC_X1BUFCFG_X1_BUF_SIZE = ((1UL << 8) - 1) << 8,	 // X1_BUF_SIZE
	FMAC_X1BUFCFG_X1_BASE	  = ((1UL << 8) - 1) << 0,	 // X1_BASE
};
inline void fmac_x1bufcfg_set_full_wm(struct FMAC_Type *p, uint32_t val) {
	p->X1BUFCFG = (p->X1BUFCFG & ~FMAC_X1BUFCFG_FULL_WM) | ((val << 24) & FMAC_X1BUFCFG_FULL_WM);
}
inline void fmac_x1bufcfg_set_x1_buf_size(struct FMAC_Type *p, uint32_t val) {
	p->X1BUFCFG = (p->X1BUFCFG & ~FMAC_X1BUFCFG_X1_BUF_SIZE) | ((val << 8) & FMAC_X1BUFCFG_X1_BUF_SIZE);
}
inline void fmac_x1bufcfg_set_x1_base(struct FMAC_Type *p, uint32_t val) {
	p->X1BUFCFG = (p->X1BUFCFG & ~FMAC_X1BUFCFG_X1_BASE) | ((val << 0) & FMAC_X1BUFCFG_X1_BASE);
}
inline uint32_t fmac_x1bufcfg_get_full_wm(struct FMAC_Type *p) { return (p->X1BUFCFG & FMAC_X1BUFCFG_FULL_WM) >> 24; }
inline uint32_t fmac_x1bufcfg_get_x1_buf_size(struct FMAC_Type *p) { return (p->X1BUFCFG & FMAC_X1BUFCFG_X1_BUF_SIZE) >> 8; }
inline uint32_t fmac_x1bufcfg_get_x1_base(struct FMAC_Type *p) { return (p->X1BUFCFG & FMAC_X1BUFCFG_X1_BASE) >> 0; }

// FMAC->X2BUFCFG FMAC X2 Buffer Configuration register
enum {
	FMAC_X2BUFCFG_X2_BUF_SIZE = ((1UL << 8) - 1) << 8,	// X1_BUF_SIZE
	FMAC_X2BUFCFG_X2_BASE	  = ((1UL << 8) - 1) << 0,	// X1_BASE
};
inline void fmac_x2bufcfg_set_x2_buf_size(struct FMAC_Type *p, uint32_t val) {
	p->X2BUFCFG = (p->X2BUFCFG & ~FMAC_X2BUFCFG_X2_BUF_SIZE) | ((val << 8) & FMAC_X2BUFCFG_X2_BUF_SIZE);
}
inline void fmac_x2bufcfg_set_x2_base(struct FMAC_Type *p, uint32_t val) {
	p->X2BUFCFG = (p->X2BUFCFG & ~FMAC_X2BUFCFG_X2_BASE) | ((val << 0) & FMAC_X2BUFCFG_X2_BASE);
}
inline uint32_t fmac_x2bufcfg_get_x2_buf_size(struct FMAC_Type *p) { return (p->X2BUFCFG & FMAC_X2BUFCFG_X2_BUF_SIZE) >> 8; }
inline uint32_t fmac_x2bufcfg_get_x2_base(struct FMAC_Type *p) { return (p->X2BUFCFG & FMAC_X2BUFCFG_X2_BASE) >> 0; }

// FMAC->YBUFCFG FMAC Y Buffer Configuration register
enum {
	FMAC_YBUFCFG_EMPTY_WM	= ((1UL << 2) - 1) << 24,  // EMPTY_WM
	FMAC_YBUFCFG_Y_BUF_SIZE = ((1UL << 8) - 1) << 8,   // X1_BUF_SIZE
	FMAC_YBUFCFG_Y_BASE		= ((1UL << 8) - 1) << 0,   // X1_BASE
};
inline void fmac_ybufcfg_set_empty_wm(struct FMAC_Type *p, uint32_t val) {
	p->YBUFCFG = (p->YBUFCFG & ~FMAC_YBUFCFG_EMPTY_WM) | ((val << 24) & FMAC_YBUFCFG_EMPTY_WM);
}
inline void fmac_ybufcfg_set_y_buf_size(struct FMAC_Type *p, uint32_t val) {
	p->YBUFCFG = (p->YBUFCFG & ~FMAC_YBUFCFG_Y_BUF_SIZE) | ((val << 8) & FMAC_YBUFCFG_Y_BUF_SIZE);
}
inline void fmac_ybufcfg_set_y_base(struct FMAC_Type *p, uint32_t val) {
	p->YBUFCFG = (p->YBUFCFG & ~FMAC_YBUFCFG_Y_BASE) | ((val << 0) & FMAC_YBUFCFG_Y_BASE);
}
inline uint32_t fmac_ybufcfg_get_empty_wm(struct FMAC_Type *p) { return (p->YBUFCFG & FMAC_YBUFCFG_EMPTY_WM) >> 24; }
inline uint32_t fmac_ybufcfg_get_y_buf_size(struct FMAC_Type *p) { return (p->YBUFCFG & FMAC_YBUFCFG_Y_BUF_SIZE) >> 8; }
inline uint32_t fmac_ybufcfg_get_y_base(struct FMAC_Type *p) { return (p->YBUFCFG & FMAC_YBUFCFG_Y_BASE) >> 0; }

// FMAC->PARAM FMAC Parameter register
enum {
	FMAC_PARAM_START = 1UL << 31,				// START
	FMAC_PARAM_FUNC	 = ((1UL << 7) - 1) << 24,	// FUNC
	FMAC_PARAM_R	 = ((1UL << 8) - 1) << 16,	// R
	FMAC_PARAM_Q	 = ((1UL << 8) - 1) << 8,	// Q
	FMAC_PARAM_P	 = ((1UL << 8) - 1) << 0,	// P
};
inline void fmac_param_set_func(struct FMAC_Type *p, uint32_t val) {
	p->PARAM = (p->PARAM & ~FMAC_PARAM_FUNC) | ((val << 24) & FMAC_PARAM_FUNC);
}
inline void fmac_param_set_r(struct FMAC_Type *p, uint32_t val) {
	p->PARAM = (p->PARAM & ~FMAC_PARAM_R) | ((val << 16) & FMAC_PARAM_R);
}
inline void fmac_param_set_q(struct FMAC_Type *p, uint32_t val) {
	p->PARAM = (p->PARAM & ~FMAC_PARAM_Q) | ((val << 8) & FMAC_PARAM_Q);
}
inline void fmac_param_set_p(struct FMAC_Type *p, uint32_t val) {
	p->PARAM = (p->PARAM & ~FMAC_PARAM_P) | ((val << 0) & FMAC_PARAM_P);
}
inline uint32_t fmac_param_get_func(struct FMAC_Type *p) { return (p->PARAM & FMAC_PARAM_FUNC) >> 24; }
inline uint32_t fmac_param_get_r(struct FMAC_Type *p) { return (p->PARAM & FMAC_PARAM_R) >> 16; }
inline uint32_t fmac_param_get_q(struct FMAC_Type *p) { return (p->PARAM & FMAC_PARAM_Q) >> 8; }
inline uint32_t fmac_param_get_p(struct FMAC_Type *p) { return (p->PARAM & FMAC_PARAM_P) >> 0; }

// FMAC->CR FMAC Control register
enum {
	FMAC_CR_RESET	= 1UL << 16,  // RESET
	FMAC_CR_CLIPEN	= 1UL << 15,  // CLIPEN
	FMAC_CR_DMAWEN	= 1UL << 9,	  // DMAWEN
	FMAC_CR_DMAREN	= 1UL << 8,	  // DMAREN
	FMAC_CR_SATIEN	= 1UL << 4,	  // SATIEN
	FMAC_CR_UNFLIEN = 1UL << 3,	  // UNFLIEN
	FMAC_CR_OVFLIEN = 1UL << 2,	  // OVFLIEN
	FMAC_CR_WIEN	= 1UL << 1,	  // WIEN
	FMAC_CR_RIEN	= 1UL << 0,	  // RIEN
};

// FMAC->SR FMAC Status register
enum {
	FMAC_SR_SAT	   = 1UL << 10,	 // SAT
	FMAC_SR_UNFL   = 1UL << 9,	 // UNFL
	FMAC_SR_OVFL   = 1UL << 8,	 // OVFL
	FMAC_SR_X1FULL = 1UL << 1,	 // X1FULL
	FMAC_SR_YEMPTY = 1UL << 0,	 // YEMPTY
};

/* Flexible memory controller */
struct FMC_Type {
	__IO uint32_t BCR1;			   // @0 SRAM/NOR-Flash chip-select control register 1
	__IO uint32_t BTR1;			   // @4 SRAM/NOR-Flash chip-select timing register 1
	__IO uint32_t BCR2;			   // @8 SRAM/NOR-Flash chip-select control register 2
	__IO uint32_t BTR2;			   // @12 SRAM/NOR-Flash chip-select timing register 2
	__IO uint32_t BCR3;			   // @16 SRAM/NOR-Flash chip-select control register 3
	__IO uint32_t BTR3;			   // @20 SRAM/NOR-Flash chip-select timing register 3
	__IO uint32_t BCR4;			   // @24 SRAM/NOR-Flash chip-select control register 4
	__IO uint32_t BTR4;			   // @28 SRAM/NOR-Flash chip-select timing register 4
	__IO uint32_t PCSCNTR;		   // @32 PSRAM chip select counter register
	uint8_t		  RESERVED0[92];   // @36
	__IO uint32_t PCR;			   // @128 PC Card/NAND Flash control register 3
	__IO uint8_t  SR;			   // @132 FIFO status and interrupt register 3
	uint8_t		  RESERVED1[3];	   // @133
	__IO uint32_t PMEM;			   // @136 Common memory space timing register 3
	__IO uint32_t PATT;			   // @140 Attribute memory space timing register 3
	uint8_t		  RESERVED2[4];	   // @144
	__I uint32_t  ECCR;			   // @148 ECC result register 3
	uint8_t		  RESERVED3[108];  // @152
	__IO uint32_t BWTR1;		   // @260 SRAM/NOR-Flash write timing registers 1
	uint8_t		  RESERVED4[4];	   // @264
	__IO uint32_t BWTR2;		   // @268 SRAM/NOR-Flash write timing registers 2
	uint8_t		  RESERVED5[4];	   // @272
	__IO uint32_t BWTR3;		   // @276 SRAM/NOR-Flash write timing registers 3
	uint8_t		  RESERVED6[4];	   // @280
	__IO uint32_t BWTR4;		   // @284 SRAM/NOR-Flash write timing registers 4
};

// FMC->BCR1 SRAM/NOR-Flash chip-select control register 1
enum {
	FMC_BCR1_NBLSET	   = ((1UL << 2) - 1) << 22,  // NBLSET
	FMC_BCR1_WFDIS	   = 1UL << 21,				  // WFDIS
	FMC_BCR1_CCLKEN	   = 1UL << 20,				  // CCLKEN
	FMC_BCR1_CBURSTRW  = 1UL << 19,				  // CBURSTRW
	FMC_BCR1_CPSIZE	   = ((1UL << 3) - 1) << 16,  // CPSIZE
	FMC_BCR1_ASYNCWAIT = 1UL << 15,				  // ASYNCWAIT
	FMC_BCR1_EXTMOD	   = 1UL << 14,				  // EXTMOD
	FMC_BCR1_WAITEN	   = 1UL << 13,				  // WAITEN
	FMC_BCR1_WREN	   = 1UL << 12,				  // WREN
	FMC_BCR1_WAITCFG   = 1UL << 11,				  // WAITCFG
	FMC_BCR1_WAITPOL   = 1UL << 9,				  // WAITPOL
	FMC_BCR1_BURSTEN   = 1UL << 8,				  // BURSTEN
	FMC_BCR1_FACCEN	   = 1UL << 6,				  // FACCEN
	FMC_BCR1_MWID	   = ((1UL << 2) - 1) << 4,	  // MWID
	FMC_BCR1_MTYP	   = ((1UL << 2) - 1) << 2,	  // MTYP
	FMC_BCR1_MUXEN	   = 1UL << 1,				  // MUXEN
	FMC_BCR1_MBKEN	   = 1UL << 0,				  // MBKEN
};
inline void fmc_bcr1_set_nblset(struct FMC_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~FMC_BCR1_NBLSET) | ((val << 22) & FMC_BCR1_NBLSET);
}
inline void fmc_bcr1_set_cpsize(struct FMC_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~FMC_BCR1_CPSIZE) | ((val << 16) & FMC_BCR1_CPSIZE);
}
inline void fmc_bcr1_set_mwid(struct FMC_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~FMC_BCR1_MWID) | ((val << 4) & FMC_BCR1_MWID);
}
inline void fmc_bcr1_set_mtyp(struct FMC_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~FMC_BCR1_MTYP) | ((val << 2) & FMC_BCR1_MTYP);
}
inline uint32_t fmc_bcr1_get_nblset(struct FMC_Type *p) { return (p->BCR1 & FMC_BCR1_NBLSET) >> 22; }
inline uint32_t fmc_bcr1_get_cpsize(struct FMC_Type *p) { return (p->BCR1 & FMC_BCR1_CPSIZE) >> 16; }
inline uint32_t fmc_bcr1_get_mwid(struct FMC_Type *p) { return (p->BCR1 & FMC_BCR1_MWID) >> 4; }
inline uint32_t fmc_bcr1_get_mtyp(struct FMC_Type *p) { return (p->BCR1 & FMC_BCR1_MTYP) >> 2; }

// FMC->BTR1 SRAM/NOR-Flash chip-select timing register 1
enum {
	FMC_BTR1_DATAHLD = ((1UL << 2) - 1) << 30,	// DATAHLD
	FMC_BTR1_ACCMOD	 = ((1UL << 2) - 1) << 28,	// ACCMOD
	FMC_BTR1_DATLAT	 = ((1UL << 4) - 1) << 24,	// DATLAT
	FMC_BTR1_CLKDIV	 = ((1UL << 4) - 1) << 20,	// CLKDIV
	FMC_BTR1_BUSTURN = ((1UL << 4) - 1) << 16,	// BUSTURN
	FMC_BTR1_DATAST	 = ((1UL << 8) - 1) << 8,	// DATAST
	FMC_BTR1_ADDHLD	 = ((1UL << 4) - 1) << 4,	// ADDHLD
	FMC_BTR1_ADDSET	 = ((1UL << 4) - 1) << 0,	// ADDSET
};
inline void fmc_btr1_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATAHLD) | ((val << 30) & FMC_BTR1_DATAHLD);
}
inline void fmc_btr1_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_ACCMOD) | ((val << 28) & FMC_BTR1_ACCMOD);
}
inline void fmc_btr1_set_datlat(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATLAT) | ((val << 24) & FMC_BTR1_DATLAT);
}
inline void fmc_btr1_set_clkdiv(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_CLKDIV) | ((val << 20) & FMC_BTR1_CLKDIV);
}
inline void fmc_btr1_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_BUSTURN) | ((val << 16) & FMC_BTR1_BUSTURN);
}
inline void fmc_btr1_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_DATAST) | ((val << 8) & FMC_BTR1_DATAST);
}
inline void fmc_btr1_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_ADDHLD) | ((val << 4) & FMC_BTR1_ADDHLD);
}
inline void fmc_btr1_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BTR1 = (p->BTR1 & ~FMC_BTR1_ADDSET) | ((val << 0) & FMC_BTR1_ADDSET);
}
inline uint32_t fmc_btr1_get_datahld(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_DATAHLD) >> 30; }
inline uint32_t fmc_btr1_get_accmod(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_ACCMOD) >> 28; }
inline uint32_t fmc_btr1_get_datlat(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_DATLAT) >> 24; }
inline uint32_t fmc_btr1_get_clkdiv(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_CLKDIV) >> 20; }
inline uint32_t fmc_btr1_get_busturn(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_BUSTURN) >> 16; }
inline uint32_t fmc_btr1_get_datast(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_DATAST) >> 8; }
inline uint32_t fmc_btr1_get_addhld(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_ADDHLD) >> 4; }
inline uint32_t fmc_btr1_get_addset(struct FMC_Type *p) { return (p->BTR1 & FMC_BTR1_ADDSET) >> 0; }

// FMC->BCR2 SRAM/NOR-Flash chip-select control register 2
enum {
	FMC_BCR2_NBLSET	   = ((1UL << 2) - 1) << 22,  // NBLSET
	FMC_BCR2_WFDIS	   = 1UL << 21,				  // WFDIS
	FMC_BCR2_CCLKEN	   = 1UL << 20,				  // CCLKEN
	FMC_BCR2_CBURSTRW  = 1UL << 19,				  // CBURSTRW
	FMC_BCR2_CPSIZE	   = ((1UL << 3) - 1) << 16,  // CPSIZE
	FMC_BCR2_ASYNCWAIT = 1UL << 15,				  // ASYNCWAIT
	FMC_BCR2_EXTMOD	   = 1UL << 14,				  // EXTMOD
	FMC_BCR2_WAITEN	   = 1UL << 13,				  // WAITEN
	FMC_BCR2_WREN	   = 1UL << 12,				  // WREN
	FMC_BCR2_WAITCFG   = 1UL << 11,				  // WAITCFG
	FMC_BCR2_WAITPOL   = 1UL << 9,				  // WAITPOL
	FMC_BCR2_BURSTEN   = 1UL << 8,				  // BURSTEN
	FMC_BCR2_FACCEN	   = 1UL << 6,				  // FACCEN
	FMC_BCR2_MWID	   = ((1UL << 2) - 1) << 4,	  // MWID
	FMC_BCR2_MTYP	   = ((1UL << 2) - 1) << 2,	  // MTYP
	FMC_BCR2_MUXEN	   = 1UL << 1,				  // MUXEN
	FMC_BCR2_MBKEN	   = 1UL << 0,				  // MBKEN
};
inline void fmc_bcr2_set_nblset(struct FMC_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~FMC_BCR2_NBLSET) | ((val << 22) & FMC_BCR2_NBLSET);
}
inline void fmc_bcr2_set_cpsize(struct FMC_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~FMC_BCR2_CPSIZE) | ((val << 16) & FMC_BCR2_CPSIZE);
}
inline void fmc_bcr2_set_mwid(struct FMC_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~FMC_BCR2_MWID) | ((val << 4) & FMC_BCR2_MWID);
}
inline void fmc_bcr2_set_mtyp(struct FMC_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~FMC_BCR2_MTYP) | ((val << 2) & FMC_BCR2_MTYP);
}
inline uint32_t fmc_bcr2_get_nblset(struct FMC_Type *p) { return (p->BCR2 & FMC_BCR2_NBLSET) >> 22; }
inline uint32_t fmc_bcr2_get_cpsize(struct FMC_Type *p) { return (p->BCR2 & FMC_BCR2_CPSIZE) >> 16; }
inline uint32_t fmc_bcr2_get_mwid(struct FMC_Type *p) { return (p->BCR2 & FMC_BCR2_MWID) >> 4; }
inline uint32_t fmc_bcr2_get_mtyp(struct FMC_Type *p) { return (p->BCR2 & FMC_BCR2_MTYP) >> 2; }

// FMC->BTR2 SRAM/NOR-Flash chip-select timing register 2
enum {
	FMC_BTR2_DATAHLD = ((1UL << 2) - 1) << 30,	// DATAHLD
	FMC_BTR2_ACCMOD	 = ((1UL << 2) - 1) << 28,	// ACCMOD
	FMC_BTR2_DATLAT	 = ((1UL << 4) - 1) << 24,	// DATLAT
	FMC_BTR2_CLKDIV	 = ((1UL << 4) - 1) << 20,	// CLKDIV
	FMC_BTR2_BUSTURN = ((1UL << 4) - 1) << 16,	// BUSTURN
	FMC_BTR2_DATAST	 = ((1UL << 8) - 1) << 8,	// DATAST
	FMC_BTR2_ADDHLD	 = ((1UL << 4) - 1) << 4,	// ADDHLD
	FMC_BTR2_ADDSET	 = ((1UL << 4) - 1) << 0,	// ADDSET
};
inline void fmc_btr2_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATAHLD) | ((val << 30) & FMC_BTR2_DATAHLD);
}
inline void fmc_btr2_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_ACCMOD) | ((val << 28) & FMC_BTR2_ACCMOD);
}
inline void fmc_btr2_set_datlat(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATLAT) | ((val << 24) & FMC_BTR2_DATLAT);
}
inline void fmc_btr2_set_clkdiv(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_CLKDIV) | ((val << 20) & FMC_BTR2_CLKDIV);
}
inline void fmc_btr2_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_BUSTURN) | ((val << 16) & FMC_BTR2_BUSTURN);
}
inline void fmc_btr2_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_DATAST) | ((val << 8) & FMC_BTR2_DATAST);
}
inline void fmc_btr2_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_ADDHLD) | ((val << 4) & FMC_BTR2_ADDHLD);
}
inline void fmc_btr2_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BTR2 = (p->BTR2 & ~FMC_BTR2_ADDSET) | ((val << 0) & FMC_BTR2_ADDSET);
}
inline uint32_t fmc_btr2_get_datahld(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_DATAHLD) >> 30; }
inline uint32_t fmc_btr2_get_accmod(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_ACCMOD) >> 28; }
inline uint32_t fmc_btr2_get_datlat(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_DATLAT) >> 24; }
inline uint32_t fmc_btr2_get_clkdiv(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_CLKDIV) >> 20; }
inline uint32_t fmc_btr2_get_busturn(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_BUSTURN) >> 16; }
inline uint32_t fmc_btr2_get_datast(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_DATAST) >> 8; }
inline uint32_t fmc_btr2_get_addhld(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_ADDHLD) >> 4; }
inline uint32_t fmc_btr2_get_addset(struct FMC_Type *p) { return (p->BTR2 & FMC_BTR2_ADDSET) >> 0; }

// FMC->BCR3 SRAM/NOR-Flash chip-select control register 3
enum {
	FMC_BCR3_NBLSET	   = ((1UL << 2) - 1) << 22,  // NBLSET
	FMC_BCR3_WFDIS	   = 1UL << 21,				  // WFDIS
	FMC_BCR3_CCLKEN	   = 1UL << 20,				  // CCLKEN
	FMC_BCR3_CBURSTRW  = 1UL << 19,				  // CBURSTRW
	FMC_BCR3_CPSIZE	   = ((1UL << 3) - 1) << 16,  // CPSIZE
	FMC_BCR3_ASYNCWAIT = 1UL << 15,				  // ASYNCWAIT
	FMC_BCR3_EXTMOD	   = 1UL << 14,				  // EXTMOD
	FMC_BCR3_WAITEN	   = 1UL << 13,				  // WAITEN
	FMC_BCR3_WREN	   = 1UL << 12,				  // WREN
	FMC_BCR3_WAITCFG   = 1UL << 11,				  // WAITCFG
	FMC_BCR3_WAITPOL   = 1UL << 9,				  // WAITPOL
	FMC_BCR3_BURSTEN   = 1UL << 8,				  // BURSTEN
	FMC_BCR3_FACCEN	   = 1UL << 6,				  // FACCEN
	FMC_BCR3_MWID	   = ((1UL << 2) - 1) << 4,	  // MWID
	FMC_BCR3_MTYP	   = ((1UL << 2) - 1) << 2,	  // MTYP
	FMC_BCR3_MUXEN	   = 1UL << 1,				  // MUXEN
	FMC_BCR3_MBKEN	   = 1UL << 0,				  // MBKEN
};
inline void fmc_bcr3_set_nblset(struct FMC_Type *p, uint32_t val) {
	p->BCR3 = (p->BCR3 & ~FMC_BCR3_NBLSET) | ((val << 22) & FMC_BCR3_NBLSET);
}
inline void fmc_bcr3_set_cpsize(struct FMC_Type *p, uint32_t val) {
	p->BCR3 = (p->BCR3 & ~FMC_BCR3_CPSIZE) | ((val << 16) & FMC_BCR3_CPSIZE);
}
inline void fmc_bcr3_set_mwid(struct FMC_Type *p, uint32_t val) {
	p->BCR3 = (p->BCR3 & ~FMC_BCR3_MWID) | ((val << 4) & FMC_BCR3_MWID);
}
inline void fmc_bcr3_set_mtyp(struct FMC_Type *p, uint32_t val) {
	p->BCR3 = (p->BCR3 & ~FMC_BCR3_MTYP) | ((val << 2) & FMC_BCR3_MTYP);
}
inline uint32_t fmc_bcr3_get_nblset(struct FMC_Type *p) { return (p->BCR3 & FMC_BCR3_NBLSET) >> 22; }
inline uint32_t fmc_bcr3_get_cpsize(struct FMC_Type *p) { return (p->BCR3 & FMC_BCR3_CPSIZE) >> 16; }
inline uint32_t fmc_bcr3_get_mwid(struct FMC_Type *p) { return (p->BCR3 & FMC_BCR3_MWID) >> 4; }
inline uint32_t fmc_bcr3_get_mtyp(struct FMC_Type *p) { return (p->BCR3 & FMC_BCR3_MTYP) >> 2; }

// FMC->BTR3 SRAM/NOR-Flash chip-select timing register 3
enum {
	FMC_BTR3_DATAHLD = ((1UL << 2) - 1) << 30,	// DATAHLD
	FMC_BTR3_ACCMOD	 = ((1UL << 2) - 1) << 28,	// ACCMOD
	FMC_BTR3_DATLAT	 = ((1UL << 4) - 1) << 24,	// DATLAT
	FMC_BTR3_CLKDIV	 = ((1UL << 4) - 1) << 20,	// CLKDIV
	FMC_BTR3_BUSTURN = ((1UL << 4) - 1) << 16,	// BUSTURN
	FMC_BTR3_DATAST	 = ((1UL << 8) - 1) << 8,	// DATAST
	FMC_BTR3_ADDHLD	 = ((1UL << 4) - 1) << 4,	// ADDHLD
	FMC_BTR3_ADDSET	 = ((1UL << 4) - 1) << 0,	// ADDSET
};
inline void fmc_btr3_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATAHLD) | ((val << 30) & FMC_BTR3_DATAHLD);
}
inline void fmc_btr3_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_ACCMOD) | ((val << 28) & FMC_BTR3_ACCMOD);
}
inline void fmc_btr3_set_datlat(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATLAT) | ((val << 24) & FMC_BTR3_DATLAT);
}
inline void fmc_btr3_set_clkdiv(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_CLKDIV) | ((val << 20) & FMC_BTR3_CLKDIV);
}
inline void fmc_btr3_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_BUSTURN) | ((val << 16) & FMC_BTR3_BUSTURN);
}
inline void fmc_btr3_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_DATAST) | ((val << 8) & FMC_BTR3_DATAST);
}
inline void fmc_btr3_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_ADDHLD) | ((val << 4) & FMC_BTR3_ADDHLD);
}
inline void fmc_btr3_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BTR3 = (p->BTR3 & ~FMC_BTR3_ADDSET) | ((val << 0) & FMC_BTR3_ADDSET);
}
inline uint32_t fmc_btr3_get_datahld(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_DATAHLD) >> 30; }
inline uint32_t fmc_btr3_get_accmod(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_ACCMOD) >> 28; }
inline uint32_t fmc_btr3_get_datlat(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_DATLAT) >> 24; }
inline uint32_t fmc_btr3_get_clkdiv(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_CLKDIV) >> 20; }
inline uint32_t fmc_btr3_get_busturn(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_BUSTURN) >> 16; }
inline uint32_t fmc_btr3_get_datast(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_DATAST) >> 8; }
inline uint32_t fmc_btr3_get_addhld(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_ADDHLD) >> 4; }
inline uint32_t fmc_btr3_get_addset(struct FMC_Type *p) { return (p->BTR3 & FMC_BTR3_ADDSET) >> 0; }

// FMC->BCR4 SRAM/NOR-Flash chip-select control register 4
enum {
	FMC_BCR4_NBLSET	   = ((1UL << 2) - 1) << 22,  // NBLSET
	FMC_BCR4_WFDIS	   = 1UL << 21,				  // WFDIS
	FMC_BCR4_CCLKEN	   = 1UL << 20,				  // CCLKEN
	FMC_BCR4_CBURSTRW  = 1UL << 19,				  // CBURSTRW
	FMC_BCR4_CPSIZE	   = ((1UL << 3) - 1) << 16,  // CPSIZE
	FMC_BCR4_ASYNCWAIT = 1UL << 15,				  // ASYNCWAIT
	FMC_BCR4_EXTMOD	   = 1UL << 14,				  // EXTMOD
	FMC_BCR4_WAITEN	   = 1UL << 13,				  // WAITEN
	FMC_BCR4_WREN	   = 1UL << 12,				  // WREN
	FMC_BCR4_WAITCFG   = 1UL << 11,				  // WAITCFG
	FMC_BCR4_WAITPOL   = 1UL << 9,				  // WAITPOL
	FMC_BCR4_BURSTEN   = 1UL << 8,				  // BURSTEN
	FMC_BCR4_FACCEN	   = 1UL << 6,				  // FACCEN
	FMC_BCR4_MWID	   = ((1UL << 2) - 1) << 4,	  // MWID
	FMC_BCR4_MTYP	   = ((1UL << 2) - 1) << 2,	  // MTYP
	FMC_BCR4_MUXEN	   = 1UL << 1,				  // MUXEN
	FMC_BCR4_MBKEN	   = 1UL << 0,				  // MBKEN
};
inline void fmc_bcr4_set_nblset(struct FMC_Type *p, uint32_t val) {
	p->BCR4 = (p->BCR4 & ~FMC_BCR4_NBLSET) | ((val << 22) & FMC_BCR4_NBLSET);
}
inline void fmc_bcr4_set_cpsize(struct FMC_Type *p, uint32_t val) {
	p->BCR4 = (p->BCR4 & ~FMC_BCR4_CPSIZE) | ((val << 16) & FMC_BCR4_CPSIZE);
}
inline void fmc_bcr4_set_mwid(struct FMC_Type *p, uint32_t val) {
	p->BCR4 = (p->BCR4 & ~FMC_BCR4_MWID) | ((val << 4) & FMC_BCR4_MWID);
}
inline void fmc_bcr4_set_mtyp(struct FMC_Type *p, uint32_t val) {
	p->BCR4 = (p->BCR4 & ~FMC_BCR4_MTYP) | ((val << 2) & FMC_BCR4_MTYP);
}
inline uint32_t fmc_bcr4_get_nblset(struct FMC_Type *p) { return (p->BCR4 & FMC_BCR4_NBLSET) >> 22; }
inline uint32_t fmc_bcr4_get_cpsize(struct FMC_Type *p) { return (p->BCR4 & FMC_BCR4_CPSIZE) >> 16; }
inline uint32_t fmc_bcr4_get_mwid(struct FMC_Type *p) { return (p->BCR4 & FMC_BCR4_MWID) >> 4; }
inline uint32_t fmc_bcr4_get_mtyp(struct FMC_Type *p) { return (p->BCR4 & FMC_BCR4_MTYP) >> 2; }

// FMC->BTR4 SRAM/NOR-Flash chip-select timing register 4
enum {
	FMC_BTR4_DATAHLD = ((1UL << 2) - 1) << 30,	// DATAHLD
	FMC_BTR4_ACCMOD	 = ((1UL << 2) - 1) << 28,	// ACCMOD
	FMC_BTR4_DATLAT	 = ((1UL << 4) - 1) << 24,	// DATLAT
	FMC_BTR4_CLKDIV	 = ((1UL << 4) - 1) << 20,	// CLKDIV
	FMC_BTR4_BUSTURN = ((1UL << 4) - 1) << 16,	// BUSTURN
	FMC_BTR4_DATAST	 = ((1UL << 8) - 1) << 8,	// DATAST
	FMC_BTR4_ADDHLD	 = ((1UL << 4) - 1) << 4,	// ADDHLD
	FMC_BTR4_ADDSET	 = ((1UL << 4) - 1) << 0,	// ADDSET
};
inline void fmc_btr4_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATAHLD) | ((val << 30) & FMC_BTR4_DATAHLD);
}
inline void fmc_btr4_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_ACCMOD) | ((val << 28) & FMC_BTR4_ACCMOD);
}
inline void fmc_btr4_set_datlat(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATLAT) | ((val << 24) & FMC_BTR4_DATLAT);
}
inline void fmc_btr4_set_clkdiv(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_CLKDIV) | ((val << 20) & FMC_BTR4_CLKDIV);
}
inline void fmc_btr4_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_BUSTURN) | ((val << 16) & FMC_BTR4_BUSTURN);
}
inline void fmc_btr4_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_DATAST) | ((val << 8) & FMC_BTR4_DATAST);
}
inline void fmc_btr4_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_ADDHLD) | ((val << 4) & FMC_BTR4_ADDHLD);
}
inline void fmc_btr4_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BTR4 = (p->BTR4 & ~FMC_BTR4_ADDSET) | ((val << 0) & FMC_BTR4_ADDSET);
}
inline uint32_t fmc_btr4_get_datahld(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_DATAHLD) >> 30; }
inline uint32_t fmc_btr4_get_accmod(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_ACCMOD) >> 28; }
inline uint32_t fmc_btr4_get_datlat(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_DATLAT) >> 24; }
inline uint32_t fmc_btr4_get_clkdiv(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_CLKDIV) >> 20; }
inline uint32_t fmc_btr4_get_busturn(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_BUSTURN) >> 16; }
inline uint32_t fmc_btr4_get_datast(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_DATAST) >> 8; }
inline uint32_t fmc_btr4_get_addhld(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_ADDHLD) >> 4; }
inline uint32_t fmc_btr4_get_addset(struct FMC_Type *p) { return (p->BTR4 & FMC_BTR4_ADDSET) >> 0; }

// FMC->PCSCNTR PSRAM chip select counter register
enum {
	FMC_PCSCNTR_CNTB4EN = 1UL << 19,			   // CNTB4EN
	FMC_PCSCNTR_CNTB3EN = 1UL << 18,			   // CNTB3EN
	FMC_PCSCNTR_CNTB2EN = 1UL << 17,			   // CNTB2EN
	FMC_PCSCNTR_CNTB1EN = 1UL << 16,			   // CNTB1EN
	FMC_PCSCNTR_CSCOUNT = ((1UL << 16) - 1) << 0,  // CSCOUNT
};
inline void fmc_pcscntr_set_cscount(struct FMC_Type *p, uint32_t val) {
	p->PCSCNTR = (p->PCSCNTR & ~FMC_PCSCNTR_CSCOUNT) | ((val << 0) & FMC_PCSCNTR_CSCOUNT);
}
inline uint32_t fmc_pcscntr_get_cscount(struct FMC_Type *p) { return (p->PCSCNTR & FMC_PCSCNTR_CSCOUNT) >> 0; }

// FMC->PCR PC Card/NAND Flash control register 3
enum {
	FMC_PCR_ECCPS	= ((1UL << 3) - 1) << 17,  // ECCPS
	FMC_PCR_TAR		= ((1UL << 4) - 1) << 13,  // TAR
	FMC_PCR_TCLR	= ((1UL << 4) - 1) << 9,   // TCLR
	FMC_PCR_ECCEN	= 1UL << 6,				   // ECCEN
	FMC_PCR_PWID	= ((1UL << 2) - 1) << 4,   // PWID
	FMC_PCR_PTYP	= 1UL << 3,				   // PTYP
	FMC_PCR_PBKEN	= 1UL << 2,				   // PBKEN
	FMC_PCR_PWAITEN = 1UL << 1,				   // PWAITEN
};
inline void fmc_pcr_set_eccps(struct FMC_Type *p, uint32_t val) {
	p->PCR = (p->PCR & ~FMC_PCR_ECCPS) | ((val << 17) & FMC_PCR_ECCPS);
}
inline void fmc_pcr_set_tar(struct FMC_Type *p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_TAR) | ((val << 13) & FMC_PCR_TAR); }
inline void fmc_pcr_set_tclr(struct FMC_Type *p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_TCLR) | ((val << 9) & FMC_PCR_TCLR); }
inline void fmc_pcr_set_pwid(struct FMC_Type *p, uint32_t val) { p->PCR = (p->PCR & ~FMC_PCR_PWID) | ((val << 4) & FMC_PCR_PWID); }
inline uint32_t fmc_pcr_get_eccps(struct FMC_Type *p) { return (p->PCR & FMC_PCR_ECCPS) >> 17; }
inline uint32_t fmc_pcr_get_tar(struct FMC_Type *p) { return (p->PCR & FMC_PCR_TAR) >> 13; }
inline uint32_t fmc_pcr_get_tclr(struct FMC_Type *p) { return (p->PCR & FMC_PCR_TCLR) >> 9; }
inline uint32_t fmc_pcr_get_pwid(struct FMC_Type *p) { return (p->PCR & FMC_PCR_PWID) >> 4; }

// FMC->SR FIFO status and interrupt register 3
enum {
	FMC_SR_FEMPT = 1UL << 6,  // FEMPT
	FMC_SR_IFEN	 = 1UL << 5,  // IFEN
	FMC_SR_ILEN	 = 1UL << 4,  // ILEN
	FMC_SR_IREN	 = 1UL << 3,  // IREN
	FMC_SR_IFS	 = 1UL << 2,  // IFS
	FMC_SR_ILS	 = 1UL << 1,  // ILS
	FMC_SR_IRS	 = 1UL << 0,  // IRS
};

// FMC->PMEM Common memory space timing register 3
enum {
	FMC_PMEM_MEMHIZX  = ((1UL << 8) - 1) << 24,	 // MEMHIZx
	FMC_PMEM_MEMHOLDX = ((1UL << 8) - 1) << 16,	 // MEMHOLDx
	FMC_PMEM_MEMWAITX = ((1UL << 8) - 1) << 8,	 // MEMWAITx
	FMC_PMEM_MEMSETX  = ((1UL << 8) - 1) << 0,	 // MEMSETx
};
inline void fmc_pmem_set_memhizx(struct FMC_Type *p, uint32_t val) {
	p->PMEM = (p->PMEM & ~FMC_PMEM_MEMHIZX) | ((val << 24) & FMC_PMEM_MEMHIZX);
}
inline void fmc_pmem_set_memholdx(struct FMC_Type *p, uint32_t val) {
	p->PMEM = (p->PMEM & ~FMC_PMEM_MEMHOLDX) | ((val << 16) & FMC_PMEM_MEMHOLDX);
}
inline void fmc_pmem_set_memwaitx(struct FMC_Type *p, uint32_t val) {
	p->PMEM = (p->PMEM & ~FMC_PMEM_MEMWAITX) | ((val << 8) & FMC_PMEM_MEMWAITX);
}
inline void fmc_pmem_set_memsetx(struct FMC_Type *p, uint32_t val) {
	p->PMEM = (p->PMEM & ~FMC_PMEM_MEMSETX) | ((val << 0) & FMC_PMEM_MEMSETX);
}
inline uint32_t fmc_pmem_get_memhizx(struct FMC_Type *p) { return (p->PMEM & FMC_PMEM_MEMHIZX) >> 24; }
inline uint32_t fmc_pmem_get_memholdx(struct FMC_Type *p) { return (p->PMEM & FMC_PMEM_MEMHOLDX) >> 16; }
inline uint32_t fmc_pmem_get_memwaitx(struct FMC_Type *p) { return (p->PMEM & FMC_PMEM_MEMWAITX) >> 8; }
inline uint32_t fmc_pmem_get_memsetx(struct FMC_Type *p) { return (p->PMEM & FMC_PMEM_MEMSETX) >> 0; }

// FMC->PATT Attribute memory space timing register 3
enum {
	FMC_PATT_ATTHIZX  = ((1UL << 8) - 1) << 24,	 // ATTHIZx
	FMC_PATT_ATTHOLDX = ((1UL << 8) - 1) << 16,	 // ATTHOLDx
	FMC_PATT_ATTWAITX = ((1UL << 8) - 1) << 8,	 // ATTWAITx
	FMC_PATT_ATTSETX  = ((1UL << 8) - 1) << 0,	 // ATTSETx
};
inline void fmc_patt_set_atthizx(struct FMC_Type *p, uint32_t val) {
	p->PATT = (p->PATT & ~FMC_PATT_ATTHIZX) | ((val << 24) & FMC_PATT_ATTHIZX);
}
inline void fmc_patt_set_attholdx(struct FMC_Type *p, uint32_t val) {
	p->PATT = (p->PATT & ~FMC_PATT_ATTHOLDX) | ((val << 16) & FMC_PATT_ATTHOLDX);
}
inline void fmc_patt_set_attwaitx(struct FMC_Type *p, uint32_t val) {
	p->PATT = (p->PATT & ~FMC_PATT_ATTWAITX) | ((val << 8) & FMC_PATT_ATTWAITX);
}
inline void fmc_patt_set_attsetx(struct FMC_Type *p, uint32_t val) {
	p->PATT = (p->PATT & ~FMC_PATT_ATTSETX) | ((val << 0) & FMC_PATT_ATTSETX);
}
inline uint32_t fmc_patt_get_atthizx(struct FMC_Type *p) { return (p->PATT & FMC_PATT_ATTHIZX) >> 24; }
inline uint32_t fmc_patt_get_attholdx(struct FMC_Type *p) { return (p->PATT & FMC_PATT_ATTHOLDX) >> 16; }
inline uint32_t fmc_patt_get_attwaitx(struct FMC_Type *p) { return (p->PATT & FMC_PATT_ATTWAITX) >> 8; }
inline uint32_t fmc_patt_get_attsetx(struct FMC_Type *p) { return (p->PATT & FMC_PATT_ATTSETX) >> 0; }

// FMC->BWTR1 SRAM/NOR-Flash write timing registers 1
enum {
	FMC_BWTR1_DATAHLD = ((1UL << 2) - 1) << 30,	 // DATAHLD
	FMC_BWTR1_ACCMOD  = ((1UL << 2) - 1) << 28,	 // ACCMOD
	FMC_BWTR1_BUSTURN = ((1UL << 4) - 1) << 16,	 // BUSTURN
	FMC_BWTR1_DATAST  = ((1UL << 8) - 1) << 8,	 // DATAST
	FMC_BWTR1_ADDHLD  = ((1UL << 4) - 1) << 4,	 // ADDHLD
	FMC_BWTR1_ADDSET  = ((1UL << 4) - 1) << 0,	 // ADDSET
};
inline void fmc_bwtr1_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_DATAHLD) | ((val << 30) & FMC_BWTR1_DATAHLD);
}
inline void fmc_bwtr1_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ACCMOD) | ((val << 28) & FMC_BWTR1_ACCMOD);
}
inline void fmc_bwtr1_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_BUSTURN) | ((val << 16) & FMC_BWTR1_BUSTURN);
}
inline void fmc_bwtr1_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_DATAST) | ((val << 8) & FMC_BWTR1_DATAST);
}
inline void fmc_bwtr1_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ADDHLD) | ((val << 4) & FMC_BWTR1_ADDHLD);
}
inline void fmc_bwtr1_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BWTR1 = (p->BWTR1 & ~FMC_BWTR1_ADDSET) | ((val << 0) & FMC_BWTR1_ADDSET);
}
inline uint32_t fmc_bwtr1_get_datahld(struct FMC_Type *p) { return (p->BWTR1 & FMC_BWTR1_DATAHLD) >> 30; }
inline uint32_t fmc_bwtr1_get_accmod(struct FMC_Type *p) { return (p->BWTR1 & FMC_BWTR1_ACCMOD) >> 28; }
inline uint32_t fmc_bwtr1_get_busturn(struct FMC_Type *p) { return (p->BWTR1 & FMC_BWTR1_BUSTURN) >> 16; }
inline uint32_t fmc_bwtr1_get_datast(struct FMC_Type *p) { return (p->BWTR1 & FMC_BWTR1_DATAST) >> 8; }
inline uint32_t fmc_bwtr1_get_addhld(struct FMC_Type *p) { return (p->BWTR1 & FMC_BWTR1_ADDHLD) >> 4; }
inline uint32_t fmc_bwtr1_get_addset(struct FMC_Type *p) { return (p->BWTR1 & FMC_BWTR1_ADDSET) >> 0; }

// FMC->BWTR2 SRAM/NOR-Flash write timing registers 2
enum {
	FMC_BWTR2_DATAHLD = ((1UL << 2) - 1) << 30,	 // DATAHLD
	FMC_BWTR2_ACCMOD  = ((1UL << 2) - 1) << 28,	 // ACCMOD
	FMC_BWTR2_BUSTURN = ((1UL << 4) - 1) << 16,	 // BUSTURN
	FMC_BWTR2_DATAST  = ((1UL << 8) - 1) << 8,	 // DATAST
	FMC_BWTR2_ADDHLD  = ((1UL << 4) - 1) << 4,	 // ADDHLD
	FMC_BWTR2_ADDSET  = ((1UL << 4) - 1) << 0,	 // ADDSET
};
inline void fmc_bwtr2_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_DATAHLD) | ((val << 30) & FMC_BWTR2_DATAHLD);
}
inline void fmc_bwtr2_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ACCMOD) | ((val << 28) & FMC_BWTR2_ACCMOD);
}
inline void fmc_bwtr2_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_BUSTURN) | ((val << 16) & FMC_BWTR2_BUSTURN);
}
inline void fmc_bwtr2_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_DATAST) | ((val << 8) & FMC_BWTR2_DATAST);
}
inline void fmc_bwtr2_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ADDHLD) | ((val << 4) & FMC_BWTR2_ADDHLD);
}
inline void fmc_bwtr2_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BWTR2 = (p->BWTR2 & ~FMC_BWTR2_ADDSET) | ((val << 0) & FMC_BWTR2_ADDSET);
}
inline uint32_t fmc_bwtr2_get_datahld(struct FMC_Type *p) { return (p->BWTR2 & FMC_BWTR2_DATAHLD) >> 30; }
inline uint32_t fmc_bwtr2_get_accmod(struct FMC_Type *p) { return (p->BWTR2 & FMC_BWTR2_ACCMOD) >> 28; }
inline uint32_t fmc_bwtr2_get_busturn(struct FMC_Type *p) { return (p->BWTR2 & FMC_BWTR2_BUSTURN) >> 16; }
inline uint32_t fmc_bwtr2_get_datast(struct FMC_Type *p) { return (p->BWTR2 & FMC_BWTR2_DATAST) >> 8; }
inline uint32_t fmc_bwtr2_get_addhld(struct FMC_Type *p) { return (p->BWTR2 & FMC_BWTR2_ADDHLD) >> 4; }
inline uint32_t fmc_bwtr2_get_addset(struct FMC_Type *p) { return (p->BWTR2 & FMC_BWTR2_ADDSET) >> 0; }

// FMC->BWTR3 SRAM/NOR-Flash write timing registers 3
enum {
	FMC_BWTR3_DATAHLD = ((1UL << 2) - 1) << 30,	 // DATAHLD
	FMC_BWTR3_ACCMOD  = ((1UL << 2) - 1) << 28,	 // ACCMOD
	FMC_BWTR3_BUSTURN = ((1UL << 4) - 1) << 16,	 // BUSTURN
	FMC_BWTR3_DATAST  = ((1UL << 8) - 1) << 8,	 // DATAST
	FMC_BWTR3_ADDHLD  = ((1UL << 4) - 1) << 4,	 // ADDHLD
	FMC_BWTR3_ADDSET  = ((1UL << 4) - 1) << 0,	 // ADDSET
};
inline void fmc_bwtr3_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_DATAHLD) | ((val << 30) & FMC_BWTR3_DATAHLD);
}
inline void fmc_bwtr3_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ACCMOD) | ((val << 28) & FMC_BWTR3_ACCMOD);
}
inline void fmc_bwtr3_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_BUSTURN) | ((val << 16) & FMC_BWTR3_BUSTURN);
}
inline void fmc_bwtr3_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_DATAST) | ((val << 8) & FMC_BWTR3_DATAST);
}
inline void fmc_bwtr3_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ADDHLD) | ((val << 4) & FMC_BWTR3_ADDHLD);
}
inline void fmc_bwtr3_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BWTR3 = (p->BWTR3 & ~FMC_BWTR3_ADDSET) | ((val << 0) & FMC_BWTR3_ADDSET);
}
inline uint32_t fmc_bwtr3_get_datahld(struct FMC_Type *p) { return (p->BWTR3 & FMC_BWTR3_DATAHLD) >> 30; }
inline uint32_t fmc_bwtr3_get_accmod(struct FMC_Type *p) { return (p->BWTR3 & FMC_BWTR3_ACCMOD) >> 28; }
inline uint32_t fmc_bwtr3_get_busturn(struct FMC_Type *p) { return (p->BWTR3 & FMC_BWTR3_BUSTURN) >> 16; }
inline uint32_t fmc_bwtr3_get_datast(struct FMC_Type *p) { return (p->BWTR3 & FMC_BWTR3_DATAST) >> 8; }
inline uint32_t fmc_bwtr3_get_addhld(struct FMC_Type *p) { return (p->BWTR3 & FMC_BWTR3_ADDHLD) >> 4; }
inline uint32_t fmc_bwtr3_get_addset(struct FMC_Type *p) { return (p->BWTR3 & FMC_BWTR3_ADDSET) >> 0; }

// FMC->BWTR4 SRAM/NOR-Flash write timing registers 4
enum {
	FMC_BWTR4_DATAHLD = ((1UL << 2) - 1) << 30,	 // DATAHLD
	FMC_BWTR4_ACCMOD  = ((1UL << 2) - 1) << 28,	 // ACCMOD
	FMC_BWTR4_BUSTURN = ((1UL << 4) - 1) << 16,	 // BUSTURN
	FMC_BWTR4_DATAST  = ((1UL << 8) - 1) << 8,	 // DATAST
	FMC_BWTR4_ADDHLD  = ((1UL << 4) - 1) << 4,	 // ADDHLD
	FMC_BWTR4_ADDSET  = ((1UL << 4) - 1) << 0,	 // ADDSET
};
inline void fmc_bwtr4_set_datahld(struct FMC_Type *p, uint32_t val) {
	p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_DATAHLD) | ((val << 30) & FMC_BWTR4_DATAHLD);
}
inline void fmc_bwtr4_set_accmod(struct FMC_Type *p, uint32_t val) {
	p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ACCMOD) | ((val << 28) & FMC_BWTR4_ACCMOD);
}
inline void fmc_bwtr4_set_busturn(struct FMC_Type *p, uint32_t val) {
	p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_BUSTURN) | ((val << 16) & FMC_BWTR4_BUSTURN);
}
inline void fmc_bwtr4_set_datast(struct FMC_Type *p, uint32_t val) {
	p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_DATAST) | ((val << 8) & FMC_BWTR4_DATAST);
}
inline void fmc_bwtr4_set_addhld(struct FMC_Type *p, uint32_t val) {
	p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ADDHLD) | ((val << 4) & FMC_BWTR4_ADDHLD);
}
inline void fmc_bwtr4_set_addset(struct FMC_Type *p, uint32_t val) {
	p->BWTR4 = (p->BWTR4 & ~FMC_BWTR4_ADDSET) | ((val << 0) & FMC_BWTR4_ADDSET);
}
inline uint32_t fmc_bwtr4_get_datahld(struct FMC_Type *p) { return (p->BWTR4 & FMC_BWTR4_DATAHLD) >> 30; }
inline uint32_t fmc_bwtr4_get_accmod(struct FMC_Type *p) { return (p->BWTR4 & FMC_BWTR4_ACCMOD) >> 28; }
inline uint32_t fmc_bwtr4_get_busturn(struct FMC_Type *p) { return (p->BWTR4 & FMC_BWTR4_BUSTURN) >> 16; }
inline uint32_t fmc_bwtr4_get_datast(struct FMC_Type *p) { return (p->BWTR4 & FMC_BWTR4_DATAST) >> 8; }
inline uint32_t fmc_bwtr4_get_addhld(struct FMC_Type *p) { return (p->BWTR4 & FMC_BWTR4_ADDHLD) >> 4; }
inline uint32_t fmc_bwtr4_get_addset(struct FMC_Type *p) { return (p->BWTR4 & FMC_BWTR4_ADDSET) >> 0; }

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR;  // @0 Floating-point context control register
	__IO uint32_t FPCAR;  // @4 Floating-point context address register
	__IO uint32_t FPSCR;  // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN	 = 1UL << 31,  // ASPEN
	FPU_FPCCR_LSPEN	 = 1UL << 30,  // LSPEN
	FPU_FPCCR_MONRDY = 1UL << 8,   // MONRDY
	FPU_FPCCR_BFRDY	 = 1UL << 6,   // BFRDY
	FPU_FPCCR_MMRDY	 = 1UL << 5,   // MMRDY
	FPU_FPCCR_HFRDY	 = 1UL << 4,   // HFRDY
	FPU_FPCCR_THREAD = 1UL << 3,   // THREAD
	FPU_FPCCR_USER	 = 1UL << 1,   // USER
	FPU_FPCCR_LSPACT = 1UL << 0,   // LSPACT
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL << 29) - 1) << 3,	 // Location of unpopulated floating-point
};
inline void fpu_fpcar_set_address(struct FPU_Type *p, uint32_t val) {
	p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val << 3) & FPU_FPCAR_ADDRESS);
}
inline uint32_t fpu_fpcar_get_address(struct FPU_Type *p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N		= 1UL << 31,			   // Negative condition code flag
	FPU_FPSCR_Z		= 1UL << 30,			   // Zero condition code flag
	FPU_FPSCR_C		= 1UL << 29,			   // Carry condition code flag
	FPU_FPSCR_V		= 1UL << 28,			   // Overflow condition code flag
	FPU_FPSCR_AHP	= 1UL << 26,			   // Alternative half-precision control bit
	FPU_FPSCR_DN	= 1UL << 25,			   // Default NaN mode control bit
	FPU_FPSCR_FZ	= 1UL << 24,			   // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL << 2) - 1) << 22,  // Rounding Mode control field
	FPU_FPSCR_IDC	= 1UL << 7,				   // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC	= 1UL << 4,				   // Inexact cumulative exception bit
	FPU_FPSCR_UFC	= 1UL << 3,				   // Underflow cumulative exception bit
	FPU_FPSCR_OFC	= 1UL << 2,				   // Overflow cumulative exception bit
	FPU_FPSCR_DZC	= 1UL << 1,				   // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC	= 1UL << 0,				   // Invalid operation cumulative exception bit
};
inline void fpu_fpscr_set_rmode(struct FPU_Type *p, uint32_t val) {
	p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val << 22) & FPU_FPSCR_RMODE);
}
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type *p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR;  // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL << 4) - 1) << 20,  // CP
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type *p, uint32_t val) {
	p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val << 20) & FPU_CPACR_CPACR_CP);
}
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type *p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER;		 // @0 GPIO port mode register
	__IO uint16_t OTYPER;		 // @4 GPIO port output type register
	uint8_t		  RESERVED0[2];	 // @6
	__IO uint32_t OSPEEDR;		 // @8 GPIO port output speed register
	__IO uint32_t PUPDR;		 // @12 GPIO port pull-up/pull-down register
	__I uint16_t  IDR;			 // @16 GPIO port input data register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t ODR;			 // @20 GPIO port output data register
	uint8_t		  RESERVED2[2];	 // @22
	__O uint32_t  BSRR;			 // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR;			 // @28 GPIO port configuration lock register
	__IO uint32_t AFRL;			 // @32 GPIO alternate function low register
	__IO uint32_t AFRH;			 // @36 GPIO alternate function high register
	__O uint16_t  BRR;			 // @40 GPIO port bit reset register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL << 2) - 1) << 30,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL << 2) - 1) << 28,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL << 2) - 1) << 26,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL << 2) - 1) << 24,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL << 2) - 1) << 22,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL << 2) - 1) << 20,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9	= ((1UL << 2) - 1) << 18,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8	= ((1UL << 2) - 1) << 16,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7	= ((1UL << 2) - 1) << 14,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6	= ((1UL << 2) - 1) << 12,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5	= ((1UL << 2) - 1) << 10,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4	= ((1UL << 2) - 1) << 8,   // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3	= ((1UL << 2) - 1) << 6,   // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2	= ((1UL << 2) - 1) << 4,   // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1	= ((1UL << 2) - 1) << 2,   // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0	= ((1UL << 2) - 1) << 0,   // Port x configuration bits (y = 0..15)
};
inline void gpioa_moder_set_moder15(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val << 30) & GPIOA_MODER_MODER15);
}
inline void gpioa_moder_set_moder14(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val << 28) & GPIOA_MODER_MODER14);
}
inline void gpioa_moder_set_moder13(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val << 26) & GPIOA_MODER_MODER13);
}
inline void gpioa_moder_set_moder12(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val << 24) & GPIOA_MODER_MODER12);
}
inline void gpioa_moder_set_moder11(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val << 22) & GPIOA_MODER_MODER11);
}
inline void gpioa_moder_set_moder10(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val << 20) & GPIOA_MODER_MODER10);
}
inline void gpioa_moder_set_moder9(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val << 18) & GPIOA_MODER_MODER9);
}
inline void gpioa_moder_set_moder8(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val << 16) & GPIOA_MODER_MODER8);
}
inline void gpioa_moder_set_moder7(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val << 14) & GPIOA_MODER_MODER7);
}
inline void gpioa_moder_set_moder6(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val << 12) & GPIOA_MODER_MODER6);
}
inline void gpioa_moder_set_moder5(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val << 10) & GPIOA_MODER_MODER5);
}
inline void gpioa_moder_set_moder4(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val << 8) & GPIOA_MODER_MODER4);
}
inline void gpioa_moder_set_moder3(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val << 6) & GPIOA_MODER_MODER3);
}
inline void gpioa_moder_set_moder2(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val << 4) & GPIOA_MODER_MODER2);
}
inline void gpioa_moder_set_moder1(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val << 2) & GPIOA_MODER_MODER1);
}
inline void gpioa_moder_set_moder0(struct GPIOA_Type *p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val << 0) & GPIOA_MODER_MODER0);
}
inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30; }
inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28; }
inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26; }
inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24; }
inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22; }
inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20; }
inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18; }
inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16; }
inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14; }
inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12; }
inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10; }
inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8; }
inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6; }
inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4; }
inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2; }
inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type *p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL << 2) - 1) << 30,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL << 2) - 1) << 28,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL << 2) - 1) << 26,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL << 2) - 1) << 24,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL << 2) - 1) << 22,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL << 2) - 1) << 20,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9	= ((1UL << 2) - 1) << 18,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8	= ((1UL << 2) - 1) << 16,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7	= ((1UL << 2) - 1) << 14,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6	= ((1UL << 2) - 1) << 12,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5	= ((1UL << 2) - 1) << 10,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4	= ((1UL << 2) - 1) << 8,   // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3	= ((1UL << 2) - 1) << 6,   // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2	= ((1UL << 2) - 1) << 4,   // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1	= ((1UL << 2) - 1) << 2,   // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0	= ((1UL << 2) - 1) << 0,   // Port x configuration bits (y = 0..15)
};
inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val << 30) & GPIOA_OSPEEDR_OSPEEDR15);
}
inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val << 28) & GPIOA_OSPEEDR_OSPEEDR14);
}
inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val << 26) & GPIOA_OSPEEDR_OSPEEDR13);
}
inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val << 24) & GPIOA_OSPEEDR_OSPEEDR12);
}
inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val << 22) & GPIOA_OSPEEDR_OSPEEDR11);
}
inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val << 20) & GPIOA_OSPEEDR_OSPEEDR10);
}
inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val << 18) & GPIOA_OSPEEDR_OSPEEDR9);
}
inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val << 16) & GPIOA_OSPEEDR_OSPEEDR8);
}
inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val << 14) & GPIOA_OSPEEDR_OSPEEDR7);
}
inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val << 12) & GPIOA_OSPEEDR_OSPEEDR6);
}
inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val << 10) & GPIOA_OSPEEDR_OSPEEDR5);
}
inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val << 8) & GPIOA_OSPEEDR_OSPEEDR4);
}
inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val << 6) & GPIOA_OSPEEDR_OSPEEDR3);
}
inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val << 4) & GPIOA_OSPEEDR_OSPEEDR2);
}
inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val << 2) & GPIOA_OSPEEDR_OSPEEDR1);
}
inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type *p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val << 0) & GPIOA_OSPEEDR_OSPEEDR0);
}
inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30; }
inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28; }
inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26; }
inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24; }
inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22; }
inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20; }
inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18; }
inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16; }
inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14; }
inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12; }
inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10; }
inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8; }
inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6; }
inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4; }
inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2; }
inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type *p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL << 2) - 1) << 30,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL << 2) - 1) << 28,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL << 2) - 1) << 26,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL << 2) - 1) << 24,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL << 2) - 1) << 22,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL << 2) - 1) << 20,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9	= ((1UL << 2) - 1) << 18,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8	= ((1UL << 2) - 1) << 16,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7	= ((1UL << 2) - 1) << 14,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6	= ((1UL << 2) - 1) << 12,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5	= ((1UL << 2) - 1) << 10,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4	= ((1UL << 2) - 1) << 8,   // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3	= ((1UL << 2) - 1) << 6,   // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2	= ((1UL << 2) - 1) << 4,   // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1	= ((1UL << 2) - 1) << 2,   // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0	= ((1UL << 2) - 1) << 0,   // Port x configuration bits (y = 0..15)
};
inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val << 30) & GPIOA_PUPDR_PUPDR15);
}
inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val << 28) & GPIOA_PUPDR_PUPDR14);
}
inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val << 26) & GPIOA_PUPDR_PUPDR13);
}
inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val << 24) & GPIOA_PUPDR_PUPDR12);
}
inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val << 22) & GPIOA_PUPDR_PUPDR11);
}
inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val << 20) & GPIOA_PUPDR_PUPDR10);
}
inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val << 18) & GPIOA_PUPDR_PUPDR9);
}
inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val << 16) & GPIOA_PUPDR_PUPDR8);
}
inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val << 14) & GPIOA_PUPDR_PUPDR7);
}
inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val << 12) & GPIOA_PUPDR_PUPDR6);
}
inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val << 10) & GPIOA_PUPDR_PUPDR5);
}
inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val << 8) & GPIOA_PUPDR_PUPDR4);
}
inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val << 6) & GPIOA_PUPDR_PUPDR3);
}
inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val << 4) & GPIOA_PUPDR_PUPDR2);
}
inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val << 2) & GPIOA_PUPDR_PUPDR1);
}
inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type *p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val << 0) & GPIOA_PUPDR_PUPDR0);
}
inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30; }
inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28; }
inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26; }
inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24; }
inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22; }
inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20; }
inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18; }
inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16; }
inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14; }
inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12; }
inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10; }
inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8; }
inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6; }
inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4; }
inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2; }
inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type *p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL << 31,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL << 30,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL << 29,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL << 28,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL << 27,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL << 26,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9	= 1UL << 25,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8	= 1UL << 24,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7	= 1UL << 23,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6	= 1UL << 22,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5	= 1UL << 21,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4	= 1UL << 20,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3	= 1UL << 19,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2	= 1UL << 18,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1	= 1UL << 17,  // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0	= 1UL << 16,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL << 15,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL << 14,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL << 13,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL << 12,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL << 11,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL << 10,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9	= 1UL << 9,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8	= 1UL << 8,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7	= 1UL << 7,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6	= 1UL << 6,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5	= 1UL << 5,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4	= 1UL << 4,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3	= 1UL << 3,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2	= 1UL << 2,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1	= 1UL << 1,	  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0	= 1UL << 0,	  // Port x set bit y (y= 0..15)
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK	 = 1UL << 16,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL << 15,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL << 14,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL << 13,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL << 12,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL << 11,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL << 10,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9	 = 1UL << 9,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8	 = 1UL << 8,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7	 = 1UL << 7,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6	 = 1UL << 6,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5	 = 1UL << 5,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4	 = 1UL << 4,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3	 = 1UL << 3,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2	 = 1UL << 2,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1	 = 1UL << 1,   // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0	 = 1UL << 0,   // Port x lock bit y (y= 0..15)
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFRL7 = ((1UL << 4) - 1) << 28,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL6 = ((1UL << 4) - 1) << 24,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL5 = ((1UL << 4) - 1) << 20,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL4 = ((1UL << 4) - 1) << 16,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL3 = ((1UL << 4) - 1) << 12,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL2 = ((1UL << 4) - 1) << 8,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL1 = ((1UL << 4) - 1) << 4,	// Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL0 = ((1UL << 4) - 1) << 0,	// Alternate function selection for port x bit y (y = 0..7)
};
inline void gpioa_afrl_set_afrl7(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL7) | ((val << 28) & GPIOA_AFRL_AFRL7);
}
inline void gpioa_afrl_set_afrl6(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL6) | ((val << 24) & GPIOA_AFRL_AFRL6);
}
inline void gpioa_afrl_set_afrl5(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL5) | ((val << 20) & GPIOA_AFRL_AFRL5);
}
inline void gpioa_afrl_set_afrl4(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL4) | ((val << 16) & GPIOA_AFRL_AFRL4);
}
inline void gpioa_afrl_set_afrl3(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL3) | ((val << 12) & GPIOA_AFRL_AFRL3);
}
inline void gpioa_afrl_set_afrl2(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL2) | ((val << 8) & GPIOA_AFRL_AFRL2);
}
inline void gpioa_afrl_set_afrl1(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL1) | ((val << 4) & GPIOA_AFRL_AFRL1);
}
inline void gpioa_afrl_set_afrl0(struct GPIOA_Type *p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL0) | ((val << 0) & GPIOA_AFRL_AFRL0);
}
inline uint32_t gpioa_afrl_get_afrl7(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL7) >> 28; }
inline uint32_t gpioa_afrl_get_afrl6(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL6) >> 24; }
inline uint32_t gpioa_afrl_get_afrl5(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL5) >> 20; }
inline uint32_t gpioa_afrl_get_afrl4(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL4) >> 16; }
inline uint32_t gpioa_afrl_get_afrl3(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL3) >> 12; }
inline uint32_t gpioa_afrl_get_afrl2(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL2) >> 8; }
inline uint32_t gpioa_afrl_get_afrl1(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL1) >> 4; }
inline uint32_t gpioa_afrl_get_afrl0(struct GPIOA_Type *p) { return (p->AFRL & GPIOA_AFRL_AFRL0) >> 0; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFRH15 = ((1UL << 4) - 1) << 28,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH14 = ((1UL << 4) - 1) << 24,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH13 = ((1UL << 4) - 1) << 20,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH12 = ((1UL << 4) - 1) << 16,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH11 = ((1UL << 4) - 1) << 12,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH10 = ((1UL << 4) - 1) << 8,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH9  = ((1UL << 4) - 1) << 4,	 // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH8  = ((1UL << 4) - 1) << 0,	 // Alternate function selection for port x bit y (y = 8..15)
};
inline void gpioa_afrh_set_afrh15(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH15) | ((val << 28) & GPIOA_AFRH_AFRH15);
}
inline void gpioa_afrh_set_afrh14(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH14) | ((val << 24) & GPIOA_AFRH_AFRH14);
}
inline void gpioa_afrh_set_afrh13(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH13) | ((val << 20) & GPIOA_AFRH_AFRH13);
}
inline void gpioa_afrh_set_afrh12(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH12) | ((val << 16) & GPIOA_AFRH_AFRH12);
}
inline void gpioa_afrh_set_afrh11(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH11) | ((val << 12) & GPIOA_AFRH_AFRH11);
}
inline void gpioa_afrh_set_afrh10(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH10) | ((val << 8) & GPIOA_AFRH_AFRH10);
}
inline void gpioa_afrh_set_afrh9(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH9) | ((val << 4) & GPIOA_AFRH_AFRH9);
}
inline void gpioa_afrh_set_afrh8(struct GPIOA_Type *p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH8) | ((val << 0) & GPIOA_AFRH_AFRH8);
}
inline uint32_t gpioa_afrh_get_afrh15(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH15) >> 28; }
inline uint32_t gpioa_afrh_get_afrh14(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH14) >> 24; }
inline uint32_t gpioa_afrh_get_afrh13(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH13) >> 20; }
inline uint32_t gpioa_afrh_get_afrh12(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH12) >> 16; }
inline uint32_t gpioa_afrh_get_afrh11(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH11) >> 12; }
inline uint32_t gpioa_afrh_get_afrh10(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH10) >> 8; }
inline uint32_t gpioa_afrh_get_afrh9(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH9) >> 4; }
inline uint32_t gpioa_afrh_get_afrh8(struct GPIOA_Type *p) { return (p->AFRH & GPIOA_AFRH_AFRH8) >> 0; }

/* High Resolution Timer: Common functions */
struct HRTIM_Common_Type {
	__IO uint32_t CR1;			 // @0 Control Register 1
	__IO uint32_t CR2;			 // @4 Control Register 2
	__I uint32_t  ISR;			 // @8 Interrupt Status Register
	__O uint32_t  ICR;			 // @12 Interrupt Clear Register
	__IO uint32_t IER;			 // @16 Interrupt Enable Register
	__IO uint16_t OENR;			 // @20 Output Enable Register
	uint8_t		  RESERVED0[2];	 // @22
	__O uint16_t  ODISR;		 // @24 ODISR
	uint8_t		  RESERVED1[2];	 // @26
	__I uint16_t  ODSR;			 // @28 Output Disable Status Register
	uint8_t		  RESERVED2[2];	 // @30
	__IO uint32_t BMCR;			 // @32 Burst Mode Control Register
	__IO uint32_t BMTRG;		 // @36 BMTRG
	__IO uint16_t BMCMPR;		 // @40 BMCMPR
	uint8_t		  RESERVED3[2];	 // @42
	__IO uint16_t BMPER;		 // @44 Burst Mode Period Register
	uint8_t		  RESERVED4[2];	 // @46
	__IO uint32_t EECR1;		 // @48 Timer External Event Control Register 1
	__IO uint32_t EECR2;		 // @52 Timer External Event Control Register 2
	__IO uint32_t EECR3;		 // @56 Timer External Event Control Register 3
	__IO uint32_t ADC1R;		 // @60 ADC Trigger 1 Register
	__IO uint32_t ADC2R;		 // @64 ADC Trigger 2 Register
	__IO uint32_t ADC3R;		 // @68 ADC Trigger 3 Register
	__IO uint32_t ADC4R;		 // @72 ADC Trigger 4 Register
	__IO uint8_t  DLLCR;		 // @76 DLL Control Register
	uint8_t		  RESERVED5[3];	 // @77
	__IO uint32_t FLTINR1;		 // @80 HRTIM Fault Input Register 1
	__IO uint32_t FLTINR2;		 // @84 HRTIM Fault Input Register 2
	__IO uint16_t BDMUPDR;		 // @88 BDMUPDR
	uint8_t		  RESERVED6[2];	 // @90
	__IO uint32_t BDTAUPR;		 // @92 Burst DMA Timerx update Register
	__IO uint32_t BDTBUPR;		 // @96 Burst DMA Timerx update Register
	__IO uint32_t BDTCUPR;		 // @100 Burst DMA Timerx update Register
	__IO uint32_t BDTDUPR;		 // @104 Burst DMA Timerx update Register
	__IO uint32_t BDTEUPR;		 // @108 Burst DMA Timerx update Register
	__O uint32_t  BDMADR;		 // @112 Burst DMA Data Register
	__IO uint32_t BDTFUPR;		 // @116 Burst DMA Timerx update Register
	__IO uint32_t ADCER;		 // @120 HRTIM ADC Extended Trigger Register
	__IO uint32_t ADCUR;		 // @124 HRTIM ADC Trigger Update Register
	__IO uint32_t ADCPS1;		 // @128 HRTIM ADC Post Scaler Register 1
	__IO uint32_t ADCPS2;		 // @132 HRTIM ADC Post Scaler Register 2
	__IO uint32_t FLTINR3;		 // @136 HRTIM Fault Input Register 3
	__IO uint16_t FLTINR4;		 // @140 HRTIM Fault Input Register 4
};

// HRTIM_Common->CR1 Control Register 1
enum {
	HRTIM_COMMON_CR1_AD4USRC = ((1UL << 3) - 1) << 25,	// ADC Trigger 4 Update Source
	HRTIM_COMMON_CR1_AD3USRC = ((1UL << 3) - 1) << 22,	// ADC Trigger 3 Update Source
	HRTIM_COMMON_CR1_AD2USRC = ((1UL << 3) - 1) << 19,	// ADC Trigger 2 Update Source
	HRTIM_COMMON_CR1_AD1USRC = ((1UL << 3) - 1) << 16,	// ADC Trigger 1 Update Source
	HRTIM_COMMON_CR1_TFUDIS	 = 1UL << 6,				// Timer f Update Disable
	HRTIM_COMMON_CR1_TEUDIS	 = 1UL << 5,				// Timer E Update Disable
	HRTIM_COMMON_CR1_TDUDIS	 = 1UL << 4,				// Timer D Update Disable
	HRTIM_COMMON_CR1_TCUDIS	 = 1UL << 3,				// Timer C Update Disable
	HRTIM_COMMON_CR1_TBUDIS	 = 1UL << 2,				// Timer B Update Disable
	HRTIM_COMMON_CR1_TAUDIS	 = 1UL << 1,				// Timer A Update Disable
	HRTIM_COMMON_CR1_MUDIS	 = 1UL << 0,				// Master Update Disable
};
inline void hrtim_common_cr1_set_ad4usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD4USRC) | ((val << 25) & HRTIM_COMMON_CR1_AD4USRC);
}
inline void hrtim_common_cr1_set_ad3usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD3USRC) | ((val << 22) & HRTIM_COMMON_CR1_AD3USRC);
}
inline void hrtim_common_cr1_set_ad2usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD2USRC) | ((val << 19) & HRTIM_COMMON_CR1_AD2USRC);
}
inline void hrtim_common_cr1_set_ad1usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->CR1 = (p->CR1 & ~HRTIM_COMMON_CR1_AD1USRC) | ((val << 16) & HRTIM_COMMON_CR1_AD1USRC);
}
inline uint32_t hrtim_common_cr1_get_ad4usrc(struct HRTIM_Common_Type *p) { return (p->CR1 & HRTIM_COMMON_CR1_AD4USRC) >> 25; }
inline uint32_t hrtim_common_cr1_get_ad3usrc(struct HRTIM_Common_Type *p) { return (p->CR1 & HRTIM_COMMON_CR1_AD3USRC) >> 22; }
inline uint32_t hrtim_common_cr1_get_ad2usrc(struct HRTIM_Common_Type *p) { return (p->CR1 & HRTIM_COMMON_CR1_AD2USRC) >> 19; }
inline uint32_t hrtim_common_cr1_get_ad1usrc(struct HRTIM_Common_Type *p) { return (p->CR1 & HRTIM_COMMON_CR1_AD1USRC) >> 16; }

// HRTIM_Common->CR2 Control Register 2
enum {
	HRTIM_COMMON_CR2_SWPF  = 1UL << 21,	 // Swap Timer F outputs
	HRTIM_COMMON_CR2_SWPE  = 1UL << 20,	 // Swap Timer E outputs
	HRTIM_COMMON_CR2_SWPD  = 1UL << 19,	 // Swap Timer D outputs
	HRTIM_COMMON_CR2_SWPC  = 1UL << 18,	 // Swap Timer C outputs
	HRTIM_COMMON_CR2_SWPB  = 1UL << 17,	 // Swap Timer B outputs
	HRTIM_COMMON_CR2_SWPA  = 1UL << 16,	 // Swap Timer A outputs
	HRTIM_COMMON_CR2_TFRST = 1UL << 14,	 // Timer f counter software reset
	HRTIM_COMMON_CR2_TERST = 1UL << 13,	 // Timer E counter software reset
	HRTIM_COMMON_CR2_TDRST = 1UL << 12,	 // Timer D counter software reset
	HRTIM_COMMON_CR2_TCRST = 1UL << 11,	 // Timer C counter software reset
	HRTIM_COMMON_CR2_TBRST = 1UL << 10,	 // Timer B counter software reset
	HRTIM_COMMON_CR2_TARST = 1UL << 9,	 // Timer A counter software reset
	HRTIM_COMMON_CR2_MRST  = 1UL << 8,	 // Master Counter software reset
	HRTIM_COMMON_CR2_TFSWU = 1UL << 6,	 // Timer f Software Update
	HRTIM_COMMON_CR2_TESWU = 1UL << 5,	 // Timer E Software Update
	HRTIM_COMMON_CR2_TDSWU = 1UL << 4,	 // Timer D Software Update
	HRTIM_COMMON_CR2_TCSWU = 1UL << 3,	 // Timer C Software Update
	HRTIM_COMMON_CR2_TBSWU = 1UL << 2,	 // Timer B Software Update
	HRTIM_COMMON_CR2_TASWU = 1UL << 1,	 // Timer A Software update
	HRTIM_COMMON_CR2_MSWU  = 1UL << 0,	 // Master Timer Software update
};

// HRTIM_Common->ISR Interrupt Status Register
enum {
	HRTIM_COMMON_ISR_BMPER	= 1UL << 17,  // Burst mode Period Interrupt Flag
	HRTIM_COMMON_ISR_DLLRDY = 1UL << 16,  // DLL Ready Interrupt Flag
	HRTIM_COMMON_ISR_FLT6	= 1UL << 6,	  // Fault 6 Interrupt Flag
	HRTIM_COMMON_ISR_SYSFLT = 1UL << 5,	  // System Fault Interrupt Flag
	HRTIM_COMMON_ISR_FLT5	= 1UL << 4,	  // Fault 5 Interrupt Flag
	HRTIM_COMMON_ISR_FLT4	= 1UL << 3,	  // Fault 4 Interrupt Flag
	HRTIM_COMMON_ISR_FLT3	= 1UL << 2,	  // Fault 3 Interrupt Flag
	HRTIM_COMMON_ISR_FLT2	= 1UL << 1,	  // Fault 2 Interrupt Flag
	HRTIM_COMMON_ISR_FLT1	= 1UL << 0,	  // Fault 1 Interrupt Flag
};

// HRTIM_Common->ICR Interrupt Clear Register
enum {
	HRTIM_COMMON_ICR_BMPERC	 = 1UL << 17,  // Burst mode period flag Clear
	HRTIM_COMMON_ICR_DLLRDYC = 1UL << 16,  // DLL Ready Interrupt flag Clear
	HRTIM_COMMON_ICR_FLT6C	 = 1UL << 6,   // Fault 6 Interrupt Flag Clear
	HRTIM_COMMON_ICR_SYSFLTC = 1UL << 5,   // System Fault Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT5C	 = 1UL << 4,   // Fault 5 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT4C	 = 1UL << 3,   // Fault 4 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT3C	 = 1UL << 2,   // Fault 3 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT2C	 = 1UL << 1,   // Fault 2 Interrupt Flag Clear
	HRTIM_COMMON_ICR_FLT1C	 = 1UL << 0,   // Fault 1 Interrupt Flag Clear
};

// HRTIM_Common->IER Interrupt Enable Register
enum {
	HRTIM_COMMON_IER_BMPERIE  = 1UL << 17,	// Burst mode period Interrupt Enable
	HRTIM_COMMON_IER_DLLRDYIE = 1UL << 16,	// DLL Ready Interrupt Enable
	HRTIM_COMMON_IER_FLT6IE	  = 1UL << 6,	// Fault 6 Interrupt Enable
	HRTIM_COMMON_IER_SYSFLTE  = 1UL << 5,	// System Fault Interrupt Enable
	HRTIM_COMMON_IER_FLT5IE	  = 1UL << 4,	// Fault 5 Interrupt Enable
	HRTIM_COMMON_IER_FLT4IE	  = 1UL << 3,	// Fault 4 Interrupt Enable
	HRTIM_COMMON_IER_FLT3IE	  = 1UL << 2,	// Fault 3 Interrupt Enable
	HRTIM_COMMON_IER_FLT2IE	  = 1UL << 1,	// Fault 2 Interrupt Enable
	HRTIM_COMMON_IER_FLT1IE	  = 1UL << 0,	// Fault 1 Interrupt Enable
};

// HRTIM_Common->OENR Output Enable Register
enum {
	HRTIM_COMMON_OENR_TF2ODS = 1UL << 11,  // Timer F Output 2 disable status
	HRTIM_COMMON_OENR_TF1ODS = 1UL << 10,  // Timer F Output 1 disable status
	HRTIM_COMMON_OENR_TE2OEN = 1UL << 9,   // Timer E Output 2 Enable
	HRTIM_COMMON_OENR_TE1OEN = 1UL << 8,   // Timer E Output 1 Enable
	HRTIM_COMMON_OENR_TD2OEN = 1UL << 7,   // Timer D Output 2 Enable
	HRTIM_COMMON_OENR_TD1OEN = 1UL << 6,   // Timer D Output 1 Enable
	HRTIM_COMMON_OENR_TC2OEN = 1UL << 5,   // Timer C Output 2 Enable
	HRTIM_COMMON_OENR_TC1OEN = 1UL << 4,   // Timer C Output 1 Enable
	HRTIM_COMMON_OENR_TB2OEN = 1UL << 3,   // Timer B Output 2 Enable
	HRTIM_COMMON_OENR_TB1OEN = 1UL << 2,   // Timer B Output 1 Enable
	HRTIM_COMMON_OENR_TA2OEN = 1UL << 1,   // Timer A Output 2 Enable
	HRTIM_COMMON_OENR_TA1OEN = 1UL << 0,   // Timer A Output 1 Enable
};

// HRTIM_Common->ODISR ODISR
enum {
	HRTIM_COMMON_ODISR_TF2ODIS = 1UL << 11,	 // TF2ODIS
	HRTIM_COMMON_ODISR_TF1ODIS = 1UL << 10,	 // TF1ODIS
	HRTIM_COMMON_ODISR_TE2ODIS = 1UL << 9,	 // TE2ODIS
	HRTIM_COMMON_ODISR_TE1ODIS = 1UL << 8,	 // TE1ODIS
	HRTIM_COMMON_ODISR_TD2ODIS = 1UL << 7,	 // TD2ODIS
	HRTIM_COMMON_ODISR_TD1ODIS = 1UL << 6,	 // TD1ODIS
	HRTIM_COMMON_ODISR_TC2ODIS = 1UL << 5,	 // TC2ODIS
	HRTIM_COMMON_ODISR_TC1ODIS = 1UL << 4,	 // TC1ODIS
	HRTIM_COMMON_ODISR_TB2ODIS = 1UL << 3,	 // TB2ODIS
	HRTIM_COMMON_ODISR_TB1ODIS = 1UL << 2,	 // TB1ODIS
	HRTIM_COMMON_ODISR_TA2ODIS = 1UL << 1,	 // TA2ODIS
	HRTIM_COMMON_ODISR_TA1ODIS = 1UL << 0,	 // TA1ODIS
};

// HRTIM_Common->ODSR Output Disable Status Register
enum {
	HRTIM_COMMON_ODSR_TF2ODS = 1UL << 11,  // TF2ODS
	HRTIM_COMMON_ODSR_TF1ODS = 1UL << 10,  // TF1ODS
	HRTIM_COMMON_ODSR_TE2ODS = 1UL << 9,   // Timer E Output 2 disable status
	HRTIM_COMMON_ODSR_TE1ODS = 1UL << 8,   // Timer E Output 1 disable status
	HRTIM_COMMON_ODSR_TD2ODS = 1UL << 7,   // Timer D Output 2 disable status
	HRTIM_COMMON_ODSR_TD1ODS = 1UL << 6,   // Timer D Output 1 disable status
	HRTIM_COMMON_ODSR_TC2ODS = 1UL << 5,   // Timer C Output 2 disable status
	HRTIM_COMMON_ODSR_TC1ODS = 1UL << 4,   // Timer C Output 1 disable status
	HRTIM_COMMON_ODSR_TB2ODS = 1UL << 3,   // Timer B Output 2 disable status
	HRTIM_COMMON_ODSR_TB1ODS = 1UL << 2,   // Timer B Output 1 disable status
	HRTIM_COMMON_ODSR_TA2ODS = 1UL << 1,   // Timer A Output 2 disable status
	HRTIM_COMMON_ODSR_TA1ODS = 1UL << 0,   // Timer A Output 1 disable status
};

// HRTIM_Common->BMCR Burst Mode Control Register
enum {
	HRTIM_COMMON_BMCR_BMSTAT = 1UL << 31,			   // Burst Mode Status
	HRTIM_COMMON_BMCR_TFBM	 = 1UL << 22,			   // Timer f Burst Mode
	HRTIM_COMMON_BMCR_TEBM	 = 1UL << 21,			   // Timer E Burst Mode
	HRTIM_COMMON_BMCR_TDBM	 = 1UL << 20,			   // Timer D Burst Mode
	HRTIM_COMMON_BMCR_TCBM	 = 1UL << 19,			   // Timer C Burst Mode
	HRTIM_COMMON_BMCR_TBBM	 = 1UL << 18,			   // Timer B Burst Mode
	HRTIM_COMMON_BMCR_TABM	 = 1UL << 17,			   // Timer A Burst Mode
	HRTIM_COMMON_BMCR_MTBM	 = 1UL << 16,			   // Master Timer Burst Mode
	HRTIM_COMMON_BMCR_BMPREN = 1UL << 10,			   // Burst Mode Preload Enable
	HRTIM_COMMON_BMCR_BMPRSC = ((1UL << 4) - 1) << 6,  // Burst Mode Prescaler
	HRTIM_COMMON_BMCR_BMCLK	 = ((1UL << 4) - 1) << 2,  // Burst Mode Clock source
	HRTIM_COMMON_BMCR_BMOM	 = 1UL << 1,			   // Burst Mode operating mode
	HRTIM_COMMON_BMCR_BME	 = 1UL << 0,			   // Burst Mode enable
};
inline void hrtim_common_bmcr_set_bmprsc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->BMCR = (p->BMCR & ~HRTIM_COMMON_BMCR_BMPRSC) | ((val << 6) & HRTIM_COMMON_BMCR_BMPRSC);
}
inline void hrtim_common_bmcr_set_bmclk(struct HRTIM_Common_Type *p, uint32_t val) {
	p->BMCR = (p->BMCR & ~HRTIM_COMMON_BMCR_BMCLK) | ((val << 2) & HRTIM_COMMON_BMCR_BMCLK);
}
inline uint32_t hrtim_common_bmcr_get_bmprsc(struct HRTIM_Common_Type *p) { return (p->BMCR & HRTIM_COMMON_BMCR_BMPRSC) >> 6; }
inline uint32_t hrtim_common_bmcr_get_bmclk(struct HRTIM_Common_Type *p) { return (p->BMCR & HRTIM_COMMON_BMCR_BMCLK) >> 2; }

// HRTIM_Common->BMTRG BMTRG
enum {
	HRTIM_COMMON_BMTRG_OCHPEV  = 1UL << 31,	 // OCHPEV
	HRTIM_COMMON_BMTRG_EEV8	   = 1UL << 30,	 // EEV8
	HRTIM_COMMON_BMTRG_EEV7	   = 1UL << 29,	 // EEV7
	HRTIM_COMMON_BMTRG_TDEEV8  = 1UL << 28,	 // TDEEV8
	HRTIM_COMMON_BMTRG_TDEEV7  = 1UL << 27,	 // TDEEV7
	HRTIM_COMMON_BMTRG_TECMP2  = 1UL << 26,	 // TECMP2
	HRTIM_COMMON_BMTRG_TECMP1  = 1UL << 25,	 // TECMP1
	HRTIM_COMMON_BMTRG_TEREP   = 1UL << 24,	 // TEREP
	HRTIM_COMMON_BMTRG_TERST   = 1UL << 23,	 // TERST
	HRTIM_COMMON_BMTRG_TDCMP2  = 1UL << 22,	 // TDCMP2
	HRTIM_COMMON_BMTRG_TDCMP1  = 1UL << 21,	 // TDCMP1
	HRTIM_COMMON_BMTRG_TDREP   = 1UL << 20,	 // TDREP
	HRTIM_COMMON_BMTRG_TDRST   = 1UL << 19,	 // TDRST
	HRTIM_COMMON_BMTRG_TCCMP2  = 1UL << 18,	 // TCCMP2
	HRTIM_COMMON_BMTRG_TCCMP1  = 1UL << 17,	 // TCCMP1
	HRTIM_COMMON_BMTRG_TCREP   = 1UL << 16,	 // TCREP
	HRTIM_COMMON_BMTRG_TCRST   = 1UL << 15,	 // TCRST
	HRTIM_COMMON_BMTRG_TBCMP2  = 1UL << 14,	 // TBCMP2
	HRTIM_COMMON_BMTRG_TBCMP1  = 1UL << 13,	 // TBCMP1
	HRTIM_COMMON_BMTRG_TBREP   = 1UL << 12,	 // TBREP
	HRTIM_COMMON_BMTRG_TBRST   = 1UL << 11,	 // TBRST
	HRTIM_COMMON_BMTRG_TACMP2  = 1UL << 10,	 // TACMP2
	HRTIM_COMMON_BMTRG_TACMP1  = 1UL << 9,	 // TACMP1
	HRTIM_COMMON_BMTRG_TAREP   = 1UL << 8,	 // TAREP
	HRTIM_COMMON_BMTRG_TARST   = 1UL << 7,	 // TARST
	HRTIM_COMMON_BMTRG_MSTCMP4 = 1UL << 6,	 // MSTCMP4
	HRTIM_COMMON_BMTRG_MSTCMP3 = 1UL << 5,	 // MSTCMP3
	HRTIM_COMMON_BMTRG_MSTCMP2 = 1UL << 4,	 // MSTCMP2
	HRTIM_COMMON_BMTRG_MSTCMP1 = 1UL << 3,	 // MSTCMP1
	HRTIM_COMMON_BMTRG_MSTREP  = 1UL << 2,	 // MSTREP
	HRTIM_COMMON_BMTRG_MSTRST  = 1UL << 1,	 // MSTRST
	HRTIM_COMMON_BMTRG_SW	   = 1UL << 0,	 // SW
};

// HRTIM_Common->EECR1 Timer External Event Control Register 1
enum {
	HRTIM_COMMON_EECR1_EE5FAST = 1UL << 29,				  // External Event 5 Fast mode
	HRTIM_COMMON_EECR1_EE5SNS  = ((1UL << 2) - 1) << 27,  // External Event 5 Sensitivity
	HRTIM_COMMON_EECR1_EE5POL  = 1UL << 26,				  // External Event 5 Polarity
	HRTIM_COMMON_EECR1_EE5SRC  = ((1UL << 2) - 1) << 24,  // External Event 5 Source
	HRTIM_COMMON_EECR1_EE4FAST = 1UL << 23,				  // External Event 4 Fast mode
	HRTIM_COMMON_EECR1_EE4SNS  = ((1UL << 2) - 1) << 21,  // External Event 4 Sensitivity
	HRTIM_COMMON_EECR1_EE4POL  = 1UL << 20,				  // External Event 4 Polarity
	HRTIM_COMMON_EECR1_EE4SRC  = ((1UL << 2) - 1) << 18,  // External Event 4 Source
	HRTIM_COMMON_EECR1_EE3FAST = 1UL << 17,				  // External Event 3 Fast mode
	HRTIM_COMMON_EECR1_EE3SNS  = ((1UL << 2) - 1) << 15,  // External Event 3 Sensitivity
	HRTIM_COMMON_EECR1_EE3POL  = 1UL << 14,				  // External Event 3 Polarity
	HRTIM_COMMON_EECR1_EE3SRC  = ((1UL << 2) - 1) << 12,  // External Event 3 Source
	HRTIM_COMMON_EECR1_EE2FAST = 1UL << 11,				  // External Event 2 Fast mode
	HRTIM_COMMON_EECR1_EE2SNS  = ((1UL << 2) - 1) << 9,	  // External Event 2 Sensitivity
	HRTIM_COMMON_EECR1_EE2POL  = 1UL << 8,				  // External Event 2 Polarity
	HRTIM_COMMON_EECR1_EE2SRC  = ((1UL << 2) - 1) << 6,	  // External Event 2 Source
	HRTIM_COMMON_EECR1_EE1FAST = 1UL << 5,				  // External Event 1 Fast mode
	HRTIM_COMMON_EECR1_EE1SNS  = ((1UL << 2) - 1) << 3,	  // External Event 1 Sensitivity
	HRTIM_COMMON_EECR1_EE1POL  = 1UL << 2,				  // External Event 1 Polarity
	HRTIM_COMMON_EECR1_EE1SRC  = ((1UL << 2) - 1) << 0,	  // External Event 1 Source
};
inline void hrtim_common_eecr1_set_ee5sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE5SNS) | ((val << 27) & HRTIM_COMMON_EECR1_EE5SNS);
}
inline void hrtim_common_eecr1_set_ee5src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE5SRC) | ((val << 24) & HRTIM_COMMON_EECR1_EE5SRC);
}
inline void hrtim_common_eecr1_set_ee4sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE4SNS) | ((val << 21) & HRTIM_COMMON_EECR1_EE4SNS);
}
inline void hrtim_common_eecr1_set_ee4src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE4SRC) | ((val << 18) & HRTIM_COMMON_EECR1_EE4SRC);
}
inline void hrtim_common_eecr1_set_ee3sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE3SNS) | ((val << 15) & HRTIM_COMMON_EECR1_EE3SNS);
}
inline void hrtim_common_eecr1_set_ee3src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE3SRC) | ((val << 12) & HRTIM_COMMON_EECR1_EE3SRC);
}
inline void hrtim_common_eecr1_set_ee2sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE2SNS) | ((val << 9) & HRTIM_COMMON_EECR1_EE2SNS);
}
inline void hrtim_common_eecr1_set_ee2src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE2SRC) | ((val << 6) & HRTIM_COMMON_EECR1_EE2SRC);
}
inline void hrtim_common_eecr1_set_ee1sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE1SNS) | ((val << 3) & HRTIM_COMMON_EECR1_EE1SNS);
}
inline void hrtim_common_eecr1_set_ee1src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR1 = (p->EECR1 & ~HRTIM_COMMON_EECR1_EE1SRC) | ((val << 0) & HRTIM_COMMON_EECR1_EE1SRC);
}
inline uint32_t hrtim_common_eecr1_get_ee5sns(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE5SNS) >> 27; }
inline uint32_t hrtim_common_eecr1_get_ee5src(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE5SRC) >> 24; }
inline uint32_t hrtim_common_eecr1_get_ee4sns(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE4SNS) >> 21; }
inline uint32_t hrtim_common_eecr1_get_ee4src(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE4SRC) >> 18; }
inline uint32_t hrtim_common_eecr1_get_ee3sns(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE3SNS) >> 15; }
inline uint32_t hrtim_common_eecr1_get_ee3src(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE3SRC) >> 12; }
inline uint32_t hrtim_common_eecr1_get_ee2sns(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE2SNS) >> 9; }
inline uint32_t hrtim_common_eecr1_get_ee2src(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE2SRC) >> 6; }
inline uint32_t hrtim_common_eecr1_get_ee1sns(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE1SNS) >> 3; }
inline uint32_t hrtim_common_eecr1_get_ee1src(struct HRTIM_Common_Type *p) { return (p->EECR1 & HRTIM_COMMON_EECR1_EE1SRC) >> 0; }

// HRTIM_Common->EECR2 Timer External Event Control Register 2
enum {
	HRTIM_COMMON_EECR2_EE10SNS = ((1UL << 2) - 1) << 27,  // EE10SNS
	HRTIM_COMMON_EECR2_EE10POL = 1UL << 26,				  // EE10POL
	HRTIM_COMMON_EECR2_EE10SRC = ((1UL << 2) - 1) << 24,  // EE10SRC
	HRTIM_COMMON_EECR2_EE9SNS  = ((1UL << 2) - 1) << 21,  // EE9SNS
	HRTIM_COMMON_EECR2_EE9POL  = 1UL << 20,				  // EE9POL
	HRTIM_COMMON_EECR2_EE9SRC  = ((1UL << 2) - 1) << 18,  // EE9SRC
	HRTIM_COMMON_EECR2_EE8SNS  = ((1UL << 2) - 1) << 15,  // EE8SNS
	HRTIM_COMMON_EECR2_EE8POL  = 1UL << 14,				  // EE8POL
	HRTIM_COMMON_EECR2_EE8SRC  = ((1UL << 2) - 1) << 12,  // EE8SRC
	HRTIM_COMMON_EECR2_EE7SNS  = ((1UL << 2) - 1) << 9,	  // EE7SNS
	HRTIM_COMMON_EECR2_EE7POL  = 1UL << 8,				  // EE7POL
	HRTIM_COMMON_EECR2_EE7SRC  = ((1UL << 2) - 1) << 6,	  // EE7SRC
	HRTIM_COMMON_EECR2_EE6SNS  = ((1UL << 2) - 1) << 3,	  // EE6SNS
	HRTIM_COMMON_EECR2_EE6POL  = 1UL << 2,				  // EE6POL
	HRTIM_COMMON_EECR2_EE6SRC  = ((1UL << 2) - 1) << 0,	  // EE6SRC
};
inline void hrtim_common_eecr2_set_ee10sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE10SNS) | ((val << 27) & HRTIM_COMMON_EECR2_EE10SNS);
}
inline void hrtim_common_eecr2_set_ee10src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE10SRC) | ((val << 24) & HRTIM_COMMON_EECR2_EE10SRC);
}
inline void hrtim_common_eecr2_set_ee9sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE9SNS) | ((val << 21) & HRTIM_COMMON_EECR2_EE9SNS);
}
inline void hrtim_common_eecr2_set_ee9src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE9SRC) | ((val << 18) & HRTIM_COMMON_EECR2_EE9SRC);
}
inline void hrtim_common_eecr2_set_ee8sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE8SNS) | ((val << 15) & HRTIM_COMMON_EECR2_EE8SNS);
}
inline void hrtim_common_eecr2_set_ee8src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE8SRC) | ((val << 12) & HRTIM_COMMON_EECR2_EE8SRC);
}
inline void hrtim_common_eecr2_set_ee7sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE7SNS) | ((val << 9) & HRTIM_COMMON_EECR2_EE7SNS);
}
inline void hrtim_common_eecr2_set_ee7src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE7SRC) | ((val << 6) & HRTIM_COMMON_EECR2_EE7SRC);
}
inline void hrtim_common_eecr2_set_ee6sns(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE6SNS) | ((val << 3) & HRTIM_COMMON_EECR2_EE6SNS);
}
inline void hrtim_common_eecr2_set_ee6src(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR2 = (p->EECR2 & ~HRTIM_COMMON_EECR2_EE6SRC) | ((val << 0) & HRTIM_COMMON_EECR2_EE6SRC);
}
inline uint32_t hrtim_common_eecr2_get_ee10sns(struct HRTIM_Common_Type *p) {
	return (p->EECR2 & HRTIM_COMMON_EECR2_EE10SNS) >> 27;
}
inline uint32_t hrtim_common_eecr2_get_ee10src(struct HRTIM_Common_Type *p) {
	return (p->EECR2 & HRTIM_COMMON_EECR2_EE10SRC) >> 24;
}
inline uint32_t hrtim_common_eecr2_get_ee9sns(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE9SNS) >> 21; }
inline uint32_t hrtim_common_eecr2_get_ee9src(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE9SRC) >> 18; }
inline uint32_t hrtim_common_eecr2_get_ee8sns(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE8SNS) >> 15; }
inline uint32_t hrtim_common_eecr2_get_ee8src(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE8SRC) >> 12; }
inline uint32_t hrtim_common_eecr2_get_ee7sns(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE7SNS) >> 9; }
inline uint32_t hrtim_common_eecr2_get_ee7src(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE7SRC) >> 6; }
inline uint32_t hrtim_common_eecr2_get_ee6sns(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE6SNS) >> 3; }
inline uint32_t hrtim_common_eecr2_get_ee6src(struct HRTIM_Common_Type *p) { return (p->EECR2 & HRTIM_COMMON_EECR2_EE6SRC) >> 0; }

// HRTIM_Common->EECR3 Timer External Event Control Register 3
enum {
	HRTIM_COMMON_EECR3_EEVSD = ((1UL << 2) - 1) << 30,	// EEVSD
	HRTIM_COMMON_EECR3_EE10F = ((1UL << 4) - 1) << 24,	// EE10F
	HRTIM_COMMON_EECR3_EE9F	 = ((1UL << 4) - 1) << 18,	// EE9F
	HRTIM_COMMON_EECR3_EE8F	 = ((1UL << 4) - 1) << 12,	// EE8F
	HRTIM_COMMON_EECR3_EE7F	 = ((1UL << 4) - 1) << 6,	// EE7F
	HRTIM_COMMON_EECR3_EE6F	 = ((1UL << 4) - 1) << 0,	// EE6F
};
inline void hrtim_common_eecr3_set_eevsd(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EEVSD) | ((val << 30) & HRTIM_COMMON_EECR3_EEVSD);
}
inline void hrtim_common_eecr3_set_ee10f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE10F) | ((val << 24) & HRTIM_COMMON_EECR3_EE10F);
}
inline void hrtim_common_eecr3_set_ee9f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE9F) | ((val << 18) & HRTIM_COMMON_EECR3_EE9F);
}
inline void hrtim_common_eecr3_set_ee8f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE8F) | ((val << 12) & HRTIM_COMMON_EECR3_EE8F);
}
inline void hrtim_common_eecr3_set_ee7f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE7F) | ((val << 6) & HRTIM_COMMON_EECR3_EE7F);
}
inline void hrtim_common_eecr3_set_ee6f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->EECR3 = (p->EECR3 & ~HRTIM_COMMON_EECR3_EE6F) | ((val << 0) & HRTIM_COMMON_EECR3_EE6F);
}
inline uint32_t hrtim_common_eecr3_get_eevsd(struct HRTIM_Common_Type *p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EEVSD) >> 30; }
inline uint32_t hrtim_common_eecr3_get_ee10f(struct HRTIM_Common_Type *p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE10F) >> 24; }
inline uint32_t hrtim_common_eecr3_get_ee9f(struct HRTIM_Common_Type *p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE9F) >> 18; }
inline uint32_t hrtim_common_eecr3_get_ee8f(struct HRTIM_Common_Type *p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE8F) >> 12; }
inline uint32_t hrtim_common_eecr3_get_ee7f(struct HRTIM_Common_Type *p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE7F) >> 6; }
inline uint32_t hrtim_common_eecr3_get_ee6f(struct HRTIM_Common_Type *p) { return (p->EECR3 & HRTIM_COMMON_EECR3_EE6F) >> 0; }

// HRTIM_Common->ADC1R ADC Trigger 1 Register
enum {
	HRTIM_COMMON_ADC1R_AD1TEPER = 1UL << 31,  // ADC trigger 1 on Timer E Period
	HRTIM_COMMON_ADC1R_AD1TEC4	= 1UL << 30,  // ADC trigger 1 on Timer E compare 4
	HRTIM_COMMON_ADC1R_AD1TEC3	= 1UL << 29,  // ADC trigger 1 on Timer E compare 3
	HRTIM_COMMON_ADC1R_AD1TEC2	= 1UL << 28,  // ADC trigger 1 on Timer E compare 2
	HRTIM_COMMON_ADC1R_AD1TDPER = 1UL << 27,  // ADC trigger 1 on Timer D Period
	HRTIM_COMMON_ADC1R_AD1TDC4	= 1UL << 26,  // ADC trigger 1 on Timer D compare 4
	HRTIM_COMMON_ADC1R_AD1TDC3	= 1UL << 25,  // ADC trigger 1 on Timer D compare 3
	HRTIM_COMMON_ADC1R_AD1TDC2	= 1UL << 24,  // ADC trigger 1 on Timer D compare 2
	HRTIM_COMMON_ADC1R_AD1TCPER = 1UL << 23,  // ADC trigger 1 on Timer C Period
	HRTIM_COMMON_ADC1R_AD1TCC4	= 1UL << 22,  // ADC trigger 1 on Timer C compare 4
	HRTIM_COMMON_ADC1R_AD1TCC3	= 1UL << 21,  // ADC trigger 1 on Timer C compare 3
	HRTIM_COMMON_ADC1R_AD1TCC2	= 1UL << 20,  // ADC trigger 1 on Timer C compare 2
	HRTIM_COMMON_ADC1R_AD1TBRST = 1UL << 19,  // ADC trigger 1 on Timer B Reset
	HRTIM_COMMON_ADC1R_AD1TBPER = 1UL << 18,  // ADC trigger 1 on Timer B Period
	HRTIM_COMMON_ADC1R_AD1TBC4	= 1UL << 17,  // ADC trigger 1 on Timer B compare 4
	HRTIM_COMMON_ADC1R_AD1TBC3	= 1UL << 16,  // ADC trigger 1 on Timer B compare 3
	HRTIM_COMMON_ADC1R_AD1TBC2	= 1UL << 15,  // ADC trigger 1 on Timer B compare 2
	HRTIM_COMMON_ADC1R_AD1TARST = 1UL << 14,  // ADC trigger 1 on Timer A Reset
	HRTIM_COMMON_ADC1R_AD1TAPER = 1UL << 13,  // ADC trigger 1 on Timer A Period
	HRTIM_COMMON_ADC1R_AD1TAC4	= 1UL << 12,  // ADC trigger 1 on Timer A compare 4
	HRTIM_COMMON_ADC1R_AD1TAC3	= 1UL << 11,  // ADC trigger 1 on Timer A compare 3
	HRTIM_COMMON_ADC1R_AD1TAC2	= 1UL << 10,  // ADC trigger 1 on Timer A compare 2
	HRTIM_COMMON_ADC1R_AD1EEV5	= 1UL << 9,	  // ADC trigger 1 on External Event 5
	HRTIM_COMMON_ADC1R_AD1EEV4	= 1UL << 8,	  // ADC trigger 1 on External Event 4
	HRTIM_COMMON_ADC1R_AD1EEV3	= 1UL << 7,	  // ADC trigger 1 on External Event 3
	HRTIM_COMMON_ADC1R_AD1EEV2	= 1UL << 6,	  // ADC trigger 1 on External Event 2
	HRTIM_COMMON_ADC1R_AD1EEV1	= 1UL << 5,	  // ADC trigger 1 on External Event 1
	HRTIM_COMMON_ADC1R_AD1MPER	= 1UL << 4,	  // ADC trigger 1 on Master Period
	HRTIM_COMMON_ADC1R_AD1MC4	= 1UL << 3,	  // ADC trigger 1 on Master Compare 4
	HRTIM_COMMON_ADC1R_AD1MC3	= 1UL << 2,	  // ADC trigger 1 on Master Compare 3
	HRTIM_COMMON_ADC1R_AD1MC2	= 1UL << 1,	  // ADC trigger 1 on Master Compare 2
	HRTIM_COMMON_ADC1R_AD1MC1	= 1UL << 0,	  // ADC trigger 1 on Master Compare 1
};

// HRTIM_Common->ADC2R ADC Trigger 2 Register
enum {
	HRTIM_COMMON_ADC2R_AD2TERST = 1UL << 31,  // ADC trigger 2 on Timer E Reset
	HRTIM_COMMON_ADC2R_AD2TEC4	= 1UL << 30,  // ADC trigger 2 on Timer E compare 4
	HRTIM_COMMON_ADC2R_AD2TEC3	= 1UL << 29,  // ADC trigger 2 on Timer E compare 3
	HRTIM_COMMON_ADC2R_AD2TEC2	= 1UL << 28,  // ADC trigger 2 on Timer E compare 2
	HRTIM_COMMON_ADC2R_AD2TDRST = 1UL << 27,  // ADC trigger 2 on Timer D Reset
	HRTIM_COMMON_ADC2R_AD2TDPER = 1UL << 26,  // ADC trigger 2 on Timer D Period
	HRTIM_COMMON_ADC2R_AD2TDC4	= 1UL << 25,  // ADC trigger 2 on Timer D compare 4
	HRTIM_COMMON_ADC2R_AD2TDC3	= 1UL << 24,  // ADC trigger 2 on Timer D compare 3
	HRTIM_COMMON_ADC2R_AD2TDC2	= 1UL << 23,  // ADC trigger 2 on Timer D compare 2
	HRTIM_COMMON_ADC2R_AD2TCRST = 1UL << 22,  // ADC trigger 2 on Timer C Reset
	HRTIM_COMMON_ADC2R_AD2TCPER = 1UL << 21,  // ADC trigger 2 on Timer C Period
	HRTIM_COMMON_ADC2R_AD2TCC4	= 1UL << 20,  // ADC trigger 2 on Timer C compare 4
	HRTIM_COMMON_ADC2R_AD2TCC3	= 1UL << 19,  // ADC trigger 2 on Timer C compare 3
	HRTIM_COMMON_ADC2R_AD2TCC2	= 1UL << 18,  // ADC trigger 2 on Timer C compare 2
	HRTIM_COMMON_ADC2R_AD2TBPER = 1UL << 17,  // ADC trigger 2 on Timer B Period
	HRTIM_COMMON_ADC2R_AD2TBC4	= 1UL << 16,  // ADC trigger 2 on Timer B compare 4
	HRTIM_COMMON_ADC2R_AD2TBC3	= 1UL << 15,  // ADC trigger 2 on Timer B compare 3
	HRTIM_COMMON_ADC2R_AD2TBC2	= 1UL << 14,  // ADC trigger 2 on Timer B compare 2
	HRTIM_COMMON_ADC2R_AD2TAPER = 1UL << 13,  // ADC trigger 2 on Timer A Period
	HRTIM_COMMON_ADC2R_AD2TAC4	= 1UL << 12,  // ADC trigger 2 on Timer A compare 4
	HRTIM_COMMON_ADC2R_AD2TAC3	= 1UL << 11,  // ADC trigger 2 on Timer A compare 3
	HRTIM_COMMON_ADC2R_AD2TAC2	= 1UL << 10,  // ADC trigger 2 on Timer A compare 2
	HRTIM_COMMON_ADC2R_AD2EEV10 = 1UL << 9,	  // ADC trigger 2 on External Event 10
	HRTIM_COMMON_ADC2R_AD2EEV9	= 1UL << 8,	  // ADC trigger 2 on External Event 9
	HRTIM_COMMON_ADC2R_AD2EEV8	= 1UL << 7,	  // ADC trigger 2 on External Event 8
	HRTIM_COMMON_ADC2R_AD2EEV7	= 1UL << 6,	  // ADC trigger 2 on External Event 7
	HRTIM_COMMON_ADC2R_AD2EEV6	= 1UL << 5,	  // ADC trigger 2 on External Event 6
	HRTIM_COMMON_ADC2R_AD2MPER	= 1UL << 4,	  // ADC trigger 2 on Master Period
	HRTIM_COMMON_ADC2R_AD2MC4	= 1UL << 3,	  // ADC trigger 2 on Master Compare 4
	HRTIM_COMMON_ADC2R_AD2MC3	= 1UL << 2,	  // ADC trigger 2 on Master Compare 3
	HRTIM_COMMON_ADC2R_AD2MC2	= 1UL << 1,	  // ADC trigger 2 on Master Compare 2
	HRTIM_COMMON_ADC2R_AD2MC1	= 1UL << 0,	  // ADC trigger 2 on Master Compare 1
};

// HRTIM_Common->ADC3R ADC Trigger 3 Register
enum {
	HRTIM_COMMON_ADC3R_AD1TEPER = 1UL << 31,  // AD1TEPER
	HRTIM_COMMON_ADC3R_AD1TEC4	= 1UL << 30,  // AD1TEC4
	HRTIM_COMMON_ADC3R_AD1TEC3	= 1UL << 29,  // AD1TEC3
	HRTIM_COMMON_ADC3R_AD1TEC2	= 1UL << 28,  // AD1TEC2
	HRTIM_COMMON_ADC3R_AD1TDPER = 1UL << 27,  // AD1TDPER
	HRTIM_COMMON_ADC3R_AD1TDC4	= 1UL << 26,  // AD1TDC4
	HRTIM_COMMON_ADC3R_AD1TDC3	= 1UL << 25,  // AD1TDC3
	HRTIM_COMMON_ADC3R_AD1TDC2	= 1UL << 24,  // AD1TDC2
	HRTIM_COMMON_ADC3R_AD1TCPER = 1UL << 23,  // AD1TCPER
	HRTIM_COMMON_ADC3R_AD1TCC4	= 1UL << 22,  // AD1TCC4
	HRTIM_COMMON_ADC3R_AD1TCC3	= 1UL << 21,  // AD1TCC3
	HRTIM_COMMON_ADC3R_AD1TCC2	= 1UL << 20,  // AD1TCC2
	HRTIM_COMMON_ADC3R_AD1TBRST = 1UL << 19,  // AD1TBRST
	HRTIM_COMMON_ADC3R_AD1TBPER = 1UL << 18,  // AD1TBPER
	HRTIM_COMMON_ADC3R_AD1TBC4	= 1UL << 17,  // AD1TBC4
	HRTIM_COMMON_ADC3R_AD1TBC3	= 1UL << 16,  // AD1TBC3
	HRTIM_COMMON_ADC3R_AD1TBC2	= 1UL << 15,  // AD1TBC2
	HRTIM_COMMON_ADC3R_AD1TARST = 1UL << 14,  // AD1TARST
	HRTIM_COMMON_ADC3R_AD1TAPER = 1UL << 13,  // AD1TAPER
	HRTIM_COMMON_ADC3R_AD1TAC4	= 1UL << 12,  // AD1TAC4
	HRTIM_COMMON_ADC3R_AD1TAC3	= 1UL << 11,  // AD1TAC3
	HRTIM_COMMON_ADC3R_AD1TAC2	= 1UL << 10,  // AD1TAC2
	HRTIM_COMMON_ADC3R_AD1EEV5	= 1UL << 9,	  // AD1EEV5
	HRTIM_COMMON_ADC3R_AD1EEV4	= 1UL << 8,	  // AD1EEV4
	HRTIM_COMMON_ADC3R_AD1EEV3	= 1UL << 7,	  // AD1EEV3
	HRTIM_COMMON_ADC3R_AD1EEV2	= 1UL << 6,	  // AD1EEV2
	HRTIM_COMMON_ADC3R_AD1EEV1	= 1UL << 5,	  // AD1EEV1
	HRTIM_COMMON_ADC3R_AD1MPER	= 1UL << 4,	  // AD1MPER
	HRTIM_COMMON_ADC3R_AD1MC4	= 1UL << 3,	  // AD1MC4
	HRTIM_COMMON_ADC3R_AD1MC3	= 1UL << 2,	  // AD1MC3
	HRTIM_COMMON_ADC3R_AD1MC2	= 1UL << 1,	  // AD1MC2
	HRTIM_COMMON_ADC3R_AD1MC1	= 1UL << 0,	  // AD1MC1
};

// HRTIM_Common->ADC4R ADC Trigger 4 Register
enum {
	HRTIM_COMMON_ADC4R_AD2TERST = 1UL << 31,  // AD2TERST
	HRTIM_COMMON_ADC4R_AD2TEC4	= 1UL << 30,  // AD2TEC4
	HRTIM_COMMON_ADC4R_AD2TEC3	= 1UL << 29,  // AD2TEC3
	HRTIM_COMMON_ADC4R_AD2TEC2	= 1UL << 28,  // AD2TEC2
	HRTIM_COMMON_ADC4R_AD2TDRST = 1UL << 27,  // AD2TDRST
	HRTIM_COMMON_ADC4R_AD2TDPER = 1UL << 26,  // AD2TDPER
	HRTIM_COMMON_ADC4R_AD2TDC4	= 1UL << 25,  // AD2TDC4
	HRTIM_COMMON_ADC4R_AD2TDC3	= 1UL << 24,  // AD2TDC3
	HRTIM_COMMON_ADC4R_AD2TDC2	= 1UL << 23,  // AD2TDC2
	HRTIM_COMMON_ADC4R_AD2TCRST = 1UL << 22,  // AD2TCRST
	HRTIM_COMMON_ADC4R_AD2TCPER = 1UL << 21,  // AD2TCPER
	HRTIM_COMMON_ADC4R_AD2TCC4	= 1UL << 20,  // AD2TCC4
	HRTIM_COMMON_ADC4R_AD2TCC3	= 1UL << 19,  // AD2TCC3
	HRTIM_COMMON_ADC4R_AD2TCC2	= 1UL << 18,  // AD2TCC2
	HRTIM_COMMON_ADC4R_AD2TBPER = 1UL << 17,  // AD2TBPER
	HRTIM_COMMON_ADC4R_AD2TBC4	= 1UL << 16,  // AD2TBC4
	HRTIM_COMMON_ADC4R_AD2TBC3	= 1UL << 15,  // AD2TBC3
	HRTIM_COMMON_ADC4R_AD2TBC2	= 1UL << 14,  // AD2TBC2
	HRTIM_COMMON_ADC4R_AD2TAPER = 1UL << 13,  // AD2TAPER
	HRTIM_COMMON_ADC4R_AD2TAC4	= 1UL << 12,  // AD2TAC4
	HRTIM_COMMON_ADC4R_AD2TAC3	= 1UL << 11,  // AD2TAC3
	HRTIM_COMMON_ADC4R_AD2TAC2	= 1UL << 10,  // AD2TAC2
	HRTIM_COMMON_ADC4R_AD2EEV10 = 1UL << 9,	  // AD2EEV10
	HRTIM_COMMON_ADC4R_AD2EEV9	= 1UL << 8,	  // AD2EEV9
	HRTIM_COMMON_ADC4R_AD2EEV8	= 1UL << 7,	  // AD2EEV8
	HRTIM_COMMON_ADC4R_AD2EEV7	= 1UL << 6,	  // AD2EEV7
	HRTIM_COMMON_ADC4R_AD2EEV6	= 1UL << 5,	  // AD2EEV6
	HRTIM_COMMON_ADC4R_AD2MPER	= 1UL << 4,	  // AD2MPER
	HRTIM_COMMON_ADC4R_AD2MC4	= 1UL << 3,	  // AD2MC4
	HRTIM_COMMON_ADC4R_AD2MC3	= 1UL << 2,	  // AD2MC3
	HRTIM_COMMON_ADC4R_AD2MC2	= 1UL << 1,	  // AD2MC2
	HRTIM_COMMON_ADC4R_AD2MC1	= 1UL << 0,	  // AD2MC1
};

// HRTIM_Common->DLLCR DLL Control Register
enum {
	HRTIM_COMMON_DLLCR_CALRTE = ((1UL << 2) - 1) << 2,	// DLL Calibration rate
	HRTIM_COMMON_DLLCR_CALEN  = 1UL << 1,				// DLL Calibration Enable
	HRTIM_COMMON_DLLCR_CAL	  = 1UL << 0,				// DLL Calibration Start
};
inline void hrtim_common_dllcr_set_calrte(struct HRTIM_Common_Type *p, uint32_t val) {
	p->DLLCR = (p->DLLCR & ~HRTIM_COMMON_DLLCR_CALRTE) | ((val << 2) & HRTIM_COMMON_DLLCR_CALRTE);
}
inline uint32_t hrtim_common_dllcr_get_calrte(struct HRTIM_Common_Type *p) { return (p->DLLCR & HRTIM_COMMON_DLLCR_CALRTE) >> 2; }

// HRTIM_Common->FLTINR1 HRTIM Fault Input Register 1
enum {
	HRTIM_COMMON_FLTINR1_FLT4LCK = 1UL << 31,				// FLT4LCK
	HRTIM_COMMON_FLTINR1_FLT4F	 = ((1UL << 4) - 1) << 27,	// FLT4F
	HRTIM_COMMON_FLTINR1_FLT4SRC = 1UL << 26,				// FLT4SRC
	HRTIM_COMMON_FLTINR1_FLT4P	 = 1UL << 25,				// FLT4P
	HRTIM_COMMON_FLTINR1_FLT4E	 = 1UL << 24,				// FLT4E
	HRTIM_COMMON_FLTINR1_FLT3LCK = 1UL << 23,				// FLT3LCK
	HRTIM_COMMON_FLTINR1_FLT3F	 = ((1UL << 4) - 1) << 19,	// FLT3F
	HRTIM_COMMON_FLTINR1_FLT3SRC = 1UL << 18,				// FLT3SRC
	HRTIM_COMMON_FLTINR1_FLT3P	 = 1UL << 17,				// FLT3P
	HRTIM_COMMON_FLTINR1_FLT3E	 = 1UL << 16,				// FLT3E
	HRTIM_COMMON_FLTINR1_FLT2LCK = 1UL << 15,				// FLT2LCK
	HRTIM_COMMON_FLTINR1_FLT2F	 = ((1UL << 4) - 1) << 11,	// FLT2F
	HRTIM_COMMON_FLTINR1_FLT2SRC = 1UL << 10,				// FLT2SRC
	HRTIM_COMMON_FLTINR1_FLT2P	 = 1UL << 9,				// FLT2P
	HRTIM_COMMON_FLTINR1_FLT2E	 = 1UL << 8,				// FLT2E
	HRTIM_COMMON_FLTINR1_FLT1LCK = 1UL << 7,				// FLT1LCK
	HRTIM_COMMON_FLTINR1_FLT1F	 = ((1UL << 4) - 1) << 3,	// FLT1F
	HRTIM_COMMON_FLTINR1_FLT1SRC = 1UL << 2,				// FLT1SRC
	HRTIM_COMMON_FLTINR1_FLT1P	 = 1UL << 1,				// FLT1P
	HRTIM_COMMON_FLTINR1_FLT1E	 = 1UL << 0,				// FLT1E
};
inline void hrtim_common_fltinr1_set_flt4f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT4F) | ((val << 27) & HRTIM_COMMON_FLTINR1_FLT4F);
}
inline void hrtim_common_fltinr1_set_flt3f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT3F) | ((val << 19) & HRTIM_COMMON_FLTINR1_FLT3F);
}
inline void hrtim_common_fltinr1_set_flt2f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT2F) | ((val << 11) & HRTIM_COMMON_FLTINR1_FLT2F);
}
inline void hrtim_common_fltinr1_set_flt1f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR1 = (p->FLTINR1 & ~HRTIM_COMMON_FLTINR1_FLT1F) | ((val << 3) & HRTIM_COMMON_FLTINR1_FLT1F);
}
inline uint32_t hrtim_common_fltinr1_get_flt4f(struct HRTIM_Common_Type *p) {
	return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT4F) >> 27;
}
inline uint32_t hrtim_common_fltinr1_get_flt3f(struct HRTIM_Common_Type *p) {
	return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT3F) >> 19;
}
inline uint32_t hrtim_common_fltinr1_get_flt2f(struct HRTIM_Common_Type *p) {
	return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT2F) >> 11;
}
inline uint32_t hrtim_common_fltinr1_get_flt1f(struct HRTIM_Common_Type *p) {
	return (p->FLTINR1 & HRTIM_COMMON_FLTINR1_FLT1F) >> 3;
}

// HRTIM_Common->FLTINR2 HRTIM Fault Input Register 2
enum {
	HRTIM_COMMON_FLTINR2_FLTSD	   = ((1UL << 2) - 1) << 24,  // FLTSD
	HRTIM_COMMON_FLTINR2_FLT6SRC_1 = 1UL << 21,				  // FLT6SRC
	HRTIM_COMMON_FLTINR2_FLT5SRC_1 = 1UL << 20,				  // FLT5SRC_1
	HRTIM_COMMON_FLTINR2_FLT4SRC_1 = 1UL << 19,				  // FLT4SRC_1
	HRTIM_COMMON_FLTINR2_FLT3SRC_1 = 1UL << 18,				  // FLT3SRC_1
	HRTIM_COMMON_FLTINR2_FLT2SRC_1 = 1UL << 17,				  // FLT2SRC_1
	HRTIM_COMMON_FLTINR2_FLT1SRC_1 = 1UL << 16,				  // FLT1SRC_1
	HRTIM_COMMON_FLTINR2_FLT6LCK   = 1UL << 15,				  // FLT6LCK
	HRTIM_COMMON_FLTINR2_FLT6F	   = ((1UL << 4) - 1) << 11,  // FLT6F
	HRTIM_COMMON_FLTINR2_FLT6SRC_0 = 1UL << 10,				  // FLT6F
	HRTIM_COMMON_FLTINR2_FLT6P	   = 1UL << 9,				  // FLT6P
	HRTIM_COMMON_FLTINR2_FLT6E	   = 1UL << 8,				  // FLT6E
	HRTIM_COMMON_FLTINR2_FLT5LCK   = 1UL << 7,				  // FLT5LCK
	HRTIM_COMMON_FLTINR2_FLT5F	   = ((1UL << 4) - 1) << 3,	  // FLT5F
	HRTIM_COMMON_FLTINR2_FLT5SRC   = 1UL << 2,				  // FLT5SRC
	HRTIM_COMMON_FLTINR2_FLT5P	   = 1UL << 1,				  // FLT5P
	HRTIM_COMMON_FLTINR2_FLT5E	   = 1UL << 0,				  // FLT5E
};
inline void hrtim_common_fltinr2_set_fltsd(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR2 = (p->FLTINR2 & ~HRTIM_COMMON_FLTINR2_FLTSD) | ((val << 24) & HRTIM_COMMON_FLTINR2_FLTSD);
}
inline void hrtim_common_fltinr2_set_flt6f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR2 = (p->FLTINR2 & ~HRTIM_COMMON_FLTINR2_FLT6F) | ((val << 11) & HRTIM_COMMON_FLTINR2_FLT6F);
}
inline void hrtim_common_fltinr2_set_flt5f(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR2 = (p->FLTINR2 & ~HRTIM_COMMON_FLTINR2_FLT5F) | ((val << 3) & HRTIM_COMMON_FLTINR2_FLT5F);
}
inline uint32_t hrtim_common_fltinr2_get_fltsd(struct HRTIM_Common_Type *p) {
	return (p->FLTINR2 & HRTIM_COMMON_FLTINR2_FLTSD) >> 24;
}
inline uint32_t hrtim_common_fltinr2_get_flt6f(struct HRTIM_Common_Type *p) {
	return (p->FLTINR2 & HRTIM_COMMON_FLTINR2_FLT6F) >> 11;
}
inline uint32_t hrtim_common_fltinr2_get_flt5f(struct HRTIM_Common_Type *p) {
	return (p->FLTINR2 & HRTIM_COMMON_FLTINR2_FLT5F) >> 3;
}

// HRTIM_Common->BDMUPDR BDMUPDR
enum {
	HRTIM_COMMON_BDMUPDR_MCMP4 = 1UL << 9,	// MCMP4
	HRTIM_COMMON_BDMUPDR_MCMP3 = 1UL << 8,	// MCMP3
	HRTIM_COMMON_BDMUPDR_MCMP2 = 1UL << 7,	// MCMP2
	HRTIM_COMMON_BDMUPDR_MCMP1 = 1UL << 6,	// MCMP1
	HRTIM_COMMON_BDMUPDR_MREP  = 1UL << 5,	// MREP
	HRTIM_COMMON_BDMUPDR_MPER  = 1UL << 4,	// MPER
	HRTIM_COMMON_BDMUPDR_MCNT  = 1UL << 3,	// MCNT
	HRTIM_COMMON_BDMUPDR_MDIER = 1UL << 2,	// MDIER
	HRTIM_COMMON_BDMUPDR_MICR  = 1UL << 1,	// MICR
	HRTIM_COMMON_BDMUPDR_MCR   = 1UL << 0,	// MCR
};

// HRTIM_Common->BDTAUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTAUPR_TIMXEEFR3 = 1UL << 22,	 // TIMxEEFR3
	HRTIM_COMMON_BDTAUPR_TIMXCR2   = 1UL << 21,	 // TIMxCR2
	HRTIM_COMMON_BDTAUPR_TIMXFLTR  = 1UL << 20,	 // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXOUTR  = 1UL << 19,	 // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCHPR  = 1UL << 18,	 // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXRSTR  = 1UL << 17,	 // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXEEFR2 = 1UL << 16,	 // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTAUPR_TIMXEEFR1 = 1UL << 15,	 // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTAUPR_TIMXRST2R = 1UL << 14,	 // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXSET2R = 1UL << 13,	 // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXRST1R = 1UL << 12,	 // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXSET1R = 1UL << 11,	 // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMX_DTXR = 1UL << 10,	 // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCMP4  = 1UL << 9,	 // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCMP3  = 1UL << 8,	 // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCMP2  = 1UL << 7,	 // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCMP1  = 1UL << 6,	 // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXREP   = 1UL << 5,	 // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXPER   = 1UL << 4,	 // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCNT   = 1UL << 3,	 // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXDIER  = 1UL << 2,	 // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTAUPR_TIMXICR   = 1UL << 1,	 // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTAUPR_TIMXCR	   = 1UL << 0,	 // HRTIM_TIMxCR register update enable
};

// HRTIM_Common->BDTBUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTBUPR_TIMXEEFR3 = 1UL << 22,	 // TIMxEEFR3
	HRTIM_COMMON_BDTBUPR_TIMXCR2   = 1UL << 21,	 // TIMxCR2
	HRTIM_COMMON_BDTBUPR_TIMXFLTR  = 1UL << 20,	 // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXOUTR  = 1UL << 19,	 // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCHPR  = 1UL << 18,	 // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXRSTR  = 1UL << 17,	 // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXEEFR2 = 1UL << 16,	 // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTBUPR_TIMXEEFR1 = 1UL << 15,	 // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTBUPR_TIMXRST2R = 1UL << 14,	 // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXSET2R = 1UL << 13,	 // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXRST1R = 1UL << 12,	 // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXSET1R = 1UL << 11,	 // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMX_DTXR = 1UL << 10,	 // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCMP4  = 1UL << 9,	 // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCMP3  = 1UL << 8,	 // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCMP2  = 1UL << 7,	 // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCMP1  = 1UL << 6,	 // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXREP   = 1UL << 5,	 // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXPER   = 1UL << 4,	 // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCNT   = 1UL << 3,	 // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXDIER  = 1UL << 2,	 // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTBUPR_TIMXICR   = 1UL << 1,	 // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTBUPR_TIMXCR	   = 1UL << 0,	 // HRTIM_TIMxCR register update enable
};

// HRTIM_Common->BDTCUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTCUPR_TIMXEEFR3 = 1UL << 22,	 // TIMxEEFR3
	HRTIM_COMMON_BDTCUPR_TIMXCR2   = 1UL << 21,	 // TIMxCR2
	HRTIM_COMMON_BDTCUPR_TIMXFLTR  = 1UL << 20,	 // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXOUTR  = 1UL << 19,	 // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCHPR  = 1UL << 18,	 // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXRSTR  = 1UL << 17,	 // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXEEFR2 = 1UL << 16,	 // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTCUPR_TIMXEEFR1 = 1UL << 15,	 // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTCUPR_TIMXRST2R = 1UL << 14,	 // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXSET2R = 1UL << 13,	 // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXRST1R = 1UL << 12,	 // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXSET1R = 1UL << 11,	 // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMX_DTXR = 1UL << 10,	 // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCMP4  = 1UL << 9,	 // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCMP3  = 1UL << 8,	 // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCMP2  = 1UL << 7,	 // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCMP1  = 1UL << 6,	 // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXREP   = 1UL << 5,	 // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXPER   = 1UL << 4,	 // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCNT   = 1UL << 3,	 // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXDIER  = 1UL << 2,	 // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTCUPR_TIMXICR   = 1UL << 1,	 // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTCUPR_TIMXCR	   = 1UL << 0,	 // HRTIM_TIMxCR register update enable
};

// HRTIM_Common->BDTDUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTDUPR_TIMXEEFR3 = 1UL << 22,	 // TIMxEEFR3
	HRTIM_COMMON_BDTDUPR_TIMXCR2   = 1UL << 21,	 // TIMxCR2
	HRTIM_COMMON_BDTDUPR_TIMXFLTR  = 1UL << 20,	 // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXOUTR  = 1UL << 19,	 // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCHPR  = 1UL << 18,	 // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXRSTR  = 1UL << 17,	 // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXEEFR2 = 1UL << 16,	 // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTDUPR_TIMXEEFR1 = 1UL << 15,	 // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTDUPR_TIMXRST2R = 1UL << 14,	 // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXSET2R = 1UL << 13,	 // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXRST1R = 1UL << 12,	 // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXSET1R = 1UL << 11,	 // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMX_DTXR = 1UL << 10,	 // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCMP4  = 1UL << 9,	 // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCMP3  = 1UL << 8,	 // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCMP2  = 1UL << 7,	 // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCMP1  = 1UL << 6,	 // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXREP   = 1UL << 5,	 // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXPER   = 1UL << 4,	 // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCNT   = 1UL << 3,	 // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXDIER  = 1UL << 2,	 // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTDUPR_TIMXICR   = 1UL << 1,	 // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTDUPR_TIMXCR	   = 1UL << 0,	 // HRTIM_TIMxCR register update enable
};

// HRTIM_Common->BDTEUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTEUPR_TIMXEEFR3 = 1UL << 22,	 // TIMxEEFR3
	HRTIM_COMMON_BDTEUPR_TIMXCR2   = 1UL << 21,	 // TIMxCR2
	HRTIM_COMMON_BDTEUPR_TIMXFLTR  = 1UL << 20,	 // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXOUTR  = 1UL << 19,	 // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCHPR  = 1UL << 18,	 // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXRSTR  = 1UL << 17,	 // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXEEFR2 = 1UL << 16,	 // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTEUPR_TIMXEEFR1 = 1UL << 15,	 // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTEUPR_TIMXRST2R = 1UL << 14,	 // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXSET2R = 1UL << 13,	 // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXRST1R = 1UL << 12,	 // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXSET1R = 1UL << 11,	 // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMX_DTXR = 1UL << 10,	 // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCMP4  = 1UL << 9,	 // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCMP3  = 1UL << 8,	 // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCMP2  = 1UL << 7,	 // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCMP1  = 1UL << 6,	 // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXREP   = 1UL << 5,	 // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXPER   = 1UL << 4,	 // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCNT   = 1UL << 3,	 // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXDIER  = 1UL << 2,	 // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTEUPR_TIMXICR   = 1UL << 1,	 // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTEUPR_TIMXCR	   = 1UL << 0,	 // HRTIM_TIMxCR register update enable
};

// HRTIM_Common->BDTFUPR Burst DMA Timerx update Register
enum {
	HRTIM_COMMON_BDTFUPR_TIMXEEFR3 = 1UL << 22,	 // TIMxEEFR3
	HRTIM_COMMON_BDTFUPR_TIMXCR2   = 1UL << 21,	 // TIMxCR2
	HRTIM_COMMON_BDTFUPR_TIMXFLTR  = 1UL << 20,	 // HRTIM_FLTxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXOUTR  = 1UL << 19,	 // HRTIM_OUTxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCHPR  = 1UL << 18,	 // HRTIM_CHPxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXRSTR  = 1UL << 17,	 // HRTIM_RSTxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXEEFR2 = 1UL << 16,	 // HRTIM_EEFxR2 register update enable
	HRTIM_COMMON_BDTFUPR_TIMXEEFR1 = 1UL << 15,	 // HRTIM_EEFxR1 register update enable
	HRTIM_COMMON_BDTFUPR_TIMXRST2R = 1UL << 14,	 // HRTIM_RST2xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXSET2R = 1UL << 13,	 // HRTIM_SET2xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXRST1R = 1UL << 12,	 // HRTIM_RST1xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXSET1R = 1UL << 11,	 // HRTIM_SET1xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMX_DTXR = 1UL << 10,	 // HRTIM_DTxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCMP4  = 1UL << 9,	 // HRTIM_CMP4xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCMP3  = 1UL << 8,	 // HRTIM_CMP3xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCMP2  = 1UL << 7,	 // HRTIM_CMP2xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCMP1  = 1UL << 6,	 // HRTIM_CMP1xR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXREP   = 1UL << 5,	 // HRTIM_REPxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXPER   = 1UL << 4,	 // HRTIM_PERxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCNT   = 1UL << 3,	 // HRTIM_CNTxR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXDIER  = 1UL << 2,	 // HRTIM_TIMxDIER register update enable
	HRTIM_COMMON_BDTFUPR_TIMXICR   = 1UL << 1,	 // HRTIM_TIMxICR register update enable
	HRTIM_COMMON_BDTFUPR_TIMXCR	   = 1UL << 0,	 // HRTIM_TIMxCR register update enable
};

// HRTIM_Common->ADCER HRTIM ADC Extended Trigger Register
enum {
	HRTIM_COMMON_ADCER_ADC10TRG = ((1UL << 5) - 1) << 26,  // ADC10TRG
	HRTIM_COMMON_ADCER_ADC9TRG	= ((1UL << 5) - 1) << 21,  // ADC9TRG
	HRTIM_COMMON_ADCER_ADC8TRG	= ((1UL << 5) - 1) << 16,  // ADC8TRG
	HRTIM_COMMON_ADCER_ADC7TRG	= ((1UL << 5) - 1) << 10,  // ADC7TRG
	HRTIM_COMMON_ADCER_ADC6TRG	= ((1UL << 5) - 1) << 5,   // ADC6TRG
	HRTIM_COMMON_ADCER_ADC5TRG	= ((1UL << 5) - 1) << 0,   // ADC5TRG
};
inline void hrtim_common_adcer_set_adc10trg(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCER = (p->ADCER & ~HRTIM_COMMON_ADCER_ADC10TRG) | ((val << 26) & HRTIM_COMMON_ADCER_ADC10TRG);
}
inline void hrtim_common_adcer_set_adc9trg(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCER = (p->ADCER & ~HRTIM_COMMON_ADCER_ADC9TRG) | ((val << 21) & HRTIM_COMMON_ADCER_ADC9TRG);
}
inline void hrtim_common_adcer_set_adc8trg(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCER = (p->ADCER & ~HRTIM_COMMON_ADCER_ADC8TRG) | ((val << 16) & HRTIM_COMMON_ADCER_ADC8TRG);
}
inline void hrtim_common_adcer_set_adc7trg(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCER = (p->ADCER & ~HRTIM_COMMON_ADCER_ADC7TRG) | ((val << 10) & HRTIM_COMMON_ADCER_ADC7TRG);
}
inline void hrtim_common_adcer_set_adc6trg(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCER = (p->ADCER & ~HRTIM_COMMON_ADCER_ADC6TRG) | ((val << 5) & HRTIM_COMMON_ADCER_ADC6TRG);
}
inline void hrtim_common_adcer_set_adc5trg(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCER = (p->ADCER & ~HRTIM_COMMON_ADCER_ADC5TRG) | ((val << 0) & HRTIM_COMMON_ADCER_ADC5TRG);
}
inline uint32_t hrtim_common_adcer_get_adc10trg(struct HRTIM_Common_Type *p) {
	return (p->ADCER & HRTIM_COMMON_ADCER_ADC10TRG) >> 26;
}
inline uint32_t hrtim_common_adcer_get_adc9trg(struct HRTIM_Common_Type *p) {
	return (p->ADCER & HRTIM_COMMON_ADCER_ADC9TRG) >> 21;
}
inline uint32_t hrtim_common_adcer_get_adc8trg(struct HRTIM_Common_Type *p) {
	return (p->ADCER & HRTIM_COMMON_ADCER_ADC8TRG) >> 16;
}
inline uint32_t hrtim_common_adcer_get_adc7trg(struct HRTIM_Common_Type *p) {
	return (p->ADCER & HRTIM_COMMON_ADCER_ADC7TRG) >> 10;
}
inline uint32_t hrtim_common_adcer_get_adc6trg(struct HRTIM_Common_Type *p) { return (p->ADCER & HRTIM_COMMON_ADCER_ADC6TRG) >> 5; }
inline uint32_t hrtim_common_adcer_get_adc5trg(struct HRTIM_Common_Type *p) { return (p->ADCER & HRTIM_COMMON_ADCER_ADC5TRG) >> 0; }

// HRTIM_Common->ADCUR HRTIM ADC Trigger Update Register
enum {
	HRTIM_COMMON_ADCUR_AD10USRC = ((1UL << 3) - 1) << 20,  // AD10USRC
	HRTIM_COMMON_ADCUR_AD9USRC	= ((1UL << 3) - 1) << 16,  // AD9USRC
	HRTIM_COMMON_ADCUR_AD8USRC	= ((1UL << 3) - 1) << 12,  // AD8USRC
	HRTIM_COMMON_ADCUR_AD7USRC	= ((1UL << 3) - 1) << 8,   // AD7USRC
	HRTIM_COMMON_ADCUR_AD6USRC	= ((1UL << 3) - 1) << 4,   // AD6USRC
	HRTIM_COMMON_ADCUR_AD5USRC	= ((1UL << 3) - 1) << 0,   // AD5USRC
};
inline void hrtim_common_adcur_set_ad10usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCUR = (p->ADCUR & ~HRTIM_COMMON_ADCUR_AD10USRC) | ((val << 20) & HRTIM_COMMON_ADCUR_AD10USRC);
}
inline void hrtim_common_adcur_set_ad9usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCUR = (p->ADCUR & ~HRTIM_COMMON_ADCUR_AD9USRC) | ((val << 16) & HRTIM_COMMON_ADCUR_AD9USRC);
}
inline void hrtim_common_adcur_set_ad8usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCUR = (p->ADCUR & ~HRTIM_COMMON_ADCUR_AD8USRC) | ((val << 12) & HRTIM_COMMON_ADCUR_AD8USRC);
}
inline void hrtim_common_adcur_set_ad7usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCUR = (p->ADCUR & ~HRTIM_COMMON_ADCUR_AD7USRC) | ((val << 8) & HRTIM_COMMON_ADCUR_AD7USRC);
}
inline void hrtim_common_adcur_set_ad6usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCUR = (p->ADCUR & ~HRTIM_COMMON_ADCUR_AD6USRC) | ((val << 4) & HRTIM_COMMON_ADCUR_AD6USRC);
}
inline void hrtim_common_adcur_set_ad5usrc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCUR = (p->ADCUR & ~HRTIM_COMMON_ADCUR_AD5USRC) | ((val << 0) & HRTIM_COMMON_ADCUR_AD5USRC);
}
inline uint32_t hrtim_common_adcur_get_ad10usrc(struct HRTIM_Common_Type *p) {
	return (p->ADCUR & HRTIM_COMMON_ADCUR_AD10USRC) >> 20;
}
inline uint32_t hrtim_common_adcur_get_ad9usrc(struct HRTIM_Common_Type *p) {
	return (p->ADCUR & HRTIM_COMMON_ADCUR_AD9USRC) >> 16;
}
inline uint32_t hrtim_common_adcur_get_ad8usrc(struct HRTIM_Common_Type *p) {
	return (p->ADCUR & HRTIM_COMMON_ADCUR_AD8USRC) >> 12;
}
inline uint32_t hrtim_common_adcur_get_ad7usrc(struct HRTIM_Common_Type *p) { return (p->ADCUR & HRTIM_COMMON_ADCUR_AD7USRC) >> 8; }
inline uint32_t hrtim_common_adcur_get_ad6usrc(struct HRTIM_Common_Type *p) { return (p->ADCUR & HRTIM_COMMON_ADCUR_AD6USRC) >> 4; }
inline uint32_t hrtim_common_adcur_get_ad5usrc(struct HRTIM_Common_Type *p) { return (p->ADCUR & HRTIM_COMMON_ADCUR_AD5USRC) >> 0; }

// HRTIM_Common->ADCPS1 HRTIM ADC Post Scaler Register 1
enum {
	HRTIM_COMMON_ADCPS1_ADC5PSC = ((1UL << 5) - 1) << 24,  // ADC5PSC
	HRTIM_COMMON_ADCPS1_ADC4PSC = ((1UL << 5) - 1) << 18,  // ADC4PSC
	HRTIM_COMMON_ADCPS1_ADC3PSC = ((1UL << 5) - 1) << 12,  // ADC3PSC
	HRTIM_COMMON_ADCPS1_ADC2PSC = ((1UL << 5) - 1) << 6,   // ADC2PSC
	HRTIM_COMMON_ADCPS1_ADC1PSC = ((1UL << 5) - 1) << 0,   // ADC1PSC
};
inline void hrtim_common_adcps1_set_adc5psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS1 = (p->ADCPS1 & ~HRTIM_COMMON_ADCPS1_ADC5PSC) | ((val << 24) & HRTIM_COMMON_ADCPS1_ADC5PSC);
}
inline void hrtim_common_adcps1_set_adc4psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS1 = (p->ADCPS1 & ~HRTIM_COMMON_ADCPS1_ADC4PSC) | ((val << 18) & HRTIM_COMMON_ADCPS1_ADC4PSC);
}
inline void hrtim_common_adcps1_set_adc3psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS1 = (p->ADCPS1 & ~HRTIM_COMMON_ADCPS1_ADC3PSC) | ((val << 12) & HRTIM_COMMON_ADCPS1_ADC3PSC);
}
inline void hrtim_common_adcps1_set_adc2psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS1 = (p->ADCPS1 & ~HRTIM_COMMON_ADCPS1_ADC2PSC) | ((val << 6) & HRTIM_COMMON_ADCPS1_ADC2PSC);
}
inline void hrtim_common_adcps1_set_adc1psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS1 = (p->ADCPS1 & ~HRTIM_COMMON_ADCPS1_ADC1PSC) | ((val << 0) & HRTIM_COMMON_ADCPS1_ADC1PSC);
}
inline uint32_t hrtim_common_adcps1_get_adc5psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS1 & HRTIM_COMMON_ADCPS1_ADC5PSC) >> 24;
}
inline uint32_t hrtim_common_adcps1_get_adc4psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS1 & HRTIM_COMMON_ADCPS1_ADC4PSC) >> 18;
}
inline uint32_t hrtim_common_adcps1_get_adc3psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS1 & HRTIM_COMMON_ADCPS1_ADC3PSC) >> 12;
}
inline uint32_t hrtim_common_adcps1_get_adc2psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS1 & HRTIM_COMMON_ADCPS1_ADC2PSC) >> 6;
}
inline uint32_t hrtim_common_adcps1_get_adc1psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS1 & HRTIM_COMMON_ADCPS1_ADC1PSC) >> 0;
}

// HRTIM_Common->ADCPS2 HRTIM ADC Post Scaler Register 2
enum {
	HRTIM_COMMON_ADCPS2_ADC10PSC = ((1UL << 5) - 1) << 24,	// ADC10PSC
	HRTIM_COMMON_ADCPS2_ADC9PSC	 = ((1UL << 5) - 1) << 18,	// ADC9PSC
	HRTIM_COMMON_ADCPS2_ADC8PSC	 = ((1UL << 5) - 1) << 12,	// ADC8PSC
	HRTIM_COMMON_ADCPS2_ADC7PSC	 = ((1UL << 5) - 1) << 6,	// ADC7PSC
	HRTIM_COMMON_ADCPS2_ADC6PSC	 = ((1UL << 5) - 1) << 0,	// ADC6PSC
};
inline void hrtim_common_adcps2_set_adc10psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS2 = (p->ADCPS2 & ~HRTIM_COMMON_ADCPS2_ADC10PSC) | ((val << 24) & HRTIM_COMMON_ADCPS2_ADC10PSC);
}
inline void hrtim_common_adcps2_set_adc9psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS2 = (p->ADCPS2 & ~HRTIM_COMMON_ADCPS2_ADC9PSC) | ((val << 18) & HRTIM_COMMON_ADCPS2_ADC9PSC);
}
inline void hrtim_common_adcps2_set_adc8psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS2 = (p->ADCPS2 & ~HRTIM_COMMON_ADCPS2_ADC8PSC) | ((val << 12) & HRTIM_COMMON_ADCPS2_ADC8PSC);
}
inline void hrtim_common_adcps2_set_adc7psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS2 = (p->ADCPS2 & ~HRTIM_COMMON_ADCPS2_ADC7PSC) | ((val << 6) & HRTIM_COMMON_ADCPS2_ADC7PSC);
}
inline void hrtim_common_adcps2_set_adc6psc(struct HRTIM_Common_Type *p, uint32_t val) {
	p->ADCPS2 = (p->ADCPS2 & ~HRTIM_COMMON_ADCPS2_ADC6PSC) | ((val << 0) & HRTIM_COMMON_ADCPS2_ADC6PSC);
}
inline uint32_t hrtim_common_adcps2_get_adc10psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS2 & HRTIM_COMMON_ADCPS2_ADC10PSC) >> 24;
}
inline uint32_t hrtim_common_adcps2_get_adc9psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS2 & HRTIM_COMMON_ADCPS2_ADC9PSC) >> 18;
}
inline uint32_t hrtim_common_adcps2_get_adc8psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS2 & HRTIM_COMMON_ADCPS2_ADC8PSC) >> 12;
}
inline uint32_t hrtim_common_adcps2_get_adc7psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS2 & HRTIM_COMMON_ADCPS2_ADC7PSC) >> 6;
}
inline uint32_t hrtim_common_adcps2_get_adc6psc(struct HRTIM_Common_Type *p) {
	return (p->ADCPS2 & HRTIM_COMMON_ADCPS2_ADC6PSC) >> 0;
}

// HRTIM_Common->FLTINR3 HRTIM Fault Input Register 3
enum {
	HRTIM_COMMON_FLTINR3_FLT4RSTM = 1UL << 31,				 // FLT4RSTM
	HRTIM_COMMON_FLTINR3_FLT4CRES = 1UL << 30,				 // FLT4CRES
	HRTIM_COMMON_FLTINR3_FLT4CNT  = ((1UL << 4) - 1) << 26,	 // FLT4CNT
	HRTIM_COMMON_FLTINR3_FLT4BLKS = 1UL << 25,				 // FLT4BLKS
	HRTIM_COMMON_FLTINR3_FLT4BLKE = 1UL << 24,				 // FLT4BLKE
	HRTIM_COMMON_FLTINR3_FLT3RSTM = 1UL << 23,				 // FLT3RSTM
	HRTIM_COMMON_FLTINR3_FLT3CRES = 1UL << 22,				 // FLT3CRES
	HRTIM_COMMON_FLTINR3_FLT3CNT  = ((1UL << 4) - 1) << 18,	 // FLT3CNT
	HRTIM_COMMON_FLTINR3_FLT3BLKS = 1UL << 17,				 // FLT3BLKS
	HRTIM_COMMON_FLTINR3_FLT3BLKE = 1UL << 16,				 // FLT3BLKE
	HRTIM_COMMON_FLTINR3_FLT2RSTM = 1UL << 15,				 // FLT2RSTM
	HRTIM_COMMON_FLTINR3_FLT2CRES = 1UL << 14,				 // FLT2CRES
	HRTIM_COMMON_FLTINR3_FLT2CNT  = ((1UL << 4) - 1) << 10,	 // FLT2CNT
	HRTIM_COMMON_FLTINR3_FLT2BLKS = 1UL << 9,				 // FLT2BLKS
	HRTIM_COMMON_FLTINR3_FLT2BLKE = 1UL << 8,				 // FLT2BLKE
	HRTIM_COMMON_FLTINR3_FLT1RSTM = 1UL << 7,				 // FLT1RSTM
	HRTIM_COMMON_FLTINR3_FLT1CRES = 1UL << 6,				 // FLT1CRES
	HRTIM_COMMON_FLTINR3_FLT1CNT  = ((1UL << 4) - 1) << 2,	 // FLT1CNT
	HRTIM_COMMON_FLTINR3_FLT1BLKS = 1UL << 1,				 // FLT1BLKS
	HRTIM_COMMON_FLTINR3_FLT1BLKE = 1UL << 0,				 // FLT1BLKE
};
inline void hrtim_common_fltinr3_set_flt4cnt(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR3 = (p->FLTINR3 & ~HRTIM_COMMON_FLTINR3_FLT4CNT) | ((val << 26) & HRTIM_COMMON_FLTINR3_FLT4CNT);
}
inline void hrtim_common_fltinr3_set_flt3cnt(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR3 = (p->FLTINR3 & ~HRTIM_COMMON_FLTINR3_FLT3CNT) | ((val << 18) & HRTIM_COMMON_FLTINR3_FLT3CNT);
}
inline void hrtim_common_fltinr3_set_flt2cnt(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR3 = (p->FLTINR3 & ~HRTIM_COMMON_FLTINR3_FLT2CNT) | ((val << 10) & HRTIM_COMMON_FLTINR3_FLT2CNT);
}
inline void hrtim_common_fltinr3_set_flt1cnt(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR3 = (p->FLTINR3 & ~HRTIM_COMMON_FLTINR3_FLT1CNT) | ((val << 2) & HRTIM_COMMON_FLTINR3_FLT1CNT);
}
inline uint32_t hrtim_common_fltinr3_get_flt4cnt(struct HRTIM_Common_Type *p) {
	return (p->FLTINR3 & HRTIM_COMMON_FLTINR3_FLT4CNT) >> 26;
}
inline uint32_t hrtim_common_fltinr3_get_flt3cnt(struct HRTIM_Common_Type *p) {
	return (p->FLTINR3 & HRTIM_COMMON_FLTINR3_FLT3CNT) >> 18;
}
inline uint32_t hrtim_common_fltinr3_get_flt2cnt(struct HRTIM_Common_Type *p) {
	return (p->FLTINR3 & HRTIM_COMMON_FLTINR3_FLT2CNT) >> 10;
}
inline uint32_t hrtim_common_fltinr3_get_flt1cnt(struct HRTIM_Common_Type *p) {
	return (p->FLTINR3 & HRTIM_COMMON_FLTINR3_FLT1CNT) >> 2;
}

// HRTIM_Common->FLTINR4 HRTIM Fault Input Register 4
enum {
	HRTIM_COMMON_FLTINR4_FLT6RSTM = 1UL << 15,				 // FLT6RSTM
	HRTIM_COMMON_FLTINR4_FLT6CRES = 1UL << 14,				 // FLT6CRES
	HRTIM_COMMON_FLTINR4_FLT6CNT  = ((1UL << 4) - 1) << 10,	 // FLT6CNT
	HRTIM_COMMON_FLTINR4_FLT6BLKS = 1UL << 9,				 // FLT6BLKS
	HRTIM_COMMON_FLTINR4_FLT6BLKE = 1UL << 8,				 // FLT6BLKE
	HRTIM_COMMON_FLTINR4_FLT5RSTM = 1UL << 7,				 // FLT5RSTM
	HRTIM_COMMON_FLTINR4_FLT5CRES = 1UL << 6,				 // FLT5CRES
	HRTIM_COMMON_FLTINR4_FLT5CNT  = ((1UL << 4) - 1) << 2,	 // FLT5CNT
	HRTIM_COMMON_FLTINR4_FLT5BLKS = 1UL << 1,				 // FLT5BLKS
	HRTIM_COMMON_FLTINR4_FLT5BLKE = 1UL << 0,				 // FLT5BLKE
};
inline void hrtim_common_fltinr4_set_flt6cnt(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR4 = (p->FLTINR4 & ~HRTIM_COMMON_FLTINR4_FLT6CNT) | ((val << 10) & HRTIM_COMMON_FLTINR4_FLT6CNT);
}
inline void hrtim_common_fltinr4_set_flt5cnt(struct HRTIM_Common_Type *p, uint32_t val) {
	p->FLTINR4 = (p->FLTINR4 & ~HRTIM_COMMON_FLTINR4_FLT5CNT) | ((val << 2) & HRTIM_COMMON_FLTINR4_FLT5CNT);
}
inline uint32_t hrtim_common_fltinr4_get_flt6cnt(struct HRTIM_Common_Type *p) {
	return (p->FLTINR4 & HRTIM_COMMON_FLTINR4_FLT6CNT) >> 10;
}
inline uint32_t hrtim_common_fltinr4_get_flt5cnt(struct HRTIM_Common_Type *p) {
	return (p->FLTINR4 & HRTIM_COMMON_FLTINR4_FLT5CNT) >> 2;
}

/* High Resolution Timer: Master Timers */
struct HRTIM_Master_Type {
	__IO uint32_t MCR;			 // @0 Master Timer Control Register
	__I uint8_t	  MISR;			 // @4 Master Timer Interrupt Status Register
	uint8_t		  RESERVED0[3];	 // @5
	__O uint8_t	  MICR;			 // @8 Master Timer Interrupt Clear Register
	uint8_t		  RESERVED1[3];	 // @9
	__IO uint32_t MDIER;		 // @12 HRTIM Master Timer DMA / Interrupt Enable Register
	__IO uint16_t MCNTR;		 // @16 Master Timer Counter Register
	uint8_t		  RESERVED2[2];	 // @18
	__IO uint16_t MPER;			 // @20 Master Timer Period Register
	uint8_t		  RESERVED3[2];	 // @22
	__IO uint8_t  MREP;			 // @24 Master Timer Repetition Register
	uint8_t		  RESERVED4[3];	 // @25
	__IO uint16_t MCMP1R;		 // @28 Master Timer Compare 1 Register
	uint8_t		  RESERVED5[6];	 // @30
	__IO uint16_t MCMP2R;		 // @36 Master Timer Compare 2 Register
	uint8_t		  RESERVED6[2];	 // @38
	__IO uint16_t MCMP3R;		 // @40 Master Timer Compare 3 Register
	uint8_t		  RESERVED7[2];	 // @42
	__IO uint16_t MCMP4R;		 // @44 Master Timer Compare 4 Register
};

// HRTIM_Master->MCR Master Timer Control Register
enum {
	HRTIM_MASTER_MCR_BRSTDMA   = ((1UL << 2) - 1) << 30,  // Burst DMA Update
	HRTIM_MASTER_MCR_MREPU	   = 1UL << 29,				  // Master Timer Repetition update
	HRTIM_MASTER_MCR_PREEN	   = 1UL << 27,				  // Preload enable
	HRTIM_MASTER_MCR_DACSYNC   = ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_MASTER_MCR_TFCEN	   = 1UL << 22,				  // Timer F counter enable
	HRTIM_MASTER_MCR_TECEN	   = 1UL << 21,				  // Timer E counter enable
	HRTIM_MASTER_MCR_TDCEN	   = 1UL << 20,				  // Timer D counter enable
	HRTIM_MASTER_MCR_TCCEN	   = 1UL << 19,				  // Timer C counter enable
	HRTIM_MASTER_MCR_TBCEN	   = 1UL << 18,				  // Timer B counter enable
	HRTIM_MASTER_MCR_TACEN	   = 1UL << 17,				  // Timer A counter enable
	HRTIM_MASTER_MCR_MCEN	   = 1UL << 16,				  // Master Counter enable
	HRTIM_MASTER_MCR_SYNC_SRC  = ((1UL << 2) - 1) << 14,  // Synchronization source
	HRTIM_MASTER_MCR_SYNC_OUT  = ((1UL << 2) - 1) << 12,  // Synchronization output
	HRTIM_MASTER_MCR_SYNCSTRTM = 1UL << 11,				  // Synchronization Starts Master
	HRTIM_MASTER_MCR_SYNCRSTM  = 1UL << 10,				  // Synchronization Resets Master
	HRTIM_MASTER_MCR_SYNC_IN   = ((1UL << 2) - 1) << 8,	  // synchronization input
	HRTIM_MASTER_MCR_INTLVD	   = ((1UL << 2) - 1) << 6,	  // Interleaved mode
	HRTIM_MASTER_MCR_HALF	   = 1UL << 5,				  // Half mode enable
	HRTIM_MASTER_MCR_RETRIG	   = 1UL << 4,				  // Master Re-triggerable mode
	HRTIM_MASTER_MCR_CONT	   = 1UL << 3,				  // Master Continuous mode
	HRTIM_MASTER_MCR_CK_PSC	   = ((1UL << 3) - 1) << 0,	  // HRTIM Master Clock prescaler
};
inline void hrtim_master_mcr_set_brstdma(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_BRSTDMA) | ((val << 30) & HRTIM_MASTER_MCR_BRSTDMA);
}
inline void hrtim_master_mcr_set_dacsync(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_DACSYNC) | ((val << 25) & HRTIM_MASTER_MCR_DACSYNC);
}
inline void hrtim_master_mcr_set_sync_src(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_SYNC_SRC) | ((val << 14) & HRTIM_MASTER_MCR_SYNC_SRC);
}
inline void hrtim_master_mcr_set_sync_out(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_SYNC_OUT) | ((val << 12) & HRTIM_MASTER_MCR_SYNC_OUT);
}
inline void hrtim_master_mcr_set_sync_in(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_SYNC_IN) | ((val << 8) & HRTIM_MASTER_MCR_SYNC_IN);
}
inline void hrtim_master_mcr_set_intlvd(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_INTLVD) | ((val << 6) & HRTIM_MASTER_MCR_INTLVD);
}
inline void hrtim_master_mcr_set_ck_psc(struct HRTIM_Master_Type *p, uint32_t val) {
	p->MCR = (p->MCR & ~HRTIM_MASTER_MCR_CK_PSC) | ((val << 0) & HRTIM_MASTER_MCR_CK_PSC);
}
inline uint32_t hrtim_master_mcr_get_brstdma(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_BRSTDMA) >> 30; }
inline uint32_t hrtim_master_mcr_get_dacsync(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_DACSYNC) >> 25; }
inline uint32_t hrtim_master_mcr_get_sync_src(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_SYNC_SRC) >> 14; }
inline uint32_t hrtim_master_mcr_get_sync_out(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_SYNC_OUT) >> 12; }
inline uint32_t hrtim_master_mcr_get_sync_in(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_SYNC_IN) >> 8; }
inline uint32_t hrtim_master_mcr_get_intlvd(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_INTLVD) >> 6; }
inline uint32_t hrtim_master_mcr_get_ck_psc(struct HRTIM_Master_Type *p) { return (p->MCR & HRTIM_MASTER_MCR_CK_PSC) >> 0; }

// HRTIM_Master->MISR Master Timer Interrupt Status Register
enum {
	HRTIM_MASTER_MISR_MUPD	= 1UL << 6,	 // Master Update Interrupt Flag
	HRTIM_MASTER_MISR_SYNC	= 1UL << 5,	 // Sync Input Interrupt Flag
	HRTIM_MASTER_MISR_MREP	= 1UL << 4,	 // Master Repetition Interrupt Flag
	HRTIM_MASTER_MISR_MCMP4 = 1UL << 3,	 // Master Compare 4 Interrupt Flag
	HRTIM_MASTER_MISR_MCMP3 = 1UL << 2,	 // Master Compare 3 Interrupt Flag
	HRTIM_MASTER_MISR_MCMP2 = 1UL << 1,	 // Master Compare 2 Interrupt Flag
	HRTIM_MASTER_MISR_MCMP1 = 1UL << 0,	 // Master Compare 1 Interrupt Flag
};

// HRTIM_Master->MICR Master Timer Interrupt Clear Register
enum {
	HRTIM_MASTER_MICR_MUPDC	 = 1UL << 6,  // Master update Interrupt flag clear
	HRTIM_MASTER_MICR_SYNCC	 = 1UL << 5,  // Sync Input Interrupt flag clear
	HRTIM_MASTER_MICR_MREPC	 = 1UL << 4,  // Repetition Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP4C = 1UL << 3,  // Master Compare 4 Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP3C = 1UL << 2,  // Master Compare 3 Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP2C = 1UL << 1,  // Master Compare 2 Interrupt flag clear
	HRTIM_MASTER_MICR_MCMP1C = 1UL << 0,  // Master Compare 1 Interrupt flag clear
};

// HRTIM_Master->MDIER HRTIM Master Timer DMA / Interrupt Enable Register
enum {
	HRTIM_MASTER_MDIER_MUPDDE  = 1UL << 22,	 // MUPDDE
	HRTIM_MASTER_MDIER_SYNCDE  = 1UL << 21,	 // SYNCDE
	HRTIM_MASTER_MDIER_MREPDE  = 1UL << 20,	 // MREPDE
	HRTIM_MASTER_MDIER_MCMP4DE = 1UL << 19,	 // MCMP4DE
	HRTIM_MASTER_MDIER_MCMP3DE = 1UL << 18,	 // MCMP3DE
	HRTIM_MASTER_MDIER_MCMP2DE = 1UL << 17,	 // MCMP2DE
	HRTIM_MASTER_MDIER_MCMP1DE = 1UL << 16,	 // MCMP1DE
	HRTIM_MASTER_MDIER_MUPDIE  = 1UL << 6,	 // MUPDIE
	HRTIM_MASTER_MDIER_SYNCIE  = 1UL << 5,	 // SYNCIE
	HRTIM_MASTER_MDIER_MREPIE  = 1UL << 4,	 // MREPIE
	HRTIM_MASTER_MDIER_MCMP4IE = 1UL << 3,	 // MCMP4IE
	HRTIM_MASTER_MDIER_MCMP3IE = 1UL << 2,	 // MCMP3IE
	HRTIM_MASTER_MDIER_MCMP2IE = 1UL << 1,	 // MCMP2IE
	HRTIM_MASTER_MDIER_MCMP1IE = 1UL << 0,	 // MCMP1IE
};

/* High Resolution Timer: TIMA */
struct HRTIM_TIMA_Type {
	__IO uint32_t TIMACR;		 // @0 Timerx Control Register
	__I uint32_t  TIMAISR;		 // @4 Timerx Interrupt Status Register
	__O uint16_t  TIMAICR;		 // @8 Timerx Interrupt Clear Register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t TIMADIER;		 // @12 TIMxDIER
	__IO uint16_t CNTAR;		 // @16 Timerx Counter Register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t PERAR;		 // @20 Timerx Period Register
	uint8_t		  RESERVED2[2];	 // @22
	__IO uint8_t  REPAR;		 // @24 Timerx Repetition Register
	uint8_t		  RESERVED3[3];	 // @25
	__IO uint16_t CMP1AR;		 // @28 Timerx Compare 1 Register
	uint8_t		  RESERVED4[2];	 // @30
	__IO uint32_t CMP1CAR;		 // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2AR;		 // @36 Timerx Compare 2 Register
	uint8_t		  RESERVED5[2];	 // @38
	__IO uint16_t CMP3AR;		 // @40 Timerx Compare 3 Register
	uint8_t		  RESERVED6[2];	 // @42
	__IO uint16_t CMP4AR;		 // @44 Timerx Compare 4 Register
	uint8_t		  RESERVED7[2];	 // @46
	__I uint32_t  CPT1AR;		 // @48 Timerx Capture 1 Register
	__I uint32_t  CPT2AR;		 // @52 Timerx Capture 2 Register
	__IO uint32_t DTAR;			 // @56 Timerx Deadtime Register
	__IO uint32_t SETA1R;		 // @60 Timerx Output1 Set Register
	__IO uint32_t RSTA1R;		 // @64 Timerx Output1 Reset Register
	__IO uint32_t SETA2R;		 // @68 Timerx Output2 Set Register
	__IO uint32_t RSTA2R;		 // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFAR1;		 // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFAR2;		 // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTAR;		 // @84 TimerA Reset Register
	__IO uint16_t CHPAR;		 // @88 Timerx Chopper Register
	uint8_t		  RESERVED8[2];	 // @90
	__IO uint32_t CPT1ACR;		 // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2ACR;		 // @96 CPT2xCR
	__IO uint32_t OUTAR;		 // @100 Timerx Output Register
	__IO uint32_t FLTAR;		 // @104 Timerx Fault Register
	__IO uint32_t TIMACR2;		 // @108 HRTIM Timerx Control Register 2
	__IO uint16_t AEEFR3;		 // @112 HRTIM Timerx External Event Filtering Register 3
};

// HRTIM_TIMA->TIMACR Timerx Control Register
enum {
	HRTIM_TIMA_TIMACR_UPDGAT	= ((1UL << 4) - 1) << 28,  // Update Gating
	HRTIM_TIMA_TIMACR_PREEN		= 1UL << 27,			   // Preload enable
	HRTIM_TIMA_TIMACR_DACSYNC	= ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_TIMA_TIMACR_MSTU		= 1UL << 24,			   // Master Timer update
	HRTIM_TIMA_TIMACR_TEU		= 1UL << 23,			   // TEU
	HRTIM_TIMA_TIMACR_TDU		= 1UL << 22,			   // TDU
	HRTIM_TIMA_TIMACR_TCU		= 1UL << 21,			   // TCU
	HRTIM_TIMA_TIMACR_TBU		= 1UL << 20,			   // TBU
	HRTIM_TIMA_TIMACR_TXRSTU	= 1UL << 18,			   // Timerx reset update
	HRTIM_TIMA_TIMACR_TXREPU	= 1UL << 17,			   // Timer x Repetition update
	HRTIM_TIMA_TIMACR_TFU		= 1UL << 16,			   // TFU
	HRTIM_TIMA_TIMACR_DELCMP4	= ((1UL << 2) - 1) << 14,  // Delayed CMP4 mode
	HRTIM_TIMA_TIMACR_DELCMP2	= ((1UL << 2) - 1) << 12,  // Delayed CMP2 mode
	HRTIM_TIMA_TIMACR_SYNCSTRTX = 1UL << 11,			   // Synchronization Starts Timer x
	HRTIM_TIMA_TIMACR_SYNCRSTX	= 1UL << 10,			   // Synchronization Resets Timer x
	HRTIM_TIMA_TIMACR_RSYNCU	= 1UL << 9,				   // Re-Synchronized Update
	HRTIM_TIMA_TIMACR_INTLVD	= ((1UL << 2) - 1) << 7,   // Interleaved mode
	HRTIM_TIMA_TIMACR_PSHPLL	= 1UL << 6,				   // Push-Pull mode enable
	HRTIM_TIMA_TIMACR_HALF		= 1UL << 5,				   // Half mode enable
	HRTIM_TIMA_TIMACR_RETRIG	= 1UL << 4,				   // Re-triggerable mode
	HRTIM_TIMA_TIMACR_CONT		= 1UL << 3,				   // Continuous mode
	HRTIM_TIMA_TIMACR_CK_PSCX	= ((1UL << 3) - 1) << 0,   // HRTIM Timer x Clock prescaler
};
inline void hrtim_tima_timacr_set_updgat(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_UPDGAT) | ((val << 28) & HRTIM_TIMA_TIMACR_UPDGAT);
}
inline void hrtim_tima_timacr_set_dacsync(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_DACSYNC) | ((val << 25) & HRTIM_TIMA_TIMACR_DACSYNC);
}
inline void hrtim_tima_timacr_set_delcmp4(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_DELCMP4) | ((val << 14) & HRTIM_TIMA_TIMACR_DELCMP4);
}
inline void hrtim_tima_timacr_set_delcmp2(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_DELCMP2) | ((val << 12) & HRTIM_TIMA_TIMACR_DELCMP2);
}
inline void hrtim_tima_timacr_set_intlvd(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_INTLVD) | ((val << 7) & HRTIM_TIMA_TIMACR_INTLVD);
}
inline void hrtim_tima_timacr_set_ck_pscx(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR = (p->TIMACR & ~HRTIM_TIMA_TIMACR_CK_PSCX) | ((val << 0) & HRTIM_TIMA_TIMACR_CK_PSCX);
}
inline uint32_t hrtim_tima_timacr_get_updgat(struct HRTIM_TIMA_Type *p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_UPDGAT) >> 28; }
inline uint32_t hrtim_tima_timacr_get_dacsync(struct HRTIM_TIMA_Type *p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_DACSYNC) >> 25; }
inline uint32_t hrtim_tima_timacr_get_delcmp4(struct HRTIM_TIMA_Type *p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_DELCMP4) >> 14; }
inline uint32_t hrtim_tima_timacr_get_delcmp2(struct HRTIM_TIMA_Type *p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_DELCMP2) >> 12; }
inline uint32_t hrtim_tima_timacr_get_intlvd(struct HRTIM_TIMA_Type *p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_INTLVD) >> 7; }
inline uint32_t hrtim_tima_timacr_get_ck_pscx(struct HRTIM_TIMA_Type *p) { return (p->TIMACR & HRTIM_TIMA_TIMACR_CK_PSCX) >> 0; }

// HRTIM_TIMA->TIMAISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMA_TIMAISR_O2CPY   = 1UL << 21,	 // Output 2 Copy
	HRTIM_TIMA_TIMAISR_O1CPY   = 1UL << 20,	 // Output 1 Copy
	HRTIM_TIMA_TIMAISR_O2STAT  = 1UL << 19,	 // Output 2 State
	HRTIM_TIMA_TIMAISR_O1STAT  = 1UL << 18,	 // Output 1 State
	HRTIM_TIMA_TIMAISR_IPPSTAT = 1UL << 17,	 // Idle Push Pull Status
	HRTIM_TIMA_TIMAISR_CPPSTAT = 1UL << 16,	 // Current Push Pull Status
	HRTIM_TIMA_TIMAISR_DLYPRT  = 1UL << 14,	 // Delayed Protection Flag
	HRTIM_TIMA_TIMAISR_RST	   = 1UL << 13,	 // Reset Interrupt Flag
	HRTIM_TIMA_TIMAISR_RSTX2   = 1UL << 12,	 // Output 2 Reset Interrupt Flag
	HRTIM_TIMA_TIMAISR_SETX2   = 1UL << 11,	 // Output 2 Set Interrupt Flag
	HRTIM_TIMA_TIMAISR_RSTX1   = 1UL << 10,	 // Output 1 Reset Interrupt Flag
	HRTIM_TIMA_TIMAISR_SETX1   = 1UL << 9,	 // Output 1 Set Interrupt Flag
	HRTIM_TIMA_TIMAISR_CPT2	   = 1UL << 8,	 // Capture2 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CPT1	   = 1UL << 7,	 // Capture1 Interrupt Flag
	HRTIM_TIMA_TIMAISR_UPD	   = 1UL << 6,	 // Update Interrupt Flag
	HRTIM_TIMA_TIMAISR_REP	   = 1UL << 4,	 // Repetition Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP4	   = 1UL << 3,	 // Compare 4 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP3	   = 1UL << 2,	 // Compare 3 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP2	   = 1UL << 1,	 // Compare 2 Interrupt Flag
	HRTIM_TIMA_TIMAISR_CMP1	   = 1UL << 0,	 // Compare 1 Interrupt Flag
};

// HRTIM_TIMA->TIMAICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMA_TIMAICR_DLYPRTC = 1UL << 14,	 // Delayed Protection Flag Clear
	HRTIM_TIMA_TIMAICR_RSTC	   = 1UL << 13,	 // Reset Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_RSTX2C  = 1UL << 12,	 // Output 2 Reset flag Clear
	HRTIM_TIMA_TIMAICR_SET2XC  = 1UL << 11,	 // Output 2 Set flag Clear
	HRTIM_TIMA_TIMAICR_RSTX1C  = 1UL << 10,	 // Output 1 Reset flag Clear
	HRTIM_TIMA_TIMAICR_SET1XC  = 1UL << 9,	 // Output 1 Set flag Clear
	HRTIM_TIMA_TIMAICR_CPT2C   = 1UL << 8,	 // Capture2 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CPT1C   = 1UL << 7,	 // Capture1 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_UPDC	   = 1UL << 6,	 // Update Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_REPC	   = 1UL << 4,	 // Repetition Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP4C   = 1UL << 3,	 // Compare 4 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP3C   = 1UL << 2,	 // Compare 3 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP2C   = 1UL << 1,	 // Compare 2 Interrupt flag Clear
	HRTIM_TIMA_TIMAICR_CMP1C   = 1UL << 0,	 // Compare 1 Interrupt flag Clear
};

// HRTIM_TIMA->TIMADIER TIMxDIER
enum {
	HRTIM_TIMA_TIMADIER_DLYPRTDE = 1UL << 30,  // DLYPRTDE
	HRTIM_TIMA_TIMADIER_RSTDE	 = 1UL << 29,  // RSTDE
	HRTIM_TIMA_TIMADIER_RSTX2DE	 = 1UL << 28,  // RSTx2DE
	HRTIM_TIMA_TIMADIER_SETX2DE	 = 1UL << 27,  // SETx2DE
	HRTIM_TIMA_TIMADIER_RSTX1DE	 = 1UL << 26,  // RSTx1DE
	HRTIM_TIMA_TIMADIER_SET1XDE	 = 1UL << 25,  // SET1xDE
	HRTIM_TIMA_TIMADIER_CPT2DE	 = 1UL << 24,  // CPT2DE
	HRTIM_TIMA_TIMADIER_CPT1DE	 = 1UL << 23,  // CPT1DE
	HRTIM_TIMA_TIMADIER_UPDDE	 = 1UL << 22,  // UPDDE
	HRTIM_TIMA_TIMADIER_REPDE	 = 1UL << 20,  // REPDE
	HRTIM_TIMA_TIMADIER_CMP4DE	 = 1UL << 19,  // CMP4DE
	HRTIM_TIMA_TIMADIER_CMP3DE	 = 1UL << 18,  // CMP3DE
	HRTIM_TIMA_TIMADIER_CMP2DE	 = 1UL << 17,  // CMP2DE
	HRTIM_TIMA_TIMADIER_CMP1DE	 = 1UL << 16,  // CMP1DE
	HRTIM_TIMA_TIMADIER_DLYPRTIE = 1UL << 14,  // DLYPRTIE
	HRTIM_TIMA_TIMADIER_RSTIE	 = 1UL << 13,  // RSTIE
	HRTIM_TIMA_TIMADIER_RSTX2IE	 = 1UL << 12,  // RSTx2IE
	HRTIM_TIMA_TIMADIER_SETX2IE	 = 1UL << 11,  // SETx2IE
	HRTIM_TIMA_TIMADIER_RSTX1IE	 = 1UL << 10,  // RSTx1IE
	HRTIM_TIMA_TIMADIER_SET1XIE	 = 1UL << 9,   // SET1xIE
	HRTIM_TIMA_TIMADIER_CPT2IE	 = 1UL << 8,   // CPT2IE
	HRTIM_TIMA_TIMADIER_CPT1IE	 = 1UL << 7,   // CPT1IE
	HRTIM_TIMA_TIMADIER_UPDIE	 = 1UL << 6,   // UPDIE
	HRTIM_TIMA_TIMADIER_REPIE	 = 1UL << 4,   // REPIE
	HRTIM_TIMA_TIMADIER_CMP4IE	 = 1UL << 3,   // CMP4IE
	HRTIM_TIMA_TIMADIER_CMP3IE	 = 1UL << 2,   // CMP3IE
	HRTIM_TIMA_TIMADIER_CMP2IE	 = 1UL << 1,   // CMP2IE
	HRTIM_TIMA_TIMADIER_CMP1IE	 = 1UL << 0,   // CMP1IE
};

// HRTIM_TIMA->CMP1CAR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMA_CMP1CAR_REPX	 = ((1UL << 8) - 1) << 16,	// Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMA_CMP1CAR_CMP1X = ((1UL << 16) - 1) << 0,	// Timerx Compare 1 value
};
inline void hrtim_tima_cmp1car_set_repx(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->CMP1CAR = (p->CMP1CAR & ~HRTIM_TIMA_CMP1CAR_REPX) | ((val << 16) & HRTIM_TIMA_CMP1CAR_REPX);
}
inline void hrtim_tima_cmp1car_set_cmp1x(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->CMP1CAR = (p->CMP1CAR & ~HRTIM_TIMA_CMP1CAR_CMP1X) | ((val << 0) & HRTIM_TIMA_CMP1CAR_CMP1X);
}
inline uint32_t hrtim_tima_cmp1car_get_repx(struct HRTIM_TIMA_Type *p) { return (p->CMP1CAR & HRTIM_TIMA_CMP1CAR_REPX) >> 16; }
inline uint32_t hrtim_tima_cmp1car_get_cmp1x(struct HRTIM_TIMA_Type *p) { return (p->CMP1CAR & HRTIM_TIMA_CMP1CAR_CMP1X) >> 0; }

// HRTIM_TIMA->CPT1AR Timerx Capture 1 Register
enum {
	HRTIM_TIMA_CPT1AR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMA_CPT1AR_CPT1X = ((1UL << 16) - 1) << 0,  // Timerx Capture 1 value
};
inline uint32_t hrtim_tima_cpt1ar_get_cpt1x(struct HRTIM_TIMA_Type *p) { return (p->CPT1AR & HRTIM_TIMA_CPT1AR_CPT1X) >> 0; }

// HRTIM_TIMA->CPT2AR Timerx Capture 2 Register
enum {
	HRTIM_TIMA_CPT2AR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMA_CPT2AR_CPT2X = ((1UL << 16) - 1) << 0,  // Timerx Capture 2 value
};
inline uint32_t hrtim_tima_cpt2ar_get_cpt2x(struct HRTIM_TIMA_Type *p) { return (p->CPT2AR & HRTIM_TIMA_CPT2AR_CPT2X) >> 0; }

// HRTIM_TIMA->DTAR Timerx Deadtime Register
enum {
	HRTIM_TIMA_DTAR_DTFLKX	= 1UL << 31,			   // Deadtime Falling Lock
	HRTIM_TIMA_DTAR_DTFSLKX = 1UL << 30,			   // Deadtime Falling Sign Lock
	HRTIM_TIMA_DTAR_SDTFX	= 1UL << 25,			   // Sign Deadtime Falling value
	HRTIM_TIMA_DTAR_DTFX	= ((1UL << 9) - 1) << 16,  // Deadtime Falling value
	HRTIM_TIMA_DTAR_DTRLKX	= 1UL << 15,			   // Deadtime Rising Lock
	HRTIM_TIMA_DTAR_DTRSLKX = 1UL << 14,			   // Deadtime Rising Sign Lock
	HRTIM_TIMA_DTAR_DTPRSC	= ((1UL << 3) - 1) << 10,  // Deadtime Prescaler
	HRTIM_TIMA_DTAR_SDTRX	= 1UL << 9,				   // Sign Deadtime Rising value
	HRTIM_TIMA_DTAR_DTRX	= ((1UL << 9) - 1) << 0,   // Deadtime Rising value
};
inline void hrtim_tima_dtar_set_dtfx(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->DTAR = (p->DTAR & ~HRTIM_TIMA_DTAR_DTFX) | ((val << 16) & HRTIM_TIMA_DTAR_DTFX);
}
inline void hrtim_tima_dtar_set_dtprsc(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->DTAR = (p->DTAR & ~HRTIM_TIMA_DTAR_DTPRSC) | ((val << 10) & HRTIM_TIMA_DTAR_DTPRSC);
}
inline void hrtim_tima_dtar_set_dtrx(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->DTAR = (p->DTAR & ~HRTIM_TIMA_DTAR_DTRX) | ((val << 0) & HRTIM_TIMA_DTAR_DTRX);
}
inline uint32_t hrtim_tima_dtar_get_dtfx(struct HRTIM_TIMA_Type *p) { return (p->DTAR & HRTIM_TIMA_DTAR_DTFX) >> 16; }
inline uint32_t hrtim_tima_dtar_get_dtprsc(struct HRTIM_TIMA_Type *p) { return (p->DTAR & HRTIM_TIMA_DTAR_DTPRSC) >> 10; }
inline uint32_t hrtim_tima_dtar_get_dtrx(struct HRTIM_TIMA_Type *p) { return (p->DTAR & HRTIM_TIMA_DTAR_DTRX) >> 0; }

// HRTIM_TIMA->SETA1R Timerx Output1 Set Register
enum {
	HRTIM_TIMA_SETA1R_UPDATE	= 1UL << 31,  // Registers update (transfer preload to active)
	HRTIM_TIMA_SETA1R_EXTEVNT10 = 1UL << 30,  // External Event 10
	HRTIM_TIMA_SETA1R_EXTEVNT9	= 1UL << 29,  // External Event 9
	HRTIM_TIMA_SETA1R_EXTEVNT8	= 1UL << 28,  // External Event 8
	HRTIM_TIMA_SETA1R_EXTEVNT7	= 1UL << 27,  // External Event 7
	HRTIM_TIMA_SETA1R_EXTEVNT6	= 1UL << 26,  // External Event 6
	HRTIM_TIMA_SETA1R_EXTEVNT5	= 1UL << 25,  // External Event 5
	HRTIM_TIMA_SETA1R_EXTEVNT4	= 1UL << 24,  // External Event 4
	HRTIM_TIMA_SETA1R_EXTEVNT3	= 1UL << 23,  // External Event 3
	HRTIM_TIMA_SETA1R_EXTEVNT2	= 1UL << 22,  // External Event 2
	HRTIM_TIMA_SETA1R_EXTEVNT1	= 1UL << 21,  // External Event 1
	HRTIM_TIMA_SETA1R_TIMEVNT9	= 1UL << 20,  // Timer Event 9
	HRTIM_TIMA_SETA1R_TIMEVNT8	= 1UL << 19,  // Timer Event 8
	HRTIM_TIMA_SETA1R_TIMEVNT7	= 1UL << 18,  // Timer Event 7
	HRTIM_TIMA_SETA1R_TIMEVNT6	= 1UL << 17,  // Timer Event 6
	HRTIM_TIMA_SETA1R_TIMEVNT5	= 1UL << 16,  // Timer Event 5
	HRTIM_TIMA_SETA1R_TIMEVNT4	= 1UL << 15,  // Timer Event 4
	HRTIM_TIMA_SETA1R_TIMEVNT3	= 1UL << 14,  // Timer Event 3
	HRTIM_TIMA_SETA1R_TIMEVNT2	= 1UL << 13,  // Timer Event 2
	HRTIM_TIMA_SETA1R_TIMEVNT1	= 1UL << 12,  // Timer Event 1
	HRTIM_TIMA_SETA1R_MSTCMP4	= 1UL << 11,  // Master Compare 4
	HRTIM_TIMA_SETA1R_MSTCMP3	= 1UL << 10,  // Master Compare 3
	HRTIM_TIMA_SETA1R_MSTCMP2	= 1UL << 9,	  // Master Compare 2
	HRTIM_TIMA_SETA1R_MSTCMP1	= 1UL << 8,	  // Master Compare 1
	HRTIM_TIMA_SETA1R_MSTPER	= 1UL << 7,	  // Master Period
	HRTIM_TIMA_SETA1R_CMP4		= 1UL << 6,	  // Timer A compare 4
	HRTIM_TIMA_SETA1R_CMP3		= 1UL << 5,	  // Timer A compare 3
	HRTIM_TIMA_SETA1R_CMP2		= 1UL << 4,	  // Timer A compare 2
	HRTIM_TIMA_SETA1R_CMP1		= 1UL << 3,	  // Timer A compare 1
	HRTIM_TIMA_SETA1R_PER		= 1UL << 2,	  // Timer A Period
	HRTIM_TIMA_SETA1R_RESYNC	= 1UL << 1,	  // Timer A resynchronizaton
	HRTIM_TIMA_SETA1R_SST		= 1UL << 0,	  // Software Set trigger
};

// HRTIM_TIMA->RSTA1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMA_RSTA1R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMA_RSTA1R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMA_RSTA1R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMA_RSTA1R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMA_RSTA1R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMA_RSTA1R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMA_RSTA1R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMA_RSTA1R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMA_RSTA1R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMA_RSTA1R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMA_RSTA1R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMA_RSTA1R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMA_RSTA1R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMA_RSTA1R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMA_RSTA1R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMA_RSTA1R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMA_RSTA1R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMA_RSTA1R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMA_RSTA1R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMA_RSTA1R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMA_RSTA1R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMA_RSTA1R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMA_RSTA1R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMA_RSTA1R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMA_RSTA1R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMA_RSTA1R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMA_RSTA1R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMA_RSTA1R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMA_RSTA1R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMA_RSTA1R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMA_RSTA1R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMA_RSTA1R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMA->SETA2R Timerx Output2 Set Register
enum {
	HRTIM_TIMA_SETA2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMA_SETA2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMA_SETA2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMA_SETA2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMA_SETA2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMA_SETA2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMA_SETA2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMA_SETA2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMA_SETA2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMA_SETA2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMA_SETA2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMA_SETA2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMA_SETA2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMA_SETA2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMA_SETA2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMA_SETA2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMA_SETA2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMA_SETA2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMA_SETA2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMA_SETA2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMA_SETA2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMA_SETA2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMA_SETA2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMA_SETA2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMA_SETA2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMA_SETA2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMA_SETA2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMA_SETA2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMA_SETA2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMA_SETA2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMA_SETA2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMA_SETA2R_SST		= 1UL << 0,	  // SST
};

// HRTIM_TIMA->RSTA2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMA_RSTA2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMA_RSTA2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMA_RSTA2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMA_RSTA2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMA_RSTA2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMA_RSTA2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMA_RSTA2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMA_RSTA2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMA_RSTA2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMA_RSTA2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMA_RSTA2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMA_RSTA2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMA_RSTA2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMA_RSTA2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMA_RSTA2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMA_RSTA2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMA_RSTA2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMA_RSTA2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMA_RSTA2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMA_RSTA2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMA_RSTA2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMA_RSTA2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMA_RSTA2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMA_RSTA2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMA_RSTA2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMA_RSTA2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMA_RSTA2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMA_RSTA2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMA_RSTA2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMA_RSTA2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMA_RSTA2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMA_RSTA2R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMA->EEFAR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMA_EEFAR1_EE5FLTR = ((1UL << 4) - 1) << 25,	 // External Event 5 filter
	HRTIM_TIMA_EEFAR1_EE5LTCH = 1UL << 24,				 // External Event 5 latch
	HRTIM_TIMA_EEFAR1_EE4FLTR = ((1UL << 4) - 1) << 19,	 // External Event 4 filter
	HRTIM_TIMA_EEFAR1_EE4LTCH = 1UL << 18,				 // External Event 4 latch
	HRTIM_TIMA_EEFAR1_EE3FLTR = ((1UL << 4) - 1) << 13,	 // External Event 3 filter
	HRTIM_TIMA_EEFAR1_EE3LTCH = 1UL << 12,				 // External Event 3 latch
	HRTIM_TIMA_EEFAR1_EE2FLTR = ((1UL << 4) - 1) << 7,	 // External Event 2 filter
	HRTIM_TIMA_EEFAR1_EE2LTCH = 1UL << 6,				 // External Event 2 latch
	HRTIM_TIMA_EEFAR1_EE1FLTR = ((1UL << 4) - 1) << 1,	 // External Event 1 filter
	HRTIM_TIMA_EEFAR1_EE1LTCH = 1UL << 0,				 // External Event 1 latch
};
inline void hrtim_tima_eefar1_set_ee5fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE5FLTR) | ((val << 25) & HRTIM_TIMA_EEFAR1_EE5FLTR);
}
inline void hrtim_tima_eefar1_set_ee4fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE4FLTR) | ((val << 19) & HRTIM_TIMA_EEFAR1_EE4FLTR);
}
inline void hrtim_tima_eefar1_set_ee3fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE3FLTR) | ((val << 13) & HRTIM_TIMA_EEFAR1_EE3FLTR);
}
inline void hrtim_tima_eefar1_set_ee2fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE2FLTR) | ((val << 7) & HRTIM_TIMA_EEFAR1_EE2FLTR);
}
inline void hrtim_tima_eefar1_set_ee1fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR1 = (p->EEFAR1 & ~HRTIM_TIMA_EEFAR1_EE1FLTR) | ((val << 1) & HRTIM_TIMA_EEFAR1_EE1FLTR);
}
inline uint32_t hrtim_tima_eefar1_get_ee5fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE5FLTR) >> 25; }
inline uint32_t hrtim_tima_eefar1_get_ee4fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE4FLTR) >> 19; }
inline uint32_t hrtim_tima_eefar1_get_ee3fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE3FLTR) >> 13; }
inline uint32_t hrtim_tima_eefar1_get_ee2fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE2FLTR) >> 7; }
inline uint32_t hrtim_tima_eefar1_get_ee1fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR1 & HRTIM_TIMA_EEFAR1_EE1FLTR) >> 1; }

// HRTIM_TIMA->EEFAR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMA_EEFAR2_EE10FLTR = ((1UL << 4) - 1) << 25,  // External Event 10 filter
	HRTIM_TIMA_EEFAR2_EE10LTCH = 1UL << 24,				  // External Event 10 latch
	HRTIM_TIMA_EEFAR2_EE9FLTR  = ((1UL << 4) - 1) << 19,  // External Event 9 filter
	HRTIM_TIMA_EEFAR2_EE9LTCH  = 1UL << 18,				  // External Event 9 latch
	HRTIM_TIMA_EEFAR2_EE8FLTR  = ((1UL << 4) - 1) << 13,  // External Event 8 filter
	HRTIM_TIMA_EEFAR2_EE8LTCH  = 1UL << 12,				  // External Event 8 latch
	HRTIM_TIMA_EEFAR2_EE7FLTR  = ((1UL << 4) - 1) << 7,	  // External Event 7 filter
	HRTIM_TIMA_EEFAR2_EE7LTCH  = 1UL << 6,				  // External Event 7 latch
	HRTIM_TIMA_EEFAR2_EE6FLTR  = ((1UL << 4) - 1) << 1,	  // External Event 6 filter
	HRTIM_TIMA_EEFAR2_EE6LTCH  = 1UL << 0,				  // External Event 6 latch
};
inline void hrtim_tima_eefar2_set_ee10fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE10FLTR) | ((val << 25) & HRTIM_TIMA_EEFAR2_EE10FLTR);
}
inline void hrtim_tima_eefar2_set_ee9fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE9FLTR) | ((val << 19) & HRTIM_TIMA_EEFAR2_EE9FLTR);
}
inline void hrtim_tima_eefar2_set_ee8fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE8FLTR) | ((val << 13) & HRTIM_TIMA_EEFAR2_EE8FLTR);
}
inline void hrtim_tima_eefar2_set_ee7fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE7FLTR) | ((val << 7) & HRTIM_TIMA_EEFAR2_EE7FLTR);
}
inline void hrtim_tima_eefar2_set_ee6fltr(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->EEFAR2 = (p->EEFAR2 & ~HRTIM_TIMA_EEFAR2_EE6FLTR) | ((val << 1) & HRTIM_TIMA_EEFAR2_EE6FLTR);
}
inline uint32_t hrtim_tima_eefar2_get_ee10fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE10FLTR) >> 25; }
inline uint32_t hrtim_tima_eefar2_get_ee9fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE9FLTR) >> 19; }
inline uint32_t hrtim_tima_eefar2_get_ee8fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE8FLTR) >> 13; }
inline uint32_t hrtim_tima_eefar2_get_ee7fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE7FLTR) >> 7; }
inline uint32_t hrtim_tima_eefar2_get_ee6fltr(struct HRTIM_TIMA_Type *p) { return (p->EEFAR2 & HRTIM_TIMA_EEFAR2_EE6FLTR) >> 1; }

// HRTIM_TIMA->RSTAR TimerA Reset Register
enum {
	HRTIM_TIMA_RSTAR_TIMFCPM2  = 1UL << 31,	 // Timer F Compare 2
	HRTIM_TIMA_RSTAR_TIMECMP4  = 1UL << 30,	 // Timer E Compare 4
	HRTIM_TIMA_RSTAR_TIMECMP2  = 1UL << 29,	 // Timer E Compare 2
	HRTIM_TIMA_RSTAR_TIMECMP1  = 1UL << 28,	 // Timer E Compare 1
	HRTIM_TIMA_RSTAR_TIMDCMP4  = 1UL << 27,	 // Timer D Compare 4
	HRTIM_TIMA_RSTAR_TIMDCMP2  = 1UL << 26,	 // Timer D Compare 2
	HRTIM_TIMA_RSTAR_TIMDCMP1  = 1UL << 25,	 // Timer D Compare 1
	HRTIM_TIMA_RSTAR_TIMCCMP4  = 1UL << 24,	 // Timer C Compare 4
	HRTIM_TIMA_RSTAR_TIMCCMP2  = 1UL << 23,	 // Timer C Compare 2
	HRTIM_TIMA_RSTAR_TIMCCMP1  = 1UL << 22,	 // Timer C Compare 1
	HRTIM_TIMA_RSTAR_TIMBCMP4  = 1UL << 21,	 // Timer B Compare 4
	HRTIM_TIMA_RSTAR_TIMBCMP2  = 1UL << 20,	 // Timer B Compare 2
	HRTIM_TIMA_RSTAR_TIMBCMP1  = 1UL << 19,	 // Timer B Compare 1
	HRTIM_TIMA_RSTAR_EXTEVNT10 = 1UL << 18,	 // External Event 10
	HRTIM_TIMA_RSTAR_EXTEVNT9  = 1UL << 17,	 // External Event 9
	HRTIM_TIMA_RSTAR_EXTEVNT8  = 1UL << 16,	 // External Event 8
	HRTIM_TIMA_RSTAR_EXTEVNT7  = 1UL << 15,	 // External Event 7
	HRTIM_TIMA_RSTAR_EXTEVNT6  = 1UL << 14,	 // External Event 6
	HRTIM_TIMA_RSTAR_EXTEVNT5  = 1UL << 13,	 // External Event 5
	HRTIM_TIMA_RSTAR_EXTEVNT4  = 1UL << 12,	 // External Event 4
	HRTIM_TIMA_RSTAR_EXTEVNT3  = 1UL << 11,	 // External Event 3
	HRTIM_TIMA_RSTAR_EXTEVNT2  = 1UL << 10,	 // External Event 2
	HRTIM_TIMA_RSTAR_EXTEVNT1  = 1UL << 9,	 // External Event 1
	HRTIM_TIMA_RSTAR_MSTCMP4   = 1UL << 8,	 // Master compare 4
	HRTIM_TIMA_RSTAR_MSTCMP3   = 1UL << 7,	 // Master compare 3
	HRTIM_TIMA_RSTAR_MSTCMP2   = 1UL << 6,	 // Master compare 2
	HRTIM_TIMA_RSTAR_MSTCMP1   = 1UL << 5,	 // Master compare 1
	HRTIM_TIMA_RSTAR_MSTPER	   = 1UL << 4,	 // Master timer Period
	HRTIM_TIMA_RSTAR_CMP4	   = 1UL << 3,	 // Timer A compare 4 reset
	HRTIM_TIMA_RSTAR_CMP2	   = 1UL << 2,	 // Timer A compare 2 reset
	HRTIM_TIMA_RSTAR_UPDT	   = 1UL << 1,	 // Timer A Update reset
	HRTIM_TIMA_RSTAR_TIMFCMP1  = 1UL << 0,	 // Timer A Update reset
};

// HRTIM_TIMA->CHPAR Timerx Chopper Register
enum {
	HRTIM_TIMA_CHPAR_STRTPW = ((1UL << 4) - 1) << 7,  // STRTPW
	HRTIM_TIMA_CHPAR_CHPDTY = ((1UL << 3) - 1) << 4,  // Timerx chopper duty cycle value
	HRTIM_TIMA_CHPAR_CHPFRQ = ((1UL << 4) - 1) << 0,  // Timerx carrier frequency value
};
inline void hrtim_tima_chpar_set_strtpw(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->CHPAR = (p->CHPAR & ~HRTIM_TIMA_CHPAR_STRTPW) | ((val << 7) & HRTIM_TIMA_CHPAR_STRTPW);
}
inline void hrtim_tima_chpar_set_chpdty(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->CHPAR = (p->CHPAR & ~HRTIM_TIMA_CHPAR_CHPDTY) | ((val << 4) & HRTIM_TIMA_CHPAR_CHPDTY);
}
inline void hrtim_tima_chpar_set_chpfrq(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->CHPAR = (p->CHPAR & ~HRTIM_TIMA_CHPAR_CHPFRQ) | ((val << 0) & HRTIM_TIMA_CHPAR_CHPFRQ);
}
inline uint32_t hrtim_tima_chpar_get_strtpw(struct HRTIM_TIMA_Type *p) { return (p->CHPAR & HRTIM_TIMA_CHPAR_STRTPW) >> 7; }
inline uint32_t hrtim_tima_chpar_get_chpdty(struct HRTIM_TIMA_Type *p) { return (p->CHPAR & HRTIM_TIMA_CHPAR_CHPDTY) >> 4; }
inline uint32_t hrtim_tima_chpar_get_chpfrq(struct HRTIM_TIMA_Type *p) { return (p->CHPAR & HRTIM_TIMA_CHPAR_CHPFRQ) >> 0; }

// HRTIM_TIMA->CPT1ACR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMA_CPT1ACR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMA_CPT1ACR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMA_CPT1ACR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMA_CPT1ACR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMA_CPT1ACR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMA_CPT1ACR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMA_CPT1ACR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMA_CPT1ACR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMA_CPT1ACR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMA_CPT1ACR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMA_CPT1ACR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMA_CPT1ACR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMA_CPT1ACR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMA_CPT1ACR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMA_CPT1ACR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMA_CPT1ACR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMA_CPT1ACR_TFCMP2	 = 1UL << 15,  // TFCMP2
	HRTIM_TIMA_CPT1ACR_TFCMP1	 = 1UL << 14,  // TFCMP1
	HRTIM_TIMA_CPT1ACR_TF1RST	 = 1UL << 13,  // TF1RST
	HRTIM_TIMA_CPT1ACR_TF1SET	 = 1UL << 12,  // TF1SET
	HRTIM_TIMA_CPT1ACR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMA_CPT1ACR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMA_CPT1ACR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMA_CPT1ACR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMA_CPT1ACR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMA_CPT1ACR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMA_CPT1ACR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMA_CPT1ACR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMA_CPT1ACR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMA_CPT1ACR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMA_CPT1ACR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMA_CPT1ACR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMA->CPT2ACR CPT2xCR
enum {
	HRTIM_TIMA_CPT2ACR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMA_CPT2ACR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMA_CPT2ACR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMA_CPT2ACR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMA_CPT2ACR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMA_CPT2ACR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMA_CPT2ACR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMA_CPT2ACR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMA_CPT2ACR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMA_CPT2ACR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMA_CPT2ACR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMA_CPT2ACR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMA_CPT2ACR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMA_CPT2ACR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMA_CPT2ACR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMA_CPT2ACR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMA_CPT2ACR_TFCMP2	 = 1UL << 15,  // TFCMP2
	HRTIM_TIMA_CPT2ACR_TFCMP1	 = 1UL << 14,  // TFCMP1
	HRTIM_TIMA_CPT2ACR_TF1RST	 = 1UL << 13,  // TF1RST
	HRTIM_TIMA_CPT2ACR_TF1SET	 = 1UL << 12,  // TF1SET
	HRTIM_TIMA_CPT2ACR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMA_CPT2ACR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMA_CPT2ACR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMA_CPT2ACR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMA_CPT2ACR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMA_CPT2ACR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMA_CPT2ACR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMA_CPT2ACR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMA_CPT2ACR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMA_CPT2ACR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMA_CPT2ACR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMA_CPT2ACR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMA->OUTAR Timerx Output Register
enum {
	HRTIM_TIMA_OUTAR_DIDL2	  = 1UL << 23,				 // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMA_OUTAR_CHP2	  = 1UL << 22,				 // Output 2 Chopper enable
	HRTIM_TIMA_OUTAR_FAULT2	  = ((1UL << 2) - 1) << 20,	 // Output 2 Fault state
	HRTIM_TIMA_OUTAR_IDLES2	  = 1UL << 19,				 // Output 2 Idle State
	HRTIM_TIMA_OUTAR_IDLEM2	  = 1UL << 18,				 // Output 2 Idle mode
	HRTIM_TIMA_OUTAR_POL2	  = 1UL << 17,				 // Output 2 polarity
	HRTIM_TIMA_OUTAR_BIAR	  = 1UL << 14,				 // Balanced Idle Automatic Resume
	HRTIM_TIMA_OUTAR_DLYPRT	  = ((1UL << 3) - 1) << 10,	 // Delayed Protection
	HRTIM_TIMA_OUTAR_DLYPRTEN = 1UL << 9,				 // Delayed Protection Enable
	HRTIM_TIMA_OUTAR_DTEN	  = 1UL << 8,				 // Deadtime enable
	HRTIM_TIMA_OUTAR_DIDL1	  = 1UL << 7,				 // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMA_OUTAR_CHP1	  = 1UL << 6,				 // Output 1 Chopper enable
	HRTIM_TIMA_OUTAR_FAULT1	  = ((1UL << 2) - 1) << 4,	 // Output 1 Fault state
	HRTIM_TIMA_OUTAR_IDLES1	  = 1UL << 3,				 // Output 1 Idle State
	HRTIM_TIMA_OUTAR_IDLEM1	  = 1UL << 2,				 // Output 1 Idle mode
	HRTIM_TIMA_OUTAR_POL1	  = 1UL << 1,				 // Output 1 polarity
};
inline void hrtim_tima_outar_set_fault2(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->OUTAR = (p->OUTAR & ~HRTIM_TIMA_OUTAR_FAULT2) | ((val << 20) & HRTIM_TIMA_OUTAR_FAULT2);
}
inline void hrtim_tima_outar_set_dlyprt(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->OUTAR = (p->OUTAR & ~HRTIM_TIMA_OUTAR_DLYPRT) | ((val << 10) & HRTIM_TIMA_OUTAR_DLYPRT);
}
inline void hrtim_tima_outar_set_fault1(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->OUTAR = (p->OUTAR & ~HRTIM_TIMA_OUTAR_FAULT1) | ((val << 4) & HRTIM_TIMA_OUTAR_FAULT1);
}
inline uint32_t hrtim_tima_outar_get_fault2(struct HRTIM_TIMA_Type *p) { return (p->OUTAR & HRTIM_TIMA_OUTAR_FAULT2) >> 20; }
inline uint32_t hrtim_tima_outar_get_dlyprt(struct HRTIM_TIMA_Type *p) { return (p->OUTAR & HRTIM_TIMA_OUTAR_DLYPRT) >> 10; }
inline uint32_t hrtim_tima_outar_get_fault1(struct HRTIM_TIMA_Type *p) { return (p->OUTAR & HRTIM_TIMA_OUTAR_FAULT1) >> 4; }

// HRTIM_TIMA->FLTAR Timerx Fault Register
enum {
	HRTIM_TIMA_FLTAR_FLTLCK = 1UL << 31,  // Fault sources Lock
	HRTIM_TIMA_FLTAR_FLT6EN = 1UL << 5,	  // Fault 6 enable
	HRTIM_TIMA_FLTAR_FLT5EN = 1UL << 4,	  // Fault 5 enable
	HRTIM_TIMA_FLTAR_FLT4EN = 1UL << 3,	  // Fault 4 enable
	HRTIM_TIMA_FLTAR_FLT3EN = 1UL << 2,	  // Fault 3 enable
	HRTIM_TIMA_FLTAR_FLT2EN = 1UL << 1,	  // Fault 2 enable
	HRTIM_TIMA_FLTAR_FLT1EN = 1UL << 0,	  // Fault 1 enable
};

// HRTIM_TIMA->TIMACR2 HRTIM Timerx Control Register 2
enum {
	HRTIM_TIMA_TIMACR2_TRGHLF = 1UL << 20,				 // Triggered-half mode
	HRTIM_TIMA_TIMACR2_GTCMP3 = 1UL << 17,				 // Greater than Compare 3 PWM mode
	HRTIM_TIMA_TIMACR2_GTCMP1 = 1UL << 16,				 // Greater than Compare 1 PWM mode
	HRTIM_TIMA_TIMACR2_FEROM  = ((1UL << 2) - 1) << 14,	 // Fault and Event Roll-Over Mode
	HRTIM_TIMA_TIMACR2_BMROM  = ((1UL << 2) - 1) << 12,	 // Burst Mode Roll-Over Mode
	HRTIM_TIMA_TIMACR2_ADROM  = ((1UL << 2) - 1) << 10,	 // ADC Roll-Over Mode
	HRTIM_TIMA_TIMACR2_OUTROM = ((1UL << 2) - 1) << 8,	 // Output Roll-Over Mode
	HRTIM_TIMA_TIMACR2_ROM	  = ((1UL << 2) - 1) << 6,	 // Roll-Over Mode
	HRTIM_TIMA_TIMACR2_UDM	  = 1UL << 4,				 // Up-Down Mode
	HRTIM_TIMA_TIMACR2_DCDR	  = 1UL << 2,				 // Dual Channel DAC Reset trigger
	HRTIM_TIMA_TIMACR2_DCDS	  = 1UL << 1,				 // Dual Channel DAC Step trigger
	HRTIM_TIMA_TIMACR2_DCDE	  = 1UL << 0,				 // Dual Channel DAC trigger enable
};
inline void hrtim_tima_timacr2_set_ferom(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR2 = (p->TIMACR2 & ~HRTIM_TIMA_TIMACR2_FEROM) | ((val << 14) & HRTIM_TIMA_TIMACR2_FEROM);
}
inline void hrtim_tima_timacr2_set_bmrom(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR2 = (p->TIMACR2 & ~HRTIM_TIMA_TIMACR2_BMROM) | ((val << 12) & HRTIM_TIMA_TIMACR2_BMROM);
}
inline void hrtim_tima_timacr2_set_adrom(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR2 = (p->TIMACR2 & ~HRTIM_TIMA_TIMACR2_ADROM) | ((val << 10) & HRTIM_TIMA_TIMACR2_ADROM);
}
inline void hrtim_tima_timacr2_set_outrom(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR2 = (p->TIMACR2 & ~HRTIM_TIMA_TIMACR2_OUTROM) | ((val << 8) & HRTIM_TIMA_TIMACR2_OUTROM);
}
inline void hrtim_tima_timacr2_set_rom(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->TIMACR2 = (p->TIMACR2 & ~HRTIM_TIMA_TIMACR2_ROM) | ((val << 6) & HRTIM_TIMA_TIMACR2_ROM);
}
inline uint32_t hrtim_tima_timacr2_get_ferom(struct HRTIM_TIMA_Type *p) { return (p->TIMACR2 & HRTIM_TIMA_TIMACR2_FEROM) >> 14; }
inline uint32_t hrtim_tima_timacr2_get_bmrom(struct HRTIM_TIMA_Type *p) { return (p->TIMACR2 & HRTIM_TIMA_TIMACR2_BMROM) >> 12; }
inline uint32_t hrtim_tima_timacr2_get_adrom(struct HRTIM_TIMA_Type *p) { return (p->TIMACR2 & HRTIM_TIMA_TIMACR2_ADROM) >> 10; }
inline uint32_t hrtim_tima_timacr2_get_outrom(struct HRTIM_TIMA_Type *p) { return (p->TIMACR2 & HRTIM_TIMA_TIMACR2_OUTROM) >> 8; }
inline uint32_t hrtim_tima_timacr2_get_rom(struct HRTIM_TIMA_Type *p) { return (p->TIMACR2 & HRTIM_TIMA_TIMACR2_ROM) >> 6; }

// HRTIM_TIMA->AEEFR3 HRTIM Timerx External Event Filtering Register 3
enum {
	HRTIM_TIMA_AEEFR3_EEVACNT  = ((1UL << 6) - 1) << 8,	 // External Event A counter
	HRTIM_TIMA_AEEFR3_EEVASEL  = ((1UL << 4) - 1) << 4,	 // External Event A Selection
	HRTIM_TIMA_AEEFR3_EEVARSTM = 1UL << 2,				 // External Event A Reset Mode
	HRTIM_TIMA_AEEFR3_EEVACRES = 1UL << 1,				 // External Event A Counter Reset
	HRTIM_TIMA_AEEFR3_EEVACE   = 1UL << 0,				 // External Event A Counter Enable
};
inline void hrtim_tima_aeefr3_set_eevacnt(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->AEEFR3 = (p->AEEFR3 & ~HRTIM_TIMA_AEEFR3_EEVACNT) | ((val << 8) & HRTIM_TIMA_AEEFR3_EEVACNT);
}
inline void hrtim_tima_aeefr3_set_eevasel(struct HRTIM_TIMA_Type *p, uint32_t val) {
	p->AEEFR3 = (p->AEEFR3 & ~HRTIM_TIMA_AEEFR3_EEVASEL) | ((val << 4) & HRTIM_TIMA_AEEFR3_EEVASEL);
}
inline uint32_t hrtim_tima_aeefr3_get_eevacnt(struct HRTIM_TIMA_Type *p) { return (p->AEEFR3 & HRTIM_TIMA_AEEFR3_EEVACNT) >> 8; }
inline uint32_t hrtim_tima_aeefr3_get_eevasel(struct HRTIM_TIMA_Type *p) { return (p->AEEFR3 & HRTIM_TIMA_AEEFR3_EEVASEL) >> 4; }

/* High Resolution Timer: TIMB */
struct HRTIM_TIMB_Type {
	__IO uint32_t TIMBCR;		 // @0 Timerx Control Register
	__I uint32_t  TIMBISR;		 // @4 Timerx Interrupt Status Register
	__O uint16_t  TIMBICR;		 // @8 Timerx Interrupt Clear Register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t TIMBDIER;		 // @12 TIMxDIER
	__IO uint16_t CNTR;			 // @16 Timerx Counter Register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t PERBR;		 // @20 Timerx Period Register
	uint8_t		  RESERVED2[2];	 // @22
	__IO uint8_t  REPBR;		 // @24 Timerx Repetition Register
	uint8_t		  RESERVED3[3];	 // @25
	__IO uint16_t CMP1BR;		 // @28 Timerx Compare 1 Register
	uint8_t		  RESERVED4[2];	 // @30
	__IO uint32_t CMP1CBR;		 // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2BR;		 // @36 Timerx Compare 2 Register
	uint8_t		  RESERVED5[2];	 // @38
	__IO uint16_t CMP3BR;		 // @40 Timerx Compare 3 Register
	uint8_t		  RESERVED6[2];	 // @42
	__IO uint16_t CMP4BR;		 // @44 Timerx Compare 4 Register
	uint8_t		  RESERVED7[2];	 // @46
	__I uint32_t  CPT1BR;		 // @48 Timerx Capture 1 Register
	__I uint32_t  CPT2BR;		 // @52 Timerx Capture 2 Register
	__IO uint32_t DTBR;			 // @56 Timerx Deadtime Register
	__IO uint32_t SETB1R;		 // @60 Timerx Output1 Set Register
	__IO uint32_t RSTB1R;		 // @64 Timerx Output1 Reset Register
	__IO uint32_t SETB2R;		 // @68 Timerx Output2 Set Register
	__IO uint32_t RSTB2R;		 // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFBR1;		 // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFBR2;		 // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTBR;		 // @84 TimerA Reset Register
	__IO uint16_t CHPBR;		 // @88 Timerx Chopper Register
	uint8_t		  RESERVED8[2];	 // @90
	__IO uint32_t CPT1BCR;		 // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2BCR;		 // @96 CPT2xCR
	__IO uint32_t OUTBR;		 // @100 Timerx Output Register
	__IO uint32_t FLTBR;		 // @104 Timerx Fault Register
	__IO uint32_t TIMBCR2;		 // @108 HRTIM Timerx Control Register 2
	__IO uint16_t BEEFR3;		 // @112 HRTIM Timerx External Event Filtering Register 3
};

// HRTIM_TIMB->TIMBCR Timerx Control Register
enum {
	HRTIM_TIMB_TIMBCR_UPDGAT	= ((1UL << 4) - 1) << 28,  // Update Gating
	HRTIM_TIMB_TIMBCR_PREEN		= 1UL << 27,			   // Preload enable
	HRTIM_TIMB_TIMBCR_DACSYNC	= ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_TIMB_TIMBCR_MSTU		= 1UL << 24,			   // Master Timer update
	HRTIM_TIMB_TIMBCR_TEU		= 1UL << 23,			   // TEU
	HRTIM_TIMB_TIMBCR_TDU		= 1UL << 22,			   // TDU
	HRTIM_TIMB_TIMBCR_TCU		= 1UL << 21,			   // TCU
	HRTIM_TIMB_TIMBCR_TAU		= 1UL << 19,			   // TAU
	HRTIM_TIMB_TIMBCR_TXRSTU	= 1UL << 18,			   // Timerx reset update
	HRTIM_TIMB_TIMBCR_TXREPU	= 1UL << 17,			   // Timer x Repetition update
	HRTIM_TIMB_TIMBCR_TFU		= 1UL << 16,			   // TFU
	HRTIM_TIMB_TIMBCR_DELCMP4	= ((1UL << 2) - 1) << 14,  // Delayed CMP4 mode
	HRTIM_TIMB_TIMBCR_DELCMP2	= ((1UL << 2) - 1) << 12,  // Delayed CMP2 mode
	HRTIM_TIMB_TIMBCR_SYNCSTRTX = 1UL << 11,			   // Synchronization Starts Timer x
	HRTIM_TIMB_TIMBCR_SYNCRSTX	= 1UL << 10,			   // Synchronization Resets Timer x
	HRTIM_TIMB_TIMBCR_RSYNCU	= 1UL << 9,				   // Re-Synchronized Update
	HRTIM_TIMB_TIMBCR_INTLVD	= ((1UL << 2) - 1) << 7,   // Interleaved mode
	HRTIM_TIMB_TIMBCR_PSHPLL	= 1UL << 6,				   // Push-Pull mode enable
	HRTIM_TIMB_TIMBCR_HALF		= 1UL << 5,				   // Half mode enable
	HRTIM_TIMB_TIMBCR_RETRIG	= 1UL << 4,				   // Re-triggerable mode
	HRTIM_TIMB_TIMBCR_CONT		= 1UL << 3,				   // Continuous mode
	HRTIM_TIMB_TIMBCR_CK_PSCX	= ((1UL << 3) - 1) << 0,   // HRTIM Timer x Clock prescaler
};
inline void hrtim_timb_timbcr_set_updgat(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_UPDGAT) | ((val << 28) & HRTIM_TIMB_TIMBCR_UPDGAT);
}
inline void hrtim_timb_timbcr_set_dacsync(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_DACSYNC) | ((val << 25) & HRTIM_TIMB_TIMBCR_DACSYNC);
}
inline void hrtim_timb_timbcr_set_delcmp4(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_DELCMP4) | ((val << 14) & HRTIM_TIMB_TIMBCR_DELCMP4);
}
inline void hrtim_timb_timbcr_set_delcmp2(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_DELCMP2) | ((val << 12) & HRTIM_TIMB_TIMBCR_DELCMP2);
}
inline void hrtim_timb_timbcr_set_intlvd(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_INTLVD) | ((val << 7) & HRTIM_TIMB_TIMBCR_INTLVD);
}
inline void hrtim_timb_timbcr_set_ck_pscx(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR = (p->TIMBCR & ~HRTIM_TIMB_TIMBCR_CK_PSCX) | ((val << 0) & HRTIM_TIMB_TIMBCR_CK_PSCX);
}
inline uint32_t hrtim_timb_timbcr_get_updgat(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_UPDGAT) >> 28; }
inline uint32_t hrtim_timb_timbcr_get_dacsync(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_DACSYNC) >> 25; }
inline uint32_t hrtim_timb_timbcr_get_delcmp4(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_DELCMP4) >> 14; }
inline uint32_t hrtim_timb_timbcr_get_delcmp2(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_DELCMP2) >> 12; }
inline uint32_t hrtim_timb_timbcr_get_intlvd(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_INTLVD) >> 7; }
inline uint32_t hrtim_timb_timbcr_get_ck_pscx(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR & HRTIM_TIMB_TIMBCR_CK_PSCX) >> 0; }

// HRTIM_TIMB->TIMBISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMB_TIMBISR_O2CPY   = 1UL << 21,	 // Output 2 Copy
	HRTIM_TIMB_TIMBISR_O1CPY   = 1UL << 20,	 // Output 1 Copy
	HRTIM_TIMB_TIMBISR_O2STAT  = 1UL << 19,	 // Output 2 State
	HRTIM_TIMB_TIMBISR_O1STAT  = 1UL << 18,	 // Output 1 State
	HRTIM_TIMB_TIMBISR_IPPSTAT = 1UL << 17,	 // Idle Push Pull Status
	HRTIM_TIMB_TIMBISR_CPPSTAT = 1UL << 16,	 // Current Push Pull Status
	HRTIM_TIMB_TIMBISR_DLYPRT  = 1UL << 14,	 // Delayed Protection Flag
	HRTIM_TIMB_TIMBISR_RST	   = 1UL << 13,	 // Reset Interrupt Flag
	HRTIM_TIMB_TIMBISR_RSTX2   = 1UL << 12,	 // Output 2 Reset Interrupt Flag
	HRTIM_TIMB_TIMBISR_SETX2   = 1UL << 11,	 // Output 2 Set Interrupt Flag
	HRTIM_TIMB_TIMBISR_RSTX1   = 1UL << 10,	 // Output 1 Reset Interrupt Flag
	HRTIM_TIMB_TIMBISR_SETX1   = 1UL << 9,	 // Output 1 Set Interrupt Flag
	HRTIM_TIMB_TIMBISR_CPT2	   = 1UL << 8,	 // Capture2 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CPT1	   = 1UL << 7,	 // Capture1 Interrupt Flag
	HRTIM_TIMB_TIMBISR_UPD	   = 1UL << 6,	 // Update Interrupt Flag
	HRTIM_TIMB_TIMBISR_REP	   = 1UL << 4,	 // Repetition Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP4	   = 1UL << 3,	 // Compare 4 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP3	   = 1UL << 2,	 // Compare 3 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP2	   = 1UL << 1,	 // Compare 2 Interrupt Flag
	HRTIM_TIMB_TIMBISR_CMP1	   = 1UL << 0,	 // Compare 1 Interrupt Flag
};

// HRTIM_TIMB->TIMBICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMB_TIMBICR_DLYPRTC = 1UL << 14,	 // Delayed Protection Flag Clear
	HRTIM_TIMB_TIMBICR_RSTC	   = 1UL << 13,	 // Reset Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_RSTX2C  = 1UL << 12,	 // Output 2 Reset flag Clear
	HRTIM_TIMB_TIMBICR_SET2XC  = 1UL << 11,	 // Output 2 Set flag Clear
	HRTIM_TIMB_TIMBICR_RSTX1C  = 1UL << 10,	 // Output 1 Reset flag Clear
	HRTIM_TIMB_TIMBICR_SET1XC  = 1UL << 9,	 // Output 1 Set flag Clear
	HRTIM_TIMB_TIMBICR_CPT2C   = 1UL << 8,	 // Capture2 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CPT1C   = 1UL << 7,	 // Capture1 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_UPDC	   = 1UL << 6,	 // Update Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_REPC	   = 1UL << 4,	 // Repetition Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP4C   = 1UL << 3,	 // Compare 4 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP3C   = 1UL << 2,	 // Compare 3 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP2C   = 1UL << 1,	 // Compare 2 Interrupt flag Clear
	HRTIM_TIMB_TIMBICR_CMP1C   = 1UL << 0,	 // Compare 1 Interrupt flag Clear
};

// HRTIM_TIMB->TIMBDIER TIMxDIER
enum {
	HRTIM_TIMB_TIMBDIER_DLYPRTDE = 1UL << 30,  // DLYPRTDE
	HRTIM_TIMB_TIMBDIER_RSTDE	 = 1UL << 29,  // RSTDE
	HRTIM_TIMB_TIMBDIER_RSTX2DE	 = 1UL << 28,  // RSTx2DE
	HRTIM_TIMB_TIMBDIER_SETX2DE	 = 1UL << 27,  // SETx2DE
	HRTIM_TIMB_TIMBDIER_RSTX1DE	 = 1UL << 26,  // RSTx1DE
	HRTIM_TIMB_TIMBDIER_SET1XDE	 = 1UL << 25,  // SET1xDE
	HRTIM_TIMB_TIMBDIER_CPT2DE	 = 1UL << 24,  // CPT2DE
	HRTIM_TIMB_TIMBDIER_CPT1DE	 = 1UL << 23,  // CPT1DE
	HRTIM_TIMB_TIMBDIER_UPDDE	 = 1UL << 22,  // UPDDE
	HRTIM_TIMB_TIMBDIER_REPDE	 = 1UL << 20,  // REPDE
	HRTIM_TIMB_TIMBDIER_CMP4DE	 = 1UL << 19,  // CMP4DE
	HRTIM_TIMB_TIMBDIER_CMP3DE	 = 1UL << 18,  // CMP3DE
	HRTIM_TIMB_TIMBDIER_CMP2DE	 = 1UL << 17,  // CMP2DE
	HRTIM_TIMB_TIMBDIER_CMP1DE	 = 1UL << 16,  // CMP1DE
	HRTIM_TIMB_TIMBDIER_DLYPRTIE = 1UL << 14,  // DLYPRTIE
	HRTIM_TIMB_TIMBDIER_RSTIE	 = 1UL << 13,  // RSTIE
	HRTIM_TIMB_TIMBDIER_RSTX2IE	 = 1UL << 12,  // RSTx2IE
	HRTIM_TIMB_TIMBDIER_SETX2IE	 = 1UL << 11,  // SETx2IE
	HRTIM_TIMB_TIMBDIER_RSTX1IE	 = 1UL << 10,  // RSTx1IE
	HRTIM_TIMB_TIMBDIER_SET1XIE	 = 1UL << 9,   // SET1xIE
	HRTIM_TIMB_TIMBDIER_CPT2IE	 = 1UL << 8,   // CPT2IE
	HRTIM_TIMB_TIMBDIER_CPT1IE	 = 1UL << 7,   // CPT1IE
	HRTIM_TIMB_TIMBDIER_UPDIE	 = 1UL << 6,   // UPDIE
	HRTIM_TIMB_TIMBDIER_REPIE	 = 1UL << 4,   // REPIE
	HRTIM_TIMB_TIMBDIER_CMP4IE	 = 1UL << 3,   // CMP4IE
	HRTIM_TIMB_TIMBDIER_CMP3IE	 = 1UL << 2,   // CMP3IE
	HRTIM_TIMB_TIMBDIER_CMP2IE	 = 1UL << 1,   // CMP2IE
	HRTIM_TIMB_TIMBDIER_CMP1IE	 = 1UL << 0,   // CMP1IE
};

// HRTIM_TIMB->CMP1CBR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMB_CMP1CBR_REPX	 = ((1UL << 8) - 1) << 16,	// Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMB_CMP1CBR_CMP1X = ((1UL << 16) - 1) << 0,	// Timerx Compare 1 value
};
inline void hrtim_timb_cmp1cbr_set_repx(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->CMP1CBR = (p->CMP1CBR & ~HRTIM_TIMB_CMP1CBR_REPX) | ((val << 16) & HRTIM_TIMB_CMP1CBR_REPX);
}
inline void hrtim_timb_cmp1cbr_set_cmp1x(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->CMP1CBR = (p->CMP1CBR & ~HRTIM_TIMB_CMP1CBR_CMP1X) | ((val << 0) & HRTIM_TIMB_CMP1CBR_CMP1X);
}
inline uint32_t hrtim_timb_cmp1cbr_get_repx(struct HRTIM_TIMB_Type *p) { return (p->CMP1CBR & HRTIM_TIMB_CMP1CBR_REPX) >> 16; }
inline uint32_t hrtim_timb_cmp1cbr_get_cmp1x(struct HRTIM_TIMB_Type *p) { return (p->CMP1CBR & HRTIM_TIMB_CMP1CBR_CMP1X) >> 0; }

// HRTIM_TIMB->CPT1BR Timerx Capture 1 Register
enum {
	HRTIM_TIMB_CPT1BR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMB_CPT1BR_CPT1X = ((1UL << 16) - 1) << 0,  // Timerx Capture 1 value
};
inline uint32_t hrtim_timb_cpt1br_get_cpt1x(struct HRTIM_TIMB_Type *p) { return (p->CPT1BR & HRTIM_TIMB_CPT1BR_CPT1X) >> 0; }

// HRTIM_TIMB->CPT2BR Timerx Capture 2 Register
enum {
	HRTIM_TIMB_CPT2BR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMB_CPT2BR_CPT2X = ((1UL << 16) - 1) << 0,  // Timerx Capture 2 value
};
inline uint32_t hrtim_timb_cpt2br_get_cpt2x(struct HRTIM_TIMB_Type *p) { return (p->CPT2BR & HRTIM_TIMB_CPT2BR_CPT2X) >> 0; }

// HRTIM_TIMB->DTBR Timerx Deadtime Register
enum {
	HRTIM_TIMB_DTBR_DTFLKX	= 1UL << 31,			   // Deadtime Falling Lock
	HRTIM_TIMB_DTBR_DTFSLKX = 1UL << 30,			   // Deadtime Falling Sign Lock
	HRTIM_TIMB_DTBR_SDTFX	= 1UL << 25,			   // Sign Deadtime Falling value
	HRTIM_TIMB_DTBR_DTFX	= ((1UL << 9) - 1) << 16,  // Deadtime Falling value
	HRTIM_TIMB_DTBR_DTRLKX	= 1UL << 15,			   // Deadtime Rising Lock
	HRTIM_TIMB_DTBR_DTRSLKX = 1UL << 14,			   // Deadtime Rising Sign Lock
	HRTIM_TIMB_DTBR_DTPRSC	= ((1UL << 3) - 1) << 10,  // Deadtime Prescaler
	HRTIM_TIMB_DTBR_SDTRX	= 1UL << 9,				   // Sign Deadtime Rising value
	HRTIM_TIMB_DTBR_DTRX	= ((1UL << 9) - 1) << 0,   // Deadtime Rising value
};
inline void hrtim_timb_dtbr_set_dtfx(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->DTBR = (p->DTBR & ~HRTIM_TIMB_DTBR_DTFX) | ((val << 16) & HRTIM_TIMB_DTBR_DTFX);
}
inline void hrtim_timb_dtbr_set_dtprsc(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->DTBR = (p->DTBR & ~HRTIM_TIMB_DTBR_DTPRSC) | ((val << 10) & HRTIM_TIMB_DTBR_DTPRSC);
}
inline void hrtim_timb_dtbr_set_dtrx(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->DTBR = (p->DTBR & ~HRTIM_TIMB_DTBR_DTRX) | ((val << 0) & HRTIM_TIMB_DTBR_DTRX);
}
inline uint32_t hrtim_timb_dtbr_get_dtfx(struct HRTIM_TIMB_Type *p) { return (p->DTBR & HRTIM_TIMB_DTBR_DTFX) >> 16; }
inline uint32_t hrtim_timb_dtbr_get_dtprsc(struct HRTIM_TIMB_Type *p) { return (p->DTBR & HRTIM_TIMB_DTBR_DTPRSC) >> 10; }
inline uint32_t hrtim_timb_dtbr_get_dtrx(struct HRTIM_TIMB_Type *p) { return (p->DTBR & HRTIM_TIMB_DTBR_DTRX) >> 0; }

// HRTIM_TIMB->SETB1R Timerx Output1 Set Register
enum {
	HRTIM_TIMB_SETB1R_UPDATE	= 1UL << 31,  // Registers update (transfer preload to active)
	HRTIM_TIMB_SETB1R_EXTEVNT10 = 1UL << 30,  // External Event 10
	HRTIM_TIMB_SETB1R_EXTEVNT9	= 1UL << 29,  // External Event 9
	HRTIM_TIMB_SETB1R_EXTEVNT8	= 1UL << 28,  // External Event 8
	HRTIM_TIMB_SETB1R_EXTEVNT7	= 1UL << 27,  // External Event 7
	HRTIM_TIMB_SETB1R_EXTEVNT6	= 1UL << 26,  // External Event 6
	HRTIM_TIMB_SETB1R_EXTEVNT5	= 1UL << 25,  // External Event 5
	HRTIM_TIMB_SETB1R_EXTEVNT4	= 1UL << 24,  // External Event 4
	HRTIM_TIMB_SETB1R_EXTEVNT3	= 1UL << 23,  // External Event 3
	HRTIM_TIMB_SETB1R_EXTEVNT2	= 1UL << 22,  // External Event 2
	HRTIM_TIMB_SETB1R_EXTEVNT1	= 1UL << 21,  // External Event 1
	HRTIM_TIMB_SETB1R_TIMEVNT9	= 1UL << 20,  // Timer Event 9
	HRTIM_TIMB_SETB1R_TIMEVNT8	= 1UL << 19,  // Timer Event 8
	HRTIM_TIMB_SETB1R_TIMEVNT7	= 1UL << 18,  // Timer Event 7
	HRTIM_TIMB_SETB1R_TIMEVNT6	= 1UL << 17,  // Timer Event 6
	HRTIM_TIMB_SETB1R_TIMEVNT5	= 1UL << 16,  // Timer Event 5
	HRTIM_TIMB_SETB1R_TIMEVNT4	= 1UL << 15,  // Timer Event 4
	HRTIM_TIMB_SETB1R_TIMEVNT3	= 1UL << 14,  // Timer Event 3
	HRTIM_TIMB_SETB1R_TIMEVNT2	= 1UL << 13,  // Timer Event 2
	HRTIM_TIMB_SETB1R_TIMEVNT1	= 1UL << 12,  // Timer Event 1
	HRTIM_TIMB_SETB1R_MSTCMP4	= 1UL << 11,  // Master Compare 4
	HRTIM_TIMB_SETB1R_MSTCMP3	= 1UL << 10,  // Master Compare 3
	HRTIM_TIMB_SETB1R_MSTCMP2	= 1UL << 9,	  // Master Compare 2
	HRTIM_TIMB_SETB1R_MSTCMP1	= 1UL << 8,	  // Master Compare 1
	HRTIM_TIMB_SETB1R_MSTPER	= 1UL << 7,	  // Master Period
	HRTIM_TIMB_SETB1R_CMP4		= 1UL << 6,	  // Timer A compare 4
	HRTIM_TIMB_SETB1R_CMP3		= 1UL << 5,	  // Timer A compare 3
	HRTIM_TIMB_SETB1R_CMP2		= 1UL << 4,	  // Timer A compare 2
	HRTIM_TIMB_SETB1R_CMP1		= 1UL << 3,	  // Timer A compare 1
	HRTIM_TIMB_SETB1R_PER		= 1UL << 2,	  // Timer A Period
	HRTIM_TIMB_SETB1R_RESYNC	= 1UL << 1,	  // Timer A resynchronizaton
	HRTIM_TIMB_SETB1R_SST		= 1UL << 0,	  // Software Set trigger
};

// HRTIM_TIMB->RSTB1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMB_RSTB1R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMB_RSTB1R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMB_RSTB1R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMB_RSTB1R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMB_RSTB1R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMB_RSTB1R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMB_RSTB1R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMB_RSTB1R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMB_RSTB1R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMB_RSTB1R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMB_RSTB1R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMB_RSTB1R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMB_RSTB1R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMB_RSTB1R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMB_RSTB1R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMB_RSTB1R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMB_RSTB1R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMB_RSTB1R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMB_RSTB1R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMB_RSTB1R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMB_RSTB1R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMB_RSTB1R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMB_RSTB1R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMB_RSTB1R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMB_RSTB1R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMB_RSTB1R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMB_RSTB1R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMB_RSTB1R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMB_RSTB1R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMB_RSTB1R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMB_RSTB1R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMB_RSTB1R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMB->SETB2R Timerx Output2 Set Register
enum {
	HRTIM_TIMB_SETB2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMB_SETB2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMB_SETB2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMB_SETB2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMB_SETB2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMB_SETB2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMB_SETB2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMB_SETB2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMB_SETB2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMB_SETB2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMB_SETB2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMB_SETB2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMB_SETB2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMB_SETB2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMB_SETB2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMB_SETB2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMB_SETB2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMB_SETB2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMB_SETB2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMB_SETB2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMB_SETB2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMB_SETB2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMB_SETB2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMB_SETB2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMB_SETB2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMB_SETB2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMB_SETB2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMB_SETB2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMB_SETB2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMB_SETB2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMB_SETB2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMB_SETB2R_SST		= 1UL << 0,	  // SST
};

// HRTIM_TIMB->RSTB2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMB_RSTB2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMB_RSTB2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMB_RSTB2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMB_RSTB2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMB_RSTB2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMB_RSTB2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMB_RSTB2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMB_RSTB2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMB_RSTB2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMB_RSTB2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMB_RSTB2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMB_RSTB2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMB_RSTB2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMB_RSTB2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMB_RSTB2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMB_RSTB2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMB_RSTB2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMB_RSTB2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMB_RSTB2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMB_RSTB2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMB_RSTB2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMB_RSTB2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMB_RSTB2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMB_RSTB2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMB_RSTB2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMB_RSTB2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMB_RSTB2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMB_RSTB2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMB_RSTB2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMB_RSTB2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMB_RSTB2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMB_RSTB2R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMB->EEFBR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMB_EEFBR1_EE5FLTR = ((1UL << 4) - 1) << 25,	 // External Event 5 filter
	HRTIM_TIMB_EEFBR1_EE5LTCH = 1UL << 24,				 // External Event 5 latch
	HRTIM_TIMB_EEFBR1_EE4FLTR = ((1UL << 4) - 1) << 19,	 // External Event 4 filter
	HRTIM_TIMB_EEFBR1_EE4LTCH = 1UL << 18,				 // External Event 4 latch
	HRTIM_TIMB_EEFBR1_EE3FLTR = ((1UL << 4) - 1) << 13,	 // External Event 3 filter
	HRTIM_TIMB_EEFBR1_EE3LTCH = 1UL << 12,				 // External Event 3 latch
	HRTIM_TIMB_EEFBR1_EE2FLTR = ((1UL << 4) - 1) << 7,	 // External Event 2 filter
	HRTIM_TIMB_EEFBR1_EE2LTCH = 1UL << 6,				 // External Event 2 latch
	HRTIM_TIMB_EEFBR1_EE1FLTR = ((1UL << 4) - 1) << 1,	 // External Event 1 filter
	HRTIM_TIMB_EEFBR1_EE1LTCH = 1UL << 0,				 // External Event 1 latch
};
inline void hrtim_timb_eefbr1_set_ee5fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE5FLTR) | ((val << 25) & HRTIM_TIMB_EEFBR1_EE5FLTR);
}
inline void hrtim_timb_eefbr1_set_ee4fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE4FLTR) | ((val << 19) & HRTIM_TIMB_EEFBR1_EE4FLTR);
}
inline void hrtim_timb_eefbr1_set_ee3fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE3FLTR) | ((val << 13) & HRTIM_TIMB_EEFBR1_EE3FLTR);
}
inline void hrtim_timb_eefbr1_set_ee2fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE2FLTR) | ((val << 7) & HRTIM_TIMB_EEFBR1_EE2FLTR);
}
inline void hrtim_timb_eefbr1_set_ee1fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR1 = (p->EEFBR1 & ~HRTIM_TIMB_EEFBR1_EE1FLTR) | ((val << 1) & HRTIM_TIMB_EEFBR1_EE1FLTR);
}
inline uint32_t hrtim_timb_eefbr1_get_ee5fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE5FLTR) >> 25; }
inline uint32_t hrtim_timb_eefbr1_get_ee4fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE4FLTR) >> 19; }
inline uint32_t hrtim_timb_eefbr1_get_ee3fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE3FLTR) >> 13; }
inline uint32_t hrtim_timb_eefbr1_get_ee2fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE2FLTR) >> 7; }
inline uint32_t hrtim_timb_eefbr1_get_ee1fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR1 & HRTIM_TIMB_EEFBR1_EE1FLTR) >> 1; }

// HRTIM_TIMB->EEFBR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMB_EEFBR2_EE10FLTR = ((1UL << 4) - 1) << 25,  // External Event 10 filter
	HRTIM_TIMB_EEFBR2_EE10LTCH = 1UL << 24,				  // External Event 10 latch
	HRTIM_TIMB_EEFBR2_EE9FLTR  = ((1UL << 4) - 1) << 19,  // External Event 9 filter
	HRTIM_TIMB_EEFBR2_EE9LTCH  = 1UL << 18,				  // External Event 9 latch
	HRTIM_TIMB_EEFBR2_EE8FLTR  = ((1UL << 4) - 1) << 13,  // External Event 8 filter
	HRTIM_TIMB_EEFBR2_EE8LTCH  = 1UL << 12,				  // External Event 8 latch
	HRTIM_TIMB_EEFBR2_EE7FLTR  = ((1UL << 4) - 1) << 7,	  // External Event 7 filter
	HRTIM_TIMB_EEFBR2_EE7LTCH  = 1UL << 6,				  // External Event 7 latch
	HRTIM_TIMB_EEFBR2_EE6FLTR  = ((1UL << 4) - 1) << 1,	  // External Event 6 filter
	HRTIM_TIMB_EEFBR2_EE6LTCH  = 1UL << 0,				  // External Event 6 latch
};
inline void hrtim_timb_eefbr2_set_ee10fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE10FLTR) | ((val << 25) & HRTIM_TIMB_EEFBR2_EE10FLTR);
}
inline void hrtim_timb_eefbr2_set_ee9fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE9FLTR) | ((val << 19) & HRTIM_TIMB_EEFBR2_EE9FLTR);
}
inline void hrtim_timb_eefbr2_set_ee8fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE8FLTR) | ((val << 13) & HRTIM_TIMB_EEFBR2_EE8FLTR);
}
inline void hrtim_timb_eefbr2_set_ee7fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE7FLTR) | ((val << 7) & HRTIM_TIMB_EEFBR2_EE7FLTR);
}
inline void hrtim_timb_eefbr2_set_ee6fltr(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->EEFBR2 = (p->EEFBR2 & ~HRTIM_TIMB_EEFBR2_EE6FLTR) | ((val << 1) & HRTIM_TIMB_EEFBR2_EE6FLTR);
}
inline uint32_t hrtim_timb_eefbr2_get_ee10fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE10FLTR) >> 25; }
inline uint32_t hrtim_timb_eefbr2_get_ee9fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE9FLTR) >> 19; }
inline uint32_t hrtim_timb_eefbr2_get_ee8fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE8FLTR) >> 13; }
inline uint32_t hrtim_timb_eefbr2_get_ee7fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE7FLTR) >> 7; }
inline uint32_t hrtim_timb_eefbr2_get_ee6fltr(struct HRTIM_TIMB_Type *p) { return (p->EEFBR2 & HRTIM_TIMB_EEFBR2_EE6FLTR) >> 1; }

// HRTIM_TIMB->RSTBR TimerA Reset Register
enum {
	HRTIM_TIMB_RSTBR_TIMFCPM2  = 1UL << 31,	 // Timer F Compare 2
	HRTIM_TIMB_RSTBR_TIMECMP4  = 1UL << 30,	 // Timer E Compare 4
	HRTIM_TIMB_RSTBR_TIMECMP2  = 1UL << 29,	 // Timer E Compare 2
	HRTIM_TIMB_RSTBR_TIMECMP1  = 1UL << 28,	 // Timer E Compare 1
	HRTIM_TIMB_RSTBR_TIMDCMP4  = 1UL << 27,	 // Timer D Compare 4
	HRTIM_TIMB_RSTBR_TIMDCMP2  = 1UL << 26,	 // Timer D Compare 2
	HRTIM_TIMB_RSTBR_TIMDCMP1  = 1UL << 25,	 // Timer D Compare 1
	HRTIM_TIMB_RSTBR_TIMCCMP4  = 1UL << 24,	 // Timer C Compare 4
	HRTIM_TIMB_RSTBR_TIMCCMP2  = 1UL << 23,	 // Timer C Compare 2
	HRTIM_TIMB_RSTBR_TIMCCMP1  = 1UL << 22,	 // Timer C Compare 1
	HRTIM_TIMB_RSTBR_TIMACMP4  = 1UL << 21,	 // Timer A Compare 4
	HRTIM_TIMB_RSTBR_TIMACMP2  = 1UL << 20,	 // Timer A Compare 2
	HRTIM_TIMB_RSTBR_TIMACMP1  = 1UL << 19,	 // Timer A Compare 1
	HRTIM_TIMB_RSTBR_EXTEVNT10 = 1UL << 18,	 // External Event 10
	HRTIM_TIMB_RSTBR_EXTEVNT9  = 1UL << 17,	 // External Event 9
	HRTIM_TIMB_RSTBR_EXTEVNT8  = 1UL << 16,	 // External Event 8
	HRTIM_TIMB_RSTBR_EXTEVNT7  = 1UL << 15,	 // External Event 7
	HRTIM_TIMB_RSTBR_EXTEVNT6  = 1UL << 14,	 // External Event 6
	HRTIM_TIMB_RSTBR_EXTEVNT5  = 1UL << 13,	 // External Event 5
	HRTIM_TIMB_RSTBR_EXTEVNT4  = 1UL << 12,	 // External Event 4
	HRTIM_TIMB_RSTBR_EXTEVNT3  = 1UL << 11,	 // External Event 3
	HRTIM_TIMB_RSTBR_EXTEVNT2  = 1UL << 10,	 // External Event 2
	HRTIM_TIMB_RSTBR_EXTEVNT1  = 1UL << 9,	 // External Event 1
	HRTIM_TIMB_RSTBR_MSTCMP4   = 1UL << 8,	 // Master compare 4
	HRTIM_TIMB_RSTBR_MSTCMP3   = 1UL << 7,	 // Master compare 3
	HRTIM_TIMB_RSTBR_MSTCMP2   = 1UL << 6,	 // Master compare 2
	HRTIM_TIMB_RSTBR_MSTCMP1   = 1UL << 5,	 // Master compare 1
	HRTIM_TIMB_RSTBR_MSTPER	   = 1UL << 4,	 // Master timer Period
	HRTIM_TIMB_RSTBR_CMP4	   = 1UL << 3,	 // Timer A compare 4 reset
	HRTIM_TIMB_RSTBR_CMP2	   = 1UL << 2,	 // Timer A compare 2 reset
	HRTIM_TIMB_RSTBR_UPDT	   = 1UL << 1,	 // Timer A Update reset
	HRTIM_TIMB_RSTBR_TIMFCMP1  = 1UL << 0,	 // Timer A Update reset
};

// HRTIM_TIMB->CHPBR Timerx Chopper Register
enum {
	HRTIM_TIMB_CHPBR_STRTPW = ((1UL << 4) - 1) << 7,  // STRTPW
	HRTIM_TIMB_CHPBR_CHPDTY = ((1UL << 3) - 1) << 4,  // Timerx chopper duty cycle value
	HRTIM_TIMB_CHPBR_CHPFRQ = ((1UL << 4) - 1) << 0,  // Timerx carrier frequency value
};
inline void hrtim_timb_chpbr_set_strtpw(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->CHPBR = (p->CHPBR & ~HRTIM_TIMB_CHPBR_STRTPW) | ((val << 7) & HRTIM_TIMB_CHPBR_STRTPW);
}
inline void hrtim_timb_chpbr_set_chpdty(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->CHPBR = (p->CHPBR & ~HRTIM_TIMB_CHPBR_CHPDTY) | ((val << 4) & HRTIM_TIMB_CHPBR_CHPDTY);
}
inline void hrtim_timb_chpbr_set_chpfrq(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->CHPBR = (p->CHPBR & ~HRTIM_TIMB_CHPBR_CHPFRQ) | ((val << 0) & HRTIM_TIMB_CHPBR_CHPFRQ);
}
inline uint32_t hrtim_timb_chpbr_get_strtpw(struct HRTIM_TIMB_Type *p) { return (p->CHPBR & HRTIM_TIMB_CHPBR_STRTPW) >> 7; }
inline uint32_t hrtim_timb_chpbr_get_chpdty(struct HRTIM_TIMB_Type *p) { return (p->CHPBR & HRTIM_TIMB_CHPBR_CHPDTY) >> 4; }
inline uint32_t hrtim_timb_chpbr_get_chpfrq(struct HRTIM_TIMB_Type *p) { return (p->CHPBR & HRTIM_TIMB_CHPBR_CHPFRQ) >> 0; }

// HRTIM_TIMB->CPT1BCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMB_CPT1BCR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMB_CPT1BCR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMB_CPT1BCR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMB_CPT1BCR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMB_CPT1BCR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMB_CPT1BCR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMB_CPT1BCR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMB_CPT1BCR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMB_CPT1BCR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMB_CPT1BCR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMB_CPT1BCR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMB_CPT1BCR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMB_CPT1BCR_TFCMP2	 = 1UL << 19,  // TFCMP2
	HRTIM_TIMB_CPT1BCR_TFCMP1	 = 1UL << 18,  // TFCMP1
	HRTIM_TIMB_CPT1BCR_TF1RST	 = 1UL << 17,  // TF1RST
	HRTIM_TIMB_CPT1BCR_TF1SET	 = 1UL << 16,  // TF1SET
	HRTIM_TIMB_CPT1BCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMB_CPT1BCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMB_CPT1BCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMB_CPT1BCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMB_CPT1BCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMB_CPT1BCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMB_CPT1BCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMB_CPT1BCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMB_CPT1BCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMB_CPT1BCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMB_CPT1BCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMB_CPT1BCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMB_CPT1BCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMB_CPT1BCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMB_CPT1BCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMB_CPT1BCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMB->CPT2BCR CPT2xCR
enum {
	HRTIM_TIMB_CPT2BCR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMB_CPT2BCR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMB_CPT2BCR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMB_CPT2BCR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMB_CPT2BCR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMB_CPT2BCR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMB_CPT2BCR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMB_CPT2BCR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMB_CPT2BCR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMB_CPT2BCR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMB_CPT2BCR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMB_CPT2BCR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMB_CPT2BCR_TFCMP2	 = 1UL << 19,  // TFCMP2
	HRTIM_TIMB_CPT2BCR_TFCMP1	 = 1UL << 18,  // TFCMP1
	HRTIM_TIMB_CPT2BCR_TF1RST	 = 1UL << 17,  // TF1RST
	HRTIM_TIMB_CPT2BCR_TF1SET	 = 1UL << 16,  // TF1SET
	HRTIM_TIMB_CPT2BCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMB_CPT2BCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMB_CPT2BCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMB_CPT2BCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMB_CPT2BCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMB_CPT2BCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMB_CPT2BCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMB_CPT2BCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMB_CPT2BCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMB_CPT2BCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMB_CPT2BCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMB_CPT2BCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMB_CPT2BCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMB_CPT2BCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMB_CPT2BCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMB_CPT2BCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMB->OUTBR Timerx Output Register
enum {
	HRTIM_TIMB_OUTBR_DIDL2	  = 1UL << 23,				 // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMB_OUTBR_CHP2	  = 1UL << 22,				 // Output 2 Chopper enable
	HRTIM_TIMB_OUTBR_FAULT2	  = ((1UL << 2) - 1) << 20,	 // Output 2 Fault state
	HRTIM_TIMB_OUTBR_IDLES2	  = 1UL << 19,				 // Output 2 Idle State
	HRTIM_TIMB_OUTBR_IDLEM2	  = 1UL << 18,				 // Output 2 Idle mode
	HRTIM_TIMB_OUTBR_POL2	  = 1UL << 17,				 // Output 2 polarity
	HRTIM_TIMB_OUTBR_BIAR	  = 1UL << 14,				 // Balanced Idle Automatic Resume
	HRTIM_TIMB_OUTBR_DLYPRT	  = ((1UL << 3) - 1) << 10,	 // Delayed Protection
	HRTIM_TIMB_OUTBR_DLYPRTEN = 1UL << 9,				 // Delayed Protection Enable
	HRTIM_TIMB_OUTBR_DTEN	  = 1UL << 8,				 // Deadtime enable
	HRTIM_TIMB_OUTBR_DIDL1	  = 1UL << 7,				 // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMB_OUTBR_CHP1	  = 1UL << 6,				 // Output 1 Chopper enable
	HRTIM_TIMB_OUTBR_FAULT1	  = ((1UL << 2) - 1) << 4,	 // Output 1 Fault state
	HRTIM_TIMB_OUTBR_IDLES1	  = 1UL << 3,				 // Output 1 Idle State
	HRTIM_TIMB_OUTBR_IDLEM1	  = 1UL << 2,				 // Output 1 Idle mode
	HRTIM_TIMB_OUTBR_POL1	  = 1UL << 1,				 // Output 1 polarity
};
inline void hrtim_timb_outbr_set_fault2(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->OUTBR = (p->OUTBR & ~HRTIM_TIMB_OUTBR_FAULT2) | ((val << 20) & HRTIM_TIMB_OUTBR_FAULT2);
}
inline void hrtim_timb_outbr_set_dlyprt(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->OUTBR = (p->OUTBR & ~HRTIM_TIMB_OUTBR_DLYPRT) | ((val << 10) & HRTIM_TIMB_OUTBR_DLYPRT);
}
inline void hrtim_timb_outbr_set_fault1(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->OUTBR = (p->OUTBR & ~HRTIM_TIMB_OUTBR_FAULT1) | ((val << 4) & HRTIM_TIMB_OUTBR_FAULT1);
}
inline uint32_t hrtim_timb_outbr_get_fault2(struct HRTIM_TIMB_Type *p) { return (p->OUTBR & HRTIM_TIMB_OUTBR_FAULT2) >> 20; }
inline uint32_t hrtim_timb_outbr_get_dlyprt(struct HRTIM_TIMB_Type *p) { return (p->OUTBR & HRTIM_TIMB_OUTBR_DLYPRT) >> 10; }
inline uint32_t hrtim_timb_outbr_get_fault1(struct HRTIM_TIMB_Type *p) { return (p->OUTBR & HRTIM_TIMB_OUTBR_FAULT1) >> 4; }

// HRTIM_TIMB->FLTBR Timerx Fault Register
enum {
	HRTIM_TIMB_FLTBR_FLTLCK = 1UL << 31,  // Fault sources Lock
	HRTIM_TIMB_FLTBR_FLT6EN = 1UL << 5,	  // Fault 6 enable
	HRTIM_TIMB_FLTBR_FLT5EN = 1UL << 4,	  // Fault 5 enable
	HRTIM_TIMB_FLTBR_FLT4EN = 1UL << 3,	  // Fault 4 enable
	HRTIM_TIMB_FLTBR_FLT3EN = 1UL << 2,	  // Fault 3 enable
	HRTIM_TIMB_FLTBR_FLT2EN = 1UL << 1,	  // Fault 2 enable
	HRTIM_TIMB_FLTBR_FLT1EN = 1UL << 0,	  // Fault 1 enable
};

// HRTIM_TIMB->TIMBCR2 HRTIM Timerx Control Register 2
enum {
	HRTIM_TIMB_TIMBCR2_TRGHLF = 1UL << 20,				 // Triggered-half mode
	HRTIM_TIMB_TIMBCR2_GTCMP3 = 1UL << 17,				 // Greater than Compare 3 PWM mode
	HRTIM_TIMB_TIMBCR2_GTCMP1 = 1UL << 16,				 // Greater than Compare 1 PWM mode
	HRTIM_TIMB_TIMBCR2_FEROM  = ((1UL << 2) - 1) << 14,	 // Fault and Event Roll-Over Mode
	HRTIM_TIMB_TIMBCR2_BMROM  = ((1UL << 2) - 1) << 12,	 // Burst Mode Roll-Over Mode
	HRTIM_TIMB_TIMBCR2_ADROM  = ((1UL << 2) - 1) << 10,	 // ADC Roll-Over Mode
	HRTIM_TIMB_TIMBCR2_OUTROM = ((1UL << 2) - 1) << 8,	 // Output Roll-Over Mode
	HRTIM_TIMB_TIMBCR2_ROM	  = ((1UL << 2) - 1) << 6,	 // Roll-Over Mode
	HRTIM_TIMB_TIMBCR2_UDM	  = 1UL << 4,				 // Up-Down Mode
	HRTIM_TIMB_TIMBCR2_DCDR	  = 1UL << 2,				 // Dual Channel DAC Reset trigger
	HRTIM_TIMB_TIMBCR2_DCDS	  = 1UL << 1,				 // Dual Channel DAC Step trigger
	HRTIM_TIMB_TIMBCR2_DCDE	  = 1UL << 0,				 // Dual Channel DAC trigger enable
};
inline void hrtim_timb_timbcr2_set_ferom(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR2 = (p->TIMBCR2 & ~HRTIM_TIMB_TIMBCR2_FEROM) | ((val << 14) & HRTIM_TIMB_TIMBCR2_FEROM);
}
inline void hrtim_timb_timbcr2_set_bmrom(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR2 = (p->TIMBCR2 & ~HRTIM_TIMB_TIMBCR2_BMROM) | ((val << 12) & HRTIM_TIMB_TIMBCR2_BMROM);
}
inline void hrtim_timb_timbcr2_set_adrom(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR2 = (p->TIMBCR2 & ~HRTIM_TIMB_TIMBCR2_ADROM) | ((val << 10) & HRTIM_TIMB_TIMBCR2_ADROM);
}
inline void hrtim_timb_timbcr2_set_outrom(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR2 = (p->TIMBCR2 & ~HRTIM_TIMB_TIMBCR2_OUTROM) | ((val << 8) & HRTIM_TIMB_TIMBCR2_OUTROM);
}
inline void hrtim_timb_timbcr2_set_rom(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->TIMBCR2 = (p->TIMBCR2 & ~HRTIM_TIMB_TIMBCR2_ROM) | ((val << 6) & HRTIM_TIMB_TIMBCR2_ROM);
}
inline uint32_t hrtim_timb_timbcr2_get_ferom(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR2 & HRTIM_TIMB_TIMBCR2_FEROM) >> 14; }
inline uint32_t hrtim_timb_timbcr2_get_bmrom(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR2 & HRTIM_TIMB_TIMBCR2_BMROM) >> 12; }
inline uint32_t hrtim_timb_timbcr2_get_adrom(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR2 & HRTIM_TIMB_TIMBCR2_ADROM) >> 10; }
inline uint32_t hrtim_timb_timbcr2_get_outrom(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR2 & HRTIM_TIMB_TIMBCR2_OUTROM) >> 8; }
inline uint32_t hrtim_timb_timbcr2_get_rom(struct HRTIM_TIMB_Type *p) { return (p->TIMBCR2 & HRTIM_TIMB_TIMBCR2_ROM) >> 6; }

// HRTIM_TIMB->BEEFR3 HRTIM Timerx External Event Filtering Register 3
enum {
	HRTIM_TIMB_BEEFR3_EEVACNT  = ((1UL << 6) - 1) << 8,	 // External Event A counter
	HRTIM_TIMB_BEEFR3_EEVASEL  = ((1UL << 4) - 1) << 4,	 // External Event A Selection
	HRTIM_TIMB_BEEFR3_EEVARSTM = 1UL << 2,				 // External Event A Reset Mode
	HRTIM_TIMB_BEEFR3_EEVACRES = 1UL << 1,				 // External Event A Counter Reset
	HRTIM_TIMB_BEEFR3_EEVACE   = 1UL << 0,				 // External Event A Counter Enable
};
inline void hrtim_timb_beefr3_set_eevacnt(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->BEEFR3 = (p->BEEFR3 & ~HRTIM_TIMB_BEEFR3_EEVACNT) | ((val << 8) & HRTIM_TIMB_BEEFR3_EEVACNT);
}
inline void hrtim_timb_beefr3_set_eevasel(struct HRTIM_TIMB_Type *p, uint32_t val) {
	p->BEEFR3 = (p->BEEFR3 & ~HRTIM_TIMB_BEEFR3_EEVASEL) | ((val << 4) & HRTIM_TIMB_BEEFR3_EEVASEL);
}
inline uint32_t hrtim_timb_beefr3_get_eevacnt(struct HRTIM_TIMB_Type *p) { return (p->BEEFR3 & HRTIM_TIMB_BEEFR3_EEVACNT) >> 8; }
inline uint32_t hrtim_timb_beefr3_get_eevasel(struct HRTIM_TIMB_Type *p) { return (p->BEEFR3 & HRTIM_TIMB_BEEFR3_EEVASEL) >> 4; }

/* High Resolution Timer: TIMC */
struct HRTIM_TIMC_Type {
	__IO uint32_t TIMCCR;		 // @0 Timerx Control Register
	__I uint32_t  TIMCISR;		 // @4 Timerx Interrupt Status Register
	__O uint16_t  TIMCICR;		 // @8 Timerx Interrupt Clear Register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t TIMCDIER;		 // @12 TIMxDIER
	__IO uint16_t CNTCR;		 // @16 Timerx Counter Register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t PERCR;		 // @20 Timerx Period Register
	uint8_t		  RESERVED2[2];	 // @22
	__IO uint8_t  REPCR;		 // @24 Timerx Repetition Register
	uint8_t		  RESERVED3[3];	 // @25
	__IO uint16_t CMP1CR;		 // @28 Timerx Compare 1 Register
	uint8_t		  RESERVED4[2];	 // @30
	__IO uint32_t CMP1CCR;		 // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2CR;		 // @36 Timerx Compare 2 Register
	uint8_t		  RESERVED5[2];	 // @38
	__IO uint16_t CMP3CR;		 // @40 Timerx Compare 3 Register
	uint8_t		  RESERVED6[2];	 // @42
	__IO uint16_t CMP4CR;		 // @44 Timerx Compare 4 Register
	uint8_t		  RESERVED7[2];	 // @46
	__I uint32_t  CPT1CR;		 // @48 Timerx Capture 1 Register
	__I uint32_t  CPT2CR;		 // @52 Timerx Capture 2 Register
	__IO uint32_t DTCR;			 // @56 Timerx Deadtime Register
	__IO uint32_t SETC1R;		 // @60 Timerx Output1 Set Register
	__IO uint32_t RSTC1R;		 // @64 Timerx Output1 Reset Register
	__IO uint32_t SETC2R;		 // @68 Timerx Output2 Set Register
	__IO uint32_t RSTC2R;		 // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFCR1;		 // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFCR2;		 // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTCR;		 // @84 TimerA Reset Register
	__IO uint16_t CHPCR;		 // @88 Timerx Chopper Register
	uint8_t		  RESERVED8[2];	 // @90
	__IO uint32_t CPT1CCR;		 // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2CCR;		 // @96 CPT2xCR
	__IO uint32_t OUTCR;		 // @100 Timerx Output Register
	__IO uint32_t FLTCR;		 // @104 Timerx Fault Register
	__IO uint32_t TIMCCR2;		 // @108 HRTIM Timerx Control Register 2
	__IO uint16_t CEEFR3;		 // @112 HRTIM Timerx External Event Filtering Register 3
};

// HRTIM_TIMC->TIMCCR Timerx Control Register
enum {
	HRTIM_TIMC_TIMCCR_UPDGAT	= ((1UL << 4) - 1) << 28,  // Update Gating
	HRTIM_TIMC_TIMCCR_PREEN		= 1UL << 27,			   // Preload enable
	HRTIM_TIMC_TIMCCR_DACSYNC	= ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_TIMC_TIMCCR_MSTU		= 1UL << 24,			   // Master Timer update
	HRTIM_TIMC_TIMCCR_TEU		= 1UL << 23,			   // TEU
	HRTIM_TIMC_TIMCCR_TDU		= 1UL << 22,			   // TDU
	HRTIM_TIMC_TIMCCR_TBU		= 1UL << 20,			   // TBU
	HRTIM_TIMC_TIMCCR_TAU		= 1UL << 19,			   // TAU
	HRTIM_TIMC_TIMCCR_TXRSTU	= 1UL << 18,			   // Timerx reset update
	HRTIM_TIMC_TIMCCR_TXREPU	= 1UL << 17,			   // Timer x Repetition update
	HRTIM_TIMC_TIMCCR_TFU		= 1UL << 16,			   // TFU
	HRTIM_TIMC_TIMCCR_DELCMP4	= ((1UL << 2) - 1) << 14,  // Delayed CMP4 mode
	HRTIM_TIMC_TIMCCR_DELCMP2	= ((1UL << 2) - 1) << 12,  // Delayed CMP2 mode
	HRTIM_TIMC_TIMCCR_SYNCSTRTX = 1UL << 11,			   // Synchronization Starts Timer x
	HRTIM_TIMC_TIMCCR_SYNCRSTX	= 1UL << 10,			   // Synchronization Resets Timer x
	HRTIM_TIMC_TIMCCR_RSYNCU	= 1UL << 9,				   // Re-Synchronized Update
	HRTIM_TIMC_TIMCCR_INTLVD	= ((1UL << 2) - 1) << 7,   // Interleaved mode
	HRTIM_TIMC_TIMCCR_PSHPLL	= 1UL << 6,				   // Push-Pull mode enable
	HRTIM_TIMC_TIMCCR_HALF		= 1UL << 5,				   // Half mode enable
	HRTIM_TIMC_TIMCCR_RETRIG	= 1UL << 4,				   // Re-triggerable mode
	HRTIM_TIMC_TIMCCR_CONT		= 1UL << 3,				   // Continuous mode
	HRTIM_TIMC_TIMCCR_CK_PSCX	= ((1UL << 3) - 1) << 0,   // HRTIM Timer x Clock prescaler
};
inline void hrtim_timc_timccr_set_updgat(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_UPDGAT) | ((val << 28) & HRTIM_TIMC_TIMCCR_UPDGAT);
}
inline void hrtim_timc_timccr_set_dacsync(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_DACSYNC) | ((val << 25) & HRTIM_TIMC_TIMCCR_DACSYNC);
}
inline void hrtim_timc_timccr_set_delcmp4(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_DELCMP4) | ((val << 14) & HRTIM_TIMC_TIMCCR_DELCMP4);
}
inline void hrtim_timc_timccr_set_delcmp2(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_DELCMP2) | ((val << 12) & HRTIM_TIMC_TIMCCR_DELCMP2);
}
inline void hrtim_timc_timccr_set_intlvd(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_INTLVD) | ((val << 7) & HRTIM_TIMC_TIMCCR_INTLVD);
}
inline void hrtim_timc_timccr_set_ck_pscx(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR = (p->TIMCCR & ~HRTIM_TIMC_TIMCCR_CK_PSCX) | ((val << 0) & HRTIM_TIMC_TIMCCR_CK_PSCX);
}
inline uint32_t hrtim_timc_timccr_get_updgat(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_UPDGAT) >> 28; }
inline uint32_t hrtim_timc_timccr_get_dacsync(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_DACSYNC) >> 25; }
inline uint32_t hrtim_timc_timccr_get_delcmp4(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_DELCMP4) >> 14; }
inline uint32_t hrtim_timc_timccr_get_delcmp2(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_DELCMP2) >> 12; }
inline uint32_t hrtim_timc_timccr_get_intlvd(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_INTLVD) >> 7; }
inline uint32_t hrtim_timc_timccr_get_ck_pscx(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR & HRTIM_TIMC_TIMCCR_CK_PSCX) >> 0; }

// HRTIM_TIMC->TIMCISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMC_TIMCISR_O2CPY   = 1UL << 21,	 // Output 2 Copy
	HRTIM_TIMC_TIMCISR_O1CPY   = 1UL << 20,	 // Output 1 Copy
	HRTIM_TIMC_TIMCISR_O2STAT  = 1UL << 19,	 // Output 2 State
	HRTIM_TIMC_TIMCISR_O1STAT  = 1UL << 18,	 // Output 1 State
	HRTIM_TIMC_TIMCISR_IPPSTAT = 1UL << 17,	 // Idle Push Pull Status
	HRTIM_TIMC_TIMCISR_CPPSTAT = 1UL << 16,	 // Current Push Pull Status
	HRTIM_TIMC_TIMCISR_DLYPRT  = 1UL << 14,	 // Delayed Protection Flag
	HRTIM_TIMC_TIMCISR_RST	   = 1UL << 13,	 // Reset Interrupt Flag
	HRTIM_TIMC_TIMCISR_RSTX2   = 1UL << 12,	 // Output 2 Reset Interrupt Flag
	HRTIM_TIMC_TIMCISR_SETX2   = 1UL << 11,	 // Output 2 Set Interrupt Flag
	HRTIM_TIMC_TIMCISR_RSTX1   = 1UL << 10,	 // Output 1 Reset Interrupt Flag
	HRTIM_TIMC_TIMCISR_SETX1   = 1UL << 9,	 // Output 1 Set Interrupt Flag
	HRTIM_TIMC_TIMCISR_CPT2	   = 1UL << 8,	 // Capture2 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CPT1	   = 1UL << 7,	 // Capture1 Interrupt Flag
	HRTIM_TIMC_TIMCISR_UPD	   = 1UL << 6,	 // Update Interrupt Flag
	HRTIM_TIMC_TIMCISR_REP	   = 1UL << 4,	 // Repetition Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP4	   = 1UL << 3,	 // Compare 4 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP3	   = 1UL << 2,	 // Compare 3 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP2	   = 1UL << 1,	 // Compare 2 Interrupt Flag
	HRTIM_TIMC_TIMCISR_CMP1	   = 1UL << 0,	 // Compare 1 Interrupt Flag
};

// HRTIM_TIMC->TIMCICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMC_TIMCICR_DLYPRTC = 1UL << 14,	 // Delayed Protection Flag Clear
	HRTIM_TIMC_TIMCICR_RSTC	   = 1UL << 13,	 // Reset Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_RSTX2C  = 1UL << 12,	 // Output 2 Reset flag Clear
	HRTIM_TIMC_TIMCICR_SET2XC  = 1UL << 11,	 // Output 2 Set flag Clear
	HRTIM_TIMC_TIMCICR_RSTX1C  = 1UL << 10,	 // Output 1 Reset flag Clear
	HRTIM_TIMC_TIMCICR_SET1XC  = 1UL << 9,	 // Output 1 Set flag Clear
	HRTIM_TIMC_TIMCICR_CPT2C   = 1UL << 8,	 // Capture2 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CPT1C   = 1UL << 7,	 // Capture1 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_UPDC	   = 1UL << 6,	 // Update Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_REPC	   = 1UL << 4,	 // Repetition Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP4C   = 1UL << 3,	 // Compare 4 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP3C   = 1UL << 2,	 // Compare 3 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP2C   = 1UL << 1,	 // Compare 2 Interrupt flag Clear
	HRTIM_TIMC_TIMCICR_CMP1C   = 1UL << 0,	 // Compare 1 Interrupt flag Clear
};

// HRTIM_TIMC->TIMCDIER TIMxDIER
enum {
	HRTIM_TIMC_TIMCDIER_DLYPRTDE = 1UL << 30,  // DLYPRTDE
	HRTIM_TIMC_TIMCDIER_RSTDE	 = 1UL << 29,  // RSTDE
	HRTIM_TIMC_TIMCDIER_RSTX2DE	 = 1UL << 28,  // RSTx2DE
	HRTIM_TIMC_TIMCDIER_SETX2DE	 = 1UL << 27,  // SETx2DE
	HRTIM_TIMC_TIMCDIER_RSTX1DE	 = 1UL << 26,  // RSTx1DE
	HRTIM_TIMC_TIMCDIER_SET1XDE	 = 1UL << 25,  // SET1xDE
	HRTIM_TIMC_TIMCDIER_CPT2DE	 = 1UL << 24,  // CPT2DE
	HRTIM_TIMC_TIMCDIER_CPT1DE	 = 1UL << 23,  // CPT1DE
	HRTIM_TIMC_TIMCDIER_UPDDE	 = 1UL << 22,  // UPDDE
	HRTIM_TIMC_TIMCDIER_REPDE	 = 1UL << 20,  // REPDE
	HRTIM_TIMC_TIMCDIER_CMP4DE	 = 1UL << 19,  // CMP4DE
	HRTIM_TIMC_TIMCDIER_CMP3DE	 = 1UL << 18,  // CMP3DE
	HRTIM_TIMC_TIMCDIER_CMP2DE	 = 1UL << 17,  // CMP2DE
	HRTIM_TIMC_TIMCDIER_CMP1DE	 = 1UL << 16,  // CMP1DE
	HRTIM_TIMC_TIMCDIER_DLYPRTIE = 1UL << 14,  // DLYPRTIE
	HRTIM_TIMC_TIMCDIER_RSTIE	 = 1UL << 13,  // RSTIE
	HRTIM_TIMC_TIMCDIER_RSTX2IE	 = 1UL << 12,  // RSTx2IE
	HRTIM_TIMC_TIMCDIER_SETX2IE	 = 1UL << 11,  // SETx2IE
	HRTIM_TIMC_TIMCDIER_RSTX1IE	 = 1UL << 10,  // RSTx1IE
	HRTIM_TIMC_TIMCDIER_SET1XIE	 = 1UL << 9,   // SET1xIE
	HRTIM_TIMC_TIMCDIER_CPT2IE	 = 1UL << 8,   // CPT2IE
	HRTIM_TIMC_TIMCDIER_CPT1IE	 = 1UL << 7,   // CPT1IE
	HRTIM_TIMC_TIMCDIER_UPDIE	 = 1UL << 6,   // UPDIE
	HRTIM_TIMC_TIMCDIER_REPIE	 = 1UL << 4,   // REPIE
	HRTIM_TIMC_TIMCDIER_CMP4IE	 = 1UL << 3,   // CMP4IE
	HRTIM_TIMC_TIMCDIER_CMP3IE	 = 1UL << 2,   // CMP3IE
	HRTIM_TIMC_TIMCDIER_CMP2IE	 = 1UL << 1,   // CMP2IE
	HRTIM_TIMC_TIMCDIER_CMP1IE	 = 1UL << 0,   // CMP1IE
};

// HRTIM_TIMC->CMP1CCR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMC_CMP1CCR_REPX	 = ((1UL << 8) - 1) << 16,	// Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMC_CMP1CCR_CMP1X = ((1UL << 16) - 1) << 0,	// Timerx Compare 1 value
};
inline void hrtim_timc_cmp1ccr_set_repx(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CMP1CCR = (p->CMP1CCR & ~HRTIM_TIMC_CMP1CCR_REPX) | ((val << 16) & HRTIM_TIMC_CMP1CCR_REPX);
}
inline void hrtim_timc_cmp1ccr_set_cmp1x(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CMP1CCR = (p->CMP1CCR & ~HRTIM_TIMC_CMP1CCR_CMP1X) | ((val << 0) & HRTIM_TIMC_CMP1CCR_CMP1X);
}
inline uint32_t hrtim_timc_cmp1ccr_get_repx(struct HRTIM_TIMC_Type *p) { return (p->CMP1CCR & HRTIM_TIMC_CMP1CCR_REPX) >> 16; }
inline uint32_t hrtim_timc_cmp1ccr_get_cmp1x(struct HRTIM_TIMC_Type *p) { return (p->CMP1CCR & HRTIM_TIMC_CMP1CCR_CMP1X) >> 0; }

// HRTIM_TIMC->CPT1CR Timerx Capture 1 Register
enum {
	HRTIM_TIMC_CPT1CR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMC_CPT1CR_CPT1X = ((1UL << 16) - 1) << 0,  // Timerx Capture 1 value
};
inline uint32_t hrtim_timc_cpt1cr_get_cpt1x(struct HRTIM_TIMC_Type *p) { return (p->CPT1CR & HRTIM_TIMC_CPT1CR_CPT1X) >> 0; }

// HRTIM_TIMC->CPT2CR Timerx Capture 2 Register
enum {
	HRTIM_TIMC_CPT2CR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMC_CPT2CR_CPT2X = ((1UL << 16) - 1) << 0,  // Timerx Capture 2 value
};
inline uint32_t hrtim_timc_cpt2cr_get_cpt2x(struct HRTIM_TIMC_Type *p) { return (p->CPT2CR & HRTIM_TIMC_CPT2CR_CPT2X) >> 0; }

// HRTIM_TIMC->DTCR Timerx Deadtime Register
enum {
	HRTIM_TIMC_DTCR_DTFLKX	= 1UL << 31,			   // Deadtime Falling Lock
	HRTIM_TIMC_DTCR_DTFSLKX = 1UL << 30,			   // Deadtime Falling Sign Lock
	HRTIM_TIMC_DTCR_SDTFX	= 1UL << 25,			   // Sign Deadtime Falling value
	HRTIM_TIMC_DTCR_DTFX	= ((1UL << 9) - 1) << 16,  // Deadtime Falling value
	HRTIM_TIMC_DTCR_DTRLKX	= 1UL << 15,			   // Deadtime Rising Lock
	HRTIM_TIMC_DTCR_DTRSLKX = 1UL << 14,			   // Deadtime Rising Sign Lock
	HRTIM_TIMC_DTCR_DTPRSC	= ((1UL << 3) - 1) << 10,  // Deadtime Prescaler
	HRTIM_TIMC_DTCR_SDTRX	= 1UL << 9,				   // Sign Deadtime Rising value
	HRTIM_TIMC_DTCR_DTRX	= ((1UL << 9) - 1) << 0,   // Deadtime Rising value
};
inline void hrtim_timc_dtcr_set_dtfx(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->DTCR = (p->DTCR & ~HRTIM_TIMC_DTCR_DTFX) | ((val << 16) & HRTIM_TIMC_DTCR_DTFX);
}
inline void hrtim_timc_dtcr_set_dtprsc(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->DTCR = (p->DTCR & ~HRTIM_TIMC_DTCR_DTPRSC) | ((val << 10) & HRTIM_TIMC_DTCR_DTPRSC);
}
inline void hrtim_timc_dtcr_set_dtrx(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->DTCR = (p->DTCR & ~HRTIM_TIMC_DTCR_DTRX) | ((val << 0) & HRTIM_TIMC_DTCR_DTRX);
}
inline uint32_t hrtim_timc_dtcr_get_dtfx(struct HRTIM_TIMC_Type *p) { return (p->DTCR & HRTIM_TIMC_DTCR_DTFX) >> 16; }
inline uint32_t hrtim_timc_dtcr_get_dtprsc(struct HRTIM_TIMC_Type *p) { return (p->DTCR & HRTIM_TIMC_DTCR_DTPRSC) >> 10; }
inline uint32_t hrtim_timc_dtcr_get_dtrx(struct HRTIM_TIMC_Type *p) { return (p->DTCR & HRTIM_TIMC_DTCR_DTRX) >> 0; }

// HRTIM_TIMC->SETC1R Timerx Output1 Set Register
enum {
	HRTIM_TIMC_SETC1R_UPDATE	= 1UL << 31,  // Registers update (transfer preload to active)
	HRTIM_TIMC_SETC1R_EXTEVNT10 = 1UL << 30,  // External Event 10
	HRTIM_TIMC_SETC1R_EXTEVNT9	= 1UL << 29,  // External Event 9
	HRTIM_TIMC_SETC1R_EXTEVNT8	= 1UL << 28,  // External Event 8
	HRTIM_TIMC_SETC1R_EXTEVNT7	= 1UL << 27,  // External Event 7
	HRTIM_TIMC_SETC1R_EXTEVNT6	= 1UL << 26,  // External Event 6
	HRTIM_TIMC_SETC1R_EXTEVNT5	= 1UL << 25,  // External Event 5
	HRTIM_TIMC_SETC1R_EXTEVNT4	= 1UL << 24,  // External Event 4
	HRTIM_TIMC_SETC1R_EXTEVNT3	= 1UL << 23,  // External Event 3
	HRTIM_TIMC_SETC1R_EXTEVNT2	= 1UL << 22,  // External Event 2
	HRTIM_TIMC_SETC1R_EXTEVNT1	= 1UL << 21,  // External Event 1
	HRTIM_TIMC_SETC1R_TIMEVNT9	= 1UL << 20,  // Timer Event 9
	HRTIM_TIMC_SETC1R_TIMEVNT8	= 1UL << 19,  // Timer Event 8
	HRTIM_TIMC_SETC1R_TIMEVNT7	= 1UL << 18,  // Timer Event 7
	HRTIM_TIMC_SETC1R_TIMEVNT6	= 1UL << 17,  // Timer Event 6
	HRTIM_TIMC_SETC1R_TIMEVNT5	= 1UL << 16,  // Timer Event 5
	HRTIM_TIMC_SETC1R_TIMEVNT4	= 1UL << 15,  // Timer Event 4
	HRTIM_TIMC_SETC1R_TIMEVNT3	= 1UL << 14,  // Timer Event 3
	HRTIM_TIMC_SETC1R_TIMEVNT2	= 1UL << 13,  // Timer Event 2
	HRTIM_TIMC_SETC1R_TIMEVNT1	= 1UL << 12,  // Timer Event 1
	HRTIM_TIMC_SETC1R_MSTCMP4	= 1UL << 11,  // Master Compare 4
	HRTIM_TIMC_SETC1R_MSTCMP3	= 1UL << 10,  // Master Compare 3
	HRTIM_TIMC_SETC1R_MSTCMP2	= 1UL << 9,	  // Master Compare 2
	HRTIM_TIMC_SETC1R_MSTCMP1	= 1UL << 8,	  // Master Compare 1
	HRTIM_TIMC_SETC1R_MSTPER	= 1UL << 7,	  // Master Period
	HRTIM_TIMC_SETC1R_CMP4		= 1UL << 6,	  // Timer A compare 4
	HRTIM_TIMC_SETC1R_CMP3		= 1UL << 5,	  // Timer A compare 3
	HRTIM_TIMC_SETC1R_CMP2		= 1UL << 4,	  // Timer A compare 2
	HRTIM_TIMC_SETC1R_CMP1		= 1UL << 3,	  // Timer A compare 1
	HRTIM_TIMC_SETC1R_PER		= 1UL << 2,	  // Timer A Period
	HRTIM_TIMC_SETC1R_RESYNC	= 1UL << 1,	  // Timer A resynchronizaton
	HRTIM_TIMC_SETC1R_SST		= 1UL << 0,	  // Software Set trigger
};

// HRTIM_TIMC->RSTC1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMC_RSTC1R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMC_RSTC1R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMC_RSTC1R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMC_RSTC1R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMC_RSTC1R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMC_RSTC1R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMC_RSTC1R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMC_RSTC1R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMC_RSTC1R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMC_RSTC1R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMC_RSTC1R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMC_RSTC1R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMC_RSTC1R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMC_RSTC1R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMC_RSTC1R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMC_RSTC1R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMC_RSTC1R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMC_RSTC1R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMC_RSTC1R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMC_RSTC1R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMC_RSTC1R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMC_RSTC1R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMC_RSTC1R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMC_RSTC1R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMC_RSTC1R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMC_RSTC1R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMC_RSTC1R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMC_RSTC1R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMC_RSTC1R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMC_RSTC1R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMC_RSTC1R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMC_RSTC1R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMC->SETC2R Timerx Output2 Set Register
enum {
	HRTIM_TIMC_SETC2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMC_SETC2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMC_SETC2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMC_SETC2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMC_SETC2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMC_SETC2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMC_SETC2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMC_SETC2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMC_SETC2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMC_SETC2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMC_SETC2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMC_SETC2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMC_SETC2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMC_SETC2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMC_SETC2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMC_SETC2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMC_SETC2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMC_SETC2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMC_SETC2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMC_SETC2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMC_SETC2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMC_SETC2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMC_SETC2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMC_SETC2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMC_SETC2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMC_SETC2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMC_SETC2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMC_SETC2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMC_SETC2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMC_SETC2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMC_SETC2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMC_SETC2R_SST		= 1UL << 0,	  // SST
};

// HRTIM_TIMC->RSTC2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMC_RSTC2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMC_RSTC2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMC_RSTC2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMC_RSTC2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMC_RSTC2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMC_RSTC2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMC_RSTC2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMC_RSTC2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMC_RSTC2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMC_RSTC2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMC_RSTC2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMC_RSTC2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMC_RSTC2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMC_RSTC2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMC_RSTC2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMC_RSTC2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMC_RSTC2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMC_RSTC2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMC_RSTC2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMC_RSTC2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMC_RSTC2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMC_RSTC2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMC_RSTC2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMC_RSTC2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMC_RSTC2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMC_RSTC2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMC_RSTC2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMC_RSTC2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMC_RSTC2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMC_RSTC2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMC_RSTC2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMC_RSTC2R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMC->EEFCR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMC_EEFCR1_EE5FLTR = ((1UL << 4) - 1) << 25,	 // External Event 5 filter
	HRTIM_TIMC_EEFCR1_EE5LTCH = 1UL << 24,				 // External Event 5 latch
	HRTIM_TIMC_EEFCR1_EE4FLTR = ((1UL << 4) - 1) << 19,	 // External Event 4 filter
	HRTIM_TIMC_EEFCR1_EE4LTCH = 1UL << 18,				 // External Event 4 latch
	HRTIM_TIMC_EEFCR1_EE3FLTR = ((1UL << 4) - 1) << 13,	 // External Event 3 filter
	HRTIM_TIMC_EEFCR1_EE3LTCH = 1UL << 12,				 // External Event 3 latch
	HRTIM_TIMC_EEFCR1_EE2FLTR = ((1UL << 4) - 1) << 7,	 // External Event 2 filter
	HRTIM_TIMC_EEFCR1_EE2LTCH = 1UL << 6,				 // External Event 2 latch
	HRTIM_TIMC_EEFCR1_EE1FLTR = ((1UL << 4) - 1) << 1,	 // External Event 1 filter
	HRTIM_TIMC_EEFCR1_EE1LTCH = 1UL << 0,				 // External Event 1 latch
};
inline void hrtim_timc_eefcr1_set_ee5fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE5FLTR) | ((val << 25) & HRTIM_TIMC_EEFCR1_EE5FLTR);
}
inline void hrtim_timc_eefcr1_set_ee4fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE4FLTR) | ((val << 19) & HRTIM_TIMC_EEFCR1_EE4FLTR);
}
inline void hrtim_timc_eefcr1_set_ee3fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE3FLTR) | ((val << 13) & HRTIM_TIMC_EEFCR1_EE3FLTR);
}
inline void hrtim_timc_eefcr1_set_ee2fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE2FLTR) | ((val << 7) & HRTIM_TIMC_EEFCR1_EE2FLTR);
}
inline void hrtim_timc_eefcr1_set_ee1fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR1 = (p->EEFCR1 & ~HRTIM_TIMC_EEFCR1_EE1FLTR) | ((val << 1) & HRTIM_TIMC_EEFCR1_EE1FLTR);
}
inline uint32_t hrtim_timc_eefcr1_get_ee5fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE5FLTR) >> 25; }
inline uint32_t hrtim_timc_eefcr1_get_ee4fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE4FLTR) >> 19; }
inline uint32_t hrtim_timc_eefcr1_get_ee3fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE3FLTR) >> 13; }
inline uint32_t hrtim_timc_eefcr1_get_ee2fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE2FLTR) >> 7; }
inline uint32_t hrtim_timc_eefcr1_get_ee1fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR1 & HRTIM_TIMC_EEFCR1_EE1FLTR) >> 1; }

// HRTIM_TIMC->EEFCR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMC_EEFCR2_EE10FLTR = ((1UL << 4) - 1) << 25,  // External Event 10 filter
	HRTIM_TIMC_EEFCR2_EE10LTCH = 1UL << 24,				  // External Event 10 latch
	HRTIM_TIMC_EEFCR2_EE9FLTR  = ((1UL << 4) - 1) << 19,  // External Event 9 filter
	HRTIM_TIMC_EEFCR2_EE9LTCH  = 1UL << 18,				  // External Event 9 latch
	HRTIM_TIMC_EEFCR2_EE8FLTR  = ((1UL << 4) - 1) << 13,  // External Event 8 filter
	HRTIM_TIMC_EEFCR2_EE8LTCH  = 1UL << 12,				  // External Event 8 latch
	HRTIM_TIMC_EEFCR2_EE7FLTR  = ((1UL << 4) - 1) << 7,	  // External Event 7 filter
	HRTIM_TIMC_EEFCR2_EE7LTCH  = 1UL << 6,				  // External Event 7 latch
	HRTIM_TIMC_EEFCR2_EE6FLTR  = ((1UL << 4) - 1) << 1,	  // External Event 6 filter
	HRTIM_TIMC_EEFCR2_EE6LTCH  = 1UL << 0,				  // External Event 6 latch
};
inline void hrtim_timc_eefcr2_set_ee10fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE10FLTR) | ((val << 25) & HRTIM_TIMC_EEFCR2_EE10FLTR);
}
inline void hrtim_timc_eefcr2_set_ee9fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE9FLTR) | ((val << 19) & HRTIM_TIMC_EEFCR2_EE9FLTR);
}
inline void hrtim_timc_eefcr2_set_ee8fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE8FLTR) | ((val << 13) & HRTIM_TIMC_EEFCR2_EE8FLTR);
}
inline void hrtim_timc_eefcr2_set_ee7fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE7FLTR) | ((val << 7) & HRTIM_TIMC_EEFCR2_EE7FLTR);
}
inline void hrtim_timc_eefcr2_set_ee6fltr(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->EEFCR2 = (p->EEFCR2 & ~HRTIM_TIMC_EEFCR2_EE6FLTR) | ((val << 1) & HRTIM_TIMC_EEFCR2_EE6FLTR);
}
inline uint32_t hrtim_timc_eefcr2_get_ee10fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE10FLTR) >> 25; }
inline uint32_t hrtim_timc_eefcr2_get_ee9fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE9FLTR) >> 19; }
inline uint32_t hrtim_timc_eefcr2_get_ee8fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE8FLTR) >> 13; }
inline uint32_t hrtim_timc_eefcr2_get_ee7fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE7FLTR) >> 7; }
inline uint32_t hrtim_timc_eefcr2_get_ee6fltr(struct HRTIM_TIMC_Type *p) { return (p->EEFCR2 & HRTIM_TIMC_EEFCR2_EE6FLTR) >> 1; }

// HRTIM_TIMC->RSTCR TimerA Reset Register
enum {
	HRTIM_TIMC_RSTCR_TIMFCPM2  = 1UL << 31,	 // Timer F Compare 2
	HRTIM_TIMC_RSTCR_TIMECMP4  = 1UL << 30,	 // Timer E Compare 4
	HRTIM_TIMC_RSTCR_TIMECMP2  = 1UL << 29,	 // Timer E Compare 2
	HRTIM_TIMC_RSTCR_TIMECMP1  = 1UL << 28,	 // Timer E Compare 1
	HRTIM_TIMC_RSTCR_TIMDCMP4  = 1UL << 27,	 // Timer D Compare 4
	HRTIM_TIMC_RSTCR_TIMDCMP2  = 1UL << 26,	 // Timer D Compare 2
	HRTIM_TIMC_RSTCR_TIMDCMP1  = 1UL << 25,	 // Timer D Compare 1
	HRTIM_TIMC_RSTCR_TIMBCMP4  = 1UL << 24,	 // Timer B Compare 4
	HRTIM_TIMC_RSTCR_TIMBCMP2  = 1UL << 23,	 // Timer B Compare 2
	HRTIM_TIMC_RSTCR_TIMBCMP1  = 1UL << 22,	 // Timer B Compare 1
	HRTIM_TIMC_RSTCR_TIMACMP4  = 1UL << 21,	 // Timer A Compare 4
	HRTIM_TIMC_RSTCR_TIMACMP2  = 1UL << 20,	 // Timer A Compare 2
	HRTIM_TIMC_RSTCR_TIMACMP1  = 1UL << 19,	 // Timer A Compare 1
	HRTIM_TIMC_RSTCR_EXTEVNT10 = 1UL << 18,	 // External Event 10
	HRTIM_TIMC_RSTCR_EXTEVNT9  = 1UL << 17,	 // External Event 9
	HRTIM_TIMC_RSTCR_EXTEVNT8  = 1UL << 16,	 // External Event 8
	HRTIM_TIMC_RSTCR_EXTEVNT7  = 1UL << 15,	 // External Event 7
	HRTIM_TIMC_RSTCR_EXTEVNT6  = 1UL << 14,	 // External Event 6
	HRTIM_TIMC_RSTCR_EXTEVNT5  = 1UL << 13,	 // External Event 5
	HRTIM_TIMC_RSTCR_EXTEVNT4  = 1UL << 12,	 // External Event 4
	HRTIM_TIMC_RSTCR_EXTEVNT3  = 1UL << 11,	 // External Event 3
	HRTIM_TIMC_RSTCR_EXTEVNT2  = 1UL << 10,	 // External Event 2
	HRTIM_TIMC_RSTCR_EXTEVNT1  = 1UL << 9,	 // External Event 1
	HRTIM_TIMC_RSTCR_MSTCMP4   = 1UL << 8,	 // Master compare 4
	HRTIM_TIMC_RSTCR_MSTCMP3   = 1UL << 7,	 // Master compare 3
	HRTIM_TIMC_RSTCR_MSTCMP2   = 1UL << 6,	 // Master compare 2
	HRTIM_TIMC_RSTCR_MSTCMP1   = 1UL << 5,	 // Master compare 1
	HRTIM_TIMC_RSTCR_MSTPER	   = 1UL << 4,	 // Master timer Period
	HRTIM_TIMC_RSTCR_CMP4	   = 1UL << 3,	 // Timer A compare 4 reset
	HRTIM_TIMC_RSTCR_CMP2	   = 1UL << 2,	 // Timer A compare 2 reset
	HRTIM_TIMC_RSTCR_UPDT	   = 1UL << 1,	 // Timer A Update reset
	HRTIM_TIMC_RSTCR_TIMFCMP1  = 1UL << 0,	 // Timer A Update reset
};

// HRTIM_TIMC->CHPCR Timerx Chopper Register
enum {
	HRTIM_TIMC_CHPCR_STRTPW = ((1UL << 4) - 1) << 7,  // STRTPW
	HRTIM_TIMC_CHPCR_CHPDTY = ((1UL << 3) - 1) << 4,  // Timerx chopper duty cycle value
	HRTIM_TIMC_CHPCR_CHPFRQ = ((1UL << 4) - 1) << 0,  // Timerx carrier frequency value
};
inline void hrtim_timc_chpcr_set_strtpw(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CHPCR = (p->CHPCR & ~HRTIM_TIMC_CHPCR_STRTPW) | ((val << 7) & HRTIM_TIMC_CHPCR_STRTPW);
}
inline void hrtim_timc_chpcr_set_chpdty(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CHPCR = (p->CHPCR & ~HRTIM_TIMC_CHPCR_CHPDTY) | ((val << 4) & HRTIM_TIMC_CHPCR_CHPDTY);
}
inline void hrtim_timc_chpcr_set_chpfrq(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CHPCR = (p->CHPCR & ~HRTIM_TIMC_CHPCR_CHPFRQ) | ((val << 0) & HRTIM_TIMC_CHPCR_CHPFRQ);
}
inline uint32_t hrtim_timc_chpcr_get_strtpw(struct HRTIM_TIMC_Type *p) { return (p->CHPCR & HRTIM_TIMC_CHPCR_STRTPW) >> 7; }
inline uint32_t hrtim_timc_chpcr_get_chpdty(struct HRTIM_TIMC_Type *p) { return (p->CHPCR & HRTIM_TIMC_CHPCR_CHPDTY) >> 4; }
inline uint32_t hrtim_timc_chpcr_get_chpfrq(struct HRTIM_TIMC_Type *p) { return (p->CHPCR & HRTIM_TIMC_CHPCR_CHPFRQ) >> 0; }

// HRTIM_TIMC->CPT1CCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMC_CPT1CCR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMC_CPT1CCR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMC_CPT1CCR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMC_CPT1CCR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMC_CPT1CCR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMC_CPT1CCR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMC_CPT1CCR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMC_CPT1CCR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMC_CPT1CCR_TFCMP2	 = 1UL << 23,  // TFCMP2
	HRTIM_TIMC_CPT1CCR_TFCMP1	 = 1UL << 22,  // TFCMP1
	HRTIM_TIMC_CPT1CCR_TF1RST	 = 1UL << 21,  // TF1RST
	HRTIM_TIMC_CPT1CCR_TF1SET	 = 1UL << 20,  // TF1SET
	HRTIM_TIMC_CPT1CCR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMC_CPT1CCR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMC_CPT1CCR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMC_CPT1CCR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMC_CPT1CCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMC_CPT1CCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMC_CPT1CCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMC_CPT1CCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMC_CPT1CCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMC_CPT1CCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMC_CPT1CCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMC_CPT1CCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMC_CPT1CCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMC_CPT1CCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMC_CPT1CCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMC_CPT1CCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMC_CPT1CCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMC_CPT1CCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMC_CPT1CCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMC_CPT1CCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMC->CPT2CCR CPT2xCR
enum {
	HRTIM_TIMC_CPT2CCR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMC_CPT2CCR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMC_CPT2CCR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMC_CPT2CCR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMC_CPT2CCR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMC_CPT2CCR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMC_CPT2CCR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMC_CPT2CCR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMC_CPT2CCR_TF1CMP2	 = 1UL << 23,  // TF1CMP2
	HRTIM_TIMC_CPT2CCR_TF1CMP1	 = 1UL << 22,  // TF1CMP1
	HRTIM_TIMC_CPT2CCR_TF1RST	 = 1UL << 21,  // TF1RST
	HRTIM_TIMC_CPT2CCR_TF1SET	 = 1UL << 20,  // TF1SET
	HRTIM_TIMC_CPT2CCR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMC_CPT2CCR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMC_CPT2CCR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMC_CPT2CCR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMC_CPT2CCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMC_CPT2CCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMC_CPT2CCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMC_CPT2CCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMC_CPT2CCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMC_CPT2CCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMC_CPT2CCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMC_CPT2CCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMC_CPT2CCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMC_CPT2CCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMC_CPT2CCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMC_CPT2CCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMC_CPT2CCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMC_CPT2CCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMC_CPT2CCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMC_CPT2CCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMC->OUTCR Timerx Output Register
enum {
	HRTIM_TIMC_OUTCR_DIDL2	  = 1UL << 23,				 // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMC_OUTCR_CHP2	  = 1UL << 22,				 // Output 2 Chopper enable
	HRTIM_TIMC_OUTCR_FAULT2	  = ((1UL << 2) - 1) << 20,	 // Output 2 Fault state
	HRTIM_TIMC_OUTCR_IDLES2	  = 1UL << 19,				 // Output 2 Idle State
	HRTIM_TIMC_OUTCR_IDLEM2	  = 1UL << 18,				 // Output 2 Idle mode
	HRTIM_TIMC_OUTCR_POL2	  = 1UL << 17,				 // Output 2 polarity
	HRTIM_TIMC_OUTCR_BIAR	  = 1UL << 14,				 // Balanced Idle Automatic Resume
	HRTIM_TIMC_OUTCR_DLYPRT	  = ((1UL << 3) - 1) << 10,	 // Delayed Protection
	HRTIM_TIMC_OUTCR_DLYPRTEN = 1UL << 9,				 // Delayed Protection Enable
	HRTIM_TIMC_OUTCR_DTEN	  = 1UL << 8,				 // Deadtime enable
	HRTIM_TIMC_OUTCR_DIDL1	  = 1UL << 7,				 // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMC_OUTCR_CHP1	  = 1UL << 6,				 // Output 1 Chopper enable
	HRTIM_TIMC_OUTCR_FAULT1	  = ((1UL << 2) - 1) << 4,	 // Output 1 Fault state
	HRTIM_TIMC_OUTCR_IDLES1	  = 1UL << 3,				 // Output 1 Idle State
	HRTIM_TIMC_OUTCR_IDLEM1	  = 1UL << 2,				 // Output 1 Idle mode
	HRTIM_TIMC_OUTCR_POL1	  = 1UL << 1,				 // Output 1 polarity
};
inline void hrtim_timc_outcr_set_fault2(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->OUTCR = (p->OUTCR & ~HRTIM_TIMC_OUTCR_FAULT2) | ((val << 20) & HRTIM_TIMC_OUTCR_FAULT2);
}
inline void hrtim_timc_outcr_set_dlyprt(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->OUTCR = (p->OUTCR & ~HRTIM_TIMC_OUTCR_DLYPRT) | ((val << 10) & HRTIM_TIMC_OUTCR_DLYPRT);
}
inline void hrtim_timc_outcr_set_fault1(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->OUTCR = (p->OUTCR & ~HRTIM_TIMC_OUTCR_FAULT1) | ((val << 4) & HRTIM_TIMC_OUTCR_FAULT1);
}
inline uint32_t hrtim_timc_outcr_get_fault2(struct HRTIM_TIMC_Type *p) { return (p->OUTCR & HRTIM_TIMC_OUTCR_FAULT2) >> 20; }
inline uint32_t hrtim_timc_outcr_get_dlyprt(struct HRTIM_TIMC_Type *p) { return (p->OUTCR & HRTIM_TIMC_OUTCR_DLYPRT) >> 10; }
inline uint32_t hrtim_timc_outcr_get_fault1(struct HRTIM_TIMC_Type *p) { return (p->OUTCR & HRTIM_TIMC_OUTCR_FAULT1) >> 4; }

// HRTIM_TIMC->FLTCR Timerx Fault Register
enum {
	HRTIM_TIMC_FLTCR_FLTLCK = 1UL << 31,  // Fault sources Lock
	HRTIM_TIMC_FLTCR_FLT6EN = 1UL << 5,	  // Fault 6 enable
	HRTIM_TIMC_FLTCR_FLT5EN = 1UL << 4,	  // Fault 5 enable
	HRTIM_TIMC_FLTCR_FLT4EN = 1UL << 3,	  // Fault 4 enable
	HRTIM_TIMC_FLTCR_FLT3EN = 1UL << 2,	  // Fault 3 enable
	HRTIM_TIMC_FLTCR_FLT2EN = 1UL << 1,	  // Fault 2 enable
	HRTIM_TIMC_FLTCR_FLT1EN = 1UL << 0,	  // Fault 1 enable
};

// HRTIM_TIMC->TIMCCR2 HRTIM Timerx Control Register 2
enum {
	HRTIM_TIMC_TIMCCR2_TRGHLF = 1UL << 20,				 // Triggered-half mode
	HRTIM_TIMC_TIMCCR2_GTCMP3 = 1UL << 17,				 // Greater than Compare 3 PWM mode
	HRTIM_TIMC_TIMCCR2_GTCMP1 = 1UL << 16,				 // Greater than Compare 1 PWM mode
	HRTIM_TIMC_TIMCCR2_FEROM  = ((1UL << 2) - 1) << 14,	 // Fault and Event Roll-Over Mode
	HRTIM_TIMC_TIMCCR2_BMROM  = ((1UL << 2) - 1) << 12,	 // Burst Mode Roll-Over Mode
	HRTIM_TIMC_TIMCCR2_ADROM  = ((1UL << 2) - 1) << 10,	 // ADC Roll-Over Mode
	HRTIM_TIMC_TIMCCR2_OUTROM = ((1UL << 2) - 1) << 8,	 // Output Roll-Over Mode
	HRTIM_TIMC_TIMCCR2_ROM	  = ((1UL << 2) - 1) << 6,	 // Roll-Over Mode
	HRTIM_TIMC_TIMCCR2_UDM	  = 1UL << 4,				 // Up-Down Mode
	HRTIM_TIMC_TIMCCR2_DCDR	  = 1UL << 2,				 // Dual Channel DAC Reset trigger
	HRTIM_TIMC_TIMCCR2_DCDS	  = 1UL << 1,				 // Dual Channel DAC Step trigger
	HRTIM_TIMC_TIMCCR2_DCDE	  = 1UL << 0,				 // Dual Channel DAC trigger enable
};
inline void hrtim_timc_timccr2_set_ferom(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR2 = (p->TIMCCR2 & ~HRTIM_TIMC_TIMCCR2_FEROM) | ((val << 14) & HRTIM_TIMC_TIMCCR2_FEROM);
}
inline void hrtim_timc_timccr2_set_bmrom(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR2 = (p->TIMCCR2 & ~HRTIM_TIMC_TIMCCR2_BMROM) | ((val << 12) & HRTIM_TIMC_TIMCCR2_BMROM);
}
inline void hrtim_timc_timccr2_set_adrom(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR2 = (p->TIMCCR2 & ~HRTIM_TIMC_TIMCCR2_ADROM) | ((val << 10) & HRTIM_TIMC_TIMCCR2_ADROM);
}
inline void hrtim_timc_timccr2_set_outrom(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR2 = (p->TIMCCR2 & ~HRTIM_TIMC_TIMCCR2_OUTROM) | ((val << 8) & HRTIM_TIMC_TIMCCR2_OUTROM);
}
inline void hrtim_timc_timccr2_set_rom(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->TIMCCR2 = (p->TIMCCR2 & ~HRTIM_TIMC_TIMCCR2_ROM) | ((val << 6) & HRTIM_TIMC_TIMCCR2_ROM);
}
inline uint32_t hrtim_timc_timccr2_get_ferom(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR2 & HRTIM_TIMC_TIMCCR2_FEROM) >> 14; }
inline uint32_t hrtim_timc_timccr2_get_bmrom(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR2 & HRTIM_TIMC_TIMCCR2_BMROM) >> 12; }
inline uint32_t hrtim_timc_timccr2_get_adrom(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR2 & HRTIM_TIMC_TIMCCR2_ADROM) >> 10; }
inline uint32_t hrtim_timc_timccr2_get_outrom(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR2 & HRTIM_TIMC_TIMCCR2_OUTROM) >> 8; }
inline uint32_t hrtim_timc_timccr2_get_rom(struct HRTIM_TIMC_Type *p) { return (p->TIMCCR2 & HRTIM_TIMC_TIMCCR2_ROM) >> 6; }

// HRTIM_TIMC->CEEFR3 HRTIM Timerx External Event Filtering Register 3
enum {
	HRTIM_TIMC_CEEFR3_EEVACNT  = ((1UL << 6) - 1) << 8,	 // External Event A counter
	HRTIM_TIMC_CEEFR3_EEVASEL  = ((1UL << 4) - 1) << 4,	 // External Event A Selection
	HRTIM_TIMC_CEEFR3_EEVARSTM = 1UL << 2,				 // External Event A Reset Mode
	HRTIM_TIMC_CEEFR3_EEVACRES = 1UL << 1,				 // External Event A Counter Reset
	HRTIM_TIMC_CEEFR3_EEVACE   = 1UL << 0,				 // External Event A Counter Enable
};
inline void hrtim_timc_ceefr3_set_eevacnt(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CEEFR3 = (p->CEEFR3 & ~HRTIM_TIMC_CEEFR3_EEVACNT) | ((val << 8) & HRTIM_TIMC_CEEFR3_EEVACNT);
}
inline void hrtim_timc_ceefr3_set_eevasel(struct HRTIM_TIMC_Type *p, uint32_t val) {
	p->CEEFR3 = (p->CEEFR3 & ~HRTIM_TIMC_CEEFR3_EEVASEL) | ((val << 4) & HRTIM_TIMC_CEEFR3_EEVASEL);
}
inline uint32_t hrtim_timc_ceefr3_get_eevacnt(struct HRTIM_TIMC_Type *p) { return (p->CEEFR3 & HRTIM_TIMC_CEEFR3_EEVACNT) >> 8; }
inline uint32_t hrtim_timc_ceefr3_get_eevasel(struct HRTIM_TIMC_Type *p) { return (p->CEEFR3 & HRTIM_TIMC_CEEFR3_EEVASEL) >> 4; }

/* High Resolution Timer: TIMD */
struct HRTIM_TIMD_Type {
	__IO uint32_t TIMDCR;		 // @0 Timerx Control Register
	__I uint32_t  TIMDISR;		 // @4 Timerx Interrupt Status Register
	__O uint16_t  TIMDICR;		 // @8 Timerx Interrupt Clear Register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t TIMDDIER;		 // @12 TIMxDIER
	__IO uint16_t CNTDR;		 // @16 Timerx Counter Register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t PERDR;		 // @20 Timerx Period Register
	uint8_t		  RESERVED2[2];	 // @22
	__IO uint8_t  REPDR;		 // @24 Timerx Repetition Register
	uint8_t		  RESERVED3[3];	 // @25
	__IO uint16_t CMP1DR;		 // @28 Timerx Compare 1 Register
	uint8_t		  RESERVED4[2];	 // @30
	__IO uint32_t CMP1CDR;		 // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2DR;		 // @36 Timerx Compare 2 Register
	uint8_t		  RESERVED5[2];	 // @38
	__IO uint16_t CMP3DR;		 // @40 Timerx Compare 3 Register
	uint8_t		  RESERVED6[2];	 // @42
	__IO uint16_t CMP4DR;		 // @44 Timerx Compare 4 Register
	uint8_t		  RESERVED7[2];	 // @46
	__I uint32_t  CPT1DR;		 // @48 Timerx Capture 1 Register
	__I uint32_t  CPT2DR;		 // @52 Timerx Capture 2 Register
	__IO uint32_t DTDR;			 // @56 Timerx Deadtime Register
	__IO uint32_t SETD1R;		 // @60 Timerx Output1 Set Register
	__IO uint32_t RSTD1R;		 // @64 Timerx Output1 Reset Register
	__IO uint32_t SETD2R;		 // @68 Timerx Output2 Set Register
	__IO uint32_t RSTD2R;		 // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFDR1;		 // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFDR2;		 // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTDR;		 // @84 TimerA Reset Register
	__IO uint16_t CHPDR;		 // @88 Timerx Chopper Register
	uint8_t		  RESERVED8[2];	 // @90
	__IO uint32_t CPT1DCR;		 // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2DCR;		 // @96 CPT2xCR
	__IO uint32_t OUTDR;		 // @100 Timerx Output Register
	__IO uint32_t FLTDR;		 // @104 Timerx Fault Register
	__IO uint32_t TIMDCR2;		 // @108 HRTIM Timerx Control Register 2
	__IO uint16_t DEEFR3;		 // @112 HRTIM Timerx External Event Filtering Register 3
};

// HRTIM_TIMD->TIMDCR Timerx Control Register
enum {
	HRTIM_TIMD_TIMDCR_UPDGAT	= ((1UL << 4) - 1) << 28,  // Update Gating
	HRTIM_TIMD_TIMDCR_PREEN		= 1UL << 27,			   // Preload enable
	HRTIM_TIMD_TIMDCR_DACSYNC	= ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_TIMD_TIMDCR_MSTU		= 1UL << 24,			   // Master Timer update
	HRTIM_TIMD_TIMDCR_TEU		= 1UL << 23,			   // TEU
	HRTIM_TIMD_TIMDCR_TCU		= 1UL << 21,			   // TCU
	HRTIM_TIMD_TIMDCR_TBU		= 1UL << 20,			   // TBU
	HRTIM_TIMD_TIMDCR_TAU		= 1UL << 19,			   // TAU
	HRTIM_TIMD_TIMDCR_TXRSTU	= 1UL << 18,			   // Timerx reset update
	HRTIM_TIMD_TIMDCR_TXREPU	= 1UL << 17,			   // Timer x Repetition update
	HRTIM_TIMD_TIMDCR_TFU		= 1UL << 16,			   // TFU
	HRTIM_TIMD_TIMDCR_DELCMP4	= ((1UL << 2) - 1) << 14,  // Delayed CMP4 mode
	HRTIM_TIMD_TIMDCR_DELCMP2	= ((1UL << 2) - 1) << 12,  // Delayed CMP2 mode
	HRTIM_TIMD_TIMDCR_SYNCSTRTX = 1UL << 11,			   // Synchronization Starts Timer x
	HRTIM_TIMD_TIMDCR_SYNCRSTX	= 1UL << 10,			   // Synchronization Resets Timer x
	HRTIM_TIMD_TIMDCR_RSYNCU	= 1UL << 9,				   // Re-Synchronized Update
	HRTIM_TIMD_TIMDCR_INTLVD	= ((1UL << 2) - 1) << 7,   // Interleaved mode
	HRTIM_TIMD_TIMDCR_PSHPLL	= 1UL << 6,				   // Push-Pull mode enable
	HRTIM_TIMD_TIMDCR_HALF		= 1UL << 5,				   // Half mode enable
	HRTIM_TIMD_TIMDCR_RETRIG	= 1UL << 4,				   // Re-triggerable mode
	HRTIM_TIMD_TIMDCR_CONT		= 1UL << 3,				   // Continuous mode
	HRTIM_TIMD_TIMDCR_CK_PSCX	= ((1UL << 3) - 1) << 0,   // HRTIM Timer x Clock prescaler
};
inline void hrtim_timd_timdcr_set_updgat(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_UPDGAT) | ((val << 28) & HRTIM_TIMD_TIMDCR_UPDGAT);
}
inline void hrtim_timd_timdcr_set_dacsync(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_DACSYNC) | ((val << 25) & HRTIM_TIMD_TIMDCR_DACSYNC);
}
inline void hrtim_timd_timdcr_set_delcmp4(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_DELCMP4) | ((val << 14) & HRTIM_TIMD_TIMDCR_DELCMP4);
}
inline void hrtim_timd_timdcr_set_delcmp2(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_DELCMP2) | ((val << 12) & HRTIM_TIMD_TIMDCR_DELCMP2);
}
inline void hrtim_timd_timdcr_set_intlvd(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_INTLVD) | ((val << 7) & HRTIM_TIMD_TIMDCR_INTLVD);
}
inline void hrtim_timd_timdcr_set_ck_pscx(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR = (p->TIMDCR & ~HRTIM_TIMD_TIMDCR_CK_PSCX) | ((val << 0) & HRTIM_TIMD_TIMDCR_CK_PSCX);
}
inline uint32_t hrtim_timd_timdcr_get_updgat(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_UPDGAT) >> 28; }
inline uint32_t hrtim_timd_timdcr_get_dacsync(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_DACSYNC) >> 25; }
inline uint32_t hrtim_timd_timdcr_get_delcmp4(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_DELCMP4) >> 14; }
inline uint32_t hrtim_timd_timdcr_get_delcmp2(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_DELCMP2) >> 12; }
inline uint32_t hrtim_timd_timdcr_get_intlvd(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_INTLVD) >> 7; }
inline uint32_t hrtim_timd_timdcr_get_ck_pscx(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR & HRTIM_TIMD_TIMDCR_CK_PSCX) >> 0; }

// HRTIM_TIMD->TIMDISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMD_TIMDISR_O2CPY   = 1UL << 21,	 // Output 2 Copy
	HRTIM_TIMD_TIMDISR_O1CPY   = 1UL << 20,	 // Output 1 Copy
	HRTIM_TIMD_TIMDISR_O2STAT  = 1UL << 19,	 // Output 2 State
	HRTIM_TIMD_TIMDISR_O1STAT  = 1UL << 18,	 // Output 1 State
	HRTIM_TIMD_TIMDISR_IPPSTAT = 1UL << 17,	 // Idle Push Pull Status
	HRTIM_TIMD_TIMDISR_CPPSTAT = 1UL << 16,	 // Current Push Pull Status
	HRTIM_TIMD_TIMDISR_DLYPRT  = 1UL << 14,	 // Delayed Protection Flag
	HRTIM_TIMD_TIMDISR_RST	   = 1UL << 13,	 // Reset Interrupt Flag
	HRTIM_TIMD_TIMDISR_RSTX2   = 1UL << 12,	 // Output 2 Reset Interrupt Flag
	HRTIM_TIMD_TIMDISR_SETX2   = 1UL << 11,	 // Output 2 Set Interrupt Flag
	HRTIM_TIMD_TIMDISR_RSTX1   = 1UL << 10,	 // Output 1 Reset Interrupt Flag
	HRTIM_TIMD_TIMDISR_SETX1   = 1UL << 9,	 // Output 1 Set Interrupt Flag
	HRTIM_TIMD_TIMDISR_CPT2	   = 1UL << 8,	 // Capture2 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CPT1	   = 1UL << 7,	 // Capture1 Interrupt Flag
	HRTIM_TIMD_TIMDISR_UPD	   = 1UL << 6,	 // Update Interrupt Flag
	HRTIM_TIMD_TIMDISR_REP	   = 1UL << 4,	 // Repetition Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP4	   = 1UL << 3,	 // Compare 4 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP3	   = 1UL << 2,	 // Compare 3 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP2	   = 1UL << 1,	 // Compare 2 Interrupt Flag
	HRTIM_TIMD_TIMDISR_CMP1	   = 1UL << 0,	 // Compare 1 Interrupt Flag
};

// HRTIM_TIMD->TIMDICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMD_TIMDICR_DLYPRTC = 1UL << 14,	 // Delayed Protection Flag Clear
	HRTIM_TIMD_TIMDICR_RSTC	   = 1UL << 13,	 // Reset Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_RSTX2C  = 1UL << 12,	 // Output 2 Reset flag Clear
	HRTIM_TIMD_TIMDICR_SET2XC  = 1UL << 11,	 // Output 2 Set flag Clear
	HRTIM_TIMD_TIMDICR_RSTX1C  = 1UL << 10,	 // Output 1 Reset flag Clear
	HRTIM_TIMD_TIMDICR_SET1XC  = 1UL << 9,	 // Output 1 Set flag Clear
	HRTIM_TIMD_TIMDICR_CPT2C   = 1UL << 8,	 // Capture2 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CPT1C   = 1UL << 7,	 // Capture1 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_UPDC	   = 1UL << 6,	 // Update Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_REPC	   = 1UL << 4,	 // Repetition Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP4C   = 1UL << 3,	 // Compare 4 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP3C   = 1UL << 2,	 // Compare 3 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP2C   = 1UL << 1,	 // Compare 2 Interrupt flag Clear
	HRTIM_TIMD_TIMDICR_CMP1C   = 1UL << 0,	 // Compare 1 Interrupt flag Clear
};

// HRTIM_TIMD->TIMDDIER TIMxDIER
enum {
	HRTIM_TIMD_TIMDDIER_DLYPRTDE = 1UL << 30,  // DLYPRTDE
	HRTIM_TIMD_TIMDDIER_RSTDE	 = 1UL << 29,  // RSTDE
	HRTIM_TIMD_TIMDDIER_RSTX2DE	 = 1UL << 28,  // RSTx2DE
	HRTIM_TIMD_TIMDDIER_SETX2DE	 = 1UL << 27,  // SETx2DE
	HRTIM_TIMD_TIMDDIER_RSTX1DE	 = 1UL << 26,  // RSTx1DE
	HRTIM_TIMD_TIMDDIER_SET1XDE	 = 1UL << 25,  // SET1xDE
	HRTIM_TIMD_TIMDDIER_CPT2DE	 = 1UL << 24,  // CPT2DE
	HRTIM_TIMD_TIMDDIER_CPT1DE	 = 1UL << 23,  // CPT1DE
	HRTIM_TIMD_TIMDDIER_UPDDE	 = 1UL << 22,  // UPDDE
	HRTIM_TIMD_TIMDDIER_REPDE	 = 1UL << 20,  // REPDE
	HRTIM_TIMD_TIMDDIER_CMP4DE	 = 1UL << 19,  // CMP4DE
	HRTIM_TIMD_TIMDDIER_CMP3DE	 = 1UL << 18,  // CMP3DE
	HRTIM_TIMD_TIMDDIER_CMP2DE	 = 1UL << 17,  // CMP2DE
	HRTIM_TIMD_TIMDDIER_CMP1DE	 = 1UL << 16,  // CMP1DE
	HRTIM_TIMD_TIMDDIER_DLYPRTIE = 1UL << 14,  // DLYPRTIE
	HRTIM_TIMD_TIMDDIER_RSTIE	 = 1UL << 13,  // RSTIE
	HRTIM_TIMD_TIMDDIER_RSTX2IE	 = 1UL << 12,  // RSTx2IE
	HRTIM_TIMD_TIMDDIER_SETX2IE	 = 1UL << 11,  // SETx2IE
	HRTIM_TIMD_TIMDDIER_RSTX1IE	 = 1UL << 10,  // RSTx1IE
	HRTIM_TIMD_TIMDDIER_SET1XIE	 = 1UL << 9,   // SET1xIE
	HRTIM_TIMD_TIMDDIER_CPT2IE	 = 1UL << 8,   // CPT2IE
	HRTIM_TIMD_TIMDDIER_CPT1IE	 = 1UL << 7,   // CPT1IE
	HRTIM_TIMD_TIMDDIER_UPDIE	 = 1UL << 6,   // UPDIE
	HRTIM_TIMD_TIMDDIER_REPIE	 = 1UL << 4,   // REPIE
	HRTIM_TIMD_TIMDDIER_CMP4IE	 = 1UL << 3,   // CMP4IE
	HRTIM_TIMD_TIMDDIER_CMP3IE	 = 1UL << 2,   // CMP3IE
	HRTIM_TIMD_TIMDDIER_CMP2IE	 = 1UL << 1,   // CMP2IE
	HRTIM_TIMD_TIMDDIER_CMP1IE	 = 1UL << 0,   // CMP1IE
};

// HRTIM_TIMD->CMP1CDR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMD_CMP1CDR_REPX	 = ((1UL << 8) - 1) << 16,	// Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMD_CMP1CDR_CMP1X = ((1UL << 16) - 1) << 0,	// Timerx Compare 1 value
};
inline void hrtim_timd_cmp1cdr_set_repx(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->CMP1CDR = (p->CMP1CDR & ~HRTIM_TIMD_CMP1CDR_REPX) | ((val << 16) & HRTIM_TIMD_CMP1CDR_REPX);
}
inline void hrtim_timd_cmp1cdr_set_cmp1x(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->CMP1CDR = (p->CMP1CDR & ~HRTIM_TIMD_CMP1CDR_CMP1X) | ((val << 0) & HRTIM_TIMD_CMP1CDR_CMP1X);
}
inline uint32_t hrtim_timd_cmp1cdr_get_repx(struct HRTIM_TIMD_Type *p) { return (p->CMP1CDR & HRTIM_TIMD_CMP1CDR_REPX) >> 16; }
inline uint32_t hrtim_timd_cmp1cdr_get_cmp1x(struct HRTIM_TIMD_Type *p) { return (p->CMP1CDR & HRTIM_TIMD_CMP1CDR_CMP1X) >> 0; }

// HRTIM_TIMD->CPT1DR Timerx Capture 1 Register
enum {
	HRTIM_TIMD_CPT1DR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMD_CPT1DR_CPT1X = ((1UL << 16) - 1) << 0,  // Timerx Capture 1 value
};
inline uint32_t hrtim_timd_cpt1dr_get_cpt1x(struct HRTIM_TIMD_Type *p) { return (p->CPT1DR & HRTIM_TIMD_CPT1DR_CPT1X) >> 0; }

// HRTIM_TIMD->CPT2DR Timerx Capture 2 Register
enum {
	HRTIM_TIMD_CPT2DR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMD_CPT2DR_CPT2X = ((1UL << 16) - 1) << 0,  // Timerx Capture 2 value
};
inline uint32_t hrtim_timd_cpt2dr_get_cpt2x(struct HRTIM_TIMD_Type *p) { return (p->CPT2DR & HRTIM_TIMD_CPT2DR_CPT2X) >> 0; }

// HRTIM_TIMD->DTDR Timerx Deadtime Register
enum {
	HRTIM_TIMD_DTDR_DTFLKX	= 1UL << 31,			   // Deadtime Falling Lock
	HRTIM_TIMD_DTDR_DTFSLKX = 1UL << 30,			   // Deadtime Falling Sign Lock
	HRTIM_TIMD_DTDR_SDTFX	= 1UL << 25,			   // Sign Deadtime Falling value
	HRTIM_TIMD_DTDR_DTFX	= ((1UL << 9) - 1) << 16,  // Deadtime Falling value
	HRTIM_TIMD_DTDR_DTRLKX	= 1UL << 15,			   // Deadtime Rising Lock
	HRTIM_TIMD_DTDR_DTRSLKX = 1UL << 14,			   // Deadtime Rising Sign Lock
	HRTIM_TIMD_DTDR_DTPRSC	= ((1UL << 3) - 1) << 10,  // Deadtime Prescaler
	HRTIM_TIMD_DTDR_SDTRX	= 1UL << 9,				   // Sign Deadtime Rising value
	HRTIM_TIMD_DTDR_DTRX	= ((1UL << 9) - 1) << 0,   // Deadtime Rising value
};
inline void hrtim_timd_dtdr_set_dtfx(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->DTDR = (p->DTDR & ~HRTIM_TIMD_DTDR_DTFX) | ((val << 16) & HRTIM_TIMD_DTDR_DTFX);
}
inline void hrtim_timd_dtdr_set_dtprsc(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->DTDR = (p->DTDR & ~HRTIM_TIMD_DTDR_DTPRSC) | ((val << 10) & HRTIM_TIMD_DTDR_DTPRSC);
}
inline void hrtim_timd_dtdr_set_dtrx(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->DTDR = (p->DTDR & ~HRTIM_TIMD_DTDR_DTRX) | ((val << 0) & HRTIM_TIMD_DTDR_DTRX);
}
inline uint32_t hrtim_timd_dtdr_get_dtfx(struct HRTIM_TIMD_Type *p) { return (p->DTDR & HRTIM_TIMD_DTDR_DTFX) >> 16; }
inline uint32_t hrtim_timd_dtdr_get_dtprsc(struct HRTIM_TIMD_Type *p) { return (p->DTDR & HRTIM_TIMD_DTDR_DTPRSC) >> 10; }
inline uint32_t hrtim_timd_dtdr_get_dtrx(struct HRTIM_TIMD_Type *p) { return (p->DTDR & HRTIM_TIMD_DTDR_DTRX) >> 0; }

// HRTIM_TIMD->SETD1R Timerx Output1 Set Register
enum {
	HRTIM_TIMD_SETD1R_UPDATE	= 1UL << 31,  // Registers update (transfer preload to active)
	HRTIM_TIMD_SETD1R_EXTEVNT10 = 1UL << 30,  // External Event 10
	HRTIM_TIMD_SETD1R_EXTEVNT9	= 1UL << 29,  // External Event 9
	HRTIM_TIMD_SETD1R_EXTEVNT8	= 1UL << 28,  // External Event 8
	HRTIM_TIMD_SETD1R_EXTEVNT7	= 1UL << 27,  // External Event 7
	HRTIM_TIMD_SETD1R_EXTEVNT6	= 1UL << 26,  // External Event 6
	HRTIM_TIMD_SETD1R_EXTEVNT5	= 1UL << 25,  // External Event 5
	HRTIM_TIMD_SETD1R_EXTEVNT4	= 1UL << 24,  // External Event 4
	HRTIM_TIMD_SETD1R_EXTEVNT3	= 1UL << 23,  // External Event 3
	HRTIM_TIMD_SETD1R_EXTEVNT2	= 1UL << 22,  // External Event 2
	HRTIM_TIMD_SETD1R_EXTEVNT1	= 1UL << 21,  // External Event 1
	HRTIM_TIMD_SETD1R_TIMEVNT9	= 1UL << 20,  // Timer Event 9
	HRTIM_TIMD_SETD1R_TIMEVNT8	= 1UL << 19,  // Timer Event 8
	HRTIM_TIMD_SETD1R_TIMEVNT7	= 1UL << 18,  // Timer Event 7
	HRTIM_TIMD_SETD1R_TIMEVNT6	= 1UL << 17,  // Timer Event 6
	HRTIM_TIMD_SETD1R_TIMEVNT5	= 1UL << 16,  // Timer Event 5
	HRTIM_TIMD_SETD1R_TIMEVNT4	= 1UL << 15,  // Timer Event 4
	HRTIM_TIMD_SETD1R_TIMEVNT3	= 1UL << 14,  // Timer Event 3
	HRTIM_TIMD_SETD1R_TIMEVNT2	= 1UL << 13,  // Timer Event 2
	HRTIM_TIMD_SETD1R_TIMEVNT1	= 1UL << 12,  // Timer Event 1
	HRTIM_TIMD_SETD1R_MSTCMP4	= 1UL << 11,  // Master Compare 4
	HRTIM_TIMD_SETD1R_MSTCMP3	= 1UL << 10,  // Master Compare 3
	HRTIM_TIMD_SETD1R_MSTCMP2	= 1UL << 9,	  // Master Compare 2
	HRTIM_TIMD_SETD1R_MSTCMP1	= 1UL << 8,	  // Master Compare 1
	HRTIM_TIMD_SETD1R_MSTPER	= 1UL << 7,	  // Master Period
	HRTIM_TIMD_SETD1R_CMP4		= 1UL << 6,	  // Timer A compare 4
	HRTIM_TIMD_SETD1R_CMP3		= 1UL << 5,	  // Timer A compare 3
	HRTIM_TIMD_SETD1R_CMP2		= 1UL << 4,	  // Timer A compare 2
	HRTIM_TIMD_SETD1R_CMP1		= 1UL << 3,	  // Timer A compare 1
	HRTIM_TIMD_SETD1R_PER		= 1UL << 2,	  // Timer A Period
	HRTIM_TIMD_SETD1R_RESYNC	= 1UL << 1,	  // Timer A resynchronizaton
	HRTIM_TIMD_SETD1R_SST		= 1UL << 0,	  // Software Set trigger
};

// HRTIM_TIMD->RSTD1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMD_RSTD1R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMD_RSTD1R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMD_RSTD1R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMD_RSTD1R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMD_RSTD1R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMD_RSTD1R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMD_RSTD1R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMD_RSTD1R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMD_RSTD1R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMD_RSTD1R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMD_RSTD1R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMD_RSTD1R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMD_RSTD1R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMD_RSTD1R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMD_RSTD1R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMD_RSTD1R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMD_RSTD1R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMD_RSTD1R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMD_RSTD1R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMD_RSTD1R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMD_RSTD1R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMD_RSTD1R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMD_RSTD1R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMD_RSTD1R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMD_RSTD1R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMD_RSTD1R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMD_RSTD1R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMD_RSTD1R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMD_RSTD1R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMD_RSTD1R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMD_RSTD1R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMD_RSTD1R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMD->SETD2R Timerx Output2 Set Register
enum {
	HRTIM_TIMD_SETD2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMD_SETD2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMD_SETD2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMD_SETD2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMD_SETD2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMD_SETD2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMD_SETD2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMD_SETD2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMD_SETD2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMD_SETD2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMD_SETD2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMD_SETD2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMD_SETD2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMD_SETD2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMD_SETD2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMD_SETD2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMD_SETD2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMD_SETD2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMD_SETD2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMD_SETD2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMD_SETD2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMD_SETD2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMD_SETD2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMD_SETD2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMD_SETD2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMD_SETD2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMD_SETD2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMD_SETD2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMD_SETD2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMD_SETD2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMD_SETD2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMD_SETD2R_SST		= 1UL << 0,	  // SST
};

// HRTIM_TIMD->RSTD2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMD_RSTD2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMD_RSTD2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMD_RSTD2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMD_RSTD2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMD_RSTD2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMD_RSTD2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMD_RSTD2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMD_RSTD2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMD_RSTD2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMD_RSTD2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMD_RSTD2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMD_RSTD2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMD_RSTD2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMD_RSTD2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMD_RSTD2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMD_RSTD2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMD_RSTD2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMD_RSTD2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMD_RSTD2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMD_RSTD2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMD_RSTD2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMD_RSTD2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMD_RSTD2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMD_RSTD2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMD_RSTD2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMD_RSTD2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMD_RSTD2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMD_RSTD2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMD_RSTD2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMD_RSTD2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMD_RSTD2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMD_RSTD2R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMD->EEFDR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMD_EEFDR1_EE5FLTR = ((1UL << 4) - 1) << 25,	 // External Event 5 filter
	HRTIM_TIMD_EEFDR1_EE5LTCH = 1UL << 24,				 // External Event 5 latch
	HRTIM_TIMD_EEFDR1_EE4FLTR = ((1UL << 4) - 1) << 19,	 // External Event 4 filter
	HRTIM_TIMD_EEFDR1_EE4LTCH = 1UL << 18,				 // External Event 4 latch
	HRTIM_TIMD_EEFDR1_EE3FLTR = ((1UL << 4) - 1) << 13,	 // External Event 3 filter
	HRTIM_TIMD_EEFDR1_EE3LTCH = 1UL << 12,				 // External Event 3 latch
	HRTIM_TIMD_EEFDR1_EE2FLTR = ((1UL << 4) - 1) << 7,	 // External Event 2 filter
	HRTIM_TIMD_EEFDR1_EE2LTCH = 1UL << 6,				 // External Event 2 latch
	HRTIM_TIMD_EEFDR1_EE1FLTR = ((1UL << 4) - 1) << 1,	 // External Event 1 filter
	HRTIM_TIMD_EEFDR1_EE1LTCH = 1UL << 0,				 // External Event 1 latch
};
inline void hrtim_timd_eefdr1_set_ee5fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE5FLTR) | ((val << 25) & HRTIM_TIMD_EEFDR1_EE5FLTR);
}
inline void hrtim_timd_eefdr1_set_ee4fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE4FLTR) | ((val << 19) & HRTIM_TIMD_EEFDR1_EE4FLTR);
}
inline void hrtim_timd_eefdr1_set_ee3fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE3FLTR) | ((val << 13) & HRTIM_TIMD_EEFDR1_EE3FLTR);
}
inline void hrtim_timd_eefdr1_set_ee2fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE2FLTR) | ((val << 7) & HRTIM_TIMD_EEFDR1_EE2FLTR);
}
inline void hrtim_timd_eefdr1_set_ee1fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR1 = (p->EEFDR1 & ~HRTIM_TIMD_EEFDR1_EE1FLTR) | ((val << 1) & HRTIM_TIMD_EEFDR1_EE1FLTR);
}
inline uint32_t hrtim_timd_eefdr1_get_ee5fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE5FLTR) >> 25; }
inline uint32_t hrtim_timd_eefdr1_get_ee4fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE4FLTR) >> 19; }
inline uint32_t hrtim_timd_eefdr1_get_ee3fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE3FLTR) >> 13; }
inline uint32_t hrtim_timd_eefdr1_get_ee2fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE2FLTR) >> 7; }
inline uint32_t hrtim_timd_eefdr1_get_ee1fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR1 & HRTIM_TIMD_EEFDR1_EE1FLTR) >> 1; }

// HRTIM_TIMD->EEFDR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMD_EEFDR2_EE10FLTR = ((1UL << 4) - 1) << 25,  // External Event 10 filter
	HRTIM_TIMD_EEFDR2_EE10LTCH = 1UL << 24,				  // External Event 10 latch
	HRTIM_TIMD_EEFDR2_EE9FLTR  = ((1UL << 4) - 1) << 19,  // External Event 9 filter
	HRTIM_TIMD_EEFDR2_EE9LTCH  = 1UL << 18,				  // External Event 9 latch
	HRTIM_TIMD_EEFDR2_EE8FLTR  = ((1UL << 4) - 1) << 13,  // External Event 8 filter
	HRTIM_TIMD_EEFDR2_EE8LTCH  = 1UL << 12,				  // External Event 8 latch
	HRTIM_TIMD_EEFDR2_EE7FLTR  = ((1UL << 4) - 1) << 7,	  // External Event 7 filter
	HRTIM_TIMD_EEFDR2_EE7LTCH  = 1UL << 6,				  // External Event 7 latch
	HRTIM_TIMD_EEFDR2_EE6FLTR  = ((1UL << 4) - 1) << 1,	  // External Event 6 filter
	HRTIM_TIMD_EEFDR2_EE6LTCH  = 1UL << 0,				  // External Event 6 latch
};
inline void hrtim_timd_eefdr2_set_ee10fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE10FLTR) | ((val << 25) & HRTIM_TIMD_EEFDR2_EE10FLTR);
}
inline void hrtim_timd_eefdr2_set_ee9fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE9FLTR) | ((val << 19) & HRTIM_TIMD_EEFDR2_EE9FLTR);
}
inline void hrtim_timd_eefdr2_set_ee8fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE8FLTR) | ((val << 13) & HRTIM_TIMD_EEFDR2_EE8FLTR);
}
inline void hrtim_timd_eefdr2_set_ee7fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE7FLTR) | ((val << 7) & HRTIM_TIMD_EEFDR2_EE7FLTR);
}
inline void hrtim_timd_eefdr2_set_ee6fltr(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->EEFDR2 = (p->EEFDR2 & ~HRTIM_TIMD_EEFDR2_EE6FLTR) | ((val << 1) & HRTIM_TIMD_EEFDR2_EE6FLTR);
}
inline uint32_t hrtim_timd_eefdr2_get_ee10fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE10FLTR) >> 25; }
inline uint32_t hrtim_timd_eefdr2_get_ee9fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE9FLTR) >> 19; }
inline uint32_t hrtim_timd_eefdr2_get_ee8fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE8FLTR) >> 13; }
inline uint32_t hrtim_timd_eefdr2_get_ee7fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE7FLTR) >> 7; }
inline uint32_t hrtim_timd_eefdr2_get_ee6fltr(struct HRTIM_TIMD_Type *p) { return (p->EEFDR2 & HRTIM_TIMD_EEFDR2_EE6FLTR) >> 1; }

// HRTIM_TIMD->RSTDR TimerA Reset Register
enum {
	HRTIM_TIMD_RSTDR_TIMFCPM2  = 1UL << 31,	 // Timer F Compare 2
	HRTIM_TIMD_RSTDR_TIMECMP4  = 1UL << 30,	 // Timer E Compare 4
	HRTIM_TIMD_RSTDR_TIMECMP2  = 1UL << 29,	 // Timer E Compare 2
	HRTIM_TIMD_RSTDR_TIMECMP1  = 1UL << 28,	 // Timer E Compare 1
	HRTIM_TIMD_RSTDR_TIMCCMP4  = 1UL << 27,	 // Timer C Compare 4
	HRTIM_TIMD_RSTDR_TIMCCMP2  = 1UL << 26,	 // Timer C Compare 2
	HRTIM_TIMD_RSTDR_TIMCCMP1  = 1UL << 25,	 // Timer C Compare 1
	HRTIM_TIMD_RSTDR_TIMBCMP4  = 1UL << 24,	 // Timer B Compare 4
	HRTIM_TIMD_RSTDR_TIMBCMP2  = 1UL << 23,	 // Timer B Compare 2
	HRTIM_TIMD_RSTDR_TIMBCMP1  = 1UL << 22,	 // Timer B Compare 1
	HRTIM_TIMD_RSTDR_TIMACMP4  = 1UL << 21,	 // Timer A Compare 4
	HRTIM_TIMD_RSTDR_TIMACMP2  = 1UL << 20,	 // Timer A Compare 2
	HRTIM_TIMD_RSTDR_TIMACMP1  = 1UL << 19,	 // Timer A Compare 1
	HRTIM_TIMD_RSTDR_EXTEVNT10 = 1UL << 18,	 // External Event 10
	HRTIM_TIMD_RSTDR_EXTEVNT9  = 1UL << 17,	 // External Event 9
	HRTIM_TIMD_RSTDR_EXTEVNT8  = 1UL << 16,	 // External Event 8
	HRTIM_TIMD_RSTDR_EXTEVNT7  = 1UL << 15,	 // External Event 7
	HRTIM_TIMD_RSTDR_EXTEVNT6  = 1UL << 14,	 // External Event 6
	HRTIM_TIMD_RSTDR_EXTEVNT5  = 1UL << 13,	 // External Event 5
	HRTIM_TIMD_RSTDR_EXTEVNT4  = 1UL << 12,	 // External Event 4
	HRTIM_TIMD_RSTDR_EXTEVNT3  = 1UL << 11,	 // External Event 3
	HRTIM_TIMD_RSTDR_EXTEVNT2  = 1UL << 10,	 // External Event 2
	HRTIM_TIMD_RSTDR_EXTEVNT1  = 1UL << 9,	 // External Event 1
	HRTIM_TIMD_RSTDR_MSTCMP4   = 1UL << 8,	 // Master compare 4
	HRTIM_TIMD_RSTDR_MSTCMP3   = 1UL << 7,	 // Master compare 3
	HRTIM_TIMD_RSTDR_MSTCMP2   = 1UL << 6,	 // Master compare 2
	HRTIM_TIMD_RSTDR_MSTCMP1   = 1UL << 5,	 // Master compare 1
	HRTIM_TIMD_RSTDR_MSTPER	   = 1UL << 4,	 // Master timer Period
	HRTIM_TIMD_RSTDR_CMP4	   = 1UL << 3,	 // Timer A compare 4 reset
	HRTIM_TIMD_RSTDR_CMP2	   = 1UL << 2,	 // Timer A compare 2 reset
	HRTIM_TIMD_RSTDR_UPDT	   = 1UL << 1,	 // Timer A Update reset
	HRTIM_TIMD_RSTDR_TIMFCMP1  = 1UL << 0,	 // Timer A Update reset
};

// HRTIM_TIMD->CHPDR Timerx Chopper Register
enum {
	HRTIM_TIMD_CHPDR_STRTPW = ((1UL << 4) - 1) << 7,  // STRTPW
	HRTIM_TIMD_CHPDR_CHPDTY = ((1UL << 3) - 1) << 4,  // Timerx chopper duty cycle value
	HRTIM_TIMD_CHPDR_CHPFRQ = ((1UL << 4) - 1) << 0,  // Timerx carrier frequency value
};
inline void hrtim_timd_chpdr_set_strtpw(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->CHPDR = (p->CHPDR & ~HRTIM_TIMD_CHPDR_STRTPW) | ((val << 7) & HRTIM_TIMD_CHPDR_STRTPW);
}
inline void hrtim_timd_chpdr_set_chpdty(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->CHPDR = (p->CHPDR & ~HRTIM_TIMD_CHPDR_CHPDTY) | ((val << 4) & HRTIM_TIMD_CHPDR_CHPDTY);
}
inline void hrtim_timd_chpdr_set_chpfrq(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->CHPDR = (p->CHPDR & ~HRTIM_TIMD_CHPDR_CHPFRQ) | ((val << 0) & HRTIM_TIMD_CHPDR_CHPFRQ);
}
inline uint32_t hrtim_timd_chpdr_get_strtpw(struct HRTIM_TIMD_Type *p) { return (p->CHPDR & HRTIM_TIMD_CHPDR_STRTPW) >> 7; }
inline uint32_t hrtim_timd_chpdr_get_chpdty(struct HRTIM_TIMD_Type *p) { return (p->CHPDR & HRTIM_TIMD_CHPDR_CHPDTY) >> 4; }
inline uint32_t hrtim_timd_chpdr_get_chpfrq(struct HRTIM_TIMD_Type *p) { return (p->CHPDR & HRTIM_TIMD_CHPDR_CHPFRQ) >> 0; }

// HRTIM_TIMD->CPT1DCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMD_CPT1DCR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMD_CPT1DCR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMD_CPT1DCR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMD_CPT1DCR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMD_CPT1DCR_TFCMP2	 = 1UL << 27,  // TFCMP2
	HRTIM_TIMD_CPT1DCR_TFCMP1	 = 1UL << 26,  // TFCMP1
	HRTIM_TIMD_CPT1DCR_TF1RST	 = 1UL << 25,  // TF1RST
	HRTIM_TIMD_CPT1DCR_TF1SET	 = 1UL << 24,  // TF1SET
	HRTIM_TIMD_CPT1DCR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMD_CPT1DCR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMD_CPT1DCR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMD_CPT1DCR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMD_CPT1DCR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMD_CPT1DCR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMD_CPT1DCR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMD_CPT1DCR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMD_CPT1DCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMD_CPT1DCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMD_CPT1DCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMD_CPT1DCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMD_CPT1DCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMD_CPT1DCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMD_CPT1DCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMD_CPT1DCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMD_CPT1DCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMD_CPT1DCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMD_CPT1DCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMD_CPT1DCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMD_CPT1DCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMD_CPT1DCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMD_CPT1DCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMD_CPT1DCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMD->CPT2DCR CPT2xCR
enum {
	HRTIM_TIMD_CPT2DCR_TECMP2	 = 1UL << 31,  // Timer E Compare 2
	HRTIM_TIMD_CPT2DCR_TECMP1	 = 1UL << 30,  // Timer E Compare 1
	HRTIM_TIMD_CPT2DCR_TE1RST	 = 1UL << 29,  // Timer E output 1 Reset
	HRTIM_TIMD_CPT2DCR_TE1SET	 = 1UL << 28,  // Timer E output 1 Set
	HRTIM_TIMD_CPT2DCR_TFCMP2	 = 1UL << 27,  // TFCMP2
	HRTIM_TIMD_CPT2DCR_TFCMP1	 = 1UL << 26,  // TFCMP1
	HRTIM_TIMD_CPT2DCR_TF1RST	 = 1UL << 25,  // TF1RST
	HRTIM_TIMD_CPT2DCR_TF1SET	 = 1UL << 24,  // TF1SET
	HRTIM_TIMD_CPT2DCR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMD_CPT2DCR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMD_CPT2DCR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMD_CPT2DCR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMD_CPT2DCR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMD_CPT2DCR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMD_CPT2DCR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMD_CPT2DCR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMD_CPT2DCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMD_CPT2DCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMD_CPT2DCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMD_CPT2DCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMD_CPT2DCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMD_CPT2DCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMD_CPT2DCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMD_CPT2DCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMD_CPT2DCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMD_CPT2DCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMD_CPT2DCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMD_CPT2DCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMD_CPT2DCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMD_CPT2DCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMD_CPT2DCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMD_CPT2DCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMD->OUTDR Timerx Output Register
enum {
	HRTIM_TIMD_OUTDR_DIDL2	  = 1UL << 23,				 // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMD_OUTDR_CHP2	  = 1UL << 22,				 // Output 2 Chopper enable
	HRTIM_TIMD_OUTDR_FAULT2	  = ((1UL << 2) - 1) << 20,	 // Output 2 Fault state
	HRTIM_TIMD_OUTDR_IDLES2	  = 1UL << 19,				 // Output 2 Idle State
	HRTIM_TIMD_OUTDR_IDLEM2	  = 1UL << 18,				 // Output 2 Idle mode
	HRTIM_TIMD_OUTDR_POL2	  = 1UL << 17,				 // Output 2 polarity
	HRTIM_TIMD_OUTDR_BIAR	  = 1UL << 14,				 // Balanced Idle Automatic Resume
	HRTIM_TIMD_OUTDR_DLYPRT	  = ((1UL << 3) - 1) << 10,	 // Delayed Protection
	HRTIM_TIMD_OUTDR_DLYPRTEN = 1UL << 9,				 // Delayed Protection Enable
	HRTIM_TIMD_OUTDR_DTEN	  = 1UL << 8,				 // Deadtime enable
	HRTIM_TIMD_OUTDR_DIDL1	  = 1UL << 7,				 // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMD_OUTDR_CHP1	  = 1UL << 6,				 // Output 1 Chopper enable
	HRTIM_TIMD_OUTDR_FAULT1	  = ((1UL << 2) - 1) << 4,	 // Output 1 Fault state
	HRTIM_TIMD_OUTDR_IDLES1	  = 1UL << 3,				 // Output 1 Idle State
	HRTIM_TIMD_OUTDR_IDLEM1	  = 1UL << 2,				 // Output 1 Idle mode
	HRTIM_TIMD_OUTDR_POL1	  = 1UL << 1,				 // Output 1 polarity
};
inline void hrtim_timd_outdr_set_fault2(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->OUTDR = (p->OUTDR & ~HRTIM_TIMD_OUTDR_FAULT2) | ((val << 20) & HRTIM_TIMD_OUTDR_FAULT2);
}
inline void hrtim_timd_outdr_set_dlyprt(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->OUTDR = (p->OUTDR & ~HRTIM_TIMD_OUTDR_DLYPRT) | ((val << 10) & HRTIM_TIMD_OUTDR_DLYPRT);
}
inline void hrtim_timd_outdr_set_fault1(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->OUTDR = (p->OUTDR & ~HRTIM_TIMD_OUTDR_FAULT1) | ((val << 4) & HRTIM_TIMD_OUTDR_FAULT1);
}
inline uint32_t hrtim_timd_outdr_get_fault2(struct HRTIM_TIMD_Type *p) { return (p->OUTDR & HRTIM_TIMD_OUTDR_FAULT2) >> 20; }
inline uint32_t hrtim_timd_outdr_get_dlyprt(struct HRTIM_TIMD_Type *p) { return (p->OUTDR & HRTIM_TIMD_OUTDR_DLYPRT) >> 10; }
inline uint32_t hrtim_timd_outdr_get_fault1(struct HRTIM_TIMD_Type *p) { return (p->OUTDR & HRTIM_TIMD_OUTDR_FAULT1) >> 4; }

// HRTIM_TIMD->FLTDR Timerx Fault Register
enum {
	HRTIM_TIMD_FLTDR_FLTLCK = 1UL << 31,  // Fault sources Lock
	HRTIM_TIMD_FLTDR_FLT6EN = 1UL << 5,	  // Fault 6 enable
	HRTIM_TIMD_FLTDR_FLT5EN = 1UL << 4,	  // Fault 5 enable
	HRTIM_TIMD_FLTDR_FLT4EN = 1UL << 3,	  // Fault 4 enable
	HRTIM_TIMD_FLTDR_FLT3EN = 1UL << 2,	  // Fault 3 enable
	HRTIM_TIMD_FLTDR_FLT2EN = 1UL << 1,	  // Fault 2 enable
	HRTIM_TIMD_FLTDR_FLT1EN = 1UL << 0,	  // Fault 1 enable
};

// HRTIM_TIMD->TIMDCR2 HRTIM Timerx Control Register 2
enum {
	HRTIM_TIMD_TIMDCR2_TRGHLF = 1UL << 20,				 // Triggered-half mode
	HRTIM_TIMD_TIMDCR2_GTCMP3 = 1UL << 17,				 // Greater than Compare 3 PWM mode
	HRTIM_TIMD_TIMDCR2_GTCMP1 = 1UL << 16,				 // Greater than Compare 1 PWM mode
	HRTIM_TIMD_TIMDCR2_FEROM  = ((1UL << 2) - 1) << 14,	 // Fault and Event Roll-Over Mode
	HRTIM_TIMD_TIMDCR2_BMROM  = ((1UL << 2) - 1) << 12,	 // Burst Mode Roll-Over Mode
	HRTIM_TIMD_TIMDCR2_ADROM  = ((1UL << 2) - 1) << 10,	 // ADC Roll-Over Mode
	HRTIM_TIMD_TIMDCR2_OUTROM = ((1UL << 2) - 1) << 8,	 // Output Roll-Over Mode
	HRTIM_TIMD_TIMDCR2_ROM	  = ((1UL << 2) - 1) << 6,	 // Roll-Over Mode
	HRTIM_TIMD_TIMDCR2_UDM	  = 1UL << 4,				 // Up-Down Mode
	HRTIM_TIMD_TIMDCR2_DCDR	  = 1UL << 2,				 // Dual Channel DAC Reset trigger
	HRTIM_TIMD_TIMDCR2_DCDS	  = 1UL << 1,				 // Dual Channel DAC Step trigger
	HRTIM_TIMD_TIMDCR2_DCDE	  = 1UL << 0,				 // Dual Channel DAC trigger enable
};
inline void hrtim_timd_timdcr2_set_ferom(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR2 = (p->TIMDCR2 & ~HRTIM_TIMD_TIMDCR2_FEROM) | ((val << 14) & HRTIM_TIMD_TIMDCR2_FEROM);
}
inline void hrtim_timd_timdcr2_set_bmrom(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR2 = (p->TIMDCR2 & ~HRTIM_TIMD_TIMDCR2_BMROM) | ((val << 12) & HRTIM_TIMD_TIMDCR2_BMROM);
}
inline void hrtim_timd_timdcr2_set_adrom(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR2 = (p->TIMDCR2 & ~HRTIM_TIMD_TIMDCR2_ADROM) | ((val << 10) & HRTIM_TIMD_TIMDCR2_ADROM);
}
inline void hrtim_timd_timdcr2_set_outrom(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR2 = (p->TIMDCR2 & ~HRTIM_TIMD_TIMDCR2_OUTROM) | ((val << 8) & HRTIM_TIMD_TIMDCR2_OUTROM);
}
inline void hrtim_timd_timdcr2_set_rom(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->TIMDCR2 = (p->TIMDCR2 & ~HRTIM_TIMD_TIMDCR2_ROM) | ((val << 6) & HRTIM_TIMD_TIMDCR2_ROM);
}
inline uint32_t hrtim_timd_timdcr2_get_ferom(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR2 & HRTIM_TIMD_TIMDCR2_FEROM) >> 14; }
inline uint32_t hrtim_timd_timdcr2_get_bmrom(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR2 & HRTIM_TIMD_TIMDCR2_BMROM) >> 12; }
inline uint32_t hrtim_timd_timdcr2_get_adrom(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR2 & HRTIM_TIMD_TIMDCR2_ADROM) >> 10; }
inline uint32_t hrtim_timd_timdcr2_get_outrom(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR2 & HRTIM_TIMD_TIMDCR2_OUTROM) >> 8; }
inline uint32_t hrtim_timd_timdcr2_get_rom(struct HRTIM_TIMD_Type *p) { return (p->TIMDCR2 & HRTIM_TIMD_TIMDCR2_ROM) >> 6; }

// HRTIM_TIMD->DEEFR3 HRTIM Timerx External Event Filtering Register 3
enum {
	HRTIM_TIMD_DEEFR3_EEVACNT  = ((1UL << 6) - 1) << 8,	 // External Event A counter
	HRTIM_TIMD_DEEFR3_EEVASEL  = ((1UL << 4) - 1) << 4,	 // External Event A Selection
	HRTIM_TIMD_DEEFR3_EEVARSTM = 1UL << 2,				 // External Event A Reset Mode
	HRTIM_TIMD_DEEFR3_EEVACRES = 1UL << 1,				 // External Event A Counter Reset
	HRTIM_TIMD_DEEFR3_EEVACE   = 1UL << 0,				 // External Event A Counter Enable
};
inline void hrtim_timd_deefr3_set_eevacnt(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->DEEFR3 = (p->DEEFR3 & ~HRTIM_TIMD_DEEFR3_EEVACNT) | ((val << 8) & HRTIM_TIMD_DEEFR3_EEVACNT);
}
inline void hrtim_timd_deefr3_set_eevasel(struct HRTIM_TIMD_Type *p, uint32_t val) {
	p->DEEFR3 = (p->DEEFR3 & ~HRTIM_TIMD_DEEFR3_EEVASEL) | ((val << 4) & HRTIM_TIMD_DEEFR3_EEVASEL);
}
inline uint32_t hrtim_timd_deefr3_get_eevacnt(struct HRTIM_TIMD_Type *p) { return (p->DEEFR3 & HRTIM_TIMD_DEEFR3_EEVACNT) >> 8; }
inline uint32_t hrtim_timd_deefr3_get_eevasel(struct HRTIM_TIMD_Type *p) { return (p->DEEFR3 & HRTIM_TIMD_DEEFR3_EEVASEL) >> 4; }

/* High Resolution Timer: TIME */
struct HRTIM_TIME_Type {
	__IO uint32_t TIMECR;		 // @0 Timerx Control Register
	__I uint32_t  TIMEISR;		 // @4 Timerx Interrupt Status Register
	__O uint16_t  TIMEICR;		 // @8 Timerx Interrupt Clear Register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t TIMEDIER;		 // @12 TIMxDIER
	__IO uint16_t CNTER;		 // @16 Timerx Counter Register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t PERER;		 // @20 Timerx Period Register
	uint8_t		  RESERVED2[2];	 // @22
	__IO uint8_t  REPER;		 // @24 Timerx Repetition Register
	uint8_t		  RESERVED3[3];	 // @25
	__IO uint16_t CMP1ER;		 // @28 Timerx Compare 1 Register
	uint8_t		  RESERVED4[2];	 // @30
	__IO uint32_t CMP1CER;		 // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2ER;		 // @36 Timerx Compare 2 Register
	uint8_t		  RESERVED5[2];	 // @38
	__IO uint16_t CMP3ER;		 // @40 Timerx Compare 3 Register
	uint8_t		  RESERVED6[2];	 // @42
	__IO uint16_t CMP4ER;		 // @44 Timerx Compare 4 Register
	uint8_t		  RESERVED7[2];	 // @46
	__I uint32_t  CPT1ER;		 // @48 Timerx Capture 1 Register
	__I uint32_t  CPT2ER;		 // @52 Timerx Capture 2 Register
	__IO uint32_t DTER;			 // @56 Timerx Deadtime Register
	__IO uint32_t SETE1R;		 // @60 Timerx Output1 Set Register
	__IO uint32_t RSTE1R;		 // @64 Timerx Output1 Reset Register
	__IO uint32_t SETE2R;		 // @68 Timerx Output2 Set Register
	__IO uint32_t RSTE2R;		 // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFER1;		 // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFER2;		 // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTER;		 // @84 TimerA Reset Register
	__IO uint16_t CHPER;		 // @88 Timerx Chopper Register
	uint8_t		  RESERVED8[2];	 // @90
	__IO uint32_t CPT1ECR;		 // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2ECR;		 // @96 CPT2xCR
	__IO uint32_t OUTER;		 // @100 Timerx Output Register
	__IO uint32_t FLTER;		 // @104 Timerx Fault Register
	__IO uint32_t TIMECR2;		 // @108 HRTIM Timerx Control Register 2
	__IO uint16_t EEEFR3;		 // @112 HRTIM Timerx External Event Filtering Register 3
};

// HRTIM_TIME->TIMECR Timerx Control Register
enum {
	HRTIM_TIME_TIMECR_UPDGAT	= ((1UL << 4) - 1) << 28,  // Update Gating
	HRTIM_TIME_TIMECR_PREEN		= 1UL << 27,			   // Preload enable
	HRTIM_TIME_TIMECR_DACSYNC	= ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_TIME_TIMECR_MSTU		= 1UL << 24,			   // Master Timer update
	HRTIM_TIME_TIMECR_TDU		= 1UL << 22,			   // TDU
	HRTIM_TIME_TIMECR_TCU		= 1UL << 21,			   // TCU
	HRTIM_TIME_TIMECR_TBU		= 1UL << 20,			   // TBU
	HRTIM_TIME_TIMECR_TAU		= 1UL << 19,			   // TAU
	HRTIM_TIME_TIMECR_TXRSTU	= 1UL << 18,			   // Timerx reset update
	HRTIM_TIME_TIMECR_TXREPU	= 1UL << 17,			   // Timer x Repetition update
	HRTIM_TIME_TIMECR_TFU		= 1UL << 16,			   // TFU
	HRTIM_TIME_TIMECR_DELCMP4	= ((1UL << 2) - 1) << 14,  // Delayed CMP4 mode
	HRTIM_TIME_TIMECR_DELCMP2	= ((1UL << 2) - 1) << 12,  // Delayed CMP2 mode
	HRTIM_TIME_TIMECR_SYNCSTRTX = 1UL << 11,			   // Synchronization Starts Timer x
	HRTIM_TIME_TIMECR_SYNCRSTX	= 1UL << 10,			   // Synchronization Resets Timer x
	HRTIM_TIME_TIMECR_RSYNCU	= 1UL << 9,				   // Re-Synchronized Update
	HRTIM_TIME_TIMECR_INTLVD	= ((1UL << 2) - 1) << 7,   // Interleaved mode
	HRTIM_TIME_TIMECR_PSHPLL	= 1UL << 6,				   // Push-Pull mode enable
	HRTIM_TIME_TIMECR_HALF		= 1UL << 5,				   // Half mode enable
	HRTIM_TIME_TIMECR_RETRIG	= 1UL << 4,				   // Re-triggerable mode
	HRTIM_TIME_TIMECR_CONT		= 1UL << 3,				   // Continuous mode
	HRTIM_TIME_TIMECR_CK_PSCX	= ((1UL << 3) - 1) << 0,   // HRTIM Timer x Clock prescaler
};
inline void hrtim_time_timecr_set_updgat(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_UPDGAT) | ((val << 28) & HRTIM_TIME_TIMECR_UPDGAT);
}
inline void hrtim_time_timecr_set_dacsync(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_DACSYNC) | ((val << 25) & HRTIM_TIME_TIMECR_DACSYNC);
}
inline void hrtim_time_timecr_set_delcmp4(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_DELCMP4) | ((val << 14) & HRTIM_TIME_TIMECR_DELCMP4);
}
inline void hrtim_time_timecr_set_delcmp2(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_DELCMP2) | ((val << 12) & HRTIM_TIME_TIMECR_DELCMP2);
}
inline void hrtim_time_timecr_set_intlvd(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_INTLVD) | ((val << 7) & HRTIM_TIME_TIMECR_INTLVD);
}
inline void hrtim_time_timecr_set_ck_pscx(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR = (p->TIMECR & ~HRTIM_TIME_TIMECR_CK_PSCX) | ((val << 0) & HRTIM_TIME_TIMECR_CK_PSCX);
}
inline uint32_t hrtim_time_timecr_get_updgat(struct HRTIM_TIME_Type *p) { return (p->TIMECR & HRTIM_TIME_TIMECR_UPDGAT) >> 28; }
inline uint32_t hrtim_time_timecr_get_dacsync(struct HRTIM_TIME_Type *p) { return (p->TIMECR & HRTIM_TIME_TIMECR_DACSYNC) >> 25; }
inline uint32_t hrtim_time_timecr_get_delcmp4(struct HRTIM_TIME_Type *p) { return (p->TIMECR & HRTIM_TIME_TIMECR_DELCMP4) >> 14; }
inline uint32_t hrtim_time_timecr_get_delcmp2(struct HRTIM_TIME_Type *p) { return (p->TIMECR & HRTIM_TIME_TIMECR_DELCMP2) >> 12; }
inline uint32_t hrtim_time_timecr_get_intlvd(struct HRTIM_TIME_Type *p) { return (p->TIMECR & HRTIM_TIME_TIMECR_INTLVD) >> 7; }
inline uint32_t hrtim_time_timecr_get_ck_pscx(struct HRTIM_TIME_Type *p) { return (p->TIMECR & HRTIM_TIME_TIMECR_CK_PSCX) >> 0; }

// HRTIM_TIME->TIMEISR Timerx Interrupt Status Register
enum {
	HRTIM_TIME_TIMEISR_O2CPY   = 1UL << 21,	 // Output 2 Copy
	HRTIM_TIME_TIMEISR_O1CPY   = 1UL << 20,	 // Output 1 Copy
	HRTIM_TIME_TIMEISR_O2STAT  = 1UL << 19,	 // Output 2 State
	HRTIM_TIME_TIMEISR_O1STAT  = 1UL << 18,	 // Output 1 State
	HRTIM_TIME_TIMEISR_IPPSTAT = 1UL << 17,	 // Idle Push Pull Status
	HRTIM_TIME_TIMEISR_CPPSTAT = 1UL << 16,	 // Current Push Pull Status
	HRTIM_TIME_TIMEISR_DLYPRT  = 1UL << 14,	 // Delayed Protection Flag
	HRTIM_TIME_TIMEISR_RST	   = 1UL << 13,	 // Reset Interrupt Flag
	HRTIM_TIME_TIMEISR_RSTX2   = 1UL << 12,	 // Output 2 Reset Interrupt Flag
	HRTIM_TIME_TIMEISR_SETX2   = 1UL << 11,	 // Output 2 Set Interrupt Flag
	HRTIM_TIME_TIMEISR_RSTX1   = 1UL << 10,	 // Output 1 Reset Interrupt Flag
	HRTIM_TIME_TIMEISR_SETX1   = 1UL << 9,	 // Output 1 Set Interrupt Flag
	HRTIM_TIME_TIMEISR_CPT2	   = 1UL << 8,	 // Capture2 Interrupt Flag
	HRTIM_TIME_TIMEISR_CPT1	   = 1UL << 7,	 // Capture1 Interrupt Flag
	HRTIM_TIME_TIMEISR_UPD	   = 1UL << 6,	 // Update Interrupt Flag
	HRTIM_TIME_TIMEISR_REP	   = 1UL << 4,	 // Repetition Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP4	   = 1UL << 3,	 // Compare 4 Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP3	   = 1UL << 2,	 // Compare 3 Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP2	   = 1UL << 1,	 // Compare 2 Interrupt Flag
	HRTIM_TIME_TIMEISR_CMP1	   = 1UL << 0,	 // Compare 1 Interrupt Flag
};

// HRTIM_TIME->TIMEICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIME_TIMEICR_DLYPRTC = 1UL << 14,	 // Delayed Protection Flag Clear
	HRTIM_TIME_TIMEICR_RSTC	   = 1UL << 13,	 // Reset Interrupt flag Clear
	HRTIM_TIME_TIMEICR_RSTX2C  = 1UL << 12,	 // Output 2 Reset flag Clear
	HRTIM_TIME_TIMEICR_SET2XC  = 1UL << 11,	 // Output 2 Set flag Clear
	HRTIM_TIME_TIMEICR_RSTX1C  = 1UL << 10,	 // Output 1 Reset flag Clear
	HRTIM_TIME_TIMEICR_SET1XC  = 1UL << 9,	 // Output 1 Set flag Clear
	HRTIM_TIME_TIMEICR_CPT2C   = 1UL << 8,	 // Capture2 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CPT1C   = 1UL << 7,	 // Capture1 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_UPDC	   = 1UL << 6,	 // Update Interrupt flag Clear
	HRTIM_TIME_TIMEICR_REPC	   = 1UL << 4,	 // Repetition Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP4C   = 1UL << 3,	 // Compare 4 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP3C   = 1UL << 2,	 // Compare 3 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP2C   = 1UL << 1,	 // Compare 2 Interrupt flag Clear
	HRTIM_TIME_TIMEICR_CMP1C   = 1UL << 0,	 // Compare 1 Interrupt flag Clear
};

// HRTIM_TIME->TIMEDIER TIMxDIER
enum {
	HRTIM_TIME_TIMEDIER_DLYPRTDE = 1UL << 30,  // DLYPRTDE
	HRTIM_TIME_TIMEDIER_RSTDE	 = 1UL << 29,  // RSTDE
	HRTIM_TIME_TIMEDIER_RSTX2DE	 = 1UL << 28,  // RSTx2DE
	HRTIM_TIME_TIMEDIER_SETX2DE	 = 1UL << 27,  // SETx2DE
	HRTIM_TIME_TIMEDIER_RSTX1DE	 = 1UL << 26,  // RSTx1DE
	HRTIM_TIME_TIMEDIER_SET1XDE	 = 1UL << 25,  // SET1xDE
	HRTIM_TIME_TIMEDIER_CPT2DE	 = 1UL << 24,  // CPT2DE
	HRTIM_TIME_TIMEDIER_CPT1DE	 = 1UL << 23,  // CPT1DE
	HRTIM_TIME_TIMEDIER_UPDDE	 = 1UL << 22,  // UPDDE
	HRTIM_TIME_TIMEDIER_REPDE	 = 1UL << 20,  // REPDE
	HRTIM_TIME_TIMEDIER_CMP4DE	 = 1UL << 19,  // CMP4DE
	HRTIM_TIME_TIMEDIER_CMP3DE	 = 1UL << 18,  // CMP3DE
	HRTIM_TIME_TIMEDIER_CMP2DE	 = 1UL << 17,  // CMP2DE
	HRTIM_TIME_TIMEDIER_CMP1DE	 = 1UL << 16,  // CMP1DE
	HRTIM_TIME_TIMEDIER_DLYPRTIE = 1UL << 14,  // DLYPRTIE
	HRTIM_TIME_TIMEDIER_RSTIE	 = 1UL << 13,  // RSTIE
	HRTIM_TIME_TIMEDIER_RSTX2IE	 = 1UL << 12,  // RSTx2IE
	HRTIM_TIME_TIMEDIER_SETX2IE	 = 1UL << 11,  // SETx2IE
	HRTIM_TIME_TIMEDIER_RSTX1IE	 = 1UL << 10,  // RSTx1IE
	HRTIM_TIME_TIMEDIER_SET1XIE	 = 1UL << 9,   // SET1xIE
	HRTIM_TIME_TIMEDIER_CPT2IE	 = 1UL << 8,   // CPT2IE
	HRTIM_TIME_TIMEDIER_CPT1IE	 = 1UL << 7,   // CPT1IE
	HRTIM_TIME_TIMEDIER_UPDIE	 = 1UL << 6,   // UPDIE
	HRTIM_TIME_TIMEDIER_REPIE	 = 1UL << 4,   // REPIE
	HRTIM_TIME_TIMEDIER_CMP4IE	 = 1UL << 3,   // CMP4IE
	HRTIM_TIME_TIMEDIER_CMP3IE	 = 1UL << 2,   // CMP3IE
	HRTIM_TIME_TIMEDIER_CMP2IE	 = 1UL << 1,   // CMP2IE
	HRTIM_TIME_TIMEDIER_CMP1IE	 = 1UL << 0,   // CMP1IE
};

// HRTIM_TIME->CMP1CER Timerx Compare 1 Compound Register
enum {
	HRTIM_TIME_CMP1CER_REPX	 = ((1UL << 8) - 1) << 16,	// Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIME_CMP1CER_CMP1X = ((1UL << 16) - 1) << 0,	// Timerx Compare 1 value
};
inline void hrtim_time_cmp1cer_set_repx(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->CMP1CER = (p->CMP1CER & ~HRTIM_TIME_CMP1CER_REPX) | ((val << 16) & HRTIM_TIME_CMP1CER_REPX);
}
inline void hrtim_time_cmp1cer_set_cmp1x(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->CMP1CER = (p->CMP1CER & ~HRTIM_TIME_CMP1CER_CMP1X) | ((val << 0) & HRTIM_TIME_CMP1CER_CMP1X);
}
inline uint32_t hrtim_time_cmp1cer_get_repx(struct HRTIM_TIME_Type *p) { return (p->CMP1CER & HRTIM_TIME_CMP1CER_REPX) >> 16; }
inline uint32_t hrtim_time_cmp1cer_get_cmp1x(struct HRTIM_TIME_Type *p) { return (p->CMP1CER & HRTIM_TIME_CMP1CER_CMP1X) >> 0; }

// HRTIM_TIME->CPT1ER Timerx Capture 1 Register
enum {
	HRTIM_TIME_CPT1ER_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIME_CPT1ER_CPT1X = ((1UL << 16) - 1) << 0,  // Timerx Capture 1 value
};
inline uint32_t hrtim_time_cpt1er_get_cpt1x(struct HRTIM_TIME_Type *p) { return (p->CPT1ER & HRTIM_TIME_CPT1ER_CPT1X) >> 0; }

// HRTIM_TIME->CPT2ER Timerx Capture 2 Register
enum {
	HRTIM_TIME_CPT2ER_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIME_CPT2ER_CPT2X = ((1UL << 16) - 1) << 0,  // Timerx Capture 2 value
};
inline uint32_t hrtim_time_cpt2er_get_cpt2x(struct HRTIM_TIME_Type *p) { return (p->CPT2ER & HRTIM_TIME_CPT2ER_CPT2X) >> 0; }

// HRTIM_TIME->DTER Timerx Deadtime Register
enum {
	HRTIM_TIME_DTER_DTFLKX	= 1UL << 31,			   // Deadtime Falling Lock
	HRTIM_TIME_DTER_DTFSLKX = 1UL << 30,			   // Deadtime Falling Sign Lock
	HRTIM_TIME_DTER_SDTFX	= 1UL << 25,			   // Sign Deadtime Falling value
	HRTIM_TIME_DTER_DTFX	= ((1UL << 9) - 1) << 16,  // Deadtime Falling value
	HRTIM_TIME_DTER_DTRLKX	= 1UL << 15,			   // Deadtime Rising Lock
	HRTIM_TIME_DTER_DTRSLKX = 1UL << 14,			   // Deadtime Rising Sign Lock
	HRTIM_TIME_DTER_DTPRSC	= ((1UL << 3) - 1) << 10,  // Deadtime Prescaler
	HRTIM_TIME_DTER_SDTRX	= 1UL << 9,				   // Sign Deadtime Rising value
	HRTIM_TIME_DTER_DTRX	= ((1UL << 9) - 1) << 0,   // Deadtime Rising value
};
inline void hrtim_time_dter_set_dtfx(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->DTER = (p->DTER & ~HRTIM_TIME_DTER_DTFX) | ((val << 16) & HRTIM_TIME_DTER_DTFX);
}
inline void hrtim_time_dter_set_dtprsc(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->DTER = (p->DTER & ~HRTIM_TIME_DTER_DTPRSC) | ((val << 10) & HRTIM_TIME_DTER_DTPRSC);
}
inline void hrtim_time_dter_set_dtrx(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->DTER = (p->DTER & ~HRTIM_TIME_DTER_DTRX) | ((val << 0) & HRTIM_TIME_DTER_DTRX);
}
inline uint32_t hrtim_time_dter_get_dtfx(struct HRTIM_TIME_Type *p) { return (p->DTER & HRTIM_TIME_DTER_DTFX) >> 16; }
inline uint32_t hrtim_time_dter_get_dtprsc(struct HRTIM_TIME_Type *p) { return (p->DTER & HRTIM_TIME_DTER_DTPRSC) >> 10; }
inline uint32_t hrtim_time_dter_get_dtrx(struct HRTIM_TIME_Type *p) { return (p->DTER & HRTIM_TIME_DTER_DTRX) >> 0; }

// HRTIM_TIME->SETE1R Timerx Output1 Set Register
enum {
	HRTIM_TIME_SETE1R_UPDATE	= 1UL << 31,  // Registers update (transfer preload to active)
	HRTIM_TIME_SETE1R_EXTEVNT10 = 1UL << 30,  // External Event 10
	HRTIM_TIME_SETE1R_EXTEVNT9	= 1UL << 29,  // External Event 9
	HRTIM_TIME_SETE1R_EXTEVNT8	= 1UL << 28,  // External Event 8
	HRTIM_TIME_SETE1R_EXTEVNT7	= 1UL << 27,  // External Event 7
	HRTIM_TIME_SETE1R_EXTEVNT6	= 1UL << 26,  // External Event 6
	HRTIM_TIME_SETE1R_EXTEVNT5	= 1UL << 25,  // External Event 5
	HRTIM_TIME_SETE1R_EXTEVNT4	= 1UL << 24,  // External Event 4
	HRTIM_TIME_SETE1R_EXTEVNT3	= 1UL << 23,  // External Event 3
	HRTIM_TIME_SETE1R_EXTEVNT2	= 1UL << 22,  // External Event 2
	HRTIM_TIME_SETE1R_EXTEVNT1	= 1UL << 21,  // External Event 1
	HRTIM_TIME_SETE1R_TIMEVNT9	= 1UL << 20,  // Timer Event 9
	HRTIM_TIME_SETE1R_TIMEVNT8	= 1UL << 19,  // Timer Event 8
	HRTIM_TIME_SETE1R_TIMEVNT7	= 1UL << 18,  // Timer Event 7
	HRTIM_TIME_SETE1R_TIMEVNT6	= 1UL << 17,  // Timer Event 6
	HRTIM_TIME_SETE1R_TIMEVNT5	= 1UL << 16,  // Timer Event 5
	HRTIM_TIME_SETE1R_TIMEVNT4	= 1UL << 15,  // Timer Event 4
	HRTIM_TIME_SETE1R_TIMEVNT3	= 1UL << 14,  // Timer Event 3
	HRTIM_TIME_SETE1R_TIMEVNT2	= 1UL << 13,  // Timer Event 2
	HRTIM_TIME_SETE1R_TIMEVNT1	= 1UL << 12,  // Timer Event 1
	HRTIM_TIME_SETE1R_MSTCMP4	= 1UL << 11,  // Master Compare 4
	HRTIM_TIME_SETE1R_MSTCMP3	= 1UL << 10,  // Master Compare 3
	HRTIM_TIME_SETE1R_MSTCMP2	= 1UL << 9,	  // Master Compare 2
	HRTIM_TIME_SETE1R_MSTCMP1	= 1UL << 8,	  // Master Compare 1
	HRTIM_TIME_SETE1R_MSTPER	= 1UL << 7,	  // Master Period
	HRTIM_TIME_SETE1R_CMP4		= 1UL << 6,	  // Timer A compare 4
	HRTIM_TIME_SETE1R_CMP3		= 1UL << 5,	  // Timer A compare 3
	HRTIM_TIME_SETE1R_CMP2		= 1UL << 4,	  // Timer A compare 2
	HRTIM_TIME_SETE1R_CMP1		= 1UL << 3,	  // Timer A compare 1
	HRTIM_TIME_SETE1R_PER		= 1UL << 2,	  // Timer A Period
	HRTIM_TIME_SETE1R_RESYNC	= 1UL << 1,	  // Timer A resynchronizaton
	HRTIM_TIME_SETE1R_SST		= 1UL << 0,	  // Software Set trigger
};

// HRTIM_TIME->RSTE1R Timerx Output1 Reset Register
enum {
	HRTIM_TIME_RSTE1R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIME_RSTE1R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIME_RSTE1R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIME_RSTE1R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIME_RSTE1R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIME_RSTE1R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIME_RSTE1R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIME_RSTE1R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIME_RSTE1R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIME_RSTE1R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIME_RSTE1R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIME_RSTE1R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIME_RSTE1R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIME_RSTE1R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIME_RSTE1R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIME_RSTE1R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIME_RSTE1R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIME_RSTE1R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIME_RSTE1R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIME_RSTE1R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIME_RSTE1R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIME_RSTE1R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIME_RSTE1R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIME_RSTE1R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIME_RSTE1R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIME_RSTE1R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIME_RSTE1R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIME_RSTE1R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIME_RSTE1R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIME_RSTE1R_PER		= 1UL << 2,	  // PER
	HRTIM_TIME_RSTE1R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIME_RSTE1R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIME->SETE2R Timerx Output2 Set Register
enum {
	HRTIM_TIME_SETE2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIME_SETE2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIME_SETE2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIME_SETE2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIME_SETE2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIME_SETE2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIME_SETE2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIME_SETE2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIME_SETE2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIME_SETE2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIME_SETE2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIME_SETE2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIME_SETE2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIME_SETE2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIME_SETE2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIME_SETE2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIME_SETE2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIME_SETE2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIME_SETE2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIME_SETE2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIME_SETE2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIME_SETE2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIME_SETE2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIME_SETE2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIME_SETE2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIME_SETE2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIME_SETE2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIME_SETE2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIME_SETE2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIME_SETE2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIME_SETE2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIME_SETE2R_SST		= 1UL << 0,	  // SST
};

// HRTIM_TIME->RSTE2R Timerx Output2 Reset Register
enum {
	HRTIM_TIME_RSTE2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIME_RSTE2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIME_RSTE2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIME_RSTE2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIME_RSTE2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIME_RSTE2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIME_RSTE2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIME_RSTE2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIME_RSTE2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIME_RSTE2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIME_RSTE2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIME_RSTE2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIME_RSTE2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIME_RSTE2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIME_RSTE2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIME_RSTE2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIME_RSTE2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIME_RSTE2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIME_RSTE2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIME_RSTE2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIME_RSTE2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIME_RSTE2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIME_RSTE2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIME_RSTE2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIME_RSTE2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIME_RSTE2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIME_RSTE2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIME_RSTE2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIME_RSTE2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIME_RSTE2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIME_RSTE2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIME_RSTE2R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIME->EEFER1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIME_EEFER1_EE5FLTR = ((1UL << 4) - 1) << 25,	 // External Event 5 filter
	HRTIM_TIME_EEFER1_EE5LTCH = 1UL << 24,				 // External Event 5 latch
	HRTIM_TIME_EEFER1_EE4FLTR = ((1UL << 4) - 1) << 19,	 // External Event 4 filter
	HRTIM_TIME_EEFER1_EE4LTCH = 1UL << 18,				 // External Event 4 latch
	HRTIM_TIME_EEFER1_EE3FLTR = ((1UL << 4) - 1) << 13,	 // External Event 3 filter
	HRTIM_TIME_EEFER1_EE3LTCH = 1UL << 12,				 // External Event 3 latch
	HRTIM_TIME_EEFER1_EE2FLTR = ((1UL << 4) - 1) << 7,	 // External Event 2 filter
	HRTIM_TIME_EEFER1_EE2LTCH = 1UL << 6,				 // External Event 2 latch
	HRTIM_TIME_EEFER1_EE1FLTR = ((1UL << 4) - 1) << 1,	 // External Event 1 filter
	HRTIM_TIME_EEFER1_EE1LTCH = 1UL << 0,				 // External Event 1 latch
};
inline void hrtim_time_eefer1_set_ee5fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE5FLTR) | ((val << 25) & HRTIM_TIME_EEFER1_EE5FLTR);
}
inline void hrtim_time_eefer1_set_ee4fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE4FLTR) | ((val << 19) & HRTIM_TIME_EEFER1_EE4FLTR);
}
inline void hrtim_time_eefer1_set_ee3fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE3FLTR) | ((val << 13) & HRTIM_TIME_EEFER1_EE3FLTR);
}
inline void hrtim_time_eefer1_set_ee2fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE2FLTR) | ((val << 7) & HRTIM_TIME_EEFER1_EE2FLTR);
}
inline void hrtim_time_eefer1_set_ee1fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER1 = (p->EEFER1 & ~HRTIM_TIME_EEFER1_EE1FLTR) | ((val << 1) & HRTIM_TIME_EEFER1_EE1FLTR);
}
inline uint32_t hrtim_time_eefer1_get_ee5fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE5FLTR) >> 25; }
inline uint32_t hrtim_time_eefer1_get_ee4fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE4FLTR) >> 19; }
inline uint32_t hrtim_time_eefer1_get_ee3fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE3FLTR) >> 13; }
inline uint32_t hrtim_time_eefer1_get_ee2fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE2FLTR) >> 7; }
inline uint32_t hrtim_time_eefer1_get_ee1fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER1 & HRTIM_TIME_EEFER1_EE1FLTR) >> 1; }

// HRTIM_TIME->EEFER2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIME_EEFER2_EE10FLTR = ((1UL << 4) - 1) << 25,  // External Event 10 filter
	HRTIM_TIME_EEFER2_EE10LTCH = 1UL << 24,				  // External Event 10 latch
	HRTIM_TIME_EEFER2_EE9FLTR  = ((1UL << 4) - 1) << 19,  // External Event 9 filter
	HRTIM_TIME_EEFER2_EE9LTCH  = 1UL << 18,				  // External Event 9 latch
	HRTIM_TIME_EEFER2_EE8FLTR  = ((1UL << 4) - 1) << 13,  // External Event 8 filter
	HRTIM_TIME_EEFER2_EE8LTCH  = 1UL << 12,				  // External Event 8 latch
	HRTIM_TIME_EEFER2_EE7FLTR  = ((1UL << 4) - 1) << 7,	  // External Event 7 filter
	HRTIM_TIME_EEFER2_EE7LTCH  = 1UL << 6,				  // External Event 7 latch
	HRTIM_TIME_EEFER2_EE6FLTR  = ((1UL << 4) - 1) << 1,	  // External Event 6 filter
	HRTIM_TIME_EEFER2_EE6LTCH  = 1UL << 0,				  // External Event 6 latch
};
inline void hrtim_time_eefer2_set_ee10fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE10FLTR) | ((val << 25) & HRTIM_TIME_EEFER2_EE10FLTR);
}
inline void hrtim_time_eefer2_set_ee9fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE9FLTR) | ((val << 19) & HRTIM_TIME_EEFER2_EE9FLTR);
}
inline void hrtim_time_eefer2_set_ee8fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE8FLTR) | ((val << 13) & HRTIM_TIME_EEFER2_EE8FLTR);
}
inline void hrtim_time_eefer2_set_ee7fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE7FLTR) | ((val << 7) & HRTIM_TIME_EEFER2_EE7FLTR);
}
inline void hrtim_time_eefer2_set_ee6fltr(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEFER2 = (p->EEFER2 & ~HRTIM_TIME_EEFER2_EE6FLTR) | ((val << 1) & HRTIM_TIME_EEFER2_EE6FLTR);
}
inline uint32_t hrtim_time_eefer2_get_ee10fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE10FLTR) >> 25; }
inline uint32_t hrtim_time_eefer2_get_ee9fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE9FLTR) >> 19; }
inline uint32_t hrtim_time_eefer2_get_ee8fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE8FLTR) >> 13; }
inline uint32_t hrtim_time_eefer2_get_ee7fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE7FLTR) >> 7; }
inline uint32_t hrtim_time_eefer2_get_ee6fltr(struct HRTIM_TIME_Type *p) { return (p->EEFER2 & HRTIM_TIME_EEFER2_EE6FLTR) >> 1; }

// HRTIM_TIME->RSTER TimerA Reset Register
enum {
	HRTIM_TIME_RSTER_TIMFCPM2  = 1UL << 31,	 // Timer F Compare 2
	HRTIM_TIME_RSTER_TIMDCMP4  = 1UL << 30,	 // Timer D Compare 4
	HRTIM_TIME_RSTER_TIMDCMP2  = 1UL << 29,	 // Timer D Compare 2
	HRTIM_TIME_RSTER_TIMDCMP1  = 1UL << 28,	 // Timer D Compare 1
	HRTIM_TIME_RSTER_TIMCCMP4  = 1UL << 27,	 // Timer C Compare 4
	HRTIM_TIME_RSTER_TIMCCMP2  = 1UL << 26,	 // Timer C Compare 2
	HRTIM_TIME_RSTER_TIMCCMP1  = 1UL << 25,	 // Timer C Compare 1
	HRTIM_TIME_RSTER_TIMBCMP4  = 1UL << 24,	 // Timer B Compare 4
	HRTIM_TIME_RSTER_TIMBCMP2  = 1UL << 23,	 // Timer B Compare 2
	HRTIM_TIME_RSTER_TIMBCMP1  = 1UL << 22,	 // Timer B Compare 1
	HRTIM_TIME_RSTER_TIMACMP4  = 1UL << 21,	 // Timer A Compare 4
	HRTIM_TIME_RSTER_TIMACMP2  = 1UL << 20,	 // Timer A Compare 2
	HRTIM_TIME_RSTER_TIMACMP1  = 1UL << 19,	 // Timer A Compare 1
	HRTIM_TIME_RSTER_EXTEVNT10 = 1UL << 18,	 // External Event 10
	HRTIM_TIME_RSTER_EXTEVNT9  = 1UL << 17,	 // External Event 9
	HRTIM_TIME_RSTER_EXTEVNT8  = 1UL << 16,	 // External Event 8
	HRTIM_TIME_RSTER_EXTEVNT7  = 1UL << 15,	 // External Event 7
	HRTIM_TIME_RSTER_EXTEVNT6  = 1UL << 14,	 // External Event 6
	HRTIM_TIME_RSTER_EXTEVNT5  = 1UL << 13,	 // External Event 5
	HRTIM_TIME_RSTER_EXTEVNT4  = 1UL << 12,	 // External Event 4
	HRTIM_TIME_RSTER_EXTEVNT3  = 1UL << 11,	 // External Event 3
	HRTIM_TIME_RSTER_EXTEVNT2  = 1UL << 10,	 // External Event 2
	HRTIM_TIME_RSTER_EXTEVNT1  = 1UL << 9,	 // External Event 1
	HRTIM_TIME_RSTER_MSTCMP4   = 1UL << 8,	 // Master compare 4
	HRTIM_TIME_RSTER_MSTCMP3   = 1UL << 7,	 // Master compare 3
	HRTIM_TIME_RSTER_MSTCMP2   = 1UL << 6,	 // Master compare 2
	HRTIM_TIME_RSTER_MSTCMP1   = 1UL << 5,	 // Master compare 1
	HRTIM_TIME_RSTER_MSTPER	   = 1UL << 4,	 // Master timer Period
	HRTIM_TIME_RSTER_CMP4	   = 1UL << 3,	 // Timer A compare 4 reset
	HRTIM_TIME_RSTER_CMP2	   = 1UL << 2,	 // Timer A compare 2 reset
	HRTIM_TIME_RSTER_UPDT	   = 1UL << 1,	 // Timer A Update reset
	HRTIM_TIME_RSTER_TIMFCMP1  = 1UL << 0,	 // Timer A Update reset
};

// HRTIM_TIME->CHPER Timerx Chopper Register
enum {
	HRTIM_TIME_CHPER_STRTPW = ((1UL << 4) - 1) << 7,  // STRTPW
	HRTIM_TIME_CHPER_CHPDTY = ((1UL << 3) - 1) << 4,  // Timerx chopper duty cycle value
	HRTIM_TIME_CHPER_CHPFRQ = ((1UL << 4) - 1) << 0,  // Timerx carrier frequency value
};
inline void hrtim_time_chper_set_strtpw(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->CHPER = (p->CHPER & ~HRTIM_TIME_CHPER_STRTPW) | ((val << 7) & HRTIM_TIME_CHPER_STRTPW);
}
inline void hrtim_time_chper_set_chpdty(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->CHPER = (p->CHPER & ~HRTIM_TIME_CHPER_CHPDTY) | ((val << 4) & HRTIM_TIME_CHPER_CHPDTY);
}
inline void hrtim_time_chper_set_chpfrq(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->CHPER = (p->CHPER & ~HRTIM_TIME_CHPER_CHPFRQ) | ((val << 0) & HRTIM_TIME_CHPER_CHPFRQ);
}
inline uint32_t hrtim_time_chper_get_strtpw(struct HRTIM_TIME_Type *p) { return (p->CHPER & HRTIM_TIME_CHPER_STRTPW) >> 7; }
inline uint32_t hrtim_time_chper_get_chpdty(struct HRTIM_TIME_Type *p) { return (p->CHPER & HRTIM_TIME_CHPER_CHPDTY) >> 4; }
inline uint32_t hrtim_time_chper_get_chpfrq(struct HRTIM_TIME_Type *p) { return (p->CHPER & HRTIM_TIME_CHPER_CHPFRQ) >> 0; }

// HRTIM_TIME->CPT1ECR Timerx Capture 2 Control Register
enum {
	HRTIM_TIME_CPT1ECR_TFCMP2	 = 1UL << 31,  // TFCMP2
	HRTIM_TIME_CPT1ECR_TFCMP1	 = 1UL << 30,  // TFCMP1
	HRTIM_TIME_CPT1ECR_TF1RST	 = 1UL << 29,  // TF1RST
	HRTIM_TIME_CPT1ECR_TF1SET	 = 1UL << 28,  // TF1SET
	HRTIM_TIME_CPT1ECR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIME_CPT1ECR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIME_CPT1ECR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIME_CPT1ECR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIME_CPT1ECR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIME_CPT1ECR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIME_CPT1ECR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIME_CPT1ECR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIME_CPT1ECR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIME_CPT1ECR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIME_CPT1ECR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIME_CPT1ECR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIME_CPT1ECR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIME_CPT1ECR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIME_CPT1ECR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIME_CPT1ECR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIME_CPT1ECR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIME_CPT1ECR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIME_CPT1ECR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIME_CPT1ECR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIME_CPT1ECR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIME_CPT1ECR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIME_CPT1ECR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIME_CPT1ECR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIME_CPT1ECR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIME_CPT1ECR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIME_CPT1ECR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIME_CPT1ECR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIME->CPT2ECR CPT2xCR
enum {
	HRTIM_TIME_CPT2ECR_TFCMP2	 = 1UL << 31,  // TFCMP2
	HRTIM_TIME_CPT2ECR_TFCMP1	 = 1UL << 30,  // TFCMP1
	HRTIM_TIME_CPT2ECR_TF1RST	 = 1UL << 29,  // TF1RST
	HRTIM_TIME_CPT2ECR_TF1SET	 = 1UL << 28,  // TF1SET
	HRTIM_TIME_CPT2ECR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIME_CPT2ECR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIME_CPT2ECR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIME_CPT2ECR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIME_CPT2ECR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIME_CPT2ECR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIME_CPT2ECR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIME_CPT2ECR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIME_CPT2ECR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIME_CPT2ECR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIME_CPT2ECR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIME_CPT2ECR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIME_CPT2ECR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIME_CPT2ECR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIME_CPT2ECR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIME_CPT2ECR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIME_CPT2ECR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIME_CPT2ECR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIME_CPT2ECR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIME_CPT2ECR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIME_CPT2ECR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIME_CPT2ECR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIME_CPT2ECR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIME_CPT2ECR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIME_CPT2ECR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIME_CPT2ECR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIME_CPT2ECR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIME_CPT2ECR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIME->OUTER Timerx Output Register
enum {
	HRTIM_TIME_OUTER_DIDL2	  = 1UL << 23,				 // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIME_OUTER_CHP2	  = 1UL << 22,				 // Output 2 Chopper enable
	HRTIM_TIME_OUTER_FAULT2	  = ((1UL << 2) - 1) << 20,	 // Output 2 Fault state
	HRTIM_TIME_OUTER_IDLES2	  = 1UL << 19,				 // Output 2 Idle State
	HRTIM_TIME_OUTER_IDLEM2	  = 1UL << 18,				 // Output 2 Idle mode
	HRTIM_TIME_OUTER_POL2	  = 1UL << 17,				 // Output 2 polarity
	HRTIM_TIME_OUTER_BIAR	  = 1UL << 14,				 // Balanced Idle Automatic Resume
	HRTIM_TIME_OUTER_DLYPRT	  = ((1UL << 3) - 1) << 10,	 // Delayed Protection
	HRTIM_TIME_OUTER_DLYPRTEN = 1UL << 9,				 // Delayed Protection Enable
	HRTIM_TIME_OUTER_DTEN	  = 1UL << 8,				 // Deadtime enable
	HRTIM_TIME_OUTER_DIDL1	  = 1UL << 7,				 // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIME_OUTER_CHP1	  = 1UL << 6,				 // Output 1 Chopper enable
	HRTIM_TIME_OUTER_FAULT1	  = ((1UL << 2) - 1) << 4,	 // Output 1 Fault state
	HRTIM_TIME_OUTER_IDLES1	  = 1UL << 3,				 // Output 1 Idle State
	HRTIM_TIME_OUTER_IDLEM1	  = 1UL << 2,				 // Output 1 Idle mode
	HRTIM_TIME_OUTER_POL1	  = 1UL << 1,				 // Output 1 polarity
};
inline void hrtim_time_outer_set_fault2(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->OUTER = (p->OUTER & ~HRTIM_TIME_OUTER_FAULT2) | ((val << 20) & HRTIM_TIME_OUTER_FAULT2);
}
inline void hrtim_time_outer_set_dlyprt(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->OUTER = (p->OUTER & ~HRTIM_TIME_OUTER_DLYPRT) | ((val << 10) & HRTIM_TIME_OUTER_DLYPRT);
}
inline void hrtim_time_outer_set_fault1(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->OUTER = (p->OUTER & ~HRTIM_TIME_OUTER_FAULT1) | ((val << 4) & HRTIM_TIME_OUTER_FAULT1);
}
inline uint32_t hrtim_time_outer_get_fault2(struct HRTIM_TIME_Type *p) { return (p->OUTER & HRTIM_TIME_OUTER_FAULT2) >> 20; }
inline uint32_t hrtim_time_outer_get_dlyprt(struct HRTIM_TIME_Type *p) { return (p->OUTER & HRTIM_TIME_OUTER_DLYPRT) >> 10; }
inline uint32_t hrtim_time_outer_get_fault1(struct HRTIM_TIME_Type *p) { return (p->OUTER & HRTIM_TIME_OUTER_FAULT1) >> 4; }

// HRTIM_TIME->FLTER Timerx Fault Register
enum {
	HRTIM_TIME_FLTER_FLTLCK = 1UL << 31,  // Fault sources Lock
	HRTIM_TIME_FLTER_FLT6EN = 1UL << 5,	  // Fault 6 enable
	HRTIM_TIME_FLTER_FLT5EN = 1UL << 4,	  // Fault 5 enable
	HRTIM_TIME_FLTER_FLT4EN = 1UL << 3,	  // Fault 4 enable
	HRTIM_TIME_FLTER_FLT3EN = 1UL << 2,	  // Fault 3 enable
	HRTIM_TIME_FLTER_FLT2EN = 1UL << 1,	  // Fault 2 enable
	HRTIM_TIME_FLTER_FLT1EN = 1UL << 0,	  // Fault 1 enable
};

// HRTIM_TIME->TIMECR2 HRTIM Timerx Control Register 2
enum {
	HRTIM_TIME_TIMECR2_TRGHLF = 1UL << 20,				 // Triggered-half mode
	HRTIM_TIME_TIMECR2_GTCMP3 = 1UL << 17,				 // Greater than Compare 3 PWM mode
	HRTIM_TIME_TIMECR2_GTCMP1 = 1UL << 16,				 // Greater than Compare 1 PWM mode
	HRTIM_TIME_TIMECR2_FEROM  = ((1UL << 2) - 1) << 14,	 // Fault and Event Roll-Over Mode
	HRTIM_TIME_TIMECR2_BMROM  = ((1UL << 2) - 1) << 12,	 // Burst Mode Roll-Over Mode
	HRTIM_TIME_TIMECR2_ADROM  = ((1UL << 2) - 1) << 10,	 // ADC Roll-Over Mode
	HRTIM_TIME_TIMECR2_OUTROM = ((1UL << 2) - 1) << 8,	 // Output Roll-Over Mode
	HRTIM_TIME_TIMECR2_ROM	  = ((1UL << 2) - 1) << 6,	 // Roll-Over Mode
	HRTIM_TIME_TIMECR2_UDM	  = 1UL << 4,				 // Up-Down Mode
	HRTIM_TIME_TIMECR2_DCDR	  = 1UL << 2,				 // Dual Channel DAC Reset trigger
	HRTIM_TIME_TIMECR2_DCDS	  = 1UL << 1,				 // Dual Channel DAC Step trigger
	HRTIM_TIME_TIMECR2_DCDE	  = 1UL << 0,				 // Dual Channel DAC trigger enable
};
inline void hrtim_time_timecr2_set_ferom(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR2 = (p->TIMECR2 & ~HRTIM_TIME_TIMECR2_FEROM) | ((val << 14) & HRTIM_TIME_TIMECR2_FEROM);
}
inline void hrtim_time_timecr2_set_bmrom(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR2 = (p->TIMECR2 & ~HRTIM_TIME_TIMECR2_BMROM) | ((val << 12) & HRTIM_TIME_TIMECR2_BMROM);
}
inline void hrtim_time_timecr2_set_adrom(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR2 = (p->TIMECR2 & ~HRTIM_TIME_TIMECR2_ADROM) | ((val << 10) & HRTIM_TIME_TIMECR2_ADROM);
}
inline void hrtim_time_timecr2_set_outrom(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR2 = (p->TIMECR2 & ~HRTIM_TIME_TIMECR2_OUTROM) | ((val << 8) & HRTIM_TIME_TIMECR2_OUTROM);
}
inline void hrtim_time_timecr2_set_rom(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->TIMECR2 = (p->TIMECR2 & ~HRTIM_TIME_TIMECR2_ROM) | ((val << 6) & HRTIM_TIME_TIMECR2_ROM);
}
inline uint32_t hrtim_time_timecr2_get_ferom(struct HRTIM_TIME_Type *p) { return (p->TIMECR2 & HRTIM_TIME_TIMECR2_FEROM) >> 14; }
inline uint32_t hrtim_time_timecr2_get_bmrom(struct HRTIM_TIME_Type *p) { return (p->TIMECR2 & HRTIM_TIME_TIMECR2_BMROM) >> 12; }
inline uint32_t hrtim_time_timecr2_get_adrom(struct HRTIM_TIME_Type *p) { return (p->TIMECR2 & HRTIM_TIME_TIMECR2_ADROM) >> 10; }
inline uint32_t hrtim_time_timecr2_get_outrom(struct HRTIM_TIME_Type *p) { return (p->TIMECR2 & HRTIM_TIME_TIMECR2_OUTROM) >> 8; }
inline uint32_t hrtim_time_timecr2_get_rom(struct HRTIM_TIME_Type *p) { return (p->TIMECR2 & HRTIM_TIME_TIMECR2_ROM) >> 6; }

// HRTIM_TIME->EEEFR3 HRTIM Timerx External Event Filtering Register 3
enum {
	HRTIM_TIME_EEEFR3_EEVACNT  = ((1UL << 6) - 1) << 8,	 // External Event A counter
	HRTIM_TIME_EEEFR3_EEVASEL  = ((1UL << 4) - 1) << 4,	 // External Event A Selection
	HRTIM_TIME_EEEFR3_EEVARSTM = 1UL << 2,				 // External Event A Reset Mode
	HRTIM_TIME_EEEFR3_EEVACRES = 1UL << 1,				 // External Event A Counter Reset
	HRTIM_TIME_EEEFR3_EEVACE   = 1UL << 0,				 // External Event A Counter Enable
};
inline void hrtim_time_eeefr3_set_eevacnt(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEEFR3 = (p->EEEFR3 & ~HRTIM_TIME_EEEFR3_EEVACNT) | ((val << 8) & HRTIM_TIME_EEEFR3_EEVACNT);
}
inline void hrtim_time_eeefr3_set_eevasel(struct HRTIM_TIME_Type *p, uint32_t val) {
	p->EEEFR3 = (p->EEEFR3 & ~HRTIM_TIME_EEEFR3_EEVASEL) | ((val << 4) & HRTIM_TIME_EEEFR3_EEVASEL);
}
inline uint32_t hrtim_time_eeefr3_get_eevacnt(struct HRTIM_TIME_Type *p) { return (p->EEEFR3 & HRTIM_TIME_EEEFR3_EEVACNT) >> 8; }
inline uint32_t hrtim_time_eeefr3_get_eevasel(struct HRTIM_TIME_Type *p) { return (p->EEEFR3 & HRTIM_TIME_EEEFR3_EEVASEL) >> 4; }

/* High Resolution Timer: TIMF */
struct HRTIM_TIMF_Type {
	__IO uint32_t TIMFCR;		 // @0 Timerx Control Register
	__I uint32_t  TIMFISR;		 // @4 Timerx Interrupt Status Register
	__O uint16_t  TIMFICR;		 // @8 Timerx Interrupt Clear Register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t TIMFDIER;		 // @12 TIMxDIER
	__IO uint16_t CNTFR;		 // @16 Timerx Counter Register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint16_t PERFR;		 // @20 Timerx Period Register
	uint8_t		  RESERVED2[2];	 // @22
	__IO uint8_t  REPFR;		 // @24 Timerx Repetition Register
	uint8_t		  RESERVED3[3];	 // @25
	__IO uint16_t CMP1FR;		 // @28 Timerx Compare 1 Register
	uint8_t		  RESERVED4[2];	 // @30
	__IO uint32_t CMP1CFR;		 // @32 Timerx Compare 1 Compound Register
	__IO uint16_t CMP2FR;		 // @36 Timerx Compare 2 Register
	uint8_t		  RESERVED5[2];	 // @38
	__IO uint16_t CMP3FR;		 // @40 Timerx Compare 3 Register
	uint8_t		  RESERVED6[2];	 // @42
	__IO uint16_t CMP4FR;		 // @44 Timerx Compare 4 Register
	uint8_t		  RESERVED7[2];	 // @46
	__I uint32_t  CPT1FR;		 // @48 Timerx Capture 1 Register
	__I uint32_t  CPT2FR;		 // @52 Timerx Capture 2 Register
	__IO uint32_t DTFR;			 // @56 Timerx Deadtime Register
	__IO uint32_t SETF1R;		 // @60 Timerx Output1 Set Register
	__IO uint32_t RSTE1R;		 // @64 Timerx Output1 Reset Register
	__IO uint32_t SETF2R;		 // @68 Timerx Output2 Set Register
	__IO uint32_t RSTF2R;		 // @72 Timerx Output2 Reset Register
	__IO uint32_t EEFFR1;		 // @76 Timerx External Event Filtering Register 1
	__IO uint32_t EEFFR2;		 // @80 Timerx External Event Filtering Register 2
	__IO uint32_t RSTFR;		 // @84 TimerA Reset Register
	__IO uint16_t CHPFR;		 // @88 Timerx Chopper Register
	uint8_t		  RESERVED8[2];	 // @90
	__IO uint32_t CPT1FCR;		 // @92 Timerx Capture 2 Control Register
	__IO uint32_t CPT2FCR;		 // @96 CPT2xCR
	__IO uint32_t OUTFR;		 // @100 Timerx Output Register
	__IO uint32_t FLTFR;		 // @104 Timerx Fault Register
	__IO uint32_t TIMFCR2;		 // @108 HRTIM Timerx Control Register 2
	__IO uint16_t FEEFR3;		 // @112 HRTIM Timerx External Event Filtering Register 3
};

// HRTIM_TIMF->TIMFCR Timerx Control Register
enum {
	HRTIM_TIMF_TIMFCR_UPDGAT	= ((1UL << 4) - 1) << 28,  // Update Gating
	HRTIM_TIMF_TIMFCR_PREEN		= 1UL << 27,			   // Preload enable
	HRTIM_TIMF_TIMFCR_DACSYNC	= ((1UL << 2) - 1) << 25,  // AC Synchronization
	HRTIM_TIMF_TIMFCR_MSTU		= 1UL << 24,			   // Master Timer update
	HRTIM_TIMF_TIMFCR_TDU		= 1UL << 22,			   // TDU
	HRTIM_TIMF_TIMFCR_TCU		= 1UL << 21,			   // TCU
	HRTIM_TIMF_TIMFCR_TBU		= 1UL << 20,			   // TBU
	HRTIM_TIMF_TIMFCR_TAU		= 1UL << 19,			   // TAU
	HRTIM_TIMF_TIMFCR_TXRSTU	= 1UL << 18,			   // Timerx reset update
	HRTIM_TIMF_TIMFCR_TXREPU	= 1UL << 17,			   // Timer x Repetition update
	HRTIM_TIMF_TIMFCR_DELCMP4	= ((1UL << 2) - 1) << 14,  // Delayed CMP4 mode
	HRTIM_TIMF_TIMFCR_DELCMP2	= ((1UL << 2) - 1) << 12,  // Delayed CMP2 mode
	HRTIM_TIMF_TIMFCR_SYNCSTRTX = 1UL << 11,			   // Synchronization Starts Timer x
	HRTIM_TIMF_TIMFCR_SYNCRSTX	= 1UL << 10,			   // Synchronization Resets Timer x
	HRTIM_TIMF_TIMFCR_RSYNCU	= 1UL << 9,				   // Re-Synchronized Update
	HRTIM_TIMF_TIMFCR_INTLVD	= ((1UL << 2) - 1) << 7,   // Interleaved mode
	HRTIM_TIMF_TIMFCR_PSHPLL	= 1UL << 6,				   // Push-Pull mode enable
	HRTIM_TIMF_TIMFCR_HALF		= 1UL << 5,				   // Half mode enable
	HRTIM_TIMF_TIMFCR_RETRIG	= 1UL << 4,				   // Re-triggerable mode
	HRTIM_TIMF_TIMFCR_CONT		= 1UL << 3,				   // Continuous mode
	HRTIM_TIMF_TIMFCR_CK_PSCX	= ((1UL << 3) - 1) << 0,   // HRTIM Timer x Clock prescaler
};
inline void hrtim_timf_timfcr_set_updgat(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR = (p->TIMFCR & ~HRTIM_TIMF_TIMFCR_UPDGAT) | ((val << 28) & HRTIM_TIMF_TIMFCR_UPDGAT);
}
inline void hrtim_timf_timfcr_set_dacsync(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR = (p->TIMFCR & ~HRTIM_TIMF_TIMFCR_DACSYNC) | ((val << 25) & HRTIM_TIMF_TIMFCR_DACSYNC);
}
inline void hrtim_timf_timfcr_set_delcmp4(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR = (p->TIMFCR & ~HRTIM_TIMF_TIMFCR_DELCMP4) | ((val << 14) & HRTIM_TIMF_TIMFCR_DELCMP4);
}
inline void hrtim_timf_timfcr_set_delcmp2(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR = (p->TIMFCR & ~HRTIM_TIMF_TIMFCR_DELCMP2) | ((val << 12) & HRTIM_TIMF_TIMFCR_DELCMP2);
}
inline void hrtim_timf_timfcr_set_intlvd(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR = (p->TIMFCR & ~HRTIM_TIMF_TIMFCR_INTLVD) | ((val << 7) & HRTIM_TIMF_TIMFCR_INTLVD);
}
inline void hrtim_timf_timfcr_set_ck_pscx(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR = (p->TIMFCR & ~HRTIM_TIMF_TIMFCR_CK_PSCX) | ((val << 0) & HRTIM_TIMF_TIMFCR_CK_PSCX);
}
inline uint32_t hrtim_timf_timfcr_get_updgat(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR & HRTIM_TIMF_TIMFCR_UPDGAT) >> 28; }
inline uint32_t hrtim_timf_timfcr_get_dacsync(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR & HRTIM_TIMF_TIMFCR_DACSYNC) >> 25; }
inline uint32_t hrtim_timf_timfcr_get_delcmp4(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR & HRTIM_TIMF_TIMFCR_DELCMP4) >> 14; }
inline uint32_t hrtim_timf_timfcr_get_delcmp2(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR & HRTIM_TIMF_TIMFCR_DELCMP2) >> 12; }
inline uint32_t hrtim_timf_timfcr_get_intlvd(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR & HRTIM_TIMF_TIMFCR_INTLVD) >> 7; }
inline uint32_t hrtim_timf_timfcr_get_ck_pscx(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR & HRTIM_TIMF_TIMFCR_CK_PSCX) >> 0; }

// HRTIM_TIMF->TIMFISR Timerx Interrupt Status Register
enum {
	HRTIM_TIMF_TIMFISR_O2CPY   = 1UL << 21,	 // Output 2 Copy
	HRTIM_TIMF_TIMFISR_O1CPY   = 1UL << 20,	 // Output 1 Copy
	HRTIM_TIMF_TIMFISR_O2STAT  = 1UL << 19,	 // Output 2 State
	HRTIM_TIMF_TIMFISR_O1STAT  = 1UL << 18,	 // Output 1 State
	HRTIM_TIMF_TIMFISR_IPPSTAT = 1UL << 17,	 // Idle Push Pull Status
	HRTIM_TIMF_TIMFISR_CPPSTAT = 1UL << 16,	 // Current Push Pull Status
	HRTIM_TIMF_TIMFISR_DLYPRT  = 1UL << 14,	 // Delayed Protection Flag
	HRTIM_TIMF_TIMFISR_RST	   = 1UL << 13,	 // Reset Interrupt Flag
	HRTIM_TIMF_TIMFISR_RSTX2   = 1UL << 12,	 // Output 2 Reset Interrupt Flag
	HRTIM_TIMF_TIMFISR_SETX2   = 1UL << 11,	 // Output 2 Set Interrupt Flag
	HRTIM_TIMF_TIMFISR_RSTX1   = 1UL << 10,	 // Output 1 Reset Interrupt Flag
	HRTIM_TIMF_TIMFISR_SETX1   = 1UL << 9,	 // Output 1 Set Interrupt Flag
	HRTIM_TIMF_TIMFISR_CPT2	   = 1UL << 8,	 // Capture2 Interrupt Flag
	HRTIM_TIMF_TIMFISR_CPT1	   = 1UL << 7,	 // Capture1 Interrupt Flag
	HRTIM_TIMF_TIMFISR_UPD	   = 1UL << 6,	 // Update Interrupt Flag
	HRTIM_TIMF_TIMFISR_REP	   = 1UL << 4,	 // Repetition Interrupt Flag
	HRTIM_TIMF_TIMFISR_CMP4	   = 1UL << 3,	 // Compare 4 Interrupt Flag
	HRTIM_TIMF_TIMFISR_CMP3	   = 1UL << 2,	 // Compare 3 Interrupt Flag
	HRTIM_TIMF_TIMFISR_CMP2	   = 1UL << 1,	 // Compare 2 Interrupt Flag
	HRTIM_TIMF_TIMFISR_CMP1	   = 1UL << 0,	 // Compare 1 Interrupt Flag
};

// HRTIM_TIMF->TIMFICR Timerx Interrupt Clear Register
enum {
	HRTIM_TIMF_TIMFICR_DLYPRTC = 1UL << 14,	 // Delayed Protection Flag Clear
	HRTIM_TIMF_TIMFICR_RSTC	   = 1UL << 13,	 // Reset Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_RSTX2C  = 1UL << 12,	 // Output 2 Reset flag Clear
	HRTIM_TIMF_TIMFICR_SET2XC  = 1UL << 11,	 // Output 2 Set flag Clear
	HRTIM_TIMF_TIMFICR_RSTX1C  = 1UL << 10,	 // Output 1 Reset flag Clear
	HRTIM_TIMF_TIMFICR_SET1XC  = 1UL << 9,	 // Output 1 Set flag Clear
	HRTIM_TIMF_TIMFICR_CPT2C   = 1UL << 8,	 // Capture2 Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_CPT1C   = 1UL << 7,	 // Capture1 Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_UPDC	   = 1UL << 6,	 // Update Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_REPC	   = 1UL << 4,	 // Repetition Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_CMP4C   = 1UL << 3,	 // Compare 4 Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_CMP3C   = 1UL << 2,	 // Compare 3 Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_CMP2C   = 1UL << 1,	 // Compare 2 Interrupt flag Clear
	HRTIM_TIMF_TIMFICR_CMP1C   = 1UL << 0,	 // Compare 1 Interrupt flag Clear
};

// HRTIM_TIMF->TIMFDIER TIMxDIER
enum {
	HRTIM_TIMF_TIMFDIER_DLYPRTDE = 1UL << 30,  // DLYPRTDE
	HRTIM_TIMF_TIMFDIER_RSTDE	 = 1UL << 29,  // RSTDE
	HRTIM_TIMF_TIMFDIER_RSTX2DE	 = 1UL << 28,  // RSTx2DE
	HRTIM_TIMF_TIMFDIER_SETX2DE	 = 1UL << 27,  // SETx2DE
	HRTIM_TIMF_TIMFDIER_RSTX1DE	 = 1UL << 26,  // RSTx1DE
	HRTIM_TIMF_TIMFDIER_SET1XDE	 = 1UL << 25,  // SET1xDE
	HRTIM_TIMF_TIMFDIER_CPT2DE	 = 1UL << 24,  // CPT2DE
	HRTIM_TIMF_TIMFDIER_CPT1DE	 = 1UL << 23,  // CPT1DE
	HRTIM_TIMF_TIMFDIER_UPDDE	 = 1UL << 22,  // UPDDE
	HRTIM_TIMF_TIMFDIER_REPDE	 = 1UL << 20,  // REPDE
	HRTIM_TIMF_TIMFDIER_CMP4DE	 = 1UL << 19,  // CMP4DE
	HRTIM_TIMF_TIMFDIER_CMP3DE	 = 1UL << 18,  // CMP3DE
	HRTIM_TIMF_TIMFDIER_CMP2DE	 = 1UL << 17,  // CMP2DE
	HRTIM_TIMF_TIMFDIER_CMP1DE	 = 1UL << 16,  // CMP1DE
	HRTIM_TIMF_TIMFDIER_DLYPRTIE = 1UL << 14,  // DLYPRTIE
	HRTIM_TIMF_TIMFDIER_RSTIE	 = 1UL << 13,  // RSTIE
	HRTIM_TIMF_TIMFDIER_RSTX2IE	 = 1UL << 12,  // RSTx2IE
	HRTIM_TIMF_TIMFDIER_SETX2IE	 = 1UL << 11,  // SETx2IE
	HRTIM_TIMF_TIMFDIER_RSTX1IE	 = 1UL << 10,  // RSTx1IE
	HRTIM_TIMF_TIMFDIER_SET1XIE	 = 1UL << 9,   // SET1xIE
	HRTIM_TIMF_TIMFDIER_CPT2IE	 = 1UL << 8,   // CPT2IE
	HRTIM_TIMF_TIMFDIER_CPT1IE	 = 1UL << 7,   // CPT1IE
	HRTIM_TIMF_TIMFDIER_UPDIE	 = 1UL << 6,   // UPDIE
	HRTIM_TIMF_TIMFDIER_REPIE	 = 1UL << 4,   // REPIE
	HRTIM_TIMF_TIMFDIER_CMP4IE	 = 1UL << 3,   // CMP4IE
	HRTIM_TIMF_TIMFDIER_CMP3IE	 = 1UL << 2,   // CMP3IE
	HRTIM_TIMF_TIMFDIER_CMP2IE	 = 1UL << 1,   // CMP2IE
	HRTIM_TIMF_TIMFDIER_CMP1IE	 = 1UL << 0,   // CMP1IE
};

// HRTIM_TIMF->CMP1CFR Timerx Compare 1 Compound Register
enum {
	HRTIM_TIMF_CMP1CFR_REPX	 = ((1UL << 8) - 1) << 16,	// Timerx Repetition value (aliased from HRTIM_REPx register)
	HRTIM_TIMF_CMP1CFR_CMP1X = ((1UL << 16) - 1) << 0,	// Timerx Compare 1 value
};
inline void hrtim_timf_cmp1cfr_set_repx(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->CMP1CFR = (p->CMP1CFR & ~HRTIM_TIMF_CMP1CFR_REPX) | ((val << 16) & HRTIM_TIMF_CMP1CFR_REPX);
}
inline void hrtim_timf_cmp1cfr_set_cmp1x(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->CMP1CFR = (p->CMP1CFR & ~HRTIM_TIMF_CMP1CFR_CMP1X) | ((val << 0) & HRTIM_TIMF_CMP1CFR_CMP1X);
}
inline uint32_t hrtim_timf_cmp1cfr_get_repx(struct HRTIM_TIMF_Type *p) { return (p->CMP1CFR & HRTIM_TIMF_CMP1CFR_REPX) >> 16; }
inline uint32_t hrtim_timf_cmp1cfr_get_cmp1x(struct HRTIM_TIMF_Type *p) { return (p->CMP1CFR & HRTIM_TIMF_CMP1CFR_CMP1X) >> 0; }

// HRTIM_TIMF->CPT1FR Timerx Capture 1 Register
enum {
	HRTIM_TIMF_CPT1FR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMF_CPT1FR_CPT1X = ((1UL << 16) - 1) << 0,  // Timerx Capture 1 value
};
inline uint32_t hrtim_timf_cpt1fr_get_cpt1x(struct HRTIM_TIMF_Type *p) { return (p->CPT1FR & HRTIM_TIMF_CPT1FR_CPT1X) >> 0; }

// HRTIM_TIMF->CPT2FR Timerx Capture 2 Register
enum {
	HRTIM_TIMF_CPT2FR_DIR	= 1UL << 16,			   // Timerx Capture 1 Direction status
	HRTIM_TIMF_CPT2FR_CPT2X = ((1UL << 16) - 1) << 0,  // Timerx Capture 2 value
};
inline uint32_t hrtim_timf_cpt2fr_get_cpt2x(struct HRTIM_TIMF_Type *p) { return (p->CPT2FR & HRTIM_TIMF_CPT2FR_CPT2X) >> 0; }

// HRTIM_TIMF->DTFR Timerx Deadtime Register
enum {
	HRTIM_TIMF_DTFR_DTFLKX	= 1UL << 31,			   // Deadtime Falling Lock
	HRTIM_TIMF_DTFR_DTFSLKX = 1UL << 30,			   // Deadtime Falling Sign Lock
	HRTIM_TIMF_DTFR_SDTFX	= 1UL << 25,			   // Sign Deadtime Falling value
	HRTIM_TIMF_DTFR_DTFX	= ((1UL << 9) - 1) << 16,  // Deadtime Falling value
	HRTIM_TIMF_DTFR_DTRLKX	= 1UL << 15,			   // Deadtime Rising Lock
	HRTIM_TIMF_DTFR_DTRSLKX = 1UL << 14,			   // Deadtime Rising Sign Lock
	HRTIM_TIMF_DTFR_DTPRSC	= ((1UL << 3) - 1) << 10,  // Deadtime Prescaler
	HRTIM_TIMF_DTFR_SDTRX	= 1UL << 9,				   // Sign Deadtime Rising value
	HRTIM_TIMF_DTFR_DTRX	= ((1UL << 9) - 1) << 0,   // Deadtime Rising value
};
inline void hrtim_timf_dtfr_set_dtfx(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->DTFR = (p->DTFR & ~HRTIM_TIMF_DTFR_DTFX) | ((val << 16) & HRTIM_TIMF_DTFR_DTFX);
}
inline void hrtim_timf_dtfr_set_dtprsc(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->DTFR = (p->DTFR & ~HRTIM_TIMF_DTFR_DTPRSC) | ((val << 10) & HRTIM_TIMF_DTFR_DTPRSC);
}
inline void hrtim_timf_dtfr_set_dtrx(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->DTFR = (p->DTFR & ~HRTIM_TIMF_DTFR_DTRX) | ((val << 0) & HRTIM_TIMF_DTFR_DTRX);
}
inline uint32_t hrtim_timf_dtfr_get_dtfx(struct HRTIM_TIMF_Type *p) { return (p->DTFR & HRTIM_TIMF_DTFR_DTFX) >> 16; }
inline uint32_t hrtim_timf_dtfr_get_dtprsc(struct HRTIM_TIMF_Type *p) { return (p->DTFR & HRTIM_TIMF_DTFR_DTPRSC) >> 10; }
inline uint32_t hrtim_timf_dtfr_get_dtrx(struct HRTIM_TIMF_Type *p) { return (p->DTFR & HRTIM_TIMF_DTFR_DTRX) >> 0; }

// HRTIM_TIMF->SETF1R Timerx Output1 Set Register
enum {
	HRTIM_TIMF_SETF1R_UPDATE	= 1UL << 31,  // Registers update (transfer preload to active)
	HRTIM_TIMF_SETF1R_EXTEVNT10 = 1UL << 30,  // External Event 10
	HRTIM_TIMF_SETF1R_EXTEVNT9	= 1UL << 29,  // External Event 9
	HRTIM_TIMF_SETF1R_EXTEVNT8	= 1UL << 28,  // External Event 8
	HRTIM_TIMF_SETF1R_EXTEVNT7	= 1UL << 27,  // External Event 7
	HRTIM_TIMF_SETF1R_EXTEVNT6	= 1UL << 26,  // External Event 6
	HRTIM_TIMF_SETF1R_EXTEVNT5	= 1UL << 25,  // External Event 5
	HRTIM_TIMF_SETF1R_EXTEVNT4	= 1UL << 24,  // External Event 4
	HRTIM_TIMF_SETF1R_EXTEVNT3	= 1UL << 23,  // External Event 3
	HRTIM_TIMF_SETF1R_EXTEVNT2	= 1UL << 22,  // External Event 2
	HRTIM_TIMF_SETF1R_EXTEVNT1	= 1UL << 21,  // External Event 1
	HRTIM_TIMF_SETF1R_TIMEVNT9	= 1UL << 20,  // Timer Event 9
	HRTIM_TIMF_SETF1R_TIMEVNT8	= 1UL << 19,  // Timer Event 8
	HRTIM_TIMF_SETF1R_TIMEVNT7	= 1UL << 18,  // Timer Event 7
	HRTIM_TIMF_SETF1R_TIMEVNT6	= 1UL << 17,  // Timer Event 6
	HRTIM_TIMF_SETF1R_TIMEVNT5	= 1UL << 16,  // Timer Event 5
	HRTIM_TIMF_SETF1R_TIMEVNT4	= 1UL << 15,  // Timer Event 4
	HRTIM_TIMF_SETF1R_TIMEVNT3	= 1UL << 14,  // Timer Event 3
	HRTIM_TIMF_SETF1R_TIMEVNT2	= 1UL << 13,  // Timer Event 2
	HRTIM_TIMF_SETF1R_TIMEVNT1	= 1UL << 12,  // Timer Event 1
	HRTIM_TIMF_SETF1R_MSTCMP4	= 1UL << 11,  // Master Compare 4
	HRTIM_TIMF_SETF1R_MSTCMP3	= 1UL << 10,  // Master Compare 3
	HRTIM_TIMF_SETF1R_MSTCMP2	= 1UL << 9,	  // Master Compare 2
	HRTIM_TIMF_SETF1R_MSTCMP1	= 1UL << 8,	  // Master Compare 1
	HRTIM_TIMF_SETF1R_MSTPER	= 1UL << 7,	  // Master Period
	HRTIM_TIMF_SETF1R_CMP4		= 1UL << 6,	  // Timer A compare 4
	HRTIM_TIMF_SETF1R_CMP3		= 1UL << 5,	  // Timer A compare 3
	HRTIM_TIMF_SETF1R_CMP2		= 1UL << 4,	  // Timer A compare 2
	HRTIM_TIMF_SETF1R_CMP1		= 1UL << 3,	  // Timer A compare 1
	HRTIM_TIMF_SETF1R_PER		= 1UL << 2,	  // Timer A Period
	HRTIM_TIMF_SETF1R_RESYNC	= 1UL << 1,	  // Timer A resynchronizaton
	HRTIM_TIMF_SETF1R_SST		= 1UL << 0,	  // Software Set trigger
};

// HRTIM_TIMF->RSTE1R Timerx Output1 Reset Register
enum {
	HRTIM_TIMF_RSTE1R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMF_RSTE1R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMF_RSTE1R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMF_RSTE1R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMF_RSTE1R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMF_RSTE1R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMF_RSTE1R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMF_RSTE1R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMF_RSTE1R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMF_RSTE1R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMF_RSTE1R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMF_RSTE1R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMF_RSTE1R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMF_RSTE1R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMF_RSTE1R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMF_RSTE1R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMF_RSTE1R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMF_RSTE1R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMF_RSTE1R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMF_RSTE1R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMF_RSTE1R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMF_RSTE1R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMF_RSTE1R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMF_RSTE1R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMF_RSTE1R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMF_RSTE1R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMF_RSTE1R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMF_RSTE1R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMF_RSTE1R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMF_RSTE1R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMF_RSTE1R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMF_RSTE1R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMF->SETF2R Timerx Output2 Set Register
enum {
	HRTIM_TIMF_SETF2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMF_SETF2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMF_SETF2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMF_SETF2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMF_SETF2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMF_SETF2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMF_SETF2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMF_SETF2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMF_SETF2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMF_SETF2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMF_SETF2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMF_SETF2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMF_SETF2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMF_SETF2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMF_SETF2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMF_SETF2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMF_SETF2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMF_SETF2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMF_SETF2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMF_SETF2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMF_SETF2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMF_SETF2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMF_SETF2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMF_SETF2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMF_SETF2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMF_SETF2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMF_SETF2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMF_SETF2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMF_SETF2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMF_SETF2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMF_SETF2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMF_SETF2R_SST		= 1UL << 0,	  // SST
};

// HRTIM_TIMF->RSTF2R Timerx Output2 Reset Register
enum {
	HRTIM_TIMF_RSTF2R_UPDATE	= 1UL << 31,  // UPDATE
	HRTIM_TIMF_RSTF2R_EXTEVNT10 = 1UL << 30,  // EXTEVNT10
	HRTIM_TIMF_RSTF2R_EXTEVNT9	= 1UL << 29,  // EXTEVNT9
	HRTIM_TIMF_RSTF2R_EXTEVNT8	= 1UL << 28,  // EXTEVNT8
	HRTIM_TIMF_RSTF2R_EXTEVNT7	= 1UL << 27,  // EXTEVNT7
	HRTIM_TIMF_RSTF2R_EXTEVNT6	= 1UL << 26,  // EXTEVNT6
	HRTIM_TIMF_RSTF2R_EXTEVNT5	= 1UL << 25,  // EXTEVNT5
	HRTIM_TIMF_RSTF2R_EXTEVNT4	= 1UL << 24,  // EXTEVNT4
	HRTIM_TIMF_RSTF2R_EXTEVNT3	= 1UL << 23,  // EXTEVNT3
	HRTIM_TIMF_RSTF2R_EXTEVNT2	= 1UL << 22,  // EXTEVNT2
	HRTIM_TIMF_RSTF2R_EXTEVNT1	= 1UL << 21,  // EXTEVNT1
	HRTIM_TIMF_RSTF2R_TIMEVNT9	= 1UL << 20,  // TIMEVNT9
	HRTIM_TIMF_RSTF2R_TIMEVNT8	= 1UL << 19,  // TIMEVNT8
	HRTIM_TIMF_RSTF2R_TIMEVNT7	= 1UL << 18,  // TIMEVNT7
	HRTIM_TIMF_RSTF2R_TIMEVNT6	= 1UL << 17,  // TIMEVNT6
	HRTIM_TIMF_RSTF2R_TIMEVNT5	= 1UL << 16,  // TIMEVNT5
	HRTIM_TIMF_RSTF2R_TIMEVNT4	= 1UL << 15,  // TIMEVNT4
	HRTIM_TIMF_RSTF2R_TIMEVNT3	= 1UL << 14,  // TIMEVNT3
	HRTIM_TIMF_RSTF2R_TIMEVNT2	= 1UL << 13,  // TIMEVNT2
	HRTIM_TIMF_RSTF2R_TIMEVNT1	= 1UL << 12,  // TIMEVNT1
	HRTIM_TIMF_RSTF2R_MSTCMP4	= 1UL << 11,  // MSTCMP4
	HRTIM_TIMF_RSTF2R_MSTCMP3	= 1UL << 10,  // MSTCMP3
	HRTIM_TIMF_RSTF2R_MSTCMP2	= 1UL << 9,	  // MSTCMP2
	HRTIM_TIMF_RSTF2R_MSTCMP1	= 1UL << 8,	  // MSTCMP1
	HRTIM_TIMF_RSTF2R_MSTPER	= 1UL << 7,	  // MSTPER
	HRTIM_TIMF_RSTF2R_CMP4		= 1UL << 6,	  // CMP4
	HRTIM_TIMF_RSTF2R_CMP3		= 1UL << 5,	  // CMP3
	HRTIM_TIMF_RSTF2R_CMP2		= 1UL << 4,	  // CMP2
	HRTIM_TIMF_RSTF2R_CMP1		= 1UL << 3,	  // CMP1
	HRTIM_TIMF_RSTF2R_PER		= 1UL << 2,	  // PER
	HRTIM_TIMF_RSTF2R_RESYNC	= 1UL << 1,	  // RESYNC
	HRTIM_TIMF_RSTF2R_SRT		= 1UL << 0,	  // SRT
};

// HRTIM_TIMF->EEFFR1 Timerx External Event Filtering Register 1
enum {
	HRTIM_TIMF_EEFFR1_EE5FLTR = ((1UL << 4) - 1) << 25,	 // External Event 5 filter
	HRTIM_TIMF_EEFFR1_EE5LTCH = 1UL << 24,				 // External Event 5 latch
	HRTIM_TIMF_EEFFR1_EE4FLTR = ((1UL << 4) - 1) << 19,	 // External Event 4 filter
	HRTIM_TIMF_EEFFR1_EE4LTCH = 1UL << 18,				 // External Event 4 latch
	HRTIM_TIMF_EEFFR1_EE3FLTR = ((1UL << 4) - 1) << 13,	 // External Event 3 filter
	HRTIM_TIMF_EEFFR1_EE3LTCH = 1UL << 12,				 // External Event 3 latch
	HRTIM_TIMF_EEFFR1_EE2FLTR = ((1UL << 4) - 1) << 7,	 // External Event 2 filter
	HRTIM_TIMF_EEFFR1_EE2LTCH = 1UL << 6,				 // External Event 2 latch
	HRTIM_TIMF_EEFFR1_EE1FLTR = ((1UL << 4) - 1) << 1,	 // External Event 1 filter
	HRTIM_TIMF_EEFFR1_EE1LTCH = 1UL << 0,				 // External Event 1 latch
};
inline void hrtim_timf_eeffr1_set_ee5fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR1 = (p->EEFFR1 & ~HRTIM_TIMF_EEFFR1_EE5FLTR) | ((val << 25) & HRTIM_TIMF_EEFFR1_EE5FLTR);
}
inline void hrtim_timf_eeffr1_set_ee4fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR1 = (p->EEFFR1 & ~HRTIM_TIMF_EEFFR1_EE4FLTR) | ((val << 19) & HRTIM_TIMF_EEFFR1_EE4FLTR);
}
inline void hrtim_timf_eeffr1_set_ee3fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR1 = (p->EEFFR1 & ~HRTIM_TIMF_EEFFR1_EE3FLTR) | ((val << 13) & HRTIM_TIMF_EEFFR1_EE3FLTR);
}
inline void hrtim_timf_eeffr1_set_ee2fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR1 = (p->EEFFR1 & ~HRTIM_TIMF_EEFFR1_EE2FLTR) | ((val << 7) & HRTIM_TIMF_EEFFR1_EE2FLTR);
}
inline void hrtim_timf_eeffr1_set_ee1fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR1 = (p->EEFFR1 & ~HRTIM_TIMF_EEFFR1_EE1FLTR) | ((val << 1) & HRTIM_TIMF_EEFFR1_EE1FLTR);
}
inline uint32_t hrtim_timf_eeffr1_get_ee5fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR1 & HRTIM_TIMF_EEFFR1_EE5FLTR) >> 25; }
inline uint32_t hrtim_timf_eeffr1_get_ee4fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR1 & HRTIM_TIMF_EEFFR1_EE4FLTR) >> 19; }
inline uint32_t hrtim_timf_eeffr1_get_ee3fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR1 & HRTIM_TIMF_EEFFR1_EE3FLTR) >> 13; }
inline uint32_t hrtim_timf_eeffr1_get_ee2fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR1 & HRTIM_TIMF_EEFFR1_EE2FLTR) >> 7; }
inline uint32_t hrtim_timf_eeffr1_get_ee1fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR1 & HRTIM_TIMF_EEFFR1_EE1FLTR) >> 1; }

// HRTIM_TIMF->EEFFR2 Timerx External Event Filtering Register 2
enum {
	HRTIM_TIMF_EEFFR2_EE10FLTR = ((1UL << 4) - 1) << 25,  // External Event 10 filter
	HRTIM_TIMF_EEFFR2_EE10LTCH = 1UL << 24,				  // External Event 10 latch
	HRTIM_TIMF_EEFFR2_EE9FLTR  = ((1UL << 4) - 1) << 19,  // External Event 9 filter
	HRTIM_TIMF_EEFFR2_EE9LTCH  = 1UL << 18,				  // External Event 9 latch
	HRTIM_TIMF_EEFFR2_EE8FLTR  = ((1UL << 4) - 1) << 13,  // External Event 8 filter
	HRTIM_TIMF_EEFFR2_EE8LTCH  = 1UL << 12,				  // External Event 8 latch
	HRTIM_TIMF_EEFFR2_EE7FLTR  = ((1UL << 4) - 1) << 7,	  // External Event 7 filter
	HRTIM_TIMF_EEFFR2_EE7LTCH  = 1UL << 6,				  // External Event 7 latch
	HRTIM_TIMF_EEFFR2_EE6FLTR  = ((1UL << 4) - 1) << 1,	  // External Event 6 filter
	HRTIM_TIMF_EEFFR2_EE6LTCH  = 1UL << 0,				  // External Event 6 latch
};
inline void hrtim_timf_eeffr2_set_ee10fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR2 = (p->EEFFR2 & ~HRTIM_TIMF_EEFFR2_EE10FLTR) | ((val << 25) & HRTIM_TIMF_EEFFR2_EE10FLTR);
}
inline void hrtim_timf_eeffr2_set_ee9fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR2 = (p->EEFFR2 & ~HRTIM_TIMF_EEFFR2_EE9FLTR) | ((val << 19) & HRTIM_TIMF_EEFFR2_EE9FLTR);
}
inline void hrtim_timf_eeffr2_set_ee8fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR2 = (p->EEFFR2 & ~HRTIM_TIMF_EEFFR2_EE8FLTR) | ((val << 13) & HRTIM_TIMF_EEFFR2_EE8FLTR);
}
inline void hrtim_timf_eeffr2_set_ee7fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR2 = (p->EEFFR2 & ~HRTIM_TIMF_EEFFR2_EE7FLTR) | ((val << 7) & HRTIM_TIMF_EEFFR2_EE7FLTR);
}
inline void hrtim_timf_eeffr2_set_ee6fltr(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->EEFFR2 = (p->EEFFR2 & ~HRTIM_TIMF_EEFFR2_EE6FLTR) | ((val << 1) & HRTIM_TIMF_EEFFR2_EE6FLTR);
}
inline uint32_t hrtim_timf_eeffr2_get_ee10fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR2 & HRTIM_TIMF_EEFFR2_EE10FLTR) >> 25; }
inline uint32_t hrtim_timf_eeffr2_get_ee9fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR2 & HRTIM_TIMF_EEFFR2_EE9FLTR) >> 19; }
inline uint32_t hrtim_timf_eeffr2_get_ee8fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR2 & HRTIM_TIMF_EEFFR2_EE8FLTR) >> 13; }
inline uint32_t hrtim_timf_eeffr2_get_ee7fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR2 & HRTIM_TIMF_EEFFR2_EE7FLTR) >> 7; }
inline uint32_t hrtim_timf_eeffr2_get_ee6fltr(struct HRTIM_TIMF_Type *p) { return (p->EEFFR2 & HRTIM_TIMF_EEFFR2_EE6FLTR) >> 1; }

// HRTIM_TIMF->RSTFR TimerA Reset Register
enum {
	HRTIM_TIMF_RSTFR_TIMFCPM2  = 1UL << 31,	 // Timer F Compare 2
	HRTIM_TIMF_RSTFR_TIMDCMP4  = 1UL << 30,	 // Timer D Compare 4
	HRTIM_TIMF_RSTFR_TIMDCMP2  = 1UL << 29,	 // Timer D Compare 2
	HRTIM_TIMF_RSTFR_TIMDCMP1  = 1UL << 28,	 // Timer D Compare 1
	HRTIM_TIMF_RSTFR_TIMCCMP4  = 1UL << 27,	 // Timer C Compare 4
	HRTIM_TIMF_RSTFR_TIMCCMP2  = 1UL << 26,	 // Timer C Compare 2
	HRTIM_TIMF_RSTFR_TIMCCMP1  = 1UL << 25,	 // Timer C Compare 1
	HRTIM_TIMF_RSTFR_TIMBCMP4  = 1UL << 24,	 // Timer B Compare 4
	HRTIM_TIMF_RSTFR_TIMBCMP2  = 1UL << 23,	 // Timer B Compare 2
	HRTIM_TIMF_RSTFR_TIMBCMP1  = 1UL << 22,	 // Timer B Compare 1
	HRTIM_TIMF_RSTFR_TIMACMP4  = 1UL << 21,	 // Timer A Compare 4
	HRTIM_TIMF_RSTFR_TIMACMP2  = 1UL << 20,	 // Timer A Compare 2
	HRTIM_TIMF_RSTFR_TIMACMP1  = 1UL << 19,	 // Timer A Compare 1
	HRTIM_TIMF_RSTFR_EXTEVNT10 = 1UL << 18,	 // External Event 10
	HRTIM_TIMF_RSTFR_EXTEVNT9  = 1UL << 17,	 // External Event 9
	HRTIM_TIMF_RSTFR_EXTEVNT8  = 1UL << 16,	 // External Event 8
	HRTIM_TIMF_RSTFR_EXTEVNT7  = 1UL << 15,	 // External Event 7
	HRTIM_TIMF_RSTFR_EXTEVNT6  = 1UL << 14,	 // External Event 6
	HRTIM_TIMF_RSTFR_EXTEVNT5  = 1UL << 13,	 // External Event 5
	HRTIM_TIMF_RSTFR_EXTEVNT4  = 1UL << 12,	 // External Event 4
	HRTIM_TIMF_RSTFR_EXTEVNT3  = 1UL << 11,	 // External Event 3
	HRTIM_TIMF_RSTFR_EXTEVNT2  = 1UL << 10,	 // External Event 2
	HRTIM_TIMF_RSTFR_EXTEVNT1  = 1UL << 9,	 // External Event 1
	HRTIM_TIMF_RSTFR_MSTCMP4   = 1UL << 8,	 // Master compare 4
	HRTIM_TIMF_RSTFR_MSTCMP3   = 1UL << 7,	 // Master compare 3
	HRTIM_TIMF_RSTFR_MSTCMP2   = 1UL << 6,	 // Master compare 2
	HRTIM_TIMF_RSTFR_MSTCMP1   = 1UL << 5,	 // Master compare 1
	HRTIM_TIMF_RSTFR_MSTPER	   = 1UL << 4,	 // Master timer Period
	HRTIM_TIMF_RSTFR_CMP4	   = 1UL << 3,	 // Timer A compare 4 reset
	HRTIM_TIMF_RSTFR_CMP2	   = 1UL << 2,	 // Timer A compare 2 reset
	HRTIM_TIMF_RSTFR_UPDT	   = 1UL << 1,	 // Timer A Update reset
	HRTIM_TIMF_RSTFR_TIMFCMP1  = 1UL << 0,	 // Timer A Update reset
};

// HRTIM_TIMF->CHPFR Timerx Chopper Register
enum {
	HRTIM_TIMF_CHPFR_STRTPW = ((1UL << 4) - 1) << 7,  // STRTPW
	HRTIM_TIMF_CHPFR_CHPDTY = ((1UL << 3) - 1) << 4,  // Timerx chopper duty cycle value
	HRTIM_TIMF_CHPFR_CHPFRQ = ((1UL << 4) - 1) << 0,  // Timerx carrier frequency value
};
inline void hrtim_timf_chpfr_set_strtpw(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->CHPFR = (p->CHPFR & ~HRTIM_TIMF_CHPFR_STRTPW) | ((val << 7) & HRTIM_TIMF_CHPFR_STRTPW);
}
inline void hrtim_timf_chpfr_set_chpdty(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->CHPFR = (p->CHPFR & ~HRTIM_TIMF_CHPFR_CHPDTY) | ((val << 4) & HRTIM_TIMF_CHPFR_CHPDTY);
}
inline void hrtim_timf_chpfr_set_chpfrq(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->CHPFR = (p->CHPFR & ~HRTIM_TIMF_CHPFR_CHPFRQ) | ((val << 0) & HRTIM_TIMF_CHPFR_CHPFRQ);
}
inline uint32_t hrtim_timf_chpfr_get_strtpw(struct HRTIM_TIMF_Type *p) { return (p->CHPFR & HRTIM_TIMF_CHPFR_STRTPW) >> 7; }
inline uint32_t hrtim_timf_chpfr_get_chpdty(struct HRTIM_TIMF_Type *p) { return (p->CHPFR & HRTIM_TIMF_CHPFR_CHPDTY) >> 4; }
inline uint32_t hrtim_timf_chpfr_get_chpfrq(struct HRTIM_TIMF_Type *p) { return (p->CHPFR & HRTIM_TIMF_CHPFR_CHPFRQ) >> 0; }

// HRTIM_TIMF->CPT1FCR Timerx Capture 2 Control Register
enum {
	HRTIM_TIMF_CPT1FCR_TECMP2	 = 1UL << 31,  // TECMP2
	HRTIM_TIMF_CPT1FCR_TECMP1	 = 1UL << 30,  // TECMP1
	HRTIM_TIMF_CPT1FCR_TE1RST	 = 1UL << 29,  // TE1RST
	HRTIM_TIMF_CPT1FCR_TE1SET	 = 1UL << 28,  // TE1SET
	HRTIM_TIMF_CPT1FCR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMF_CPT1FCR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMF_CPT1FCR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMF_CPT1FCR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMF_CPT1FCR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMF_CPT1FCR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMF_CPT1FCR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMF_CPT1FCR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMF_CPT1FCR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMF_CPT1FCR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMF_CPT1FCR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMF_CPT1FCR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMF_CPT1FCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMF_CPT1FCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMF_CPT1FCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMF_CPT1FCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMF_CPT1FCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMF_CPT1FCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMF_CPT1FCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMF_CPT1FCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMF_CPT1FCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMF_CPT1FCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMF_CPT1FCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMF_CPT1FCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMF_CPT1FCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMF_CPT1FCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMF_CPT1FCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMF_CPT1FCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMF->CPT2FCR CPT2xCR
enum {
	HRTIM_TIMF_CPT2FCR_TECMP2	 = 1UL << 31,  // TECMP2
	HRTIM_TIMF_CPT2FCR_TECMP1	 = 1UL << 30,  // TECMP1
	HRTIM_TIMF_CPT2FCR_TE1RST	 = 1UL << 29,  // TE1RST
	HRTIM_TIMF_CPT2FCR_TE1SET	 = 1UL << 28,  // TE1SET
	HRTIM_TIMF_CPT2FCR_TDCMP2	 = 1UL << 27,  // Timer D Compare 2
	HRTIM_TIMF_CPT2FCR_TDCMP1	 = 1UL << 26,  // Timer D Compare 1
	HRTIM_TIMF_CPT2FCR_TD1RST	 = 1UL << 25,  // Timer D output 1 Reset
	HRTIM_TIMF_CPT2FCR_TD1SET	 = 1UL << 24,  // Timer D output 1 Set
	HRTIM_TIMF_CPT2FCR_TCCMP2	 = 1UL << 23,  // Timer C Compare 2
	HRTIM_TIMF_CPT2FCR_TCCMP1	 = 1UL << 22,  // Timer C Compare 1
	HRTIM_TIMF_CPT2FCR_TC1RST	 = 1UL << 21,  // Timer C output 1 Reset
	HRTIM_TIMF_CPT2FCR_TC1SET	 = 1UL << 20,  // Timer C output 1 Set
	HRTIM_TIMF_CPT2FCR_TBCMP2	 = 1UL << 19,  // Timer B Compare 2
	HRTIM_TIMF_CPT2FCR_TBCMP1	 = 1UL << 18,  // Timer B Compare 1
	HRTIM_TIMF_CPT2FCR_TB1RST	 = 1UL << 17,  // Timer B output 1 Reset
	HRTIM_TIMF_CPT2FCR_TB1SET	 = 1UL << 16,  // Timer B output 1 Set
	HRTIM_TIMF_CPT2FCR_TACMP2	 = 1UL << 15,  // Timer A Compare 2
	HRTIM_TIMF_CPT2FCR_TACMP1	 = 1UL << 14,  // Timer A Compare 1
	HRTIM_TIMF_CPT2FCR_TA1RST	 = 1UL << 13,  // Timer A output 1 Reset
	HRTIM_TIMF_CPT2FCR_TA1SET	 = 1UL << 12,  // Timer A output 1 Set
	HRTIM_TIMF_CPT2FCR_EXEV10CPT = 1UL << 11,  // External Event 10 Capture
	HRTIM_TIMF_CPT2FCR_EXEV9CPT	 = 1UL << 10,  // External Event 9 Capture
	HRTIM_TIMF_CPT2FCR_EXEV8CPT	 = 1UL << 9,   // External Event 8 Capture
	HRTIM_TIMF_CPT2FCR_EXEV7CPT	 = 1UL << 8,   // External Event 7 Capture
	HRTIM_TIMF_CPT2FCR_EXEV6CPT	 = 1UL << 7,   // External Event 6 Capture
	HRTIM_TIMF_CPT2FCR_EXEV5CPT	 = 1UL << 6,   // External Event 5 Capture
	HRTIM_TIMF_CPT2FCR_EXEV4CPT	 = 1UL << 5,   // External Event 4 Capture
	HRTIM_TIMF_CPT2FCR_EXEV3CPT	 = 1UL << 4,   // External Event 3 Capture
	HRTIM_TIMF_CPT2FCR_EXEV2CPT	 = 1UL << 3,   // External Event 2 Capture
	HRTIM_TIMF_CPT2FCR_EXEV1CPT	 = 1UL << 2,   // External Event 1 Capture
	HRTIM_TIMF_CPT2FCR_UDPCPT	 = 1UL << 1,   // Update Capture
	HRTIM_TIMF_CPT2FCR_SWCPT	 = 1UL << 0,   // Software Capture
};

// HRTIM_TIMF->OUTFR Timerx Output Register
enum {
	HRTIM_TIMF_OUTFR_DIDL2	  = 1UL << 23,				 // Output 2 Deadtime upon burst mode Idle entry
	HRTIM_TIMF_OUTFR_CHP2	  = 1UL << 22,				 // Output 2 Chopper enable
	HRTIM_TIMF_OUTFR_FAULT2	  = ((1UL << 2) - 1) << 20,	 // Output 2 Fault state
	HRTIM_TIMF_OUTFR_IDLES2	  = 1UL << 19,				 // Output 2 Idle State
	HRTIM_TIMF_OUTFR_IDLEM2	  = 1UL << 18,				 // Output 2 Idle mode
	HRTIM_TIMF_OUTFR_POL2	  = 1UL << 17,				 // Output 2 polarity
	HRTIM_TIMF_OUTFR_BIAR	  = 1UL << 14,				 // Balanced Idle Automatic Resume
	HRTIM_TIMF_OUTFR_DLYPRT	  = ((1UL << 3) - 1) << 10,	 // Delayed Protection
	HRTIM_TIMF_OUTFR_DLYPRTEN = 1UL << 9,				 // Delayed Protection Enable
	HRTIM_TIMF_OUTFR_DTEN	  = 1UL << 8,				 // Deadtime enable
	HRTIM_TIMF_OUTFR_DIDL1	  = 1UL << 7,				 // Output 1 Deadtime upon burst mode Idle entry
	HRTIM_TIMF_OUTFR_CHP1	  = 1UL << 6,				 // Output 1 Chopper enable
	HRTIM_TIMF_OUTFR_FAULT1	  = ((1UL << 2) - 1) << 4,	 // Output 1 Fault state
	HRTIM_TIMF_OUTFR_IDLES1	  = 1UL << 3,				 // Output 1 Idle State
	HRTIM_TIMF_OUTFR_IDLEM1	  = 1UL << 2,				 // Output 1 Idle mode
	HRTIM_TIMF_OUTFR_POL1	  = 1UL << 1,				 // Output 1 polarity
};
inline void hrtim_timf_outfr_set_fault2(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->OUTFR = (p->OUTFR & ~HRTIM_TIMF_OUTFR_FAULT2) | ((val << 20) & HRTIM_TIMF_OUTFR_FAULT2);
}
inline void hrtim_timf_outfr_set_dlyprt(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->OUTFR = (p->OUTFR & ~HRTIM_TIMF_OUTFR_DLYPRT) | ((val << 10) & HRTIM_TIMF_OUTFR_DLYPRT);
}
inline void hrtim_timf_outfr_set_fault1(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->OUTFR = (p->OUTFR & ~HRTIM_TIMF_OUTFR_FAULT1) | ((val << 4) & HRTIM_TIMF_OUTFR_FAULT1);
}
inline uint32_t hrtim_timf_outfr_get_fault2(struct HRTIM_TIMF_Type *p) { return (p->OUTFR & HRTIM_TIMF_OUTFR_FAULT2) >> 20; }
inline uint32_t hrtim_timf_outfr_get_dlyprt(struct HRTIM_TIMF_Type *p) { return (p->OUTFR & HRTIM_TIMF_OUTFR_DLYPRT) >> 10; }
inline uint32_t hrtim_timf_outfr_get_fault1(struct HRTIM_TIMF_Type *p) { return (p->OUTFR & HRTIM_TIMF_OUTFR_FAULT1) >> 4; }

// HRTIM_TIMF->FLTFR Timerx Fault Register
enum {
	HRTIM_TIMF_FLTFR_FLTLCK = 1UL << 31,  // Fault sources Lock
	HRTIM_TIMF_FLTFR_FLT6EN = 1UL << 5,	  // Fault 6 enable
	HRTIM_TIMF_FLTFR_FLT5EN = 1UL << 4,	  // Fault 5 enable
	HRTIM_TIMF_FLTFR_FLT4EN = 1UL << 3,	  // Fault 4 enable
	HRTIM_TIMF_FLTFR_FLT3EN = 1UL << 2,	  // Fault 3 enable
	HRTIM_TIMF_FLTFR_FLT2EN = 1UL << 1,	  // Fault 2 enable
	HRTIM_TIMF_FLTFR_FLT1EN = 1UL << 0,	  // Fault 1 enable
};

// HRTIM_TIMF->TIMFCR2 HRTIM Timerx Control Register 2
enum {
	HRTIM_TIMF_TIMFCR2_TRGHLF = 1UL << 20,				 // Triggered-half mode
	HRTIM_TIMF_TIMFCR2_GTCMP3 = 1UL << 17,				 // Greater than Compare 3 PWM mode
	HRTIM_TIMF_TIMFCR2_GTCMP1 = 1UL << 16,				 // Greater than Compare 1 PWM mode
	HRTIM_TIMF_TIMFCR2_FEROM  = ((1UL << 2) - 1) << 14,	 // Fault and Event Roll-Over Mode
	HRTIM_TIMF_TIMFCR2_BMROM  = ((1UL << 2) - 1) << 12,	 // Burst Mode Roll-Over Mode
	HRTIM_TIMF_TIMFCR2_ADROM  = ((1UL << 2) - 1) << 10,	 // ADC Roll-Over Mode
	HRTIM_TIMF_TIMFCR2_OUTROM = ((1UL << 2) - 1) << 8,	 // Output Roll-Over Mode
	HRTIM_TIMF_TIMFCR2_ROM	  = ((1UL << 2) - 1) << 6,	 // Roll-Over Mode
	HRTIM_TIMF_TIMFCR2_UDM	  = 1UL << 4,				 // Up-Down Mode
	HRTIM_TIMF_TIMFCR2_DCDR	  = 1UL << 2,				 // Dual Channel DAC Reset trigger
	HRTIM_TIMF_TIMFCR2_DCDS	  = 1UL << 1,				 // Dual Channel DAC Step trigger
	HRTIM_TIMF_TIMFCR2_DCDE	  = 1UL << 0,				 // Dual Channel DAC trigger enable
};
inline void hrtim_timf_timfcr2_set_ferom(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR2 = (p->TIMFCR2 & ~HRTIM_TIMF_TIMFCR2_FEROM) | ((val << 14) & HRTIM_TIMF_TIMFCR2_FEROM);
}
inline void hrtim_timf_timfcr2_set_bmrom(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR2 = (p->TIMFCR2 & ~HRTIM_TIMF_TIMFCR2_BMROM) | ((val << 12) & HRTIM_TIMF_TIMFCR2_BMROM);
}
inline void hrtim_timf_timfcr2_set_adrom(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR2 = (p->TIMFCR2 & ~HRTIM_TIMF_TIMFCR2_ADROM) | ((val << 10) & HRTIM_TIMF_TIMFCR2_ADROM);
}
inline void hrtim_timf_timfcr2_set_outrom(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR2 = (p->TIMFCR2 & ~HRTIM_TIMF_TIMFCR2_OUTROM) | ((val << 8) & HRTIM_TIMF_TIMFCR2_OUTROM);
}
inline void hrtim_timf_timfcr2_set_rom(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->TIMFCR2 = (p->TIMFCR2 & ~HRTIM_TIMF_TIMFCR2_ROM) | ((val << 6) & HRTIM_TIMF_TIMFCR2_ROM);
}
inline uint32_t hrtim_timf_timfcr2_get_ferom(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR2 & HRTIM_TIMF_TIMFCR2_FEROM) >> 14; }
inline uint32_t hrtim_timf_timfcr2_get_bmrom(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR2 & HRTIM_TIMF_TIMFCR2_BMROM) >> 12; }
inline uint32_t hrtim_timf_timfcr2_get_adrom(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR2 & HRTIM_TIMF_TIMFCR2_ADROM) >> 10; }
inline uint32_t hrtim_timf_timfcr2_get_outrom(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR2 & HRTIM_TIMF_TIMFCR2_OUTROM) >> 8; }
inline uint32_t hrtim_timf_timfcr2_get_rom(struct HRTIM_TIMF_Type *p) { return (p->TIMFCR2 & HRTIM_TIMF_TIMFCR2_ROM) >> 6; }

// HRTIM_TIMF->FEEFR3 HRTIM Timerx External Event Filtering Register 3
enum {
	HRTIM_TIMF_FEEFR3_EEVACNT  = ((1UL << 6) - 1) << 8,	 // External Event A counter
	HRTIM_TIMF_FEEFR3_EEVASEL  = ((1UL << 4) - 1) << 4,	 // External Event A Selection
	HRTIM_TIMF_FEEFR3_EEVARSTM = 1UL << 2,				 // External Event A Reset Mode
	HRTIM_TIMF_FEEFR3_EEVACRES = 1UL << 1,				 // External Event A Counter Reset
	HRTIM_TIMF_FEEFR3_EEVACE   = 1UL << 0,				 // External Event A Counter Enable
};
inline void hrtim_timf_feefr3_set_eevacnt(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->FEEFR3 = (p->FEEFR3 & ~HRTIM_TIMF_FEEFR3_EEVACNT) | ((val << 8) & HRTIM_TIMF_FEEFR3_EEVACNT);
}
inline void hrtim_timf_feefr3_set_eevasel(struct HRTIM_TIMF_Type *p, uint32_t val) {
	p->FEEFR3 = (p->FEEFR3 & ~HRTIM_TIMF_FEEFR3_EEVASEL) | ((val << 4) & HRTIM_TIMF_FEEFR3_EEVASEL);
}
inline uint32_t hrtim_timf_feefr3_get_eevacnt(struct HRTIM_TIMF_Type *p) { return (p->FEEFR3 & HRTIM_TIMF_FEEFR3_EEVACNT) >> 8; }
inline uint32_t hrtim_timf_feefr3_get_eevasel(struct HRTIM_TIMF_Type *p) { return (p->FEEFR3 & HRTIM_TIMF_FEEFR3_EEVASEL) >> 4; }

/* Inter-integrated circuit */
struct I2C1_Type {
	__IO uint32_t CR1;			 // @0 Control register 1
	__IO uint32_t CR2;			 // @4 Control register 2
	__IO uint16_t OAR1;			 // @8 Own address register 1
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint16_t OAR2;			 // @12 Own address register 2
	uint8_t		  RESERVED1[2];	 // @14
	__IO uint32_t TIMINGR;		 // @16 Timing register
	__IO uint32_t TIMEOUTR;		 // @20 Status register 1
	__IO uint32_t ISR;			 // @24 Interrupt and Status register
	__O uint16_t  ICR;			 // @28 Interrupt clear register
	uint8_t		  RESERVED2[2];	 // @30
	__I uint8_t	  PECR;			 // @32 PEC register
	uint8_t		  RESERVED3[3];	 // @33
	__I uint8_t	  RXDR;			 // @36 Receive data register
	uint8_t		  RESERVED4[3];	 // @37
	__IO uint8_t  TXDR;			 // @40 Transmit data register
};

// I2C1->CR1 Control register 1
enum {
	I2C1_CR1_PECEN	   = 1UL << 23,				 // PEC enable
	I2C1_CR1_ALERTEN   = 1UL << 22,				 // SMBUS alert enable
	I2C1_CR1_SMBDEN	   = 1UL << 21,				 // SMBus Device Default address enable
	I2C1_CR1_SMBHEN	   = 1UL << 20,				 // SMBus Host address enable
	I2C1_CR1_GCEN	   = 1UL << 19,				 // General call enable
	I2C1_CR1_WUPEN	   = 1UL << 18,				 // Wakeup from STOP enable
	I2C1_CR1_NOSTRETCH = 1UL << 17,				 // Clock stretching disable
	I2C1_CR1_SBC	   = 1UL << 16,				 // Slave byte control
	I2C1_CR1_RXDMAEN   = 1UL << 15,				 // DMA reception requests enable
	I2C1_CR1_TXDMAEN   = 1UL << 14,				 // DMA transmission requests enable
	I2C1_CR1_ANFOFF	   = 1UL << 12,				 // Analog noise filter OFF
	I2C1_CR1_DNF	   = ((1UL << 4) - 1) << 8,	 // Digital noise filter
	I2C1_CR1_ERRIE	   = 1UL << 7,				 // Error interrupts enable
	I2C1_CR1_TCIE	   = 1UL << 6,				 // Transfer Complete interrupt enable
	I2C1_CR1_STOPIE	   = 1UL << 5,				 // STOP detection Interrupt enable
	I2C1_CR1_NACKIE	   = 1UL << 4,				 // Not acknowledge received interrupt enable
	I2C1_CR1_ADDRIE	   = 1UL << 3,				 // Address match interrupt enable (slave only)
	I2C1_CR1_RXIE	   = 1UL << 2,				 // RX Interrupt enable
	I2C1_CR1_TXIE	   = 1UL << 1,				 // TX Interrupt enable
	I2C1_CR1_PE		   = 1UL << 0,				 // Peripheral enable
};
inline void i2c1_cr1_set_dnf(struct I2C1_Type *p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C1_CR1_DNF) | ((val << 8) & I2C1_CR1_DNF); }
inline uint32_t i2c1_cr1_get_dnf(struct I2C1_Type *p) { return (p->CR1 & I2C1_CR1_DNF) >> 8; }

// I2C1->CR2 Control register 2
enum {
	I2C1_CR2_PECBYTE = 1UL << 26,				// Packet error checking byte
	I2C1_CR2_AUTOEND = 1UL << 25,				// Automatic end mode (master mode)
	I2C1_CR2_RELOAD	 = 1UL << 24,				// NBYTES reload mode
	I2C1_CR2_NBYTES	 = ((1UL << 8) - 1) << 16,	// Number of bytes
	I2C1_CR2_NACK	 = 1UL << 15,				// NACK generation (slave mode)
	I2C1_CR2_STOP	 = 1UL << 14,				// Stop generation (master mode)
	I2C1_CR2_START	 = 1UL << 13,				// Start generation
	I2C1_CR2_HEAD10R = 1UL << 12,				// 10-bit address header only read direction (master receiver mode)
	I2C1_CR2_ADD10	 = 1UL << 11,				// 10-bit addressing mode (master mode)
	I2C1_CR2_RD_WRN	 = 1UL << 10,				// Transfer direction (master mode)
	I2C1_CR2_SADD	 = ((1UL << 10) - 1) << 0,	// Slave address bit (master mode)
};
inline void i2c1_cr2_set_nbytes(struct I2C1_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~I2C1_CR2_NBYTES) | ((val << 16) & I2C1_CR2_NBYTES);
}
inline void i2c1_cr2_set_sadd(struct I2C1_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~I2C1_CR2_SADD) | ((val << 0) & I2C1_CR2_SADD);
}
inline uint32_t i2c1_cr2_get_nbytes(struct I2C1_Type *p) { return (p->CR2 & I2C1_CR2_NBYTES) >> 16; }
inline uint32_t i2c1_cr2_get_sadd(struct I2C1_Type *p) { return (p->CR2 & I2C1_CR2_SADD) >> 0; }

// I2C1->OAR1 Own address register 1
enum {
	I2C1_OAR1_OA1EN	  = 1UL << 15,				 // Own Address 1 enable
	I2C1_OAR1_OA1MODE = 1UL << 10,				 // Own Address 1 10-bit mode
	I2C1_OAR1_OA1	  = ((1UL << 10) - 1) << 0,	 // Interface address
};
inline void i2c1_oar1_set_oa1(struct I2C1_Type *p, uint32_t val) {
	p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1) | ((val << 0) & I2C1_OAR1_OA1);
}
inline uint32_t i2c1_oar1_get_oa1(struct I2C1_Type *p) { return (p->OAR1 & I2C1_OAR1_OA1) >> 0; }

// I2C1->OAR2 Own address register 2
enum {
	I2C1_OAR2_OA2EN	 = 1UL << 15,			   // Own Address 2 enable
	I2C1_OAR2_OA2MSK = ((1UL << 3) - 1) << 8,  // Own Address 2 masks
	I2C1_OAR2_OA2	 = ((1UL << 7) - 1) << 1,  // Interface address
};
inline void i2c1_oar2_set_oa2msk(struct I2C1_Type *p, uint32_t val) {
	p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2MSK) | ((val << 8) & I2C1_OAR2_OA2MSK);
}
inline void i2c1_oar2_set_oa2(struct I2C1_Type *p, uint32_t val) {
	p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2) | ((val << 1) & I2C1_OAR2_OA2);
}
inline uint32_t i2c1_oar2_get_oa2msk(struct I2C1_Type *p) { return (p->OAR2 & I2C1_OAR2_OA2MSK) >> 8; }
inline uint32_t i2c1_oar2_get_oa2(struct I2C1_Type *p) { return (p->OAR2 & I2C1_OAR2_OA2) >> 1; }

// I2C1->TIMINGR Timing register
enum {
	I2C1_TIMINGR_PRESC	= ((1UL << 4) - 1) << 28,  // Timing prescaler
	I2C1_TIMINGR_SCLDEL = ((1UL << 4) - 1) << 20,  // Data setup time
	I2C1_TIMINGR_SDADEL = ((1UL << 4) - 1) << 16,  // Data hold time
	I2C1_TIMINGR_SCLH	= ((1UL << 8) - 1) << 8,   // SCL high period (master mode)
	I2C1_TIMINGR_SCLL	= ((1UL << 8) - 1) << 0,   // SCL low period (master mode)
};
inline void i2c1_timingr_set_presc(struct I2C1_Type *p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_PRESC) | ((val << 28) & I2C1_TIMINGR_PRESC);
}
inline void i2c1_timingr_set_scldel(struct I2C1_Type *p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLDEL) | ((val << 20) & I2C1_TIMINGR_SCLDEL);
}
inline void i2c1_timingr_set_sdadel(struct I2C1_Type *p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SDADEL) | ((val << 16) & I2C1_TIMINGR_SDADEL);
}
inline void i2c1_timingr_set_sclh(struct I2C1_Type *p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLH) | ((val << 8) & I2C1_TIMINGR_SCLH);
}
inline void i2c1_timingr_set_scll(struct I2C1_Type *p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLL) | ((val << 0) & I2C1_TIMINGR_SCLL);
}
inline uint32_t i2c1_timingr_get_presc(struct I2C1_Type *p) { return (p->TIMINGR & I2C1_TIMINGR_PRESC) >> 28; }
inline uint32_t i2c1_timingr_get_scldel(struct I2C1_Type *p) { return (p->TIMINGR & I2C1_TIMINGR_SCLDEL) >> 20; }
inline uint32_t i2c1_timingr_get_sdadel(struct I2C1_Type *p) { return (p->TIMINGR & I2C1_TIMINGR_SDADEL) >> 16; }
inline uint32_t i2c1_timingr_get_sclh(struct I2C1_Type *p) { return (p->TIMINGR & I2C1_TIMINGR_SCLH) >> 8; }
inline uint32_t i2c1_timingr_get_scll(struct I2C1_Type *p) { return (p->TIMINGR & I2C1_TIMINGR_SCLL) >> 0; }

// I2C1->TIMEOUTR Status register 1
enum {
	I2C1_TIMEOUTR_TEXTEN   = 1UL << 31,				   // Extended clock timeout enable
	I2C1_TIMEOUTR_TIMEOUTB = ((1UL << 12) - 1) << 16,  // Bus timeout B
	I2C1_TIMEOUTR_TIMOUTEN = 1UL << 15,				   // Clock timeout enable
	I2C1_TIMEOUTR_TIDLE	   = 1UL << 12,				   // Idle clock timeout detection
	I2C1_TIMEOUTR_TIMEOUTA = ((1UL << 12) - 1) << 0,   // Bus timeout A
};
inline void i2c1_timeoutr_set_timeoutb(struct I2C1_Type *p, uint32_t val) {
	p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTB) | ((val << 16) & I2C1_TIMEOUTR_TIMEOUTB);
}
inline void i2c1_timeoutr_set_timeouta(struct I2C1_Type *p, uint32_t val) {
	p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTA) | ((val << 0) & I2C1_TIMEOUTR_TIMEOUTA);
}
inline uint32_t i2c1_timeoutr_get_timeoutb(struct I2C1_Type *p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTB) >> 16; }
inline uint32_t i2c1_timeoutr_get_timeouta(struct I2C1_Type *p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTA) >> 0; }

// I2C1->ISR Interrupt and Status register
enum {
	I2C1_ISR_ADDCODE = ((1UL << 7) - 1) << 17,	// Address match code (Slave mode)
	I2C1_ISR_DIR	 = 1UL << 16,				// Transfer direction (Slave mode)
	I2C1_ISR_BUSY	 = 1UL << 15,				// Bus busy
	I2C1_ISR_ALERT	 = 1UL << 13,				// SMBus alert
	I2C1_ISR_TIMEOUT = 1UL << 12,				// Timeout or t_low detection flag
	I2C1_ISR_PECERR	 = 1UL << 11,				// PEC Error in reception
	I2C1_ISR_OVR	 = 1UL << 10,				// Overrun/Underrun (slave mode)
	I2C1_ISR_ARLO	 = 1UL << 9,				// Arbitration lost
	I2C1_ISR_BERR	 = 1UL << 8,				// Bus error
	I2C1_ISR_TCR	 = 1UL << 7,				// Transfer Complete Reload
	I2C1_ISR_TC		 = 1UL << 6,				// Transfer Complete (master mode)
	I2C1_ISR_STOPF	 = 1UL << 5,				// Stop detection flag
	I2C1_ISR_NACKF	 = 1UL << 4,				// Not acknowledge received flag
	I2C1_ISR_ADDR	 = 1UL << 3,				// Address matched (slave mode)
	I2C1_ISR_RXNE	 = 1UL << 2,				// Receive data register not empty (receivers)
	I2C1_ISR_TXIS	 = 1UL << 1,				// Transmit interrupt status (transmitters)
	I2C1_ISR_TXE	 = 1UL << 0,				// Transmit data register empty (transmitters)
};
inline void i2c1_isr_set_addcode(struct I2C1_Type *p, uint32_t val) {
	p->ISR = (p->ISR & ~I2C1_ISR_ADDCODE) | ((val << 17) & I2C1_ISR_ADDCODE);
}
inline uint32_t i2c1_isr_get_addcode(struct I2C1_Type *p) { return (p->ISR & I2C1_ISR_ADDCODE) >> 17; }

// I2C1->ICR Interrupt clear register
enum {
	I2C1_ICR_ALERTCF  = 1UL << 13,	// Alert flag clear
	I2C1_ICR_TIMOUTCF = 1UL << 12,	// Timeout detection flag clear
	I2C1_ICR_PECCF	  = 1UL << 11,	// PEC Error flag clear
	I2C1_ICR_OVRCF	  = 1UL << 10,	// Overrun/Underrun flag clear
	I2C1_ICR_ARLOCF	  = 1UL << 9,	// Arbitration lost flag clear
	I2C1_ICR_BERRCF	  = 1UL << 8,	// Bus error flag clear
	I2C1_ICR_STOPCF	  = 1UL << 5,	// Stop detection flag clear
	I2C1_ICR_NACKCF	  = 1UL << 4,	// Not Acknowledge flag clear
	I2C1_ICR_ADDRCF	  = 1UL << 3,	// Address Matched flag clear
};

/* WinWATCHDOG */
struct IWDG_Type {
	__O uint16_t  KR;			 // @0 Key register
	uint8_t		  RESERVED0[2];	 // @2
	__IO uint8_t  PR;			 // @4 Prescaler register
	uint8_t		  RESERVED1[3];	 // @5
	__IO uint16_t RLR;			 // @8 Reload register
	uint8_t		  RESERVED2[2];	 // @10
	__I uint8_t	  SR;			 // @12 Status register
	uint8_t		  RESERVED3[3];	 // @13
	__IO uint16_t WINR;			 // @16 Window register
};

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL << 3) - 1) << 0,	 // Prescaler divider
};
inline void		iwdg_pr_set_pr(struct IWDG_Type *p, uint32_t val) { p->PR = (p->PR & ~IWDG_PR_PR) | ((val << 0) & IWDG_PR_PR); }
inline uint32_t iwdg_pr_get_pr(struct IWDG_Type *p) { return (p->PR & IWDG_PR_PR) >> 0; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL << 12) - 1) << 0,  // Watchdog counter reload value
};
inline void iwdg_rlr_set_rl(struct IWDG_Type *p, uint32_t val) { p->RLR = (p->RLR & ~IWDG_RLR_RL) | ((val << 0) & IWDG_RLR_RL); }
inline uint32_t iwdg_rlr_get_rl(struct IWDG_Type *p) { return (p->RLR & IWDG_RLR_RL) >> 0; }

// IWDG->SR Status register
enum {
	IWDG_SR_WVU = 1UL << 2,	 // Watchdog counter window value update
	IWDG_SR_RVU = 1UL << 1,	 // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL << 0,	 // Watchdog prescaler value update
};

// IWDG->WINR Window register
enum {
	IWDG_WINR_WIN = ((1UL << 12) - 1) << 0,	 // Watchdog counter window value
};
inline void iwdg_winr_set_win(struct IWDG_Type *p, uint32_t val) {
	p->WINR = (p->WINR & ~IWDG_WINR_WIN) | ((val << 0) & IWDG_WINR_WIN);
}
inline uint32_t iwdg_winr_get_win(struct IWDG_Type *p) { return (p->WINR & IWDG_WINR_WIN) >> 0; }

/* Low power timer */
struct LPTIMER1_Type {
	__I uint8_t	  ISR;			 // @0 Interrupt and Status Register
	uint8_t		  RESERVED0[3];	 // @1
	__O uint8_t	  ICR;			 // @4 Interrupt Clear Register
	uint8_t		  RESERVED1[3];	 // @5
	__IO uint8_t  IER;			 // @8 Interrupt Enable Register
	uint8_t		  RESERVED2[3];	 // @9
	__IO uint32_t CFGR;			 // @12 Configuration Register
	__IO uint8_t  CR;			 // @16 Control Register
	uint8_t		  RESERVED3[3];	 // @17
	__IO uint16_t CMP;			 // @20 Compare Register
	uint8_t		  RESERVED4[2];	 // @22
	__IO uint16_t ARR;			 // @24 Autoreload Register
	uint8_t		  RESERVED5[2];	 // @26
	__I uint16_t  CNT;			 // @28 Counter Register
	uint8_t		  RESERVED6[2];	 // @30
	__IO uint8_t  OR;			 // @32 option register
};

// LPTIMER1->ISR Interrupt and Status Register
enum {
	LPTIMER1_ISR_DOWN	 = 1UL << 6,  // Counter direction change up to down
	LPTIMER1_ISR_UP		 = 1UL << 5,  // Counter direction change down to up
	LPTIMER1_ISR_ARROK	 = 1UL << 4,  // Autoreload register update OK
	LPTIMER1_ISR_CMPOK	 = 1UL << 3,  // Compare register update OK
	LPTIMER1_ISR_EXTTRIG = 1UL << 2,  // External trigger edge event
	LPTIMER1_ISR_ARRM	 = 1UL << 1,  // Autoreload match
	LPTIMER1_ISR_CMPM	 = 1UL << 0,  // Compare match
};

// LPTIMER1->ICR Interrupt Clear Register
enum {
	LPTIMER1_ICR_DOWNCF	   = 1UL << 6,	// Direction change to down Clear Flag
	LPTIMER1_ICR_UPCF	   = 1UL << 5,	// Direction change to UP Clear Flag
	LPTIMER1_ICR_ARROKCF   = 1UL << 4,	// Autoreload register update OK Clear Flag
	LPTIMER1_ICR_CMPOKCF   = 1UL << 3,	// Compare register update OK Clear Flag
	LPTIMER1_ICR_EXTTRIGCF = 1UL << 2,	// External trigger valid edge Clear Flag
	LPTIMER1_ICR_ARRMCF	   = 1UL << 1,	// Autoreload match Clear Flag
	LPTIMER1_ICR_CMPMCF	   = 1UL << 0,	// compare match Clear Flag
};

// LPTIMER1->IER Interrupt Enable Register
enum {
	LPTIMER1_IER_DOWNIE	   = 1UL << 6,	// Direction change to down Interrupt Enable
	LPTIMER1_IER_UPIE	   = 1UL << 5,	// Direction change to UP Interrupt Enable
	LPTIMER1_IER_ARROKIE   = 1UL << 4,	// Autoreload register update OK Interrupt Enable
	LPTIMER1_IER_CMPOKIE   = 1UL << 3,	// Compare register update OK Interrupt Enable
	LPTIMER1_IER_EXTTRIGIE = 1UL << 2,	// External trigger valid edge Interrupt Enable
	LPTIMER1_IER_ARRMIE	   = 1UL << 1,	// Autoreload match Interrupt Enable
	LPTIMER1_IER_CMPMIE	   = 1UL << 0,	// Compare match Interrupt Enable
};

// LPTIMER1->CFGR Configuration Register
enum {
	LPTIMER1_CFGR_ENC		= 1UL << 24,			   // Encoder mode enable
	LPTIMER1_CFGR_COUNTMODE = 1UL << 23,			   // counter mode enabled
	LPTIMER1_CFGR_PRELOAD	= 1UL << 22,			   // Registers update mode
	LPTIMER1_CFGR_WAVPOL	= 1UL << 21,			   // Waveform shape polarity
	LPTIMER1_CFGR_WAVE		= 1UL << 20,			   // Waveform shape
	LPTIMER1_CFGR_TIMOUT	= 1UL << 19,			   // Timeout enable
	LPTIMER1_CFGR_TRIGEN	= ((1UL << 2) - 1) << 17,  // Trigger enable and polarity
	LPTIMER1_CFGR_TRIGSEL	= ((1UL << 4) - 1) << 13,  // Trigger selector
	LPTIMER1_CFGR_PRESC		= ((1UL << 3) - 1) << 9,   // Clock prescaler
	LPTIMER1_CFGR_TRGFLT	= ((1UL << 2) - 1) << 6,   // Configurable digital filter for trigger
	LPTIMER1_CFGR_CKFLT		= ((1UL << 2) - 1) << 3,   // Configurable digital filter for external clock
	LPTIMER1_CFGR_CKPOL		= ((1UL << 2) - 1) << 1,   // Clock Polarity
	LPTIMER1_CFGR_CKSEL		= 1UL << 0,				   // Clock selector
};
inline void lptimer1_cfgr_set_trigen(struct LPTIMER1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_TRIGEN) | ((val << 17) & LPTIMER1_CFGR_TRIGEN);
}
inline void lptimer1_cfgr_set_trigsel(struct LPTIMER1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_TRIGSEL) | ((val << 13) & LPTIMER1_CFGR_TRIGSEL);
}
inline void lptimer1_cfgr_set_presc(struct LPTIMER1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_PRESC) | ((val << 9) & LPTIMER1_CFGR_PRESC);
}
inline void lptimer1_cfgr_set_trgflt(struct LPTIMER1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_TRGFLT) | ((val << 6) & LPTIMER1_CFGR_TRGFLT);
}
inline void lptimer1_cfgr_set_ckflt(struct LPTIMER1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_CKFLT) | ((val << 3) & LPTIMER1_CFGR_CKFLT);
}
inline void lptimer1_cfgr_set_ckpol(struct LPTIMER1_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_CKPOL) | ((val << 1) & LPTIMER1_CFGR_CKPOL);
}
inline uint32_t lptimer1_cfgr_get_trigen(struct LPTIMER1_Type *p) { return (p->CFGR & LPTIMER1_CFGR_TRIGEN) >> 17; }
inline uint32_t lptimer1_cfgr_get_trigsel(struct LPTIMER1_Type *p) { return (p->CFGR & LPTIMER1_CFGR_TRIGSEL) >> 13; }
inline uint32_t lptimer1_cfgr_get_presc(struct LPTIMER1_Type *p) { return (p->CFGR & LPTIMER1_CFGR_PRESC) >> 9; }
inline uint32_t lptimer1_cfgr_get_trgflt(struct LPTIMER1_Type *p) { return (p->CFGR & LPTIMER1_CFGR_TRGFLT) >> 6; }
inline uint32_t lptimer1_cfgr_get_ckflt(struct LPTIMER1_Type *p) { return (p->CFGR & LPTIMER1_CFGR_CKFLT) >> 3; }
inline uint32_t lptimer1_cfgr_get_ckpol(struct LPTIMER1_Type *p) { return (p->CFGR & LPTIMER1_CFGR_CKPOL) >> 1; }

// LPTIMER1->CR Control Register
enum {
	LPTIMER1_CR_RSTARE	 = 1UL << 4,  // RSTARE
	LPTIMER1_CR_COUNTRST = 1UL << 3,  // COUNTRST
	LPTIMER1_CR_CNTSTRT	 = 1UL << 2,  // Timer start in continuous mode
	LPTIMER1_CR_SNGSTRT	 = 1UL << 1,  // LPTIM start in single mode
	LPTIMER1_CR_ENABLE	 = 1UL << 0,  // LPTIM Enable
};

// LPTIMER1->OR option register
enum {
	LPTIMER1_OR_IN2_2_1 = ((1UL << 2) - 1) << 4,  // IN2_2_1
	LPTIMER1_OR_IN1_2_1 = ((1UL << 2) - 1) << 2,  // IN1_2_1
	LPTIMER1_OR_IN2		= 1UL << 1,				  // IN2
	LPTIMER1_OR_IN1		= 1UL << 0,				  // IN1
};
inline void lptimer1_or_set_in2_2_1(struct LPTIMER1_Type *p, uint32_t val) {
	p->OR = (p->OR & ~LPTIMER1_OR_IN2_2_1) | ((val << 4) & LPTIMER1_OR_IN2_2_1);
}
inline void lptimer1_or_set_in1_2_1(struct LPTIMER1_Type *p, uint32_t val) {
	p->OR = (p->OR & ~LPTIMER1_OR_IN1_2_1) | ((val << 2) & LPTIMER1_OR_IN1_2_1);
}
inline uint32_t lptimer1_or_get_in2_2_1(struct LPTIMER1_Type *p) { return (p->OR & LPTIMER1_OR_IN2_2_1) >> 4; }
inline uint32_t lptimer1_or_get_in1_2_1(struct LPTIMER1_Type *p) { return (p->OR & LPTIMER1_OR_IN1_2_1) >> 2; }

/* Universal synchronous asynchronous receiver transmitter */
struct LPUART1_Type {
	__IO uint32_t CR1;			 // @0 Control register 1
	__IO uint32_t CR2;			 // @4 Control register 2
	__IO uint32_t CR3;			 // @8 Control register 3
	__IO uint32_t BRR;			 // @12 Baud rate register
	uint8_t		  RESERVED0[8];	 // @16
	__O uint8_t	  RQR;			 // @24 Request register
	uint8_t		  RESERVED1[3];	 // @25
	__I uint32_t  ISR;			 // @28 Interrupt & status register
	__O uint32_t  ICR;			 // @32 Interrupt flag clear register
	__I uint16_t  RDR;			 // @36 Receive data register
	uint8_t		  RESERVED2[2];	 // @38
	__IO uint16_t TDR;			 // @40 Transmit data register
	uint8_t		  RESERVED3[2];	 // @42
	__IO uint8_t  PRESC;		 // @44 Prescaler register
};

// LPUART1->CR1 Control register 1
enum {
	LPUART1_CR1_RXFFIE = 1UL << 31,	 // RXFFIE
	LPUART1_CR1_TXFEIE = 1UL << 30,	 // TXFEIE
	LPUART1_CR1_FIFOEN = 1UL << 29,	 // FIFOEN
	LPUART1_CR1_M1	   = 1UL << 28,	 // Word length
	LPUART1_CR1_DEAT4  = 1UL << 25,	 // Driver Enable assertion time
	LPUART1_CR1_DEAT3  = 1UL << 24,	 // DEAT3
	LPUART1_CR1_DEAT2  = 1UL << 23,	 // DEAT2
	LPUART1_CR1_DEAT1  = 1UL << 22,	 // DEAT1
	LPUART1_CR1_DEAT0  = 1UL << 21,	 // DEAT0
	LPUART1_CR1_DEDT4  = 1UL << 20,	 // Driver Enable de-assertion time
	LPUART1_CR1_DEDT3  = 1UL << 19,	 // DEDT3
	LPUART1_CR1_DEDT2  = 1UL << 18,	 // DEDT2
	LPUART1_CR1_DEDT1  = 1UL << 17,	 // DEDT1
	LPUART1_CR1_DEDT0  = 1UL << 16,	 // DEDT0
	LPUART1_CR1_CMIE   = 1UL << 14,	 // Character match interrupt enable
	LPUART1_CR1_MME	   = 1UL << 13,	 // Mute mode enable
	LPUART1_CR1_M0	   = 1UL << 12,	 // Word length
	LPUART1_CR1_WAKE   = 1UL << 11,	 // Receiver wakeup method
	LPUART1_CR1_PCE	   = 1UL << 10,	 // Parity control enable
	LPUART1_CR1_PS	   = 1UL << 9,	 // Parity selection
	LPUART1_CR1_PEIE   = 1UL << 8,	 // PE interrupt enable
	LPUART1_CR1_TXEIE  = 1UL << 7,	 // interrupt enable
	LPUART1_CR1_TCIE   = 1UL << 6,	 // Transmission complete interrupt enable
	LPUART1_CR1_RXNEIE = 1UL << 5,	 // RXNE interrupt enable
	LPUART1_CR1_IDLEIE = 1UL << 4,	 // IDLE interrupt enable
	LPUART1_CR1_TE	   = 1UL << 3,	 // Transmitter enable
	LPUART1_CR1_RE	   = 1UL << 2,	 // Receiver enable
	LPUART1_CR1_UESM   = 1UL << 1,	 // USART enable in Stop mode
	LPUART1_CR1_UE	   = 1UL << 0,	 // USART enable
};

// LPUART1->CR2 Control register 2
enum {
	LPUART1_CR2_ADD4_7	 = ((1UL << 4) - 1) << 28,	// Address of the USART node
	LPUART1_CR2_ADD0_3	 = ((1UL << 4) - 1) << 24,	// Address of the USART node
	LPUART1_CR2_MSBFIRST = 1UL << 19,				// Most significant bit first
	LPUART1_CR2_TAINV	 = 1UL << 18,				// Binary data inversion
	LPUART1_CR2_TXINV	 = 1UL << 17,				// TX pin active level inversion
	LPUART1_CR2_RXINV	 = 1UL << 16,				// RX pin active level inversion
	LPUART1_CR2_SWAP	 = 1UL << 15,				// Swap TX/RX pins
	LPUART1_CR2_STOP	 = ((1UL << 2) - 1) << 12,	// STOP bits
	LPUART1_CR2_ADDM7	 = 1UL << 4,				// 7-bit Address Detection/4-bit Address Detection
};
inline void lpuart1_cr2_set_add4_7(struct LPUART1_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD4_7) | ((val << 28) & LPUART1_CR2_ADD4_7);
}
inline void lpuart1_cr2_set_add0_3(struct LPUART1_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD0_3) | ((val << 24) & LPUART1_CR2_ADD0_3);
}
inline void lpuart1_cr2_set_stop(struct LPUART1_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~LPUART1_CR2_STOP) | ((val << 12) & LPUART1_CR2_STOP);
}
inline uint32_t lpuart1_cr2_get_add4_7(struct LPUART1_Type *p) { return (p->CR2 & LPUART1_CR2_ADD4_7) >> 28; }
inline uint32_t lpuart1_cr2_get_add0_3(struct LPUART1_Type *p) { return (p->CR2 & LPUART1_CR2_ADD0_3) >> 24; }
inline uint32_t lpuart1_cr2_get_stop(struct LPUART1_Type *p) { return (p->CR2 & LPUART1_CR2_STOP) >> 12; }

// LPUART1->CR3 Control register 3
enum {
	LPUART1_CR3_TXFTCFG = ((1UL << 3) - 1) << 29,  // TXFTCFG
	LPUART1_CR3_RXFTIE	= 1UL << 28,			   // RXFTIE
	LPUART1_CR3_RXFTCFG = ((1UL << 3) - 1) << 25,  // RXFTCFG
	LPUART1_CR3_TXFTIE	= 1UL << 23,			   // TXFTIE
	LPUART1_CR3_WUFIE	= 1UL << 22,			   // Wakeup from Stop mode interrupt enable
	LPUART1_CR3_WUS		= ((1UL << 2) - 1) << 20,  // Wakeup from Stop mode interrupt flag selection
	LPUART1_CR3_DEP		= 1UL << 15,			   // Driver enable polarity selection
	LPUART1_CR3_DEM		= 1UL << 14,			   // Driver enable mode
	LPUART1_CR3_DDRE	= 1UL << 13,			   // DMA Disable on Reception Error
	LPUART1_CR3_OVRDIS	= 1UL << 12,			   // Overrun Disable
	LPUART1_CR3_CTSIE	= 1UL << 10,			   // CTS interrupt enable
	LPUART1_CR3_CTSE	= 1UL << 9,				   // CTS enable
	LPUART1_CR3_RTSE	= 1UL << 8,				   // RTS enable
	LPUART1_CR3_DMAT	= 1UL << 7,				   // DMA enable transmitter
	LPUART1_CR3_DMAR	= 1UL << 6,				   // DMA enable receiver
	LPUART1_CR3_HDSEL	= 1UL << 3,				   // Half-duplex selection
	LPUART1_CR3_EIE		= 1UL << 0,				   // Error interrupt enable
};
inline void lpuart1_cr3_set_txftcfg(struct LPUART1_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~LPUART1_CR3_TXFTCFG) | ((val << 29) & LPUART1_CR3_TXFTCFG);
}
inline void lpuart1_cr3_set_rxftcfg(struct LPUART1_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~LPUART1_CR3_RXFTCFG) | ((val << 25) & LPUART1_CR3_RXFTCFG);
}
inline void lpuart1_cr3_set_wus(struct LPUART1_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~LPUART1_CR3_WUS) | ((val << 20) & LPUART1_CR3_WUS);
}
inline uint32_t lpuart1_cr3_get_txftcfg(struct LPUART1_Type *p) { return (p->CR3 & LPUART1_CR3_TXFTCFG) >> 29; }
inline uint32_t lpuart1_cr3_get_rxftcfg(struct LPUART1_Type *p) { return (p->CR3 & LPUART1_CR3_RXFTCFG) >> 25; }
inline uint32_t lpuart1_cr3_get_wus(struct LPUART1_Type *p) { return (p->CR3 & LPUART1_CR3_WUS) >> 20; }

// LPUART1->BRR Baud rate register
enum {
	LPUART1_BRR_BRR = ((1UL << 20) - 1) << 0,  // BRR
};
inline void lpuart1_brr_set_brr(struct LPUART1_Type *p, uint32_t val) {
	p->BRR = (p->BRR & ~LPUART1_BRR_BRR) | ((val << 0) & LPUART1_BRR_BRR);
}
inline uint32_t lpuart1_brr_get_brr(struct LPUART1_Type *p) { return (p->BRR & LPUART1_BRR_BRR) >> 0; }

// LPUART1->RQR Request register
enum {
	LPUART1_RQR_TXFRQ = 1UL << 4,  // TXFRQ
	LPUART1_RQR_RXFRQ = 1UL << 3,  // Receive data flush request
	LPUART1_RQR_MMRQ  = 1UL << 2,  // Mute mode request
	LPUART1_RQR_SBKRQ = 1UL << 1,  // Send break request
};

// LPUART1->ISR Interrupt & status register
enum {
	LPUART1_ISR_TXFT  = 1UL << 27,	// TXFT
	LPUART1_ISR_RXFT  = 1UL << 26,	// RXFT
	LPUART1_ISR_RXFF  = 1UL << 24,	// RXFF
	LPUART1_ISR_TXFE  = 1UL << 23,	// TXFE
	LPUART1_ISR_REACK = 1UL << 22,	// REACK
	LPUART1_ISR_TEACK = 1UL << 21,	// TEACK
	LPUART1_ISR_WUF	  = 1UL << 20,	// WUF
	LPUART1_ISR_RWU	  = 1UL << 19,	// RWU
	LPUART1_ISR_SBKF  = 1UL << 18,	// SBKF
	LPUART1_ISR_CMF	  = 1UL << 17,	// CMF
	LPUART1_ISR_BUSY  = 1UL << 16,	// BUSY
	LPUART1_ISR_CTS	  = 1UL << 10,	// CTS
	LPUART1_ISR_CTSIF = 1UL << 9,	// CTSIF
	LPUART1_ISR_TXE	  = 1UL << 7,	// TXE
	LPUART1_ISR_TC	  = 1UL << 6,	// TC
	LPUART1_ISR_RXNE  = 1UL << 5,	// RXNE
	LPUART1_ISR_IDLE  = 1UL << 4,	// IDLE
	LPUART1_ISR_ORE	  = 1UL << 3,	// ORE
	LPUART1_ISR_NF	  = 1UL << 2,	// NF
	LPUART1_ISR_FE	  = 1UL << 1,	// FE
	LPUART1_ISR_PE	  = 1UL << 0,	// PE
};

// LPUART1->ICR Interrupt flag clear register
enum {
	LPUART1_ICR_WUCF   = 1UL << 20,	 // Wakeup from Stop mode clear flag
	LPUART1_ICR_CMCF   = 1UL << 17,	 // Character match clear flag
	LPUART1_ICR_CTSCF  = 1UL << 9,	 // CTS clear flag
	LPUART1_ICR_TCCF   = 1UL << 6,	 // Transmission complete clear flag
	LPUART1_ICR_IDLECF = 1UL << 4,	 // Idle line detected clear flag
	LPUART1_ICR_ORECF  = 1UL << 3,	 // Overrun error clear flag
	LPUART1_ICR_NCF	   = 1UL << 2,	 // Noise detected clear flag
	LPUART1_ICR_FECF   = 1UL << 1,	 // Framing error clear flag
	LPUART1_ICR_PECF   = 1UL << 0,	 // Parity error clear flag
};

// LPUART1->RDR Receive data register
enum {
	LPUART1_RDR_RDR = ((1UL << 9) - 1) << 0,  // Receive data value
};
inline uint32_t lpuart1_rdr_get_rdr(struct LPUART1_Type *p) { return (p->RDR & LPUART1_RDR_RDR) >> 0; }

// LPUART1->TDR Transmit data register
enum {
	LPUART1_TDR_TDR = ((1UL << 9) - 1) << 0,  // Transmit data value
};
inline void lpuart1_tdr_set_tdr(struct LPUART1_Type *p, uint32_t val) {
	p->TDR = (p->TDR & ~LPUART1_TDR_TDR) | ((val << 0) & LPUART1_TDR_TDR);
}
inline uint32_t lpuart1_tdr_get_tdr(struct LPUART1_Type *p) { return (p->TDR & LPUART1_TDR_TDR) >> 0; }

// LPUART1->PRESC Prescaler register
enum {
	LPUART1_PRESC_PRESCALER = ((1UL << 4) - 1) << 0,  // PRESCALER
};
inline void lpuart1_presc_set_prescaler(struct LPUART1_Type *p, uint32_t val) {
	p->PRESC = (p->PRESC & ~LPUART1_PRESC_PRESCALER) | ((val << 0) & LPUART1_PRESC_PRESCALER);
}
inline uint32_t lpuart1_presc_get_prescaler(struct LPUART1_Type *p) { return (p->PRESC & LPUART1_PRESC_PRESCALER) >> 0; }

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t  TYPER;		 // @0 MPU type register
	__IO uint8_t  CTRL;			 // @4 MPU control register
	uint8_t		  RESERVED0[3];	 // @5
	__IO uint8_t  RNR;			 // @8 MPU region number register
	uint8_t		  RESERVED1[3];	 // @9
	__IO uint32_t RBAR;			 // @12 MPU region base address register
	__IO uint32_t RASR;			 // @16 MPU region attribute and size register
};

// MPU->TYPER MPU type register
enum {
	MPU_TYPER_IREGION  = ((1UL << 8) - 1) << 16,  // Number of MPU instruction regions
	MPU_TYPER_DREGION  = ((1UL << 8) - 1) << 8,	  // Number of MPU data regions
	MPU_TYPER_SEPARATE = 1UL << 0,				  // Separate flag
};
inline uint32_t mpu_typer_get_iregion(struct MPU_Type *p) { return (p->TYPER & MPU_TYPER_IREGION) >> 16; }
inline uint32_t mpu_typer_get_dregion(struct MPU_Type *p) { return (p->TYPER & MPU_TYPER_DREGION) >> 8; }

// MPU->CTRL MPU control register
enum {
	MPU_CTRL_PRIVDEFENA = 1UL << 2,	 // Enable priviliged software access to default memory map
	MPU_CTRL_HFNMIENA	= 1UL << 1,	 // Enables the operation of MPU during hard fault
	MPU_CTRL_ENABLE		= 1UL << 0,	 // Enables the MPU
};

// MPU->RBAR MPU region base address register
enum {
	MPU_RBAR_ADDR	= ((1UL << 27) - 1) << 5,  // Region base address field
	MPU_RBAR_VALID	= 1UL << 4,				   // MPU region number valid
	MPU_RBAR_REGION = ((1UL << 4) - 1) << 0,   // MPU region field
};
inline void mpu_rbar_set_addr(struct MPU_Type *p, uint32_t val) {
	p->RBAR = (p->RBAR & ~MPU_RBAR_ADDR) | ((val << 5) & MPU_RBAR_ADDR);
}
inline void mpu_rbar_set_region(struct MPU_Type *p, uint32_t val) {
	p->RBAR = (p->RBAR & ~MPU_RBAR_REGION) | ((val << 0) & MPU_RBAR_REGION);
}
inline uint32_t mpu_rbar_get_addr(struct MPU_Type *p) { return (p->RBAR & MPU_RBAR_ADDR) >> 5; }
inline uint32_t mpu_rbar_get_region(struct MPU_Type *p) { return (p->RBAR & MPU_RBAR_REGION) >> 0; }

// MPU->RASR MPU region attribute and size register
enum {
	MPU_RASR_XN		= 1UL << 28,			   // Instruction access disable bit
	MPU_RASR_AP		= ((1UL << 3) - 1) << 24,  // Access permission
	MPU_RASR_TEX	= ((1UL << 3) - 1) << 19,  // memory attribute
	MPU_RASR_S		= 1UL << 18,			   // Shareable memory attribute
	MPU_RASR_C		= 1UL << 17,			   // memory attribute
	MPU_RASR_B		= 1UL << 16,			   // memory attribute
	MPU_RASR_SRD	= ((1UL << 8) - 1) << 8,   // Subregion disable bits
	MPU_RASR_SIZE	= ((1UL << 5) - 1) << 1,   // Size of the MPU protection region
	MPU_RASR_ENABLE = 1UL << 0,				   // Region enable bit.
};
inline void mpu_rasr_set_ap(struct MPU_Type *p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_AP) | ((val << 24) & MPU_RASR_AP); }
inline void mpu_rasr_set_tex(struct MPU_Type *p, uint32_t val) {
	p->RASR = (p->RASR & ~MPU_RASR_TEX) | ((val << 19) & MPU_RASR_TEX);
}
inline void mpu_rasr_set_srd(struct MPU_Type *p, uint32_t val) {
	p->RASR = (p->RASR & ~MPU_RASR_SRD) | ((val << 8) & MPU_RASR_SRD);
}
inline void mpu_rasr_set_size(struct MPU_Type *p, uint32_t val) {
	p->RASR = (p->RASR & ~MPU_RASR_SIZE) | ((val << 1) & MPU_RASR_SIZE);
}
inline uint32_t mpu_rasr_get_ap(struct MPU_Type *p) { return (p->RASR & MPU_RASR_AP) >> 24; }
inline uint32_t mpu_rasr_get_tex(struct MPU_Type *p) { return (p->RASR & MPU_RASR_TEX) >> 19; }
inline uint32_t mpu_rasr_get_srd(struct MPU_Type *p) { return (p->RASR & MPU_RASR_SRD) >> 8; }
inline uint32_t mpu_rasr_get_size(struct MPU_Type *p) { return (p->RASR & MPU_RASR_SIZE) >> 1; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER0;		   // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1;		   // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2;		   // @8 Interrupt Set-Enable Register
	__IO uint32_t ISER3;		   // @12 Interrupt Set-Enable Register
	uint8_t		  RESERVED0[112];  // @16
	__IO uint32_t ICER0;		   // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1;		   // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2;		   // @136 Interrupt Clear-Enable Register
	__IO uint32_t ICER3;		   // @140 Interrupt Clear-Enable Register
	uint8_t		  RESERVED1[112];  // @144
	__IO uint32_t ISPR0;		   // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1;		   // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2;		   // @264 Interrupt Set-Pending Register
	__IO uint32_t ISPR3;		   // @268 Interrupt Set-Pending Register
	uint8_t		  RESERVED2[112];  // @272
	__IO uint32_t ICPR0;		   // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1;		   // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2;		   // @392 Interrupt Clear-Pending Register
	__IO uint32_t ICPR3;		   // @396 Interrupt Clear-Pending Register
	uint8_t		  RESERVED3[112];  // @400
	__I uint32_t  IABR0;		   // @512 Interrupt Active Bit Register
	__I uint32_t  IABR1;		   // @516 Interrupt Active Bit Register
	__I uint32_t  IABR2;		   // @520 Interrupt Active Bit Register
	__I uint32_t  IABR3;		   // @524 Interrupt Active Bit Register
	uint8_t		  RESERVED4[240];  // @528
	__IO uint32_t IPR0;			   // @768 Interrupt Priority Register
	__IO uint32_t IPR1;			   // @772 Interrupt Priority Register
	__IO uint32_t IPR2;			   // @776 Interrupt Priority Register
	__IO uint32_t IPR3;			   // @780 Interrupt Priority Register
	__IO uint32_t IPR4;			   // @784 Interrupt Priority Register
	__IO uint32_t IPR5;			   // @788 Interrupt Priority Register
	__IO uint32_t IPR6;			   // @792 Interrupt Priority Register
	__IO uint32_t IPR7;			   // @796 Interrupt Priority Register
	__IO uint32_t IPR8;			   // @800 Interrupt Priority Register
	__IO uint32_t IPR9;			   // @804 Interrupt Priority Register
	__IO uint32_t IPR10;		   // @808 Interrupt Priority Register
	__IO uint32_t IPR11;		   // @812 Interrupt Priority Register
	__IO uint32_t IPR12;		   // @816 Interrupt Priority Register
	__IO uint32_t IPR13;		   // @820 Interrupt Priority Register
	__IO uint32_t IPR14;		   // @824 Interrupt Priority Register
	__IO uint32_t IPR15;		   // @828 Interrupt Priority Register
	__IO uint32_t IPR16;		   // @832 Interrupt Priority Register
	__IO uint32_t IPR17;		   // @836 Interrupt Priority Register
	__IO uint32_t IPR18;		   // @840 Interrupt Priority Register
	__IO uint32_t IPR19;		   // @844 Interrupt Priority Register
	__IO uint32_t IPR20;		   // @848 Interrupt Priority Register
	__IO uint32_t IPR21;		   // @852 Interrupt Priority Register
	__IO uint32_t IPR22;		   // @856 Interrupt Priority Register
	__IO uint32_t IPR23;		   // @860 Interrupt Priority Register
	__IO uint32_t IPR24;		   // @864 Interrupt Priority Register
	__IO uint32_t IPR25;		   // @868 Interrupt Priority Register
};

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr0_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N3) | ((val << 24) & NVIC_IPR0_IPR_N3);
}
inline void nvic_ipr0_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N2) | ((val << 16) & NVIC_IPR0_IPR_N2);
}
inline void nvic_ipr0_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N1) | ((val << 8) & NVIC_IPR0_IPR_N1);
}
inline void nvic_ipr0_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N0) | ((val << 0) & NVIC_IPR0_IPR_N0);
}
inline uint32_t nvic_ipr0_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR0 & NVIC_IPR0_IPR_N3) >> 24; }
inline uint32_t nvic_ipr0_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR0 & NVIC_IPR0_IPR_N2) >> 16; }
inline uint32_t nvic_ipr0_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR0 & NVIC_IPR0_IPR_N1) >> 8; }
inline uint32_t nvic_ipr0_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR0 & NVIC_IPR0_IPR_N0) >> 0; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr1_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N3) | ((val << 24) & NVIC_IPR1_IPR_N3);
}
inline void nvic_ipr1_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N2) | ((val << 16) & NVIC_IPR1_IPR_N2);
}
inline void nvic_ipr1_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N1) | ((val << 8) & NVIC_IPR1_IPR_N1);
}
inline void nvic_ipr1_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N0) | ((val << 0) & NVIC_IPR1_IPR_N0);
}
inline uint32_t nvic_ipr1_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR1 & NVIC_IPR1_IPR_N3) >> 24; }
inline uint32_t nvic_ipr1_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR1 & NVIC_IPR1_IPR_N2) >> 16; }
inline uint32_t nvic_ipr1_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR1 & NVIC_IPR1_IPR_N1) >> 8; }
inline uint32_t nvic_ipr1_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR1 & NVIC_IPR1_IPR_N0) >> 0; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr2_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N3) | ((val << 24) & NVIC_IPR2_IPR_N3);
}
inline void nvic_ipr2_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N2) | ((val << 16) & NVIC_IPR2_IPR_N2);
}
inline void nvic_ipr2_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N1) | ((val << 8) & NVIC_IPR2_IPR_N1);
}
inline void nvic_ipr2_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N0) | ((val << 0) & NVIC_IPR2_IPR_N0);
}
inline uint32_t nvic_ipr2_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR2 & NVIC_IPR2_IPR_N3) >> 24; }
inline uint32_t nvic_ipr2_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR2 & NVIC_IPR2_IPR_N2) >> 16; }
inline uint32_t nvic_ipr2_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR2 & NVIC_IPR2_IPR_N1) >> 8; }
inline uint32_t nvic_ipr2_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR2 & NVIC_IPR2_IPR_N0) >> 0; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr3_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N3) | ((val << 24) & NVIC_IPR3_IPR_N3);
}
inline void nvic_ipr3_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N2) | ((val << 16) & NVIC_IPR3_IPR_N2);
}
inline void nvic_ipr3_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N1) | ((val << 8) & NVIC_IPR3_IPR_N1);
}
inline void nvic_ipr3_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N0) | ((val << 0) & NVIC_IPR3_IPR_N0);
}
inline uint32_t nvic_ipr3_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR3 & NVIC_IPR3_IPR_N3) >> 24; }
inline uint32_t nvic_ipr3_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR3 & NVIC_IPR3_IPR_N2) >> 16; }
inline uint32_t nvic_ipr3_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR3 & NVIC_IPR3_IPR_N1) >> 8; }
inline uint32_t nvic_ipr3_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR3 & NVIC_IPR3_IPR_N0) >> 0; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr4_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N3) | ((val << 24) & NVIC_IPR4_IPR_N3);
}
inline void nvic_ipr4_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N2) | ((val << 16) & NVIC_IPR4_IPR_N2);
}
inline void nvic_ipr4_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N1) | ((val << 8) & NVIC_IPR4_IPR_N1);
}
inline void nvic_ipr4_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N0) | ((val << 0) & NVIC_IPR4_IPR_N0);
}
inline uint32_t nvic_ipr4_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR4 & NVIC_IPR4_IPR_N3) >> 24; }
inline uint32_t nvic_ipr4_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR4 & NVIC_IPR4_IPR_N2) >> 16; }
inline uint32_t nvic_ipr4_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR4 & NVIC_IPR4_IPR_N1) >> 8; }
inline uint32_t nvic_ipr4_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR4 & NVIC_IPR4_IPR_N0) >> 0; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr5_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N3) | ((val << 24) & NVIC_IPR5_IPR_N3);
}
inline void nvic_ipr5_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N2) | ((val << 16) & NVIC_IPR5_IPR_N2);
}
inline void nvic_ipr5_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N1) | ((val << 8) & NVIC_IPR5_IPR_N1);
}
inline void nvic_ipr5_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N0) | ((val << 0) & NVIC_IPR5_IPR_N0);
}
inline uint32_t nvic_ipr5_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR5 & NVIC_IPR5_IPR_N3) >> 24; }
inline uint32_t nvic_ipr5_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR5 & NVIC_IPR5_IPR_N2) >> 16; }
inline uint32_t nvic_ipr5_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR5 & NVIC_IPR5_IPR_N1) >> 8; }
inline uint32_t nvic_ipr5_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR5 & NVIC_IPR5_IPR_N0) >> 0; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr6_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N3) | ((val << 24) & NVIC_IPR6_IPR_N3);
}
inline void nvic_ipr6_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N2) | ((val << 16) & NVIC_IPR6_IPR_N2);
}
inline void nvic_ipr6_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N1) | ((val << 8) & NVIC_IPR6_IPR_N1);
}
inline void nvic_ipr6_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N0) | ((val << 0) & NVIC_IPR6_IPR_N0);
}
inline uint32_t nvic_ipr6_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR6 & NVIC_IPR6_IPR_N3) >> 24; }
inline uint32_t nvic_ipr6_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR6 & NVIC_IPR6_IPR_N2) >> 16; }
inline uint32_t nvic_ipr6_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR6 & NVIC_IPR6_IPR_N1) >> 8; }
inline uint32_t nvic_ipr6_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR6 & NVIC_IPR6_IPR_N0) >> 0; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr7_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N3) | ((val << 24) & NVIC_IPR7_IPR_N3);
}
inline void nvic_ipr7_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N2) | ((val << 16) & NVIC_IPR7_IPR_N2);
}
inline void nvic_ipr7_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N1) | ((val << 8) & NVIC_IPR7_IPR_N1);
}
inline void nvic_ipr7_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N0) | ((val << 0) & NVIC_IPR7_IPR_N0);
}
inline uint32_t nvic_ipr7_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR7 & NVIC_IPR7_IPR_N3) >> 24; }
inline uint32_t nvic_ipr7_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR7 & NVIC_IPR7_IPR_N2) >> 16; }
inline uint32_t nvic_ipr7_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR7 & NVIC_IPR7_IPR_N1) >> 8; }
inline uint32_t nvic_ipr7_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR7 & NVIC_IPR7_IPR_N0) >> 0; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr8_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N3) | ((val << 24) & NVIC_IPR8_IPR_N3);
}
inline void nvic_ipr8_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N2) | ((val << 16) & NVIC_IPR8_IPR_N2);
}
inline void nvic_ipr8_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N1) | ((val << 8) & NVIC_IPR8_IPR_N1);
}
inline void nvic_ipr8_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N0) | ((val << 0) & NVIC_IPR8_IPR_N0);
}
inline uint32_t nvic_ipr8_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR8 & NVIC_IPR8_IPR_N3) >> 24; }
inline uint32_t nvic_ipr8_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR8 & NVIC_IPR8_IPR_N2) >> 16; }
inline uint32_t nvic_ipr8_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR8 & NVIC_IPR8_IPR_N1) >> 8; }
inline uint32_t nvic_ipr8_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR8 & NVIC_IPR8_IPR_N0) >> 0; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL << 8) - 1) << 24,	// IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL << 8) - 1) << 16,	// IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL << 8) - 1) << 8,	// IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL << 8) - 1) << 0,	// IPR_N0
};
inline void nvic_ipr9_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N3) | ((val << 24) & NVIC_IPR9_IPR_N3);
}
inline void nvic_ipr9_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N2) | ((val << 16) & NVIC_IPR9_IPR_N2);
}
inline void nvic_ipr9_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N1) | ((val << 8) & NVIC_IPR9_IPR_N1);
}
inline void nvic_ipr9_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N0) | ((val << 0) & NVIC_IPR9_IPR_N0);
}
inline uint32_t nvic_ipr9_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR9 & NVIC_IPR9_IPR_N3) >> 24; }
inline uint32_t nvic_ipr9_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR9 & NVIC_IPR9_IPR_N2) >> 16; }
inline uint32_t nvic_ipr9_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR9 & NVIC_IPR9_IPR_N1) >> 8; }
inline uint32_t nvic_ipr9_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR9 & NVIC_IPR9_IPR_N0) >> 0; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr10_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N3) | ((val << 24) & NVIC_IPR10_IPR_N3);
}
inline void nvic_ipr10_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N2) | ((val << 16) & NVIC_IPR10_IPR_N2);
}
inline void nvic_ipr10_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N1) | ((val << 8) & NVIC_IPR10_IPR_N1);
}
inline void nvic_ipr10_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N0) | ((val << 0) & NVIC_IPR10_IPR_N0);
}
inline uint32_t nvic_ipr10_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR10 & NVIC_IPR10_IPR_N3) >> 24; }
inline uint32_t nvic_ipr10_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR10 & NVIC_IPR10_IPR_N2) >> 16; }
inline uint32_t nvic_ipr10_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR10 & NVIC_IPR10_IPR_N1) >> 8; }
inline uint32_t nvic_ipr10_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR10 & NVIC_IPR10_IPR_N0) >> 0; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr11_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N3) | ((val << 24) & NVIC_IPR11_IPR_N3);
}
inline void nvic_ipr11_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N2) | ((val << 16) & NVIC_IPR11_IPR_N2);
}
inline void nvic_ipr11_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N1) | ((val << 8) & NVIC_IPR11_IPR_N1);
}
inline void nvic_ipr11_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N0) | ((val << 0) & NVIC_IPR11_IPR_N0);
}
inline uint32_t nvic_ipr11_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR11 & NVIC_IPR11_IPR_N3) >> 24; }
inline uint32_t nvic_ipr11_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR11 & NVIC_IPR11_IPR_N2) >> 16; }
inline uint32_t nvic_ipr11_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR11 & NVIC_IPR11_IPR_N1) >> 8; }
inline uint32_t nvic_ipr11_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR11 & NVIC_IPR11_IPR_N0) >> 0; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr12_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N3) | ((val << 24) & NVIC_IPR12_IPR_N3);
}
inline void nvic_ipr12_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N2) | ((val << 16) & NVIC_IPR12_IPR_N2);
}
inline void nvic_ipr12_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N1) | ((val << 8) & NVIC_IPR12_IPR_N1);
}
inline void nvic_ipr12_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N0) | ((val << 0) & NVIC_IPR12_IPR_N0);
}
inline uint32_t nvic_ipr12_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR12 & NVIC_IPR12_IPR_N3) >> 24; }
inline uint32_t nvic_ipr12_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR12 & NVIC_IPR12_IPR_N2) >> 16; }
inline uint32_t nvic_ipr12_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR12 & NVIC_IPR12_IPR_N1) >> 8; }
inline uint32_t nvic_ipr12_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR12 & NVIC_IPR12_IPR_N0) >> 0; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr13_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N3) | ((val << 24) & NVIC_IPR13_IPR_N3);
}
inline void nvic_ipr13_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N2) | ((val << 16) & NVIC_IPR13_IPR_N2);
}
inline void nvic_ipr13_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N1) | ((val << 8) & NVIC_IPR13_IPR_N1);
}
inline void nvic_ipr13_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N0) | ((val << 0) & NVIC_IPR13_IPR_N0);
}
inline uint32_t nvic_ipr13_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR13 & NVIC_IPR13_IPR_N3) >> 24; }
inline uint32_t nvic_ipr13_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR13 & NVIC_IPR13_IPR_N2) >> 16; }
inline uint32_t nvic_ipr13_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR13 & NVIC_IPR13_IPR_N1) >> 8; }
inline uint32_t nvic_ipr13_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR13 & NVIC_IPR13_IPR_N0) >> 0; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr14_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N3) | ((val << 24) & NVIC_IPR14_IPR_N3);
}
inline void nvic_ipr14_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N2) | ((val << 16) & NVIC_IPR14_IPR_N2);
}
inline void nvic_ipr14_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N1) | ((val << 8) & NVIC_IPR14_IPR_N1);
}
inline void nvic_ipr14_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N0) | ((val << 0) & NVIC_IPR14_IPR_N0);
}
inline uint32_t nvic_ipr14_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR14 & NVIC_IPR14_IPR_N3) >> 24; }
inline uint32_t nvic_ipr14_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR14 & NVIC_IPR14_IPR_N2) >> 16; }
inline uint32_t nvic_ipr14_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR14 & NVIC_IPR14_IPR_N1) >> 8; }
inline uint32_t nvic_ipr14_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR14 & NVIC_IPR14_IPR_N0) >> 0; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr15_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N3) | ((val << 24) & NVIC_IPR15_IPR_N3);
}
inline void nvic_ipr15_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N2) | ((val << 16) & NVIC_IPR15_IPR_N2);
}
inline void nvic_ipr15_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N1) | ((val << 8) & NVIC_IPR15_IPR_N1);
}
inline void nvic_ipr15_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N0) | ((val << 0) & NVIC_IPR15_IPR_N0);
}
inline uint32_t nvic_ipr15_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR15 & NVIC_IPR15_IPR_N3) >> 24; }
inline uint32_t nvic_ipr15_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR15 & NVIC_IPR15_IPR_N2) >> 16; }
inline uint32_t nvic_ipr15_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR15 & NVIC_IPR15_IPR_N1) >> 8; }
inline uint32_t nvic_ipr15_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR15 & NVIC_IPR15_IPR_N0) >> 0; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr16_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N3) | ((val << 24) & NVIC_IPR16_IPR_N3);
}
inline void nvic_ipr16_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N2) | ((val << 16) & NVIC_IPR16_IPR_N2);
}
inline void nvic_ipr16_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N1) | ((val << 8) & NVIC_IPR16_IPR_N1);
}
inline void nvic_ipr16_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N0) | ((val << 0) & NVIC_IPR16_IPR_N0);
}
inline uint32_t nvic_ipr16_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR16 & NVIC_IPR16_IPR_N3) >> 24; }
inline uint32_t nvic_ipr16_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR16 & NVIC_IPR16_IPR_N2) >> 16; }
inline uint32_t nvic_ipr16_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR16 & NVIC_IPR16_IPR_N1) >> 8; }
inline uint32_t nvic_ipr16_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR16 & NVIC_IPR16_IPR_N0) >> 0; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr17_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N3) | ((val << 24) & NVIC_IPR17_IPR_N3);
}
inline void nvic_ipr17_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N2) | ((val << 16) & NVIC_IPR17_IPR_N2);
}
inline void nvic_ipr17_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N1) | ((val << 8) & NVIC_IPR17_IPR_N1);
}
inline void nvic_ipr17_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N0) | ((val << 0) & NVIC_IPR17_IPR_N0);
}
inline uint32_t nvic_ipr17_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR17 & NVIC_IPR17_IPR_N3) >> 24; }
inline uint32_t nvic_ipr17_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR17 & NVIC_IPR17_IPR_N2) >> 16; }
inline uint32_t nvic_ipr17_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR17 & NVIC_IPR17_IPR_N1) >> 8; }
inline uint32_t nvic_ipr17_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR17 & NVIC_IPR17_IPR_N0) >> 0; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr18_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N3) | ((val << 24) & NVIC_IPR18_IPR_N3);
}
inline void nvic_ipr18_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N2) | ((val << 16) & NVIC_IPR18_IPR_N2);
}
inline void nvic_ipr18_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N1) | ((val << 8) & NVIC_IPR18_IPR_N1);
}
inline void nvic_ipr18_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N0) | ((val << 0) & NVIC_IPR18_IPR_N0);
}
inline uint32_t nvic_ipr18_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR18 & NVIC_IPR18_IPR_N3) >> 24; }
inline uint32_t nvic_ipr18_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR18 & NVIC_IPR18_IPR_N2) >> 16; }
inline uint32_t nvic_ipr18_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR18 & NVIC_IPR18_IPR_N1) >> 8; }
inline uint32_t nvic_ipr18_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR18 & NVIC_IPR18_IPR_N0) >> 0; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr19_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N3) | ((val << 24) & NVIC_IPR19_IPR_N3);
}
inline void nvic_ipr19_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N2) | ((val << 16) & NVIC_IPR19_IPR_N2);
}
inline void nvic_ipr19_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N1) | ((val << 8) & NVIC_IPR19_IPR_N1);
}
inline void nvic_ipr19_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N0) | ((val << 0) & NVIC_IPR19_IPR_N0);
}
inline uint32_t nvic_ipr19_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR19 & NVIC_IPR19_IPR_N3) >> 24; }
inline uint32_t nvic_ipr19_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR19 & NVIC_IPR19_IPR_N2) >> 16; }
inline uint32_t nvic_ipr19_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR19 & NVIC_IPR19_IPR_N1) >> 8; }
inline uint32_t nvic_ipr19_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR19 & NVIC_IPR19_IPR_N0) >> 0; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL << 8) - 1) << 24,	 // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL << 8) - 1) << 16,	 // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL << 8) - 1) << 8,	 // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL << 8) - 1) << 0,	 // IPR_N0
};
inline void nvic_ipr20_set_ipr_n3(struct NVIC_Type *p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N3) | ((val << 24) & NVIC_IPR20_IPR_N3);
}
inline void nvic_ipr20_set_ipr_n2(struct NVIC_Type *p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N2) | ((val << 16) & NVIC_IPR20_IPR_N2);
}
inline void nvic_ipr20_set_ipr_n1(struct NVIC_Type *p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N1) | ((val << 8) & NVIC_IPR20_IPR_N1);
}
inline void nvic_ipr20_set_ipr_n0(struct NVIC_Type *p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N0) | ((val << 0) & NVIC_IPR20_IPR_N0);
}
inline uint32_t nvic_ipr20_get_ipr_n3(struct NVIC_Type *p) { return (p->IPR20 & NVIC_IPR20_IPR_N3) >> 24; }
inline uint32_t nvic_ipr20_get_ipr_n2(struct NVIC_Type *p) { return (p->IPR20 & NVIC_IPR20_IPR_N2) >> 16; }
inline uint32_t nvic_ipr20_get_ipr_n1(struct NVIC_Type *p) { return (p->IPR20 & NVIC_IPR20_IPR_N1) >> 8; }
inline uint32_t nvic_ipr20_get_ipr_n0(struct NVIC_Type *p) { return (p->IPR20 & NVIC_IPR20_IPR_N0) >> 0; }

/* Nested vectored interrupt controller */
struct NVIC_STIR_Type {
	__IO uint16_t STIR;	 // @0 Software trigger interrupt register
};

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL << 9) - 1) << 0,  // Software generated interrupt ID
};
inline void nvic_stir_stir_set_intid(struct NVIC_STIR_Type *p, uint32_t val) {
	p->STIR = (p->STIR & ~NVIC_STIR_STIR_INTID) | ((val << 0) & NVIC_STIR_STIR_INTID);
}
inline uint32_t nvic_stir_stir_get_intid(struct NVIC_STIR_Type *p) { return (p->STIR & NVIC_STIR_STIR_INTID) >> 0; }

/* Operational amplifiers */
struct OPAMP_Type {
	__IO uint32_t OPAMP1_CSR;	// @0 OPAMP1 control/status register
	__IO uint32_t OPAMP2_CSR;	// @4 OPAMP2 control/status register
	__IO uint32_t OPAMP3_CSR;	// @8 OPAMP3 control/status register
	__IO uint32_t OPAMP4_CSR;	// @12 OPAMP4 control/status register
	__IO uint32_t OPAMP5_CSR;	// @16 OPAMP5 control/status register
	__IO uint32_t OPAMP6_CSR;	// @20 OPAMP6 control/status register
	__IO uint32_t OPAMP1_TCMR;	// @24 OPAMP1 control/status register
	__IO uint32_t OPAMP2_TCMR;	// @28 OPAMP2 control/status register
	__IO uint32_t OPAMP3_TCMR;	// @32 OPAMP3 control/status register
	__IO uint32_t OPAMP4_TCMR;	// @36 OPAMP4 control/status register
	__IO uint32_t OPAMP5_TCMR;	// @40 OPAMP5 control/status register
	__IO uint32_t OPAMP6_TCMR;	// @44 OPAMP6 control/status register
};

// OPAMP->OPAMP1_CSR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_CSR_LOCK		 = 1UL << 31,				// LOCK
	OPAMP_OPAMP1_CSR_CALOUT		 = 1UL << 30,				// CALOUT
	OPAMP_OPAMP1_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24,	// TRIMOFFSETN
	OPAMP_OPAMP1_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19,	// TRIMOFFSETP
	OPAMP_OPAMP1_CSR_PGA_GAIN	 = ((1UL << 5) - 1) << 14,	// PGA_GAIN
	OPAMP_OPAMP1_CSR_CALSEL		 = ((1UL << 2) - 1) << 12,	// CALSEL
	OPAMP_OPAMP1_CSR_CALON		 = 1UL << 11,				// CALON
	OPAMP_OPAMP1_CSR_OPAINTOEN	 = 1UL << 8,				// OPAINTOEN
	OPAMP_OPAMP1_CSR_OPAHSM		 = 1UL << 7,				// OPAHSM
	OPAMP_OPAMP1_CSR_VM_SEL		 = ((1UL << 2) - 1) << 5,	// VM_SEL
	OPAMP_OPAMP1_CSR_USERTRIM	 = 1UL << 4,				// USERTRIM
	OPAMP_OPAMP1_CSR_VP_SEL		 = ((1UL << 2) - 1) << 2,	// VP_SEL
	OPAMP_OPAMP1_CSR_FORCE_VP	 = 1UL << 1,				// FORCE_VP
	OPAMP_OPAMP1_CSR_OPAEN		 = 1UL << 0,				// Operational amplifier Enable
};
inline void opamp_opamp1_csr_set_trimoffsetn(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP1_CSR_TRIMOFFSETN);
}
inline void opamp_opamp1_csr_set_trimoffsetp(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP1_CSR_TRIMOFFSETP);
}
inline void opamp_opamp1_csr_set_pga_gain(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP1_CSR_PGA_GAIN);
}
inline void opamp_opamp1_csr_set_calsel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP1_CSR_CALSEL);
}
inline void opamp_opamp1_csr_set_vm_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP1_CSR_VM_SEL);
}
inline void opamp_opamp1_csr_set_vp_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP1_CSR_VP_SEL);
}
inline uint32_t opamp_opamp1_csr_get_trimoffsetn(struct OPAMP_Type *p) {
	return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_TRIMOFFSETN) >> 24;
}
inline uint32_t opamp_opamp1_csr_get_trimoffsetp(struct OPAMP_Type *p) {
	return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_TRIMOFFSETP) >> 19;
}
inline uint32_t opamp_opamp1_csr_get_pga_gain(struct OPAMP_Type *p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp1_csr_get_calsel(struct OPAMP_Type *p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp1_csr_get_vm_sel(struct OPAMP_Type *p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp1_csr_get_vp_sel(struct OPAMP_Type *p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP2_CSR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_CSR_LOCK		 = 1UL << 31,				// LOCK
	OPAMP_OPAMP2_CSR_CALOUT		 = 1UL << 30,				// CALOUT
	OPAMP_OPAMP2_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24,	// TRIMOFFSETN
	OPAMP_OPAMP2_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19,	// TRIMOFFSETP
	OPAMP_OPAMP2_CSR_PGA_GAIN	 = ((1UL << 5) - 1) << 14,	// PGA_GAIN
	OPAMP_OPAMP2_CSR_CALSEL		 = ((1UL << 2) - 1) << 12,	// CALSEL
	OPAMP_OPAMP2_CSR_CALON		 = 1UL << 11,				// CALON
	OPAMP_OPAMP2_CSR_OPAINTOEN	 = 1UL << 8,				// OPAINTOEN
	OPAMP_OPAMP2_CSR_OPAHSM		 = 1UL << 7,				// OPAHSM
	OPAMP_OPAMP2_CSR_VM_SEL		 = ((1UL << 2) - 1) << 5,	// VM_SEL
	OPAMP_OPAMP2_CSR_USERTRIM	 = 1UL << 4,				// USERTRIM
	OPAMP_OPAMP2_CSR_VP_SEL		 = ((1UL << 2) - 1) << 2,	// VP_SEL
	OPAMP_OPAMP2_CSR_FORCE_VP	 = 1UL << 1,				// FORCE_VP
	OPAMP_OPAMP2_CSR_OPAEN		 = 1UL << 0,				// Operational amplifier Enable
};
inline void opamp_opamp2_csr_set_trimoffsetn(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP2_CSR_TRIMOFFSETN);
}
inline void opamp_opamp2_csr_set_trimoffsetp(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP2_CSR_TRIMOFFSETP);
}
inline void opamp_opamp2_csr_set_pga_gain(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP2_CSR_PGA_GAIN);
}
inline void opamp_opamp2_csr_set_calsel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP2_CSR_CALSEL);
}
inline void opamp_opamp2_csr_set_vm_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP2_CSR_VM_SEL);
}
inline void opamp_opamp2_csr_set_vp_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP2_CSR_VP_SEL);
}
inline uint32_t opamp_opamp2_csr_get_trimoffsetn(struct OPAMP_Type *p) {
	return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_TRIMOFFSETN) >> 24;
}
inline uint32_t opamp_opamp2_csr_get_trimoffsetp(struct OPAMP_Type *p) {
	return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_TRIMOFFSETP) >> 19;
}
inline uint32_t opamp_opamp2_csr_get_pga_gain(struct OPAMP_Type *p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp2_csr_get_calsel(struct OPAMP_Type *p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp2_csr_get_vm_sel(struct OPAMP_Type *p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp2_csr_get_vp_sel(struct OPAMP_Type *p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP3_CSR OPAMP3 control/status register
enum {
	OPAMP_OPAMP3_CSR_LOCK		 = 1UL << 31,				// LOCK
	OPAMP_OPAMP3_CSR_CALOUT		 = 1UL << 30,				// CALOUT
	OPAMP_OPAMP3_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24,	// TRIMOFFSETN
	OPAMP_OPAMP3_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19,	// TRIMOFFSETP
	OPAMP_OPAMP3_CSR_PGA_GAIN	 = ((1UL << 5) - 1) << 14,	// PGA_GAIN
	OPAMP_OPAMP3_CSR_CALSEL		 = ((1UL << 2) - 1) << 12,	// CALSEL
	OPAMP_OPAMP3_CSR_CALON		 = 1UL << 11,				// CALON
	OPAMP_OPAMP3_CSR_OPAINTOEN	 = 1UL << 8,				// OPAINTOEN
	OPAMP_OPAMP3_CSR_OPAHSM		 = 1UL << 7,				// OPAHSM
	OPAMP_OPAMP3_CSR_VM_SEL		 = ((1UL << 2) - 1) << 5,	// VM_SEL
	OPAMP_OPAMP3_CSR_USERTRIM	 = 1UL << 4,				// USERTRIM
	OPAMP_OPAMP3_CSR_VP_SEL		 = ((1UL << 2) - 1) << 2,	// VP_SEL
	OPAMP_OPAMP3_CSR_FORCE_VP	 = 1UL << 1,				// FORCE_VP
	OPAMP_OPAMP3_CSR_OPAEN		 = 1UL << 0,				// Operational amplifier Enable
};
inline void opamp_opamp3_csr_set_trimoffsetn(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP3_CSR_TRIMOFFSETN);
}
inline void opamp_opamp3_csr_set_trimoffsetp(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP3_CSR_TRIMOFFSETP);
}
inline void opamp_opamp3_csr_set_pga_gain(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP3_CSR_PGA_GAIN);
}
inline void opamp_opamp3_csr_set_calsel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP3_CSR_CALSEL);
}
inline void opamp_opamp3_csr_set_vm_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP3_CSR_VM_SEL);
}
inline void opamp_opamp3_csr_set_vp_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP3_CSR_VP_SEL);
}
inline uint32_t opamp_opamp3_csr_get_trimoffsetn(struct OPAMP_Type *p) {
	return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_TRIMOFFSETN) >> 24;
}
inline uint32_t opamp_opamp3_csr_get_trimoffsetp(struct OPAMP_Type *p) {
	return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_TRIMOFFSETP) >> 19;
}
inline uint32_t opamp_opamp3_csr_get_pga_gain(struct OPAMP_Type *p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp3_csr_get_calsel(struct OPAMP_Type *p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp3_csr_get_vm_sel(struct OPAMP_Type *p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp3_csr_get_vp_sel(struct OPAMP_Type *p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP4_CSR OPAMP4 control/status register
enum {
	OPAMP_OPAMP4_CSR_LOCK		 = 1UL << 31,				// LOCK
	OPAMP_OPAMP4_CSR_CALOUT		 = 1UL << 30,				// CALOUT
	OPAMP_OPAMP4_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24,	// TRIMOFFSETN
	OPAMP_OPAMP4_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19,	// TRIMOFFSETP
	OPAMP_OPAMP4_CSR_PGA_GAIN	 = ((1UL << 5) - 1) << 14,	// PGA_GAIN
	OPAMP_OPAMP4_CSR_CALSEL		 = ((1UL << 2) - 1) << 12,	// CALSEL
	OPAMP_OPAMP4_CSR_CALON		 = 1UL << 11,				// CALON
	OPAMP_OPAMP4_CSR_OPAINTOEN	 = 1UL << 8,				// OPAINTOEN
	OPAMP_OPAMP4_CSR_OPAHSM		 = 1UL << 7,				// OPAHSM
	OPAMP_OPAMP4_CSR_VM_SEL		 = ((1UL << 2) - 1) << 5,	// VM_SEL
	OPAMP_OPAMP4_CSR_USERTRIM	 = 1UL << 4,				// USERTRIM
	OPAMP_OPAMP4_CSR_VP_SEL		 = ((1UL << 2) - 1) << 2,	// VP_SEL
	OPAMP_OPAMP4_CSR_FORCE_VP	 = 1UL << 1,				// FORCE_VP
	OPAMP_OPAMP4_CSR_OPAEN		 = 1UL << 0,				// Operational amplifier Enable
};
inline void opamp_opamp4_csr_set_trimoffsetn(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_CSR = (p->OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP4_CSR_TRIMOFFSETN);
}
inline void opamp_opamp4_csr_set_trimoffsetp(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_CSR = (p->OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP4_CSR_TRIMOFFSETP);
}
inline void opamp_opamp4_csr_set_pga_gain(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_CSR = (p->OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP4_CSR_PGA_GAIN);
}
inline void opamp_opamp4_csr_set_calsel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_CSR = (p->OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP4_CSR_CALSEL);
}
inline void opamp_opamp4_csr_set_vm_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_CSR = (p->OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP4_CSR_VM_SEL);
}
inline void opamp_opamp4_csr_set_vp_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_CSR = (p->OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP4_CSR_VP_SEL);
}
inline uint32_t opamp_opamp4_csr_get_trimoffsetn(struct OPAMP_Type *p) {
	return (p->OPAMP4_CSR & OPAMP_OPAMP4_CSR_TRIMOFFSETN) >> 24;
}
inline uint32_t opamp_opamp4_csr_get_trimoffsetp(struct OPAMP_Type *p) {
	return (p->OPAMP4_CSR & OPAMP_OPAMP4_CSR_TRIMOFFSETP) >> 19;
}
inline uint32_t opamp_opamp4_csr_get_pga_gain(struct OPAMP_Type *p) { return (p->OPAMP4_CSR & OPAMP_OPAMP4_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp4_csr_get_calsel(struct OPAMP_Type *p) { return (p->OPAMP4_CSR & OPAMP_OPAMP4_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp4_csr_get_vm_sel(struct OPAMP_Type *p) { return (p->OPAMP4_CSR & OPAMP_OPAMP4_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp4_csr_get_vp_sel(struct OPAMP_Type *p) { return (p->OPAMP4_CSR & OPAMP_OPAMP4_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP5_CSR OPAMP5 control/status register
enum {
	OPAMP_OPAMP5_CSR_LOCK		 = 1UL << 31,				// LOCK
	OPAMP_OPAMP5_CSR_CALOUT		 = 1UL << 30,				// CALOUT
	OPAMP_OPAMP5_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24,	// TRIMOFFSETN
	OPAMP_OPAMP5_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19,	// TRIMOFFSETP
	OPAMP_OPAMP5_CSR_PGA_GAIN	 = ((1UL << 5) - 1) << 14,	// PGA_GAIN
	OPAMP_OPAMP5_CSR_CALSEL		 = ((1UL << 2) - 1) << 12,	// CALSEL
	OPAMP_OPAMP5_CSR_CALON		 = 1UL << 11,				// CALON
	OPAMP_OPAMP5_CSR_OPAINTOEN	 = 1UL << 8,				// OPAINTOEN
	OPAMP_OPAMP5_CSR_OPAHSM		 = 1UL << 7,				// OPAHSM
	OPAMP_OPAMP5_CSR_VM_SEL		 = ((1UL << 2) - 1) << 5,	// VM_SEL
	OPAMP_OPAMP5_CSR_USERTRIM	 = 1UL << 4,				// USERTRIM
	OPAMP_OPAMP5_CSR_VP_SEL		 = ((1UL << 2) - 1) << 2,	// VP_SEL
	OPAMP_OPAMP5_CSR_FORCE_VP	 = 1UL << 1,				// FORCE_VP
	OPAMP_OPAMP5_CSR_OPAEN		 = 1UL << 0,				// Operational amplifier Enable
};
inline void opamp_opamp5_csr_set_trimoffsetn(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_CSR = (p->OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP5_CSR_TRIMOFFSETN);
}
inline void opamp_opamp5_csr_set_trimoffsetp(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_CSR = (p->OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP5_CSR_TRIMOFFSETP);
}
inline void opamp_opamp5_csr_set_pga_gain(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_CSR = (p->OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP5_CSR_PGA_GAIN);
}
inline void opamp_opamp5_csr_set_calsel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_CSR = (p->OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP5_CSR_CALSEL);
}
inline void opamp_opamp5_csr_set_vm_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_CSR = (p->OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP5_CSR_VM_SEL);
}
inline void opamp_opamp5_csr_set_vp_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_CSR = (p->OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP5_CSR_VP_SEL);
}
inline uint32_t opamp_opamp5_csr_get_trimoffsetn(struct OPAMP_Type *p) {
	return (p->OPAMP5_CSR & OPAMP_OPAMP5_CSR_TRIMOFFSETN) >> 24;
}
inline uint32_t opamp_opamp5_csr_get_trimoffsetp(struct OPAMP_Type *p) {
	return (p->OPAMP5_CSR & OPAMP_OPAMP5_CSR_TRIMOFFSETP) >> 19;
}
inline uint32_t opamp_opamp5_csr_get_pga_gain(struct OPAMP_Type *p) { return (p->OPAMP5_CSR & OPAMP_OPAMP5_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp5_csr_get_calsel(struct OPAMP_Type *p) { return (p->OPAMP5_CSR & OPAMP_OPAMP5_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp5_csr_get_vm_sel(struct OPAMP_Type *p) { return (p->OPAMP5_CSR & OPAMP_OPAMP5_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp5_csr_get_vp_sel(struct OPAMP_Type *p) { return (p->OPAMP5_CSR & OPAMP_OPAMP5_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP6_CSR OPAMP6 control/status register
enum {
	OPAMP_OPAMP6_CSR_LOCK		 = 1UL << 31,				// LOCK
	OPAMP_OPAMP6_CSR_CALOUT		 = 1UL << 30,				// CALOUT
	OPAMP_OPAMP6_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24,	// TRIMOFFSETN
	OPAMP_OPAMP6_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19,	// TRIMOFFSETP
	OPAMP_OPAMP6_CSR_PGA_GAIN	 = ((1UL << 5) - 1) << 14,	// PGA_GAIN
	OPAMP_OPAMP6_CSR_CALSEL		 = ((1UL << 2) - 1) << 12,	// CALSEL
	OPAMP_OPAMP6_CSR_CALON		 = 1UL << 11,				// CALON
	OPAMP_OPAMP6_CSR_OPAINTOEN	 = 1UL << 8,				// OPAINTOEN
	OPAMP_OPAMP6_CSR_OPAHSM		 = 1UL << 7,				// OPAHSM
	OPAMP_OPAMP6_CSR_VM_SEL		 = ((1UL << 2) - 1) << 5,	// VM_SEL
	OPAMP_OPAMP6_CSR_USERTRIM	 = 1UL << 4,				// USERTRIM
	OPAMP_OPAMP6_CSR_VP_SEL		 = ((1UL << 2) - 1) << 2,	// VP_SEL
	OPAMP_OPAMP6_CSR_FORCE_VP	 = 1UL << 1,				// FORCE_VP
	OPAMP_OPAMP6_CSR_OPAEN		 = 1UL << 0,				// Operational amplifier Enable
};
inline void opamp_opamp6_csr_set_trimoffsetn(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_CSR = (p->OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP6_CSR_TRIMOFFSETN);
}
inline void opamp_opamp6_csr_set_trimoffsetp(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_CSR = (p->OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP6_CSR_TRIMOFFSETP);
}
inline void opamp_opamp6_csr_set_pga_gain(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_CSR = (p->OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP6_CSR_PGA_GAIN);
}
inline void opamp_opamp6_csr_set_calsel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_CSR = (p->OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP6_CSR_CALSEL);
}
inline void opamp_opamp6_csr_set_vm_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_CSR = (p->OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP6_CSR_VM_SEL);
}
inline void opamp_opamp6_csr_set_vp_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_CSR = (p->OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP6_CSR_VP_SEL);
}
inline uint32_t opamp_opamp6_csr_get_trimoffsetn(struct OPAMP_Type *p) {
	return (p->OPAMP6_CSR & OPAMP_OPAMP6_CSR_TRIMOFFSETN) >> 24;
}
inline uint32_t opamp_opamp6_csr_get_trimoffsetp(struct OPAMP_Type *p) {
	return (p->OPAMP6_CSR & OPAMP_OPAMP6_CSR_TRIMOFFSETP) >> 19;
}
inline uint32_t opamp_opamp6_csr_get_pga_gain(struct OPAMP_Type *p) { return (p->OPAMP6_CSR & OPAMP_OPAMP6_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp6_csr_get_calsel(struct OPAMP_Type *p) { return (p->OPAMP6_CSR & OPAMP_OPAMP6_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp6_csr_get_vm_sel(struct OPAMP_Type *p) { return (p->OPAMP6_CSR & OPAMP_OPAMP6_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp6_csr_get_vp_sel(struct OPAMP_Type *p) { return (p->OPAMP6_CSR & OPAMP_OPAMP6_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP1_TCMR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_TCMR_LOCK	   = 1UL << 31,				 // LOCK
	OPAMP_OPAMP1_TCMR_T20CM_EN = 1UL << 5,				 // T20CM_EN
	OPAMP_OPAMP1_TCMR_T8CM_EN  = 1UL << 4,				 // T8CM_EN
	OPAMP_OPAMP1_TCMR_T1CM_EN  = 1UL << 3,				 // T1CM_EN
	OPAMP_OPAMP1_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1,	 // VPS_SEL
	OPAMP_OPAMP1_TCMR_VMS_SEL  = 1UL << 0,				 // VMS_SEL
};
inline void opamp_opamp1_tcmr_set_vps_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP1_TCMR = (p->OPAMP1_TCMR & ~OPAMP_OPAMP1_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP1_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp1_tcmr_get_vps_sel(struct OPAMP_Type *p) { return (p->OPAMP1_TCMR & OPAMP_OPAMP1_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP2_TCMR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_TCMR_LOCK	   = 1UL << 31,				 // LOCK
	OPAMP_OPAMP2_TCMR_T20CM_EN = 1UL << 5,				 // T20CM_EN
	OPAMP_OPAMP2_TCMR_T8CM_EN  = 1UL << 4,				 // T8CM_EN
	OPAMP_OPAMP2_TCMR_T1CM_EN  = 1UL << 3,				 // T1CM_EN
	OPAMP_OPAMP2_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1,	 // VPS_SEL
	OPAMP_OPAMP2_TCMR_VMS_SEL  = 1UL << 0,				 // VMS_SEL
};
inline void opamp_opamp2_tcmr_set_vps_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP2_TCMR = (p->OPAMP2_TCMR & ~OPAMP_OPAMP2_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP2_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp2_tcmr_get_vps_sel(struct OPAMP_Type *p) { return (p->OPAMP2_TCMR & OPAMP_OPAMP2_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP3_TCMR OPAMP3 control/status register
enum {
	OPAMP_OPAMP3_TCMR_LOCK	   = 1UL << 31,				 // LOCK
	OPAMP_OPAMP3_TCMR_T20CM_EN = 1UL << 5,				 // T20CM_EN
	OPAMP_OPAMP3_TCMR_T8CM_EN  = 1UL << 4,				 // T8CM_EN
	OPAMP_OPAMP3_TCMR_T1CM_EN  = 1UL << 3,				 // T1CM_EN
	OPAMP_OPAMP3_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1,	 // VPS_SEL
	OPAMP_OPAMP3_TCMR_VMS_SEL  = 1UL << 0,				 // VMS_SEL
};
inline void opamp_opamp3_tcmr_set_vps_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP3_TCMR = (p->OPAMP3_TCMR & ~OPAMP_OPAMP3_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP3_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp3_tcmr_get_vps_sel(struct OPAMP_Type *p) { return (p->OPAMP3_TCMR & OPAMP_OPAMP3_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP4_TCMR OPAMP4 control/status register
enum {
	OPAMP_OPAMP4_TCMR_LOCK	   = 1UL << 31,				 // LOCK
	OPAMP_OPAMP4_TCMR_T20CM_EN = 1UL << 5,				 // T20CM_EN
	OPAMP_OPAMP4_TCMR_T8CM_EN  = 1UL << 4,				 // T8CM_EN
	OPAMP_OPAMP4_TCMR_T1CM_EN  = 1UL << 3,				 // T1CM_EN
	OPAMP_OPAMP4_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1,	 // VPS_SEL
	OPAMP_OPAMP4_TCMR_VMS_SEL  = 1UL << 0,				 // VMS_SEL
};
inline void opamp_opamp4_tcmr_set_vps_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP4_TCMR = (p->OPAMP4_TCMR & ~OPAMP_OPAMP4_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP4_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp4_tcmr_get_vps_sel(struct OPAMP_Type *p) { return (p->OPAMP4_TCMR & OPAMP_OPAMP4_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP5_TCMR OPAMP5 control/status register
enum {
	OPAMP_OPAMP5_TCMR_LOCK	   = 1UL << 31,				 // LOCK
	OPAMP_OPAMP5_TCMR_T20CM_EN = 1UL << 5,				 // T20CM_EN
	OPAMP_OPAMP5_TCMR_T8CM_EN  = 1UL << 4,				 // T8CM_EN
	OPAMP_OPAMP5_TCMR_T1CM_EN  = 1UL << 3,				 // T1CM_EN
	OPAMP_OPAMP5_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1,	 // VPS_SEL
	OPAMP_OPAMP5_TCMR_VMS_SEL  = 1UL << 0,				 // VMS_SEL
};
inline void opamp_opamp5_tcmr_set_vps_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP5_TCMR = (p->OPAMP5_TCMR & ~OPAMP_OPAMP5_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP5_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp5_tcmr_get_vps_sel(struct OPAMP_Type *p) { return (p->OPAMP5_TCMR & OPAMP_OPAMP5_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP6_TCMR OPAMP6 control/status register
enum {
	OPAMP_OPAMP6_TCMR_LOCK	   = 1UL << 31,				 // LOCK
	OPAMP_OPAMP6_TCMR_T20CM_EN = 1UL << 5,				 // T20CM_EN
	OPAMP_OPAMP6_TCMR_T8CM_EN  = 1UL << 4,				 // T8CM_EN
	OPAMP_OPAMP6_TCMR_T1CM_EN  = 1UL << 3,				 // T1CM_EN
	OPAMP_OPAMP6_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1,	 // VPS_SEL
	OPAMP_OPAMP6_TCMR_VMS_SEL  = 1UL << 0,				 // VMS_SEL
};
inline void opamp_opamp6_tcmr_set_vps_sel(struct OPAMP_Type *p, uint32_t val) {
	p->OPAMP6_TCMR = (p->OPAMP6_TCMR & ~OPAMP_OPAMP6_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP6_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp6_tcmr_get_vps_sel(struct OPAMP_Type *p) { return (p->OPAMP6_TCMR & OPAMP_OPAMP6_TCMR_VPS_SEL) >> 1; }

/* Power control */
struct PWR_Type {
	__IO uint16_t CR1;			   // @0 Power control register 1
	uint8_t		  RESERVED0[2];	   // @2
	__IO uint8_t  CR2;			   // @4 Power control register 2
	uint8_t		  RESERVED1[3];	   // @5
	__IO uint16_t CR3;			   // @8 Power control register 3
	uint8_t		  RESERVED2[2];	   // @10
	__IO uint16_t CR4;			   // @12 Power control register 4
	uint8_t		  RESERVED3[2];	   // @14
	__IO uint16_t SR1;			   // @16 Power status register 1
	uint8_t		  RESERVED4[2];	   // @18
	__IO uint16_t SR2;			   // @20 Power status register 2
	uint8_t		  RESERVED5[2];	   // @22
	__IO uint16_t SCR;			   // @24 Power status clear register
	uint8_t		  RESERVED6[6];	   // @26
	__IO uint16_t PUCRA;		   // @32 Power Port A pull-up control register
	uint8_t		  RESERVED7[2];	   // @34
	__IO uint16_t PDCRA;		   // @36 Power Port A pull-down control register
	uint8_t		  RESERVED8[2];	   // @38
	__IO uint16_t PUCRB;		   // @40 Power Port B pull-up control register
	uint8_t		  RESERVED9[2];	   // @42
	__IO uint16_t PDCRB;		   // @44 Power Port B pull-down control register
	uint8_t		  RESERVED10[2];   // @46
	__IO uint16_t PUCRC;		   // @48 Power Port C pull-up control register
	uint8_t		  RESERVED11[2];   // @50
	__IO uint16_t PDCRC;		   // @52 Power Port C pull-down control register
	uint8_t		  RESERVED12[2];   // @54
	__IO uint16_t PUCRD;		   // @56 Power Port D pull-up control register
	uint8_t		  RESERVED13[2];   // @58
	__IO uint16_t PDCRD;		   // @60 Power Port D pull-down control register
	uint8_t		  RESERVED14[2];   // @62
	__IO uint16_t PUCRE;		   // @64 Power Port E pull-up control register
	uint8_t		  RESERVED15[2];   // @66
	__IO uint16_t PDCRE;		   // @68 Power Port E pull-down control register
	uint8_t		  RESERVED16[2];   // @70
	__IO uint16_t PUCRF;		   // @72 Power Port F pull-up control register
	uint8_t		  RESERVED17[2];   // @74
	__IO uint16_t PDCRF;		   // @76 Power Port F pull-down control register
	uint8_t		  RESERVED18[2];   // @78
	__IO uint16_t PUCRG;		   // @80 Power Port G pull-up control register
	uint8_t		  RESERVED19[2];   // @82
	__IO uint16_t PDCRG;		   // @84 Power Port G pull-down control register
	uint8_t		  RESERVED20[42];  // @86
	__IO uint16_t CR5;			   // @128 Power control register
};

// PWR->CR1 Power control register 1
enum {
	PWR_CR1_LPR =
			1UL
			<< 14,	// Low-power run When this bit is set, the regulator is switched from main mode (MR) to low-power mode (LPR).
	PWR_CR1_VOS = ((1UL << 2) - 1) << 9,  // Voltage scaling range selection
	PWR_CR1_DBP = 1UL << 8,	 // Disable backup domain write protection In reset state, the RTC and backup registers are protected
							 // against parasitic write access. This bit must be set to enable write access to these registers.
	PWR_CR1_FPD_STOP = 1UL << 3,		   // FPD_STOP
	PWR_CR1_LPMS = ((1UL << 3) - 1) << 0,  // Low-power mode selection These bits select the low-power mode entered when CPU enters
										   // the deepsleep mode. 1xx: Shutdown mode Note: In Standby mode, SRAM2 can be preserved
										   // or not, depending on RRS bit configuration in PWR_CR3.
};
inline void pwr_cr1_set_vos(struct PWR_Type *p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_VOS) | ((val << 9) & PWR_CR1_VOS); }
inline void pwr_cr1_set_lpms(struct PWR_Type *p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_LPMS) | ((val << 0) & PWR_CR1_LPMS); }
inline uint32_t pwr_cr1_get_vos(struct PWR_Type *p) { return (p->CR1 & PWR_CR1_VOS) >> 9; }
inline uint32_t pwr_cr1_get_lpms(struct PWR_Type *p) { return (p->CR1 & PWR_CR1_LPMS) >> 0; }

// PWR->CR2 Power control register 2
enum {
	PWR_CR2_PVMEN2 = 1UL << 7,	// Peripheral voltage monitoring 4 enable: V<sub>DDA</sub> vs. DAC 1MSPS /DAC 15MSPS min voltage.
	PWR_CR2_PVMEN1 = 1UL << 6,	// Peripheral voltage monitoring 3 enable: V<sub>DDA</sub> vs. ADC/COMP min voltage 1.62V
	PWR_CR2_PVDLS  = ((1UL << 3) - 1) << 1,	 // Programmable voltage detector level selection. These bits select the PVD falling
											 // threshold: Note: These bits are write-protected when the PVDL bit is set in the
											 // SYSCFG_CFGR2 register. The protection can be reset only by a system reset.
	PWR_CR2_PVDE = 1UL << 0,  // Programmable voltage detector enable Note: This bit is write-protected when the PVDL bit is set in
							  // the SYSCFG_CFGR2 register. The protection can be reset only by a system reset.
};
inline void pwr_cr2_set_pvdls(struct PWR_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~PWR_CR2_PVDLS) | ((val << 1) & PWR_CR2_PVDLS);
}
inline uint32_t pwr_cr2_get_pvdls(struct PWR_Type *p) { return (p->CR2 & PWR_CR2_PVDLS) >> 1; }

// PWR->CR3 Power control register 3
enum {
	PWR_CR3_EIWUL		= 1UL << 15,  // Enable internal wakeup line
	PWR_CR3_UCPD1_DBDIS = 1UL << 14,  // USB Type-C and Power Delivery Dead Battery disable. After exiting reset, the USB Type-C
									  // dead battery behavior is enabled, which may have a pull-down effect on CC1 and CC2 pins.
									  // It is recommended to disable it in all cases, either to stop this pull-down or to hand over
									  // control to the UCPD1 (which should therefore be initialized before doing the disable).
	PWR_CR3_UCPD1_STDBY = 1UL << 13,  // UCPD1_STDBY USB Type-C and Power Delivery standby mode.
	PWR_CR3_APC = 1UL << 10,   // Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down
							   // configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied. When this bit is
							   // cleared, the PWR_PUCRx and PWR_PDCRx registers are not applied to the I/Os.
	PWR_CR3_RRS	  = 1UL << 8,  // SRAM2 retention in Standby mode
	PWR_CR3_EWUP5 = 1UL << 4,  // Enable Wakeup pin WKUP5 When this bit is set, the external wakeup pin WKUP5 is enabled and
							   // triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs.The active
							   // edge is configured via the WP5 bit in the PWR_CR4 register.
	PWR_CR3_EWUP4 = 1UL << 3,  // Enable Wakeup pin WKUP4 When this bit is set, the external wakeup pin WKUP4 is enabled and
							   // triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The
							   // active edge is configured via the WP4 bit in the PWR_CR4 register.
	PWR_CR3_EWUP3 = 1UL << 2,  // Enable Wakeup pin WKUP3 When this bit is set, the external wakeup pin WKUP3 is enabled and
							   // triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The
							   // active edge is configured via the WP3 bit in the PWR_CR4 register.
	PWR_CR3_EWUP2 = 1UL << 1,  // Enable Wakeup pin WKUP2 When this bit is set, the external wakeup pin WKUP2 is enabled and
							   // triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The
							   // active edge is configured via the WP2 bit in the PWR_CR4 register.
	PWR_CR3_EWUP1 = 1UL << 0,  // Enable Wakeup pin WKUP1 When this bit is set, the external wakeup pin WKUP1 is enabled and
							   // triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The
							   // active edge is configured via the WP1 bit in the PWR_CR4 register.
};

// PWR->CR4 Power control register 4
enum {
	PWR_CR4_VBRS = 1UL << 9,  // V<sub>BAT</sub> battery charging resistor selection
	PWR_CR4_VBE	 = 1UL << 8,  // V<sub>BAT</sub> battery charging enable
	PWR_CR4_WP5	 = 1UL << 4,  // Wakeup pin WKUP5 polarity This bit defines the polarity used for an event detection on external
							  // wake-up pin, WKUP5
	PWR_CR4_WP4 = 1UL << 3,	  // Wakeup pin WKUP4 polarity This bit defines the polarity used for an event detection on external
							  // wake-up pin, WKUP4
	PWR_CR4_WP3 = 1UL << 2,	  // Wakeup pin WKUP3 polarity This bit defines the polarity used for an event detection on external
							  // wake-up pin, WKUP3
	PWR_CR4_WP2 = 1UL << 1,	  // Wakeup pin WKUP2 polarity This bit defines the polarity used for an event detection on external
							  // wake-up pin, WKUP2
	PWR_CR4_WP1 = 1UL << 0,	  // Wakeup pin WKUP1 polarity This bit defines the polarity used for an event detection on external
							  // wake-up pin, WKUP1
};

// PWR->SR1 Power status register 1
enum {
	PWR_SR1_WUFI = 1UL << 15,  // Wakeup flag internal This bit is set when a wakeup is detected on the internal wakeup line. It is
							   // cleared when all internal wakeup sources are cleared.
	PWR_SR1_SBF =
			1UL << 8,  // Standby flag This bit is set by hardware when the device enters the Standby mode and is cleared by setting
					   // the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
	PWR_SR1_WUF5 = 1UL << 4,  // Wakeup flag 5 This bit is set when a wakeup event is detected on wakeup pin, WKUP5. It is cleared
							  // by writing 1 in the CWUF5 bit of the PWR_SCR register.
	PWR_SR1_WUF4 = 1UL << 3,  // Wakeup flag 4 This bit is set when a wakeup event is detected on wakeup pin,WKUP4. It is cleared by
							  // writing 1 in the CWUF4 bit of the PWR_SCR register.
	PWR_SR1_WUF3 = 1UL << 2,  // Wakeup flag 3 This bit is set when a wakeup event is detected on wakeup pin, WKUP3. It is cleared
							  // by writing 1 in the CWUF3 bit of the PWR_SCR register.
	PWR_SR1_WUF2 = 1UL << 1,  // Wakeup flag 2 This bit is set when a wakeup event is detected on wakeup pin, WKUP2. It is cleared
							  // by writing 1 in the CWUF2 bit of the PWR_SCR register.
	PWR_SR1_WUF1 = 1UL << 0,  // Wakeup flag 1 This bit is set when a wakeup event is detected on wakeup pin, WKUP1. It is cleared
							  // by writing 1 in the CWUF1 bit of the PWR_SCR register.
};

// PWR->SR2 Power status register 2
enum {
	PWR_SR2_PVMO2 = 1UL << 15,	// Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.8 V Note: PVMO2 is cleared when PVM2
								// is disabled (PVME = 0). After enabling PVM2, the PVM2 output is valid after the PVM2 wakeup time.
	PWR_SR2_PVMO1 = 1UL << 14,	// Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.62 V Note: PVMO1 is cleared when PVM1
								// is disabled (PVME = 0). After enabling PVM1, the PVM1 output is valid after the PVM1 wakeup time.
	PWR_SR2_PVDO = 1UL << 11,	// Programmable voltage detector output
	PWR_SR2_VOSF = 1UL << 10,	// Voltage scaling flag A delay is required for the internal regulator to be ready after the voltage
							   // scaling has been changed. VOSF indicates that the regulator reached the voltage level defined with
							   // VOS bits of the PWR_CR1 register.
	PWR_SR2_REGLPF = 1UL << 9,	// Low-power regulator flag This bit is set by hardware when the MCU is in Low-power run mode. When
								// the MCU exits the Low-power run mode, this bit remains at 1 until the regulator is ready in main
								// mode. A polling on this bit must be done before increasing the product frequency. This bit is
								// cleared by hardware when the regulator is ready.
	PWR_SR2_REGLPS = 1UL << 8,	// Low-power regulator started This bit provides the information whether the low-power regulator is
								// ready after a power-on reset or a Standby/Shutdown. If the Standby mode is entered while REGLPS
								// bit is still cleared, the wakeup from Standby mode time may be increased.
};

// PWR->SCR Power status clear register
enum {
	PWR_SCR_CSBF  = 1UL << 8,  // Clear standby flag Setting this bit clears the SBF flag in the PWR_SR1 register.
	PWR_SCR_CWUF5 = 1UL << 4,  // Clear wakeup flag 5 Setting this bit clears the WUF5 flag in the PWR_SR1 register.
	PWR_SCR_CWUF4 = 1UL << 3,  // Clear wakeup flag 4 Setting this bit clears the WUF4 flag in the PWR_SR1 register.
	PWR_SCR_CWUF3 = 1UL << 2,  // Clear wakeup flag 3 Setting this bit clears the WUF3 flag in the PWR_SR1 register.
	PWR_SCR_CWUF2 = 1UL << 1,  // Clear wakeup flag 2 Setting this bit clears the WUF2 flag in the PWR_SR1 register.
	PWR_SCR_CWUF1 = 1UL << 0,  // Clear wakeup flag 1 Setting this bit clears the WUF1 flag in the PWR_SR1 register.
};

// PWR->PUCRA Power Port A pull-up control register
enum {
	PWR_PUCRA_PU15 = 1UL << 15,	 // Port A pull-up bit 15 When set, this bit activates the pull-up on PA[15] when APC bit is set in
								 // PWR_CR3 register. The pull-up is not activated if the corresponding PD15 bit is also set.
	PWR_PUCRA_PU13 = 1UL << 13,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU12 = 1UL << 12,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU11 = 1UL << 11,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU10 = 1UL << 10,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU9 = 1UL << 9,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU8 = 1UL << 8,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU7 = 1UL << 7,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU6 = 1UL << 6,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU5 = 1UL << 5,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU4 = 1UL << 4,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU3 = 1UL << 3,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU2 = 1UL << 2,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU1 = 1UL << 1,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU0 = 1UL << 0,	 // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is
								 // set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
};

// PWR->PDCRA Power Port A pull-down control register
enum {
	PWR_PDCRA_PD14 = 1UL << 14,	 // Port A pull-down bit 14 When set, this bit activates the pull-down on PA[14] when APC bit is set
								 // in PWR_CR3 register.
	PWR_PDCRA_PD12 = 1UL << 12,	 // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRA_PD11 = 1UL << 11,	 // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRA_PD10 = 1UL << 10,	 // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRA_PD9 = 1UL << 9,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD8 = 1UL << 8,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD7 = 1UL << 7,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD6 = 1UL << 6,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD5 = 1UL << 5,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD4 = 1UL << 4,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD3 = 1UL << 3,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD2 = 1UL << 2,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD1 = 1UL << 1,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRA_PD0 = 1UL << 0,  // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit
							   // is set in PWR_CR3 register.
};

// PWR->PDCRB Power Port B pull-down control register
enum {
	PWR_PDCRB_PD15 = 1UL << 15,	 // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRB_PD14 = 1UL << 14,	 // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRB_PD13 = 1UL << 13,	 // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRB_PD12 = 1UL << 12,	 // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRB_PD11 = 1UL << 11,	 // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRB_PD10 = 1UL << 10,	 // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC
								 // bit is set in PWR_CR3 register.
	PWR_PDCRB_PD9 = 1UL << 9,  // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD8 = 1UL << 8,  // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD7 = 1UL << 7,  // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD6 = 1UL << 6,  // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD5 = 1UL << 5,  // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD3 = 1UL << 3,  // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD2 = 1UL << 2,  // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD1 = 1UL << 1,  // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
	PWR_PDCRB_PD0 = 1UL << 0,  // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit
							   // is set in PWR_CR3 register.
};

// PWR->PUCRG Power Port G pull-up control register
enum {
	PWR_PUCRG_PUX = ((1UL << 11) - 1)
					<< 0,  // Merged Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit
						   // is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
};
inline void pwr_pucrg_set_pux(struct PWR_Type *p, uint32_t val) {
	p->PUCRG = (p->PUCRG & ~PWR_PUCRG_PUX) | ((val << 0) & PWR_PUCRG_PUX);
}
inline uint32_t pwr_pucrg_get_pux(struct PWR_Type *p) { return (p->PUCRG & PWR_PUCRG_PUX) >> 0; }

// PWR->PDCRG Power Port G pull-down control register
enum {
	PWR_PDCRG_PDX = ((1UL << 11) - 1) << 0,	 // Merged Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down
											 // on PG[y] when APC bit is set in PWR_CR3 register.
};
inline void pwr_pdcrg_set_pdx(struct PWR_Type *p, uint32_t val) {
	p->PDCRG = (p->PDCRG & ~PWR_PDCRG_PDX) | ((val << 0) & PWR_PDCRG_PDX);
}
inline uint32_t pwr_pdcrg_get_pdx(struct PWR_Type *p) { return (p->PDCRG & PWR_PDCRG_PDX) >> 0; }

// PWR->CR5 Power control register
enum {
	PWR_CR5_R1MODE =
			1UL << 8,  // Main regular range 1 mode This bit is only valid for the main regulator in range 1 and has no effect on
					   // range 2. It is recommended to reset this bit when the system frequency is greater than 150 MHz. Refer to
};

/* QuadSPI interface */
struct QUADSPI_Type {
	__IO uint32_t CR;			 // @0 control register
	__IO uint32_t DCR;			 // @4 device configuration register
	__I uint16_t  SR;			 // @8 status register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint8_t  FCR;			 // @12 flag clear register
	uint8_t		  RESERVED1[3];	 // @13
	__IO uint32_t DLR;			 // @16 data length register
	__IO uint32_t CCR;			 // @20 communication configuration register
	__IO uint32_t AR;			 // @24 address register
	__IO uint32_t ABR;			 // @28 ABR
	__IO uint32_t DR;			 // @32 data register
	__IO uint32_t PSMKR;		 // @36 polling status mask register
	__IO uint32_t PSMAR;		 // @40 polling status match register
	__IO uint16_t PIR;			 // @44 polling interval register
	uint8_t		  RESERVED2[2];	 // @46
	__IO uint16_t LPTR;			 // @48 low-power timeout register
};

// QUADSPI->CR control register
enum {
	QUADSPI_CR_PRESCALER = ((1UL << 8) - 1) << 24,	// Clock prescaler
	QUADSPI_CR_PMM		 = 1UL << 23,				// Polling match mode
	QUADSPI_CR_APMS		 = 1UL << 22,				// Automatic poll mode stop
	QUADSPI_CR_TOIE		 = 1UL << 20,				// TimeOut interrupt enable
	QUADSPI_CR_SMIE		 = 1UL << 19,				// Status match interrupt enable
	QUADSPI_CR_FTIE		 = 1UL << 18,				// FIFO threshold interrupt enable
	QUADSPI_CR_TCIE		 = 1UL << 17,				// Transfer complete interrupt enable
	QUADSPI_CR_TEIE		 = 1UL << 16,				// Transfer error interrupt enable
	QUADSPI_CR_FTHRES	 = ((1UL << 5) - 1) << 8,	// IFO threshold level
	QUADSPI_CR_FSEL		 = 1UL << 7,				// FSEL
	QUADSPI_CR_DFM		 = 1UL << 6,				// DFM
	QUADSPI_CR_SSHIFT	 = 1UL << 4,				// Sample shift
	QUADSPI_CR_TCEN		 = 1UL << 3,				// Timeout counter enable
	QUADSPI_CR_DMAEN	 = 1UL << 2,				// DMA enable
	QUADSPI_CR_ABORT	 = 1UL << 1,				// Abort request
	QUADSPI_CR_EN		 = 1UL << 0,				// Enable
};
inline void quadspi_cr_set_prescaler(struct QUADSPI_Type *p, uint32_t val) {
	p->CR = (p->CR & ~QUADSPI_CR_PRESCALER) | ((val << 24) & QUADSPI_CR_PRESCALER);
}
inline void quadspi_cr_set_fthres(struct QUADSPI_Type *p, uint32_t val) {
	p->CR = (p->CR & ~QUADSPI_CR_FTHRES) | ((val << 8) & QUADSPI_CR_FTHRES);
}
inline uint32_t quadspi_cr_get_prescaler(struct QUADSPI_Type *p) { return (p->CR & QUADSPI_CR_PRESCALER) >> 24; }
inline uint32_t quadspi_cr_get_fthres(struct QUADSPI_Type *p) { return (p->CR & QUADSPI_CR_FTHRES) >> 8; }

// QUADSPI->DCR device configuration register
enum {
	QUADSPI_DCR_FSIZE  = ((1UL << 5) - 1) << 16,  // FLASH memory size
	QUADSPI_DCR_CSHT   = ((1UL << 3) - 1) << 8,	  // Chip select high time
	QUADSPI_DCR_CKMODE = 1UL << 0,				  // Mode 0 / mode 3
};
inline void quadspi_dcr_set_fsize(struct QUADSPI_Type *p, uint32_t val) {
	p->DCR = (p->DCR & ~QUADSPI_DCR_FSIZE) | ((val << 16) & QUADSPI_DCR_FSIZE);
}
inline void quadspi_dcr_set_csht(struct QUADSPI_Type *p, uint32_t val) {
	p->DCR = (p->DCR & ~QUADSPI_DCR_CSHT) | ((val << 8) & QUADSPI_DCR_CSHT);
}
inline uint32_t quadspi_dcr_get_fsize(struct QUADSPI_Type *p) { return (p->DCR & QUADSPI_DCR_FSIZE) >> 16; }
inline uint32_t quadspi_dcr_get_csht(struct QUADSPI_Type *p) { return (p->DCR & QUADSPI_DCR_CSHT) >> 8; }

// QUADSPI->SR status register
enum {
	QUADSPI_SR_FLEVEL = ((1UL << 5) - 1) << 8,	// FIFO level
	QUADSPI_SR_BUSY	  = 1UL << 5,				// Busy
	QUADSPI_SR_TOF	  = 1UL << 4,				// Timeout flag
	QUADSPI_SR_SMF	  = 1UL << 3,				// Status match flag
	QUADSPI_SR_FTF	  = 1UL << 2,				// FIFO threshold flag
	QUADSPI_SR_TCF	  = 1UL << 1,				// Transfer complete flag
	QUADSPI_SR_TEF	  = 1UL << 0,				// Transfer error flag
};
inline uint32_t quadspi_sr_get_flevel(struct QUADSPI_Type *p) { return (p->SR & QUADSPI_SR_FLEVEL) >> 8; }

// QUADSPI->FCR flag clear register
enum {
	QUADSPI_FCR_CTOF = 1UL << 4,  // Clear timeout flag
	QUADSPI_FCR_CSMF = 1UL << 3,  // Clear status match flag
	QUADSPI_FCR_CTCF = 1UL << 1,  // Clear transfer complete flag
	QUADSPI_FCR_CTEF = 1UL << 0,  // Clear transfer error flag
};

// QUADSPI->CCR communication configuration register
enum {
	QUADSPI_CCR_DDRM		= 1UL << 31,			   // Double data rate mode
	QUADSPI_CCR_SIOO		= 1UL << 28,			   // Send instruction only once mode
	QUADSPI_CCR_FMODE		= ((1UL << 2) - 1) << 26,  // Functional mode
	QUADSPI_CCR_DMODE		= ((1UL << 2) - 1) << 24,  // Data mode
	QUADSPI_CCR_DCYC		= ((1UL << 5) - 1) << 18,  // Number of dummy cycles
	QUADSPI_CCR_ABSIZE		= ((1UL << 2) - 1) << 16,  // Alternate bytes size
	QUADSPI_CCR_ABMODE		= ((1UL << 2) - 1) << 14,  // Alternate bytes mode
	QUADSPI_CCR_ADSIZE		= ((1UL << 2) - 1) << 12,  // Address size
	QUADSPI_CCR_ADMODE		= ((1UL << 2) - 1) << 10,  // Address mode
	QUADSPI_CCR_IMODE		= ((1UL << 2) - 1) << 8,   // Instruction mode
	QUADSPI_CCR_INSTRUCTION = ((1UL << 8) - 1) << 0,   // Instruction
};
inline void quadspi_ccr_set_fmode(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_FMODE) | ((val << 26) & QUADSPI_CCR_FMODE);
}
inline void quadspi_ccr_set_dmode(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_DMODE) | ((val << 24) & QUADSPI_CCR_DMODE);
}
inline void quadspi_ccr_set_dcyc(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_DCYC) | ((val << 18) & QUADSPI_CCR_DCYC);
}
inline void quadspi_ccr_set_absize(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_ABSIZE) | ((val << 16) & QUADSPI_CCR_ABSIZE);
}
inline void quadspi_ccr_set_abmode(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_ABMODE) | ((val << 14) & QUADSPI_CCR_ABMODE);
}
inline void quadspi_ccr_set_adsize(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_ADSIZE) | ((val << 12) & QUADSPI_CCR_ADSIZE);
}
inline void quadspi_ccr_set_admode(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_ADMODE) | ((val << 10) & QUADSPI_CCR_ADMODE);
}
inline void quadspi_ccr_set_imode(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_IMODE) | ((val << 8) & QUADSPI_CCR_IMODE);
}
inline void quadspi_ccr_set_instruction(struct QUADSPI_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~QUADSPI_CCR_INSTRUCTION) | ((val << 0) & QUADSPI_CCR_INSTRUCTION);
}
inline uint32_t quadspi_ccr_get_fmode(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_FMODE) >> 26; }
inline uint32_t quadspi_ccr_get_dmode(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_DMODE) >> 24; }
inline uint32_t quadspi_ccr_get_dcyc(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_DCYC) >> 18; }
inline uint32_t quadspi_ccr_get_absize(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_ABSIZE) >> 16; }
inline uint32_t quadspi_ccr_get_abmode(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_ABMODE) >> 14; }
inline uint32_t quadspi_ccr_get_adsize(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_ADSIZE) >> 12; }
inline uint32_t quadspi_ccr_get_admode(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_ADMODE) >> 10; }
inline uint32_t quadspi_ccr_get_imode(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_IMODE) >> 8; }
inline uint32_t quadspi_ccr_get_instruction(struct QUADSPI_Type *p) { return (p->CCR & QUADSPI_CCR_INSTRUCTION) >> 0; }

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR;			  // @0 Clock control register
	__IO uint32_t ICSCR;		  // @4 Internal clock sources calibration register
	__IO uint32_t CFGR;			  // @8 Clock configuration register
	__IO uint32_t PLLCFGR;		  // @12 PLL configuration register
	uint8_t		  RESERVED0[8];	  // @16
	__IO uint16_t CIER;			  // @24 Clock interrupt enable register
	uint8_t		  RESERVED1[2];	  // @26
	__IO uint16_t CIFR;			  // @28 Clock interrupt flag register
	uint8_t		  RESERVED2[2];	  // @30
	__IO uint16_t CICR;			  // @32 Clock interrupt clear register
	uint8_t		  RESERVED3[6];	  // @34
	__IO uint16_t AHB1RSTR;		  // @40 AHB1 peripheral reset register
	uint8_t		  RESERVED4[2];	  // @42
	__IO uint32_t AHB2RSTR;		  // @44 AHB2 peripheral reset register
	__IO uint16_t AHB3RSTR;		  // @48 AHB3 peripheral reset register
	uint8_t		  RESERVED5[6];	  // @50
	__IO uint32_t APB1RSTR1;	  // @56 APB1 peripheral reset register 1
	__IO uint16_t APB1RSTR2;	  // @60 APB1 peripheral reset register 2
	uint8_t		  RESERVED6[2];	  // @62
	__IO uint32_t APB2RSTR;		  // @64 APB2 peripheral reset register
	uint8_t		  RESERVED7[4];	  // @68
	__IO uint16_t AHB1ENR;		  // @72 AHB1 peripheral clock enable register
	uint8_t		  RESERVED8[2];	  // @74
	__IO uint32_t AHB2ENR;		  // @76 AHB2 peripheral clock enable register
	__IO uint16_t AHB3ENR;		  // @80 AHB3 peripheral clock enable register
	uint8_t		  RESERVED9[6];	  // @82
	__IO uint32_t APB1ENR1;		  // @88 APB1 peripheral clock enable register 1
	__IO uint16_t APB1ENR2;		  // @92 APB1 peripheral clock enable register 2
	uint8_t		  RESERVED10[2];  // @94
	__IO uint32_t APB2ENR;		  // @96 APB2 peripheral clock enable register
	uint8_t		  RESERVED11[4];  // @100
	__IO uint16_t AHB1SMENR;	  // @104 AHB1 peripheral clocks enable in Sleep and Stop modes register
	uint8_t		  RESERVED12[2];  // @106
	__IO uint32_t AHB2SMENR;	  // @108 AHB2 peripheral clocks enable in Sleep and Stop modes register
	__IO uint16_t AHB3SMENR;	  // @112 AHB3 peripheral clocks enable in Sleep and Stop modes register
	uint8_t		  RESERVED13[6];  // @114
	__IO uint32_t APB1SMENR1;	  // @120 APB1 peripheral clocks enable in Sleep and Stop modes register 1
	__IO uint16_t APB1SMENR2;	  // @124 APB1 peripheral clocks enable in Sleep and Stop modes register 2
	uint8_t		  RESERVED14[2];  // @126
	__IO uint32_t APB2SMENR;	  // @128 APB2 peripheral clocks enable in Sleep and Stop modes register
	uint8_t		  RESERVED15[4];  // @132
	__IO uint32_t CCIPR;		  // @136 Peripherals independent clock configuration register
	uint8_t		  RESERVED16[4];  // @140
	__IO uint32_t BDCR;			  // @144 RTC domain control register
	__IO uint32_t CSR;			  // @148 Control/status register
	__IO uint16_t CRRCR;		  // @152 Clock recovery RC register
	uint8_t		  RESERVED17[2];  // @154
	__IO uint32_t CCIPR2;		  // @156 Peripherals independent clock configuration register
};

// RCC->CR Clock control register
enum {
	RCC_CR_PLLRDY = 1UL << 25,	// Main PLL clock ready flag Set by hardware to indicate that the main PLL is locked.
	RCC_CR_PLLON =
			1UL << 24,	// Main PLL enable Set and cleared by software to enable the main PLL. Cleared by hardware when entering
						// Stop, Standby or Shutdown mode. This bit cannot be reset if the PLL clock is used as the system clock.
	RCC_CR_CSSON = 1UL << 19,	// Clock security system enable Set by software to enable the clock security system. When CSSON is
								// set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by
								// hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
	RCC_CR_HSEBYP = 1UL << 18,	// HSE crystal oscillator bypass Set and cleared by software to bypass the oscillator with an
								// external clock. The external clock must be enabled with the HSEON bit set, to be used by the
								// device. The HSEBYP bit can be written only if the HSE oscillator is disabled.
	RCC_CR_HSERDY = 1UL << 17,	// HSE clock ready flag Set by hardware to indicate that the HSE oscillator is stable. Note: Once
								// the HSEON bit is cleared, HSERDY goes low after 6 HSE clock cycles.
	RCC_CR_HSEON = 1UL << 16,	// HSE clock enable Set and cleared by software. Cleared by hardware to stop the HSE oscillator when
								// entering Stop, Standby or Shutdown mode. This bit cannot be reset if the HSE oscillator is used
								// directly or indirectly as the system clock.
	RCC_CR_HSIRDY = 1UL << 10,	// HSI16 clock ready flag Set by hardware to indicate that HSI16 oscillator is stable. This bit is
								// set only when HSI16 is enabled by software by setting HSION. Note: Once the HSION bit is cleared,
								// HSIRDY goes low after 6 HSI16 clock cycles.
	RCC_CR_HSIKERON = 1UL << 9,	 // HSI16 always enable for peripheral kernels. Set and cleared by software to force HSI16 ON even
								 // in Stop modes. The HSI16 can only feed USARTs and I<sup>2</sup>Cs peripherals configured with
								 // HSI16 as kernel clock. Keeping the HSI16 ON in Stop mode allows to avoid slowing down the
								 // communication speed because of the HSI16 startup time. This bit has no effect on HSION value.
	RCC_CR_HSION =
			1UL << 8,  // HSI16 clock enable Set and cleared by software. Cleared by hardware to stop the HSI16 oscillator when
					   // entering Stop, Standby or Shutdown mode. Set by hardware to force the HSI16 oscillator ON when STOPWUCK=1
					   // or HSIASFS = 1 when leaving Stop modes, or in case of failure of the HSE crystal oscillator. This bit is
					   // set by hardware if the HSI16 is used directly or indirectly as system clock.
};

// RCC->ICSCR Internal clock sources calibration register
enum {
	RCC_ICSCR_HSITRIM =
			((1UL << 7) - 1) << 24,	 // HSI16 clock trimming These bits provide an additional user-programmable trimming value that
									 // is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage
									 // and temperature that influence the frequency of the HSI16. The default value is 16, which,
									 // when added to the HSICAL value, should trim the HSI16 to 16 MHz  1 %.
	RCC_ICSCR_HSICAL =
			((1UL << 8) - 1)
			<< 16,	// HSI16 clock calibration These bits are initialized at startup with the factory-programmed HSI16 calibration
					// trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.
};
inline void rcc_icscr_set_hsitrim(struct RCC_Type *p, uint32_t val) {
	p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSITRIM) | ((val << 24) & RCC_ICSCR_HSITRIM);
}
inline void rcc_icscr_set_hsical(struct RCC_Type *p, uint32_t val) {
	p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSICAL) | ((val << 16) & RCC_ICSCR_HSICAL);
}
inline uint32_t rcc_icscr_get_hsitrim(struct RCC_Type *p) { return (p->ICSCR & RCC_ICSCR_HSITRIM) >> 24; }
inline uint32_t rcc_icscr_get_hsical(struct RCC_Type *p) { return (p->ICSCR & RCC_ICSCR_HSICAL) >> 16; }

// RCC->CFGR Clock configuration register
enum {
	RCC_CFGR_MCOPRE = ((1UL << 3) - 1)
					  << 28,  // Microcontroller clock output prescaler These bits are set and cleared by software. It is highly
							  // recommended to change this prescaler before MCO output is enabled. Others: not allowed
	RCC_CFGR_MCOSEL =
			((1UL << 4) - 1) << 24,	 // Microcontroller clock output Set and cleared by software. Others: Reserved Note: This clock
									 // output may have some truncated cycles at startup or during MCO clock source switching.
	RCC_CFGR_PPRE2 = ((1UL << 3) - 1) << 11,  // APB2 prescaler Set and cleared by software to control the division factor of the
											  // APB2 clock (PCLK2). 0xx: HCLK not divided
	RCC_CFGR_PPRE1 = ((1UL << 3) - 1) << 8,	  // APB1 prescaler Set and cleared by software to control the division factor of the
											  // APB1 clock (PCLK1). 0xx: HCLK not divided
	RCC_CFGR_HPRE =
			((1UL << 4) - 1)
			<< 4,  // AHB prescaler Set and cleared by software to control the division factor of the AHB clock. Note: Depending on
				   // the device voltage range, the software has to set correctly these bits to ensure that the system frequency
				   // does not exceed the maximum allowed frequency (for more details please refer to Section 6.1.5: Dynamic voltage
				   // scaling management). After a write operation to these bits and before decreasing the voltage range, this
				   // register must be read to be sure that the new value has been taken into account. 0xxx: SYSCLK not divided
	RCC_CFGR_SWS =
			((1UL << 2) - 1)
			<< 2,  // System clock switch status Set and cleared by hardware to indicate which clock source is used as system clock.
	RCC_CFGR_SW = ((1UL << 2) - 1) << 0,  // System clock switch Set and cleared by software to select system clock source (SYSCLK).
										  // Configured by hardware to force HSI16 oscillator selection when exiting stop and
										  // standby modes or in case of failure of the HSE oscillator.
};
inline void rcc_cfgr_set_mcopre(struct RCC_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_MCOPRE) | ((val << 28) & RCC_CFGR_MCOPRE);
}
inline void rcc_cfgr_set_mcosel(struct RCC_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_MCOSEL) | ((val << 24) & RCC_CFGR_MCOSEL);
}
inline void rcc_cfgr_set_ppre2(struct RCC_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE2) | ((val << 11) & RCC_CFGR_PPRE2);
}
inline void rcc_cfgr_set_ppre1(struct RCC_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE1) | ((val << 8) & RCC_CFGR_PPRE1);
}
inline void rcc_cfgr_set_hpre(struct RCC_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_HPRE) | ((val << 4) & RCC_CFGR_HPRE);
}
inline void rcc_cfgr_set_sws(struct RCC_Type *p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val << 2) & RCC_CFGR_SWS);
}
inline void rcc_cfgr_set_sw(struct RCC_Type *p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val << 0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mcopre(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_MCOPRE) >> 28; }
inline uint32_t rcc_cfgr_get_mcosel(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_MCOSEL) >> 24; }
inline uint32_t rcc_cfgr_get_ppre2(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_PPRE2) >> 11; }
inline uint32_t rcc_cfgr_get_ppre1(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_PPRE1) >> 8; }
inline uint32_t rcc_cfgr_get_hpre(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_HPRE) >> 4; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_SWS) >> 2; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type *p) { return (p->CFGR & RCC_CFGR_SW) >> 0; }

// RCC->PLLCFGR PLL configuration register
enum {
	RCC_PLLCFGR_PLLPDIV = ((1UL << 5) - 1) << 27,  // Main PLLP division factor Set and cleared by software to control the PLL P
												   // frequency. PLL P output clock frequency = VCO frequency / PLLPDIV. ....
	RCC_PLLCFGR_PLLR =
			((1UL << 2) - 1)
			<< 25,	// Main PLL division factor for PLL R clock (system clock) Set and cleared by software to control the
					// frequency of the main PLL output clock PLLCLK. This output can be selected as system clock. These bits can be
					// written only if PLL is disabled. PLL R output clock frequency = VCO frequency / PLLR with PLLR = 2, 4, 6,
					// or 8 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
	RCC_PLLCFGR_PLLREN =
			1UL
			<< 24,	// PLL R clock output enable Set and reset by software to enable the PLL R clock output of the PLL (used as
					// system clock). This bit cannot be written when PLL R clock output of the PLL is used as System Clock. In
					// order to save power, when the PLL R clock output of the PLL is not used, the value of PLLREN should be 0.
	RCC_PLLCFGR_PLLQ =
			((1UL << 2) - 1)
			<< 21,	// Main PLL division factor for PLL Q clock. Set and cleared by software to control the frequency of the main
					// PLL output clock PLL Q clock. This output can be selected for USB, RNG, SAI (48 MHz clock). These bits can
					// be written only if PLL is disabled. PLL Q output clock frequency = VCO frequency / PLLQ with PLLQ = 2, 4,
					// 6, or 8 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
	RCC_PLLCFGR_PLLQEN =
			1UL
			<< 20,	// Main PLL Q clock output enable Set and reset by software to enable the PLL Q clock output of the PLL. In
					// order to save power, when the PLL Q clock output of the PLL is not used, the value of PLLQEN should be 0.
	RCC_PLLCFGR_PLLP =
			1UL << 17,	// Main PLL division factor for PLL P clock. Set and cleared by software to control the frequency of the
						// main PLL output clock PLL P clock. These bits can be written only if PLL is disabled. When the
						// PLLPDIV[4:0] is set to 00000PLL P output clock frequency = VCO frequency / PLLP with PLLP =7, or 17
						// Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
	RCC_PLLCFGR_PLLPEN = 1UL << 16,	 // Main PLL PLL P clock output enable Set and reset by software to enable the PLL P clock
									 // output of the PLL. In order to save power, when the PLL P clock output of the PLL is not
									 // used, the value of PLLPEN should be 0.
	RCC_PLLCFGR_PLLN =
			((1UL << 7) - 1)
			<< 8,  // Main PLL multiplication factor for VCO Set and cleared by software to control the multiplication factor of the
				   // VCO. These bits can be written only when the PLL is disabled. VCO output frequency = VCO input frequency x
				   // PLLN with 8 =< PLLN =< 127 ... ... Note: The software has to set correctly these bits to assure that the VCO
				   // output frequency is within the range defined in the device datasheet.
	RCC_PLLCFGR_PLLM =
			((1UL << 4) - 1)
			<< 4,  // Division factor for the main PLL input clock Set and cleared by software to divide the PLL input clock before
				   // the VCO. These bits can be written only when all PLLs are disabled. VCO input frequency = PLL input clock
				   // frequency / PLLM with 1 <= PLLM <= 16 ... Note: The software has to set these bits correctly to ensure that
				   // the VCO input frequency is within the range defined in the device datasheet.
	RCC_PLLCFGR_PLLSRC =
			((1UL << 2) - 1)
			<< 0,  // Main PLL entry clock source Set and cleared by software to select PLL clock source. These bits can be written
				   // only when PLL is disabled. In order to save power, when no PLL is used, the value of PLLSRC should be 00.
};
inline void rcc_pllcfgr_set_pllpdiv(struct RCC_Type *p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLPDIV) | ((val << 27) & RCC_PLLCFGR_PLLPDIV);
}
inline void rcc_pllcfgr_set_pllr(struct RCC_Type *p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLR) | ((val << 25) & RCC_PLLCFGR_PLLR);
}
inline void rcc_pllcfgr_set_pllq(struct RCC_Type *p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | ((val << 21) & RCC_PLLCFGR_PLLQ);
}
inline void rcc_pllcfgr_set_plln(struct RCC_Type *p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLN) | ((val << 8) & RCC_PLLCFGR_PLLN);
}
inline void rcc_pllcfgr_set_pllm(struct RCC_Type *p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLM) | ((val << 4) & RCC_PLLCFGR_PLLM);
}
inline void rcc_pllcfgr_set_pllsrc(struct RCC_Type *p, uint32_t val) {
	p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLSRC) | ((val << 0) & RCC_PLLCFGR_PLLSRC);
}
inline uint32_t rcc_pllcfgr_get_pllpdiv(struct RCC_Type *p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLPDIV) >> 27; }
inline uint32_t rcc_pllcfgr_get_pllr(struct RCC_Type *p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25; }
inline uint32_t rcc_pllcfgr_get_pllq(struct RCC_Type *p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLQ) >> 21; }
inline uint32_t rcc_pllcfgr_get_plln(struct RCC_Type *p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8; }
inline uint32_t rcc_pllcfgr_get_pllm(struct RCC_Type *p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4; }
inline uint32_t rcc_pllcfgr_get_pllsrc(struct RCC_Type *p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 0; }

// RCC->CIER Clock interrupt enable register
enum {
	RCC_CIER_HSI48RDYIE = 1UL << 10,  // HSI48 ready interrupt enable Set and cleared by software to enable/disable interrupt caused
									  // by the internal HSI48 oscillator.
	RCC_CIER_LSECSSIE = 1UL << 9,	  // LSE clock security system interrupt enable Set and cleared by software to enable/disable
									  // interrupt caused by the clock security system on LSE.
	RCC_CIER_PLLRDYIE =
			1UL << 5,  // PLL ready interrupt enable Set and cleared by software to enable/disable interrupt caused by PLL lock.
	RCC_CIER_HSERDYIE = 1UL << 4,  // HSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by
								   // the HSE oscillator stabilization.
	RCC_CIER_HSIRDYIE = 1UL << 3,  // HSI16 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by
								   // the HSI16 oscillator stabilization.
	RCC_CIER_LSERDYIE = 1UL << 1,  // LSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by
								   // the LSE oscillator stabilization.
	RCC_CIER_LSIRDYIE = 1UL << 0,  // LSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by
								   // the LSI oscillator stabilization.
};

// RCC->CIFR Clock interrupt flag register
enum {
	RCC_CIFR_HSI48RDYF = 1UL << 10,	 // HSI48 ready interrupt flag Set by hardware when the HSI48 clock becomes stable and
									 // HSI48RDYIE is set in a response to setting the HSI48ON (refer to Clock recovery RC register
									 // (RCC_CRRCR)). Cleared by software setting the HSI48RDYC bit.
	RCC_CIFR_LSECSSF = 1UL << 9,  // LSE Clock security system interrupt flag Set by hardware when a failure is detected in the LSE
								  // oscillator. Cleared by software setting the LSECSSC bit.
	RCC_CIFR_CSSF = 1UL << 8,	  // Clock security system interrupt flag Set by hardware when a failure is detected in the HSE
								  // oscillator. Cleared by software setting the CSSC bit.
	RCC_CIFR_PLLRDYF = 1UL << 5,  // PLL ready interrupt flag Set by hardware when the PLL locks and PLLRDYDIE is set. Cleared by
								  // software setting the PLLRDYC bit.
	RCC_CIFR_HSERDYF = 1UL << 4,  // HSE ready interrupt flag Set by hardware when the HSE clock becomes stable and HSERDYDIE is
								  // set. Cleared by software setting the HSERDYC bit.
	RCC_CIFR_HSIRDYF = 1UL << 3,  // HSI16 ready interrupt flag Set by hardware when the HSI16 clock becomes stable and HSIRDYDIE is
								  // set in a response to setting the HSION (refer to Clock control register (RCC_CR)). When HSION
								  // is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this
								  // bit is not set and no interrupt is generated. Cleared by software setting the HSIRDYC bit.
	RCC_CIFR_LSERDYF = 1UL << 1,  // LSE ready interrupt flag Set by hardware when the LSE clock becomes stable and LSERDYDIE is
								  // set. Cleared by software setting the LSERDYC bit.
	RCC_CIFR_LSIRDYF = 1UL << 0,  // LSI ready interrupt flag Set by hardware when the LSI clock becomes stable and LSIRDYDIE is
								  // set. Cleared by software setting the LSIRDYC bit.
};

// RCC->CICR Clock interrupt clear register
enum {
	RCC_CICR_HSI48RDYC =
			1UL << 10,	// HSI48 oscillator ready interrupt clear This bit is set by software to clear the HSI48RDYF flag.
	RCC_CICR_LSECSSC =
			1UL << 9,  // LSE Clock security system interrupt clear This bit is set by software to clear the LSECSSF flag.
	RCC_CICR_CSSC	 = 1UL << 8,  // Clock security system interrupt clear This bit is set by software to clear the CSSF flag.
	RCC_CICR_PLLRDYC = 1UL << 5,  // PLL ready interrupt clear This bit is set by software to clear the PLLRDYF flag.
	RCC_CICR_HSERDYC = 1UL << 4,  // HSE ready interrupt clear This bit is set by software to clear the HSERDYF flag.
	RCC_CICR_HSIRDYC = 1UL << 3,  // HSI16 ready interrupt clear This bit is set software to clear the HSIRDYF flag.
	RCC_CICR_LSERDYC = 1UL << 1,  // LSE ready interrupt clear This bit is set by software to clear the LSERDYF flag.
	RCC_CICR_LSIRDYC = 1UL << 0,  // LSI ready interrupt clear This bit is set by software to clear the LSIRDYF flag.
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_CRCRST	  = 1UL << 12,	 // CRC reset Set and cleared by software.
	RCC_AHB1RSTR_FLASHRST = 1UL << 8,	 // Flash memory interface reset Set and cleared by software. This bit can be activated only
										 // when the Flash memory is in power down mode.
	RCC_AHB1RSTR_FMACRST	= 1UL << 4,	 // Set and cleared by software
	RCC_AHB1RSTR_CORDICRST	= 1UL << 3,	 // Set and cleared by software
	RCC_AHB1RSTR_DMAMUX1RST = 1UL << 2,	 // Set and cleared by software.
	RCC_AHB1RSTR_DMA2RST	= 1UL << 1,	 // DMA2 reset Set and cleared by software.
	RCC_AHB1RSTR_DMA1RST	= 1UL << 0,	 // DMA1 reset Set and cleared by software.
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_RNGRST	   = 1UL << 26,	 // RNG reset Set and cleared by software.
	RCC_AHB2RSTR_AESRST	   = 1UL << 24,	 // AESRST reset Set and cleared by software.
	RCC_AHB2RSTR_DAC4RST   = 1UL << 19,	 // DAC4 reset Set and cleared by software.
	RCC_AHB2RSTR_DAC3RST   = 1UL << 18,	 // DAC3 reset Set and cleared by software.
	RCC_AHB2RSTR_DAC2RST   = 1UL << 17,	 // DAC2 reset Set and cleared by software.
	RCC_AHB2RSTR_DAC1RST   = 1UL << 16,	 // DAC1 reset Set and cleared by software.
	RCC_AHB2RSTR_ADC345RST = 1UL << 14,	 // ADC345 reset Set and cleared by software.
	RCC_AHB2RSTR_ADC12RST  = 1UL << 13,	 // ADC12 reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOGRST  = 1UL << 6,	 // IO port G reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOFRST  = 1UL << 5,	 // IO port F reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOERST  = 1UL << 4,	 // IO port E reset Set and cleared by software.
	RCC_AHB2RSTR_GPIODRST  = 1UL << 3,	 // IO port D reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOCRST  = 1UL << 2,	 // IO port C reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOBRST  = 1UL << 1,	 // IO port B reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOARST  = 1UL << 0,	 // IO port A reset Set and cleared by software.
};

// RCC->AHB3RSTR AHB3 peripheral reset register
enum {
	RCC_AHB3RSTR_QSPIRST = 1UL << 8,  // QUADSPI reset Set and cleared by software.
	RCC_AHB3RSTR_FMCRST	 = 1UL << 0,  // Flexible static memory controller reset Set and cleared by software.
};

// RCC->APB1RSTR1 APB1 peripheral reset register 1
enum {
	RCC_APB1RSTR1_LPTIM1RST = 1UL << 31,  // Low Power Timer 1 reset Set and cleared by software.
	RCC_APB1RSTR1_I2C3RST	= 1UL << 30,  // I2C3 reset Set and cleared by software.
	RCC_APB1RSTR1_PWRRST	= 1UL << 28,  // Power interface reset Set and cleared by software.
	RCC_APB1RSTR1_FDCANRST	= 1UL << 25,  // FDCAN reset Set and reset by software.
	RCC_APB1RSTR1_USBRST	= 1UL << 23,  // USB device reset Set and reset by software.
	RCC_APB1RSTR1_I2C2RST	= 1UL << 22,  // I2C2 reset Set and cleared by software.
	RCC_APB1RSTR1_I2C1RST	= 1UL << 21,  // I2C1 reset Set and cleared by software.
	RCC_APB1RSTR1_UART5RST	= 1UL << 20,  // UART5 reset Set and cleared by software.
	RCC_APB1RSTR1_UART4RST	= 1UL << 19,  // UART4 reset Set and cleared by software.
	RCC_APB1RSTR1_USART3RST = 1UL << 18,  // USART3 reset Set and cleared by software.
	RCC_APB1RSTR1_USART2RST = 1UL << 17,  // USART2 reset Set and cleared by software.
	RCC_APB1RSTR1_SPI3RST	= 1UL << 15,  // SPI3 reset Set and cleared by software.
	RCC_APB1RSTR1_SPI2RST	= 1UL << 14,  // SPI2 reset Set and cleared by software.
	RCC_APB1RSTR1_CRSRST	= 1UL << 8,	  // CRS reset Set and cleared by software.
	RCC_APB1RSTR1_TIM7RST	= 1UL << 5,	  // TIM7 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM6RST	= 1UL << 4,	  // TIM6 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM5RST	= 1UL << 3,	  // TIM5 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM4RST	= 1UL << 2,	  // TIM3 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM3RST	= 1UL << 1,	  // TIM3 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM2RST	= 1UL << 0,	  // TIM2 timer reset Set and cleared by software.
};

// RCC->APB1RSTR2 APB1 peripheral reset register 2
enum {
	RCC_APB1RSTR2_UCPD1RST	 = 1UL << 8,  // UCPD1 reset Set and cleared by software.
	RCC_APB1RSTR2_I2C4RST	 = 1UL << 1,  // I2C4 reset Set and cleared by software
	RCC_APB1RSTR2_LPUART1RST = 1UL << 0,  // Low-power UART 1 reset Set and cleared by software.
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_HRTIM1RST = 1UL << 26,	 // HRTIM1 reset Set and cleared by software.
	RCC_APB2RSTR_SAI1RST   = 1UL << 21,	 // Serial audio interface 1 (SAI1) reset Set and cleared by software.
	RCC_APB2RSTR_TIM20RST  = 1UL << 20,	 // TIM20 reset Set and cleared by software.
	RCC_APB2RSTR_TIM17RST  = 1UL << 18,	 // TIM17 timer reset Set and cleared by software.
	RCC_APB2RSTR_TIM16RST  = 1UL << 17,	 // TIM16 timer reset Set and cleared by software.
	RCC_APB2RSTR_TIM15RST  = 1UL << 16,	 // TIM15 timer reset Set and cleared by software.
	RCC_APB2RSTR_SPI4RST   = 1UL << 15,	 // SPI4 reset Set and cleared by software.
	RCC_APB2RSTR_USART1RST = 1UL << 14,	 // USART1 reset Set and cleared by software.
	RCC_APB2RSTR_TIM8RST   = 1UL << 13,	 // TIM8 timer reset Set and cleared by software.
	RCC_APB2RSTR_SPI1RST   = 1UL << 12,	 // SPI1 reset Set and cleared by software.
	RCC_APB2RSTR_TIM1RST   = 1UL << 11,	 // TIM1 timer reset Set and cleared by software.
	RCC_APB2RSTR_SYSCFGRST = 1UL << 0,	 // SYSCFG + COMP + OPAMP + VREFBUF reset
};

// RCC->AHB1ENR AHB1 peripheral clock enable register
enum {
	RCC_AHB1ENR_CRCEN	= 1UL << 12,   // CRC clock enable Set and cleared by software.
	RCC_AHB1ENR_FLASHEN = 1UL << 8,	   // Flash memory interface clock enable Set and cleared by software. This bit can be disabled
									   // only when the Flash is in power down mode.
	RCC_AHB1ENR_FMACEN	  = 1UL << 4,  // FMAC enable Set and reset by software.
	RCC_AHB1ENR_CORDICEN  = 1UL << 3,  // CORDIC clock enable Set and reset by software.
	RCC_AHB1ENR_DMAMUX1EN = 1UL << 2,  // DMAMUX1 clock enable Set and reset by software.
	RCC_AHB1ENR_DMA2EN	  = 1UL << 1,  // DMA2 clock enable Set and cleared by software.
	RCC_AHB1ENR_DMA1EN	  = 1UL << 0,  // DMA1 clock enable Set and cleared by software.
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_RNGEN	 = 1UL << 26,  // RNG enable Set and cleared by software.
	RCC_AHB2ENR_AESEN	 = 1UL << 24,  // AES clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC4EN	 = 1UL << 19,  // DAC4 clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC3EN	 = 1UL << 18,  // DAC3 clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC2EN	 = 1UL << 17,  // DAC2 clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC1EN	 = 1UL << 16,  // DAC1 clock enable Set and cleared by software.
	RCC_AHB2ENR_ADC345EN = 1UL << 14,  // ADC345 clock enable Set and cleared by software
	RCC_AHB2ENR_ADC12EN	 = 1UL << 13,  // ADC12 clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOGEN	 = 1UL << 6,   // IO port G clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOFEN	 = 1UL << 5,   // IO port F clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOEEN	 = 1UL << 4,   // IO port E clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIODEN	 = 1UL << 3,   // IO port D clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOCEN	 = 1UL << 2,   // IO port C clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOBEN	 = 1UL << 1,   // IO port B clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOAEN	 = 1UL << 0,   // IO port A clock enable Set and cleared by software.
};

// RCC->AHB3ENR AHB3 peripheral clock enable register
enum {
	RCC_AHB3ENR_QSPIEN = 1UL << 8,	// QUADSPI memory interface clock enable Set and cleared by software.
	RCC_AHB3ENR_FMCEN  = 1UL << 0,	// Flexible static memory controller clock enable Set and cleared by software.
};

// RCC->APB1ENR1 APB1 peripheral clock enable register 1
enum {
	RCC_APB1ENR1_LPTIM1EN = 1UL << 31,	// Low power timer 1 clock enable Set and cleared by software.
	RCC_APB1ENR1_I2C3EN	  = 1UL << 30,	// I2C3 clock enable Set and cleared by software.
	RCC_APB1ENR1_PWREN	  = 1UL << 28,	// Power interface clock enable Set and cleared by software.
	RCC_APB1ENR1_FDCANEN  = 1UL << 25,	// FDCAN clock enable Set and cleared by software.
	RCC_APB1ENR1_USBEN	  = 1UL << 23,	// USB device clock enable Set and cleared by software.
	RCC_APB1ENR1_I2C2EN	  = 1UL << 22,	// I2C2 clock enable Set and cleared by software.
	RCC_APB1ENR1_I2C1EN	  = 1UL << 21,	// I2C1 clock enable Set and cleared by software.
	RCC_APB1ENR1_UART5EN  = 1UL << 20,	// UART5 clock enable Set and cleared by software.
	RCC_APB1ENR1_UART4EN  = 1UL << 19,	// UART4 clock enable Set and cleared by software.
	RCC_APB1ENR1_USART3EN = 1UL << 18,	// USART3 clock enable Set and cleared by software.
	RCC_APB1ENR1_USART2EN = 1UL << 17,	// USART2 clock enable Set and cleared by software.
	RCC_APB1ENR1_SPI3EN	  = 1UL << 15,	// SPI3 clock enable Set and cleared by software.
	RCC_APB1ENR1_SPI2EN	  = 1UL << 14,	// SPI2 clock enable Set and cleared by software.
	RCC_APB1ENR1_WWDGEN =
			1UL << 11,	// Window watchdog clock enable Set by software to enable the window watchdog clock. Reset by hardware
						// system reset. This bit can also be set by hardware if the WWDG_SW option bit is reset.
	RCC_APB1ENR1_RTCAPBEN = 1UL << 10,	// RTC APB clock enable Set and cleared by software
	RCC_APB1ENR1_CRSEN	  = 1UL << 8,	// CRS Recovery System clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM7EN	  = 1UL << 5,	// TIM7 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM6EN	  = 1UL << 4,	// TIM6 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM5EN	  = 1UL << 3,	// TIM5 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM4EN	  = 1UL << 2,	// TIM4 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM3EN	  = 1UL << 1,	// TIM3 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM2EN	  = 1UL << 0,	// TIM2 timer clock enable Set and cleared by software.
};

// RCC->APB1ENR2 APB1 peripheral clock enable register 2
enum {
	RCC_APB1ENR2_UCPD1EN   = 1UL << 8,	// UCPD1 clock enable Set and cleared by software.
	RCC_APB1ENR2_I2C4EN	   = 1UL << 1,	// I2C4 clock enable Set and cleared by software
	RCC_APB1ENR2_LPUART1EN = 1UL << 0,	// Low power UART 1 clock enable Set and cleared by software.
};

// RCC->APB2ENR APB2 peripheral clock enable register
enum {
	RCC_APB2ENR_HRTIM1EN = 1UL << 26,  // HRTIM1 clock enable Set and cleared by software.
	RCC_APB2ENR_SAI1EN	 = 1UL << 21,  // SAI1 clock enable Set and cleared by software.
	RCC_APB2ENR_TIM20EN	 = 1UL << 20,  // TIM20 timer clock enable Set and cleared by software.
	RCC_APB2ENR_TIM17EN	 = 1UL << 18,  // TIM17 timer clock enable Set and cleared by software.
	RCC_APB2ENR_TIM16EN	 = 1UL << 17,  // TIM16 timer clock enable Set and cleared by software.
	RCC_APB2ENR_TIM15EN	 = 1UL << 16,  // TIM15 timer clock enable Set and cleared by software.
	RCC_APB2ENR_SPI4EN	 = 1UL << 15,  // SPI4 clock enable Set and cleared by software.
	RCC_APB2ENR_USART1EN = 1UL << 14,  // USART1clock enable Set and cleared by software.
	RCC_APB2ENR_TIM8EN	 = 1UL << 13,  // TIM8 timer clock enable Set and cleared by software.
	RCC_APB2ENR_SPI1EN	 = 1UL << 12,  // SPI1 clock enable Set and cleared by software.
	RCC_APB2ENR_TIM1EN	 = 1UL << 11,  // TIM1 timer clock enable Set and cleared by software.
	RCC_APB2ENR_SYSCFGEN = 1UL << 0,   // SYSCFG + COMP + VREFBUF + OPAMP clock enable Set and cleared by software.
};

// RCC->AHB1SMENR AHB1 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB1SMENR_CRCSMEN	= 1UL << 12,  // CRC clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB1SMENR_SRAM1SMEN = 1UL << 9,	  // SRAM1 interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB1SMENR_FLASHSMEN =
			1UL << 8,  // Flash memory interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB1SMENR_FMACSMEN	  = 1UL << 4,  // FMACSM clock enable. Set and cleared by software.
	RCC_AHB1SMENR_CORDICSMEN  = 1UL << 3,  // CORDICSM clock enable. Set and cleared by software.
	RCC_AHB1SMENR_DMAMUX1SMEN = 1UL << 2,  // DMAMUX1 clock enable during Sleep and Stop modes. Set and cleared by software.
	RCC_AHB1SMENR_DMA2SMEN =
			1UL << 1,  // DMA2 clocks enable during Sleep and Stop modes Set and cleared by software during Sleep mode.
	RCC_AHB1SMENR_DMA1SMEN = 1UL << 0,	// DMA1 clocks enable during Sleep and Stop modes Set and cleared by software.
};

// RCC->AHB2SMENR AHB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB2SMENR_RNGEN		 = 1UL << 26,  // RNG enable Set and cleared by software.
	RCC_AHB2SMENR_AESSMEN	 = 1UL << 24,  // AESM clocks enable Set and cleared by software.
	RCC_AHB2SMENR_DAC4SMEN	 = 1UL << 19,  // DAC4 clock enable Set and cleared by software.
	RCC_AHB2SMENR_DAC3SMEN	 = 1UL << 18,  // DAC3 clock enable Set and cleared by software.
	RCC_AHB2SMENR_DAC2SMEN	 = 1UL << 17,  // DAC2 clock enable Set and cleared by software.
	RCC_AHB2SMENR_DAC1SMEN	 = 1UL << 16,  // DAC1 clock enable Set and cleared by software.
	RCC_AHB2SMENR_ADC345SMEN = 1UL << 14,  // ADC345 clock enable Set and cleared by software.
	RCC_AHB2SMENR_ADC12SMEN	 = 1UL << 13,  // ADC12 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_SRAM2SMEN	 = 1UL << 10,  // SRAM2 interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_CCMSRAMSMEN =
			1UL << 9,  // CCM SRAM interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOGSMEN = 1UL << 6,	 // IO port G clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOFSMEN = 1UL << 5,	 // IO port F clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOESMEN = 1UL << 4,	 // IO port E clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIODSMEN = 1UL << 3,	 // IO port D clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOCSMEN = 1UL << 2,	 // IO port C clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOBSMEN = 1UL << 1,	 // IO port B clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOASMEN = 1UL << 0,	 // IO port A clocks enable during Sleep and Stop modes Set and cleared by software.
};

// RCC->AHB3SMENR AHB3 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB3SMENR_QSPISMEN =
			1UL << 8,  // QUADSPI memory interface clock enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB3SMENR_FMCSMEN =
			1UL << 0,  // Flexible static memory controller clocks enable during Sleep and Stop modes Set and cleared by software.
};

// RCC->APB1SMENR1 APB1 peripheral clocks enable in Sleep and Stop modes register 1
enum {
	RCC_APB1SMENR1_LPTIM1SMEN =
			1UL << 31,	// Low power timer 1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_I2C3SMEN	 = 1UL << 30,  // I2C3 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_PWRSMEN	 = 1UL << 28,  // Power interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_FDCANSMEN = 1UL << 25,  // FDCAN clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_USBSMEN	 = 1UL << 23,  // USB device clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_I2C2SMEN	 = 1UL << 22,  // I2C2 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_I2C1SMEN	 = 1UL << 21,  // I2C1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_UART5SMEN = 1UL << 20,  // UART5 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_UART4SMEN = 1UL << 19,  // UART4 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_USART3SMEN = 1UL << 18,	// USART3 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_USART2SMEN = 1UL << 17,	// USART2 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_SPI3SMEN	  = 1UL << 15,	// SPI3 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_SPI2SMEN	  = 1UL << 14,	// SPI2 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_WWDGSMEN = 1UL << 11,  // Window watchdog clocks enable during Sleep and Stop modes Set and cleared by software.
										  // This bit is forced to 1 by hardware when the hardware WWDG option is activated.
	RCC_APB1SMENR1_RTCAPBSMEN = 1UL << 10,	// RTC APB clock enable during Sleep and Stop modes Set and cleared by software
	RCC_APB1SMENR1_CRSSMEN	  = 1UL << 8,	// CRS timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM7SMEN	  = 1UL << 5,	// TIM7 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM6SMEN	  = 1UL << 4,	// TIM6 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM5SMEN	  = 1UL << 3,	// TIM5 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM4SMEN	  = 1UL << 2,	// TIM4 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM3SMEN	  = 1UL << 1,	// TIM3 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM2SMEN	  = 1UL << 0,	// TIM2 timer clocks enable during Sleep and Stop modes Set and cleared by software.
};

// RCC->APB1SMENR2 APB1 peripheral clocks enable in Sleep and Stop modes register 2
enum {
	RCC_APB1SMENR2_UCPD1SMEN = 1UL << 8,  // UCPD1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR2_I2C4SMEN	 = 1UL << 1,  // I2C4 clocks enable during Sleep and Stop modes Set and cleared by software
	RCC_APB1SMENR2_LPUART1SMEN =
			1UL << 0,  // Low power UART 1 clocks enable during Sleep and Stop modes Set and cleared by software.
};

// RCC->APB2SMENR APB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_APB2SMENR_HRTIM1SMEN = 1UL << 26,  // HRTIM1 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SAI1SMEN	 = 1UL << 21,  // SAI1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM20SMEN	 = 1UL << 20,  // TIM20 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM17SMEN	 = 1UL << 18,  // TIM17 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM16SMEN	 = 1UL << 17,  // TIM16 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM15SMEN	 = 1UL << 16,  // TIM15 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SPI4SMEN	 = 1UL << 15,  // SPI4 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_USART1SMEN = 1UL << 14,  // USART1clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM8SMEN	 = 1UL << 13,  // TIM8 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SPI1SMEN	 = 1UL << 12,  // SPI1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM1SMEN	 = 1UL << 11,  // TIM1 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SYSCFGSMEN =
			1UL << 0,  // SYSCFG + COMP + VREFBUF + OPAMP clocks enable during Sleep and Stop modes Set and cleared by software.
};

// RCC->CCIPR Peripherals independent clock configuration register
enum {
	RCC_CCIPR_ADC345SEL = ((1UL << 2) - 1) << 30,  // ADC3/4/5 clock source selection These bits are set and cleared by software to
												   // select the clock source used by the ADC345 interface.
	RCC_CCIPR_ADC12SEL = ((1UL << 2) - 1) << 28,   // ADC1/2 clock source selection These bits are set and cleared by software to
												   // select the clock source used by the ADC interface.
	RCC_CCIPR_CLK48SEL = ((1UL << 2) - 1) << 26,   // 48 MHz clock source selection These bits are set and cleared by software to
												   // select the 48 MHz clock source used by USB device FS and RNG.
	RCC_CCIPR_FDCANSEL = ((1UL << 2) - 1) << 24,   // None
	RCC_CCIPR_I2S23SEL =
			((1UL << 2) - 1)
			<< 22,	// clock source selection These bits are set and cleared by software to select the I2S23 clock source.
	RCC_CCIPR_SAI1SEL = ((1UL << 2) - 1)
						<< 20,	// clock source selection These bits are set and cleared by software to select the SAI clock source.
	RCC_CCIPR_LPTIM1SEL = ((1UL << 2) - 1) << 18,  // Low power timer 1 clock source selection These bits are set and cleared by
												   // software to select the LPTIM1 clock source.
	RCC_CCIPR_I2C3SEL =
			((1UL << 2) - 1)
			<< 16,	// I2C3 clock source selection These bits are set and cleared by software to select the I2C3 clock source.
	RCC_CCIPR_I2C2SEL =
			((1UL << 2) - 1)
			<< 14,	// I2C2 clock source selection These bits are set and cleared by software to select the I2C2 clock source.
	RCC_CCIPR_I2C1SEL =
			((1UL << 2) - 1)
			<< 12,	// I2C1 clock source selection These bits are set and cleared by software to select the I2C1 clock source.
	RCC_CCIPR_LPUART1SEL =
			((1UL << 2) - 1)
			<< 10,	// LPUART1 clock source selection These bits are set and cleared by software to select the LPUART1 clock source.
	RCC_CCIPR_UART5SEL =
			((1UL << 2) - 1)
			<< 8,  // UART5 clock source selection These bits are set and cleared by software to select the UART5 clock source.
	RCC_CCIPR_UART4SEL =
			((1UL << 2) - 1)
			<< 6,  // UART4 clock source selection This bit is set and cleared by software to select the UART4 clock source.
	RCC_CCIPR_USART3SEL =
			((1UL << 2) - 1)
			<< 4,  // USART3 clock source selection This bit is set and cleared by software to select the USART3 clock source.
	RCC_CCIPR_USART2SEL =
			((1UL << 2) - 1)
			<< 2,  // USART2 clock source selection This bit is set and cleared by software to select the USART2 clock source.
	RCC_CCIPR_USART1SEL =
			((1UL << 2) - 1)
			<< 0,  // USART1 clock source selection This bit is set and cleared by software to select the USART1 clock source.
};
inline void rcc_ccipr_set_adc345sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_ADC345SEL) | ((val << 30) & RCC_CCIPR_ADC345SEL);
}
inline void rcc_ccipr_set_adc12sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_ADC12SEL) | ((val << 28) & RCC_CCIPR_ADC12SEL);
}
inline void rcc_ccipr_set_clk48sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_CLK48SEL) | ((val << 26) & RCC_CCIPR_CLK48SEL);
}
inline void rcc_ccipr_set_fdcansel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_FDCANSEL) | ((val << 24) & RCC_CCIPR_FDCANSEL);
}
inline void rcc_ccipr_set_i2s23sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2S23SEL) | ((val << 22) & RCC_CCIPR_I2S23SEL);
}
inline void rcc_ccipr_set_sai1sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_SAI1SEL) | ((val << 20) & RCC_CCIPR_SAI1SEL);
}
inline void rcc_ccipr_set_lptim1sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPTIM1SEL) | ((val << 18) & RCC_CCIPR_LPTIM1SEL);
}
inline void rcc_ccipr_set_i2c3sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C3SEL) | ((val << 16) & RCC_CCIPR_I2C3SEL);
}
inline void rcc_ccipr_set_i2c2sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C2SEL) | ((val << 14) & RCC_CCIPR_I2C2SEL);
}
inline void rcc_ccipr_set_i2c1sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C1SEL) | ((val << 12) & RCC_CCIPR_I2C1SEL);
}
inline void rcc_ccipr_set_lpuart1sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPUART1SEL) | ((val << 10) & RCC_CCIPR_LPUART1SEL);
}
inline void rcc_ccipr_set_uart5sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_UART5SEL) | ((val << 8) & RCC_CCIPR_UART5SEL);
}
inline void rcc_ccipr_set_uart4sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_UART4SEL) | ((val << 6) & RCC_CCIPR_UART4SEL);
}
inline void rcc_ccipr_set_usart3sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART3SEL) | ((val << 4) & RCC_CCIPR_USART3SEL);
}
inline void rcc_ccipr_set_usart2sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART2SEL) | ((val << 2) & RCC_CCIPR_USART2SEL);
}
inline void rcc_ccipr_set_usart1sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART1SEL) | ((val << 0) & RCC_CCIPR_USART1SEL);
}
inline uint32_t rcc_ccipr_get_adc345sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_ADC345SEL) >> 30; }
inline uint32_t rcc_ccipr_get_adc12sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_ADC12SEL) >> 28; }
inline uint32_t rcc_ccipr_get_clk48sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_CLK48SEL) >> 26; }
inline uint32_t rcc_ccipr_get_fdcansel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_FDCANSEL) >> 24; }
inline uint32_t rcc_ccipr_get_i2s23sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_I2S23SEL) >> 22; }
inline uint32_t rcc_ccipr_get_sai1sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_SAI1SEL) >> 20; }
inline uint32_t rcc_ccipr_get_lptim1sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_LPTIM1SEL) >> 18; }
inline uint32_t rcc_ccipr_get_i2c3sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_I2C3SEL) >> 16; }
inline uint32_t rcc_ccipr_get_i2c2sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_I2C2SEL) >> 14; }
inline uint32_t rcc_ccipr_get_i2c1sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_I2C1SEL) >> 12; }
inline uint32_t rcc_ccipr_get_lpuart1sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_LPUART1SEL) >> 10; }
inline uint32_t rcc_ccipr_get_uart5sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_UART5SEL) >> 8; }
inline uint32_t rcc_ccipr_get_uart4sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_UART4SEL) >> 6; }
inline uint32_t rcc_ccipr_get_usart3sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_USART3SEL) >> 4; }
inline uint32_t rcc_ccipr_get_usart2sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_USART2SEL) >> 2; }
inline uint32_t rcc_ccipr_get_usart1sel(struct RCC_Type *p) { return (p->CCIPR & RCC_CCIPR_USART1SEL) >> 0; }

// RCC->BDCR RTC domain control register
enum {
	RCC_BDCR_LSCOSEL = 1UL << 25,  // Low speed clock output selection Set and cleared by software.
	RCC_BDCR_LSCOEN	 = 1UL << 24,  // Low speed clock output enable Set and cleared by software.
	RCC_BDCR_BDRST	 = 1UL << 16,  // RTC domain software reset Set and cleared by software.
	RCC_BDCR_RTCEN	 = 1UL << 15,  // RTC clock enable Set and cleared by software.
	RCC_BDCR_RTCSEL	 = ((1UL << 2) - 1)
					  << 8,		  // RTC clock source selection Set by software to select the clock source for the RTC. Once the RTC
								  // clock source has been selected, it cannot be changed anymore unless the RTC domain is reset, or
								  // unless a failure is detected on LSE (LSECSSD is set). The BDRST bit can be used to reset them.
	RCC_BDCR_LSECSSD = 1UL << 6,  // CSS on LSE failure Detection Set by hardware to indicate when a failure has been detected by
								  // the Clock Security System on the external 32 kHz oscillator (LSE).
	RCC_BDCR_LSECSSON =
			1UL << 5,  // CSS on LSE enable Set by software to enable the Clock Security System on LSE (32 kHz oscillator). LSECSSON
					   // must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by
					   // hardware), and after the RTCSEL bit is selected. Once enabled this bit cannot be disabled, except after a
					   // LSE failure detection (LSECSSD =1). In that case the software MUST disable the LSECSSON bit.
	RCC_BDCR_LSEDRV = ((1UL << 2) - 1) << 3,  // LSE oscillator drive capability Set by software to modulate the LSE oscillators
											  // drive capability. The oscillator is in Xtal mode when it is not in bypass mode.
	RCC_BDCR_LSEBYP = 1UL << 2,	 // LSE oscillator bypass Set and cleared by software to bypass oscillator in debug mode. This bit
								 // can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).
	RCC_BDCR_LSERDY =
			1UL
			<< 1,  // LSE oscillator ready Set and cleared by hardware to indicate when the external 32 kHz oscillator is stable.
				   // After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
	RCC_BDCR_LSEON = 1UL << 0,	// LSE oscillator enable Set and cleared by software.
};
inline void rcc_bdcr_set_rtcsel(struct RCC_Type *p, uint32_t val) {
	p->BDCR = (p->BDCR & ~RCC_BDCR_RTCSEL) | ((val << 8) & RCC_BDCR_RTCSEL);
}
inline void rcc_bdcr_set_lsedrv(struct RCC_Type *p, uint32_t val) {
	p->BDCR = (p->BDCR & ~RCC_BDCR_LSEDRV) | ((val << 3) & RCC_BDCR_LSEDRV);
}
inline uint32_t rcc_bdcr_get_rtcsel(struct RCC_Type *p) { return (p->BDCR & RCC_BDCR_RTCSEL) >> 8; }
inline uint32_t rcc_bdcr_get_lsedrv(struct RCC_Type *p) { return (p->BDCR & RCC_BDCR_LSEDRV) >> 3; }

// RCC->CSR Control/status register
enum {
	RCC_CSR_LPWRRSTF = 1UL << 31,  // Low-power reset flag Set by hardware when a reset occurs due to illegal Stop, Standby or
								   // Shutdown mode entry. Cleared by writing to the RMVF bit.
	RCC_CSR_WWDGRSTF = 1UL << 30,  // Window watchdog reset flag Set by hardware when a window watchdog reset occurs. Cleared by
								   // writing to the RMVF bit.
	RCC_CSR_IWDGRSTF = 1UL << 29,  // Independent window watchdog reset flag Set by hardware when an independent watchdog reset
								   // domain occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_SFTRSTF =
			1UL << 28,	// Software reset flag Set by hardware when a software reset occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_BORRSTF = 1UL << 27,  // BOR flag Set by hardware when a BOR occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_PINRSTF =
			1UL << 26,	// Pin reset flag Set by hardware when a reset from the NRST pin occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_OBLRSTF = 1UL << 25,  // Option byte loader reset flag Set by hardware when a reset from the Option Byte loading occurs.
								  // Cleared by writing to the RMVF bit.
	RCC_CSR_RMVF = 1UL << 23,	  // Remove reset flag Set by software to clear the reset flags.
	RCC_CSR_LSIRDY =
			1UL
			<< 1,  // LSI oscillator ready Set and cleared by hardware to indicate when the LSI oscillator is stable. After the
				   // LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION =
				   // 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
	RCC_CSR_LSION = 1UL << 0,  // LSI oscillator enable Set and cleared by software.
};

// RCC->CRRCR Clock recovery RC register
enum {
	RCC_CRRCR_HSI48CAL = ((1UL << 9) - 1) << 7,	 // HSI48 clock calibration These bits are initialized at startup with the
												 // factory-programmed HSI48 calibration trim value. They are ready only.
	RCC_CRRCR_HSI48RDY = 1UL << 1,	// HSI48 clock ready flag Set by hardware to indicate that HSI48 oscillator is stable. This bit
									// is set only when HSI48 is enabled by software by setting HSI48ON.
	RCC_CRRCR_HSI48ON = 1UL << 0,	// HSI48 clock enable Set and cleared by software. Cleared by hardware to stop the HSI48 when
									// entering in Stop, Standby or Shutdown modes.
};
inline void rcc_crrcr_set_hsi48cal(struct RCC_Type *p, uint32_t val) {
	p->CRRCR = (p->CRRCR & ~RCC_CRRCR_HSI48CAL) | ((val << 7) & RCC_CRRCR_HSI48CAL);
}
inline uint32_t rcc_crrcr_get_hsi48cal(struct RCC_Type *p) { return (p->CRRCR & RCC_CRRCR_HSI48CAL) >> 7; }

// RCC->CCIPR2 Peripherals independent clock configuration register
enum {
	RCC_CCIPR2_QSPISEL = ((1UL << 2) - 1) << 20,  // QUADSPI clock source selection Set and reset by software.
	RCC_CCIPR2_I2C4SEL =
			((1UL << 2) - 1)
			<< 0,  // I2C4 clock source selection These bits are set and cleared by software to select the I2C4 clock source.
};
inline void rcc_ccipr2_set_qspisel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR2 = (p->CCIPR2 & ~RCC_CCIPR2_QSPISEL) | ((val << 20) & RCC_CCIPR2_QSPISEL);
}
inline void rcc_ccipr2_set_i2c4sel(struct RCC_Type *p, uint32_t val) {
	p->CCIPR2 = (p->CCIPR2 & ~RCC_CCIPR2_I2C4SEL) | ((val << 0) & RCC_CCIPR2_I2C4SEL);
}
inline uint32_t rcc_ccipr2_get_qspisel(struct RCC_Type *p) { return (p->CCIPR2 & RCC_CCIPR2_QSPISEL) >> 20; }
inline uint32_t rcc_ccipr2_get_i2c4sel(struct RCC_Type *p) { return (p->CCIPR2 & RCC_CCIPR2_I2C4SEL) >> 0; }

/* Random number generator */
struct RNG_Type {
	__IO uint8_t CR;			// @0 control register
	uint8_t		 RESERVED0[3];	// @1
	__IO uint8_t SR;			// @4 status register
	uint8_t		 RESERVED1[3];	// @5
	__I uint32_t DR;			// @8 data register
};

// RNG->CR control register
enum {
	RNG_CR_CED	 = 1UL << 5,  // Clock error detection
	RNG_CR_IE	 = 1UL << 3,  // Interrupt enable
	RNG_CR_RNGEN = 1UL << 2,  // Random number generator enable
};

// RNG->SR status register
enum {
	RNG_SR_SEIS = 1UL << 6,	 // Seed error interrupt status
	RNG_SR_CEIS = 1UL << 5,	 // Clock error interrupt status
	RNG_SR_SECS = 1UL << 2,	 // Seed error current status
	RNG_SR_CECS = 1UL << 1,	 // Clock error current status
	RNG_SR_DRDY = 1UL << 0,	 // Data ready
};

/* Real-time clock */
struct RTC_Type {
	__IO uint32_t TR;			 // @0 time register
	__IO uint32_t DR;			 // @4 date register
	__I uint16_t  SSR;			 // @8 sub second register
	uint8_t		  RESERVED0[2];	 // @10
	__IO uint32_t ICSR;			 // @12 initialization and status register
	__IO uint32_t PRER;			 // @16 prescaler register
	__IO uint16_t WUTR;			 // @20 wakeup timer register
	uint8_t		  RESERVED1[2];	 // @22
	__IO uint32_t CR;			 // @24 control register
	uint8_t		  RESERVED2[8];	 // @28
	__O uint8_t	  WPR;			 // @36 write protection register
	uint8_t		  RESERVED3[3];	 // @37
	__IO uint16_t CALR;			 // @40 calibration register
	uint8_t		  RESERVED4[2];	 // @42
	__O uint32_t  SHIFTR;		 // @44 shift control register
	__I uint32_t  TSTR;			 // @48 time stamp time register
	__I uint16_t  TSDR;			 // @52 time stamp date register
	uint8_t		  RESERVED5[2];	 // @54
	__I uint16_t  TSSSR;		 // @56 timestamp sub second register
	uint8_t		  RESERVED6[6];	 // @58
	__IO uint32_t ALRMAR;		 // @64 alarm A register
	__IO uint32_t ALRMASSR;		 // @68 alarm A sub second register
	__IO uint32_t ALRMBR;		 // @72 alarm B register
	__IO uint32_t ALRMBSSR;		 // @76 alarm B sub second register
	__I uint8_t	  SR;			 // @80 status register
	uint8_t		  RESERVED7[3];	 // @81
	__I uint8_t	  MISR;			 // @84 status register
	uint8_t		  RESERVED8[7];	 // @85
	__O uint8_t	  SCR;			 // @92 status register
};

// RTC->TR time register
enum {
	RTC_TR_PM  = 1UL << 22,				  // AM/PM notation
	RTC_TR_HT  = ((1UL << 2) - 1) << 20,  // Hour tens in BCD format
	RTC_TR_HU  = ((1UL << 4) - 1) << 16,  // Hour units in BCD format
	RTC_TR_MNT = ((1UL << 3) - 1) << 12,  // Minute tens in BCD format
	RTC_TR_MNU = ((1UL << 4) - 1) << 8,	  // Minute units in BCD format
	RTC_TR_ST  = ((1UL << 3) - 1) << 4,	  // Second tens in BCD format
	RTC_TR_SU  = ((1UL << 4) - 1) << 0,	  // Second units in BCD format
};
inline void		rtc_tr_set_ht(struct RTC_Type *p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HT) | ((val << 20) & RTC_TR_HT); }
inline void		rtc_tr_set_hu(struct RTC_Type *p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HU) | ((val << 16) & RTC_TR_HU); }
inline void		rtc_tr_set_mnt(struct RTC_Type *p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNT) | ((val << 12) & RTC_TR_MNT); }
inline void		rtc_tr_set_mnu(struct RTC_Type *p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNU) | ((val << 8) & RTC_TR_MNU); }
inline void		rtc_tr_set_st(struct RTC_Type *p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_ST) | ((val << 4) & RTC_TR_ST); }
inline void		rtc_tr_set_su(struct RTC_Type *p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_SU) | ((val << 0) & RTC_TR_SU); }
inline uint32_t rtc_tr_get_ht(struct RTC_Type *p) { return (p->TR & RTC_TR_HT) >> 20; }
inline uint32_t rtc_tr_get_hu(struct RTC_Type *p) { return (p->TR & RTC_TR_HU) >> 16; }
inline uint32_t rtc_tr_get_mnt(struct RTC_Type *p) { return (p->TR & RTC_TR_MNT) >> 12; }
inline uint32_t rtc_tr_get_mnu(struct RTC_Type *p) { return (p->TR & RTC_TR_MNU) >> 8; }
inline uint32_t rtc_tr_get_st(struct RTC_Type *p) { return (p->TR & RTC_TR_ST) >> 4; }
inline uint32_t rtc_tr_get_su(struct RTC_Type *p) { return (p->TR & RTC_TR_SU) >> 0; }

// RTC->DR date register
enum {
	RTC_DR_YT  = ((1UL << 4) - 1) << 20,  // Year tens in BCD format
	RTC_DR_YU  = ((1UL << 4) - 1) << 16,  // Year units in BCD format
	RTC_DR_WDU = ((1UL << 3) - 1) << 13,  // Week day units
	RTC_DR_MT  = 1UL << 12,				  // Month tens in BCD format
	RTC_DR_MU  = ((1UL << 4) - 1) << 8,	  // Month units in BCD format
	RTC_DR_DT  = ((1UL << 2) - 1) << 4,	  // Date tens in BCD format
	RTC_DR_DU  = ((1UL << 4) - 1) << 0,	  // Date units in BCD format
};
inline void		rtc_dr_set_yt(struct RTC_Type *p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YT) | ((val << 20) & RTC_DR_YT); }
inline void		rtc_dr_set_yu(struct RTC_Type *p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YU) | ((val << 16) & RTC_DR_YU); }
inline void		rtc_dr_set_wdu(struct RTC_Type *p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_WDU) | ((val << 13) & RTC_DR_WDU); }
inline void		rtc_dr_set_mu(struct RTC_Type *p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_MU) | ((val << 8) & RTC_DR_MU); }
inline void		rtc_dr_set_dt(struct RTC_Type *p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DT) | ((val << 4) & RTC_DR_DT); }
inline void		rtc_dr_set_du(struct RTC_Type *p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DU) | ((val << 0) & RTC_DR_DU); }
inline uint32_t rtc_dr_get_yt(struct RTC_Type *p) { return (p->DR & RTC_DR_YT) >> 20; }
inline uint32_t rtc_dr_get_yu(struct RTC_Type *p) { return (p->DR & RTC_DR_YU) >> 16; }
inline uint32_t rtc_dr_get_wdu(struct RTC_Type *p) { return (p->DR & RTC_DR_WDU) >> 13; }
inline uint32_t rtc_dr_get_mu(struct RTC_Type *p) { return (p->DR & RTC_DR_MU) >> 8; }
inline uint32_t rtc_dr_get_dt(struct RTC_Type *p) { return (p->DR & RTC_DR_DT) >> 4; }
inline uint32_t rtc_dr_get_du(struct RTC_Type *p) { return (p->DR & RTC_DR_DU) >> 0; }

// RTC->ICSR initialization and status register
enum {
	RTC_ICSR_RECALPF = 1UL << 16,  // Recalibration pending Flag
	RTC_ICSR_INIT	 = 1UL << 7,   // Initialization mode
	RTC_ICSR_INITF	 = 1UL << 6,   // Initialization flag
	RTC_ICSR_RSF	 = 1UL << 5,   // Registers synchronization flag
	RTC_ICSR_INITS	 = 1UL << 4,   // Initialization status flag
	RTC_ICSR_SHPF	 = 1UL << 3,   // Shift operation pending
	RTC_ICSR_WUTWF	 = 1UL << 2,   // Wakeup timer write flag
	RTC_ICSR_ALRBWF	 = 1UL << 1,   // Alarm B write flag
	RTC_ICSR_ALRAWF	 = 1UL << 0,   // Alarm A write flag
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL << 7) - 1) << 16,	 // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL << 15) - 1) << 0,	 // Synchronous prescaler factor
};
inline void rtc_prer_set_prediv_a(struct RTC_Type *p, uint32_t val) {
	p->PRER = (p->PRER & ~RTC_PRER_PREDIV_A) | ((val << 16) & RTC_PRER_PREDIV_A);
}
inline void rtc_prer_set_prediv_s(struct RTC_Type *p, uint32_t val) {
	p->PRER = (p->PRER & ~RTC_PRER_PREDIV_S) | ((val << 0) & RTC_PRER_PREDIV_S);
}
inline uint32_t rtc_prer_get_prediv_a(struct RTC_Type *p) { return (p->PRER & RTC_PRER_PREDIV_A) >> 16; }
inline uint32_t rtc_prer_get_prediv_s(struct RTC_Type *p) { return (p->PRER & RTC_PRER_PREDIV_S) >> 0; }

// RTC->CR control register
enum {
	RTC_CR_OUT2EN		 = 1UL << 31,				// OUT2EN
	RTC_CR_TAMPALRM_TYPE = 1UL << 30,				// TAMPALRM_TYPE
	RTC_CR_TAMPALRM_PU	 = 1UL << 29,				// TAMPALRM_PU
	RTC_CR_TAMPOE		 = 1UL << 26,				// TAMPOE
	RTC_CR_TAMPTS		 = 1UL << 25,				// TAMPTS
	RTC_CR_ITSE			 = 1UL << 24,				// timestamp on internal event enable
	RTC_CR_COE			 = 1UL << 23,				// Calibration output enable
	RTC_CR_OSEL			 = ((1UL << 2) - 1) << 21,	// Output selection
	RTC_CR_POL			 = 1UL << 20,				// Output polarity
	RTC_CR_COSEL		 = 1UL << 19,				// Calibration output selection
	RTC_CR_BKP			 = 1UL << 18,				// Backup
	RTC_CR_SUB1H		 = 1UL << 17,				// Subtract 1 hour (winter time change)
	RTC_CR_ADD1H		 = 1UL << 16,				// Add 1 hour (summer time change)
	RTC_CR_TSIE			 = 1UL << 15,				// Time-stamp interrupt enable
	RTC_CR_WUTIE		 = 1UL << 14,				// Wakeup timer interrupt enable
	RTC_CR_ALRBIE		 = 1UL << 13,				// Alarm B interrupt enable
	RTC_CR_ALRAIE		 = 1UL << 12,				// Alarm A interrupt enable
	RTC_CR_TSE			 = 1UL << 11,				// Time stamp enable
	RTC_CR_WUTE			 = 1UL << 10,				// Wakeup timer enable
	RTC_CR_ALRBE		 = 1UL << 9,				// Alarm B enable
	RTC_CR_ALRAE		 = 1UL << 8,				// Alarm A enable
	RTC_CR_FMT			 = 1UL << 6,				// Hour format
	RTC_CR_BYPSHAD		 = 1UL << 5,				// Bypass the shadow registers
	RTC_CR_REFCKON		 = 1UL << 4,				// Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE		 = 1UL << 3,				// Time-stamp event active edge
	RTC_CR_WCKSEL		 = ((1UL << 3) - 1) << 0,	// Wakeup clock selection
};
inline void rtc_cr_set_osel(struct RTC_Type *p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_OSEL) | ((val << 21) & RTC_CR_OSEL); }
inline void rtc_cr_set_wcksel(struct RTC_Type *p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_WCKSEL) | ((val << 0) & RTC_CR_WCKSEL); }
inline uint32_t rtc_cr_get_osel(struct RTC_Type *p) { return (p->CR & RTC_CR_OSEL) >> 21; }
inline uint32_t rtc_cr_get_wcksel(struct RTC_Type *p) { return (p->CR & RTC_CR_WCKSEL) >> 0; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP	= 1UL << 15,			  // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8	= 1UL << 14,			  // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL << 13,			  // Use a 16-second calibration cycle period
	RTC_CALR_CALM	= ((1UL << 9) - 1) << 0,  // Calibration minus
};
inline void rtc_calr_set_calm(struct RTC_Type *p, uint32_t val) {
	p->CALR = (p->CALR & ~RTC_CALR_CALM) | ((val << 0) & RTC_CALR_CALM);
}
inline uint32_t rtc_calr_get_calm(struct RTC_Type *p) { return (p->CALR & RTC_CALR_CALM) >> 0; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL << 31,				// Add one second
	RTC_SHIFTR_SUBFS = ((1UL << 15) - 1) << 0,	// Subtract a fraction of a second
};
inline void rtc_shiftr_set_subfs(struct RTC_Type *p, uint32_t val) {
	p->SHIFTR = (p->SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val << 0) & RTC_SHIFTR_SUBFS);
}
inline uint32_t rtc_shiftr_get_subfs(struct RTC_Type *p) { return (p->SHIFTR & RTC_SHIFTR_SUBFS) >> 0; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM	 = 1UL << 22,				// AM/PM notation
	RTC_TSTR_HT	 = ((1UL << 2) - 1) << 20,	// Hour tens in BCD format
	RTC_TSTR_HU	 = ((1UL << 4) - 1) << 16,	// Hour units in BCD format
	RTC_TSTR_MNT = ((1UL << 3) - 1) << 12,	// Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL << 4) - 1) << 8,	// Minute units in BCD format
	RTC_TSTR_ST	 = ((1UL << 3) - 1) << 4,	// Second tens in BCD format
	RTC_TSTR_SU	 = ((1UL << 4) - 1) << 0,	// Second units in BCD format
};
inline uint32_t rtc_tstr_get_ht(struct RTC_Type *p) { return (p->TSTR & RTC_TSTR_HT) >> 20; }
inline uint32_t rtc_tstr_get_hu(struct RTC_Type *p) { return (p->TSTR & RTC_TSTR_HU) >> 16; }
inline uint32_t rtc_tstr_get_mnt(struct RTC_Type *p) { return (p->TSTR & RTC_TSTR_MNT) >> 12; }
inline uint32_t rtc_tstr_get_mnu(struct RTC_Type *p) { return (p->TSTR & RTC_TSTR_MNU) >> 8; }
inline uint32_t rtc_tstr_get_st(struct RTC_Type *p) { return (p->TSTR & RTC_TSTR_ST) >> 4; }
inline uint32_t rtc_tstr_get_su(struct RTC_Type *p) { return (p->TSTR & RTC_TSTR_SU) >> 0; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL << 3) - 1) << 13,	// Week day units
	RTC_TSDR_MT	 = 1UL << 12,				// Month tens in BCD format
	RTC_TSDR_MU	 = ((1UL << 4) - 1) << 8,	// Month units in BCD format
	RTC_TSDR_DT	 = ((1UL << 2) - 1) << 4,	// Date tens in BCD format
	RTC_TSDR_DU	 = ((1UL << 4) - 1) << 0,	// Date units in BCD format
};
inline uint32_t rtc_tsdr_get_wdu(struct RTC_Type *p) { return (p->TSDR & RTC_TSDR_WDU) >> 13; }
inline uint32_t rtc_tsdr_get_mu(struct RTC_Type *p) { return (p->TSDR & RTC_TSDR_MU) >> 8; }
inline uint32_t rtc_tsdr_get_dt(struct RTC_Type *p) { return (p->TSDR & RTC_TSDR_DT) >> 4; }
inline uint32_t rtc_tsdr_get_du(struct RTC_Type *p) { return (p->TSDR & RTC_TSDR_DU) >> 0; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4	 = 1UL << 31,				// Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL << 30,				// Week day selection
	RTC_ALRMAR_DT	 = ((1UL << 2) - 1) << 28,	// Date tens in BCD format
	RTC_ALRMAR_DU	 = ((1UL << 4) - 1) << 24,	// Date units or day in BCD format
	RTC_ALRMAR_MSK3	 = 1UL << 23,				// Alarm A hours mask
	RTC_ALRMAR_PM	 = 1UL << 22,				// AM/PM notation
	RTC_ALRMAR_HT	 = ((1UL << 2) - 1) << 20,	// Hour tens in BCD format
	RTC_ALRMAR_HU	 = ((1UL << 4) - 1) << 16,	// Hour units in BCD format
	RTC_ALRMAR_MSK2	 = 1UL << 15,				// Alarm A minutes mask
	RTC_ALRMAR_MNT	 = ((1UL << 3) - 1) << 12,	// Minute tens in BCD format
	RTC_ALRMAR_MNU	 = ((1UL << 4) - 1) << 8,	// Minute units in BCD format
	RTC_ALRMAR_MSK1	 = 1UL << 7,				// Alarm A seconds mask
	RTC_ALRMAR_ST	 = ((1UL << 3) - 1) << 4,	// Second tens in BCD format
	RTC_ALRMAR_SU	 = ((1UL << 4) - 1) << 0,	// Second units in BCD format
};
inline void rtc_alrmar_set_dt(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DT) | ((val << 28) & RTC_ALRMAR_DT);
}
inline void rtc_alrmar_set_du(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DU) | ((val << 24) & RTC_ALRMAR_DU);
}
inline void rtc_alrmar_set_ht(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HT) | ((val << 20) & RTC_ALRMAR_HT);
}
inline void rtc_alrmar_set_hu(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HU) | ((val << 16) & RTC_ALRMAR_HU);
}
inline void rtc_alrmar_set_mnt(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNT) | ((val << 12) & RTC_ALRMAR_MNT);
}
inline void rtc_alrmar_set_mnu(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNU) | ((val << 8) & RTC_ALRMAR_MNU);
}
inline void rtc_alrmar_set_st(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_ST) | ((val << 4) & RTC_ALRMAR_ST);
}
inline void rtc_alrmar_set_su(struct RTC_Type *p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_SU) | ((val << 0) & RTC_ALRMAR_SU);
}
inline uint32_t rtc_alrmar_get_dt(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_DT) >> 28; }
inline uint32_t rtc_alrmar_get_du(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_DU) >> 24; }
inline uint32_t rtc_alrmar_get_ht(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_HT) >> 20; }
inline uint32_t rtc_alrmar_get_hu(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_HU) >> 16; }
inline uint32_t rtc_alrmar_get_mnt(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_MNT) >> 12; }
inline uint32_t rtc_alrmar_get_mnu(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_MNU) >> 8; }
inline uint32_t rtc_alrmar_get_st(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_ST) >> 4; }
inline uint32_t rtc_alrmar_get_su(struct RTC_Type *p) { return (p->ALRMAR & RTC_ALRMAR_SU) >> 0; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL << 4) - 1) << 24,  // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS		= ((1UL << 15) - 1) << 0,  // Sub seconds value
};
inline void rtc_alrmassr_set_maskss(struct RTC_Type *p, uint32_t val) {
	p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val << 24) & RTC_ALRMASSR_MASKSS);
}
inline void rtc_alrmassr_set_ss(struct RTC_Type *p, uint32_t val) {
	p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_SS) | ((val << 0) & RTC_ALRMASSR_SS);
}
inline uint32_t rtc_alrmassr_get_maskss(struct RTC_Type *p) { return (p->ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24; }
inline uint32_t rtc_alrmassr_get_ss(struct RTC_Type *p) { return (p->ALRMASSR & RTC_ALRMASSR_SS) >> 0; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4	 = 1UL << 31,				// Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL << 30,				// Week day selection
	RTC_ALRMBR_DT	 = ((1UL << 2) - 1) << 28,	// Date tens in BCD format
	RTC_ALRMBR_DU	 = ((1UL << 4) - 1) << 24,	// Date units or day in BCD format
	RTC_ALRMBR_MSK3	 = 1UL << 23,				// Alarm B hours mask
	RTC_ALRMBR_PM	 = 1UL << 22,				// AM/PM notation
	RTC_ALRMBR_HT	 = ((1UL << 2) - 1) << 20,	// Hour tens in BCD format
	RTC_ALRMBR_HU	 = ((1UL << 4) - 1) << 16,	// Hour units in BCD format
	RTC_ALRMBR_MSK2	 = 1UL << 15,				// Alarm B minutes mask
	RTC_ALRMBR_MNT	 = ((1UL << 3) - 1) << 12,	// Minute tens in BCD format
	RTC_ALRMBR_MNU	 = ((1UL << 4) - 1) << 8,	// Minute units in BCD format
	RTC_ALRMBR_MSK1	 = 1UL << 7,				// Alarm B seconds mask
	RTC_ALRMBR_ST	 = ((1UL << 3) - 1) << 4,	// Second tens in BCD format
	RTC_ALRMBR_SU	 = ((1UL << 4) - 1) << 0,	// Second units in BCD format
};
inline void rtc_alrmbr_set_dt(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DT) | ((val << 28) & RTC_ALRMBR_DT);
}
inline void rtc_alrmbr_set_du(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DU) | ((val << 24) & RTC_ALRMBR_DU);
}
inline void rtc_alrmbr_set_ht(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HT) | ((val << 20) & RTC_ALRMBR_HT);
}
inline void rtc_alrmbr_set_hu(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HU) | ((val << 16) & RTC_ALRMBR_HU);
}
inline void rtc_alrmbr_set_mnt(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNT) | ((val << 12) & RTC_ALRMBR_MNT);
}
inline void rtc_alrmbr_set_mnu(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNU) | ((val << 8) & RTC_ALRMBR_MNU);
}
inline void rtc_alrmbr_set_st(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_ST) | ((val << 4) & RTC_ALRMBR_ST);
}
inline void rtc_alrmbr_set_su(struct RTC_Type *p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_SU) | ((val << 0) & RTC_ALRMBR_SU);
}
inline uint32_t rtc_alrmbr_get_dt(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_DT) >> 28; }
inline uint32_t rtc_alrmbr_get_du(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_DU) >> 24; }
inline uint32_t rtc_alrmbr_get_ht(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_HT) >> 20; }
inline uint32_t rtc_alrmbr_get_hu(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_HU) >> 16; }
inline uint32_t rtc_alrmbr_get_mnt(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_MNT) >> 12; }
inline uint32_t rtc_alrmbr_get_mnu(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_MNU) >> 8; }
inline uint32_t rtc_alrmbr_get_st(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_ST) >> 4; }
inline uint32_t rtc_alrmbr_get_su(struct RTC_Type *p) { return (p->ALRMBR & RTC_ALRMBR_SU) >> 0; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL << 4) - 1) << 24,  // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS		= ((1UL << 15) - 1) << 0,  // Sub seconds value
};
inline void rtc_alrmbssr_set_maskss(struct RTC_Type *p, uint32_t val) {
	p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val << 24) & RTC_ALRMBSSR_MASKSS);
}
inline void rtc_alrmbssr_set_ss(struct RTC_Type *p, uint32_t val) {
	p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val << 0) & RTC_ALRMBSSR_SS);
}
inline uint32_t rtc_alrmbssr_get_maskss(struct RTC_Type *p) { return (p->ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24; }
inline uint32_t rtc_alrmbssr_get_ss(struct RTC_Type *p) { return (p->ALRMBSSR & RTC_ALRMBSSR_SS) >> 0; }

// RTC->SR status register
enum {
	RTC_SR_ITSF	 = 1UL << 5,  // ITSF
	RTC_SR_TSOVF = 1UL << 4,  // TSOVF
	RTC_SR_TSF	 = 1UL << 3,  // TSF
	RTC_SR_WUTF	 = 1UL << 2,  // WUTF
	RTC_SR_ALRBF = 1UL << 1,  // ALRBF
	RTC_SR_ALRAF = 1UL << 0,  // ALRAF
};

// RTC->MISR status register
enum {
	RTC_MISR_ITSMF	= 1UL << 5,	 // ITSMF
	RTC_MISR_TSOVMF = 1UL << 4,	 // TSOVMF
	RTC_MISR_TSMF	= 1UL << 3,	 // TSMF
	RTC_MISR_WUTMF	= 1UL << 2,	 // WUTMF
	RTC_MISR_ALRBMF = 1UL << 1,	 // ALRBMF
	RTC_MISR_ALRAMF = 1UL << 0,	 // ALRAMF
};

// RTC->SCR status register
enum {
	RTC_SCR_CITSF  = 1UL << 5,	// CITSF
	RTC_SCR_CTSOVF = 1UL << 4,	// CTSOVF
	RTC_SCR_CTSF   = 1UL << 3,	// CTSF
	RTC_SCR_CWUTF  = 1UL << 2,	// CWUTF
	RTC_SCR_CALRBF = 1UL << 1,	// CALRBF
	RTC_SCR_CALRAF = 1UL << 0,	// CALRAF
};

/* Serial audio interface */
struct SAI_Type {
	uint8_t		  RESERVED0[4];	 // @0
	__IO uint32_t ACR1;			 // @4 AConfiguration register 1
	__IO uint16_t ACR2;			 // @8 AConfiguration register 2
	uint8_t		  RESERVED1[2];	 // @10
	__IO uint32_t AFRCR;		 // @12 AFRCR
	__IO uint32_t ASLOTR;		 // @16 ASlot register
	__IO uint8_t  AIM;			 // @20 AInterrupt mask register2
	uint8_t		  RESERVED2[3];	 // @21
	__IO uint32_t ASR;			 // @24 AStatus register
	__IO uint8_t  ACLRFR;		 // @28 AClear flag register
	uint8_t		  RESERVED3[3];	 // @29
	__IO uint32_t ADR;			 // @32 AData register
	__IO uint32_t BCR1;			 // @36 BConfiguration register 1
	__IO uint16_t BCR2;			 // @40 BConfiguration register 2
	uint8_t		  RESERVED4[2];	 // @42
	__IO uint32_t BFRCR;		 // @44 BFRCR
	__IO uint32_t BSLOTR;		 // @48 BSlot register
	__IO uint8_t  BIM;			 // @52 BInterrupt mask register2
	uint8_t		  RESERVED5[3];	 // @53
	__I uint32_t  BSR;			 // @56 BStatus register
	__O uint8_t	  BCLRFR;		 // @60 BClear flag register
	uint8_t		  RESERVED6[3];	 // @61
	__IO uint32_t BDR;			 // @64 BData register
	__IO uint16_t PDMCR;		 // @68 PDM control register
	uint8_t		  RESERVED7[2];	 // @70
	__IO uint32_t PDMDLY;		 // @72 PDM delay register
};

// SAI->ACR1 AConfiguration register 1
enum {
	SAI_ACR1_MCKEN	  = 1UL << 27,				 // MCKEN
	SAI_ACR1_OSR	  = 1UL << 26,				 // OSR
	SAI_ACR1_MCJDIV	  = ((1UL << 6) - 1) << 20,	 // Master clock divider
	SAI_ACR1_NODIV	  = 1UL << 19,				 // No divider
	SAI_ACR1_DMAEN	  = 1UL << 17,				 // DMA enable
	SAI_ACR1_SAIAEN	  = 1UL << 16,				 // Audio block A enable
	SAI_ACR1_OUTDRI	  = 1UL << 13,				 // Output drive
	SAI_ACR1_MONO	  = 1UL << 12,				 // Mono mode
	SAI_ACR1_SYNCEN	  = ((1UL << 2) - 1) << 10,	 // Synchronization enable
	SAI_ACR1_CKSTR	  = 1UL << 9,				 // Clock strobing edge
	SAI_ACR1_LSBFIRST = 1UL << 8,				 // Least significant bit first
	SAI_ACR1_DS		  = ((1UL << 3) - 1) << 5,	 // Data size
	SAI_ACR1_PRTCFG	  = ((1UL << 2) - 1) << 2,	 // Protocol configuration
	SAI_ACR1_MODE	  = ((1UL << 2) - 1) << 0,	 // Audio block mode
};
inline void sai_acr1_set_mcjdiv(struct SAI_Type *p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_MCJDIV) | ((val << 20) & SAI_ACR1_MCJDIV);
}
inline void sai_acr1_set_syncen(struct SAI_Type *p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_SYNCEN) | ((val << 10) & SAI_ACR1_SYNCEN);
}
inline void sai_acr1_set_ds(struct SAI_Type *p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI_ACR1_DS) | ((val << 5) & SAI_ACR1_DS); }
inline void sai_acr1_set_prtcfg(struct SAI_Type *p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_PRTCFG) | ((val << 2) & SAI_ACR1_PRTCFG);
}
inline void sai_acr1_set_mode(struct SAI_Type *p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_MODE) | ((val << 0) & SAI_ACR1_MODE);
}
inline uint32_t sai_acr1_get_mcjdiv(struct SAI_Type *p) { return (p->ACR1 & SAI_ACR1_MCJDIV) >> 20; }
inline uint32_t sai_acr1_get_syncen(struct SAI_Type *p) { return (p->ACR1 & SAI_ACR1_SYNCEN) >> 10; }
inline uint32_t sai_acr1_get_ds(struct SAI_Type *p) { return (p->ACR1 & SAI_ACR1_DS) >> 5; }
inline uint32_t sai_acr1_get_prtcfg(struct SAI_Type *p) { return (p->ACR1 & SAI_ACR1_PRTCFG) >> 2; }
inline uint32_t sai_acr1_get_mode(struct SAI_Type *p) { return (p->ACR1 & SAI_ACR1_MODE) >> 0; }

// SAI->ACR2 AConfiguration register 2
enum {
	SAI_ACR2_COMP	 = ((1UL << 2) - 1) << 14,	// Companding mode
	SAI_ACR2_CPL	 = 1UL << 13,				// Complement bit
	SAI_ACR2_MUTECN	 = ((1UL << 6) - 1) << 7,	// Mute counter
	SAI_ACR2_MUTEVAL = 1UL << 6,				// Mute value
	SAI_ACR2_MUTE	 = 1UL << 5,				// Mute
	SAI_ACR2_TRIS	 = 1UL << 4,				// Tristate management on data line
	SAI_ACR2_FFLUS	 = 1UL << 3,				// FIFO flush
	SAI_ACR2_FTH	 = ((1UL << 3) - 1) << 0,	// FIFO threshold
};
inline void sai_acr2_set_comp(struct SAI_Type *p, uint32_t val) {
	p->ACR2 = (p->ACR2 & ~SAI_ACR2_COMP) | ((val << 14) & SAI_ACR2_COMP);
}
inline void sai_acr2_set_mutecn(struct SAI_Type *p, uint32_t val) {
	p->ACR2 = (p->ACR2 & ~SAI_ACR2_MUTECN) | ((val << 7) & SAI_ACR2_MUTECN);
}
inline void sai_acr2_set_fth(struct SAI_Type *p, uint32_t val) {
	p->ACR2 = (p->ACR2 & ~SAI_ACR2_FTH) | ((val << 0) & SAI_ACR2_FTH);
}
inline uint32_t sai_acr2_get_comp(struct SAI_Type *p) { return (p->ACR2 & SAI_ACR2_COMP) >> 14; }
inline uint32_t sai_acr2_get_mutecn(struct SAI_Type *p) { return (p->ACR2 & SAI_ACR2_MUTECN) >> 7; }
inline uint32_t sai_acr2_get_fth(struct SAI_Type *p) { return (p->ACR2 & SAI_ACR2_FTH) >> 0; }

// SAI->AFRCR AFRCR
enum {
	SAI_AFRCR_FSOFF = 1UL << 18,			  // Frame synchronization offset
	SAI_AFRCR_FSPOL = 1UL << 17,			  // Frame synchronization polarity
	SAI_AFRCR_FSDEF = 1UL << 16,			  // Frame synchronization definition
	SAI_AFRCR_FSALL = ((1UL << 7) - 1) << 8,  // Frame synchronization active level length
	SAI_AFRCR_FRL	= ((1UL << 8) - 1) << 0,  // Frame length
};
inline void sai_afrcr_set_fsall(struct SAI_Type *p, uint32_t val) {
	p->AFRCR = (p->AFRCR & ~SAI_AFRCR_FSALL) | ((val << 8) & SAI_AFRCR_FSALL);
}
inline void sai_afrcr_set_frl(struct SAI_Type *p, uint32_t val) {
	p->AFRCR = (p->AFRCR & ~SAI_AFRCR_FRL) | ((val << 0) & SAI_AFRCR_FRL);
}
inline uint32_t sai_afrcr_get_fsall(struct SAI_Type *p) { return (p->AFRCR & SAI_AFRCR_FSALL) >> 8; }
inline uint32_t sai_afrcr_get_frl(struct SAI_Type *p) { return (p->AFRCR & SAI_AFRCR_FRL) >> 0; }

// SAI->ASLOTR ASlot register
enum {
	SAI_ASLOTR_SLOTEN = ((1UL << 16) - 1) << 16,  // Slot enable
	SAI_ASLOTR_NBSLOT = ((1UL << 4) - 1) << 8,	  // Number of slots in an audio frame
	SAI_ASLOTR_SLOTSZ = ((1UL << 2) - 1) << 6,	  // Slot size
	SAI_ASLOTR_FBOFF  = ((1UL << 5) - 1) << 0,	  // First bit offset
};
inline void sai_aslotr_set_sloten(struct SAI_Type *p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_SLOTEN) | ((val << 16) & SAI_ASLOTR_SLOTEN);
}
inline void sai_aslotr_set_nbslot(struct SAI_Type *p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_NBSLOT) | ((val << 8) & SAI_ASLOTR_NBSLOT);
}
inline void sai_aslotr_set_slotsz(struct SAI_Type *p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_SLOTSZ) | ((val << 6) & SAI_ASLOTR_SLOTSZ);
}
inline void sai_aslotr_set_fboff(struct SAI_Type *p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_FBOFF) | ((val << 0) & SAI_ASLOTR_FBOFF);
}
inline uint32_t sai_aslotr_get_sloten(struct SAI_Type *p) { return (p->ASLOTR & SAI_ASLOTR_SLOTEN) >> 16; }
inline uint32_t sai_aslotr_get_nbslot(struct SAI_Type *p) { return (p->ASLOTR & SAI_ASLOTR_NBSLOT) >> 8; }
inline uint32_t sai_aslotr_get_slotsz(struct SAI_Type *p) { return (p->ASLOTR & SAI_ASLOTR_SLOTSZ) >> 6; }
inline uint32_t sai_aslotr_get_fboff(struct SAI_Type *p) { return (p->ASLOTR & SAI_ASLOTR_FBOFF) >> 0; }

// SAI->AIM AInterrupt mask register2
enum {
	SAI_AIM_LFSDET	 = 1UL << 6,  // Late frame synchronization detection interrupt enable
	SAI_AIM_AFSDETIE = 1UL << 5,  // Anticipated frame synchronization detection interrupt enable
	SAI_AIM_CNRDYIE	 = 1UL << 4,  // Codec not ready interrupt enable
	SAI_AIM_FREQIE	 = 1UL << 3,  // FIFO request interrupt enable
	SAI_AIM_WCKCFG	 = 1UL << 2,  // Wrong clock configuration interrupt enable
	SAI_AIM_MUTEDET	 = 1UL << 1,  // Mute detection interrupt enable
	SAI_AIM_OVRUDRIE = 1UL << 0,  // Overrun/underrun interrupt enable
};

// SAI->ASR AStatus register
enum {
	SAI_ASR_FLVL	= ((1UL << 3) - 1) << 16,  // FIFO level threshold
	SAI_ASR_LFSDET	= 1UL << 6,				   // Late frame synchronization detection
	SAI_ASR_AFSDET	= 1UL << 5,				   // Anticipated frame synchronization detection
	SAI_ASR_CNRDY	= 1UL << 4,				   // Codec not ready
	SAI_ASR_FREQ	= 1UL << 3,				   // FIFO request
	SAI_ASR_WCKCFG	= 1UL << 2,				   // Wrong clock configuration flag. This bit is read only
	SAI_ASR_MUTEDET = 1UL << 1,				   // Mute detection
	SAI_ASR_OVRUDR	= 1UL << 0,				   // Overrun / underrun
};
inline void sai_asr_set_flvl(struct SAI_Type *p, uint32_t val) { p->ASR = (p->ASR & ~SAI_ASR_FLVL) | ((val << 16) & SAI_ASR_FLVL); }
inline uint32_t sai_asr_get_flvl(struct SAI_Type *p) { return (p->ASR & SAI_ASR_FLVL) >> 16; }

// SAI->ACLRFR AClear flag register
enum {
	SAI_ACLRFR_LFSDET  = 1UL << 6,	// Clear late frame synchronization detection flag
	SAI_ACLRFR_CAFSDET = 1UL << 5,	// Clear anticipated frame synchronization detection flag
	SAI_ACLRFR_CNRDY   = 1UL << 4,	// Clear codec not ready flag
	SAI_ACLRFR_WCKCFG  = 1UL << 2,	// Clear wrong clock configuration flag
	SAI_ACLRFR_MUTEDET = 1UL << 1,	// Mute detection flag
	SAI_ACLRFR_OVRUDR  = 1UL << 0,	// Clear overrun / underrun
};

// SAI->BCR1 BConfiguration register 1
enum {
	SAI_BCR1_MCKEN	  = 1UL << 27,				 // MCKEN
	SAI_BCR1_OSR	  = 1UL << 26,				 // OSR
	SAI_BCR1_MCJDIV	  = ((1UL << 6) - 1) << 20,	 // Master clock divider
	SAI_BCR1_NODIV	  = 1UL << 19,				 // No divider
	SAI_BCR1_DMAEN	  = 1UL << 17,				 // DMA enable
	SAI_BCR1_SAIBEN	  = 1UL << 16,				 // Audio block B enable
	SAI_BCR1_OUTDRI	  = 1UL << 13,				 // Output drive
	SAI_BCR1_MONO	  = 1UL << 12,				 // Mono mode
	SAI_BCR1_SYNCEN	  = ((1UL << 2) - 1) << 10,	 // Synchronization enable
	SAI_BCR1_CKSTR	  = 1UL << 9,				 // Clock strobing edge
	SAI_BCR1_LSBFIRST = 1UL << 8,				 // Least significant bit first
	SAI_BCR1_DS		  = ((1UL << 3) - 1) << 5,	 // Data size
	SAI_BCR1_PRTCFG	  = ((1UL << 2) - 1) << 2,	 // Protocol configuration
	SAI_BCR1_MODE	  = ((1UL << 2) - 1) << 0,	 // Audio block mode
};
inline void sai_bcr1_set_mcjdiv(struct SAI_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_MCJDIV) | ((val << 20) & SAI_BCR1_MCJDIV);
}
inline void sai_bcr1_set_syncen(struct SAI_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_SYNCEN) | ((val << 10) & SAI_BCR1_SYNCEN);
}
inline void sai_bcr1_set_ds(struct SAI_Type *p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI_BCR1_DS) | ((val << 5) & SAI_BCR1_DS); }
inline void sai_bcr1_set_prtcfg(struct SAI_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_PRTCFG) | ((val << 2) & SAI_BCR1_PRTCFG);
}
inline void sai_bcr1_set_mode(struct SAI_Type *p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_MODE) | ((val << 0) & SAI_BCR1_MODE);
}
inline uint32_t sai_bcr1_get_mcjdiv(struct SAI_Type *p) { return (p->BCR1 & SAI_BCR1_MCJDIV) >> 20; }
inline uint32_t sai_bcr1_get_syncen(struct SAI_Type *p) { return (p->BCR1 & SAI_BCR1_SYNCEN) >> 10; }
inline uint32_t sai_bcr1_get_ds(struct SAI_Type *p) { return (p->BCR1 & SAI_BCR1_DS) >> 5; }
inline uint32_t sai_bcr1_get_prtcfg(struct SAI_Type *p) { return (p->BCR1 & SAI_BCR1_PRTCFG) >> 2; }
inline uint32_t sai_bcr1_get_mode(struct SAI_Type *p) { return (p->BCR1 & SAI_BCR1_MODE) >> 0; }

// SAI->BCR2 BConfiguration register 2
enum {
	SAI_BCR2_COMP	 = ((1UL << 2) - 1) << 14,	// Companding mode
	SAI_BCR2_CPL	 = 1UL << 13,				// Complement bit
	SAI_BCR2_MUTECN	 = ((1UL << 6) - 1) << 7,	// Mute counter
	SAI_BCR2_MUTEVAL = 1UL << 6,				// Mute value
	SAI_BCR2_MUTE	 = 1UL << 5,				// Mute
	SAI_BCR2_TRIS	 = 1UL << 4,				// Tristate management on data line
	SAI_BCR2_FFLUS	 = 1UL << 3,				// FIFO flush
	SAI_BCR2_FTH	 = ((1UL << 3) - 1) << 0,	// FIFO threshold
};
inline void sai_bcr2_set_comp(struct SAI_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~SAI_BCR2_COMP) | ((val << 14) & SAI_BCR2_COMP);
}
inline void sai_bcr2_set_mutecn(struct SAI_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~SAI_BCR2_MUTECN) | ((val << 7) & SAI_BCR2_MUTECN);
}
inline void sai_bcr2_set_fth(struct SAI_Type *p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~SAI_BCR2_FTH) | ((val << 0) & SAI_BCR2_FTH);
}
inline uint32_t sai_bcr2_get_comp(struct SAI_Type *p) { return (p->BCR2 & SAI_BCR2_COMP) >> 14; }
inline uint32_t sai_bcr2_get_mutecn(struct SAI_Type *p) { return (p->BCR2 & SAI_BCR2_MUTECN) >> 7; }
inline uint32_t sai_bcr2_get_fth(struct SAI_Type *p) { return (p->BCR2 & SAI_BCR2_FTH) >> 0; }

// SAI->BFRCR BFRCR
enum {
	SAI_BFRCR_FSOFF = 1UL << 18,			  // Frame synchronization offset
	SAI_BFRCR_FSPOL = 1UL << 17,			  // Frame synchronization polarity
	SAI_BFRCR_FSDEF = 1UL << 16,			  // Frame synchronization definition
	SAI_BFRCR_FSALL = ((1UL << 7) - 1) << 8,  // Frame synchronization active level length
	SAI_BFRCR_FRL	= ((1UL << 8) - 1) << 0,  // Frame length
};
inline void sai_bfrcr_set_fsall(struct SAI_Type *p, uint32_t val) {
	p->BFRCR = (p->BFRCR & ~SAI_BFRCR_FSALL) | ((val << 8) & SAI_BFRCR_FSALL);
}
inline void sai_bfrcr_set_frl(struct SAI_Type *p, uint32_t val) {
	p->BFRCR = (p->BFRCR & ~SAI_BFRCR_FRL) | ((val << 0) & SAI_BFRCR_FRL);
}
inline uint32_t sai_bfrcr_get_fsall(struct SAI_Type *p) { return (p->BFRCR & SAI_BFRCR_FSALL) >> 8; }
inline uint32_t sai_bfrcr_get_frl(struct SAI_Type *p) { return (p->BFRCR & SAI_BFRCR_FRL) >> 0; }

// SAI->BSLOTR BSlot register
enum {
	SAI_BSLOTR_SLOTEN = ((1UL << 16) - 1) << 16,  // Slot enable
	SAI_BSLOTR_NBSLOT = ((1UL << 4) - 1) << 8,	  // Number of slots in an audio frame
	SAI_BSLOTR_SLOTSZ = ((1UL << 2) - 1) << 6,	  // Slot size
	SAI_BSLOTR_FBOFF  = ((1UL << 5) - 1) << 0,	  // First bit offset
};
inline void sai_bslotr_set_sloten(struct SAI_Type *p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_SLOTEN) | ((val << 16) & SAI_BSLOTR_SLOTEN);
}
inline void sai_bslotr_set_nbslot(struct SAI_Type *p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_NBSLOT) | ((val << 8) & SAI_BSLOTR_NBSLOT);
}
inline void sai_bslotr_set_slotsz(struct SAI_Type *p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_SLOTSZ) | ((val << 6) & SAI_BSLOTR_SLOTSZ);
}
inline void sai_bslotr_set_fboff(struct SAI_Type *p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_FBOFF) | ((val << 0) & SAI_BSLOTR_FBOFF);
}
inline uint32_t sai_bslotr_get_sloten(struct SAI_Type *p) { return (p->BSLOTR & SAI_BSLOTR_SLOTEN) >> 16; }
inline uint32_t sai_bslotr_get_nbslot(struct SAI_Type *p) { return (p->BSLOTR & SAI_BSLOTR_NBSLOT) >> 8; }
inline uint32_t sai_bslotr_get_slotsz(struct SAI_Type *p) { return (p->BSLOTR & SAI_BSLOTR_SLOTSZ) >> 6; }
inline uint32_t sai_bslotr_get_fboff(struct SAI_Type *p) { return (p->BSLOTR & SAI_BSLOTR_FBOFF) >> 0; }

// SAI->BIM BInterrupt mask register2
enum {
	SAI_BIM_LFSDETIE = 1UL << 6,  // Late frame synchronization detection interrupt enable
	SAI_BIM_AFSDETIE = 1UL << 5,  // Anticipated frame synchronization detection interrupt enable
	SAI_BIM_CNRDYIE	 = 1UL << 4,  // Codec not ready interrupt enable
	SAI_BIM_FREQIE	 = 1UL << 3,  // FIFO request interrupt enable
	SAI_BIM_WCKCFG	 = 1UL << 2,  // Wrong clock configuration interrupt enable
	SAI_BIM_MUTEDET	 = 1UL << 1,  // Mute detection interrupt enable
	SAI_BIM_OVRUDRIE = 1UL << 0,  // Overrun/underrun interrupt enable
};

// SAI->BSR BStatus register
enum {
	SAI_BSR_FLVL	= ((1UL << 3) - 1) << 16,  // FIFO level threshold
	SAI_BSR_LFSDET	= 1UL << 6,				   // Late frame synchronization detection
	SAI_BSR_AFSDET	= 1UL << 5,				   // Anticipated frame synchronization detection
	SAI_BSR_CNRDY	= 1UL << 4,				   // Codec not ready
	SAI_BSR_FREQ	= 1UL << 3,				   // FIFO request
	SAI_BSR_WCKCFG	= 1UL << 2,				   // Wrong clock configuration flag
	SAI_BSR_MUTEDET = 1UL << 1,				   // Mute detection
	SAI_BSR_OVRUDR	= 1UL << 0,				   // Overrun / underrun
};
inline uint32_t sai_bsr_get_flvl(struct SAI_Type *p) { return (p->BSR & SAI_BSR_FLVL) >> 16; }

// SAI->BCLRFR BClear flag register
enum {
	SAI_BCLRFR_LFSDET  = 1UL << 6,	// Clear late frame synchronization detection flag
	SAI_BCLRFR_CAFSDET = 1UL << 5,	// Clear anticipated frame synchronization detection flag
	SAI_BCLRFR_CNRDY   = 1UL << 4,	// Clear codec not ready flag
	SAI_BCLRFR_WCKCFG  = 1UL << 2,	// Clear wrong clock configuration flag
	SAI_BCLRFR_MUTEDET = 1UL << 1,	// Mute detection flag
	SAI_BCLRFR_OVRUDR  = 1UL << 0,	// Clear overrun / underrun
};

// SAI->PDMCR PDM control register
enum {
	SAI_PDMCR_CKEN4	 = 1UL << 11,			   // CKEN4
	SAI_PDMCR_CKEN3	 = 1UL << 10,			   // CKEN3
	SAI_PDMCR_CKEN2	 = 1UL << 9,			   // CKEN2
	SAI_PDMCR_CKEN1	 = 1UL << 8,			   // CKEN1
	SAI_PDMCR_MICNBR = ((1UL << 2) - 1) << 4,  // MICNBR
	SAI_PDMCR_PDMEN	 = 1UL << 0,			   // PDMEN
};
inline void sai_pdmcr_set_micnbr(struct SAI_Type *p, uint32_t val) {
	p->PDMCR = (p->PDMCR & ~SAI_PDMCR_MICNBR) | ((val << 4) & SAI_PDMCR_MICNBR);
}
inline uint32_t sai_pdmcr_get_micnbr(struct SAI_Type *p) { return (p->PDMCR & SAI_PDMCR_MICNBR) >> 4; }

// SAI->PDMDLY PDM delay register
enum {
	SAI_PDMDLY_DLYM4R = ((1UL << 3) - 1) << 28,	 // DLYM4R
	SAI_PDMDLY_DLYM4L = ((1UL << 3) - 1) << 24,	 // DLYM4L
	SAI_PDMDLY_DLYM3R = ((1UL << 3) - 1) << 20,	 // DLYM3R
	SAI_PDMDLY_DLYM3L = ((1UL << 3) - 1) << 16,	 // DLYM3L
	SAI_PDMDLY_DLYM2R = ((1UL << 3) - 1) << 12,	 // DLYM2R
	SAI_PDMDLY_DLYM2L = ((1UL << 3) - 1) << 8,	 // DLYM2L
	SAI_PDMDLY_DLYM1R = ((1UL << 3) - 1) << 4,	 // DLYM1R
	SAI_PDMDLY_DLYM1L = ((1UL << 3) - 1) << 0,	 // DLYM1L
};
inline void sai_pdmdly_set_dlym4r(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM4R) | ((val << 28) & SAI_PDMDLY_DLYM4R);
}
inline void sai_pdmdly_set_dlym4l(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM4L) | ((val << 24) & SAI_PDMDLY_DLYM4L);
}
inline void sai_pdmdly_set_dlym3r(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM3R) | ((val << 20) & SAI_PDMDLY_DLYM3R);
}
inline void sai_pdmdly_set_dlym3l(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM3L) | ((val << 16) & SAI_PDMDLY_DLYM3L);
}
inline void sai_pdmdly_set_dlym2r(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM2R) | ((val << 12) & SAI_PDMDLY_DLYM2R);
}
inline void sai_pdmdly_set_dlym2l(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM2L) | ((val << 8) & SAI_PDMDLY_DLYM2L);
}
inline void sai_pdmdly_set_dlym1r(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM1R) | ((val << 4) & SAI_PDMDLY_DLYM1R);
}
inline void sai_pdmdly_set_dlym1l(struct SAI_Type *p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM1L) | ((val << 0) & SAI_PDMDLY_DLYM1L);
}
inline uint32_t sai_pdmdly_get_dlym4r(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM4R) >> 28; }
inline uint32_t sai_pdmdly_get_dlym4l(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM4L) >> 24; }
inline uint32_t sai_pdmdly_get_dlym3r(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM3R) >> 20; }
inline uint32_t sai_pdmdly_get_dlym3l(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM3L) >> 16; }
inline uint32_t sai_pdmdly_get_dlym2r(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM2R) >> 12; }
inline uint32_t sai_pdmdly_get_dlym2l(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM2L) >> 8; }
inline uint32_t sai_pdmdly_get_dlym1r(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM1R) >> 4; }
inline uint32_t sai_pdmdly_get_dlym1l(struct SAI_Type *p) { return (p->PDMDLY & SAI_PDMDLY_DLYM1L) >> 0; }

/* System control block */
struct SCB_Type {
	__I uint32_t  CPUID;				 // @0 CPUID base register
	__IO uint32_t ICSR;					 // @4 Interrupt control and state register
	__IO uint32_t VTOR;					 // @8 Vector table offset register
	__IO uint32_t AIRCR;				 // @12 Application interrupt and reset control register
	__IO uint8_t  SCR;					 // @16 System control register
	uint8_t		  RESERVED0[3];			 // @17
	__IO uint16_t CCR;					 // @20 Configuration and control register
	uint8_t		  RESERVED1[2];			 // @22
	__IO uint32_t SHPR1;				 // @24 System handler priority registers
	__IO uint32_t SHPR2;				 // @28 System handler priority registers
	__IO uint32_t SHPR3;				 // @32 System handler priority registers
	__IO uint32_t SHCSR;				 // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR;	 // @40 Configurable fault status register
	__IO uint32_t HFSR;					 // @44 Hard fault status register
	uint8_t		  RESERVED2[4];			 // @48
	__IO uint32_t MMFAR;				 // @52 Memory management fault address register
	__IO uint32_t BFAR;					 // @56 Bus fault address register
	__IO uint32_t AFSR;					 // @60 Auxiliary fault status register
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL << 8) - 1) << 24,	 // Implementer code
	SCB_CPUID_VARIANT	  = ((1UL << 4) - 1) << 20,	 // Variant number
	SCB_CPUID_CONSTANT	  = ((1UL << 4) - 1) << 16,	 // Reads as 0xF
	SCB_CPUID_PARTNO	  = ((1UL << 12) - 1) << 4,	 // Part number of the processor
	SCB_CPUID_REVISION	  = ((1UL << 4) - 1) << 0,	 // Revision number
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type *p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type *p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20; }
inline uint32_t scb_cpuid_get_constant(struct SCB_Type *p) { return (p->CPUID & SCB_CPUID_CONSTANT) >> 16; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type *p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type *p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET	 = 1UL << 31,				// NMI set-pending bit.
	SCB_ICSR_PENDSVSET	 = 1UL << 28,				// PendSV set-pending bit
	SCB_ICSR_PENDSVCLR	 = 1UL << 27,				// PendSV clear-pending bit
	SCB_ICSR_PENDSTSET	 = 1UL << 26,				// SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR	 = 1UL << 25,				// SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING	 = 1UL << 22,				// Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL << 7) - 1) << 12,	// Pending vector
	SCB_ICSR_RETTOBASE	 = 1UL << 11,				// Return to base level
	SCB_ICSR_VECTACTIVE	 = ((1UL << 9) - 1) << 0,	// Active vector
};
inline void scb_icsr_set_vectpending(struct SCB_Type *p, uint32_t val) {
	p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val << 12) & SCB_ICSR_VECTPENDING);
}
inline void scb_icsr_set_vectactive(struct SCB_Type *p, uint32_t val) {
	p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val << 0) & SCB_ICSR_VECTACTIVE);
}
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type *p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type *p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL << 21) - 1) << 9,  // Vector table base offset field
};
inline void scb_vtor_set_tbloff(struct SCB_Type *p, uint32_t val) {
	p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val << 9) & SCB_VTOR_TBLOFF);
}
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type *p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 9; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT	= ((1UL << 16) - 1) << 16,	// Register key
	SCB_AIRCR_ENDIANESS		= 1UL << 15,				// ENDIANESS
	SCB_AIRCR_PRIGROUP		= ((1UL << 3) - 1) << 8,	// PRIGROUP
	SCB_AIRCR_SYSRESETREQ	= 1UL << 2,					// SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL << 1,					// VECTCLRACTIVE
	SCB_AIRCR_VECTRESET		= 1UL << 0,					// VECTRESET
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type *p, uint32_t val) {
	p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val << 16) & SCB_AIRCR_VECTKEYSTAT);
}
inline void scb_aircr_set_prigroup(struct SCB_Type *p, uint32_t val) {
	p->AIRCR = (p->AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val << 8) & SCB_AIRCR_PRIGROUP);
}
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type *p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16; }
inline uint32_t scb_aircr_get_prigroup(struct SCB_Type *p) { return (p->AIRCR & SCB_AIRCR_PRIGROUP) >> 8; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND	= 1UL << 4,	 // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP	= 1UL << 2,	 // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL << 1,	 // SLEEPONEXIT
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN	   = 1UL << 9,	// STKALIGN
	SCB_CCR_BFHFNMIGN	   = 1UL << 8,	// BFHFNMIGN
	SCB_CCR_DIV_0_TRP	   = 1UL << 4,	// DIV_0_TRP
	SCB_CCR_UNALIGN_TRP	   = 1UL << 3,	// UNALIGN_ TRP
	SCB_CCR_USERSETMPEND   = 1UL << 1,	// USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL << 0,	// Configures how the processor enters Thread mode
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL << 8) - 1) << 16,  // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL << 8) - 1) << 8,   // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL << 8) - 1) << 0,   // Priority of system handler 4
};
inline void scb_shpr1_set_pri_6(struct SCB_Type *p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_6) | ((val << 16) & SCB_SHPR1_PRI_6);
}
inline void scb_shpr1_set_pri_5(struct SCB_Type *p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_5) | ((val << 8) & SCB_SHPR1_PRI_5);
}
inline void scb_shpr1_set_pri_4(struct SCB_Type *p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_4) | ((val << 0) & SCB_SHPR1_PRI_4);
}
inline uint32_t scb_shpr1_get_pri_6(struct SCB_Type *p) { return (p->SHPR1 & SCB_SHPR1_PRI_6) >> 16; }
inline uint32_t scb_shpr1_get_pri_5(struct SCB_Type *p) { return (p->SHPR1 & SCB_SHPR1_PRI_5) >> 8; }
inline uint32_t scb_shpr1_get_pri_4(struct SCB_Type *p) { return (p->SHPR1 & SCB_SHPR1_PRI_4) >> 0; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL << 8) - 1) << 24,	// Priority of system handler 11
};
inline void scb_shpr2_set_pri_11(struct SCB_Type *p, uint32_t val) {
	p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val << 24) & SCB_SHPR2_PRI_11);
}
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type *p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL << 8) - 1) << 24,	// Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL << 8) - 1) << 16,	// Priority of system handler 14
};
inline void scb_shpr3_set_pri_15(struct SCB_Type *p, uint32_t val) {
	p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val << 24) & SCB_SHPR3_PRI_15);
}
inline void scb_shpr3_set_pri_14(struct SCB_Type *p, uint32_t val) {
	p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val << 16) & SCB_SHPR3_PRI_14);
}
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type *p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type *p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16; }

// SCB->SHCSR System handler control and state register
enum {
	SCB_SHCSR_USGFAULTENA	 = 1UL << 18,  // Usage fault enable bit
	SCB_SHCSR_BUSFAULTENA	 = 1UL << 17,  // Bus fault enable bit
	SCB_SHCSR_MEMFAULTENA	 = 1UL << 16,  // Memory management fault enable bit
	SCB_SHCSR_SVCALLPENDED	 = 1UL << 15,  // SVC call pending bit
	SCB_SHCSR_BUSFAULTPENDED = 1UL << 14,  // Bus fault exception pending bit
	SCB_SHCSR_MEMFAULTPENDED = 1UL << 13,  // Memory management fault exception pending bit
	SCB_SHCSR_USGFAULTPENDED = 1UL << 12,  // Usage fault exception pending bit
	SCB_SHCSR_SYSTICKACT	 = 1UL << 11,  // SysTick exception active bit
	SCB_SHCSR_PENDSVACT		 = 1UL << 10,  // PendSV exception active bit
	SCB_SHCSR_MONITORACT	 = 1UL << 8,   // Debug monitor active bit
	SCB_SHCSR_SVCALLACT		 = 1UL << 7,   // SVC call active bit
	SCB_SHCSR_USGFAULTACT	 = 1UL << 3,   // Usage fault exception active bit
	SCB_SHCSR_BUSFAULTACT	 = 1UL << 1,   // Bus fault exception active bit
	SCB_SHCSR_MEMFAULTACT	 = 1UL << 0,   // Memory management fault exception active bit
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO	 = 1UL << 25,  // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED	 = 1UL << 24,  // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP		 = 1UL << 19,  // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC		 = 1UL << 18,  // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE	 = 1UL << 17,  // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR	 = 1UL << 16,  // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID	 = 1UL << 15,  // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR		 = 1UL << 13,  // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR		 = 1UL << 12,  // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR	 = 1UL << 11,  // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL << 10,  // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR	 = 1UL << 9,   // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR	 = 1UL << 8,   // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID	 = 1UL << 7,   // Memory Management Fault Address Register (MMAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR	 = 1UL << 5,   // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR	 = 1UL << 4,   // Memory manager fault on stacking for exception entry.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR	 = 1UL << 3,   // Memory manager fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL	 = 1UL << 1,   // Data access violation flag
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL	 = 1UL << 0,   // Instruction access violation flag
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL << 31,	// Reserved for Debug use
	SCB_HFSR_FORCED	  = 1UL << 30,	// Forced hard fault
	SCB_HFSR_VECTTBL  = 1UL << 1,	// Vector table hard fault
};

/* System control block ACTLR */
struct SCB_ACTLR_Type {
	__IO uint16_t ACTRL;  // @0 Auxiliary control register
};

// SCB_ACTLR->ACTRL Auxiliary control register
enum {
	SCB_ACTLR_ACTRL_DISOOFP	   = 1UL << 9,	// DISOOFP
	SCB_ACTLR_ACTRL_DISFPCA	   = 1UL << 8,	// DISFPCA
	SCB_ACTLR_ACTRL_DISFOLD	   = 1UL << 2,	// DISFOLD
	SCB_ACTLR_ACTRL_DISDEFWBUF = 1UL << 1,	// DISDEFWBUF
	SCB_ACTLR_ACTRL_DISMCYCINT = 1UL << 0,	// DISMCYCINT
};

/* Serial peripheral interface/Inter-IC sound */
struct SPI1_Type {
	__IO uint16_t CR1;			 // @0 control register 1
	uint8_t		  RESERVED0[2];	 // @2
	__IO uint16_t CR2;			 // @4 control register 2
	uint8_t		  RESERVED1[2];	 // @6
	__IO uint16_t SR;			 // @8 status register
	uint8_t		  RESERVED2[2];	 // @10
	__IO uint16_t DR;			 // @12 data register
	uint8_t		  RESERVED3[2];	 // @14
	__IO uint16_t CRCPR;		 // @16 CRC polynomial register
	uint8_t		  RESERVED4[2];	 // @18
	__I uint16_t  RXCRCR;		 // @20 RX CRC register
	uint8_t		  RESERVED5[2];	 // @22
	__I uint16_t  TXCRCR;		 // @24 TX CRC register
	uint8_t		  RESERVED6[2];	 // @26
	__IO uint16_t I2SCFGR;		 // @28 configuration register
	uint8_t		  RESERVED7[2];	 // @30
	__IO uint16_t I2SPR;		 // @32 prescaler register
};

// SPI1->CR1 control register 1
enum {
	SPI1_CR1_BIDIMODE = 1UL << 15,				// Bidirectional data mode enable
	SPI1_CR1_BIDIOE	  = 1UL << 14,				// Output enable in bidirectional mode
	SPI1_CR1_CRCEN	  = 1UL << 13,				// Hardware CRC calculation enable
	SPI1_CR1_CRCNEXT  = 1UL << 12,				// CRC transfer next
	SPI1_CR1_DFF	  = 1UL << 11,				// Data frame format
	SPI1_CR1_RXONLY	  = 1UL << 10,				// Receive only
	SPI1_CR1_SSM	  = 1UL << 9,				// Software slave management
	SPI1_CR1_SSI	  = 1UL << 8,				// Internal slave select
	SPI1_CR1_LSBFIRST = 1UL << 7,				// Frame format
	SPI1_CR1_SPE	  = 1UL << 6,				// SPI enable
	SPI1_CR1_BR		  = ((1UL << 3) - 1) << 3,	// Baud rate control
	SPI1_CR1_MSTR	  = 1UL << 2,				// Master selection
	SPI1_CR1_CPOL	  = 1UL << 1,				// Clock polarity
	SPI1_CR1_CPHA	  = 1UL << 0,				// Clock phase
};
inline void spi1_cr1_set_br(struct SPI1_Type *p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI1_CR1_BR) | ((val << 3) & SPI1_CR1_BR); }
inline uint32_t spi1_cr1_get_br(struct SPI1_Type *p) { return (p->CR1 & SPI1_CR1_BR) >> 3; }

// SPI1->CR2 control register 2
enum {
	SPI1_CR2_LDMA_TX = 1UL << 14,			   // Last DMA transfer for transmission
	SPI1_CR2_LDMA_RX = 1UL << 13,			   // Last DMA transfer for reception
	SPI1_CR2_FRXTH	 = 1UL << 12,			   // FIFO reception threshold
	SPI1_CR2_DS		 = ((1UL << 4) - 1) << 8,  // Data size
	SPI1_CR2_TXEIE	 = 1UL << 7,			   // Tx buffer empty interrupt enable
	SPI1_CR2_RXNEIE	 = 1UL << 6,			   // RX buffer not empty interrupt enable
	SPI1_CR2_ERRIE	 = 1UL << 5,			   // Error interrupt enable
	SPI1_CR2_FRF	 = 1UL << 4,			   // Frame format
	SPI1_CR2_NSSP	 = 1UL << 3,			   // NSS pulse management
	SPI1_CR2_SSOE	 = 1UL << 2,			   // SS output enable
	SPI1_CR2_TXDMAEN = 1UL << 1,			   // Tx buffer DMA enable
	SPI1_CR2_RXDMAEN = 1UL << 0,			   // Rx buffer DMA enable
};
inline void spi1_cr2_set_ds(struct SPI1_Type *p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_DS) | ((val << 8) & SPI1_CR2_DS); }
inline uint32_t spi1_cr2_get_ds(struct SPI1_Type *p) { return (p->CR2 & SPI1_CR2_DS) >> 8; }

// SPI1->SR status register
enum {
	SPI1_SR_FTLVL  = ((1UL << 2) - 1) << 11,  // FIFO transmission level
	SPI1_SR_FRLVL  = ((1UL << 2) - 1) << 9,	  // FIFO reception level
	SPI1_SR_TIFRFE = 1UL << 8,				  // TI frame format error
	SPI1_SR_BSY	   = 1UL << 7,				  // Busy flag
	SPI1_SR_OVR	   = 1UL << 6,				  // Overrun flag
	SPI1_SR_MODF   = 1UL << 5,				  // Mode fault
	SPI1_SR_CRCERR = 1UL << 4,				  // CRC error flag
	SPI1_SR_TXE	   = 1UL << 1,				  // Transmit buffer empty
	SPI1_SR_RXNE   = 1UL << 0,				  // Receive buffer not empty
};
inline void spi1_sr_set_ftlvl(struct SPI1_Type *p, uint32_t val) {
	p->SR = (p->SR & ~SPI1_SR_FTLVL) | ((val << 11) & SPI1_SR_FTLVL);
}
inline void spi1_sr_set_frlvl(struct SPI1_Type *p, uint32_t val) {
	p->SR = (p->SR & ~SPI1_SR_FRLVL) | ((val << 9) & SPI1_SR_FRLVL);
}
inline uint32_t spi1_sr_get_ftlvl(struct SPI1_Type *p) { return (p->SR & SPI1_SR_FTLVL) >> 11; }
inline uint32_t spi1_sr_get_frlvl(struct SPI1_Type *p) { return (p->SR & SPI1_SR_FRLVL) >> 9; }

// SPI1->I2SCFGR configuration register
enum {
	SPI1_I2SCFGR_I2SMOD	 = 1UL << 11,			   // I2SMOD
	SPI1_I2SCFGR_I2SE	 = 1UL << 10,			   // I2SE
	SPI1_I2SCFGR_I2SCFG	 = ((1UL << 2) - 1) << 8,  // I2SCFG
	SPI1_I2SCFGR_PCMSYNC = 1UL << 7,			   // PCMSYNC
	SPI1_I2SCFGR_I2SSTD	 = ((1UL << 2) - 1) << 4,  // I2SSTD
	SPI1_I2SCFGR_CKPOL	 = 1UL << 3,			   // CKPOL
	SPI1_I2SCFGR_DATLEN	 = ((1UL << 2) - 1) << 1,  // DATLEN
	SPI1_I2SCFGR_CHLEN	 = 1UL << 0,			   // CHLEN
};
inline void spi1_i2scfgr_set_i2scfg(struct SPI1_Type *p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SCFG) | ((val << 8) & SPI1_I2SCFGR_I2SCFG);
}
inline void spi1_i2scfgr_set_i2sstd(struct SPI1_Type *p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SSTD) | ((val << 4) & SPI1_I2SCFGR_I2SSTD);
}
inline void spi1_i2scfgr_set_datlen(struct SPI1_Type *p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_DATLEN) | ((val << 1) & SPI1_I2SCFGR_DATLEN);
}
inline uint32_t spi1_i2scfgr_get_i2scfg(struct SPI1_Type *p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SCFG) >> 8; }
inline uint32_t spi1_i2scfgr_get_i2sstd(struct SPI1_Type *p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SSTD) >> 4; }
inline uint32_t spi1_i2scfgr_get_datlen(struct SPI1_Type *p) { return (p->I2SCFGR & SPI1_I2SCFGR_DATLEN) >> 1; }

// SPI1->I2SPR prescaler register
enum {
	SPI1_I2SPR_MCKOE  = 1UL << 9,				// MCKOE
	SPI1_I2SPR_ODD	  = 1UL << 8,				// ODD
	SPI1_I2SPR_I2SDIV = ((1UL << 8) - 1) << 0,	// I2SDIV
};
inline void spi1_i2spr_set_i2sdiv(struct SPI1_Type *p, uint32_t val) {
	p->I2SPR = (p->I2SPR & ~SPI1_I2SPR_I2SDIV) | ((val << 0) & SPI1_I2SPR_I2SDIV);
}
inline uint32_t spi1_i2spr_get_i2sdiv(struct SPI1_Type *p) { return (p->I2SPR & SPI1_I2SPR_I2SDIV) >> 0; }

/* SysTick timer */
struct STK_Type {
	__IO uint32_t CTRL;	  // @0 SysTick control and status register
	__IO uint32_t LOAD;	  // @4 SysTick reload value register
	__IO uint32_t VAL;	  // @8 SysTick current value register
	__IO uint32_t CALIB;  // @12 SysTick calibration value register
};

// STK->CTRL SysTick control and status register
enum {
	STK_CTRL_COUNTFLAG = 1UL << 16,	 // COUNTFLAG
	STK_CTRL_CLKSOURCE = 1UL << 2,	 // Clock source selection
	STK_CTRL_TICKINT   = 1UL << 1,	 // SysTick exception request enable
	STK_CTRL_ENABLE	   = 1UL << 0,	 // Counter enable
};

// STK->LOAD SysTick reload value register
enum {
	STK_LOAD_RELOAD = ((1UL << 24) - 1) << 0,  // RELOAD value
};
inline void stk_load_set_reload(struct STK_Type *p, uint32_t val) {
	p->LOAD = (p->LOAD & ~STK_LOAD_RELOAD) | ((val << 0) & STK_LOAD_RELOAD);
}
inline uint32_t stk_load_get_reload(struct STK_Type *p) { return (p->LOAD & STK_LOAD_RELOAD) >> 0; }

// STK->VAL SysTick current value register
enum {
	STK_VAL_CURRENT = ((1UL << 24) - 1) << 0,  // Current counter value
};
inline void stk_val_set_current(struct STK_Type *p, uint32_t val) {
	p->VAL = (p->VAL & ~STK_VAL_CURRENT) | ((val << 0) & STK_VAL_CURRENT);
}
inline uint32_t stk_val_get_current(struct STK_Type *p) { return (p->VAL & STK_VAL_CURRENT) >> 0; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL << 31,			   // NOREF flag. Reads as zero
	STK_CALIB_SKEW	= 1UL << 30,			   // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL << 24) - 1) << 0,  // Calibration value
};
inline void stk_calib_set_tenms(struct STK_Type *p, uint32_t val) {
	p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val << 0) & STK_CALIB_TENMS);
}
inline uint32_t stk_calib_get_tenms(struct STK_Type *p) { return (p->CALIB & STK_CALIB_TENMS) >> 0; }

/* System configuration controller */
struct SYSCFG_Type {
	__IO uint16_t MEMRMP;		 // @0 Remap Memory register
	uint8_t		  RESERVED0[2];	 // @2
	__IO uint32_t CFGR1;		 // @4 peripheral mode configuration register
	__IO uint16_t EXTICR1;		 // @8 external interrupt configuration register 1
	uint8_t		  RESERVED1[2];	 // @10
	__IO uint16_t EXTICR2;		 // @12 external interrupt configuration register 2
	uint8_t		  RESERVED2[2];	 // @14
	__IO uint16_t EXTICR3;		 // @16 external interrupt configuration register 3
	uint8_t		  RESERVED3[2];	 // @18
	__IO uint16_t EXTICR4;		 // @20 external interrupt configuration register 4
	uint8_t		  RESERVED4[2];	 // @22
	__IO uint8_t  SCSR;			 // @24 CCM SRAM control and status register
	uint8_t		  RESERVED5[3];	 // @25
	__IO uint16_t CFGR2;		 // @28 configuration register 2
	uint8_t		  RESERVED6[2];	 // @30
	__IO uint32_t SWPR;			 // @32 SRAM Write protection register 1
	__O uint8_t	  SKR;			 // @36 SRAM2 Key Register
};

// SYSCFG->MEMRMP Remap Memory register
enum {
	SYSCFG_MEMRMP_FB_MODE  = 1UL << 8,				 // User Flash Bank mode
	SYSCFG_MEMRMP_MEM_MODE = ((1UL << 3) - 1) << 0,	 // Memory mapping selection
};
inline void syscfg_memrmp_set_mem_mode(struct SYSCFG_Type *p, uint32_t val) {
	p->MEMRMP = (p->MEMRMP & ~SYSCFG_MEMRMP_MEM_MODE) | ((val << 0) & SYSCFG_MEMRMP_MEM_MODE);
}
inline uint32_t syscfg_memrmp_get_mem_mode(struct SYSCFG_Type *p) { return (p->MEMRMP & SYSCFG_MEMRMP_MEM_MODE) >> 0; }

// SYSCFG->CFGR1 peripheral mode configuration register
enum {
	SYSCFG_CFGR1_FPU_IE		 = ((1UL << 6) - 1) << 26,	// FPU Interrupts Enable
	SYSCFG_CFGR1_I2C4_FMP	 = 1UL << 23,				// I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C3_FMP	 = 1UL << 22,				// I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C2_FMP	 = 1UL << 21,				// I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C1_FMP	 = 1UL << 20,				// I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C_PB9_FMP = 1UL << 19,				// FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB8_FMP = 1UL << 18,				// FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB7_FMP = 1UL << 17,				// FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB6_FMP = 1UL << 16,				// FM+ drive capability on PB6
	SYSCFG_CFGR1_ANASWVDD	 = 1UL << 9,				// GPIO analog switch control voltage selection
	SYSCFG_CFGR1_BOOSTEN	 = 1UL << 8,				// BOOSTEN
};
inline void syscfg_cfgr1_set_fpu_ie(struct SYSCFG_Type *p, uint32_t val) {
	p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_FPU_IE) | ((val << 26) & SYSCFG_CFGR1_FPU_IE);
}
inline uint32_t syscfg_cfgr1_get_fpu_ie(struct SYSCFG_Type *p) { return (p->CFGR1 & SYSCFG_CFGR1_FPU_IE) >> 26; }

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL << 4) - 1) << 12,	// EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI2 = ((1UL << 4) - 1) << 8,	// EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI1 = ((1UL << 4) - 1) << 4,	// EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI0 = ((1UL << 4) - 1) << 0,	// EXTI x configuration (x = 0 to 3)
};
inline void syscfg_exticr1_set_exti3(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val << 12) & SYSCFG_EXTICR1_EXTI3);
}
inline void syscfg_exticr1_set_exti2(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val << 8) & SYSCFG_EXTICR1_EXTI2);
}
inline void syscfg_exticr1_set_exti1(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val << 4) & SYSCFG_EXTICR1_EXTI1);
}
inline void syscfg_exticr1_set_exti0(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val << 0) & SYSCFG_EXTICR1_EXTI0);
}
inline uint32_t syscfg_exticr1_get_exti3(struct SYSCFG_Type *p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12; }
inline uint32_t syscfg_exticr1_get_exti2(struct SYSCFG_Type *p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8; }
inline uint32_t syscfg_exticr1_get_exti1(struct SYSCFG_Type *p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4; }
inline uint32_t syscfg_exticr1_get_exti0(struct SYSCFG_Type *p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL << 4) - 1) << 12,	// EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI6 = ((1UL << 4) - 1) << 8,	// EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI5 = ((1UL << 4) - 1) << 4,	// EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI4 = ((1UL << 4) - 1) << 0,	// EXTI x configuration (x = 4 to 7)
};
inline void syscfg_exticr2_set_exti7(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val << 12) & SYSCFG_EXTICR2_EXTI7);
}
inline void syscfg_exticr2_set_exti6(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val << 8) & SYSCFG_EXTICR2_EXTI6);
}
inline void syscfg_exticr2_set_exti5(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val << 4) & SYSCFG_EXTICR2_EXTI5);
}
inline void syscfg_exticr2_set_exti4(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val << 0) & SYSCFG_EXTICR2_EXTI4);
}
inline uint32_t syscfg_exticr2_get_exti7(struct SYSCFG_Type *p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12; }
inline uint32_t syscfg_exticr2_get_exti6(struct SYSCFG_Type *p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8; }
inline uint32_t syscfg_exticr2_get_exti5(struct SYSCFG_Type *p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4; }
inline uint32_t syscfg_exticr2_get_exti4(struct SYSCFG_Type *p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL << 4) - 1) << 12,	 // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI10 = ((1UL << 4) - 1) << 8,	 // EXTI10
	SYSCFG_EXTICR3_EXTI9  = ((1UL << 4) - 1) << 4,	 // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI8  = ((1UL << 4) - 1) << 0,	 // EXTI x configuration (x = 8 to 11)
};
inline void syscfg_exticr3_set_exti11(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val << 12) & SYSCFG_EXTICR3_EXTI11);
}
inline void syscfg_exticr3_set_exti10(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val << 8) & SYSCFG_EXTICR3_EXTI10);
}
inline void syscfg_exticr3_set_exti9(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val << 4) & SYSCFG_EXTICR3_EXTI9);
}
inline void syscfg_exticr3_set_exti8(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val << 0) & SYSCFG_EXTICR3_EXTI8);
}
inline uint32_t syscfg_exticr3_get_exti11(struct SYSCFG_Type *p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12; }
inline uint32_t syscfg_exticr3_get_exti10(struct SYSCFG_Type *p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8; }
inline uint32_t syscfg_exticr3_get_exti9(struct SYSCFG_Type *p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4; }
inline uint32_t syscfg_exticr3_get_exti8(struct SYSCFG_Type *p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL << 4) - 1) << 12,	 // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI14 = ((1UL << 4) - 1) << 8,	 // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI13 = ((1UL << 4) - 1) << 4,	 // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI12 = ((1UL << 4) - 1) << 0,	 // EXTI x configuration (x = 12 to 15)
};
inline void syscfg_exticr4_set_exti15(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val << 12) & SYSCFG_EXTICR4_EXTI15);
}
inline void syscfg_exticr4_set_exti14(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val << 8) & SYSCFG_EXTICR4_EXTI14);
}
inline void syscfg_exticr4_set_exti13(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val << 4) & SYSCFG_EXTICR4_EXTI13);
}
inline void syscfg_exticr4_set_exti12(struct SYSCFG_Type *p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val << 0) & SYSCFG_EXTICR4_EXTI12);
}
inline uint32_t syscfg_exticr4_get_exti15(struct SYSCFG_Type *p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12; }
inline uint32_t syscfg_exticr4_get_exti14(struct SYSCFG_Type *p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8; }
inline uint32_t syscfg_exticr4_get_exti13(struct SYSCFG_Type *p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4; }
inline uint32_t syscfg_exticr4_get_exti12(struct SYSCFG_Type *p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0; }

// SYSCFG->SCSR CCM SRAM control and status register
enum {
	SYSCFG_SCSR_CCMBSY = 1UL << 1,	// CCM SRAM busy by erase operation
	SYSCFG_SCSR_CCMER  = 1UL << 0,	// CCM SRAM Erase
};

// SYSCFG->CFGR2 configuration register 2
enum {
	SYSCFG_CFGR2_SPF  = 1UL << 8,  // SRAM Parity Flag
	SYSCFG_CFGR2_ECCL = 1UL << 3,  // ECC Lock
	SYSCFG_CFGR2_PVDL = 1UL << 2,  // PVD Lock
	SYSCFG_CFGR2_SPL  = 1UL << 1,  // SRAM Parity Lock
	SYSCFG_CFGR2_CLL  = 1UL << 0,  // Core Lockup Lock
};

/* Tamper and backup registers */
struct TAMP_Type {
	__IO uint32_t CR1;			   // @0 control register 1
	__IO uint32_t CR2;			   // @4 control register 2
	uint8_t		  RESERVED0[4];	   // @8
	__IO uint8_t  FLTCR;		   // @12 TAMP filter control register
	uint8_t		  RESERVED1[31];   // @13
	__IO uint32_t IER;			   // @44 TAMP interrupt enable register
	__I uint32_t  SR;			   // @48 TAMP status register
	__I uint32_t  MISR;			   // @52 TAMP masked interrupt status register
	uint8_t		  RESERVED2[4];	   // @56
	__IO uint32_t SCR;			   // @60 TAMP status clear register
	uint8_t		  RESERVED3[192];  // @64
	__IO uint32_t BKP0R;		   // @256 TAMP backup register
	__IO uint32_t BKP1R;		   // @260 TAMP backup register
	__IO uint32_t BKP2R;		   // @264 TAMP backup register
	__IO uint32_t BKP3R;		   // @268 TAMP backup register
	__IO uint32_t BKP4R;		   // @272 TAMP backup register
	__IO uint32_t BKP5R;		   // @276 TAMP backup register
	__IO uint32_t BKP6R;		   // @280 TAMP backup register
	__IO uint32_t BKP7R;		   // @284 TAMP backup register
	__IO uint32_t BKP8R;		   // @288 TAMP backup register
	__IO uint32_t BKP9R;		   // @292 TAMP backup register
	__IO uint32_t BKP10R;		   // @296 TAMP backup register
	__IO uint32_t BKP11R;		   // @300 TAMP backup register
	__IO uint32_t BKP12R;		   // @304 TAMP backup register
	__IO uint32_t BKP13R;		   // @308 TAMP backup register
	__IO uint32_t BKP14R;		   // @312 TAMP backup register
	__IO uint32_t BKP15R;		   // @316 TAMP backup register
	__IO uint32_t BKP16R;		   // @320 TAMP backup register
	__IO uint32_t BKP17R;		   // @324 TAMP backup register
	__IO uint32_t BKP18R;		   // @328 TAMP backup register
	__IO uint32_t BKP19R;		   // @332 TAMP backup register
	__IO uint32_t BKP20R;		   // @336 TAMP backup register
	__IO uint32_t BKP21R;		   // @340 TAMP backup register
	__IO uint32_t BKP22R;		   // @344 TAMP backup register
	__IO uint32_t BKP23R;		   // @348 TAMP backup register
	__IO uint32_t BKP24R;		   // @352 TAMP backup register
	__IO uint32_t BKP25R;		   // @356 TAMP backup register
	__IO uint32_t BKP26R;		   // @360 TAMP backup register
	__IO uint32_t BKP27R;		   // @364 TAMP backup register
	__IO uint32_t BKP28R;		   // @368 TAMP backup register
	__IO uint32_t BKP29R;		   // @372 TAMP backup register
	__IO uint32_t BKP30R;		   // @376 TAMP backup register
	__IO uint32_t BKP31R;		   // @380 TAMP backup register
};

// TAMP->CR1 control register 1
enum {
	TAMP_CR1_ITAMP6E = 1UL << 21,  // ITAMP6E
	TAMP_CR1_ITAMP5E = 1UL << 20,  // ITAMP5E
	TAMP_CR1_ITAMP4E = 1UL << 19,  // ITAMP4E
	TAMP_CR1_ITAMP3E = 1UL << 18,  // ITAMP3E
	TAMP_CR1_TAMP3E	 = 1UL << 2,   // TAMP2E
	TAMP_CR1_TAMP2E	 = 1UL << 1,   // TAMP2E
	TAMP_CR1_TAMP1E	 = 1UL << 0,   // TAMP1E
};

// TAMP->CR2 control register 2
enum {
	TAMP_CR2_TAMP3TRG  = 1UL << 26,	 // TAMP3TRG
	TAMP_CR2_TAMP2TRG  = 1UL << 25,	 // TAMP2TRG
	TAMP_CR2_TAMP1TRG  = 1UL << 24,	 // TAMP1TRG
	TAMP_CR2_TAMP3MSK  = 1UL << 18,	 // TAMP3MSK
	TAMP_CR2_TAMP2MSK  = 1UL << 17,	 // TAMP2MSK
	TAMP_CR2_TAMP1MSK  = 1UL << 16,	 // TAMP1MSK
	TAMP_CR2_TAMP3NOER = 1UL << 2,	 // TAMP3NOER
	TAMP_CR2_TAMP2NOER = 1UL << 1,	 // TAMP2NOER
	TAMP_CR2_TAMP1NOER = 1UL << 0,	 // TAMP1NOER
};

// TAMP->FLTCR TAMP filter control register
enum {
	TAMP_FLTCR_TAMPPUDIS = 1UL << 7,			   // TAMPPUDIS
	TAMP_FLTCR_TAMPPRCH	 = ((1UL << 2) - 1) << 5,  // TAMPPRCH
	TAMP_FLTCR_TAMPFLT	 = ((1UL << 2) - 1) << 3,  // TAMPFLT
	TAMP_FLTCR_TAMPFREQ	 = ((1UL << 3) - 1) << 0,  // TAMPFREQ
};
inline void tamp_fltcr_set_tampprch(struct TAMP_Type *p, uint32_t val) {
	p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPPRCH) | ((val << 5) & TAMP_FLTCR_TAMPPRCH);
}
inline void tamp_fltcr_set_tampflt(struct TAMP_Type *p, uint32_t val) {
	p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPFLT) | ((val << 3) & TAMP_FLTCR_TAMPFLT);
}
inline void tamp_fltcr_set_tampfreq(struct TAMP_Type *p, uint32_t val) {
	p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPFREQ) | ((val << 0) & TAMP_FLTCR_TAMPFREQ);
}
inline uint32_t tamp_fltcr_get_tampprch(struct TAMP_Type *p) { return (p->FLTCR & TAMP_FLTCR_TAMPPRCH) >> 5; }
inline uint32_t tamp_fltcr_get_tampflt(struct TAMP_Type *p) { return (p->FLTCR & TAMP_FLTCR_TAMPFLT) >> 3; }
inline uint32_t tamp_fltcr_get_tampfreq(struct TAMP_Type *p) { return (p->FLTCR & TAMP_FLTCR_TAMPFREQ) >> 0; }

// TAMP->IER TAMP interrupt enable register
enum {
	TAMP_IER_ITAMP6IE = 1UL << 21,	// ITAMP6IE
	TAMP_IER_ITAMP5IE = 1UL << 20,	// ITAMP5IE
	TAMP_IER_ITAMP4IE = 1UL << 19,	// ITAMP4IE
	TAMP_IER_ITAMP3IE = 1UL << 18,	// ITAMP3IE
	TAMP_IER_TAMP3IE  = 1UL << 2,	// TAMP3IE
	TAMP_IER_TAMP2IE  = 1UL << 1,	// TAMP2IE
	TAMP_IER_TAMP1IE  = 1UL << 0,	// TAMP1IE
};

// TAMP->SR TAMP status register
enum {
	TAMP_SR_ITAMP6F = 1UL << 21,  // ITAMP6F
	TAMP_SR_ITAMP5F = 1UL << 20,  // ITAMP5F
	TAMP_SR_ITAMP4F = 1UL << 19,  // ITAMP4F
	TAMP_SR_ITAMP3F = 1UL << 18,  // ITAMP3F
	TAMP_SR_TAMP3F	= 1UL << 2,	  // TAMP3F
	TAMP_SR_TAMP2F	= 1UL << 1,	  // TAMP2F
	TAMP_SR_TAMP1F	= 1UL << 0,	  // TAMP1F
};

// TAMP->MISR TAMP masked interrupt status register
enum {
	TAMP_MISR_ITAMP6MF = 1UL << 21,	 // ITAMP6MF
	TAMP_MISR_ITAMP5MF = 1UL << 20,	 // ITAMP5MF
	TAMP_MISR_ITAMP4MF = 1UL << 19,	 // ITAMP4MF
	TAMP_MISR_ITAMP3MF = 1UL << 18,	 // ITAMP3MF
	TAMP_MISR_TAMP3MF  = 1UL << 2,	 // TAMP3MF
	TAMP_MISR_TAMP2MF  = 1UL << 1,	 // TAMP2MF
	TAMP_MISR_TAMP1MF  = 1UL << 0,	 // TAMP1MF:
};

// TAMP->SCR TAMP status clear register
enum {
	TAMP_SCR_CITAMP6F = 1UL << 21,	// CITAMP6F
	TAMP_SCR_CITAMP5F = 1UL << 20,	// CITAMP5F
	TAMP_SCR_CITAMP4F = 1UL << 19,	// CITAMP4F
	TAMP_SCR_CITAMP3F = 1UL << 18,	// CITAMP3F
	TAMP_SCR_CTAMP3F  = 1UL << 2,	// CTAMP3F
	TAMP_SCR_CTAMP2F  = 1UL << 1,	// CTAMP2F
	TAMP_SCR_CTAMP1F  = 1UL << 0,	// CTAMP1F
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1;				 // @0 control register 1
	uint8_t		  RESERVED0[2];		 // @2
	__IO uint32_t CR2;				 // @4 control register 2
	__IO uint32_t SMCR;				 // @8 slave mode control register
	__IO uint32_t DIER;				 // @12 DMA/Interrupt enable register
	__IO uint32_t SR;				 // @16 status register
	__O uint16_t  EGR;				 // @20 event generation register
	uint8_t		  RESERVED1[2];		 // @22
	union {							 // @24
		__IO uint32_t CCMR1_Output;	 // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;	 // capture/compare mode register 1 (input mode)
	};
	union {							 // @28
		__IO uint32_t CCMR2_Output;	 // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input;	 // capture/compare mode register 2 (input mode)
	};
	__IO uint32_t CCER;				// @32 capture/compare enable register
	__IO uint32_t CNT;				// @36 counter
	__IO uint16_t PSC;				// @40 prescaler
	uint8_t		  RESERVED2[2];		// @42
	__IO uint16_t ARR;				// @44 auto-reload register
	uint8_t		  RESERVED3[2];		// @46
	__IO uint16_t RCR;				// @48 repetition counter register
	uint8_t		  RESERVED4[2];		// @50
	__IO uint16_t CCR1;				// @52 capture/compare register 1
	uint8_t		  RESERVED5[2];		// @54
	__IO uint16_t CCR2;				// @56 capture/compare register 2
	uint8_t		  RESERVED6[2];		// @58
	__IO uint16_t CCR3;				// @60 capture/compare register 3
	uint8_t		  RESERVED7[2];		// @62
	__IO uint16_t CCR4;				// @64 capture/compare register 4
	uint8_t		  RESERVED8[2];		// @66
	__IO uint32_t BDTR;				// @68 break and dead-time register
	__IO uint32_t CCR5;				// @72 capture/compare register 4
	__IO uint16_t CCR6;				// @76 capture/compare register 4
	uint8_t		  RESERVED9[2];		// @78
	__IO uint32_t CCMR3_Output;		// @80 capture/compare mode register 2 (output mode)
	__IO uint32_t DTR2;				// @84 timer Deadtime Register 2
	__IO uint32_t ECR;				// @88 DMA control register
	__IO uint32_t TISEL;			// @92 TIM timer input selection register
	__IO uint32_t AF1;				// @96 TIM alternate function option register 1
	__IO uint32_t AF2;				// @100 TIM alternate function option register 2
	uint8_t		  RESERVED10[884];	// @104
	__IO uint16_t DCR;				// @988 control register
	uint8_t		  RESERVED11[2];	// @990
	__IO uint32_t DMAR;				// @992 DMA address for full transfer
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_DITHEN	  = 1UL << 12,				// Dithering Enable
	TIM1_CR1_UIFREMAP = 1UL << 11,				// UIF status bit remapping
	TIM1_CR1_CKD	  = ((1UL << 2) - 1) << 8,	// Clock division
	TIM1_CR1_ARPE	  = 1UL << 7,				// Auto-reload preload enable
	TIM1_CR1_CMS	  = ((1UL << 2) - 1) << 5,	// Center-aligned mode selection
	TIM1_CR1_DIR	  = 1UL << 4,				// Direction
	TIM1_CR1_OPM	  = 1UL << 3,				// One-pulse mode
	TIM1_CR1_URS	  = 1UL << 2,				// Update request source
	TIM1_CR1_UDIS	  = 1UL << 1,				// Update disable
	TIM1_CR1_CEN	  = 1UL << 0,				// Counter enable
};
inline void tim1_cr1_set_ckd(struct TIM1_Type *p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val << 8) & TIM1_CR1_CKD); }
inline void tim1_cr1_set_cms(struct TIM1_Type *p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val << 5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type *p) { return (p->CR1 & TIM1_CR1_CKD) >> 8; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type *p) { return (p->CR1 & TIM1_CR1_CMS) >> 5; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_MMS_3 = 1UL << 25,				  // Master mode selection - bit 3
	TIM1_CR2_MMS2  = ((1UL << 4) - 1) << 20,  // Master mode selection 2
	TIM1_CR2_OIS6  = 1UL << 18,				  // Output Idle state 6 (OC6 output)
	TIM1_CR2_OIS5  = 1UL << 16,				  // Output Idle state 5 (OC5 output)
	TIM1_CR2_OIS4N = 1UL << 15,				  // Output Idle state 4 (OC4N output)
	TIM1_CR2_OIS4  = 1UL << 14,				  // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL << 13,				  // Output Idle state 3
	TIM1_CR2_OIS3  = 1UL << 12,				  // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL << 11,				  // Output Idle state 2
	TIM1_CR2_OIS2  = 1UL << 10,				  // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL << 9,				  // Output Idle state 1
	TIM1_CR2_OIS1  = 1UL << 8,				  // Output Idle state 1
	TIM1_CR2_TI1S  = 1UL << 7,				  // TI1 selection
	TIM1_CR2_MMS   = ((1UL << 3) - 1) << 4,	  // Master mode selection
	TIM1_CR2_CCDS  = 1UL << 3,				  // Capture/compare DMA selection
	TIM1_CR2_CCUS  = 1UL << 2,				  // Capture/compare control update selection
	TIM1_CR2_CCPC  = 1UL << 0,				  // Capture/compare preloaded control
};
inline void tim1_cr2_set_mms2(struct TIM1_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~TIM1_CR2_MMS2) | ((val << 20) & TIM1_CR2_MMS2);
}
inline void tim1_cr2_set_mms(struct TIM1_Type *p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val << 4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms2(struct TIM1_Type *p) { return (p->CR2 & TIM1_CR2_MMS2) >> 20; }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type *p) { return (p->CR2 & TIM1_CR2_MMS) >> 4; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_SMSPS	 = 1UL << 25,				// SMS Preload Source
	TIM1_SMCR_SMSPE	 = 1UL << 24,				// SMS Preload Enable
	TIM1_SMCR_TS_4_3 = ((1UL << 2) - 1) << 20,	// Trigger selection - bit 4:3
	TIM1_SMCR_SMS_3	 = 1UL << 16,				// Slave mode selection - bit 3
	TIM1_SMCR_ETP	 = 1UL << 15,				// External trigger polarity
	TIM1_SMCR_ECE	 = 1UL << 14,				// External clock enable
	TIM1_SMCR_ETPS	 = ((1UL << 2) - 1) << 12,	// External trigger prescaler
	TIM1_SMCR_ETF	 = ((1UL << 4) - 1) << 8,	// External trigger filter
	TIM1_SMCR_MSM	 = 1UL << 7,				// Master/Slave mode
	TIM1_SMCR_TS	 = ((1UL << 3) - 1) << 4,	// Trigger selection
	TIM1_SMCR_OCCS	 = 1UL << 3,				// OCREF clear selection
	TIM1_SMCR_SMS	 = ((1UL << 3) - 1) << 0,	// Slave mode selection
};
inline void tim1_smcr_set_ts_4_3(struct TIM1_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_TS_4_3) | ((val << 20) & TIM1_SMCR_TS_4_3);
}
inline void tim1_smcr_set_etps(struct TIM1_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val << 12) & TIM1_SMCR_ETPS);
}
inline void tim1_smcr_set_etf(struct TIM1_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val << 8) & TIM1_SMCR_ETF);
}
inline void tim1_smcr_set_ts(struct TIM1_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val << 4) & TIM1_SMCR_TS);
}
inline void tim1_smcr_set_sms(struct TIM1_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val << 0) & TIM1_SMCR_SMS);
}
inline uint32_t tim1_smcr_get_ts_4_3(struct TIM1_Type *p) { return (p->SMCR & TIM1_SMCR_TS_4_3) >> 20; }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type *p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type *p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8; }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type *p) { return (p->SMCR & TIM1_SMCR_TS) >> 4; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type *p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TERRIE = 1UL << 23,  // Transition Error interrupt enable
	TIM1_DIER_IERRIE = 1UL << 22,  // Index Error interrupt enable
	TIM1_DIER_DIRIE	 = 1UL << 21,  // Direction Change interrupt enable
	TIM1_DIER_IDXIE	 = 1UL << 20,  // Index interrupt enable
	TIM1_DIER_TDE	 = 1UL << 14,  // Trigger DMA request enable
	TIM1_DIER_COMDE	 = 1UL << 13,  // COM DMA request enable
	TIM1_DIER_CC4DE	 = 1UL << 12,  // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE	 = 1UL << 11,  // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE	 = 1UL << 10,  // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE	 = 1UL << 9,   // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE	 = 1UL << 8,   // Update DMA request enable
	TIM1_DIER_BIE	 = 1UL << 7,   // Break interrupt enable
	TIM1_DIER_TIE	 = 1UL << 6,   // Trigger interrupt enable
	TIM1_DIER_COMIE	 = 1UL << 5,   // COM interrupt enable
	TIM1_DIER_CC4IE	 = 1UL << 4,   // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE	 = 1UL << 3,   // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE	 = 1UL << 2,   // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE	 = 1UL << 1,   // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE	 = 1UL << 0,   // Update interrupt enable
};

// TIM1->SR status register
enum {
	TIM1_SR_TERRF = 1UL << 23,	// Transition Error interrupt flag
	TIM1_SR_IERRF = 1UL << 22,	// Index Error interrupt flag
	TIM1_SR_DIRF  = 1UL << 21,	// Direction Change interrupt flag
	TIM1_SR_IDXF  = 1UL << 20,	// Index interrupt flag
	TIM1_SR_CC6IF = 1UL << 17,	// Compare 6 interrupt flag
	TIM1_SR_CC5IF = 1UL << 16,	// Compare 5 interrupt flag
	TIM1_SR_SBIF  = 1UL << 13,	// System Break interrupt flag
	TIM1_SR_CC4OF = 1UL << 12,	// Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL << 11,	// Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL << 10,	// Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL << 9,	// Capture/Compare 1 overcapture flag
	TIM1_SR_B2IF  = 1UL << 8,	// Break 2 interrupt flag
	TIM1_SR_BIF	  = 1UL << 7,	// Break interrupt flag
	TIM1_SR_TIF	  = 1UL << 6,	// Trigger interrupt flag
	TIM1_SR_COMIF = 1UL << 5,	// COM interrupt flag
	TIM1_SR_CC4IF = 1UL << 4,	// Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL << 3,	// Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL << 2,	// Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL << 1,	// Capture/compare 1 interrupt flag
	TIM1_SR_UIF	  = 1UL << 0,	// Update interrupt flag
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_B2G  = 1UL << 8,  // Break 2 generation
	TIM1_EGR_BG	  = 1UL << 7,  // Break generation
	TIM1_EGR_TG	  = 1UL << 6,  // Trigger generation
	TIM1_EGR_COMG = 1UL << 5,  // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL << 4,  // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL << 3,  // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL << 2,  // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL << 1,  // Capture/compare 1 generation
	TIM1_EGR_UG	  = 1UL << 0,  // Update generation
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2M_3 = 1UL << 24,				// Output Compare 2 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC1M_3 = 1UL << 16,				// Output Compare 1 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC2CE	 = 1UL << 15,				// Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M	 = ((1UL << 3) - 1) << 12,	// Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE	 = 1UL << 11,				// Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE	 = 1UL << 10,				// Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S	 = ((1UL << 2) - 1) << 8,	// Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE	 = 1UL << 7,				// Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M	 = ((1UL << 3) - 1) << 4,	// Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE	 = 1UL << 3,				// Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE	 = 1UL << 2,				// Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S	 = ((1UL << 2) - 1) << 0,	// Capture/Compare 1 selection
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM1_CCMR1_OUTPUT_OC2M);
}
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM1_CCMR1_OUTPUT_CC2S);
}
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM1_CCMR1_OUTPUT_OC1M);
}
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM1_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type *p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type *p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type *p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type *p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4M_3 = 1UL << 24,				// Output Compare 4 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC3M_3 = 1UL << 16,				// Output Compare 3 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC4CE	 = 1UL << 15,				// Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M	 = ((1UL << 3) - 1) << 12,	// Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE	 = 1UL << 11,				// Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE	 = 1UL << 10,				// Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S	 = ((1UL << 2) - 1) << 8,	// Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE	 = 1UL << 7,				// Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M	 = ((1UL << 3) - 1) << 4,	// Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE	 = 1UL << 3,				// Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE	 = 1UL << 2,				// Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S	 = ((1UL << 2) - 1) << 0,	// Capture/Compare 3 selection
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type *p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val << 12) & TIM1_CCMR2_OUTPUT_OC4M);
}
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type *p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val << 8) & TIM1_CCMR2_OUTPUT_CC4S);
}
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type *p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val << 4) & TIM1_CCMR2_OUTPUT_OC3M);
}
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type *p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val << 0) & TIM1_CCMR2_OUTPUT_CC3S);
}
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type *p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type *p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type *p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type *p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC6P	= 1UL << 21,  // Capture/Compare 6 output polarity
	TIM1_CCER_CC6E	= 1UL << 20,  // Capture/Compare 6 output enable
	TIM1_CCER_CC5P	= 1UL << 17,  // Capture/Compare 5 output polarity
	TIM1_CCER_CC5E	= 1UL << 16,  // Capture/Compare 5 output enable
	TIM1_CCER_CC4NP = 1UL << 15,  // Capture/Compare 4 complementary output polarity
	TIM1_CCER_CC4NE = 1UL << 14,  // Capture/Compare 4 complementary output enable
	TIM1_CCER_CC4P	= 1UL << 13,  // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E	= 1UL << 12,  // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL << 11,  // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL << 10,  // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P	= 1UL << 9,	  // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E	= 1UL << 8,	  // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL << 7,	  // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL << 6,	  // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P	= 1UL << 5,	  // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E	= 1UL << 4,	  // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL << 3,	  // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL << 2,	  // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P	= 1UL << 1,	  // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E	= 1UL << 0,	  // Capture/Compare 1 output enable
};

// TIM1->CNT counter
enum {
	TIM1_CNT_UIFCPY = 1UL << 31,			   // UIFCPY
	TIM1_CNT_CNT	= ((1UL << 16) - 1) << 0,  // counter value
};
inline void tim1_cnt_set_cnt(struct TIM1_Type *p, uint32_t val) { p->CNT = (p->CNT & ~TIM1_CNT_CNT) | ((val << 0) & TIM1_CNT_CNT); }
inline uint32_t tim1_cnt_get_cnt(struct TIM1_Type *p) { return (p->CNT & TIM1_CNT_CNT) >> 0; }

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_BK2ID	  = 1UL << 29,				 // BK2ID
	TIM1_BDTR_BKBID	  = 1UL << 28,				 // BKBID
	TIM1_BDTR_BK2DSRM = 1UL << 27,				 // BK2DSRM
	TIM1_BDTR_BKDSRM  = 1UL << 26,				 // BKDSRM
	TIM1_BDTR_BK2P	  = 1UL << 25,				 // Break 2 polarity
	TIM1_BDTR_BK2E	  = 1UL << 24,				 // Break 2 Enable
	TIM1_BDTR_BK2F	  = ((1UL << 4) - 1) << 20,	 // Break 2 filter
	TIM1_BDTR_BKF	  = ((1UL << 4) - 1) << 16,	 // Break filter
	TIM1_BDTR_MOE	  = 1UL << 15,				 // Main output enable
	TIM1_BDTR_AOE	  = 1UL << 14,				 // Automatic output enable
	TIM1_BDTR_BKP	  = 1UL << 13,				 // Break polarity
	TIM1_BDTR_BKE	  = 1UL << 12,				 // Break enable
	TIM1_BDTR_OSSR	  = 1UL << 11,				 // Off-state selection for Run mode
	TIM1_BDTR_OSSI	  = 1UL << 10,				 // Off-state selection for Idle mode
	TIM1_BDTR_LOCK	  = ((1UL << 2) - 1) << 8,	 // Lock configuration
	TIM1_BDTR_DTG	  = ((1UL << 8) - 1) << 0,	 // Dead-time generator setup
};
inline void tim1_bdtr_set_bk2f(struct TIM1_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM1_BDTR_BK2F) | ((val << 20) & TIM1_BDTR_BK2F);
}
inline void tim1_bdtr_set_bkf(struct TIM1_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM1_BDTR_BKF) | ((val << 16) & TIM1_BDTR_BKF);
}
inline void tim1_bdtr_set_lock(struct TIM1_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val << 8) & TIM1_BDTR_LOCK);
}
inline void tim1_bdtr_set_dtg(struct TIM1_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val << 0) & TIM1_BDTR_DTG);
}
inline uint32_t tim1_bdtr_get_bk2f(struct TIM1_Type *p) { return (p->BDTR & TIM1_BDTR_BK2F) >> 20; }
inline uint32_t tim1_bdtr_get_bkf(struct TIM1_Type *p) { return (p->BDTR & TIM1_BDTR_BKF) >> 16; }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type *p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type *p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0; }

// TIM1->CCR5 capture/compare register 4
enum {
	TIM1_CCR5_GC5C3 = 1UL << 31,			   // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL << 30,			   // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL << 29,			   // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5	= ((1UL << 16) - 1) << 0,  // Capture/Compare value
};
inline void tim1_ccr5_set_ccr5(struct TIM1_Type *p, uint32_t val) {
	p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val << 0) & TIM1_CCR5_CCR5);
}
inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type *p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0; }

// TIM1->CCMR3_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M_BIT3 = 1UL << 24,			   // Output Compare 6 mode bit 3
	TIM1_CCMR3_OUTPUT_OC5M_BIT3 = ((1UL << 3) - 1) << 16,  // Output Compare 5 mode bit 3
	TIM1_CCMR3_OUTPUT_OC6CE		= 1UL << 15,			   // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M		= ((1UL << 3) - 1) << 12,  // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE		= 1UL << 11,			   // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE		= 1UL << 10,			   // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE		= 1UL << 7,				   // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M		= ((1UL << 3) - 1) << 4,   // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE		= 1UL << 3,				   // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE		= 1UL << 2,				   // Output compare 5 fast enable
};
inline void tim1_ccmr3_output_set_oc5m_bit3(struct TIM1_Type *p, uint32_t val) {
	p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M_BIT3) | ((val << 16) & TIM1_CCMR3_OUTPUT_OC5M_BIT3);
}
inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type *p, uint32_t val) {
	p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val << 12) & TIM1_CCMR3_OUTPUT_OC6M);
}
inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type *p, uint32_t val) {
	p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val << 4) & TIM1_CCMR3_OUTPUT_OC5M);
}
inline uint32_t tim1_ccmr3_output_get_oc5m_bit3(struct TIM1_Type *p) {
	return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M_BIT3) >> 16;
}
inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type *p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12; }
inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type *p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4; }

// TIM1->DTR2 timer Deadtime Register 2
enum {
	TIM1_DTR2_DTPE = 1UL << 17,				 // Deadtime Preload Enable
	TIM1_DTR2_DTAE = 1UL << 16,				 // Deadtime Asymmetric Enable
	TIM1_DTR2_DTGF = ((1UL << 8) - 1) << 0,	 // Dead-time falling edge generator setup
};
inline void tim1_dtr2_set_dtgf(struct TIM1_Type *p, uint32_t val) {
	p->DTR2 = (p->DTR2 & ~TIM1_DTR2_DTGF) | ((val << 0) & TIM1_DTR2_DTGF);
}
inline uint32_t tim1_dtr2_get_dtgf(struct TIM1_Type *p) { return (p->DTR2 & TIM1_DTR2_DTGF) >> 0; }

// TIM1->ECR DMA control register
enum {
	TIM1_ECR_PWPRSC = ((1UL << 3) - 1) << 24,  // Pulse Width prescaler
	TIM1_ECR_PW		= ((1UL << 8) - 1) << 16,  // Pulse width
	TIM1_ECR_IPOS	= ((1UL << 2) - 1) << 6,   // Index Positioning
	TIM1_ECR_FIDX	= 1UL << 5,				   // First Index
	TIM1_ECR_IBLK	= ((1UL << 2) - 1) << 3,   // Index Blanking
	TIM1_ECR_IDIR	= ((1UL << 2) - 1) << 1,   // Index Direction
	TIM1_ECR_IE		= 1UL << 0,				   // Index Enable
};
inline void tim1_ecr_set_pwprsc(struct TIM1_Type *p, uint32_t val) {
	p->ECR = (p->ECR & ~TIM1_ECR_PWPRSC) | ((val << 24) & TIM1_ECR_PWPRSC);
}
inline void tim1_ecr_set_pw(struct TIM1_Type *p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_PW) | ((val << 16) & TIM1_ECR_PW); }
inline void tim1_ecr_set_ipos(struct TIM1_Type *p, uint32_t val) {
	p->ECR = (p->ECR & ~TIM1_ECR_IPOS) | ((val << 6) & TIM1_ECR_IPOS);
}
inline void tim1_ecr_set_iblk(struct TIM1_Type *p, uint32_t val) {
	p->ECR = (p->ECR & ~TIM1_ECR_IBLK) | ((val << 3) & TIM1_ECR_IBLK);
}
inline void tim1_ecr_set_idir(struct TIM1_Type *p, uint32_t val) {
	p->ECR = (p->ECR & ~TIM1_ECR_IDIR) | ((val << 1) & TIM1_ECR_IDIR);
}
inline uint32_t tim1_ecr_get_pwprsc(struct TIM1_Type *p) { return (p->ECR & TIM1_ECR_PWPRSC) >> 24; }
inline uint32_t tim1_ecr_get_pw(struct TIM1_Type *p) { return (p->ECR & TIM1_ECR_PW) >> 16; }
inline uint32_t tim1_ecr_get_ipos(struct TIM1_Type *p) { return (p->ECR & TIM1_ECR_IPOS) >> 6; }
inline uint32_t tim1_ecr_get_iblk(struct TIM1_Type *p) { return (p->ECR & TIM1_ECR_IBLK) >> 3; }
inline uint32_t tim1_ecr_get_idir(struct TIM1_Type *p) { return (p->ECR & TIM1_ECR_IDIR) >> 1; }

// TIM1->TISEL TIM timer input selection register
enum {
	TIM1_TISEL_TI4SEL = ((1UL << 4) - 1) << 24,	 // TI4[0] to TI4[15] input selection
	TIM1_TISEL_TI3SEL = ((1UL << 4) - 1) << 16,	 // TI3[0] to TI3[15] input selection
	TIM1_TISEL_TI2SEL = ((1UL << 4) - 1) << 8,	 // TI2[0] to TI2[15] input selection
	TIM1_TISEL_TI1SEL = ((1UL << 4) - 1) << 0,	 // TI1[0] to TI1[15] input selection
};
inline void tim1_tisel_set_ti4sel(struct TIM1_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI4SEL) | ((val << 24) & TIM1_TISEL_TI4SEL);
}
inline void tim1_tisel_set_ti3sel(struct TIM1_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI3SEL) | ((val << 16) & TIM1_TISEL_TI3SEL);
}
inline void tim1_tisel_set_ti2sel(struct TIM1_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI2SEL) | ((val << 8) & TIM1_TISEL_TI2SEL);
}
inline void tim1_tisel_set_ti1sel(struct TIM1_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI1SEL) | ((val << 0) & TIM1_TISEL_TI1SEL);
}
inline uint32_t tim1_tisel_get_ti4sel(struct TIM1_Type *p) { return (p->TISEL & TIM1_TISEL_TI4SEL) >> 24; }
inline uint32_t tim1_tisel_get_ti3sel(struct TIM1_Type *p) { return (p->TISEL & TIM1_TISEL_TI3SEL) >> 16; }
inline uint32_t tim1_tisel_get_ti2sel(struct TIM1_Type *p) { return (p->TISEL & TIM1_TISEL_TI2SEL) >> 8; }
inline uint32_t tim1_tisel_get_ti1sel(struct TIM1_Type *p) { return (p->TISEL & TIM1_TISEL_TI1SEL) >> 0; }

// TIM1->AF1 TIM alternate function option register 1
enum {
	TIM1_AF1_ETRSEL	 = ((1UL << 4) - 1) << 14,	// ETR source selection
	TIM1_AF1_BKCMP4P = 1UL << 13,				// BRK COMP4 input polarity
	TIM1_AF1_BKCMP3P = 1UL << 12,				// BRK COMP3 input polarity
	TIM1_AF1_BKCMP2P = 1UL << 11,				// BRK COMP2 input polarity
	TIM1_AF1_BKCMP1P = 1UL << 10,				// BRK COMP1 input polarity
	TIM1_AF1_BKINP	 = 1UL << 9,				// BRK BKIN input polarity
	TIM1_AF1_BKCMP7E = 1UL << 7,				// BRK COMP7 enable
	TIM1_AF1_BKCMP6E = 1UL << 6,				// BRK COMP6 enable
	TIM1_AF1_BKCMP5E = 1UL << 5,				// BRK COMP5 enable
	TIM1_AF1_BKCMP4E = 1UL << 4,				// BRK COMP4 enable
	TIM1_AF1_BKCMP3E = 1UL << 3,				// BRK COMP3 enable
	TIM1_AF1_BKCMP2E = 1UL << 2,				// BRK COMP2 enable
	TIM1_AF1_BKCMP1E = 1UL << 1,				// BRK COMP1 enable
	TIM1_AF1_BKINE	 = 1UL << 0,				// BRK BKIN input enable
};
inline void tim1_af1_set_etrsel(struct TIM1_Type *p, uint32_t val) {
	p->AF1 = (p->AF1 & ~TIM1_AF1_ETRSEL) | ((val << 14) & TIM1_AF1_ETRSEL);
}
inline uint32_t tim1_af1_get_etrsel(struct TIM1_Type *p) { return (p->AF1 & TIM1_AF1_ETRSEL) >> 14; }

// TIM1->AF2 TIM alternate function option register 2
enum {
	TIM1_AF2_OCRSEL	  = ((1UL << 3) - 1) << 16,	 // OCREF_CLR source selection
	TIM1_AF2_BK2CMP4P = 1UL << 13,				 // BRK2 COMP4 input polarity
	TIM1_AF2_BK2CMP3P = 1UL << 12,				 // BRK2 COMP3 input polarity
	TIM1_AF2_BK2CMP2P = 1UL << 11,				 // BRK2 COMP2 input polarity
	TIM1_AF2_BK2CMP1P = 1UL << 10,				 // BRK2 COMP1 input polarity
	TIM1_AF2_BK2INP	  = 1UL << 9,				 // BRK2 BKIN input polarity
	TIM1_AF2_BK2CMP7E = 1UL << 7,				 // BRK2 COMP7 enable
	TIM1_AF2_BK2CMP6E = 1UL << 6,				 // BRK2 COMP6 enable
	TIM1_AF2_BK2CMP5E = 1UL << 5,				 // BRK2 COMP5 enable
	TIM1_AF2_BK2CMP4E = 1UL << 4,				 // BRK2 COMP4 enable
	TIM1_AF2_BK2CMP3E = 1UL << 3,				 // BRK2 COMP3 enable
	TIM1_AF2_BK2CMP2E = 1UL << 2,				 // BRK2 COMP2 enable
	TIM1_AF2_BK2CMP1E = 1UL << 1,				 // BRK2 COMP1 enable
	TIM1_AF2_BKINE	  = 1UL << 0,				 // BRK BKIN input enable
};
inline void tim1_af2_set_ocrsel(struct TIM1_Type *p, uint32_t val) {
	p->AF2 = (p->AF2 & ~TIM1_AF2_OCRSEL) | ((val << 16) & TIM1_AF2_OCRSEL);
}
inline uint32_t tim1_af2_get_ocrsel(struct TIM1_Type *p) { return (p->AF2 & TIM1_AF2_OCRSEL) >> 16; }

// TIM1->DCR control register
enum {
	TIM1_DCR_DBL = ((1UL << 5) - 1) << 8,  // DMA burst length
	TIM1_DCR_DBA = ((1UL << 5) - 1) << 0,  // DMA base address
};
inline void tim1_dcr_set_dbl(struct TIM1_Type *p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val << 8) & TIM1_DCR_DBL); }
inline void tim1_dcr_set_dba(struct TIM1_Type *p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val << 0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type *p) { return (p->DCR & TIM1_DCR_DBL) >> 8; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type *p) { return (p->DCR & TIM1_DCR_DBA) >> 0; }

// Valid Casts:

inline struct TIM6_Type *TIM1_as_TIM6_Type(struct TIM1_Type *p) { return (struct TIM6_Type *)p; }

/* General purpose timers */
struct TIM15_Type {
	__IO uint16_t CR1;				 // @0 control register 1
	uint8_t		  RESERVED0[2];		 // @2
	__IO uint16_t CR2;				 // @4 control register 2
	uint8_t		  RESERVED1[2];		 // @6
	__IO uint32_t SMCR;				 // @8 slave mode control register
	__IO uint16_t DIER;				 // @12 DMA/Interrupt enable register
	uint8_t		  RESERVED2[2];		 // @14
	__IO uint16_t SR;				 // @16 status register
	uint8_t		  RESERVED3[2];		 // @18
	__O uint8_t	  EGR;				 // @20 event generation register
	uint8_t		  RESERVED4[3];		 // @21
	union {							 // @24
		__IO uint32_t CCMR1_Output;	 // capture/compare mode register (output mode)
		__IO uint16_t CCMR1_Input;	 // capture/compare mode register 1 (input mode)
	};
	uint8_t		  RESERVED5[4];		// @28
	__IO uint8_t  CCER;				// @32 capture/compare enable register
	uint8_t		  RESERVED6[3];		// @33
	__IO uint32_t CNT;				// @36 counter
	__IO uint16_t PSC;				// @40 prescaler
	uint8_t		  RESERVED7[2];		// @42
	__IO uint16_t ARR;				// @44 auto-reload register
	uint8_t		  RESERVED8[2];		// @46
	__IO uint8_t  RCR;				// @48 repetition counter register
	uint8_t		  RESERVED9[3];		// @49
	__IO uint16_t CCR1;				// @52 capture/compare register 1
	uint8_t		  RESERVED10[2];	// @54
	__IO uint16_t CCR2;				// @56 capture/compare register 2
	uint8_t		  RESERVED11[10];	// @58
	__IO uint32_t BDTR;				// @68 break and dead-time register
	uint8_t		  RESERVED12[12];	// @72
	__IO uint32_t DTR2;				// @84 timer Deadtime Register 2
	uint8_t		  RESERVED13[4];	// @88
	__IO uint16_t TISEL;			// @92 TIM timer input selection register
	uint8_t		  RESERVED14[2];	// @94
	__IO uint16_t AF1;				// @96 TIM alternate function option register 1
	uint8_t		  RESERVED15[2];	// @98
	__IO uint32_t AF2;				// @100 TIM alternate function option register 2
	uint8_t		  RESERVED16[884];	// @104
	__IO uint16_t DCR;				// @988 DMA control register
	uint8_t		  RESERVED17[2];	// @990
	__IO uint32_t DMAR;				// @992 DMA address for full transfer
};

// TIM15->CR1 control register 1
enum {
	TIM15_CR1_DITHEN   = 1UL << 12,				 // Dithering Enable
	TIM15_CR1_UIFREMAP = 1UL << 11,				 // UIF status bit remapping
	TIM15_CR1_CKD	   = ((1UL << 2) - 1) << 8,	 // Clock division
	TIM15_CR1_ARPE	   = 1UL << 7,				 // Auto-reload preload enable
	TIM15_CR1_OPM	   = 1UL << 3,				 // One-pulse mode
	TIM15_CR1_URS	   = 1UL << 2,				 // Update request source
	TIM15_CR1_UDIS	   = 1UL << 1,				 // Update disable
	TIM15_CR1_CEN	   = 1UL << 0,				 // Counter enable
};
inline void tim15_cr1_set_ckd(struct TIM15_Type *p, uint32_t val) {
	p->CR1 = (p->CR1 & ~TIM15_CR1_CKD) | ((val << 8) & TIM15_CR1_CKD);
}
inline uint32_t tim15_cr1_get_ckd(struct TIM15_Type *p) { return (p->CR1 & TIM15_CR1_CKD) >> 8; }

// TIM15->CR2 control register 2
enum {
	TIM15_CR2_OIS2	= 1UL << 10,			  // Output idle state 2 (OC2 output)
	TIM15_CR2_OIS1N = 1UL << 9,				  // Output Idle state 1
	TIM15_CR2_OIS1	= 1UL << 8,				  // Output Idle state 1
	TIM15_CR2_TI1S	= 1UL << 7,				  // TI1 selection
	TIM15_CR2_MMS	= ((1UL << 3) - 1) << 4,  // Master mode selection
	TIM15_CR2_CCDS	= 1UL << 3,				  // Capture/compare DMA selection
	TIM15_CR2_CCUS	= 1UL << 2,				  // Capture/compare control update selection
	TIM15_CR2_CCPC	= 1UL << 0,				  // Capture/compare preloaded control
};
inline void tim15_cr2_set_mms(struct TIM15_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~TIM15_CR2_MMS) | ((val << 4) & TIM15_CR2_MMS);
}
inline uint32_t tim15_cr2_get_mms(struct TIM15_Type *p) { return (p->CR2 & TIM15_CR2_MMS) >> 4; }

// TIM15->SMCR slave mode control register
enum {
	TIM15_SMCR_TS_4_3 = ((1UL << 2) - 1) << 20,	 // Trigger selection - bit 4:3
	TIM15_SMCR_SMS_3  = 1UL << 16,				 // Slave mode selection - bit 3
	TIM15_SMCR_MSM	  = 1UL << 7,				 // Master/Slave mode
	TIM15_SMCR_TS	  = ((1UL << 3) - 1) << 4,	 // Trigger selection
	TIM15_SMCR_SMS	  = ((1UL << 3) - 1) << 0,	 // Slave mode selection
};
inline void tim15_smcr_set_ts_4_3(struct TIM15_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM15_SMCR_TS_4_3) | ((val << 20) & TIM15_SMCR_TS_4_3);
}
inline void tim15_smcr_set_ts(struct TIM15_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM15_SMCR_TS) | ((val << 4) & TIM15_SMCR_TS);
}
inline void tim15_smcr_set_sms(struct TIM15_Type *p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM15_SMCR_SMS) | ((val << 0) & TIM15_SMCR_SMS);
}
inline uint32_t tim15_smcr_get_ts_4_3(struct TIM15_Type *p) { return (p->SMCR & TIM15_SMCR_TS_4_3) >> 20; }
inline uint32_t tim15_smcr_get_ts(struct TIM15_Type *p) { return (p->SMCR & TIM15_SMCR_TS) >> 4; }
inline uint32_t tim15_smcr_get_sms(struct TIM15_Type *p) { return (p->SMCR & TIM15_SMCR_SMS) >> 0; }

// TIM15->DIER DMA/Interrupt enable register
enum {
	TIM15_DIER_TDE	 = 1UL << 14,  // Trigger DMA request enable
	TIM15_DIER_COMDE = 1UL << 13,  // COM DMA request enable
	TIM15_DIER_CC2DE = 1UL << 10,  // Capture/Compare 2 DMA request enable
	TIM15_DIER_CC1DE = 1UL << 9,   // Capture/Compare 1 DMA request enable
	TIM15_DIER_UDE	 = 1UL << 8,   // Update DMA request enable
	TIM15_DIER_BIE	 = 1UL << 7,   // Break interrupt enable
	TIM15_DIER_TIE	 = 1UL << 6,   // Trigger interrupt enable
	TIM15_DIER_COMIE = 1UL << 5,   // COM interrupt enable
	TIM15_DIER_CC2IE = 1UL << 2,   // Capture/Compare 2 interrupt enable
	TIM15_DIER_CC1IE = 1UL << 1,   // Capture/Compare 1 interrupt enable
	TIM15_DIER_UIE	 = 1UL << 0,   // Update interrupt enable
};

// TIM15->SR status register
enum {
	TIM15_SR_CC2OF = 1UL << 10,	 // Capture/Compare 2 overcapture flag
	TIM15_SR_CC1OF = 1UL << 9,	 // Capture/Compare 1 overcapture flag
	TIM15_SR_BIF   = 1UL << 7,	 // Break interrupt flag
	TIM15_SR_TIF   = 1UL << 6,	 // Trigger interrupt flag
	TIM15_SR_COMIF = 1UL << 5,	 // COM interrupt flag
	TIM15_SR_CC2IF = 1UL << 2,	 // Capture/compare 2 interrupt flag
	TIM15_SR_CC1IF = 1UL << 1,	 // Capture/compare 1 interrupt flag
	TIM15_SR_UIF   = 1UL << 0,	 // Update interrupt flag
};

// TIM15->EGR event generation register
enum {
	TIM15_EGR_BG   = 1UL << 7,	// Break generation
	TIM15_EGR_TG   = 1UL << 6,	// Trigger generation
	TIM15_EGR_COMG = 1UL << 5,	// Capture/Compare control update generation
	TIM15_EGR_CC2G = 1UL << 2,	// Capture/compare 2 generation
	TIM15_EGR_CC1G = 1UL << 1,	// Capture/compare 1 generation
	TIM15_EGR_UG   = 1UL << 0,	// Update generation
};

// TIM15->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM15_CCMR1_OUTPUT_OC2M_3 = 1UL << 24,				 // Output Compare 2 mode - bit 3
	TIM15_CCMR1_OUTPUT_OC1M_3 = 1UL << 16,				 // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC2M	  = ((1UL << 3) - 1) << 12,	 // OC2M
	TIM15_CCMR1_OUTPUT_OC2PE  = 1UL << 11,				 // OC2PE
	TIM15_CCMR1_OUTPUT_OC2FE  = 1UL << 10,				 // OC2FE
	TIM15_CCMR1_OUTPUT_CC2S	  = ((1UL << 2) - 1) << 8,	 // CC2S
	TIM15_CCMR1_OUTPUT_OC1CE  = 1UL << 7,				 // OC1CE
	TIM15_CCMR1_OUTPUT_OC1M	  = ((1UL << 3) - 1) << 4,	 // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1PE  = 1UL << 3,				 // Output Compare 1 preload enable
	TIM15_CCMR1_OUTPUT_OC1FE  = 1UL << 2,				 // Output Compare 1 fast enable
	TIM15_CCMR1_OUTPUT_CC1S	  = ((1UL << 2) - 1) << 0,	 // Capture/Compare 1 selection
};
inline void tim15_ccmr1_output_set_oc2m(struct TIM15_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM15_CCMR1_OUTPUT_OC2M);
}
inline void tim15_ccmr1_output_set_cc2s(struct TIM15_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM15_CCMR1_OUTPUT_CC2S);
}
inline void tim15_ccmr1_output_set_oc1m(struct TIM15_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM15_CCMR1_OUTPUT_OC1M);
}
inline void tim15_ccmr1_output_set_cc1s(struct TIM15_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM15_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim15_ccmr1_output_get_oc2m(struct TIM15_Type *p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim15_ccmr1_output_get_cc2s(struct TIM15_Type *p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim15_ccmr1_output_get_oc1m(struct TIM15_Type *p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim15_ccmr1_output_get_cc1s(struct TIM15_Type *p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM15->CCER capture/compare enable register
enum {
	TIM15_CCER_CC2NP = 1UL << 7,  // Capture/Compare 2 complementary output polarity
	TIM15_CCER_CC2P	 = 1UL << 5,  // Capture/Compare 2 output polarity
	TIM15_CCER_CC2E	 = 1UL << 4,  // Capture/Compare 2 output enable
	TIM15_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1NE = 1UL << 2,  // Capture/Compare 1 complementary output enable
	TIM15_CCER_CC1P	 = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1E	 = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM15->CNT counter
enum {
	TIM15_CNT_UIFCPY = 1UL << 31,				// UIF Copy
	TIM15_CNT_CNT	 = ((1UL << 16) - 1) << 0,	// counter value
};
inline void tim15_cnt_set_cnt(struct TIM15_Type *p, uint32_t val) {
	p->CNT = (p->CNT & ~TIM15_CNT_CNT) | ((val << 0) & TIM15_CNT_CNT);
}
inline uint32_t tim15_cnt_get_cnt(struct TIM15_Type *p) { return (p->CNT & TIM15_CNT_CNT) >> 0; }

// TIM15->BDTR break and dead-time register
enum {
	TIM15_BDTR_BKBID  = 1UL << 28,				 // BKBID
	TIM15_BDTR_BKDSRM = 1UL << 26,				 // BKDSRM
	TIM15_BDTR_BKF	  = ((1UL << 4) - 1) << 16,	 // Break filter
	TIM15_BDTR_MOE	  = 1UL << 15,				 // Main output enable
	TIM15_BDTR_AOE	  = 1UL << 14,				 // Automatic output enable
	TIM15_BDTR_BKP	  = 1UL << 13,				 // Break polarity
	TIM15_BDTR_BKE	  = 1UL << 12,				 // Break enable
	TIM15_BDTR_OSSR	  = 1UL << 11,				 // Off-state selection for Run mode
	TIM15_BDTR_OSSI	  = 1UL << 10,				 // Off-state selection for Idle mode
	TIM15_BDTR_LOCK	  = ((1UL << 2) - 1) << 8,	 // Lock configuration
	TIM15_BDTR_DTG	  = ((1UL << 8) - 1) << 0,	 // Dead-time generator setup
};
inline void tim15_bdtr_set_bkf(struct TIM15_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM15_BDTR_BKF) | ((val << 16) & TIM15_BDTR_BKF);
}
inline void tim15_bdtr_set_lock(struct TIM15_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM15_BDTR_LOCK) | ((val << 8) & TIM15_BDTR_LOCK);
}
inline void tim15_bdtr_set_dtg(struct TIM15_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM15_BDTR_DTG) | ((val << 0) & TIM15_BDTR_DTG);
}
inline uint32_t tim15_bdtr_get_bkf(struct TIM15_Type *p) { return (p->BDTR & TIM15_BDTR_BKF) >> 16; }
inline uint32_t tim15_bdtr_get_lock(struct TIM15_Type *p) { return (p->BDTR & TIM15_BDTR_LOCK) >> 8; }
inline uint32_t tim15_bdtr_get_dtg(struct TIM15_Type *p) { return (p->BDTR & TIM15_BDTR_DTG) >> 0; }

// TIM15->DTR2 timer Deadtime Register 2
enum {
	TIM15_DTR2_DTPE = 1UL << 17,			  // Deadtime Preload Enable
	TIM15_DTR2_DTAE = 1UL << 16,			  // Deadtime Asymmetric Enable
	TIM15_DTR2_DTGF = ((1UL << 8) - 1) << 0,  // Dead-time generator setup
};
inline void tim15_dtr2_set_dtgf(struct TIM15_Type *p, uint32_t val) {
	p->DTR2 = (p->DTR2 & ~TIM15_DTR2_DTGF) | ((val << 0) & TIM15_DTR2_DTGF);
}
inline uint32_t tim15_dtr2_get_dtgf(struct TIM15_Type *p) { return (p->DTR2 & TIM15_DTR2_DTGF) >> 0; }

// TIM15->TISEL TIM timer input selection register
enum {
	TIM15_TISEL_TI2SEL = ((1UL << 4) - 1) << 8,	 // TI2[0] to TI2[15] input selection
	TIM15_TISEL_TI1SEL = ((1UL << 4) - 1) << 0,	 // TI1[0] to TI1[15] input selection
};
inline void tim15_tisel_set_ti2sel(struct TIM15_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM15_TISEL_TI2SEL) | ((val << 8) & TIM15_TISEL_TI2SEL);
}
inline void tim15_tisel_set_ti1sel(struct TIM15_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM15_TISEL_TI1SEL) | ((val << 0) & TIM15_TISEL_TI1SEL);
}
inline uint32_t tim15_tisel_get_ti2sel(struct TIM15_Type *p) { return (p->TISEL & TIM15_TISEL_TI2SEL) >> 8; }
inline uint32_t tim15_tisel_get_ti1sel(struct TIM15_Type *p) { return (p->TISEL & TIM15_TISEL_TI1SEL) >> 0; }

// TIM15->AF1 TIM alternate function option register 1
enum {
	TIM15_AF1_BKCMP4P = 1UL << 13,	// BRK COMP4 input polarity
	TIM15_AF1_BKCMP3P = 1UL << 12,	// BRK COMP3 input polarity
	TIM15_AF1_BKCMP2P = 1UL << 11,	// BRK COMP2 input polarity
	TIM15_AF1_BKCMP1P = 1UL << 10,	// BRK COMP1 input polarity
	TIM15_AF1_BKINP	  = 1UL << 9,	// BRK BKIN input polarity
	TIM15_AF1_BKCMP7E = 1UL << 7,	// BRK COMP7 enable
	TIM15_AF1_BKCMP6E = 1UL << 6,	// BRK COMP6 enable
	TIM15_AF1_BKCMP5E = 1UL << 5,	// BRK COMP5 enable
	TIM15_AF1_BKCMP4E = 1UL << 4,	// BRK COMP4 enable
	TIM15_AF1_BKCMP3E = 1UL << 3,	// BRK COMP3 enable
	TIM15_AF1_BKCMP2E = 1UL << 2,	// BRK COMP2 enable
	TIM15_AF1_BKCMP1E = 1UL << 1,	// BRK COMP1 enable
	TIM15_AF1_BKINE	  = 1UL << 0,	// BRK BKIN input enable
};

// TIM15->AF2 TIM alternate function option register 2
enum {
	TIM15_AF2_OCRSEL = ((1UL << 3) - 1) << 16,	// OCREF_CLR source selection
};
inline void tim15_af2_set_ocrsel(struct TIM15_Type *p, uint32_t val) {
	p->AF2 = (p->AF2 & ~TIM15_AF2_OCRSEL) | ((val << 16) & TIM15_AF2_OCRSEL);
}
inline uint32_t tim15_af2_get_ocrsel(struct TIM15_Type *p) { return (p->AF2 & TIM15_AF2_OCRSEL) >> 16; }

// TIM15->DCR DMA control register
enum {
	TIM15_DCR_DBL = ((1UL << 5) - 1) << 8,	// DMA burst length
	TIM15_DCR_DBA = ((1UL << 5) - 1) << 0,	// DMA base address
};
inline void tim15_dcr_set_dbl(struct TIM15_Type *p, uint32_t val) {
	p->DCR = (p->DCR & ~TIM15_DCR_DBL) | ((val << 8) & TIM15_DCR_DBL);
}
inline void tim15_dcr_set_dba(struct TIM15_Type *p, uint32_t val) {
	p->DCR = (p->DCR & ~TIM15_DCR_DBA) | ((val << 0) & TIM15_DCR_DBA);
}
inline uint32_t tim15_dcr_get_dbl(struct TIM15_Type *p) { return (p->DCR & TIM15_DCR_DBL) >> 8; }
inline uint32_t tim15_dcr_get_dba(struct TIM15_Type *p) { return (p->DCR & TIM15_DCR_DBA) >> 0; }

// Valid Casts:

inline struct TIM6_Type *TIM15_as_TIM6_Type(struct TIM15_Type *p) { return (struct TIM6_Type *)p; }

/* General purpose timers */
struct TIM16_Type {
	__IO uint16_t CR1;				 // @0 control register 1
	uint8_t		  RESERVED0[2];		 // @2
	__IO uint16_t CR2;				 // @4 control register 2
	uint8_t		  RESERVED1[6];		 // @6
	__IO uint16_t DIER;				 // @12 DMA/Interrupt enable register
	uint8_t		  RESERVED2[2];		 // @14
	__IO uint16_t SR;				 // @16 status register
	uint8_t		  RESERVED3[2];		 // @18
	__O uint8_t	  EGR;				 // @20 event generation register
	uint8_t		  RESERVED4[3];		 // @21
	union {							 // @24
		__IO uint32_t CCMR1_Output;	 // capture/compare mode register (output mode)
		__IO uint8_t  CCMR1_Input;	 // capture/compare mode register 1 (input mode)
	};
	uint8_t		  RESERVED5[4];		// @28
	__IO uint8_t  CCER;				// @32 capture/compare enable register
	uint8_t		  RESERVED6[3];		// @33
	__IO uint32_t CNT;				// @36 counter
	__IO uint16_t PSC;				// @40 prescaler
	uint8_t		  RESERVED7[2];		// @42
	__IO uint16_t ARR;				// @44 auto-reload register
	uint8_t		  RESERVED8[2];		// @46
	__IO uint8_t  RCR;				// @48 repetition counter register
	uint8_t		  RESERVED9[3];		// @49
	__IO uint16_t CCR1;				// @52 capture/compare register 1
	uint8_t		  RESERVED10[14];	// @54
	__IO uint32_t BDTR;				// @68 break and dead-time register
	uint8_t		  RESERVED11[12];	// @72
	__IO uint32_t DTR2;				// @84 timer Deadtime Register 2
	uint8_t		  RESERVED12[4];	// @88
	__IO uint8_t  TISEL;			// @92 TIM timer input selection register
	uint8_t		  RESERVED13[3];	// @93
	__IO uint16_t AF1;				// @96 TIM alternate function option register 1
	uint8_t		  RESERVED14[2];	// @98
	__IO uint32_t AF2;				// @100 TIM alternate function option register 2
	__IO uint8_t  OR1;				// @104 TIM option register 1
	uint8_t		  RESERVED15[883];	// @105
	__IO uint16_t DCR;				// @988 DMA control register
	uint8_t		  RESERVED16[2];	// @990
	__IO uint32_t DMAR;				// @992 DMA address for full transfer
};

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_DITHEN   = 1UL << 12,				 // Dithering Enable
	TIM16_CR1_UIFREMAP = 1UL << 11,				 // UIF status bit remapping
	TIM16_CR1_CKD	   = ((1UL << 2) - 1) << 8,	 // Clock division
	TIM16_CR1_ARPE	   = 1UL << 7,				 // Auto-reload preload enable
	TIM16_CR1_OPM	   = 1UL << 3,				 // One-pulse mode
	TIM16_CR1_URS	   = 1UL << 2,				 // Update request source
	TIM16_CR1_UDIS	   = 1UL << 1,				 // Update disable
	TIM16_CR1_CEN	   = 1UL << 0,				 // Counter enable
};
inline void tim16_cr1_set_ckd(struct TIM16_Type *p, uint32_t val) {
	p->CR1 = (p->CR1 & ~TIM16_CR1_CKD) | ((val << 8) & TIM16_CR1_CKD);
}
inline uint32_t tim16_cr1_get_ckd(struct TIM16_Type *p) { return (p->CR1 & TIM16_CR1_CKD) >> 8; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL << 9,	 // Output Idle state 1
	TIM16_CR2_OIS1	= 1UL << 8,	 // Output Idle state 1
	TIM16_CR2_CCDS	= 1UL << 3,	 // Capture/compare DMA selection
	TIM16_CR2_CCUS	= 1UL << 2,	 // Capture/compare control update selection
	TIM16_CR2_CCPC	= 1UL << 0,	 // Capture/compare preloaded control
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_COMDE = 1UL << 13,  // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL << 9,   // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE	 = 1UL << 8,   // Update DMA request enable
	TIM16_DIER_BIE	 = 1UL << 7,   // Break interrupt enable
	TIM16_DIER_COMIE = 1UL << 5,   // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL << 1,   // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE	 = 1UL << 0,   // Update interrupt enable
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL << 9,	// Capture/Compare 1 overcapture flag
	TIM16_SR_BIF   = 1UL << 7,	// Break interrupt flag
	TIM16_SR_COMIF = 1UL << 5,	// COM interrupt flag
	TIM16_SR_CC1IF = 1UL << 1,	// Capture/compare 1 interrupt flag
	TIM16_SR_UIF   = 1UL << 0,	// Update interrupt flag
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG   = 1UL << 7,	// Break generation
	TIM16_EGR_COMG = 1UL << 5,	// Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL << 1,	// Capture/compare 1 generation
	TIM16_EGR_UG   = 1UL << 0,	// Update generation
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_3 = 1UL << 16,				// Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M	  = ((1UL << 3) - 1) << 4,	// Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE  = 1UL << 3,				// Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE  = 1UL << 2,				// Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S	  = ((1UL << 2) - 1) << 0,	// Capture/Compare 1 selection
};
inline void tim16_ccmr1_output_set_oc1m(struct TIM16_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM16_CCMR1_OUTPUT_OC1M);
}
inline void tim16_ccmr1_output_set_cc1s(struct TIM16_Type *p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM16_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim16_ccmr1_output_get_oc1m(struct TIM16_Type *p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim16_ccmr1_output_get_cc1s(struct TIM16_Type *p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL << 2,  // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P	 = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E	 = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL << 31,				// UIF Copy
	TIM16_CNT_CNT	 = ((1UL << 16) - 1) << 0,	// counter value
};
inline void tim16_cnt_set_cnt(struct TIM16_Type *p, uint32_t val) {
	p->CNT = (p->CNT & ~TIM16_CNT_CNT) | ((val << 0) & TIM16_CNT_CNT);
}
inline uint32_t tim16_cnt_get_cnt(struct TIM16_Type *p) { return (p->CNT & TIM16_CNT_CNT) >> 0; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKBID  = 1UL << 28,				 // BKBID
	TIM16_BDTR_BKDSRM = 1UL << 26,				 // BKDSRM
	TIM16_BDTR_BKF	  = ((1UL << 4) - 1) << 16,	 // Break filter
	TIM16_BDTR_MOE	  = 1UL << 15,				 // Main output enable
	TIM16_BDTR_AOE	  = 1UL << 14,				 // Automatic output enable
	TIM16_BDTR_BKP	  = 1UL << 13,				 // Break polarity
	TIM16_BDTR_BKE	  = 1UL << 12,				 // Break enable
	TIM16_BDTR_OSSR	  = 1UL << 11,				 // Off-state selection for Run mode
	TIM16_BDTR_OSSI	  = 1UL << 10,				 // Off-state selection for Idle mode
	TIM16_BDTR_LOCK	  = ((1UL << 2) - 1) << 8,	 // Lock configuration
	TIM16_BDTR_DTG	  = ((1UL << 8) - 1) << 0,	 // Dead-time generator setup
};
inline void tim16_bdtr_set_bkf(struct TIM16_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM16_BDTR_BKF) | ((val << 16) & TIM16_BDTR_BKF);
}
inline void tim16_bdtr_set_lock(struct TIM16_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM16_BDTR_LOCK) | ((val << 8) & TIM16_BDTR_LOCK);
}
inline void tim16_bdtr_set_dtg(struct TIM16_Type *p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM16_BDTR_DTG) | ((val << 0) & TIM16_BDTR_DTG);
}
inline uint32_t tim16_bdtr_get_bkf(struct TIM16_Type *p) { return (p->BDTR & TIM16_BDTR_BKF) >> 16; }
inline uint32_t tim16_bdtr_get_lock(struct TIM16_Type *p) { return (p->BDTR & TIM16_BDTR_LOCK) >> 8; }
inline uint32_t tim16_bdtr_get_dtg(struct TIM16_Type *p) { return (p->BDTR & TIM16_BDTR_DTG) >> 0; }

// TIM16->DTR2 timer Deadtime Register 2
enum {
	TIM16_DTR2_DTPE = 1UL << 17,			  // Deadtime Preload Enable
	TIM16_DTR2_DTAE = 1UL << 16,			  // Deadtime Asymmetric Enable
	TIM16_DTR2_DTGF = ((1UL << 8) - 1) << 0,  // Dead-time generator setup
};
inline void tim16_dtr2_set_dtgf(struct TIM16_Type *p, uint32_t val) {
	p->DTR2 = (p->DTR2 & ~TIM16_DTR2_DTGF) | ((val << 0) & TIM16_DTR2_DTGF);
}
inline uint32_t tim16_dtr2_get_dtgf(struct TIM16_Type *p) { return (p->DTR2 & TIM16_DTR2_DTGF) >> 0; }

// TIM16->TISEL TIM timer input selection register
enum {
	TIM16_TISEL_TI1SEL = ((1UL << 4) - 1) << 0,	 // TI1[0] to TI1[15] input selection
};
inline void tim16_tisel_set_ti1sel(struct TIM16_Type *p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM16_TISEL_TI1SEL) | ((val << 0) & TIM16_TISEL_TI1SEL);
}
inline uint32_t tim16_tisel_get_ti1sel(struct TIM16_Type *p) { return (p->TISEL & TIM16_TISEL_TI1SEL) >> 0; }

// TIM16->AF1 TIM alternate function option register 1
enum {
	TIM16_AF1_BKCMP4P = 1UL << 13,	// BRK COMP4 input polarity
	TIM16_AF1_BKCMP3P = 1UL << 12,	// BRK COMP3 input polarity
	TIM16_AF1_BKCMP2P = 1UL << 11,	// BRK COMP2 input polarity
	TIM16_AF1_BKCMP1P = 1UL << 10,	// BRK COMP1 input polarity
	TIM16_AF1_BKINP	  = 1UL << 9,	// BRK BKIN input polarity
	TIM16_AF1_BKCMP7E = 1UL << 7,	// BRK COMP7 enable
	TIM16_AF1_BKCMP6E = 1UL << 6,	// BRK COMP6 enable
	TIM16_AF1_BKCMP5E = 1UL << 5,	// BRK COMP5 enable
	TIM16_AF1_BKCMP4E = 1UL << 4,	// BRK COMP4 enable
	TIM16_AF1_BKCMP3E = 1UL << 3,	// BRK COMP3 enable
	TIM16_AF1_BKCMP2E = 1UL << 2,	// BRK COMP2 enable
	TIM16_AF1_BKCMP1E = 1UL << 1,	// BRK COMP1 enable
	TIM16_AF1_BKINE	  = 1UL << 0,	// BRK BKIN input enable
};

// TIM16->AF2 TIM alternate function option register 2
enum {
	TIM16_AF2_OCRSEL = ((1UL << 3) - 1) << 16,	// OCREF_CLR source selection
};
inline void tim16_af2_set_ocrsel(struct TIM16_Type *p, uint32_t val) {
	p->AF2 = (p->AF2 & ~TIM16_AF2_OCRSEL) | ((val << 16) & TIM16_AF2_OCRSEL);
}
inline uint32_t tim16_af2_get_ocrsel(struct TIM16_Type *p) { return (p->AF2 & TIM16_AF2_OCRSEL) >> 16; }

// TIM16->OR1 TIM option register 1
enum {
	TIM16_OR1_HSE32EN = 1UL << 0,  // HSE Divided by 32 enable
};

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL << 5) - 1) << 8,	// DMA burst length
	TIM16_DCR_DBA = ((1UL << 5) - 1) << 0,	// DMA base address
};
inline void tim16_dcr_set_dbl(struct TIM16_Type *p, uint32_t val) {
	p->DCR = (p->DCR & ~TIM16_DCR_DBL) | ((val << 8) & TIM16_DCR_DBL);
}
inline void tim16_dcr_set_dba(struct TIM16_Type *p, uint32_t val) {
	p->DCR = (p->DCR & ~TIM16_DCR_DBA) | ((val << 0) & TIM16_DCR_DBA);
}
inline uint32_t tim16_dcr_get_dbl(struct TIM16_Type *p) { return (p->DCR & TIM16_DCR_DBL) >> 8; }
inline uint32_t tim16_dcr_get_dba(struct TIM16_Type *p) { return (p->DCR & TIM16_DCR_DBA) >> 0; }

/* Basic-timers */
struct TIM6_Type {
	__IO uint16_t CR1;			  // @0 control register 1
	uint8_t		  RESERVED0[2];	  // @2
	__IO uint8_t  CR2;			  // @4 control register 2
	uint8_t		  RESERVED1[7];	  // @5
	__IO uint16_t DIER;			  // @12 DMA/Interrupt enable register
	uint8_t		  RESERVED2[2];	  // @14
	__IO uint8_t  SR;			  // @16 status register
	uint8_t		  RESERVED3[3];	  // @17
	__O uint8_t	  EGR;			  // @20 event generation register
	uint8_t		  RESERVED4[15];  // @21
	__IO uint32_t CNT;			  // @36 counter
	__IO uint16_t PSC;			  // @40 prescaler
	uint8_t		  RESERVED5[2];	  // @42
	__IO uint16_t ARR;			  // @44 auto-reload register
};

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_DITHEN	  = 1UL << 12,	// Dithering Enable
	TIM6_CR1_UIFREMAP = 1UL << 11,	// UIF status bit remapping
	TIM6_CR1_ARPE	  = 1UL << 7,	// Auto-reload preload enable
	TIM6_CR1_OPM	  = 1UL << 3,	// One-pulse mode
	TIM6_CR1_URS	  = 1UL << 2,	// Update request source
	TIM6_CR1_UDIS	  = 1UL << 1,	// Update disable
	TIM6_CR1_CEN	  = 1UL << 0,	// Counter enable
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL << 3) - 1) << 4,  // Master mode selection
};
inline void tim6_cr2_set_mms(struct TIM6_Type *p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val << 4) & TIM6_CR2_MMS); }
inline uint32_t tim6_cr2_get_mms(struct TIM6_Type *p) { return (p->CR2 & TIM6_CR2_MMS) >> 4; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL << 8,  // Update DMA request enable
	TIM6_DIER_UIE = 1UL << 0,  // Update interrupt enable
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL << 0,	 // Update interrupt flag
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL << 0,	 // Update generation
};

// TIM6->CNT counter
enum {
	TIM6_CNT_UIFCPY = 1UL << 31,			   // UIF Copy
	TIM6_CNT_CNT	= ((1UL << 16) - 1) << 0,  // Low counter value
};
inline void tim6_cnt_set_cnt(struct TIM6_Type *p, uint32_t val) { p->CNT = (p->CNT & ~TIM6_CNT_CNT) | ((val << 0) & TIM6_CNT_CNT); }
inline uint32_t tim6_cnt_get_cnt(struct TIM6_Type *p) { return (p->CNT & TIM6_CNT_CNT) >> 0; }

/* Universal synchronous asynchronous receiver transmitter */
struct USART_Type {
	__IO uint32_t CR1;			 // @0 Control register 1
	__IO uint32_t CR2;			 // @4 Control register 2
	__IO uint32_t CR3;			 // @8 Control register 3
	__IO uint16_t BRR;			 // @12 Baud rate register
	uint8_t		  RESERVED0[2];	 // @14
	__IO uint16_t GTPR;			 // @16 Guard time and prescaler register
	uint8_t		  RESERVED1[2];	 // @18
	__IO uint32_t RTOR;			 // @20 Receiver timeout register
	__O uint8_t	  RQR;			 // @24 Request register
	uint8_t		  RESERVED2[3];	 // @25
	__I uint32_t  ISR;			 // @28 Interrupt & status register
	__O uint32_t  ICR;			 // @32 Interrupt flag clear register
	__I uint16_t  RDR;			 // @36 Receive data register
	uint8_t		  RESERVED3[2];	 // @38
	__IO uint16_t TDR;			 // @40 Transmit data register
	uint8_t		  RESERVED4[2];	 // @42
	__IO uint8_t  PRESC;		 // @44 USART prescaler register
};

// USART->CR1 Control register 1
enum {
	USART_CR1_RXFFIE = 1UL << 31,  // RXFFIE
	USART_CR1_TXFEIE = 1UL << 30,  // TXFEIE
	USART_CR1_FIFOEN = 1UL << 29,  // FIFOEN
	USART_CR1_M1	 = 1UL << 28,  // M1
	USART_CR1_EOBIE	 = 1UL << 27,  // End of Block interrupt enable
	USART_CR1_RTOIE	 = 1UL << 26,  // Receiver timeout interrupt enable
	USART_CR1_DEAT4	 = 1UL << 25,  // Driver Enable assertion time
	USART_CR1_DEAT3	 = 1UL << 24,  // DEAT3
	USART_CR1_DEAT2	 = 1UL << 23,  // DEAT2
	USART_CR1_DEAT1	 = 1UL << 22,  // DEAT1
	USART_CR1_DEAT0	 = 1UL << 21,  // DEAT0
	USART_CR1_DEDT4	 = 1UL << 20,  // Driver Enable de-assertion time
	USART_CR1_DEDT3	 = 1UL << 19,  // DEDT3
	USART_CR1_DEDT2	 = 1UL << 18,  // DEDT2
	USART_CR1_DEDT1	 = 1UL << 17,  // DEDT1
	USART_CR1_DEDT0	 = 1UL << 16,  // DEDT0
	USART_CR1_OVER8	 = 1UL << 15,  // Oversampling mode
	USART_CR1_CMIE	 = 1UL << 14,  // Character match interrupt enable
	USART_CR1_MME	 = 1UL << 13,  // Mute mode enable
	USART_CR1_M0	 = 1UL << 12,  // Word length
	USART_CR1_WAKE	 = 1UL << 11,  // Receiver wakeup method
	USART_CR1_PCE	 = 1UL << 10,  // Parity control enable
	USART_CR1_PS	 = 1UL << 9,   // Parity selection
	USART_CR1_PEIE	 = 1UL << 8,   // PE interrupt enable
	USART_CR1_TXEIE	 = 1UL << 7,   // interrupt enable
	USART_CR1_TCIE	 = 1UL << 6,   // Transmission complete interrupt enable
	USART_CR1_RXNEIE = 1UL << 5,   // RXNE interrupt enable
	USART_CR1_IDLEIE = 1UL << 4,   // IDLE interrupt enable
	USART_CR1_TE	 = 1UL << 3,   // Transmitter enable
	USART_CR1_RE	 = 1UL << 2,   // Receiver enable
	USART_CR1_UESM	 = 1UL << 1,   // USART enable in Stop mode
	USART_CR1_UE	 = 1UL << 0,   // USART enable
};

// USART->CR2 Control register 2
enum {
	USART_CR2_ADD4_7   = ((1UL << 4) - 1) << 28,  // Address of the USART node
	USART_CR2_ADD0_3   = ((1UL << 4) - 1) << 24,  // Address of the USART node
	USART_CR2_RTOEN	   = 1UL << 23,				  // Receiver timeout enable
	USART_CR2_ABRMOD1  = 1UL << 22,				  // Auto baud rate mode
	USART_CR2_ABRMOD0  = 1UL << 21,				  // ABRMOD0
	USART_CR2_ABREN	   = 1UL << 20,				  // Auto baud rate enable
	USART_CR2_MSBFIRST = 1UL << 19,				  // Most significant bit first
	USART_CR2_TAINV	   = 1UL << 18,				  // Binary data inversion
	USART_CR2_TXINV	   = 1UL << 17,				  // TX pin active level inversion
	USART_CR2_RXINV	   = 1UL << 16,				  // RX pin active level inversion
	USART_CR2_SWAP	   = 1UL << 15,				  // Swap TX/RX pins
	USART_CR2_LINEN	   = 1UL << 14,				  // LIN mode enable
	USART_CR2_STOP	   = ((1UL << 2) - 1) << 12,  // STOP bits
	USART_CR2_CLKEN	   = 1UL << 11,				  // Clock enable
	USART_CR2_CPOL	   = 1UL << 10,				  // Clock polarity
	USART_CR2_CPHA	   = 1UL << 9,				  // Clock phase
	USART_CR2_LBCL	   = 1UL << 8,				  // Last bit clock pulse
	USART_CR2_LBDIE	   = 1UL << 6,				  // LIN break detection interrupt enable
	USART_CR2_LBDL	   = 1UL << 5,				  // LIN break detection length
	USART_CR2_ADDM7	   = 1UL << 4,				  // 7-bit Address Detection/4-bit Address Detection
	USART_CR2_DIS_NSS  = 1UL << 3,				  // DIS_NSS
	USART_CR2_SLVEN	   = 1UL << 0,				  // SLVEN
};
inline void usart_cr2_set_add4_7(struct USART_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~USART_CR2_ADD4_7) | ((val << 28) & USART_CR2_ADD4_7);
}
inline void usart_cr2_set_add0_3(struct USART_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~USART_CR2_ADD0_3) | ((val << 24) & USART_CR2_ADD0_3);
}
inline void usart_cr2_set_stop(struct USART_Type *p, uint32_t val) {
	p->CR2 = (p->CR2 & ~USART_CR2_STOP) | ((val << 12) & USART_CR2_STOP);
}
inline uint32_t usart_cr2_get_add4_7(struct USART_Type *p) { return (p->CR2 & USART_CR2_ADD4_7) >> 28; }
inline uint32_t usart_cr2_get_add0_3(struct USART_Type *p) { return (p->CR2 & USART_CR2_ADD0_3) >> 24; }
inline uint32_t usart_cr2_get_stop(struct USART_Type *p) { return (p->CR2 & USART_CR2_STOP) >> 12; }

// USART->CR3 Control register 3
enum {
	USART_CR3_TXFTCFG = ((1UL << 3) - 1) << 29,	 // TXFTCFG
	USART_CR3_RXFTIE  = 1UL << 28,				 // RXFTIE
	USART_CR3_RXFTCFG = ((1UL << 3) - 1) << 25,	 // RXFTCFG
	USART_CR3_TCBGTIE = 1UL << 24,				 // TCBGTIE
	USART_CR3_TXFTIE  = 1UL << 23,				 // TXFTIE
	USART_CR3_WUFIE	  = 1UL << 22,				 // Wakeup from Stop mode interrupt enable
	USART_CR3_WUS	  = ((1UL << 2) - 1) << 20,	 // Wakeup from Stop mode interrupt flag selection
	USART_CR3_SCARCNT = ((1UL << 3) - 1) << 17,	 // Smartcard auto-retry count
	USART_CR3_DEP	  = 1UL << 15,				 // Driver enable polarity selection
	USART_CR3_DEM	  = 1UL << 14,				 // Driver enable mode
	USART_CR3_DDRE	  = 1UL << 13,				 // DMA Disable on Reception Error
	USART_CR3_OVRDIS  = 1UL << 12,				 // Overrun Disable
	USART_CR3_ONEBIT  = 1UL << 11,				 // One sample bit method enable
	USART_CR3_CTSIE	  = 1UL << 10,				 // CTS interrupt enable
	USART_CR3_CTSE	  = 1UL << 9,				 // CTS enable
	USART_CR3_RTSE	  = 1UL << 8,				 // RTS enable
	USART_CR3_DMAT	  = 1UL << 7,				 // DMA enable transmitter
	USART_CR3_DMAR	  = 1UL << 6,				 // DMA enable receiver
	USART_CR3_SCEN	  = 1UL << 5,				 // Smartcard mode enable
	USART_CR3_NACK	  = 1UL << 4,				 // Smartcard NACK enable
	USART_CR3_HDSEL	  = 1UL << 3,				 // Half-duplex selection
	USART_CR3_IRLP	  = 1UL << 2,				 // Ir low-power
	USART_CR3_IREN	  = 1UL << 1,				 // Ir mode enable
	USART_CR3_EIE	  = 1UL << 0,				 // Error interrupt enable
};
inline void usart_cr3_set_txftcfg(struct USART_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_TXFTCFG) | ((val << 29) & USART_CR3_TXFTCFG);
}
inline void usart_cr3_set_rxftcfg(struct USART_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_RXFTCFG) | ((val << 25) & USART_CR3_RXFTCFG);
}
inline void usart_cr3_set_wus(struct USART_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_WUS) | ((val << 20) & USART_CR3_WUS);
}
inline void usart_cr3_set_scarcnt(struct USART_Type *p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_SCARCNT) | ((val << 17) & USART_CR3_SCARCNT);
}
inline uint32_t usart_cr3_get_txftcfg(struct USART_Type *p) { return (p->CR3 & USART_CR3_TXFTCFG) >> 29; }
inline uint32_t usart_cr3_get_rxftcfg(struct USART_Type *p) { return (p->CR3 & USART_CR3_RXFTCFG) >> 25; }
inline uint32_t usart_cr3_get_wus(struct USART_Type *p) { return (p->CR3 & USART_CR3_WUS) >> 20; }
inline uint32_t usart_cr3_get_scarcnt(struct USART_Type *p) { return (p->CR3 & USART_CR3_SCARCNT) >> 17; }

// USART->BRR Baud rate register
enum {
	USART_BRR_DIV_MANTISSA = ((1UL << 12) - 1) << 4,  // DIV_Mantissa
	USART_BRR_DIV_FRACTION = ((1UL << 4) - 1) << 0,	  // DIV_Fraction
};
inline void usart_brr_set_div_mantissa(struct USART_Type *p, uint32_t val) {
	p->BRR = (p->BRR & ~USART_BRR_DIV_MANTISSA) | ((val << 4) & USART_BRR_DIV_MANTISSA);
}
inline void usart_brr_set_div_fraction(struct USART_Type *p, uint32_t val) {
	p->BRR = (p->BRR & ~USART_BRR_DIV_FRACTION) | ((val << 0) & USART_BRR_DIV_FRACTION);
}
inline uint32_t usart_brr_get_div_mantissa(struct USART_Type *p) { return (p->BRR & USART_BRR_DIV_MANTISSA) >> 4; }
inline uint32_t usart_brr_get_div_fraction(struct USART_Type *p) { return (p->BRR & USART_BRR_DIV_FRACTION) >> 0; }

// USART->GTPR Guard time and prescaler register
enum {
	USART_GTPR_GT  = ((1UL << 8) - 1) << 8,	 // Guard time value
	USART_GTPR_PSC = ((1UL << 8) - 1) << 0,	 // Prescaler value
};
inline void usart_gtpr_set_gt(struct USART_Type *p, uint32_t val) {
	p->GTPR = (p->GTPR & ~USART_GTPR_GT) | ((val << 8) & USART_GTPR_GT);
}
inline void usart_gtpr_set_psc(struct USART_Type *p, uint32_t val) {
	p->GTPR = (p->GTPR & ~USART_GTPR_PSC) | ((val << 0) & USART_GTPR_PSC);
}
inline uint32_t usart_gtpr_get_gt(struct USART_Type *p) { return (p->GTPR & USART_GTPR_GT) >> 8; }
inline uint32_t usart_gtpr_get_psc(struct USART_Type *p) { return (p->GTPR & USART_GTPR_PSC) >> 0; }

// USART->RTOR Receiver timeout register
enum {
	USART_RTOR_BLEN = ((1UL << 8) - 1) << 24,  // Block Length
	USART_RTOR_RTO	= ((1UL << 24) - 1) << 0,  // Receiver timeout value
};
inline void usart_rtor_set_blen(struct USART_Type *p, uint32_t val) {
	p->RTOR = (p->RTOR & ~USART_RTOR_BLEN) | ((val << 24) & USART_RTOR_BLEN);
}
inline void usart_rtor_set_rto(struct USART_Type *p, uint32_t val) {
	p->RTOR = (p->RTOR & ~USART_RTOR_RTO) | ((val << 0) & USART_RTOR_RTO);
}
inline uint32_t usart_rtor_get_blen(struct USART_Type *p) { return (p->RTOR & USART_RTOR_BLEN) >> 24; }
inline uint32_t usart_rtor_get_rto(struct USART_Type *p) { return (p->RTOR & USART_RTOR_RTO) >> 0; }

// USART->RQR Request register
enum {
	USART_RQR_TXFRQ = 1UL << 4,	 // Transmit data flush request
	USART_RQR_RXFRQ = 1UL << 3,	 // Receive data flush request
	USART_RQR_MMRQ	= 1UL << 2,	 // Mute mode request
	USART_RQR_SBKRQ = 1UL << 1,	 // Send break request
	USART_RQR_ABRRQ = 1UL << 0,	 // Auto baud rate request
};

// USART->ISR Interrupt & status register
enum {
	USART_ISR_TXFT	= 1UL << 27,  // TXFT
	USART_ISR_RXFT	= 1UL << 26,  // RXFT
	USART_ISR_TCBGT = 1UL << 25,  // TCBGT
	USART_ISR_RXFF	= 1UL << 24,  // RXFF
	USART_ISR_TXFE	= 1UL << 23,  // TXFE
	USART_ISR_REACK = 1UL << 22,  // REACK
	USART_ISR_TEACK = 1UL << 21,  // TEACK
	USART_ISR_WUF	= 1UL << 20,  // WUF
	USART_ISR_RWU	= 1UL << 19,  // RWU
	USART_ISR_SBKF	= 1UL << 18,  // SBKF
	USART_ISR_CMF	= 1UL << 17,  // CMF
	USART_ISR_BUSY	= 1UL << 16,  // BUSY
	USART_ISR_ABRF	= 1UL << 15,  // ABRF
	USART_ISR_ABRE	= 1UL << 14,  // ABRE
	USART_ISR_UDR	= 1UL << 13,  // UDR
	USART_ISR_EOBF	= 1UL << 12,  // EOBF
	USART_ISR_RTOF	= 1UL << 11,  // RTOF
	USART_ISR_CTS	= 1UL << 10,  // CTS
	USART_ISR_CTSIF = 1UL << 9,	  // CTSIF
	USART_ISR_LBDF	= 1UL << 8,	  // LBDF
	USART_ISR_TXE	= 1UL << 7,	  // TXE
	USART_ISR_TC	= 1UL << 6,	  // TC
	USART_ISR_RXNE	= 1UL << 5,	  // RXNE
	USART_ISR_IDLE	= 1UL << 4,	  // IDLE
	USART_ISR_ORE	= 1UL << 3,	  // ORE
	USART_ISR_NF	= 1UL << 2,	  // NF
	USART_ISR_FE	= 1UL << 1,	  // FE
	USART_ISR_PE	= 1UL << 0,	  // PE
};

// USART->ICR Interrupt flag clear register
enum {
	USART_ICR_WUCF	  = 1UL << 20,	// Wakeup from Stop mode clear flag
	USART_ICR_CMCF	  = 1UL << 17,	// Character match clear flag
	USART_ICR_UDRCF	  = 1UL << 13,	// UDRCF
	USART_ICR_EOBCF	  = 1UL << 12,	// End of block clear flag
	USART_ICR_RTOCF	  = 1UL << 11,	// Receiver timeout clear flag
	USART_ICR_CTSCF	  = 1UL << 9,	// CTS clear flag
	USART_ICR_LBDCF	  = 1UL << 8,	// LIN break detection clear flag
	USART_ICR_TCBGTCF = 1UL << 7,	// TCBGTCF
	USART_ICR_TCCF	  = 1UL << 6,	// Transmission complete clear flag
	USART_ICR_TXFECF  = 1UL << 5,	// TXFECF
	USART_ICR_IDLECF  = 1UL << 4,	// Idle line detected clear flag
	USART_ICR_ORECF	  = 1UL << 3,	// Overrun error clear flag
	USART_ICR_NCF	  = 1UL << 2,	// Noise detected clear flag
	USART_ICR_FECF	  = 1UL << 1,	// Framing error clear flag
	USART_ICR_PECF	  = 1UL << 0,	// Parity error clear flag
};

// USART->RDR Receive data register
enum {
	USART_RDR_RDR = ((1UL << 9) - 1) << 0,	// Receive data value
};
inline uint32_t usart_rdr_get_rdr(struct USART_Type *p) { return (p->RDR & USART_RDR_RDR) >> 0; }

// USART->TDR Transmit data register
enum {
	USART_TDR_TDR = ((1UL << 9) - 1) << 0,	// Transmit data value
};
inline void usart_tdr_set_tdr(struct USART_Type *p, uint32_t val) {
	p->TDR = (p->TDR & ~USART_TDR_TDR) | ((val << 0) & USART_TDR_TDR);
}
inline uint32_t usart_tdr_get_tdr(struct USART_Type *p) { return (p->TDR & USART_TDR_TDR) >> 0; }

// USART->PRESC USART prescaler register
enum {
	USART_PRESC_PRESCALER = ((1UL << 4) - 1) << 0,	// PRESCALER
};
inline void usart_presc_set_prescaler(struct USART_Type *p, uint32_t val) {
	p->PRESC = (p->PRESC & ~USART_PRESC_PRESCALER) | ((val << 0) & USART_PRESC_PRESCALER);
}
inline uint32_t usart_presc_get_prescaler(struct USART_Type *p) { return (p->PRESC & USART_PRESC_PRESCALER) >> 0; }

/* UCPD1 */
struct UCPD1_Type {
	__IO uint32_t CFG1;			 // @0 UCPD configuration register 1
	__IO uint8_t  CFG2;			 // @4 UCPD configuration register 2
	uint8_t		  RESERVED0[7];	 // @5
	__IO uint32_t CR;			 // @12 UCPD configuration register 2
	__IO uint32_t IMR;			 // @16 UCPD Interrupt Mask Register
	__IO uint32_t SR;			 // @20 UCPD Status Register
	__IO uint32_t ICR;			 // @24 UCPD Interrupt Clear Register
	__IO uint32_t TX_ORDSET;	 // @28 UCPD Tx Ordered Set Type Register
	__IO uint16_t TX_PAYSZ;		 // @32 UCPD Tx Paysize Register
	uint8_t		  RESERVED1[2];	 // @34
	__IO uint8_t  TXDR;			 // @36 UCPD Tx Data Register
	uint8_t		  RESERVED2[3];	 // @37
	__I uint8_t	  RX_ORDSET;	 // @40 UCPD Rx Ordered Set Register
	uint8_t		  RESERVED3[3];	 // @41
	__I uint16_t  RX_PAYSZ;		 // @44 UCPD Rx Paysize Register
	uint8_t		  RESERVED4[2];	 // @46
	__I uint8_t	  RXDR;			 // @48 UCPD Rx Data Register
	uint8_t		  RESERVED5[3];	 // @49
	__IO uint32_t RX_ORDEXT1;	 // @52 UCPD Rx Ordered Set Extension Register 1
	__IO uint32_t RX_ORDEXT2;	 // @56 UCPD Rx Ordered Set Extension Register 2
};

// UCPD1->CFG1 UCPD configuration register 1
enum {
	UCPD1_CFG1_UCPDEN		= 1UL << 31,			   // UCPDEN
	UCPD1_CFG1_RXDMAEN		= 1UL << 30,			   // RXDMAEN
	UCPD1_CFG1_TXDMAEN		= 1UL << 29,			   // TXDMAEN
	UCPD1_CFG1_RXORDSETEN	= ((1UL << 9) - 1) << 20,  // RXORDSETEN
	UCPD1_CFG1_PSC_USBPDCLK = ((1UL << 3) - 1) << 17,  // PSC_USBPDCLK
	UCPD1_CFG1_TRANSWIN		= ((1UL << 5) - 1) << 11,  // TRANSWIN
	UCPD1_CFG1_IFRGAP		= ((1UL << 5) - 1) << 6,   // IFRGAP
	UCPD1_CFG1_HBITCLKDIV	= ((1UL << 6) - 1) << 0,   // HBITCLKDIV
};
inline void ucpd1_cfg1_set_rxordseten(struct UCPD1_Type *p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_RXORDSETEN) | ((val << 20) & UCPD1_CFG1_RXORDSETEN);
}
inline void ucpd1_cfg1_set_psc_usbpdclk(struct UCPD1_Type *p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_PSC_USBPDCLK) | ((val << 17) & UCPD1_CFG1_PSC_USBPDCLK);
}
inline void ucpd1_cfg1_set_transwin(struct UCPD1_Type *p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_TRANSWIN) | ((val << 11) & UCPD1_CFG1_TRANSWIN);
}
inline void ucpd1_cfg1_set_ifrgap(struct UCPD1_Type *p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_IFRGAP) | ((val << 6) & UCPD1_CFG1_IFRGAP);
}
inline void ucpd1_cfg1_set_hbitclkdiv(struct UCPD1_Type *p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_HBITCLKDIV) | ((val << 0) & UCPD1_CFG1_HBITCLKDIV);
}
inline uint32_t ucpd1_cfg1_get_rxordseten(struct UCPD1_Type *p) { return (p->CFG1 & UCPD1_CFG1_RXORDSETEN) >> 20; }
inline uint32_t ucpd1_cfg1_get_psc_usbpdclk(struct UCPD1_Type *p) { return (p->CFG1 & UCPD1_CFG1_PSC_USBPDCLK) >> 17; }
inline uint32_t ucpd1_cfg1_get_transwin(struct UCPD1_Type *p) { return (p->CFG1 & UCPD1_CFG1_TRANSWIN) >> 11; }
inline uint32_t ucpd1_cfg1_get_ifrgap(struct UCPD1_Type *p) { return (p->CFG1 & UCPD1_CFG1_IFRGAP) >> 6; }
inline uint32_t ucpd1_cfg1_get_hbitclkdiv(struct UCPD1_Type *p) { return (p->CFG1 & UCPD1_CFG1_HBITCLKDIV) >> 0; }

// UCPD1->CFG2 UCPD configuration register 2
enum {
	UCPD1_CFG2_WUPEN	 = 1UL << 3,  // WUPEN
	UCPD1_CFG2_FORCECLK	 = 1UL << 2,  // FORCECLK
	UCPD1_CFG2_RXFILT2N3 = 1UL << 1,  // RXFILT2N3
	UCPD1_CFG2_RXFILTDIS = 1UL << 0,  // RXFILTDIS
};

// UCPD1->CR UCPD configuration register 2
enum {
	UCPD1_CR_CC2TCDIS	= 1UL << 21,			   // CC2TCDIS
	UCPD1_CR_CC1TCDIS	= 1UL << 20,			   // CC1TCDIS
	UCPD1_CR_RDCH		= 1UL << 18,			   // RDCH
	UCPD1_CR_FRSTX		= 1UL << 17,			   // FRSTX
	UCPD1_CR_FRSRXEN	= 1UL << 16,			   // FRSRXEN
	UCPD1_CR_CCENABLE	= ((1UL << 2) - 1) << 10,  // CCENABLE
	UCPD1_CR_ANAMODE	= 1UL << 9,				   // ANAMODE
	UCPD1_CR_ANASUBMODE = ((1UL << 2) - 1) << 7,   // ANASUBMODE
	UCPD1_CR_PHYCCSEL	= 1UL << 6,				   // PHYCCSEL
	UCPD1_CR_PHYRXEN	= 1UL << 5,				   // PHYRXEN
	UCPD1_CR_RXMODE		= 1UL << 4,				   // RXMODE
	UCPD1_CR_TXHRST		= 1UL << 3,				   // TXHRST
	UCPD1_CR_TXSEND		= 1UL << 2,				   // TXSEND
	UCPD1_CR_TXMODE		= ((1UL << 2) - 1) << 0,   // TXMODE
};
inline void ucpd1_cr_set_ccenable(struct UCPD1_Type *p, uint32_t val) {
	p->CR = (p->CR & ~UCPD1_CR_CCENABLE) | ((val << 10) & UCPD1_CR_CCENABLE);
}
inline void ucpd1_cr_set_anasubmode(struct UCPD1_Type *p, uint32_t val) {
	p->CR = (p->CR & ~UCPD1_CR_ANASUBMODE) | ((val << 7) & UCPD1_CR_ANASUBMODE);
}
inline void ucpd1_cr_set_txmode(struct UCPD1_Type *p, uint32_t val) {
	p->CR = (p->CR & ~UCPD1_CR_TXMODE) | ((val << 0) & UCPD1_CR_TXMODE);
}
inline uint32_t ucpd1_cr_get_ccenable(struct UCPD1_Type *p) { return (p->CR & UCPD1_CR_CCENABLE) >> 10; }
inline uint32_t ucpd1_cr_get_anasubmode(struct UCPD1_Type *p) { return (p->CR & UCPD1_CR_ANASUBMODE) >> 7; }
inline uint32_t ucpd1_cr_get_txmode(struct UCPD1_Type *p) { return (p->CR & UCPD1_CR_TXMODE) >> 0; }

// UCPD1->IMR UCPD Interrupt Mask Register
enum {
	UCPD1_IMR_FRSEVTIE	  = 1UL << 20,	// FRSEVTIE
	UCPD1_IMR_TYPECEVT2IE = 1UL << 15,	// TYPECEVT2IE
	UCPD1_IMR_TYPECEVT1IE = 1UL << 14,	// TYPECEVT1IE
	UCPD1_IMR_RXMSGENDIE  = 1UL << 12,	// RXMSGENDIE
	UCPD1_IMR_RXOVRIE	  = 1UL << 11,	// RXOVRIE
	UCPD1_IMR_RXHRSTDETIE = 1UL << 10,	// RXHRSTDETIE
	UCPD1_IMR_RXORDDETIE  = 1UL << 9,	// RXORDDETIE
	UCPD1_IMR_RXNEIE	  = 1UL << 8,	// RXNEIE
	UCPD1_IMR_TXUNDIE	  = 1UL << 6,	// TXUNDIE
	UCPD1_IMR_HRSTSENTIE  = 1UL << 5,	// HRSTSENTIE
	UCPD1_IMR_HRSTDISCIE  = 1UL << 4,	// HRSTDISCIE
	UCPD1_IMR_TXMSGABTIE  = 1UL << 3,	// TXMSGABTIE
	UCPD1_IMR_TXMSGSENTIE = 1UL << 2,	// TXMSGSENTIE
	UCPD1_IMR_TXMSGDISCIE = 1UL << 1,	// TXMSGDISCIE
	UCPD1_IMR_TXISIE	  = 1UL << 0,	// TXISIE
};

// UCPD1->SR UCPD Status Register
enum {
	UCPD1_SR_FRSEVT			  = 1UL << 20,				 // FRSEVT
	UCPD1_SR_TYPEC_VSTATE_CC2 = ((1UL << 2) - 1) << 18,	 // TYPEC_VSTATE_CC2
	UCPD1_SR_TYPEC_VSTATE_CC1 = ((1UL << 2) - 1) << 16,	 // TYPEC_VSTATE_CC1
	UCPD1_SR_TYPECEVT2		  = 1UL << 15,				 // TYPECEVT2
	UCPD1_SR_TYPECEVT1		  = 1UL << 14,				 // TYPECEVT1
	UCPD1_SR_RXERR			  = 1UL << 13,				 // RXERR
	UCPD1_SR_RXMSGEND		  = 1UL << 12,				 // RXMSGEND
	UCPD1_SR_RXOVR			  = 1UL << 11,				 // RXOVR
	UCPD1_SR_RXHRSTDET		  = 1UL << 10,				 // RXHRSTDET
	UCPD1_SR_RXORDDET		  = 1UL << 9,				 // RXORDDET
	UCPD1_SR_RXNE			  = 1UL << 8,				 // RXNE
	UCPD1_SR_TXUND			  = 1UL << 6,				 // TXUND
	UCPD1_SR_HRSTSENT		  = 1UL << 5,				 // HRSTSENT
	UCPD1_SR_HRSTDISC		  = 1UL << 4,				 // HRSTDISC
	UCPD1_SR_TXMSGABT		  = 1UL << 3,				 // TXMSGABT
	UCPD1_SR_TXMSGSENT		  = 1UL << 2,				 // TXMSGSENT
	UCPD1_SR_TXMSGDISC		  = 1UL << 1,				 // TXMSGDISC
	UCPD1_SR_TXIS			  = 1UL << 0,				 // TXIS
};
inline void ucpd1_sr_set_typec_vstate_cc2(struct UCPD1_Type *p, uint32_t val) {
	p->SR = (p->SR & ~UCPD1_SR_TYPEC_VSTATE_CC2) | ((val << 18) & UCPD1_SR_TYPEC_VSTATE_CC2);
}
inline void ucpd1_sr_set_typec_vstate_cc1(struct UCPD1_Type *p, uint32_t val) {
	p->SR = (p->SR & ~UCPD1_SR_TYPEC_VSTATE_CC1) | ((val << 16) & UCPD1_SR_TYPEC_VSTATE_CC1);
}
inline uint32_t ucpd1_sr_get_typec_vstate_cc2(struct UCPD1_Type *p) { return (p->SR & UCPD1_SR_TYPEC_VSTATE_CC2) >> 18; }
inline uint32_t ucpd1_sr_get_typec_vstate_cc1(struct UCPD1_Type *p) { return (p->SR & UCPD1_SR_TYPEC_VSTATE_CC1) >> 16; }

// UCPD1->ICR UCPD Interrupt Clear Register
enum {
	UCPD1_ICR_FRSEVTCF	  = 1UL << 20,	// FRSEVTCF
	UCPD1_ICR_TYPECEVT2CF = 1UL << 15,	// TYPECEVT2CF
	UCPD1_ICR_TYPECEVT1CF = 1UL << 14,	// TYPECEVT1CF
	UCPD1_ICR_RXMSGENDCF  = 1UL << 12,	// RXMSGENDCF
	UCPD1_ICR_RXOVRCF	  = 1UL << 11,	// RXOVRCF
	UCPD1_ICR_RXHRSTDETCF = 1UL << 10,	// RXHRSTDETCF
	UCPD1_ICR_RXORDDETCF  = 1UL << 9,	// RXORDDETCF
	UCPD1_ICR_TXUNDCF	  = 1UL << 6,	// TXUNDCF
	UCPD1_ICR_HRSTSENTCF  = 1UL << 5,	// HRSTSENTCF
	UCPD1_ICR_HRSTDISCCF  = 1UL << 4,	// HRSTDISCCF
	UCPD1_ICR_TXMSGABTCF  = 1UL << 3,	// TXMSGABTCF
	UCPD1_ICR_TXMSGSENTCF = 1UL << 2,	// TXMSGSENTCF
	UCPD1_ICR_TXMSGDISCCF = 1UL << 1,	// TXMSGDISCCF
};

// UCPD1->TX_ORDSET UCPD Tx Ordered Set Type Register
enum {
	UCPD1_TX_ORDSET_TXORDSET = ((1UL << 20) - 1) << 0,	// TXORDSET
};
inline void ucpd1_tx_ordset_set_txordset(struct UCPD1_Type *p, uint32_t val) {
	p->TX_ORDSET = (p->TX_ORDSET & ~UCPD1_TX_ORDSET_TXORDSET) | ((val << 0) & UCPD1_TX_ORDSET_TXORDSET);
}
inline uint32_t ucpd1_tx_ordset_get_txordset(struct UCPD1_Type *p) { return (p->TX_ORDSET & UCPD1_TX_ORDSET_TXORDSET) >> 0; }

// UCPD1->TX_PAYSZ UCPD Tx Paysize Register
enum {
	UCPD1_TX_PAYSZ_TXPAYSZ = ((1UL << 10) - 1) << 0,  // TXPAYSZ
};
inline void ucpd1_tx_paysz_set_txpaysz(struct UCPD1_Type *p, uint32_t val) {
	p->TX_PAYSZ = (p->TX_PAYSZ & ~UCPD1_TX_PAYSZ_TXPAYSZ) | ((val << 0) & UCPD1_TX_PAYSZ_TXPAYSZ);
}
inline uint32_t ucpd1_tx_paysz_get_txpaysz(struct UCPD1_Type *p) { return (p->TX_PAYSZ & UCPD1_TX_PAYSZ_TXPAYSZ) >> 0; }

// UCPD1->RX_ORDSET UCPD Rx Ordered Set Register
enum {
	UCPD1_RX_ORDSET_RXSOPKINVALID = ((1UL << 3) - 1) << 4,	// RXSOPKINVALID
	UCPD1_RX_ORDSET_RXSOP3OF4	  = 1UL << 3,				// RXSOP3OF4
	UCPD1_RX_ORDSET_RXORDSET	  = ((1UL << 3) - 1) << 0,	// RXORDSET
};
inline uint32_t ucpd1_rx_ordset_get_rxsopkinvalid(struct UCPD1_Type *p) {
	return (p->RX_ORDSET & UCPD1_RX_ORDSET_RXSOPKINVALID) >> 4;
}
inline uint32_t ucpd1_rx_ordset_get_rxordset(struct UCPD1_Type *p) { return (p->RX_ORDSET & UCPD1_RX_ORDSET_RXORDSET) >> 0; }

// UCPD1->RX_PAYSZ UCPD Rx Paysize Register
enum {
	UCPD1_RX_PAYSZ_RXPAYSZ = ((1UL << 10) - 1) << 0,  // RXPAYSZ
};
inline uint32_t ucpd1_rx_paysz_get_rxpaysz(struct UCPD1_Type *p) { return (p->RX_PAYSZ & UCPD1_RX_PAYSZ_RXPAYSZ) >> 0; }

// UCPD1->RX_ORDEXT1 UCPD Rx Ordered Set Extension Register 1
enum {
	UCPD1_RX_ORDEXT1_RXSOPX1 = ((1UL << 20) - 1) << 0,	// RXSOPX1
};
inline void ucpd1_rx_ordext1_set_rxsopx1(struct UCPD1_Type *p, uint32_t val) {
	p->RX_ORDEXT1 = (p->RX_ORDEXT1 & ~UCPD1_RX_ORDEXT1_RXSOPX1) | ((val << 0) & UCPD1_RX_ORDEXT1_RXSOPX1);
}
inline uint32_t ucpd1_rx_ordext1_get_rxsopx1(struct UCPD1_Type *p) { return (p->RX_ORDEXT1 & UCPD1_RX_ORDEXT1_RXSOPX1) >> 0; }

// UCPD1->RX_ORDEXT2 UCPD Rx Ordered Set Extension Register 2
enum {
	UCPD1_RX_ORDEXT2_RXSOPX2 = ((1UL << 20) - 1) << 0,	// RXSOPX2
};
inline void ucpd1_rx_ordext2_set_rxsopx2(struct UCPD1_Type *p, uint32_t val) {
	p->RX_ORDEXT2 = (p->RX_ORDEXT2 & ~UCPD1_RX_ORDEXT2_RXSOPX2) | ((val << 0) & UCPD1_RX_ORDEXT2_RXSOPX2);
}
inline uint32_t ucpd1_rx_ordext2_get_rxsopx2(struct UCPD1_Type *p) { return (p->RX_ORDEXT2 & UCPD1_RX_ORDEXT2_RXSOPX2) >> 0; }

#if 0  // we're using stm32f103usb.h instead

/* USB_FS_device */
struct USB_FS_device_Type {
	__IO uint16_t EP0R; // @0 USB endpoint n register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t EP1R; // @4 USB endpoint n register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t EP2R; // @8 USB endpoint n register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t EP3R; // @12 USB endpoint n register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t EP4R; // @16 USB endpoint n register
	 uint8_t RESERVED4[2]; // @18 
	__IO uint16_t EP5R; // @20 USB endpoint n register
	 uint8_t RESERVED5[2]; // @22 
	__IO uint16_t EP6R; // @24 USB endpoint n register
	 uint8_t RESERVED6[2]; // @26 
	__IO uint16_t EP7R; // @28 USB endpoint n register
	 uint8_t RESERVED7[34]; // @30 
	__IO uint16_t CNTR; // @64 USB control register
	 uint8_t RESERVED8[2]; // @66 
	__IO uint16_t ISTR; // @68 USB interrupt status register
	 uint8_t RESERVED9[2]; // @70 
	__I uint16_t FNR; // @72 USB frame number register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint8_t DADDR; // @76 USB device address
	 uint8_t RESERVED11[3]; // @77 
	__IO uint16_t BTABLE; // @80 Buffer table address
};

// USB_FS_device->EP0R USB endpoint n register
enum {
	USB_FS_DEVICE_EP0R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP0R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP0R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP0R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP0R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP0R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP0R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP0R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP0R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP0R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep0r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP0R_STAT_RX); }
inline void usb_fs_device_ep0r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP0R_EP_TYPE); }
inline void usb_fs_device_ep0r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP0R_STAT_TX); }
inline void usb_fs_device_ep0r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_EA) | ((val<<0) & USB_FS_DEVICE_EP0R_EA); }
inline uint32_t usb_fs_device_ep0r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep0r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep0r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep0r_get_ea(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_EA) >> 0 ; }

// USB_FS_device->EP1R USB endpoint n register
enum {
	USB_FS_DEVICE_EP1R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP1R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP1R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP1R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP1R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP1R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP1R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP1R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP1R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP1R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep1r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP1R_STAT_RX); }
inline void usb_fs_device_ep1r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP1R_EP_TYPE); }
inline void usb_fs_device_ep1r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP1R_STAT_TX); }
inline void usb_fs_device_ep1r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_EA) | ((val<<0) & USB_FS_DEVICE_EP1R_EA); }
inline uint32_t usb_fs_device_ep1r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep1r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep1r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep1r_get_ea(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_EA) >> 0 ; }

// USB_FS_device->EP2R USB endpoint n register
enum {
	USB_FS_DEVICE_EP2R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP2R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP2R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP2R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP2R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP2R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP2R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP2R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP2R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP2R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep2r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP2R_STAT_RX); }
inline void usb_fs_device_ep2r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP2R_EP_TYPE); }
inline void usb_fs_device_ep2r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP2R_STAT_TX); }
inline void usb_fs_device_ep2r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_EA) | ((val<<0) & USB_FS_DEVICE_EP2R_EA); }
inline uint32_t usb_fs_device_ep2r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep2r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep2r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep2r_get_ea(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_EA) >> 0 ; }

// USB_FS_device->EP3R USB endpoint n register
enum {
	USB_FS_DEVICE_EP3R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP3R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP3R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP3R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP3R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP3R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP3R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP3R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP3R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP3R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep3r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP3R_STAT_RX); }
inline void usb_fs_device_ep3r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP3R_EP_TYPE); }
inline void usb_fs_device_ep3r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP3R_STAT_TX); }
inline void usb_fs_device_ep3r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_EA) | ((val<<0) & USB_FS_DEVICE_EP3R_EA); }
inline uint32_t usb_fs_device_ep3r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep3r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep3r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep3r_get_ea(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_EA) >> 0 ; }

// USB_FS_device->EP4R USB endpoint n register
enum {
	USB_FS_DEVICE_EP4R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP4R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP4R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP4R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP4R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP4R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP4R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP4R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP4R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP4R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep4r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP4R_STAT_RX); }
inline void usb_fs_device_ep4r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP4R_EP_TYPE); }
inline void usb_fs_device_ep4r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP4R_STAT_TX); }
inline void usb_fs_device_ep4r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_EA) | ((val<<0) & USB_FS_DEVICE_EP4R_EA); }
inline uint32_t usb_fs_device_ep4r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep4r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep4r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep4r_get_ea(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_EA) >> 0 ; }

// USB_FS_device->EP5R USB endpoint n register
enum {
	USB_FS_DEVICE_EP5R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP5R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP5R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP5R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP5R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP5R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP5R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP5R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP5R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP5R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep5r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP5R_STAT_RX); }
inline void usb_fs_device_ep5r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP5R_EP_TYPE); }
inline void usb_fs_device_ep5r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP5R_STAT_TX); }
inline void usb_fs_device_ep5r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_EA) | ((val<<0) & USB_FS_DEVICE_EP5R_EA); }
inline uint32_t usb_fs_device_ep5r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep5r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep5r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep5r_get_ea(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_EA) >> 0 ; }

// USB_FS_device->EP6R USB endpoint n register
enum {
	USB_FS_DEVICE_EP6R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP6R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP6R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP6R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP6R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP6R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP6R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP6R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP6R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP6R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep6r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP6R_STAT_RX); }
inline void usb_fs_device_ep6r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP6R_EP_TYPE); }
inline void usb_fs_device_ep6r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP6R_STAT_TX); }
inline void usb_fs_device_ep6r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_EA) | ((val<<0) & USB_FS_DEVICE_EP6R_EA); }
inline uint32_t usb_fs_device_ep6r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep6r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep6r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep6r_get_ea(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_EA) >> 0 ; }

// USB_FS_device->EP7R USB endpoint n register
enum {
	USB_FS_DEVICE_EP7R_CTR_RX = 1UL<<15, // CTR_RX
	USB_FS_DEVICE_EP7R_DTOG_RX = 1UL<<14, // DTOG_RX
	USB_FS_DEVICE_EP7R_STAT_RX = ((1UL<<2)-1) << 12, // STAT_RX
	USB_FS_DEVICE_EP7R_SETUP = 1UL<<11, // SETUP
	USB_FS_DEVICE_EP7R_EP_TYPE = ((1UL<<2)-1) << 9, // EP_TYPE
	USB_FS_DEVICE_EP7R_EP_KIND = 1UL<<8, // EP_KIND
	USB_FS_DEVICE_EP7R_CTR_TX = 1UL<<7, // CTR_TX
	USB_FS_DEVICE_EP7R_DTOG_TX = 1UL<<6, // DTOG_TX
	USB_FS_DEVICE_EP7R_STAT_TX = ((1UL<<2)-1) << 4, // STAT_TX
	USB_FS_DEVICE_EP7R_EA = ((1UL<<4)-1) << 0, // EA		
};
inline void usb_fs_device_ep7r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_STAT_RX) | ((val<<12) & USB_FS_DEVICE_EP7R_STAT_RX); }
inline void usb_fs_device_ep7r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_EP_TYPE) | ((val<<9) & USB_FS_DEVICE_EP7R_EP_TYPE); }
inline void usb_fs_device_ep7r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_STAT_TX) | ((val<<4) & USB_FS_DEVICE_EP7R_STAT_TX); }
inline void usb_fs_device_ep7r_set_ea(struct USB_FS_device_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_EA) | ((val<<0) & USB_FS_DEVICE_EP7R_EA); }
inline uint32_t usb_fs_device_ep7r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_STAT_RX) >> 12 ; }
inline uint32_t usb_fs_device_ep7r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_EP_TYPE) >> 9 ; }
inline uint32_t usb_fs_device_ep7r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_STAT_TX) >> 4 ; }
inline uint32_t usb_fs_device_ep7r_get_ea(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_EA) >> 0 ; }

// USB_FS_device->CNTR USB control register
enum {
	USB_FS_DEVICE_CNTR_CTRM = 1UL<<15, // CTRM
	USB_FS_DEVICE_CNTR_PMAOVRM = 1UL<<14, // PMAOVRM
	USB_FS_DEVICE_CNTR_ERRM = 1UL<<13, // ERRM
	USB_FS_DEVICE_CNTR_WKUPM = 1UL<<12, // WKUPM
	USB_FS_DEVICE_CNTR_SUSPM = 1UL<<11, // SUSPM
	USB_FS_DEVICE_CNTR_RESETM = 1UL<<10, // RESETM
	USB_FS_DEVICE_CNTR_SOFM = 1UL<<9, // SOFM
	USB_FS_DEVICE_CNTR_ESOFM = 1UL<<8, // ESOFM
	USB_FS_DEVICE_CNTR_L1REQM = 1UL<<7, // L1REQM
	USB_FS_DEVICE_CNTR_L1RESUME = 1UL<<5, // L1RESUME
	USB_FS_DEVICE_CNTR_RESUME = 1UL<<4, // RESUME
	USB_FS_DEVICE_CNTR_FSUSP = 1UL<<3, // FSUSP
	USB_FS_DEVICE_CNTR_LP_MODE = 1UL<<2, // LP_MODE
	USB_FS_DEVICE_CNTR_PDWN = 1UL<<1, // PDWN
	USB_FS_DEVICE_CNTR_FRES = 1UL<<0, // FRES		
};

// USB_FS_device->ISTR USB interrupt status register
enum {
	USB_FS_DEVICE_ISTR_CTR = 1UL<<15, // CTR
	USB_FS_DEVICE_ISTR_PMAOVR = 1UL<<14, // PMAOVR
	USB_FS_DEVICE_ISTR_ERR = 1UL<<13, // ERR
	USB_FS_DEVICE_ISTR_WKUP = 1UL<<12, // WKUP
	USB_FS_DEVICE_ISTR_SUSP = 1UL<<11, // SUSP
	USB_FS_DEVICE_ISTR_RESET = 1UL<<10, // RESET
	USB_FS_DEVICE_ISTR_SOF = 1UL<<9, // SOF
	USB_FS_DEVICE_ISTR_ESOF = 1UL<<8, // ESOF
	USB_FS_DEVICE_ISTR_L1REQ = 1UL<<7, // L1REQ
	USB_FS_DEVICE_ISTR_DIR = 1UL<<4, // DIR
	USB_FS_DEVICE_ISTR_EP_ID = ((1UL<<4)-1) << 0, // EP_ID		
};
inline void usb_fs_device_istr_set_ep_id(struct USB_FS_device_Type* p, uint32_t val) { p->ISTR = (p->ISTR & ~USB_FS_DEVICE_ISTR_EP_ID) | ((val<<0) & USB_FS_DEVICE_ISTR_EP_ID); }
inline uint32_t usb_fs_device_istr_get_ep_id(struct USB_FS_device_Type* p) { return (p->ISTR & USB_FS_DEVICE_ISTR_EP_ID) >> 0 ; }

// USB_FS_device->FNR USB frame number register
enum {
	USB_FS_DEVICE_FNR_RXDP = 1UL<<15, // RXDP
	USB_FS_DEVICE_FNR_RXDM = 1UL<<14, // RXDM
	USB_FS_DEVICE_FNR_LCK = 1UL<<13, // LCK
	USB_FS_DEVICE_FNR_LSOF = ((1UL<<2)-1) << 11, // LSOF
	USB_FS_DEVICE_FNR_FN = ((1UL<<11)-1) << 0, // FN		
};
inline uint32_t usb_fs_device_fnr_get_lsof(struct USB_FS_device_Type* p) { return (p->FNR & USB_FS_DEVICE_FNR_LSOF) >> 11 ; }
inline uint32_t usb_fs_device_fnr_get_fn(struct USB_FS_device_Type* p) { return (p->FNR & USB_FS_DEVICE_FNR_FN) >> 0 ; }

// USB_FS_device->DADDR USB device address
enum {
	USB_FS_DEVICE_DADDR_EF = 1UL<<7, // EF
	USB_FS_DEVICE_DADDR_ADD = ((1UL<<7)-1) << 0, // ADD		
};
inline void usb_fs_device_daddr_set_add(struct USB_FS_device_Type* p, uint32_t val) { p->DADDR = (p->DADDR & ~USB_FS_DEVICE_DADDR_ADD) | ((val<<0) & USB_FS_DEVICE_DADDR_ADD); }
inline uint32_t usb_fs_device_daddr_get_add(struct USB_FS_device_Type* p) { return (p->DADDR & USB_FS_DEVICE_DADDR_ADD) >> 0 ; }

// USB_FS_device->BTABLE Buffer table address
enum {
	USB_FS_DEVICE_BTABLE_BTABLE = ((1UL<<13)-1) << 3, // BTABLE		
};
inline void usb_fs_device_btable_set_btable(struct USB_FS_device_Type* p, uint32_t val) { p->BTABLE = (p->BTABLE & ~USB_FS_DEVICE_BTABLE_BTABLE) | ((val<<3) & USB_FS_DEVICE_BTABLE_BTABLE); }
inline uint32_t usb_fs_device_btable_get_btable(struct USB_FS_device_Type* p) { return (p->BTABLE & USB_FS_DEVICE_BTABLE_BTABLE) >> 3 ; }

#endif	// skip the USB part

/* Voltage reference buffer */
struct VREFBUF_Type {
	__IO uint8_t CSR;			// @0 VREF_BUF Control and Status Register
	uint8_t		 RESERVED0[3];	// @1
	__IO uint8_t CCR;			// @4 VREF_BUF Calibration Control Register
};

// VREFBUF->CSR VREF_BUF Control and Status Register
enum {
	VREFBUF_CSR_VRS	 = ((1UL << 2) - 1) << 4,  // Voltage reference scale
	VREFBUF_CSR_VRR	 = 1UL << 3,			   // Voltage reference buffer ready
	VREFBUF_CSR_HIZ	 = 1UL << 1,			   // High impedence mode for the VREF_BUF
	VREFBUF_CSR_ENVR = 1UL << 0,			   // Enable Voltage Reference
};
inline void vrefbuf_csr_set_vrs(struct VREFBUF_Type *p, uint32_t val) {
	p->CSR = (p->CSR & ~VREFBUF_CSR_VRS) | ((val << 4) & VREFBUF_CSR_VRS);
}
inline uint32_t vrefbuf_csr_get_vrs(struct VREFBUF_Type *p) { return (p->CSR & VREFBUF_CSR_VRS) >> 4; }

// VREFBUF->CCR VREF_BUF Calibration Control Register
enum {
	VREFBUF_CCR_TRIM = ((1UL << 6) - 1) << 0,  // Trimming code
};
inline void vrefbuf_ccr_set_trim(struct VREFBUF_Type *p, uint32_t val) {
	p->CCR = (p->CCR & ~VREFBUF_CCR_TRIM) | ((val << 0) & VREFBUF_CCR_TRIM);
}
inline uint32_t vrefbuf_ccr_get_trim(struct VREFBUF_Type *p) { return (p->CCR & VREFBUF_CCR_TRIM) >> 0; }

/* System window watchdog */
struct WWDG_Type {
	__IO uint8_t  CR;			 // @0 Control register
	uint8_t		  RESERVED0[3];	 // @1
	__IO uint16_t CFR;			 // @4 Configuration register
	uint8_t		  RESERVED1[2];	 // @6
	__IO uint8_t  SR;			 // @8 Status register
};

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL << 7,			   // Activation bit
	WWDG_CR_T	 = ((1UL << 7) - 1) << 0,  // 7-bit counter (MSB to LSB)
};
inline void		wwdg_cr_set_t(struct WWDG_Type *p, uint32_t val) { p->CR = (p->CR & ~WWDG_CR_T) | ((val << 0) & WWDG_CR_T); }
inline uint32_t wwdg_cr_get_t(struct WWDG_Type *p) { return (p->CR & WWDG_CR_T) >> 0; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_WDGTB = ((1UL << 3) - 1) << 11,  // Timer base
	WWDG_CFR_EWI   = 1UL << 9,				  // Early wakeup interrupt
	WWDG_CFR_W	   = ((1UL << 7) - 1) << 0,	  // 7-bit window value
};
inline void wwdg_cfr_set_wdgtb(struct WWDG_Type *p, uint32_t val) {
	p->CFR = (p->CFR & ~WWDG_CFR_WDGTB) | ((val << 11) & WWDG_CFR_WDGTB);
}
inline void		wwdg_cfr_set_w(struct WWDG_Type *p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_W) | ((val << 0) & WWDG_CFR_W); }
inline uint32_t wwdg_cfr_get_wdgtb(struct WWDG_Type *p) { return (p->CFR & WWDG_CFR_WDGTB) >> 11; }
inline uint32_t wwdg_cfr_get_w(struct WWDG_Type *p) { return (p->CFR & WWDG_CFR_W) >> 0; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL << 0,  // Early wakeup interrupt flag
};

#undef __I
#undef __O
#undef __IO

extern struct ADC1_Type				  ADC1;				   // @0x50000000
extern struct ADC12_Common_Type		  ADC12_Common;		   // @0x50000300
extern struct ADC1_Type				  ADC2;				   // @0x50000100
extern struct ADC3_Type				  ADC3;				   // @0x50000400
extern struct ADC12_Common_Type		  ADC345_Common;	   // @0x50000700
extern struct ADC1_Type				  ADC4;				   // @0x50000500
extern struct ADC3_Type				  ADC5;				   // @0x50000600
extern struct AES_Type				  AES;				   // @0x50060000
extern struct COMP_Type				  COMP;				   // @0x40010200
extern struct CORDIC_Type			  CORDIC;			   // @0x40020C00
extern struct CRC_Type				  CRC;				   // @0x40023000
extern struct CRS_Type				  CRS;				   // @0x40002000
extern struct DAC1_Type				  DAC1;				   // @0x50000800
extern struct DAC1_Type				  DAC2;				   // @0x50000C00
extern struct DAC1_Type				  DAC3;				   // @0x50001000
extern struct DAC1_Type				  DAC4;				   // @0x50001400
extern struct DBGMCU_Type			  DBGMCU;			   // @0xE0042000
extern struct DMA1_Type				  DMA1;				   // @0x40020000
extern struct DMA1_Type				  DMA2;				   // @0x40020400
extern struct DMAMUX_Type			  DMAMUX;			   // @0x40020800
extern struct EXTI_Type				  EXTI;				   // @0x40010400
extern struct FDCAN1_Type			  FDCAN1;			   // @0x40006400
extern struct FDCAN1_Type			  FDCAN2;			   // @0x40006800
extern struct FDCAN1_Type			  FDCAN3;			   // @0x40006C00
extern struct FDCANs_Message_RAM_Type FDCANs_Message_RAM;  // @0x4000A400
extern struct FLASH_Type			  FLASH;			   // @0x40022000
extern struct FMAC_Type				  FMAC;				   // @0x40021400
extern struct FMC_Type				  FMC;				   // @0xA0000000
extern struct FPU_Type				  FPU;				   // @0xE000EF34
extern struct FPU_CPACR_Type		  FPU_CPACR;		   // @0xE000ED88
extern struct GPIOA_Type			  GPIOA;			   // @0x48000000
extern struct GPIOA_Type			  GPIOB;			   // @0x48000400
extern struct GPIOA_Type			  GPIOC;			   // @0x48000800
extern struct GPIOA_Type			  GPIOD;			   // @0x48000C00
extern struct GPIOA_Type			  GPIOE;			   // @0x48001000
extern struct GPIOA_Type			  GPIOF;			   // @0x48001400
extern struct GPIOA_Type			  GPIOG;			   // @0x48001800
extern struct HRTIM_Common_Type		  HRTIM_Common;		   // @0x40016B80
extern struct HRTIM_Master_Type		  HRTIM_Master;		   // @0x40016800
extern struct HRTIM_TIMA_Type		  HRTIM_TIMA;		   // @0x40016880
extern struct HRTIM_TIMB_Type		  HRTIM_TIMB;		   // @0x40016900
extern struct HRTIM_TIMC_Type		  HRTIM_TIMC;		   // @0x40016980
extern struct HRTIM_TIMD_Type		  HRTIM_TIMD;		   // @0x40016A00
extern struct HRTIM_TIME_Type		  HRTIM_TIME;		   // @0x40016A80
extern struct HRTIM_TIMF_Type		  HRTIM_TIMF;		   // @0x40016B00
extern struct I2C1_Type				  I2C1;				   // @0x40005400
extern struct I2C1_Type				  I2C2;				   // @0x40005800
extern struct I2C1_Type				  I2C3;				   // @0x40007800
extern struct I2C1_Type				  I2C4;				   // @0x40008400
extern struct IWDG_Type				  IWDG;				   // @0x40003000
extern struct LPTIMER1_Type			  LPTIMER1;			   // @0x40007C00
extern struct LPUART1_Type			  LPUART1;			   // @0x40008000
extern struct MPU_Type				  MPU;				   // @0xE000E084
extern struct NVIC_Type				  NVIC;				   // @0xE000E100
extern struct NVIC_STIR_Type		  NVIC_STIR;		   // @0xE000EF00
extern struct OPAMP_Type			  OPAMP;			   // @0x40010300
extern struct PWR_Type				  PWR;				   // @0x40007000
extern struct QUADSPI_Type			  QUADSPI;			   // @0xA0001000
extern struct RCC_Type				  RCC;				   // @0x40021000
extern struct RNG_Type				  RNG;				   // @0x50060800
extern struct RTC_Type				  RTC;				   // @0x40002800
extern struct SAI_Type				  SAI;				   // @0x40015400
extern struct SCB_Type				  SCB;				   // @0xE000ED00
extern struct SCB_ACTLR_Type		  SCB_ACTLR;		   // @0xE000E008
extern struct SPI1_Type				  SPI1;				   // @0x40013000
extern struct SPI1_Type				  SPI2;				   // @0x40003800
extern struct SPI1_Type				  SPI3;				   // @0x40003C00
extern struct SPI1_Type				  SPI4;				   // @0x40013C00
extern struct STK_Type				  STK;				   // @0xE000E010
extern struct SYSCFG_Type			  SYSCFG;			   // @0x40010000
extern struct TAMP_Type				  TAMP;				   // @0x40002400
extern struct TIM1_Type				  TIM1;				   // @0x40012C00 Also: TIM6_Type
extern struct TIM15_Type			  TIM15;			   // @0x40014000 Also: TIM6_Type
extern struct TIM16_Type			  TIM16;			   // @0x40014400
extern struct TIM16_Type			  TIM17;			   // @0x40014800
extern struct TIM1_Type				  TIM2;				   // @0x40000000
extern struct TIM1_Type				  TIM20;			   // @0x40015000
extern struct TIM1_Type				  TIM3;				   // @0x40000400
extern struct TIM1_Type				  TIM4;				   // @0x40000800
extern struct TIM1_Type				  TIM5;				   // @0x40000C00
extern struct TIM6_Type				  TIM6;				   // @0x40001000
extern struct TIM6_Type				  TIM7;				   // @0x40001400
extern struct TIM1_Type				  TIM8;				   // @0x40013400
extern struct USART_Type			  UART4;			   // @0x40004C00
extern struct USART_Type			  UART5;			   // @0x40005000
extern struct UCPD1_Type			  UCPD1;			   // @0x4000A000
extern struct USART_Type			  USART1;			   // @0x40013800
extern struct USART_Type			  USART2;			   // @0x40004400
extern struct USART_Type			  USART3;			   // @0x40004800
// extern struct USB_FS_device_Type	USB_FS_device;	// @0x40005C00
extern struct VREFBUF_Type VREFBUF;	 // @0x40010030
extern struct WWDG_Type	   WWDG;	 // @0x40002C00
