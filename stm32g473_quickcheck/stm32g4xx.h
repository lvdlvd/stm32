#pragma once

// Generated enums and structures for device STM32G4xx version 2.0
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ           

	//  Cortex-CM4 Processor Exceptions Numbers 
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt                           
	HardFault_IRQn	      = -13, // 3 Hard Fault (Cortex M4 and up)
	MemoryManagement_IRQn = -12, // 4 Memory Management Interrupt            
	BusFault_IRQn         = -11, // 5 Bus Fault Interrupt                    
	UsageFault_IRQn       = -10, // 6 Usage Fault Interrupt                  
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 SV Call Interrupt                     
	DebugMonitor_IRQn     = -4, // 12 Debug Monitor Interrupt               
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Pend SV Interrupt                     
	SysTick_IRQn          = -1, // 15 System Tick Interrupt                 

	//  Device specific Interrupt Numbers
	PVD_PVM_IRQn = 1, // PVD through EXTI line detection
	RTC_TAMP_CSS_LSE_IRQn = 2, // RTC_TAMP_CSS_LSE
	RTC_WKUP_IRQn = 3, // RTC Wakeup timer
	FLASH_IRQn = 4, // FLASH
	RCC_IRQn = 5, // RCC global interrupt
	EXTI0_IRQn = 6, // EXTI Line0 interrupt
	EXTI1_IRQn = 7, // EXTI Line1 interrupt
	EXTI2_IRQn = 8, // EXTI Line2 interrupt
	EXTI3_IRQn = 9, // EXTI Line3 interrupt
	EXTI4_IRQn = 10, // EXTI Line4 interrupt
	DMA1_CH1_IRQn = 11, // DMA1 channel 1 interrupt
	DMA1_CH2_IRQn = 12, // DMA1 channel 2 interrupt
	DMA1_CH3_IRQn = 13, // DMA1 channel 3 interrupt
	DMA1_CH4_IRQn = 14, // DMA1 channel 4 interrupt
	DMA1_CH5_IRQn = 15, // DMA1 channel 5 interrupt
	DMA1_CH6_IRQn = 16, // DMA1 channel 6 interrupt
	DMA1_CH7_IRQn = 17, // DMA1 channel 7 interrupt
	ADC1_2_IRQn = 18, // ADC1 and ADC2 global interrupt
	USB_HP_IRQn = 19, // USB_HP
	USB_LP_IRQn = 20, // USB_LP
	FDCAN1_IT0_IRQn = 21, // FDCAN1 interrupt 0
	FDCAN1_IT1_IRQn = 22, // FDCAN1 interrupt 1
	EXTI9_5_IRQn = 23, // EXTI9_5
	TIM1_BRK_TIM15_IRQn = 24, // TIM1_BRK_TIM15
	TIM1_UP_TIM16_IRQn = 25, // TIM1_UP_TIM16
	TIM1_TRG_COM_IRQn = 26, // TIM1_TRG_COM/
	TIM1_CC_IRQn = 27, // TIM1 capture compare interrupt
	TIM2_IRQn = 28, // TIM2
	TIM3_IRQn = 29, // TIM3
	TIM4_IRQn = 30, // TIM4
	SPI1_IRQn = 35, // SPI1
	SPI2_IRQn = 36, // SPI2
	USART1_IRQn = 37, // USART1
	USART2_IRQn = 38, // USART2
	USART3_IRQn = 39, // USART3
	EXTI15_10_IRQn = 40, // EXTI15_10
	RTC_ALARM_IRQn = 41, // RTC_ALARM
	USBWakeUP_IRQn = 42, // USBWakeUP
	TIM8_BRK_IRQn = 43, // TIM8_BRK
	TIM8_UP_IRQn = 44, // TIM8_UP
	TIM8_TRG_COM_IRQn = 45, // TIM8_TRG_COM
	TIM8_CC_IRQn = 46, // TIM8_CC
	ADC3_IRQn = 47, // ADC3
	FMC_IRQn = 48, // FMC
	LPTIM1_IRQn = 49, // LPTIM1
	TIM5_IRQn = 50, // TIM5
	SPI3_IRQn = 51, // SPI3
	TIM6_DACUNDER_IRQn = 54, // TIM6_DACUNDER
	TIM7_IRQn = 55, // TIM7
	DMA2_CH1_IRQn = 56, // DMA2_CH1
	DMA2_CH2_IRQn = 57, // DMA2_CH2
	DMA2_CH3_IRQn = 58, // DMA2_CH3
	DMA2_CH4_IRQn = 59, // DMA2_CH4
	DMA2_CH5_IRQn = 60, // DMA2_CH5
	ADC4_IRQn = 61, // ADC4
	ADC5_IRQn = 62, // ADC5
	COMP1_2_3_IRQn = 64, // COMP1_2_3
	COMP4_5_6_IRQn = 65, // COMP4_5_6
	COMP7_IRQn = 66, // COMP7
	CRS_IRQn = 75, // CRS
	TIM20_BRK_IRQn = 77, // TIM20_BRK
	TIM20_UP_IRQn = 78, // TIM20_UP
	TIM20_TRG_COM_IRQn = 79, // TIM20_TRG_COM
	TIM20_CC_IRQn = 80, // TIM20_CC
	FPU_IRQn = 81, // Floating point unit interrupt
	SPI4_IRQn = 84, // SPI4
	FDCAN2_IT0_IRQn = 86, // FDCAN2 interrupt 0
	FDCAN2_IT1_IRQn = 87, // FDCAN2 interrupt 1
	FDCAN3_IT0_IRQn = 88, // FDCAN3 interrupt 0
	FDCAN3_IT1_IRQn = 89, // FDCAN3 interrupt 1
	RNG_IRQn = 90, // RNG
	LPUART_IRQn = 91, // LPUART
	DMAMUX_OVR_IRQn = 94, // DMAMUX_OVR
	DMA1_CH8_IRQn = 96, // DMA1_CH8
	DMA2_CH6_IRQn = 97, // DMA2_CH6
	DMA2_CH7_IRQn = 98, // DMA2_CH7
	DMA2_CH8_IRQn = 99, // DMA2_CH8
	Cordic_IRQn = 100, // Cordic
	FMAC_IRQn = 101, // FMAC
};


#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions


/* Analog-to-Digital Converter */
struct ADC1_Type {
	__IO uint32_t ISR; // @0 interrupt and status register
	__IO uint32_t IER; // @4 interrupt enable register
	__IO uint32_t CR; // @8 control register
	__IO uint32_t CFGR; // @12 configuration register
	__IO uint32_t CFGR2; // @16 configuration register
	__IO uint32_t SMPR1; // @20 sample time register 1
	__IO uint32_t SMPR2; // @24 sample time register 2
	 uint8_t RESERVED0[4]; // @28 
	__IO uint32_t TR1; // @32 watchdog threshold register 1
	__IO uint32_t TR2; // @36 watchdog threshold register
	__IO uint32_t TR3; // @40 watchdog threshold register 3
	 uint8_t RESERVED1[4]; // @44 
	__IO uint32_t SQR1; // @48 regular sequence register 1
	__IO uint32_t SQR2; // @52 regular sequence register 2
	__IO uint32_t SQR3; // @56 regular sequence register 3
	__IO uint32_t SQR4; // @60 regular sequence register 4
	__I uint32_t DR; // @64 regular Data Register
	 uint8_t RESERVED2[8]; // @68 
	__IO uint32_t JSQR; // @76 injected sequence register
	 uint8_t RESERVED3[16]; // @80 
	__IO uint32_t OFR1; // @96 offset register 1
	__IO uint32_t OFR2; // @100 offset register 2
	__IO uint32_t OFR3; // @104 offset register 3
	__IO uint32_t OFR4; // @108 offset register 4
	 uint8_t RESERVED4[16]; // @112 
	__I uint32_t JDR1; // @128 injected data register 1
	__I uint32_t JDR2; // @132 injected data register 2
	__I uint32_t JDR3; // @136 injected data register 3
	__I uint32_t JDR4; // @140 injected data register 4
	 uint8_t RESERVED5[16]; // @144 
	__IO uint32_t AWD2CR; // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR; // @164 Analog Watchdog 3 Configuration Register
	 uint8_t RESERVED6[8]; // @168 
	__IO uint32_t DIFSEL; // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT; // @180 Calibration Factors
	 uint8_t RESERVED7[8]; // @184 
	__IO uint32_t GCOMP; // @192 Gain compensation Register
};
extern struct ADC1_Type	ADC1;	// @0x50000000 
extern struct ADC1_Type 	ADC2;	// @0x50000100
extern struct ADC1_Type 	ADC4;	// @0x50000500

// ADC1->ISR interrupt and status register
enum {
	ADC1_ISR_JQOVF = 1UL<<10, // JQOVF
	ADC1_ISR_AWD3 = 1UL<<9, // AWD3
	ADC1_ISR_AWD2 = 1UL<<8, // AWD2
	ADC1_ISR_AWD1 = 1UL<<7, // AWD1
	ADC1_ISR_JEOS = 1UL<<6, // JEOS
	ADC1_ISR_JEOC = 1UL<<5, // JEOC
	ADC1_ISR_OVR = 1UL<<4, // OVR
	ADC1_ISR_EOS = 1UL<<3, // EOS
	ADC1_ISR_EOC = 1UL<<2, // EOC
	ADC1_ISR_EOSMP = 1UL<<1, // EOSMP
	ADC1_ISR_ADRDY = 1UL<<0, // ADRDY		
};

// ADC1->IER interrupt enable register
enum {
	ADC1_IER_JQOVFIE = 1UL<<10, // JQOVFIE
	ADC1_IER_AWD3IE = 1UL<<9, // AWD3IE
	ADC1_IER_AWD2IE = 1UL<<8, // AWD2IE
	ADC1_IER_AWD1IE = 1UL<<7, // AWD1IE
	ADC1_IER_JEOSIE = 1UL<<6, // JEOSIE
	ADC1_IER_JEOCIE = 1UL<<5, // JEOCIE
	ADC1_IER_OVRIE = 1UL<<4, // OVRIE
	ADC1_IER_EOSIE = 1UL<<3, // EOSIE
	ADC1_IER_EOCIE = 1UL<<2, // EOCIE
	ADC1_IER_EOSMPIE = 1UL<<1, // EOSMPIE
	ADC1_IER_ADRDYIE = 1UL<<0, // ADRDYIE		
};

// ADC1->CR control register
enum {
	ADC1_CR_ADCAL = 1UL<<31, // ADCAL
	ADC1_CR_ADCALDIF = 1UL<<30, // ADCALDIF
	ADC1_CR_DEEPPWD = 1UL<<29, // DEEPPWD
	ADC1_CR_ADVREGEN = 1UL<<28, // ADVREGEN
	ADC1_CR_JADSTP = 1UL<<5, // JADSTP
	ADC1_CR_ADSTP = 1UL<<4, // ADSTP
	ADC1_CR_JADSTART = 1UL<<3, // JADSTART
	ADC1_CR_ADSTART = 1UL<<2, // ADSTART
	ADC1_CR_ADDIS = 1UL<<1, // ADDIS
	ADC1_CR_ADEN = 1UL<<0, // ADEN		
};

// ADC1->CFGR configuration register
enum {
	ADC1_CFGR_JQDIS = 1UL<<31, // Injected Queue disable
	ADC1_CFGR_AWD1CH = ((1UL<<5)-1) << 26, // Analog watchdog 1 channel selection
	ADC1_CFGR_JAUTO = 1UL<<25, // JAUTO
	ADC1_CFGR_JAWD1EN = 1UL<<24, // JAWD1EN
	ADC1_CFGR_AWD1EN = 1UL<<23, // AWD1EN
	ADC1_CFGR_AWD1SGL = 1UL<<22, // AWD1SGL
	ADC1_CFGR_JQM = 1UL<<21, // JQM
	ADC1_CFGR_JDISCEN = 1UL<<20, // JDISCEN
	ADC1_CFGR_DISCNUM = ((1UL<<3)-1) << 17, // DISCNUM
	ADC1_CFGR_DISCEN = 1UL<<16, // DISCEN
	ADC1_CFGR_ALIGN = 1UL<<15, // ALIGN
	ADC1_CFGR_AUTDLY = 1UL<<14, // AUTDLY
	ADC1_CFGR_CONT = 1UL<<13, // CONT
	ADC1_CFGR_OVRMOD = 1UL<<12, // OVRMOD
	ADC1_CFGR_EXTEN = ((1UL<<2)-1) << 10, // EXTEN
	ADC1_CFGR_EXTSEL = ((1UL<<5)-1) << 5, // External trigger selection for regular group
	ADC1_CFGR_RES = ((1UL<<2)-1) << 3, // RES
	ADC1_CFGR_DMACFG = 1UL<<1, // DMACFG
	ADC1_CFGR_DMAEN = 1UL<<0, // DMAEN		
};
static inline void adc1_cfgr_set_awd1ch(struct ADC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC1_CFGR_AWD1CH) | ((val<<26) & ADC1_CFGR_AWD1CH); }
static inline void adc1_cfgr_set_discnum(struct ADC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC1_CFGR_DISCNUM) | ((val<<17) & ADC1_CFGR_DISCNUM); }
static inline void adc1_cfgr_set_exten(struct ADC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC1_CFGR_EXTEN) | ((val<<10) & ADC1_CFGR_EXTEN); }
static inline void adc1_cfgr_set_extsel(struct ADC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC1_CFGR_EXTSEL) | ((val<<5) & ADC1_CFGR_EXTSEL); }
static inline void adc1_cfgr_set_res(struct ADC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC1_CFGR_RES) | ((val<<3) & ADC1_CFGR_RES); }
static inline uint32_t adc1_cfgr_get_awd1ch(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_AWD1CH) >> 26 ; }
static inline uint32_t adc1_cfgr_get_discnum(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_DISCNUM) >> 17 ; }
static inline uint32_t adc1_cfgr_get_exten(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_EXTEN) >> 10 ; }
static inline uint32_t adc1_cfgr_get_extsel(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_EXTSEL) >> 5 ; }
static inline uint32_t adc1_cfgr_get_res(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_RES) >> 3 ; }

// ADC1->CFGR2 configuration register
enum {
	ADC1_CFGR2_SMPTRIG = 1UL<<27, // SMPTRIG
	ADC1_CFGR2_BULB = 1UL<<26, // BULB
	ADC1_CFGR2_SWTRIG = 1UL<<25, // SWTRIG
	ADC1_CFGR2_GCOMP = 1UL<<16, // GCOMP
	ADC1_CFGR2_ROVSM = 1UL<<10, // EXTEN
	ADC1_CFGR2_TROVS = 1UL<<9, // Triggered Regular Oversampling
	ADC1_CFGR2_OVSS = ((1UL<<4)-1) << 5, // ALIGN
	ADC1_CFGR2_OVSR = ((1UL<<3)-1) << 2, // RES
	ADC1_CFGR2_JOVSE = 1UL<<1, // DMACFG
	ADC1_CFGR2_ROVSE = 1UL<<0, // DMAEN		
};
static inline void adc1_cfgr2_set_ovss(struct ADC1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC1_CFGR2_OVSS) | ((val<<5) & ADC1_CFGR2_OVSS); }
static inline void adc1_cfgr2_set_ovsr(struct ADC1_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC1_CFGR2_OVSR) | ((val<<2) & ADC1_CFGR2_OVSR); }
static inline uint32_t adc1_cfgr2_get_ovss(struct ADC1_Type* p) { return (p->CFGR2 & ADC1_CFGR2_OVSS) >> 5 ; }
static inline uint32_t adc1_cfgr2_get_ovsr(struct ADC1_Type* p) { return (p->CFGR2 & ADC1_CFGR2_OVSR) >> 2 ; }

// ADC1->SMPR1 sample time register 1
enum {
	ADC1_SMPR1_SMPPLUS = 1UL<<31, // Addition of one clock cycle to the sampling time
	ADC1_SMPR1_SMP9 = ((1UL<<3)-1) << 27, // SMP9
	ADC1_SMPR1_SMP8 = ((1UL<<3)-1) << 24, // SMP8
	ADC1_SMPR1_SMP7 = ((1UL<<3)-1) << 21, // SMP7
	ADC1_SMPR1_SMP6 = ((1UL<<3)-1) << 18, // SMP6
	ADC1_SMPR1_SMP5 = ((1UL<<3)-1) << 15, // SMP5
	ADC1_SMPR1_SMP4 = ((1UL<<3)-1) << 12, // SMP4
	ADC1_SMPR1_SMP3 = ((1UL<<3)-1) << 9, // SMP3
	ADC1_SMPR1_SMP2 = ((1UL<<3)-1) << 6, // SMP2
	ADC1_SMPR1_SMP1 = ((1UL<<3)-1) << 3, // SMP1
	ADC1_SMPR1_SMP0 = ((1UL<<3)-1) << 0, // SMP0		
};
static inline void adc1_smpr1_set_smp9(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP9) | ((val<<27) & ADC1_SMPR1_SMP9); }
static inline void adc1_smpr1_set_smp8(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP8) | ((val<<24) & ADC1_SMPR1_SMP8); }
static inline void adc1_smpr1_set_smp7(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP7) | ((val<<21) & ADC1_SMPR1_SMP7); }
static inline void adc1_smpr1_set_smp6(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP6) | ((val<<18) & ADC1_SMPR1_SMP6); }
static inline void adc1_smpr1_set_smp5(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP5) | ((val<<15) & ADC1_SMPR1_SMP5); }
static inline void adc1_smpr1_set_smp4(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP4) | ((val<<12) & ADC1_SMPR1_SMP4); }
static inline void adc1_smpr1_set_smp3(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP3) | ((val<<9) & ADC1_SMPR1_SMP3); }
static inline void adc1_smpr1_set_smp2(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP2) | ((val<<6) & ADC1_SMPR1_SMP2); }
static inline void adc1_smpr1_set_smp1(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP1) | ((val<<3) & ADC1_SMPR1_SMP1); }
static inline void adc1_smpr1_set_smp0(struct ADC1_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP0) | ((val<<0) & ADC1_SMPR1_SMP0); }
static inline uint32_t adc1_smpr1_get_smp9(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP9) >> 27 ; }
static inline uint32_t adc1_smpr1_get_smp8(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP8) >> 24 ; }
static inline uint32_t adc1_smpr1_get_smp7(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP7) >> 21 ; }
static inline uint32_t adc1_smpr1_get_smp6(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP6) >> 18 ; }
static inline uint32_t adc1_smpr1_get_smp5(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP5) >> 15 ; }
static inline uint32_t adc1_smpr1_get_smp4(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP4) >> 12 ; }
static inline uint32_t adc1_smpr1_get_smp3(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP3) >> 9 ; }
static inline uint32_t adc1_smpr1_get_smp2(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP2) >> 6 ; }
static inline uint32_t adc1_smpr1_get_smp1(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP1) >> 3 ; }
static inline uint32_t adc1_smpr1_get_smp0(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP0) >> 0 ; }

// ADC1->SMPR2 sample time register 2
enum {
	ADC1_SMPR2_SMP18 = ((1UL<<3)-1) << 24, // SMP18
	ADC1_SMPR2_SMP17 = ((1UL<<3)-1) << 21, // SMP17
	ADC1_SMPR2_SMP16 = ((1UL<<3)-1) << 18, // SMP16
	ADC1_SMPR2_SMP15 = ((1UL<<3)-1) << 15, // SMP15
	ADC1_SMPR2_SMP14 = ((1UL<<3)-1) << 12, // SMP14
	ADC1_SMPR2_SMP13 = ((1UL<<3)-1) << 9, // SMP13
	ADC1_SMPR2_SMP12 = ((1UL<<3)-1) << 6, // SMP12
	ADC1_SMPR2_SMP11 = ((1UL<<3)-1) << 3, // SMP11
	ADC1_SMPR2_SMP10 = ((1UL<<3)-1) << 0, // SMP10		
};
static inline void adc1_smpr2_set_smp18(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP18) | ((val<<24) & ADC1_SMPR2_SMP18); }
static inline void adc1_smpr2_set_smp17(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP17) | ((val<<21) & ADC1_SMPR2_SMP17); }
static inline void adc1_smpr2_set_smp16(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP16) | ((val<<18) & ADC1_SMPR2_SMP16); }
static inline void adc1_smpr2_set_smp15(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP15) | ((val<<15) & ADC1_SMPR2_SMP15); }
static inline void adc1_smpr2_set_smp14(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP14) | ((val<<12) & ADC1_SMPR2_SMP14); }
static inline void adc1_smpr2_set_smp13(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP13) | ((val<<9) & ADC1_SMPR2_SMP13); }
static inline void adc1_smpr2_set_smp12(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP12) | ((val<<6) & ADC1_SMPR2_SMP12); }
static inline void adc1_smpr2_set_smp11(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP11) | ((val<<3) & ADC1_SMPR2_SMP11); }
static inline void adc1_smpr2_set_smp10(struct ADC1_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP10) | ((val<<0) & ADC1_SMPR2_SMP10); }
static inline uint32_t adc1_smpr2_get_smp18(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP18) >> 24 ; }
static inline uint32_t adc1_smpr2_get_smp17(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP17) >> 21 ; }
static inline uint32_t adc1_smpr2_get_smp16(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP16) >> 18 ; }
static inline uint32_t adc1_smpr2_get_smp15(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP15) >> 15 ; }
static inline uint32_t adc1_smpr2_get_smp14(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP14) >> 12 ; }
static inline uint32_t adc1_smpr2_get_smp13(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP13) >> 9 ; }
static inline uint32_t adc1_smpr2_get_smp12(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP12) >> 6 ; }
static inline uint32_t adc1_smpr2_get_smp11(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP11) >> 3 ; }
static inline uint32_t adc1_smpr2_get_smp10(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP10) >> 0 ; }

// ADC1->TR1 watchdog threshold register 1
enum {
	ADC1_TR1_HT1 = ((1UL<<12)-1) << 16, // HT1
	ADC1_TR1_AWDFILT = ((1UL<<3)-1) << 12, // AWDFILT
	ADC1_TR1_LT1 = ((1UL<<12)-1) << 0, // LT1		
};
static inline void adc1_tr1_set_ht1(struct ADC1_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC1_TR1_HT1) | ((val<<16) & ADC1_TR1_HT1); }
static inline void adc1_tr1_set_awdfilt(struct ADC1_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC1_TR1_AWDFILT) | ((val<<12) & ADC1_TR1_AWDFILT); }
static inline void adc1_tr1_set_lt1(struct ADC1_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC1_TR1_LT1) | ((val<<0) & ADC1_TR1_LT1); }
static inline uint32_t adc1_tr1_get_ht1(struct ADC1_Type* p) { return (p->TR1 & ADC1_TR1_HT1) >> 16 ; }
static inline uint32_t adc1_tr1_get_awdfilt(struct ADC1_Type* p) { return (p->TR1 & ADC1_TR1_AWDFILT) >> 12 ; }
static inline uint32_t adc1_tr1_get_lt1(struct ADC1_Type* p) { return (p->TR1 & ADC1_TR1_LT1) >> 0 ; }

// ADC1->TR2 watchdog threshold register
enum {
	ADC1_TR2_HT2 = ((1UL<<8)-1) << 16, // HT2
	ADC1_TR2_LT2 = ((1UL<<8)-1) << 0, // LT2		
};
static inline void adc1_tr2_set_ht2(struct ADC1_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC1_TR2_HT2) | ((val<<16) & ADC1_TR2_HT2); }
static inline void adc1_tr2_set_lt2(struct ADC1_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC1_TR2_LT2) | ((val<<0) & ADC1_TR2_LT2); }
static inline uint32_t adc1_tr2_get_ht2(struct ADC1_Type* p) { return (p->TR2 & ADC1_TR2_HT2) >> 16 ; }
static inline uint32_t adc1_tr2_get_lt2(struct ADC1_Type* p) { return (p->TR2 & ADC1_TR2_LT2) >> 0 ; }

// ADC1->TR3 watchdog threshold register 3
enum {
	ADC1_TR3_HT3 = ((1UL<<8)-1) << 16, // HT3
	ADC1_TR3_LT3 = ((1UL<<8)-1) << 0, // LT3		
};
static inline void adc1_tr3_set_ht3(struct ADC1_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC1_TR3_HT3) | ((val<<16) & ADC1_TR3_HT3); }
static inline void adc1_tr3_set_lt3(struct ADC1_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC1_TR3_LT3) | ((val<<0) & ADC1_TR3_LT3); }
static inline uint32_t adc1_tr3_get_ht3(struct ADC1_Type* p) { return (p->TR3 & ADC1_TR3_HT3) >> 16 ; }
static inline uint32_t adc1_tr3_get_lt3(struct ADC1_Type* p) { return (p->TR3 & ADC1_TR3_LT3) >> 0 ; }

// ADC1->SQR1 regular sequence register 1
enum {
	ADC1_SQR1_SQ4 = ((1UL<<5)-1) << 24, // SQ4
	ADC1_SQR1_SQ3 = ((1UL<<5)-1) << 18, // SQ3
	ADC1_SQR1_SQ2 = ((1UL<<5)-1) << 12, // SQ2
	ADC1_SQR1_SQ1 = ((1UL<<5)-1) << 6, // SQ1
	ADC1_SQR1_L = ((1UL<<4)-1) << 0, // Regular channel sequence length		
};
static inline void adc1_sqr1_set_sq4(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ4) | ((val<<24) & ADC1_SQR1_SQ4); }
static inline void adc1_sqr1_set_sq3(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ3) | ((val<<18) & ADC1_SQR1_SQ3); }
static inline void adc1_sqr1_set_sq2(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ2) | ((val<<12) & ADC1_SQR1_SQ2); }
static inline void adc1_sqr1_set_sq1(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ1) | ((val<<6) & ADC1_SQR1_SQ1); }
static inline void adc1_sqr1_set_l(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_L) | ((val<<0) & ADC1_SQR1_L); }
static inline uint32_t adc1_sqr1_get_sq4(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ4) >> 24 ; }
static inline uint32_t adc1_sqr1_get_sq3(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ3) >> 18 ; }
static inline uint32_t adc1_sqr1_get_sq2(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ2) >> 12 ; }
static inline uint32_t adc1_sqr1_get_sq1(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ1) >> 6 ; }
static inline uint32_t adc1_sqr1_get_l(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_L) >> 0 ; }

// ADC1->SQR2 regular sequence register 2
enum {
	ADC1_SQR2_SQ9 = ((1UL<<5)-1) << 24, // SQ9
	ADC1_SQR2_SQ8 = ((1UL<<5)-1) << 18, // SQ8
	ADC1_SQR2_SQ7 = ((1UL<<5)-1) << 12, // SQ7
	ADC1_SQR2_SQ6 = ((1UL<<5)-1) << 6, // SQ6
	ADC1_SQR2_SQ5 = ((1UL<<5)-1) << 0, // SQ5		
};
static inline void adc1_sqr2_set_sq9(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ9) | ((val<<24) & ADC1_SQR2_SQ9); }
static inline void adc1_sqr2_set_sq8(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ8) | ((val<<18) & ADC1_SQR2_SQ8); }
static inline void adc1_sqr2_set_sq7(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ7) | ((val<<12) & ADC1_SQR2_SQ7); }
static inline void adc1_sqr2_set_sq6(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ6) | ((val<<6) & ADC1_SQR2_SQ6); }
static inline void adc1_sqr2_set_sq5(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ5) | ((val<<0) & ADC1_SQR2_SQ5); }
static inline uint32_t adc1_sqr2_get_sq9(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ9) >> 24 ; }
static inline uint32_t adc1_sqr2_get_sq8(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ8) >> 18 ; }
static inline uint32_t adc1_sqr2_get_sq7(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ7) >> 12 ; }
static inline uint32_t adc1_sqr2_get_sq6(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ6) >> 6 ; }
static inline uint32_t adc1_sqr2_get_sq5(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ5) >> 0 ; }

// ADC1->SQR3 regular sequence register 3
enum {
	ADC1_SQR3_SQ14 = ((1UL<<5)-1) << 24, // SQ14
	ADC1_SQR3_SQ13 = ((1UL<<5)-1) << 18, // SQ13
	ADC1_SQR3_SQ12 = ((1UL<<5)-1) << 12, // SQ12
	ADC1_SQR3_SQ11 = ((1UL<<5)-1) << 6, // SQ11
	ADC1_SQR3_SQ10 = ((1UL<<5)-1) << 0, // SQ10		
};
static inline void adc1_sqr3_set_sq14(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ14) | ((val<<24) & ADC1_SQR3_SQ14); }
static inline void adc1_sqr3_set_sq13(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ13) | ((val<<18) & ADC1_SQR3_SQ13); }
static inline void adc1_sqr3_set_sq12(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ12) | ((val<<12) & ADC1_SQR3_SQ12); }
static inline void adc1_sqr3_set_sq11(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ11) | ((val<<6) & ADC1_SQR3_SQ11); }
static inline void adc1_sqr3_set_sq10(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ10) | ((val<<0) & ADC1_SQR3_SQ10); }
static inline uint32_t adc1_sqr3_get_sq14(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ14) >> 24 ; }
static inline uint32_t adc1_sqr3_get_sq13(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ13) >> 18 ; }
static inline uint32_t adc1_sqr3_get_sq12(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ12) >> 12 ; }
static inline uint32_t adc1_sqr3_get_sq11(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ11) >> 6 ; }
static inline uint32_t adc1_sqr3_get_sq10(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ10) >> 0 ; }

// ADC1->SQR4 regular sequence register 4
enum {
	ADC1_SQR4_SQ16 = ((1UL<<5)-1) << 6, // SQ16
	ADC1_SQR4_SQ15 = ((1UL<<5)-1) << 0, // SQ15		
};
static inline void adc1_sqr4_set_sq16(struct ADC1_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC1_SQR4_SQ16) | ((val<<6) & ADC1_SQR4_SQ16); }
static inline void adc1_sqr4_set_sq15(struct ADC1_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC1_SQR4_SQ15) | ((val<<0) & ADC1_SQR4_SQ15); }
static inline uint32_t adc1_sqr4_get_sq16(struct ADC1_Type* p) { return (p->SQR4 & ADC1_SQR4_SQ16) >> 6 ; }
static inline uint32_t adc1_sqr4_get_sq15(struct ADC1_Type* p) { return (p->SQR4 & ADC1_SQR4_SQ15) >> 0 ; }

// ADC1->DR regular Data Register
enum {
	ADC1_DR_RDATA = ((1UL<<16)-1) << 0, // Regular Data converted		
};
static inline uint32_t adc1_dr_get_rdata(struct ADC1_Type* p) { return (p->DR & ADC1_DR_RDATA) >> 0 ; }

// ADC1->JSQR injected sequence register
enum {
	ADC1_JSQR_JSQ4 = ((1UL<<5)-1) << 27, // JSQ4
	ADC1_JSQR_JSQ3 = ((1UL<<5)-1) << 21, // JSQ3
	ADC1_JSQR_JSQ2 = ((1UL<<5)-1) << 15, // JSQ2
	ADC1_JSQR_JSQ1 = ((1UL<<5)-1) << 9, // JSQ1
	ADC1_JSQR_JEXTEN = ((1UL<<2)-1) << 7, // JEXTEN
	ADC1_JSQR_JEXTSEL = ((1UL<<5)-1) << 2, // JEXTSEL
	ADC1_JSQR_JL = ((1UL<<2)-1) << 0, // JL		
};
static inline void adc1_jsqr_set_jsq4(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ4) | ((val<<27) & ADC1_JSQR_JSQ4); }
static inline void adc1_jsqr_set_jsq3(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ3) | ((val<<21) & ADC1_JSQR_JSQ3); }
static inline void adc1_jsqr_set_jsq2(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ2) | ((val<<15) & ADC1_JSQR_JSQ2); }
static inline void adc1_jsqr_set_jsq1(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ1) | ((val<<9) & ADC1_JSQR_JSQ1); }
static inline void adc1_jsqr_set_jexten(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JEXTEN) | ((val<<7) & ADC1_JSQR_JEXTEN); }
static inline void adc1_jsqr_set_jextsel(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JEXTSEL) | ((val<<2) & ADC1_JSQR_JEXTSEL); }
static inline void adc1_jsqr_set_jl(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JL) | ((val<<0) & ADC1_JSQR_JL); }
static inline uint32_t adc1_jsqr_get_jsq4(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ4) >> 27 ; }
static inline uint32_t adc1_jsqr_get_jsq3(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ3) >> 21 ; }
static inline uint32_t adc1_jsqr_get_jsq2(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ2) >> 15 ; }
static inline uint32_t adc1_jsqr_get_jsq1(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ1) >> 9 ; }
static inline uint32_t adc1_jsqr_get_jexten(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JEXTEN) >> 7 ; }
static inline uint32_t adc1_jsqr_get_jextsel(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JEXTSEL) >> 2 ; }
static inline uint32_t adc1_jsqr_get_jl(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JL) >> 0 ; }

// ADC1->OFR1 offset register 1
enum {
	ADC1_OFR1_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC1_OFR1_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC1_OFR1_SATEN = 1UL<<25, // SATEN
	ADC1_OFR1_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC1_OFR1_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc1_ofr1_set_offset1_ch(struct ADC1_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC1_OFR1_OFFSET1_CH) | ((val<<26) & ADC1_OFR1_OFFSET1_CH); }
static inline void adc1_ofr1_set_offset1(struct ADC1_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC1_OFR1_OFFSET1) | ((val<<0) & ADC1_OFR1_OFFSET1); }
static inline uint32_t adc1_ofr1_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR1 & ADC1_OFR1_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc1_ofr1_get_offset1(struct ADC1_Type* p) { return (p->OFR1 & ADC1_OFR1_OFFSET1) >> 0 ; }

// ADC1->OFR2 offset register 2
enum {
	ADC1_OFR2_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC1_OFR2_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC1_OFR2_SATEN = 1UL<<25, // SATEN
	ADC1_OFR2_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC1_OFR2_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc1_ofr2_set_offset1_ch(struct ADC1_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC1_OFR2_OFFSET1_CH) | ((val<<26) & ADC1_OFR2_OFFSET1_CH); }
static inline void adc1_ofr2_set_offset1(struct ADC1_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC1_OFR2_OFFSET1) | ((val<<0) & ADC1_OFR2_OFFSET1); }
static inline uint32_t adc1_ofr2_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR2 & ADC1_OFR2_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc1_ofr2_get_offset1(struct ADC1_Type* p) { return (p->OFR2 & ADC1_OFR2_OFFSET1) >> 0 ; }

// ADC1->OFR3 offset register 3
enum {
	ADC1_OFR3_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC1_OFR3_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC1_OFR3_SATEN = 1UL<<25, // SATEN
	ADC1_OFR3_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC1_OFR3_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc1_ofr3_set_offset1_ch(struct ADC1_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC1_OFR3_OFFSET1_CH) | ((val<<26) & ADC1_OFR3_OFFSET1_CH); }
static inline void adc1_ofr3_set_offset1(struct ADC1_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC1_OFR3_OFFSET1) | ((val<<0) & ADC1_OFR3_OFFSET1); }
static inline uint32_t adc1_ofr3_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR3 & ADC1_OFR3_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc1_ofr3_get_offset1(struct ADC1_Type* p) { return (p->OFR3 & ADC1_OFR3_OFFSET1) >> 0 ; }

// ADC1->OFR4 offset register 4
enum {
	ADC1_OFR4_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC1_OFR4_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC1_OFR4_SATEN = 1UL<<25, // SATEN
	ADC1_OFR4_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC1_OFR4_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc1_ofr4_set_offset1_ch(struct ADC1_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC1_OFR4_OFFSET1_CH) | ((val<<26) & ADC1_OFR4_OFFSET1_CH); }
static inline void adc1_ofr4_set_offset1(struct ADC1_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC1_OFR4_OFFSET1) | ((val<<0) & ADC1_OFR4_OFFSET1); }
static inline uint32_t adc1_ofr4_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR4 & ADC1_OFR4_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc1_ofr4_get_offset1(struct ADC1_Type* p) { return (p->OFR4 & ADC1_OFR4_OFFSET1) >> 0 ; }

// ADC1->JDR1 injected data register 1
enum {
	ADC1_JDR1_JDATA1 = ((1UL<<16)-1) << 0, // JDATA1		
};
static inline uint32_t adc1_jdr1_get_jdata1(struct ADC1_Type* p) { return (p->JDR1 & ADC1_JDR1_JDATA1) >> 0 ; }

// ADC1->JDR2 injected data register 2
enum {
	ADC1_JDR2_JDATA2 = ((1UL<<16)-1) << 0, // JDATA2		
};
static inline uint32_t adc1_jdr2_get_jdata2(struct ADC1_Type* p) { return (p->JDR2 & ADC1_JDR2_JDATA2) >> 0 ; }

// ADC1->JDR3 injected data register 3
enum {
	ADC1_JDR3_JDATA3 = ((1UL<<16)-1) << 0, // JDATA3		
};
static inline uint32_t adc1_jdr3_get_jdata3(struct ADC1_Type* p) { return (p->JDR3 & ADC1_JDR3_JDATA3) >> 0 ; }

// ADC1->JDR4 injected data register 4
enum {
	ADC1_JDR4_JDATA4 = ((1UL<<16)-1) << 0, // JDATA4		
};
static inline uint32_t adc1_jdr4_get_jdata4(struct ADC1_Type* p) { return (p->JDR4 & ADC1_JDR4_JDATA4) >> 0 ; }

// ADC1->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC1_AWD2CR_AWD2CH = ((1UL<<19)-1) << 0, // AWD2CH		
};
static inline void adc1_awd2cr_set_awd2ch(struct ADC1_Type* p, uint32_t val) { p->AWD2CR = (p->AWD2CR & ~ADC1_AWD2CR_AWD2CH) | ((val<<0) & ADC1_AWD2CR_AWD2CH); }
static inline uint32_t adc1_awd2cr_get_awd2ch(struct ADC1_Type* p) { return (p->AWD2CR & ADC1_AWD2CR_AWD2CH) >> 0 ; }

// ADC1->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC1_AWD3CR_AWD3CH = ((1UL<<19)-1) << 0, // AWD3CH		
};
static inline void adc1_awd3cr_set_awd3ch(struct ADC1_Type* p, uint32_t val) { p->AWD3CR = (p->AWD3CR & ~ADC1_AWD3CR_AWD3CH) | ((val<<0) & ADC1_AWD3CR_AWD3CH); }
static inline uint32_t adc1_awd3cr_get_awd3ch(struct ADC1_Type* p) { return (p->AWD3CR & ADC1_AWD3CR_AWD3CH) >> 0 ; }

// ADC1->DIFSEL Differential Mode Selection Register 2
enum {
	ADC1_DIFSEL_DIFSEL_1_18 = ((1UL<<18)-1) << 1, // Differential mode for channels 15 to 1
	ADC1_DIFSEL_DIFSEL_0 = 1UL<<0, // Differential mode for channels 0		
};
static inline void adc1_difsel_set_difsel_1_18(struct ADC1_Type* p, uint32_t val) { p->DIFSEL = (p->DIFSEL & ~ADC1_DIFSEL_DIFSEL_1_18) | ((val<<1) & ADC1_DIFSEL_DIFSEL_1_18); }
static inline uint32_t adc1_difsel_get_difsel_1_18(struct ADC1_Type* p) { return (p->DIFSEL & ADC1_DIFSEL_DIFSEL_1_18) >> 1 ; }

// ADC1->CALFACT Calibration Factors
enum {
	ADC1_CALFACT_CALFACT_D = ((1UL<<7)-1) << 16, // CALFACT_D
	ADC1_CALFACT_CALFACT_S = ((1UL<<7)-1) << 0, // CALFACT_S		
};
static inline void adc1_calfact_set_calfact_d(struct ADC1_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC1_CALFACT_CALFACT_D) | ((val<<16) & ADC1_CALFACT_CALFACT_D); }
static inline void adc1_calfact_set_calfact_s(struct ADC1_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC1_CALFACT_CALFACT_S) | ((val<<0) & ADC1_CALFACT_CALFACT_S); }
static inline uint32_t adc1_calfact_get_calfact_d(struct ADC1_Type* p) { return (p->CALFACT & ADC1_CALFACT_CALFACT_D) >> 16 ; }
static inline uint32_t adc1_calfact_get_calfact_s(struct ADC1_Type* p) { return (p->CALFACT & ADC1_CALFACT_CALFACT_S) >> 0 ; }

// ADC1->GCOMP Gain compensation Register
enum {
	ADC1_GCOMP_GCOMPCOEFF = ((1UL<<14)-1) << 0, // GCOMPCOEFF		
};
static inline void adc1_gcomp_set_gcompcoeff(struct ADC1_Type* p, uint32_t val) { p->GCOMP = (p->GCOMP & ~ADC1_GCOMP_GCOMPCOEFF) | ((val<<0) & ADC1_GCOMP_GCOMPCOEFF); }
static inline uint32_t adc1_gcomp_get_gcompcoeff(struct ADC1_Type* p) { return (p->GCOMP & ADC1_GCOMP_GCOMPCOEFF) >> 0 ; }

/* Analog-to-Digital Converter */
struct ADC_Common_Type {
	__I uint32_t CSR; // @0 ADC Common status register
	 uint8_t RESERVED0[4]; // @4 
	__IO uint32_t CCR; // @8 ADC common control register
	__I uint32_t CDR; // @12 ADC common regular data register for dual and triple modes
};
extern struct ADC_Common_Type	ADC12_Common;	// @0x50000300 
extern struct ADC_Common_Type 	ADC345_Common;	// @0x50000700

// ADC_Common->CSR ADC Common status register
enum {
	ADC_COMMON_CSR_JQOVF_SLV = 1UL<<26, // Injected Context Queue Overflow flag of the slave ADC
	ADC_COMMON_CSR_AWD3_SLV = 1UL<<25, // Analog watchdog 3 flag of the slave ADC
	ADC_COMMON_CSR_AWD2_SLV = 1UL<<24, // Analog watchdog 2 flag of the slave ADC
	ADC_COMMON_CSR_AWD1_SLV = 1UL<<23, // Analog watchdog 1 flag of the slave ADC
	ADC_COMMON_CSR_JEOS_SLV = 1UL<<22, // End of injected sequence flag of the slave ADC
	ADC_COMMON_CSR_JEOC_SLV = 1UL<<21, // End of injected conversion flag of the slave ADC
	ADC_COMMON_CSR_OVR_SLV = 1UL<<20, // Overrun flag of the slave ADC
	ADC_COMMON_CSR_EOS_SLV = 1UL<<19, // End of regular sequence flag of the slave ADC
	ADC_COMMON_CSR_EOC_SLV = 1UL<<18, // End of regular conversion of the slave ADC
	ADC_COMMON_CSR_EOSMP_SLV = 1UL<<17, // EOSMP_SLV
	ADC_COMMON_CSR_ADRDY_SLV = 1UL<<16, // ADRDY_SLV
	ADC_COMMON_CSR_JQOVF_MST = 1UL<<10, // JQOVF_MST
	ADC_COMMON_CSR_AWD3_MST = 1UL<<9, // AWD3_MST
	ADC_COMMON_CSR_AWD2_MST = 1UL<<8, // AWD2_MST
	ADC_COMMON_CSR_AWD1_MST = 1UL<<7, // AWD1_MST
	ADC_COMMON_CSR_JEOS_MST = 1UL<<6, // JEOS_MST
	ADC_COMMON_CSR_JEOC_MST = 1UL<<5, // JEOC_MST
	ADC_COMMON_CSR_OVR_MST = 1UL<<4, // OVR_MST
	ADC_COMMON_CSR_EOS_MST = 1UL<<3, // EOS_MST
	ADC_COMMON_CSR_EOC_MST = 1UL<<2, // EOC_MST
	ADC_COMMON_CSR_EOSMP_MST = 1UL<<1, // EOSMP_MST
	ADC_COMMON_CSR_ADDRDY_MST = 1UL<<0, // ADDRDY_MST		
};

// ADC_Common->CCR ADC common control register
enum {
	ADC_COMMON_CCR_VBATSEL = 1UL<<24, // VBAT selection
	ADC_COMMON_CCR_VSENSESEL = 1UL<<23, // VTS selection
	ADC_COMMON_CCR_VREFEN = 1UL<<22, // VREFINT enable
	ADC_COMMON_CCR_PRESC = ((1UL<<4)-1) << 18, // ADC prescaler
	ADC_COMMON_CCR_CKMODE = ((1UL<<2)-1) << 16, // ADC clock mode
	ADC_COMMON_CCR_MDMA = ((1UL<<2)-1) << 14, // Direct memory access mode for multi ADC mode
	ADC_COMMON_CCR_DMACFG = 1UL<<13, // DMA configuration (for multi-ADC mode)
	ADC_COMMON_CCR_DELAY = ((1UL<<4)-1) << 8, // Delay between 2 sampling phases
	ADC_COMMON_CCR_DUAL = ((1UL<<5)-1) << 0, // Dual ADC mode selection		
};
static inline void adc_common_ccr_set_presc(struct ADC_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC_COMMON_CCR_PRESC) | ((val<<18) & ADC_COMMON_CCR_PRESC); }
static inline void adc_common_ccr_set_ckmode(struct ADC_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC_COMMON_CCR_CKMODE) | ((val<<16) & ADC_COMMON_CCR_CKMODE); }
static inline void adc_common_ccr_set_mdma(struct ADC_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC_COMMON_CCR_MDMA) | ((val<<14) & ADC_COMMON_CCR_MDMA); }
static inline void adc_common_ccr_set_delay(struct ADC_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC_COMMON_CCR_DELAY) | ((val<<8) & ADC_COMMON_CCR_DELAY); }
static inline void adc_common_ccr_set_dual(struct ADC_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC_COMMON_CCR_DUAL) | ((val<<0) & ADC_COMMON_CCR_DUAL); }
static inline uint32_t adc_common_ccr_get_presc(struct ADC_Common_Type* p) { return (p->CCR & ADC_COMMON_CCR_PRESC) >> 18 ; }
static inline uint32_t adc_common_ccr_get_ckmode(struct ADC_Common_Type* p) { return (p->CCR & ADC_COMMON_CCR_CKMODE) >> 16 ; }
static inline uint32_t adc_common_ccr_get_mdma(struct ADC_Common_Type* p) { return (p->CCR & ADC_COMMON_CCR_MDMA) >> 14 ; }
static inline uint32_t adc_common_ccr_get_delay(struct ADC_Common_Type* p) { return (p->CCR & ADC_COMMON_CCR_DELAY) >> 8 ; }
static inline uint32_t adc_common_ccr_get_dual(struct ADC_Common_Type* p) { return (p->CCR & ADC_COMMON_CCR_DUAL) >> 0 ; }

// ADC_Common->CDR ADC common regular data register for dual and triple modes
enum {
	ADC_COMMON_CDR_RDATA_SLV = ((1UL<<16)-1) << 16, // Regular data of the slave ADC
	ADC_COMMON_CDR_RDATA_MST = ((1UL<<16)-1) << 0, // Regular data of the master ADC		
};
static inline uint32_t adc_common_cdr_get_rdata_slv(struct ADC_Common_Type* p) { return (p->CDR & ADC_COMMON_CDR_RDATA_SLV) >> 16 ; }
static inline uint32_t adc_common_cdr_get_rdata_mst(struct ADC_Common_Type* p) { return (p->CDR & ADC_COMMON_CDR_RDATA_MST) >> 0 ; }


/* Analog-to-Digital Converter */
struct ADC3_Type {
	__IO uint32_t ISR; // @0 interrupt and status register
	__IO uint32_t IER; // @4 interrupt enable register
	__IO uint32_t CR; // @8 control register
	__IO uint32_t CFGR; // @12 configuration register
	__IO uint32_t CFGR2; // @16 configuration register
	__IO uint32_t SMPR1; // @20 sample time register 1
	__IO uint32_t SMPR2; // @24 sample time register 2
	 uint8_t RESERVED0[4]; // @28 
	__IO uint32_t TR1; // @32 watchdog threshold register 1
	__IO uint32_t TR2; // @36 watchdog threshold register
	__IO uint32_t TR3; // @40 watchdog threshold register 3
	 uint8_t RESERVED1[4]; // @44 
	__IO uint32_t SQR1; // @48 regular sequence register 1
	__IO uint32_t SQR2; // @52 regular sequence register 2
	__IO uint32_t SQR3; // @56 regular sequence register 3
	__IO uint32_t SQR4; // @60 regular sequence register 4
	__I uint32_t DR; // @64 regular Data Register
	 uint8_t RESERVED2[8]; // @68 
	__IO uint32_t JSQR; // @76 injected sequence register
	 uint8_t RESERVED3[16]; // @80 
	__IO uint32_t OFR1; // @96 offset register 1
	__IO uint32_t OFR2; // @100 offset register 2
	__IO uint32_t OFR3; // @104 offset register 3
	__IO uint32_t OFR4; // @108 offset register 4
	 uint8_t RESERVED4[16]; // @112 
	__I uint32_t JDR1; // @128 injected data register 1
	__I uint32_t JDR2; // @132 injected data register 2
	__I uint32_t JDR3; // @136 injected data register 3
	__I uint32_t JDR4; // @140 injected data register 4
	 uint8_t RESERVED5[16]; // @144 
	__IO uint32_t AWD2CR; // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR; // @164 Analog Watchdog 3 Configuration Register
	 uint8_t RESERVED6[8]; // @168 
	__IO uint32_t DIFSEL; // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT; // @180 Calibration Factors
	 uint8_t RESERVED7[8]; // @184 
	__IO uint32_t GCOMP; // @192 Gain compensation Register
};
extern struct ADC3_Type	ADC3;	// @0x50000400 
extern struct ADC3_Type 	ADC5;	// @0x50000600

// ADC3->ISR interrupt and status register
enum {
	ADC3_ISR_JQOVF = 1UL<<10, // JQOVF
	ADC3_ISR_AWD3 = 1UL<<9, // AWD3
	ADC3_ISR_AWD2 = 1UL<<8, // AWD2
	ADC3_ISR_AWD1 = 1UL<<7, // AWD1
	ADC3_ISR_JEOS = 1UL<<6, // JEOS
	ADC3_ISR_JEOC = 1UL<<5, // JEOC
	ADC3_ISR_OVR = 1UL<<4, // OVR
	ADC3_ISR_EOS = 1UL<<3, // EOS
	ADC3_ISR_EOC = 1UL<<2, // EOC
	ADC3_ISR_EOSMP = 1UL<<1, // EOSMP
	ADC3_ISR_ADRDY = 1UL<<0, // ADRDY		
};

// ADC3->IER interrupt enable register
enum {
	ADC3_IER_JQOVFIE = 1UL<<10, // JQOVFIE
	ADC3_IER_AWD3IE = 1UL<<9, // AWD3IE
	ADC3_IER_AWD2IE = 1UL<<8, // AWD2IE
	ADC3_IER_AWD1IE = 1UL<<7, // AWD1IE
	ADC3_IER_JEOSIE = 1UL<<6, // JEOSIE
	ADC3_IER_JEOCIE = 1UL<<5, // JEOCIE
	ADC3_IER_OVRIE = 1UL<<4, // OVRIE
	ADC3_IER_EOSIE = 1UL<<3, // EOSIE
	ADC3_IER_EOCIE = 1UL<<2, // EOCIE
	ADC3_IER_EOSMPIE = 1UL<<1, // EOSMPIE
	ADC3_IER_ADRDYIE = 1UL<<0, // ADRDYIE		
};

// ADC3->CR control register
enum {
	ADC3_CR_ADCAL = 1UL<<31, // ADCAL
	ADC3_CR_ADCALDIF = 1UL<<30, // ADCALDIF
	ADC3_CR_DEEPPWD = 1UL<<29, // DEEPPWD
	ADC3_CR_ADVREGEN = 1UL<<28, // ADVREGEN
	ADC3_CR_JADSTP = 1UL<<5, // JADSTP
	ADC3_CR_ADSTP = 1UL<<4, // ADSTP
	ADC3_CR_JADSTART = 1UL<<3, // JADSTART
	ADC3_CR_ADSTART = 1UL<<2, // ADSTART
	ADC3_CR_ADDIS = 1UL<<1, // ADDIS
	ADC3_CR_ADEN = 1UL<<0, // ADEN		
};

// ADC3->CFGR configuration register
enum {
	ADC3_CFGR_JQDIS = 1UL<<31, // Injected Queue disable
	ADC3_CFGR_AWDCH1CH = ((1UL<<5)-1) << 26, // AWDCH1CH
	ADC3_CFGR_JAUTO = 1UL<<25, // JAUTO
	ADC3_CFGR_JAWD1EN = 1UL<<24, // JAWD1EN
	ADC3_CFGR_AWD1EN = 1UL<<23, // AWD1EN
	ADC3_CFGR_AWD1SGL = 1UL<<22, // AWD1SGL
	ADC3_CFGR_JQM = 1UL<<21, // JQM
	ADC3_CFGR_JDISCEN = 1UL<<20, // JDISCEN
	ADC3_CFGR_DISCNUM = ((1UL<<3)-1) << 17, // DISCNUM
	ADC3_CFGR_DISCEN = 1UL<<16, // DISCEN
	ADC3_CFGR_ALIGN = 1UL<<15, // ALIGN
	ADC3_CFGR_AUTDLY = 1UL<<14, // AUTDLY
	ADC3_CFGR_CONT = 1UL<<13, // CONT
	ADC3_CFGR_OVRMOD = 1UL<<12, // OVRMOD
	ADC3_CFGR_EXTEN = ((1UL<<2)-1) << 10, // EXTEN
	ADC3_CFGR_EXTSEL = ((1UL<<4)-1) << 6, // EXTSEL
	ADC3_CFGR_ALIGN_5 = 1UL<<5, // ALIGN_5
	ADC3_CFGR_RES = ((1UL<<2)-1) << 3, // RES
	ADC3_CFGR_DMACFG = 1UL<<1, // DMACFG
	ADC3_CFGR_DMAEN = 1UL<<0, // DMAEN		
};
static inline void adc3_cfgr_set_awdch1ch(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_AWDCH1CH) | ((val<<26) & ADC3_CFGR_AWDCH1CH); }
static inline void adc3_cfgr_set_discnum(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_DISCNUM) | ((val<<17) & ADC3_CFGR_DISCNUM); }
static inline void adc3_cfgr_set_exten(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_EXTEN) | ((val<<10) & ADC3_CFGR_EXTEN); }
static inline void adc3_cfgr_set_extsel(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_EXTSEL) | ((val<<6) & ADC3_CFGR_EXTSEL); }
static inline void adc3_cfgr_set_res(struct ADC3_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC3_CFGR_RES) | ((val<<3) & ADC3_CFGR_RES); }
static inline uint32_t adc3_cfgr_get_awdch1ch(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_AWDCH1CH) >> 26 ; }
static inline uint32_t adc3_cfgr_get_discnum(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_DISCNUM) >> 17 ; }
static inline uint32_t adc3_cfgr_get_exten(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_EXTEN) >> 10 ; }
static inline uint32_t adc3_cfgr_get_extsel(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_EXTSEL) >> 6 ; }
static inline uint32_t adc3_cfgr_get_res(struct ADC3_Type* p) { return (p->CFGR & ADC3_CFGR_RES) >> 3 ; }

// ADC3->CFGR2 configuration register
enum {
	ADC3_CFGR2_SMPTRIG = 1UL<<27, // SMPTRIG
	ADC3_CFGR2_BULB = 1UL<<26, // BULB
	ADC3_CFGR2_SWTRIG = 1UL<<25, // SWTRIG
	ADC3_CFGR2_GCOMP = 1UL<<16, // GCOMP
	ADC3_CFGR2_ROVSM = 1UL<<10, // EXTEN
	ADC3_CFGR2_TROVS = 1UL<<9, // Triggered Regular Oversampling
	ADC3_CFGR2_OVSS = ((1UL<<4)-1) << 5, // ALIGN
	ADC3_CFGR2_OVSR = ((1UL<<3)-1) << 2, // RES
	ADC3_CFGR2_JOVSE = 1UL<<1, // DMACFG
	ADC3_CFGR2_ROVSE = 1UL<<0, // DMAEN		
};
static inline void adc3_cfgr2_set_ovss(struct ADC3_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_OVSS) | ((val<<5) & ADC3_CFGR2_OVSS); }
static inline void adc3_cfgr2_set_ovsr(struct ADC3_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC3_CFGR2_OVSR) | ((val<<2) & ADC3_CFGR2_OVSR); }
static inline uint32_t adc3_cfgr2_get_ovss(struct ADC3_Type* p) { return (p->CFGR2 & ADC3_CFGR2_OVSS) >> 5 ; }
static inline uint32_t adc3_cfgr2_get_ovsr(struct ADC3_Type* p) { return (p->CFGR2 & ADC3_CFGR2_OVSR) >> 2 ; }

// ADC3->SMPR1 sample time register 1
enum {
	ADC3_SMPR1_SMPPLUS = 1UL<<31, // Addition of one clock cycle to the sampling time
	ADC3_SMPR1_SMP9 = ((1UL<<3)-1) << 27, // SMP9
	ADC3_SMPR1_SMP8 = ((1UL<<3)-1) << 24, // SMP8
	ADC3_SMPR1_SMP7 = ((1UL<<3)-1) << 21, // SMP7
	ADC3_SMPR1_SMP6 = ((1UL<<3)-1) << 18, // SMP6
	ADC3_SMPR1_SMP5 = ((1UL<<3)-1) << 15, // SMP5
	ADC3_SMPR1_SMP4 = ((1UL<<3)-1) << 12, // SMP4
	ADC3_SMPR1_SMP3 = ((1UL<<3)-1) << 9, // SMP3
	ADC3_SMPR1_SMP2 = ((1UL<<3)-1) << 6, // SMP2
	ADC3_SMPR1_SMP1 = ((1UL<<3)-1) << 3, // SMP1
	ADC3_SMPR1_SMP0 = ((1UL<<3)-1) << 0, // SMP0		
};
static inline void adc3_smpr1_set_smp9(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP9) | ((val<<27) & ADC3_SMPR1_SMP9); }
static inline void adc3_smpr1_set_smp8(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP8) | ((val<<24) & ADC3_SMPR1_SMP8); }
static inline void adc3_smpr1_set_smp7(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP7) | ((val<<21) & ADC3_SMPR1_SMP7); }
static inline void adc3_smpr1_set_smp6(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP6) | ((val<<18) & ADC3_SMPR1_SMP6); }
static inline void adc3_smpr1_set_smp5(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP5) | ((val<<15) & ADC3_SMPR1_SMP5); }
static inline void adc3_smpr1_set_smp4(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP4) | ((val<<12) & ADC3_SMPR1_SMP4); }
static inline void adc3_smpr1_set_smp3(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP3) | ((val<<9) & ADC3_SMPR1_SMP3); }
static inline void adc3_smpr1_set_smp2(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP2) | ((val<<6) & ADC3_SMPR1_SMP2); }
static inline void adc3_smpr1_set_smp1(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP1) | ((val<<3) & ADC3_SMPR1_SMP1); }
static inline void adc3_smpr1_set_smp0(struct ADC3_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC3_SMPR1_SMP0) | ((val<<0) & ADC3_SMPR1_SMP0); }
static inline uint32_t adc3_smpr1_get_smp9(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP9) >> 27 ; }
static inline uint32_t adc3_smpr1_get_smp8(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP8) >> 24 ; }
static inline uint32_t adc3_smpr1_get_smp7(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP7) >> 21 ; }
static inline uint32_t adc3_smpr1_get_smp6(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP6) >> 18 ; }
static inline uint32_t adc3_smpr1_get_smp5(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP5) >> 15 ; }
static inline uint32_t adc3_smpr1_get_smp4(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP4) >> 12 ; }
static inline uint32_t adc3_smpr1_get_smp3(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP3) >> 9 ; }
static inline uint32_t adc3_smpr1_get_smp2(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP2) >> 6 ; }
static inline uint32_t adc3_smpr1_get_smp1(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP1) >> 3 ; }
static inline uint32_t adc3_smpr1_get_smp0(struct ADC3_Type* p) { return (p->SMPR1 & ADC3_SMPR1_SMP0) >> 0 ; }

// ADC3->SMPR2 sample time register 2
enum {
	ADC3_SMPR2_SMP18 = ((1UL<<3)-1) << 24, // SMP18
	ADC3_SMPR2_SMP17 = ((1UL<<3)-1) << 21, // SMP17
	ADC3_SMPR2_SMP16 = ((1UL<<3)-1) << 18, // SMP16
	ADC3_SMPR2_SMP15 = ((1UL<<3)-1) << 15, // SMP15
	ADC3_SMPR2_SMP14 = ((1UL<<3)-1) << 12, // SMP14
	ADC3_SMPR2_SMP13 = ((1UL<<3)-1) << 9, // SMP13
	ADC3_SMPR2_SMP12 = ((1UL<<3)-1) << 6, // SMP12
	ADC3_SMPR2_SMP11 = ((1UL<<3)-1) << 3, // SMP11
	ADC3_SMPR2_SMP10 = ((1UL<<3)-1) << 0, // SMP10		
};
static inline void adc3_smpr2_set_smp18(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP18) | ((val<<24) & ADC3_SMPR2_SMP18); }
static inline void adc3_smpr2_set_smp17(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP17) | ((val<<21) & ADC3_SMPR2_SMP17); }
static inline void adc3_smpr2_set_smp16(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP16) | ((val<<18) & ADC3_SMPR2_SMP16); }
static inline void adc3_smpr2_set_smp15(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP15) | ((val<<15) & ADC3_SMPR2_SMP15); }
static inline void adc3_smpr2_set_smp14(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP14) | ((val<<12) & ADC3_SMPR2_SMP14); }
static inline void adc3_smpr2_set_smp13(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP13) | ((val<<9) & ADC3_SMPR2_SMP13); }
static inline void adc3_smpr2_set_smp12(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP12) | ((val<<6) & ADC3_SMPR2_SMP12); }
static inline void adc3_smpr2_set_smp11(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP11) | ((val<<3) & ADC3_SMPR2_SMP11); }
static inline void adc3_smpr2_set_smp10(struct ADC3_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC3_SMPR2_SMP10) | ((val<<0) & ADC3_SMPR2_SMP10); }
static inline uint32_t adc3_smpr2_get_smp18(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP18) >> 24 ; }
static inline uint32_t adc3_smpr2_get_smp17(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP17) >> 21 ; }
static inline uint32_t adc3_smpr2_get_smp16(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP16) >> 18 ; }
static inline uint32_t adc3_smpr2_get_smp15(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP15) >> 15 ; }
static inline uint32_t adc3_smpr2_get_smp14(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP14) >> 12 ; }
static inline uint32_t adc3_smpr2_get_smp13(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP13) >> 9 ; }
static inline uint32_t adc3_smpr2_get_smp12(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP12) >> 6 ; }
static inline uint32_t adc3_smpr2_get_smp11(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP11) >> 3 ; }
static inline uint32_t adc3_smpr2_get_smp10(struct ADC3_Type* p) { return (p->SMPR2 & ADC3_SMPR2_SMP10) >> 0 ; }

// ADC3->TR1 watchdog threshold register 1
enum {
	ADC3_TR1_HT1 = ((1UL<<12)-1) << 16, // HT1
	ADC3_TR1_AWDFILT = ((1UL<<3)-1) << 12, // AWDFILT
	ADC3_TR1_LT1 = ((1UL<<12)-1) << 0, // LT1		
};
static inline void adc3_tr1_set_ht1(struct ADC3_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC3_TR1_HT1) | ((val<<16) & ADC3_TR1_HT1); }
static inline void adc3_tr1_set_awdfilt(struct ADC3_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC3_TR1_AWDFILT) | ((val<<12) & ADC3_TR1_AWDFILT); }
static inline void adc3_tr1_set_lt1(struct ADC3_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC3_TR1_LT1) | ((val<<0) & ADC3_TR1_LT1); }
static inline uint32_t adc3_tr1_get_ht1(struct ADC3_Type* p) { return (p->TR1 & ADC3_TR1_HT1) >> 16 ; }
static inline uint32_t adc3_tr1_get_awdfilt(struct ADC3_Type* p) { return (p->TR1 & ADC3_TR1_AWDFILT) >> 12 ; }
static inline uint32_t adc3_tr1_get_lt1(struct ADC3_Type* p) { return (p->TR1 & ADC3_TR1_LT1) >> 0 ; }

// ADC3->TR2 watchdog threshold register
enum {
	ADC3_TR2_HT2 = ((1UL<<8)-1) << 16, // HT2
	ADC3_TR2_LT2 = ((1UL<<8)-1) << 0, // LT2		
};
static inline void adc3_tr2_set_ht2(struct ADC3_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC3_TR2_HT2) | ((val<<16) & ADC3_TR2_HT2); }
static inline void adc3_tr2_set_lt2(struct ADC3_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC3_TR2_LT2) | ((val<<0) & ADC3_TR2_LT2); }
static inline uint32_t adc3_tr2_get_ht2(struct ADC3_Type* p) { return (p->TR2 & ADC3_TR2_HT2) >> 16 ; }
static inline uint32_t adc3_tr2_get_lt2(struct ADC3_Type* p) { return (p->TR2 & ADC3_TR2_LT2) >> 0 ; }

// ADC3->TR3 watchdog threshold register 3
enum {
	ADC3_TR3_HT3 = ((1UL<<8)-1) << 16, // HT3
	ADC3_TR3_LT3 = ((1UL<<8)-1) << 0, // LT3		
};
static inline void adc3_tr3_set_ht3(struct ADC3_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC3_TR3_HT3) | ((val<<16) & ADC3_TR3_HT3); }
static inline void adc3_tr3_set_lt3(struct ADC3_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC3_TR3_LT3) | ((val<<0) & ADC3_TR3_LT3); }
static inline uint32_t adc3_tr3_get_ht3(struct ADC3_Type* p) { return (p->TR3 & ADC3_TR3_HT3) >> 16 ; }
static inline uint32_t adc3_tr3_get_lt3(struct ADC3_Type* p) { return (p->TR3 & ADC3_TR3_LT3) >> 0 ; }

// ADC3->SQR1 regular sequence register 1
enum {
	ADC3_SQR1_SQ4 = ((1UL<<5)-1) << 24, // SQ4
	ADC3_SQR1_SQ3 = ((1UL<<5)-1) << 18, // SQ3
	ADC3_SQR1_SQ2 = ((1UL<<5)-1) << 12, // SQ2
	ADC3_SQR1_SQ1 = ((1UL<<5)-1) << 6, // SQ1
	ADC3_SQR1_L = ((1UL<<4)-1) << 0, // Regular channel sequence length		
};
static inline void adc3_sqr1_set_sq4(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ4) | ((val<<24) & ADC3_SQR1_SQ4); }
static inline void adc3_sqr1_set_sq3(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ3) | ((val<<18) & ADC3_SQR1_SQ3); }
static inline void adc3_sqr1_set_sq2(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ2) | ((val<<12) & ADC3_SQR1_SQ2); }
static inline void adc3_sqr1_set_sq1(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_SQ1) | ((val<<6) & ADC3_SQR1_SQ1); }
static inline void adc3_sqr1_set_l(struct ADC3_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC3_SQR1_L) | ((val<<0) & ADC3_SQR1_L); }
static inline uint32_t adc3_sqr1_get_sq4(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ4) >> 24 ; }
static inline uint32_t adc3_sqr1_get_sq3(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ3) >> 18 ; }
static inline uint32_t adc3_sqr1_get_sq2(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ2) >> 12 ; }
static inline uint32_t adc3_sqr1_get_sq1(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_SQ1) >> 6 ; }
static inline uint32_t adc3_sqr1_get_l(struct ADC3_Type* p) { return (p->SQR1 & ADC3_SQR1_L) >> 0 ; }

// ADC3->SQR2 regular sequence register 2
enum {
	ADC3_SQR2_SQ9 = ((1UL<<5)-1) << 24, // SQ9
	ADC3_SQR2_SQ8 = ((1UL<<5)-1) << 18, // SQ8
	ADC3_SQR2_SQ7 = ((1UL<<5)-1) << 12, // SQ7
	ADC3_SQR2_SQ6 = ((1UL<<5)-1) << 6, // SQ6
	ADC3_SQR2_SQ5 = ((1UL<<5)-1) << 0, // SQ5		
};
static inline void adc3_sqr2_set_sq9(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ9) | ((val<<24) & ADC3_SQR2_SQ9); }
static inline void adc3_sqr2_set_sq8(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ8) | ((val<<18) & ADC3_SQR2_SQ8); }
static inline void adc3_sqr2_set_sq7(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ7) | ((val<<12) & ADC3_SQR2_SQ7); }
static inline void adc3_sqr2_set_sq6(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ6) | ((val<<6) & ADC3_SQR2_SQ6); }
static inline void adc3_sqr2_set_sq5(struct ADC3_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC3_SQR2_SQ5) | ((val<<0) & ADC3_SQR2_SQ5); }
static inline uint32_t adc3_sqr2_get_sq9(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ9) >> 24 ; }
static inline uint32_t adc3_sqr2_get_sq8(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ8) >> 18 ; }
static inline uint32_t adc3_sqr2_get_sq7(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ7) >> 12 ; }
static inline uint32_t adc3_sqr2_get_sq6(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ6) >> 6 ; }
static inline uint32_t adc3_sqr2_get_sq5(struct ADC3_Type* p) { return (p->SQR2 & ADC3_SQR2_SQ5) >> 0 ; }

// ADC3->SQR3 regular sequence register 3
enum {
	ADC3_SQR3_SQ14 = ((1UL<<5)-1) << 24, // SQ14
	ADC3_SQR3_SQ13 = ((1UL<<5)-1) << 18, // SQ13
	ADC3_SQR3_SQ12 = ((1UL<<5)-1) << 12, // SQ12
	ADC3_SQR3_SQ11 = ((1UL<<5)-1) << 6, // SQ11
	ADC3_SQR3_SQ10 = ((1UL<<5)-1) << 0, // SQ10		
};
static inline void adc3_sqr3_set_sq14(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ14) | ((val<<24) & ADC3_SQR3_SQ14); }
static inline void adc3_sqr3_set_sq13(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ13) | ((val<<18) & ADC3_SQR3_SQ13); }
static inline void adc3_sqr3_set_sq12(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ12) | ((val<<12) & ADC3_SQR3_SQ12); }
static inline void adc3_sqr3_set_sq11(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ11) | ((val<<6) & ADC3_SQR3_SQ11); }
static inline void adc3_sqr3_set_sq10(struct ADC3_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC3_SQR3_SQ10) | ((val<<0) & ADC3_SQR3_SQ10); }
static inline uint32_t adc3_sqr3_get_sq14(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ14) >> 24 ; }
static inline uint32_t adc3_sqr3_get_sq13(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ13) >> 18 ; }
static inline uint32_t adc3_sqr3_get_sq12(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ12) >> 12 ; }
static inline uint32_t adc3_sqr3_get_sq11(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ11) >> 6 ; }
static inline uint32_t adc3_sqr3_get_sq10(struct ADC3_Type* p) { return (p->SQR3 & ADC3_SQR3_SQ10) >> 0 ; }

// ADC3->SQR4 regular sequence register 4
enum {
	ADC3_SQR4_SQ16 = ((1UL<<5)-1) << 6, // SQ16
	ADC3_SQR4_SQ15 = ((1UL<<5)-1) << 0, // SQ15		
};
static inline void adc3_sqr4_set_sq16(struct ADC3_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC3_SQR4_SQ16) | ((val<<6) & ADC3_SQR4_SQ16); }
static inline void adc3_sqr4_set_sq15(struct ADC3_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC3_SQR4_SQ15) | ((val<<0) & ADC3_SQR4_SQ15); }
static inline uint32_t adc3_sqr4_get_sq16(struct ADC3_Type* p) { return (p->SQR4 & ADC3_SQR4_SQ16) >> 6 ; }
static inline uint32_t adc3_sqr4_get_sq15(struct ADC3_Type* p) { return (p->SQR4 & ADC3_SQR4_SQ15) >> 0 ; }

// ADC3->DR regular Data Register
enum {
	ADC3_DR_RDATA = ((1UL<<16)-1) << 0, // Regular Data converted		
};
static inline uint32_t adc3_dr_get_rdata(struct ADC3_Type* p) { return (p->DR & ADC3_DR_RDATA) >> 0 ; }

// ADC3->JSQR injected sequence register
enum {
	ADC3_JSQR_JSQ4 = ((1UL<<5)-1) << 27, // JSQ4
	ADC3_JSQR_JSQ3 = ((1UL<<5)-1) << 21, // JSQ3
	ADC3_JSQR_JSQ2 = ((1UL<<5)-1) << 15, // JSQ2
	ADC3_JSQR_JSQ1 = ((1UL<<5)-1) << 9, // JSQ1
	ADC3_JSQR_JEXTEN = ((1UL<<2)-1) << 7, // JEXTEN
	ADC3_JSQR_JEXTSEL = ((1UL<<5)-1) << 2, // JEXTSEL
	ADC3_JSQR_JL = ((1UL<<2)-1) << 0, // JL		
};
static inline void adc3_jsqr_set_jsq4(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ4) | ((val<<27) & ADC3_JSQR_JSQ4); }
static inline void adc3_jsqr_set_jsq3(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ3) | ((val<<21) & ADC3_JSQR_JSQ3); }
static inline void adc3_jsqr_set_jsq2(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ2) | ((val<<15) & ADC3_JSQR_JSQ2); }
static inline void adc3_jsqr_set_jsq1(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JSQ1) | ((val<<9) & ADC3_JSQR_JSQ1); }
static inline void adc3_jsqr_set_jexten(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JEXTEN) | ((val<<7) & ADC3_JSQR_JEXTEN); }
static inline void adc3_jsqr_set_jextsel(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JEXTSEL) | ((val<<2) & ADC3_JSQR_JEXTSEL); }
static inline void adc3_jsqr_set_jl(struct ADC3_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC3_JSQR_JL) | ((val<<0) & ADC3_JSQR_JL); }
static inline uint32_t adc3_jsqr_get_jsq4(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ4) >> 27 ; }
static inline uint32_t adc3_jsqr_get_jsq3(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ3) >> 21 ; }
static inline uint32_t adc3_jsqr_get_jsq2(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ2) >> 15 ; }
static inline uint32_t adc3_jsqr_get_jsq1(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JSQ1) >> 9 ; }
static inline uint32_t adc3_jsqr_get_jexten(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JEXTEN) >> 7 ; }
static inline uint32_t adc3_jsqr_get_jextsel(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JEXTSEL) >> 2 ; }
static inline uint32_t adc3_jsqr_get_jl(struct ADC3_Type* p) { return (p->JSQR & ADC3_JSQR_JL) >> 0 ; }

// ADC3->OFR1 offset register 1
enum {
	ADC3_OFR1_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC3_OFR1_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC3_OFR1_SATEN = 1UL<<25, // SATEN
	ADC3_OFR1_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC3_OFR1_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc3_ofr1_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC3_OFR1_OFFSET1_CH) | ((val<<26) & ADC3_OFR1_OFFSET1_CH); }
static inline void adc3_ofr1_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC3_OFR1_OFFSET1) | ((val<<0) & ADC3_OFR1_OFFSET1); }
static inline uint32_t adc3_ofr1_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR1 & ADC3_OFR1_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc3_ofr1_get_offset1(struct ADC3_Type* p) { return (p->OFR1 & ADC3_OFR1_OFFSET1) >> 0 ; }

// ADC3->OFR2 offset register 2
enum {
	ADC3_OFR2_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC3_OFR2_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC3_OFR2_SATEN = 1UL<<25, // SATEN
	ADC3_OFR2_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC3_OFR2_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc3_ofr2_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC3_OFR2_OFFSET1_CH) | ((val<<26) & ADC3_OFR2_OFFSET1_CH); }
static inline void adc3_ofr2_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC3_OFR2_OFFSET1) | ((val<<0) & ADC3_OFR2_OFFSET1); }
static inline uint32_t adc3_ofr2_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR2 & ADC3_OFR2_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc3_ofr2_get_offset1(struct ADC3_Type* p) { return (p->OFR2 & ADC3_OFR2_OFFSET1) >> 0 ; }

// ADC3->OFR3 offset register 3
enum {
	ADC3_OFR3_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC3_OFR3_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC3_OFR3_SATEN = 1UL<<25, // SATEN
	ADC3_OFR3_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC3_OFR3_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc3_ofr3_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC3_OFR3_OFFSET1_CH) | ((val<<26) & ADC3_OFR3_OFFSET1_CH); }
static inline void adc3_ofr3_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC3_OFR3_OFFSET1) | ((val<<0) & ADC3_OFR3_OFFSET1); }
static inline uint32_t adc3_ofr3_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR3 & ADC3_OFR3_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc3_ofr3_get_offset1(struct ADC3_Type* p) { return (p->OFR3 & ADC3_OFR3_OFFSET1) >> 0 ; }

// ADC3->OFR4 offset register 4
enum {
	ADC3_OFR4_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC3_OFR4_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC3_OFR4_SATEN = 1UL<<25, // SATEN
	ADC3_OFR4_OFFSETPOS = 1UL<<24, // OFFSETPOS
	ADC3_OFR4_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc3_ofr4_set_offset1_ch(struct ADC3_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC3_OFR4_OFFSET1_CH) | ((val<<26) & ADC3_OFR4_OFFSET1_CH); }
static inline void adc3_ofr4_set_offset1(struct ADC3_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC3_OFR4_OFFSET1) | ((val<<0) & ADC3_OFR4_OFFSET1); }
static inline uint32_t adc3_ofr4_get_offset1_ch(struct ADC3_Type* p) { return (p->OFR4 & ADC3_OFR4_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc3_ofr4_get_offset1(struct ADC3_Type* p) { return (p->OFR4 & ADC3_OFR4_OFFSET1) >> 0 ; }

// ADC3->JDR1 injected data register 1
enum {
	ADC3_JDR1_JDATA1 = ((1UL<<16)-1) << 0, // JDATA1		
};
static inline uint32_t adc3_jdr1_get_jdata1(struct ADC3_Type* p) { return (p->JDR1 & ADC3_JDR1_JDATA1) >> 0 ; }

// ADC3->JDR2 injected data register 2
enum {
	ADC3_JDR2_JDATA2 = ((1UL<<16)-1) << 0, // JDATA2		
};
static inline uint32_t adc3_jdr2_get_jdata2(struct ADC3_Type* p) { return (p->JDR2 & ADC3_JDR2_JDATA2) >> 0 ; }

// ADC3->JDR3 injected data register 3
enum {
	ADC3_JDR3_JDATA3 = ((1UL<<16)-1) << 0, // JDATA3		
};
static inline uint32_t adc3_jdr3_get_jdata3(struct ADC3_Type* p) { return (p->JDR3 & ADC3_JDR3_JDATA3) >> 0 ; }

// ADC3->JDR4 injected data register 4
enum {
	ADC3_JDR4_JDATA4 = ((1UL<<16)-1) << 0, // JDATA4		
};
static inline uint32_t adc3_jdr4_get_jdata4(struct ADC3_Type* p) { return (p->JDR4 & ADC3_JDR4_JDATA4) >> 0 ; }

// ADC3->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC3_AWD2CR_AWD2CH = ((1UL<<19)-1) << 0, // AWD2CH		
};
static inline void adc3_awd2cr_set_awd2ch(struct ADC3_Type* p, uint32_t val) { p->AWD2CR = (p->AWD2CR & ~ADC3_AWD2CR_AWD2CH) | ((val<<0) & ADC3_AWD2CR_AWD2CH); }
static inline uint32_t adc3_awd2cr_get_awd2ch(struct ADC3_Type* p) { return (p->AWD2CR & ADC3_AWD2CR_AWD2CH) >> 0 ; }

// ADC3->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC3_AWD3CR_AWD3CH = ((1UL<<19)-1) << 0, // AWD3CH		
};
static inline void adc3_awd3cr_set_awd3ch(struct ADC3_Type* p, uint32_t val) { p->AWD3CR = (p->AWD3CR & ~ADC3_AWD3CR_AWD3CH) | ((val<<0) & ADC3_AWD3CR_AWD3CH); }
static inline uint32_t adc3_awd3cr_get_awd3ch(struct ADC3_Type* p) { return (p->AWD3CR & ADC3_AWD3CR_AWD3CH) >> 0 ; }

// ADC3->DIFSEL Differential Mode Selection Register 2
enum {
	ADC3_DIFSEL_DIFSEL_1_18 = ((1UL<<18)-1) << 1, // Differential mode for channels 15 to 1
	ADC3_DIFSEL_DIFSEL_0 = 1UL<<0, // Differential mode for channels 0		
};
static inline void adc3_difsel_set_difsel_1_18(struct ADC3_Type* p, uint32_t val) { p->DIFSEL = (p->DIFSEL & ~ADC3_DIFSEL_DIFSEL_1_18) | ((val<<1) & ADC3_DIFSEL_DIFSEL_1_18); }
static inline uint32_t adc3_difsel_get_difsel_1_18(struct ADC3_Type* p) { return (p->DIFSEL & ADC3_DIFSEL_DIFSEL_1_18) >> 1 ; }

// ADC3->CALFACT Calibration Factors
enum {
	ADC3_CALFACT_CALFACT_D = ((1UL<<7)-1) << 16, // CALFACT_D
	ADC3_CALFACT_CALFACT_S = ((1UL<<7)-1) << 0, // CALFACT_S		
};
static inline void adc3_calfact_set_calfact_d(struct ADC3_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC3_CALFACT_CALFACT_D) | ((val<<16) & ADC3_CALFACT_CALFACT_D); }
static inline void adc3_calfact_set_calfact_s(struct ADC3_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC3_CALFACT_CALFACT_S) | ((val<<0) & ADC3_CALFACT_CALFACT_S); }
static inline uint32_t adc3_calfact_get_calfact_d(struct ADC3_Type* p) { return (p->CALFACT & ADC3_CALFACT_CALFACT_D) >> 16 ; }
static inline uint32_t adc3_calfact_get_calfact_s(struct ADC3_Type* p) { return (p->CALFACT & ADC3_CALFACT_CALFACT_S) >> 0 ; }

// ADC3->GCOMP Gain compensation Register
enum {
	ADC3_GCOMP_GCOMPCOEFF = ((1UL<<14)-1) << 0, // GCOMPCOEFF		
};
static inline void adc3_gcomp_set_gcompcoeff(struct ADC3_Type* p, uint32_t val) { p->GCOMP = (p->GCOMP & ~ADC3_GCOMP_GCOMPCOEFF) | ((val<<0) & ADC3_GCOMP_GCOMPCOEFF); }
static inline uint32_t adc3_gcomp_get_gcompcoeff(struct ADC3_Type* p) { return (p->GCOMP & ADC3_GCOMP_GCOMPCOEFF) >> 0 ; }




/* Comparator control and status register
There is only one peripheral of type COMP. */
struct COMP_Type {
	__IO uint32_t C1CSR; // @0 Comparator control/status register
	__IO uint32_t C2CSR; // @4 Comparator control/status register
	__IO uint32_t C3CSR; // @8 Comparator control/status register
	__IO uint32_t C4CSR; // @12 Comparator control/status register
	__IO uint32_t C5CSR; // @16 Comparator control/status register
	__IO uint32_t C6CSR; // @20 Comparator control/status register
	__IO uint32_t C7CSR; // @24 Comparator control/status register
};
extern struct COMP_Type	COMP;	// @0x40010200 

// COMP->C1CSR Comparator control/status register
enum {
	COMP_C1CSR_LOCK = 1UL<<31, // LOCK
	COMP_C1CSR_VALUE = 1UL<<30, // VALUE
	COMP_C1CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C1CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C1CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C1CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C1CSR_POL = 1UL<<15, // POL
	COMP_C1CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C1CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C1CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c1csr_set_blanksel(uint32_t val) { COMP.C1CSR = (COMP.C1CSR & ~COMP_C1CSR_BLANKSEL) | ((val<<19) & COMP_C1CSR_BLANKSEL); }
static inline void comp_c1csr_set_hyst(uint32_t val) { COMP.C1CSR = (COMP.C1CSR & ~COMP_C1CSR_HYST) | ((val<<16) & COMP_C1CSR_HYST); }
static inline void comp_c1csr_set_inmsel(uint32_t val) { COMP.C1CSR = (COMP.C1CSR & ~COMP_C1CSR_INMSEL) | ((val<<4) & COMP_C1CSR_INMSEL); }
static inline uint32_t comp_c1csr_get_blanksel(void) { return (COMP.C1CSR & COMP_C1CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c1csr_get_hyst(void) { return (COMP.C1CSR & COMP_C1CSR_HYST) >> 16 ; }
static inline uint32_t comp_c1csr_get_inmsel(void) { return (COMP.C1CSR & COMP_C1CSR_INMSEL) >> 4 ; }

// COMP->C2CSR Comparator control/status register
enum {
	COMP_C2CSR_LOCK = 1UL<<31, // LOCK
	COMP_C2CSR_VALUE = 1UL<<30, // VALUE
	COMP_C2CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C2CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C2CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C2CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C2CSR_POL = 1UL<<15, // POL
	COMP_C2CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C2CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C2CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c2csr_set_blanksel(uint32_t val) { COMP.C2CSR = (COMP.C2CSR & ~COMP_C2CSR_BLANKSEL) | ((val<<19) & COMP_C2CSR_BLANKSEL); }
static inline void comp_c2csr_set_hyst(uint32_t val) { COMP.C2CSR = (COMP.C2CSR & ~COMP_C2CSR_HYST) | ((val<<16) & COMP_C2CSR_HYST); }
static inline void comp_c2csr_set_inmsel(uint32_t val) { COMP.C2CSR = (COMP.C2CSR & ~COMP_C2CSR_INMSEL) | ((val<<4) & COMP_C2CSR_INMSEL); }
static inline uint32_t comp_c2csr_get_blanksel(void) { return (COMP.C2CSR & COMP_C2CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c2csr_get_hyst(void) { return (COMP.C2CSR & COMP_C2CSR_HYST) >> 16 ; }
static inline uint32_t comp_c2csr_get_inmsel(void) { return (COMP.C2CSR & COMP_C2CSR_INMSEL) >> 4 ; }

// COMP->C3CSR Comparator control/status register
enum {
	COMP_C3CSR_LOCK = 1UL<<31, // LOCK
	COMP_C3CSR_VALUE = 1UL<<30, // VALUE
	COMP_C3CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C3CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C3CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C3CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C3CSR_POL = 1UL<<15, // POL
	COMP_C3CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C3CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C3CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c3csr_set_blanksel(uint32_t val) { COMP.C3CSR = (COMP.C3CSR & ~COMP_C3CSR_BLANKSEL) | ((val<<19) & COMP_C3CSR_BLANKSEL); }
static inline void comp_c3csr_set_hyst(uint32_t val) { COMP.C3CSR = (COMP.C3CSR & ~COMP_C3CSR_HYST) | ((val<<16) & COMP_C3CSR_HYST); }
static inline void comp_c3csr_set_inmsel(uint32_t val) { COMP.C3CSR = (COMP.C3CSR & ~COMP_C3CSR_INMSEL) | ((val<<4) & COMP_C3CSR_INMSEL); }
static inline uint32_t comp_c3csr_get_blanksel(void) { return (COMP.C3CSR & COMP_C3CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c3csr_get_hyst(void) { return (COMP.C3CSR & COMP_C3CSR_HYST) >> 16 ; }
static inline uint32_t comp_c3csr_get_inmsel(void) { return (COMP.C3CSR & COMP_C3CSR_INMSEL) >> 4 ; }

// COMP->C4CSR Comparator control/status register
enum {
	COMP_C4CSR_LOCK = 1UL<<31, // LOCK
	COMP_C4CSR_VALUE = 1UL<<30, // VALUE
	COMP_C4CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C4CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C4CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C4CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C4CSR_POL = 1UL<<15, // POL
	COMP_C4CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C4CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C4CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c4csr_set_blanksel(uint32_t val) { COMP.C4CSR = (COMP.C4CSR & ~COMP_C4CSR_BLANKSEL) | ((val<<19) & COMP_C4CSR_BLANKSEL); }
static inline void comp_c4csr_set_hyst(uint32_t val) { COMP.C4CSR = (COMP.C4CSR & ~COMP_C4CSR_HYST) | ((val<<16) & COMP_C4CSR_HYST); }
static inline void comp_c4csr_set_inmsel(uint32_t val) { COMP.C4CSR = (COMP.C4CSR & ~COMP_C4CSR_INMSEL) | ((val<<4) & COMP_C4CSR_INMSEL); }
static inline uint32_t comp_c4csr_get_blanksel(void) { return (COMP.C4CSR & COMP_C4CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c4csr_get_hyst(void) { return (COMP.C4CSR & COMP_C4CSR_HYST) >> 16 ; }
static inline uint32_t comp_c4csr_get_inmsel(void) { return (COMP.C4CSR & COMP_C4CSR_INMSEL) >> 4 ; }

// COMP->C5CSR Comparator control/status register
enum {
	COMP_C5CSR_LOCK = 1UL<<31, // LOCK
	COMP_C5CSR_VALUE = 1UL<<30, // VALUE
	COMP_C5CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C5CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C5CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C5CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C5CSR_POL = 1UL<<15, // POL
	COMP_C5CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C5CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C5CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c5csr_set_blanksel(uint32_t val) { COMP.C5CSR = (COMP.C5CSR & ~COMP_C5CSR_BLANKSEL) | ((val<<19) & COMP_C5CSR_BLANKSEL); }
static inline void comp_c5csr_set_hyst(uint32_t val) { COMP.C5CSR = (COMP.C5CSR & ~COMP_C5CSR_HYST) | ((val<<16) & COMP_C5CSR_HYST); }
static inline void comp_c5csr_set_inmsel(uint32_t val) { COMP.C5CSR = (COMP.C5CSR & ~COMP_C5CSR_INMSEL) | ((val<<4) & COMP_C5CSR_INMSEL); }
static inline uint32_t comp_c5csr_get_blanksel(void) { return (COMP.C5CSR & COMP_C5CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c5csr_get_hyst(void) { return (COMP.C5CSR & COMP_C5CSR_HYST) >> 16 ; }
static inline uint32_t comp_c5csr_get_inmsel(void) { return (COMP.C5CSR & COMP_C5CSR_INMSEL) >> 4 ; }

// COMP->C6CSR Comparator control/status register
enum {
	COMP_C6CSR_LOCK = 1UL<<31, // LOCK
	COMP_C6CSR_VALUE = 1UL<<30, // VALUE
	COMP_C6CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C6CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C6CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C6CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C6CSR_POL = 1UL<<15, // POL
	COMP_C6CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C6CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C6CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c6csr_set_blanksel(uint32_t val) { COMP.C6CSR = (COMP.C6CSR & ~COMP_C6CSR_BLANKSEL) | ((val<<19) & COMP_C6CSR_BLANKSEL); }
static inline void comp_c6csr_set_hyst(uint32_t val) { COMP.C6CSR = (COMP.C6CSR & ~COMP_C6CSR_HYST) | ((val<<16) & COMP_C6CSR_HYST); }
static inline void comp_c6csr_set_inmsel(uint32_t val) { COMP.C6CSR = (COMP.C6CSR & ~COMP_C6CSR_INMSEL) | ((val<<4) & COMP_C6CSR_INMSEL); }
static inline uint32_t comp_c6csr_get_blanksel(void) { return (COMP.C6CSR & COMP_C6CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c6csr_get_hyst(void) { return (COMP.C6CSR & COMP_C6CSR_HYST) >> 16 ; }
static inline uint32_t comp_c6csr_get_inmsel(void) { return (COMP.C6CSR & COMP_C6CSR_INMSEL) >> 4 ; }

// COMP->C7CSR Comparator control/status register
enum {
	COMP_C7CSR_LOCK = 1UL<<31, // LOCK
	COMP_C7CSR_VALUE = 1UL<<30, // VALUE
	COMP_C7CSR_SCALEN = 1UL<<23, // SCALEN
	COMP_C7CSR_BRGEN = 1UL<<22, // BRGEN
	COMP_C7CSR_BLANKSEL = ((1UL<<3)-1) << 19, // BLANKSEL
	COMP_C7CSR_HYST = ((1UL<<3)-1) << 16, // HYST
	COMP_C7CSR_POL = 1UL<<15, // POL
	COMP_C7CSR_INPSEL = 1UL<<8, // INPSEL
	COMP_C7CSR_INMSEL = ((1UL<<3)-1) << 4, // INMSEL
	COMP_C7CSR_EN = 1UL<<0, // EN		
};
static inline void comp_c7csr_set_blanksel(uint32_t val) { COMP.C7CSR = (COMP.C7CSR & ~COMP_C7CSR_BLANKSEL) | ((val<<19) & COMP_C7CSR_BLANKSEL); }
static inline void comp_c7csr_set_hyst(uint32_t val) { COMP.C7CSR = (COMP.C7CSR & ~COMP_C7CSR_HYST) | ((val<<16) & COMP_C7CSR_HYST); }
static inline void comp_c7csr_set_inmsel(uint32_t val) { COMP.C7CSR = (COMP.C7CSR & ~COMP_C7CSR_INMSEL) | ((val<<4) & COMP_C7CSR_INMSEL); }
static inline uint32_t comp_c7csr_get_blanksel(void) { return (COMP.C7CSR & COMP_C7CSR_BLANKSEL) >> 19 ; }
static inline uint32_t comp_c7csr_get_hyst(void) { return (COMP.C7CSR & COMP_C7CSR_HYST) >> 16 ; }
static inline uint32_t comp_c7csr_get_inmsel(void) { return (COMP.C7CSR & COMP_C7CSR_INMSEL) >> 4 ; }

/* CORDIC Co-processor
There is only one peripheral of type CORDIC. */
struct CORDIC_Type {
	__IO uint32_t CSR; // @0 CORDIC Control Status register
	__IO uint32_t WDATA; // @4 FMAC Write Data register
	__I uint32_t RDATA; // @8 FMAC Read Data register
};
extern struct CORDIC_Type	CORDIC;	// @0x40020C00 

// CORDIC->CSR CORDIC Control Status register
enum {
	CORDIC_CSR_RRDY = 1UL<<31, // RRDY
	CORDIC_CSR_ARGSIZE = 1UL<<22, // ARGSIZE
	CORDIC_CSR_RESSIZE = 1UL<<21, // RESSIZE
	CORDIC_CSR_NARGS = 1UL<<20, // NARGS
	CORDIC_CSR_NRES = 1UL<<19, // NRES
	CORDIC_CSR_DMAWEN = 1UL<<18, // DMAWEN
	CORDIC_CSR_DMAREN = 1UL<<17, // DMAREN
	CORDIC_CSR_IEN = 1UL<<16, // IEN
	CORDIC_CSR_SCALE = ((1UL<<3)-1) << 8, // SCALE
	CORDIC_CSR_PRECISION = ((1UL<<4)-1) << 4, // PRECISION
	CORDIC_CSR_FUNC = ((1UL<<4)-1) << 0, // FUNC		
};
static inline void cordic_csr_set_scale(uint32_t val) { CORDIC.CSR = (CORDIC.CSR & ~CORDIC_CSR_SCALE) | ((val<<8) & CORDIC_CSR_SCALE); }
static inline void cordic_csr_set_precision(uint32_t val) { CORDIC.CSR = (CORDIC.CSR & ~CORDIC_CSR_PRECISION) | ((val<<4) & CORDIC_CSR_PRECISION); }
static inline void cordic_csr_set_func(uint32_t val) { CORDIC.CSR = (CORDIC.CSR & ~CORDIC_CSR_FUNC) | ((val<<0) & CORDIC_CSR_FUNC); }
static inline uint32_t cordic_csr_get_scale(void) { return (CORDIC.CSR & CORDIC_CSR_SCALE) >> 8 ; }
static inline uint32_t cordic_csr_get_precision(void) { return (CORDIC.CSR & CORDIC_CSR_PRECISION) >> 4 ; }
static inline uint32_t cordic_csr_get_func(void) { return (CORDIC.CSR & CORDIC_CSR_FUNC) >> 0 ; }

/* Cyclic redundancy check calculation unit
There is only one peripheral of type CRC. */
struct CRC_Type {
	__IO uint32_t DR; // @0 Data register
	__IO uint32_t IDR; // @4 Independent data register
	__IO uint32_t CR; // @8 Control register
	 uint8_t RESERVED0[4]; // @12 
	__IO uint32_t INIT; // @16 Initial CRC value
	__IO uint32_t POL; // @20 polynomial
};
extern struct CRC_Type	CRC;	// @0x40023000 

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT = 1UL<<7, // Reverse output data
	CRC_CR_REV_IN = ((1UL<<2)-1) << 5, // Reverse input data
	CRC_CR_POLYSIZE = ((1UL<<2)-1) << 3, // Polynomial size
	CRC_CR_RESET = 1UL<<0, // RESET bit		
};
static inline void crc_cr_set_rev_in(uint32_t val) { CRC.CR = (CRC.CR & ~CRC_CR_REV_IN) | ((val<<5) & CRC_CR_REV_IN); }
static inline void crc_cr_set_polysize(uint32_t val) { CRC.CR = (CRC.CR & ~CRC_CR_POLYSIZE) | ((val<<3) & CRC_CR_POLYSIZE); }
static inline uint32_t crc_cr_get_rev_in(void) { return (CRC.CR & CRC_CR_REV_IN) >> 5 ; }
static inline uint32_t crc_cr_get_polysize(void) { return (CRC.CR & CRC_CR_POLYSIZE) >> 3 ; }

/* CRS
There is only one peripheral of type CRS. */
struct CRS_Type {
	__IO uint32_t CR; // @0 CRS control register
	__IO uint32_t CFGR; // @4 This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
	__I uint32_t ISR; // @8 CRS interrupt and status register
	__IO uint32_t ICR; // @12 CRS interrupt flag clear register
};
extern struct CRS_Type	CRS;	// @0x40002000 

// CRS->CR CRS control register
enum {
	CRS_CR_TRIM = ((1UL<<7)-1) << 8, // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
	CRS_CR_SWSYNC = 1UL<<7, // Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
	CRS_CR_AUTOTRIMEN = 1UL<<6, // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
	CRS_CR_CEN = 1UL<<5, // Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
	CRS_CR_ESYNCIE = 1UL<<3, // Expected SYNC interrupt enable
	CRS_CR_ERRIE = 1UL<<2, // Synchronization or trimming error interrupt enable
	CRS_CR_SYNCWARNIE = 1UL<<1, // SYNC warning interrupt enable
	CRS_CR_SYNCOKIE = 1UL<<0, // SYNC event OK interrupt enable		
};
static inline void crs_cr_set_trim(uint32_t val) { CRS.CR = (CRS.CR & ~CRS_CR_TRIM) | ((val<<8) & CRS_CR_TRIM); }
static inline uint32_t crs_cr_get_trim(void) { return (CRS.CR & CRS_CR_TRIM) >> 8 ; }

// CRS->CFGR This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
enum {
	CRS_CFGR_SYNCPOL = 1UL<<31, // SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
	CRS_CFGR_SYNCSRC = ((1UL<<2)-1) << 28, // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
	CRS_CFGR_SYNCDIV = ((1UL<<3)-1) << 24, // SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
	CRS_CFGR_FELIM = ((1UL<<8)-1) << 16, // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
	CRS_CFGR_RELOAD = ((1UL<<16)-1) << 0, // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.		
};
static inline void crs_cfgr_set_syncsrc(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_SYNCSRC) | ((val<<28) & CRS_CFGR_SYNCSRC); }
static inline void crs_cfgr_set_syncdiv(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_SYNCDIV) | ((val<<24) & CRS_CFGR_SYNCDIV); }
static inline void crs_cfgr_set_felim(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_FELIM) | ((val<<16) & CRS_CFGR_FELIM); }
static inline void crs_cfgr_set_reload(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_RELOAD) | ((val<<0) & CRS_CFGR_RELOAD); }
static inline uint32_t crs_cfgr_get_syncsrc(void) { return (CRS.CFGR & CRS_CFGR_SYNCSRC) >> 28 ; }
static inline uint32_t crs_cfgr_get_syncdiv(void) { return (CRS.CFGR & CRS_CFGR_SYNCDIV) >> 24 ; }
static inline uint32_t crs_cfgr_get_felim(void) { return (CRS.CFGR & CRS_CFGR_FELIM) >> 16 ; }
static inline uint32_t crs_cfgr_get_reload(void) { return (CRS.CFGR & CRS_CFGR_RELOAD) >> 0 ; }

// CRS->ISR CRS interrupt and status register
enum {
	CRS_ISR_FECAP = ((1UL<<16)-1) << 16, // Frequency error capture FECAP is the frequency error counter value latched in the time ofthe last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
	CRS_ISR_FEDIR = 1UL<<15, // Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
	CRS_ISR_TRIMOVF = 1UL<<10, // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCMISS = 1UL<<9, // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCERR = 1UL<<8, // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_ESYNCF = 1UL<<3, // Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
	CRS_ISR_ERRF = 1UL<<2, // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
	CRS_ISR_SYNCWARNF = 1UL<<1, // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
	CRS_ISR_SYNCOKF = 1UL<<0, // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.		
};
static inline uint32_t crs_isr_get_fecap(void) { return (CRS.ISR & CRS_ISR_FECAP) >> 16 ; }

// CRS->ICR CRS interrupt flag clear register
enum {
	CRS_ICR_ESYNCC = 1UL<<3, // Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
	CRS_ICR_ERRC = 1UL<<2, // Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
	CRS_ICR_SYNCWARNC = 1UL<<1, // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
	CRS_ICR_SYNCOKC = 1UL<<0, // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.		
};

/* Digital-to-analog converter */
struct DAC_Type {
	__IO uint32_t DAC_CR; // @0 DAC control register
	__O uint32_t DAC_SWTRGR; // @4 DAC software trigger register
	__IO uint32_t DAC_DHR12R1; // @8 DAC channel1 12-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12L1; // @12 DAC channel1 12-bit left aligned data holding register
	__IO uint32_t DAC_DHR8R1; // @16 DAC channel1 8-bit right aligned data holding register
	__IO uint32_t DAC_DHR12R2; // @20 DAC channel2 12-bit right aligned data holding register
	__IO uint32_t DAC_DHR12L2; // @24 DAC channel2 12-bit left aligned data holding register
	__IO uint32_t DAC_DHR8R2; // @28 DAC channel2 8-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12RD; // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12LD; // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint32_t DAC_DHR8RD; // @40 DUAL DAC 8-bit right aligned data holding register
	__I uint32_t DAC_DOR1; // @44 DAC channel1 data output register
	__I uint32_t DAC_DOR2; // @48 DAC channel2 data output register
	__IO uint32_t DAC_SR; // @52 DAC status register
	__IO uint32_t DAC_CCR; // @56 DAC calibration control register
	__IO uint32_t DAC_MCR; // @60 DAC mode control register
	__IO uint32_t DAC_SHSR1; // @64 DAC Sample and Hold sample time register 1
	__IO uint32_t DAC_SHSR2; // @68 DAC Sample and Hold sample time register 2
	__IO uint32_t DAC_SHHR; // @72 DAC Sample and Hold hold time register
	__IO uint32_t DAC_SHRR; // @76 DAC Sample and Hold refresh time register
	 uint8_t RESERVED0[8]; // @80 
	__IO uint32_t DAC_STR1; // @88 Sawtooth register
	__IO uint32_t DAC_STR2; // @92 Sawtooth register
	__IO uint32_t DAC_STMODR; // @96 Sawtooth Mode register
};
extern struct DAC_Type	DAC1;	// @0x50000800 
extern struct DAC_Type 	DAC2;	// @0x50000C00
extern struct DAC_Type 	DAC3;	// @0x50001000
extern struct DAC_Type 	DAC4;	// @0x50001400

// DAC->DAC_CR DAC control register
enum {
	DAC_DAC_CR_CEN2 = 1UL<<30, // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC_DAC_CR_DMAUDRIE2 = 1UL<<29, // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
	DAC_DAC_CR_DMAEN2 = 1UL<<28, // DAC channel2 DMA enable This bit is set and cleared by software.
	DAC_DAC_CR_MAMP2 = ((1UL<<4)-1) << 24, // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC_DAC_CR_WAVE2 = ((1UL<<2)-1) << 22, // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
	DAC_DAC_CR_TSEL2 = ((1UL<<4)-1) << 18, // DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
	DAC_DAC_CR_TEN2 = 1UL<<17, // DAC channel2 trigger enable
	DAC_DAC_CR_EN2 = 1UL<<16, // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
	DAC_DAC_CR_CEN1 = 1UL<<14, // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC_DAC_CR_DMAUDRIE1 = 1UL<<13, // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
	DAC_DAC_CR_DMAEN1 = 1UL<<12, // DAC channel1 DMA enable This bit is set and cleared by software.
	DAC_DAC_CR_MAMP1 = ((1UL<<4)-1) << 8, // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC_DAC_CR_WAVE1 = ((1UL<<2)-1) << 6, // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC_DAC_CR_TSEL1 = ((1UL<<4)-1) << 2, // DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC_DAC_CR_TEN1 = 1UL<<1, // DAC channel1 trigger enable
	DAC_DAC_CR_EN1 = 1UL<<0, // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.		
};
static inline void dac_dac_cr_set_mamp2(struct DAC_Type* p, uint32_t val) { p->DAC_CR = (p->DAC_CR & ~DAC_DAC_CR_MAMP2) | ((val<<24) & DAC_DAC_CR_MAMP2); }
static inline void dac_dac_cr_set_wave2(struct DAC_Type* p, uint32_t val) { p->DAC_CR = (p->DAC_CR & ~DAC_DAC_CR_WAVE2) | ((val<<22) & DAC_DAC_CR_WAVE2); }
static inline void dac_dac_cr_set_tsel2(struct DAC_Type* p, uint32_t val) { p->DAC_CR = (p->DAC_CR & ~DAC_DAC_CR_TSEL2) | ((val<<18) & DAC_DAC_CR_TSEL2); }
static inline void dac_dac_cr_set_mamp1(struct DAC_Type* p, uint32_t val) { p->DAC_CR = (p->DAC_CR & ~DAC_DAC_CR_MAMP1) | ((val<<8) & DAC_DAC_CR_MAMP1); }
static inline void dac_dac_cr_set_wave1(struct DAC_Type* p, uint32_t val) { p->DAC_CR = (p->DAC_CR & ~DAC_DAC_CR_WAVE1) | ((val<<6) & DAC_DAC_CR_WAVE1); }
static inline void dac_dac_cr_set_tsel1(struct DAC_Type* p, uint32_t val) { p->DAC_CR = (p->DAC_CR & ~DAC_DAC_CR_TSEL1) | ((val<<2) & DAC_DAC_CR_TSEL1); }
static inline uint32_t dac_dac_cr_get_mamp2(struct DAC_Type* p) { return (p->DAC_CR & DAC_DAC_CR_MAMP2) >> 24 ; }
static inline uint32_t dac_dac_cr_get_wave2(struct DAC_Type* p) { return (p->DAC_CR & DAC_DAC_CR_WAVE2) >> 22 ; }
static inline uint32_t dac_dac_cr_get_tsel2(struct DAC_Type* p) { return (p->DAC_CR & DAC_DAC_CR_TSEL2) >> 18 ; }
static inline uint32_t dac_dac_cr_get_mamp1(struct DAC_Type* p) { return (p->DAC_CR & DAC_DAC_CR_MAMP1) >> 8 ; }
static inline uint32_t dac_dac_cr_get_wave1(struct DAC_Type* p) { return (p->DAC_CR & DAC_DAC_CR_WAVE1) >> 6 ; }
static inline uint32_t dac_dac_cr_get_tsel1(struct DAC_Type* p) { return (p->DAC_CR & DAC_DAC_CR_TSEL1) >> 2 ; }

// DAC->DAC_SWTRGR DAC software trigger register
enum {
	DAC_DAC_SWTRGR_SWTRIGB2 = 1UL<<17, // DAC channel2 software trigger B
	DAC_DAC_SWTRGR_SWTRIGB1 = 1UL<<16, // DAC channel1 software trigger B
	DAC_DAC_SWTRGR_SWTRIG2 = 1UL<<1, // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
	DAC_DAC_SWTRGR_SWTRIG1 = 1UL<<0, // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.		
};

// DAC->DAC_DHR12R1 DAC channel1 12-bit right-aligned data holding register
enum {
	DAC_DAC_DHR12R1_DACC1DHRB = ((1UL<<12)-1) << 16, // DAC channel1 12-bit right-aligned data B
	DAC_DAC_DHR12R1_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
static inline void dac_dac_dhr12r1_set_dacc1dhrb(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12R1 = (p->DAC_DHR12R1 & ~DAC_DAC_DHR12R1_DACC1DHRB) | ((val<<16) & DAC_DAC_DHR12R1_DACC1DHRB); }
static inline void dac_dac_dhr12r1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12R1 = (p->DAC_DHR12R1 & ~DAC_DAC_DHR12R1_DACC1DHR) | ((val<<0) & DAC_DAC_DHR12R1_DACC1DHR); }
static inline uint32_t dac_dac_dhr12r1_get_dacc1dhrb(struct DAC_Type* p) { return (p->DAC_DHR12R1 & DAC_DAC_DHR12R1_DACC1DHRB) >> 16 ; }
static inline uint32_t dac_dac_dhr12r1_get_dacc1dhr(struct DAC_Type* p) { return (p->DAC_DHR12R1 & DAC_DAC_DHR12R1_DACC1DHR) >> 0 ; }

// DAC->DAC_DHR12L1 DAC channel1 12-bit left aligned data holding register
enum {
	DAC_DAC_DHR12L1_DACC1DHRB = ((1UL<<12)-1) << 20, // DAC channel1 12-bit left-aligned data B
	DAC_DAC_DHR12L1_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
static inline void dac_dac_dhr12l1_set_dacc1dhrb(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12L1 = (p->DAC_DHR12L1 & ~DAC_DAC_DHR12L1_DACC1DHRB) | ((val<<20) & DAC_DAC_DHR12L1_DACC1DHRB); }
static inline void dac_dac_dhr12l1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12L1 = (p->DAC_DHR12L1 & ~DAC_DAC_DHR12L1_DACC1DHR) | ((val<<4) & DAC_DAC_DHR12L1_DACC1DHR); }
static inline uint32_t dac_dac_dhr12l1_get_dacc1dhrb(struct DAC_Type* p) { return (p->DAC_DHR12L1 & DAC_DAC_DHR12L1_DACC1DHRB) >> 20 ; }
static inline uint32_t dac_dac_dhr12l1_get_dacc1dhr(struct DAC_Type* p) { return (p->DAC_DHR12L1 & DAC_DAC_DHR12L1_DACC1DHR) >> 4 ; }

// DAC->DAC_DHR8R1 DAC channel1 8-bit right aligned data holding register
enum {
	DAC_DAC_DHR8R1_DACC1DHRB = ((1UL<<8)-1) << 8, // DAC channel1 8-bit right-aligned data
	DAC_DAC_DHR8R1_DACC1DHR = ((1UL<<8)-1) << 0, // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.		
};
static inline void dac_dac_dhr8r1_set_dacc1dhrb(struct DAC_Type* p, uint32_t val) { p->DAC_DHR8R1 = (p->DAC_DHR8R1 & ~DAC_DAC_DHR8R1_DACC1DHRB) | ((val<<8) & DAC_DAC_DHR8R1_DACC1DHRB); }
static inline void dac_dac_dhr8r1_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR8R1 = (p->DAC_DHR8R1 & ~DAC_DAC_DHR8R1_DACC1DHR) | ((val<<0) & DAC_DAC_DHR8R1_DACC1DHR); }
static inline uint32_t dac_dac_dhr8r1_get_dacc1dhrb(struct DAC_Type* p) { return (p->DAC_DHR8R1 & DAC_DAC_DHR8R1_DACC1DHRB) >> 8 ; }
static inline uint32_t dac_dac_dhr8r1_get_dacc1dhr(struct DAC_Type* p) { return (p->DAC_DHR8R1 & DAC_DAC_DHR8R1_DACC1DHR) >> 0 ; }

// DAC->DAC_DHR12R2 DAC channel2 12-bit right aligned data holding register
enum {
	DAC_DAC_DHR12R2_DACC2DHRB = ((1UL<<12)-1) << 16, // DAC channel2 12-bit right-aligned data
	DAC_DAC_DHR12R2_DACC2DHR = ((1UL<<12)-1) << 0, // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.		
};
static inline void dac_dac_dhr12r2_set_dacc2dhrb(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12R2 = (p->DAC_DHR12R2 & ~DAC_DAC_DHR12R2_DACC2DHRB) | ((val<<16) & DAC_DAC_DHR12R2_DACC2DHRB); }
static inline void dac_dac_dhr12r2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12R2 = (p->DAC_DHR12R2 & ~DAC_DAC_DHR12R2_DACC2DHR) | ((val<<0) & DAC_DAC_DHR12R2_DACC2DHR); }
static inline uint32_t dac_dac_dhr12r2_get_dacc2dhrb(struct DAC_Type* p) { return (p->DAC_DHR12R2 & DAC_DAC_DHR12R2_DACC2DHRB) >> 16 ; }
static inline uint32_t dac_dac_dhr12r2_get_dacc2dhr(struct DAC_Type* p) { return (p->DAC_DHR12R2 & DAC_DAC_DHR12R2_DACC2DHR) >> 0 ; }

// DAC->DAC_DHR12L2 DAC channel2 12-bit left aligned data holding register
enum {
	DAC_DAC_DHR12L2_DACC2DHRB = ((1UL<<12)-1) << 20, // DAC channel2 12-bit left-aligned data B
	DAC_DAC_DHR12L2_DACC2DHR = ((1UL<<12)-1) << 4, // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.		
};
static inline void dac_dac_dhr12l2_set_dacc2dhrb(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12L2 = (p->DAC_DHR12L2 & ~DAC_DAC_DHR12L2_DACC2DHRB) | ((val<<20) & DAC_DAC_DHR12L2_DACC2DHRB); }
static inline void dac_dac_dhr12l2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12L2 = (p->DAC_DHR12L2 & ~DAC_DAC_DHR12L2_DACC2DHR) | ((val<<4) & DAC_DAC_DHR12L2_DACC2DHR); }
static inline uint32_t dac_dac_dhr12l2_get_dacc2dhrb(struct DAC_Type* p) { return (p->DAC_DHR12L2 & DAC_DAC_DHR12L2_DACC2DHRB) >> 20 ; }
static inline uint32_t dac_dac_dhr12l2_get_dacc2dhr(struct DAC_Type* p) { return (p->DAC_DHR12L2 & DAC_DAC_DHR12L2_DACC2DHR) >> 4 ; }

// DAC->DAC_DHR8R2 DAC channel2 8-bit right-aligned data holding register
enum {
	DAC_DAC_DHR8R2_DACC2DHRB = ((1UL<<8)-1) << 8, // DAC channel2 8-bit right-aligned data
	DAC_DAC_DHR8R2_DACC2DHR = ((1UL<<8)-1) << 0, // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.		
};
static inline void dac_dac_dhr8r2_set_dacc2dhrb(struct DAC_Type* p, uint32_t val) { p->DAC_DHR8R2 = (p->DAC_DHR8R2 & ~DAC_DAC_DHR8R2_DACC2DHRB) | ((val<<8) & DAC_DAC_DHR8R2_DACC2DHRB); }
static inline void dac_dac_dhr8r2_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR8R2 = (p->DAC_DHR8R2 & ~DAC_DAC_DHR8R2_DACC2DHR) | ((val<<0) & DAC_DAC_DHR8R2_DACC2DHR); }
static inline uint32_t dac_dac_dhr8r2_get_dacc2dhrb(struct DAC_Type* p) { return (p->DAC_DHR8R2 & DAC_DAC_DHR8R2_DACC2DHRB) >> 8 ; }
static inline uint32_t dac_dac_dhr8r2_get_dacc2dhr(struct DAC_Type* p) { return (p->DAC_DHR8R2 & DAC_DAC_DHR8R2_DACC2DHR) >> 0 ; }

// DAC->DAC_DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC_DAC_DHR12RD_DACC2DHR = ((1UL<<12)-1) << 16, // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
	DAC_DAC_DHR12RD_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
static inline void dac_dac_dhr12rd_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12RD = (p->DAC_DHR12RD & ~DAC_DAC_DHR12RD_DACC2DHR) | ((val<<16) & DAC_DAC_DHR12RD_DACC2DHR); }
static inline void dac_dac_dhr12rd_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12RD = (p->DAC_DHR12RD & ~DAC_DAC_DHR12RD_DACC1DHR) | ((val<<0) & DAC_DAC_DHR12RD_DACC1DHR); }
static inline uint32_t dac_dac_dhr12rd_get_dacc2dhr(struct DAC_Type* p) { return (p->DAC_DHR12RD & DAC_DAC_DHR12RD_DACC2DHR) >> 16 ; }
static inline uint32_t dac_dac_dhr12rd_get_dacc1dhr(struct DAC_Type* p) { return (p->DAC_DHR12RD & DAC_DAC_DHR12RD_DACC1DHR) >> 0 ; }

// DAC->DAC_DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC_DAC_DHR12LD_DACC2DHR = ((1UL<<12)-1) << 20, // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
	DAC_DAC_DHR12LD_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.		
};
static inline void dac_dac_dhr12ld_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12LD = (p->DAC_DHR12LD & ~DAC_DAC_DHR12LD_DACC2DHR) | ((val<<20) & DAC_DAC_DHR12LD_DACC2DHR); }
static inline void dac_dac_dhr12ld_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR12LD = (p->DAC_DHR12LD & ~DAC_DAC_DHR12LD_DACC1DHR) | ((val<<4) & DAC_DAC_DHR12LD_DACC1DHR); }
static inline uint32_t dac_dac_dhr12ld_get_dacc2dhr(struct DAC_Type* p) { return (p->DAC_DHR12LD & DAC_DAC_DHR12LD_DACC2DHR) >> 20 ; }
static inline uint32_t dac_dac_dhr12ld_get_dacc1dhr(struct DAC_Type* p) { return (p->DAC_DHR12LD & DAC_DAC_DHR12LD_DACC1DHR) >> 4 ; }

// DAC->DAC_DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC_DAC_DHR8RD_DACC2DHR = ((1UL<<8)-1) << 8, // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
	DAC_DAC_DHR8RD_DACC1DHR = ((1UL<<8)-1) << 0, // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.		
};
static inline void dac_dac_dhr8rd_set_dacc2dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR8RD = (p->DAC_DHR8RD & ~DAC_DAC_DHR8RD_DACC2DHR) | ((val<<8) & DAC_DAC_DHR8RD_DACC2DHR); }
static inline void dac_dac_dhr8rd_set_dacc1dhr(struct DAC_Type* p, uint32_t val) { p->DAC_DHR8RD = (p->DAC_DHR8RD & ~DAC_DAC_DHR8RD_DACC1DHR) | ((val<<0) & DAC_DAC_DHR8RD_DACC1DHR); }
static inline uint32_t dac_dac_dhr8rd_get_dacc2dhr(struct DAC_Type* p) { return (p->DAC_DHR8RD & DAC_DAC_DHR8RD_DACC2DHR) >> 8 ; }
static inline uint32_t dac_dac_dhr8rd_get_dacc1dhr(struct DAC_Type* p) { return (p->DAC_DHR8RD & DAC_DAC_DHR8RD_DACC1DHR) >> 0 ; }

// DAC->DAC_DOR1 DAC channel1 data output register
enum {
	DAC_DAC_DOR1_DACC1DORB = ((1UL<<12)-1) << 16, // DAC channel1 data output
	DAC_DAC_DOR1_DACC1DOR = ((1UL<<12)-1) << 0, // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.		
};
static inline uint32_t dac_dac_dor1_get_dacc1dorb(struct DAC_Type* p) { return (p->DAC_DOR1 & DAC_DAC_DOR1_DACC1DORB) >> 16 ; }
static inline uint32_t dac_dac_dor1_get_dacc1dor(struct DAC_Type* p) { return (p->DAC_DOR1 & DAC_DAC_DOR1_DACC1DOR) >> 0 ; }

// DAC->DAC_DOR2 DAC channel2 data output register
enum {
	DAC_DAC_DOR2_DACC2DORB = ((1UL<<12)-1) << 16, // DAC channel2 data output
	DAC_DAC_DOR2_DACC2DOR = ((1UL<<12)-1) << 0, // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.		
};
static inline uint32_t dac_dac_dor2_get_dacc2dorb(struct DAC_Type* p) { return (p->DAC_DOR2 & DAC_DAC_DOR2_DACC2DORB) >> 16 ; }
static inline uint32_t dac_dac_dor2_get_dacc2dor(struct DAC_Type* p) { return (p->DAC_DOR2 & DAC_DAC_DOR2_DACC2DOR) >> 0 ; }

// DAC->DAC_SR DAC status register
enum {
	DAC_DAC_SR_BWST2 = 1UL<<31, // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
	DAC_DAC_SR_CAL_FLAG2 = 1UL<<30, // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
	DAC_DAC_SR_DMAUDR2 = 1UL<<29, // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC_DAC_SR_DORSTAT2 = 1UL<<28, // DAC channel 2 output register status bit
	DAC_DAC_SR_DAC2RDY = 1UL<<27, // DAC channel 2 ready status bit
	DAC_DAC_SR_BWST1 = 1UL<<15, // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
	DAC_DAC_SR_CAL_FLAG1 = 1UL<<14, // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
	DAC_DAC_SR_DMAUDR1 = 1UL<<13, // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC_DAC_SR_DORSTAT1 = 1UL<<12, // DAC channel1 output register status bit
	DAC_DAC_SR_DAC1RDY = 1UL<<11, // DAC channel1 ready status bit		
};

// DAC->DAC_CCR DAC calibration control register
enum {
	DAC_DAC_CCR_OTRIM2 = ((1UL<<5)-1) << 16, // DAC Channel 2 offset trimming value
	DAC_DAC_CCR_OTRIM1 = ((1UL<<5)-1) << 0, // DAC Channel 1 offset trimming value		
};
static inline void dac_dac_ccr_set_otrim2(struct DAC_Type* p, uint32_t val) { p->DAC_CCR = (p->DAC_CCR & ~DAC_DAC_CCR_OTRIM2) | ((val<<16) & DAC_DAC_CCR_OTRIM2); }
static inline void dac_dac_ccr_set_otrim1(struct DAC_Type* p, uint32_t val) { p->DAC_CCR = (p->DAC_CCR & ~DAC_DAC_CCR_OTRIM1) | ((val<<0) & DAC_DAC_CCR_OTRIM1); }
static inline uint32_t dac_dac_ccr_get_otrim2(struct DAC_Type* p) { return (p->DAC_CCR & DAC_DAC_CCR_OTRIM2) >> 16 ; }
static inline uint32_t dac_dac_ccr_get_otrim1(struct DAC_Type* p) { return (p->DAC_CCR & DAC_DAC_CCR_OTRIM1) >> 0 ; }

// DAC->DAC_MCR DAC mode control register
enum {
	DAC_DAC_MCR_SINFORMAT2 = 1UL<<25, // Enable signed format for DAC channel2
	DAC_DAC_MCR_DMADOUBLE2 = 1UL<<24, // DAC Channel2 DMA double data mode
	DAC_DAC_MCR_MODE2 = ((1UL<<3)-1) << 16, // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
	DAC_DAC_MCR_HFSEL = ((1UL<<2)-1) << 14, // High frequency interface mode selection
	DAC_DAC_MCR_SINFORMAT1 = 1UL<<9, // Enable signed format for DAC channel1
	DAC_DAC_MCR_DMADOUBLE1 = 1UL<<8, // DAC Channel1 DMA double data mode
	DAC_DAC_MCR_MODE1 = ((1UL<<3)-1) << 0, // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode		
};
static inline void dac_dac_mcr_set_mode2(struct DAC_Type* p, uint32_t val) { p->DAC_MCR = (p->DAC_MCR & ~DAC_DAC_MCR_MODE2) | ((val<<16) & DAC_DAC_MCR_MODE2); }
static inline void dac_dac_mcr_set_hfsel(struct DAC_Type* p, uint32_t val) { p->DAC_MCR = (p->DAC_MCR & ~DAC_DAC_MCR_HFSEL) | ((val<<14) & DAC_DAC_MCR_HFSEL); }
static inline void dac_dac_mcr_set_mode1(struct DAC_Type* p, uint32_t val) { p->DAC_MCR = (p->DAC_MCR & ~DAC_DAC_MCR_MODE1) | ((val<<0) & DAC_DAC_MCR_MODE1); }
static inline uint32_t dac_dac_mcr_get_mode2(struct DAC_Type* p) { return (p->DAC_MCR & DAC_DAC_MCR_MODE2) >> 16 ; }
static inline uint32_t dac_dac_mcr_get_hfsel(struct DAC_Type* p) { return (p->DAC_MCR & DAC_DAC_MCR_HFSEL) >> 14 ; }
static inline uint32_t dac_dac_mcr_get_mode1(struct DAC_Type* p) { return (p->DAC_MCR & DAC_DAC_MCR_MODE1) >> 0 ; }

// DAC->DAC_SHSR1 DAC Sample and Hold sample time register 1
enum {
	DAC_DAC_SHSR1_TSAMPLE1 = ((1UL<<10)-1) << 0, // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.		
};
static inline void dac_dac_shsr1_set_tsample1(struct DAC_Type* p, uint32_t val) { p->DAC_SHSR1 = (p->DAC_SHSR1 & ~DAC_DAC_SHSR1_TSAMPLE1) | ((val<<0) & DAC_DAC_SHSR1_TSAMPLE1); }
static inline uint32_t dac_dac_shsr1_get_tsample1(struct DAC_Type* p) { return (p->DAC_SHSR1 & DAC_DAC_SHSR1_TSAMPLE1) >> 0 ; }

// DAC->DAC_SHSR2 DAC Sample and Hold sample time register 2
enum {
	DAC_DAC_SHSR2_TSAMPLE2 = ((1UL<<10)-1) << 0, // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.		
};
static inline void dac_dac_shsr2_set_tsample2(struct DAC_Type* p, uint32_t val) { p->DAC_SHSR2 = (p->DAC_SHSR2 & ~DAC_DAC_SHSR2_TSAMPLE2) | ((val<<0) & DAC_DAC_SHSR2_TSAMPLE2); }
static inline uint32_t dac_dac_shsr2_get_tsample2(struct DAC_Type* p) { return (p->DAC_SHSR2 & DAC_DAC_SHSR2_TSAMPLE2) >> 0 ; }

// DAC->DAC_SHHR DAC Sample and Hold hold time register
enum {
	DAC_DAC_SHHR_THOLD2 = ((1UL<<10)-1) << 16, // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
	DAC_DAC_SHHR_THOLD1 = ((1UL<<10)-1) << 0, // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI		
};
static inline void dac_dac_shhr_set_thold2(struct DAC_Type* p, uint32_t val) { p->DAC_SHHR = (p->DAC_SHHR & ~DAC_DAC_SHHR_THOLD2) | ((val<<16) & DAC_DAC_SHHR_THOLD2); }
static inline void dac_dac_shhr_set_thold1(struct DAC_Type* p, uint32_t val) { p->DAC_SHHR = (p->DAC_SHHR & ~DAC_DAC_SHHR_THOLD1) | ((val<<0) & DAC_DAC_SHHR_THOLD1); }
static inline uint32_t dac_dac_shhr_get_thold2(struct DAC_Type* p) { return (p->DAC_SHHR & DAC_DAC_SHHR_THOLD2) >> 16 ; }
static inline uint32_t dac_dac_shhr_get_thold1(struct DAC_Type* p) { return (p->DAC_SHHR & DAC_DAC_SHHR_THOLD1) >> 0 ; }

// DAC->DAC_SHRR DAC Sample and Hold refresh time register
enum {
	DAC_DAC_SHRR_TREFRESH2 = ((1UL<<8)-1) << 16, // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
	DAC_DAC_SHRR_TREFRESH1 = ((1UL<<8)-1) << 0, // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI		
};
static inline void dac_dac_shrr_set_trefresh2(struct DAC_Type* p, uint32_t val) { p->DAC_SHRR = (p->DAC_SHRR & ~DAC_DAC_SHRR_TREFRESH2) | ((val<<16) & DAC_DAC_SHRR_TREFRESH2); }
static inline void dac_dac_shrr_set_trefresh1(struct DAC_Type* p, uint32_t val) { p->DAC_SHRR = (p->DAC_SHRR & ~DAC_DAC_SHRR_TREFRESH1) | ((val<<0) & DAC_DAC_SHRR_TREFRESH1); }
static inline uint32_t dac_dac_shrr_get_trefresh2(struct DAC_Type* p) { return (p->DAC_SHRR & DAC_DAC_SHRR_TREFRESH2) >> 16 ; }
static inline uint32_t dac_dac_shrr_get_trefresh1(struct DAC_Type* p) { return (p->DAC_SHRR & DAC_DAC_SHRR_TREFRESH1) >> 0 ; }

// DAC->DAC_STR1 Sawtooth register
enum {
	DAC_DAC_STR1_STINCDATA1 = ((1UL<<16)-1) << 16, // DAC CH1 Sawtooth increment value (12.4 bit format)
	DAC_DAC_STR1_STDIR1 = 1UL<<12, // DAC Channel1 Sawtooth direction setting
	DAC_DAC_STR1_STRSTDATA1 = ((1UL<<12)-1) << 0, // DAC Channel 1 Sawtooth reset value		
};
static inline void dac_dac_str1_set_stincdata1(struct DAC_Type* p, uint32_t val) { p->DAC_STR1 = (p->DAC_STR1 & ~DAC_DAC_STR1_STINCDATA1) | ((val<<16) & DAC_DAC_STR1_STINCDATA1); }
static inline void dac_dac_str1_set_strstdata1(struct DAC_Type* p, uint32_t val) { p->DAC_STR1 = (p->DAC_STR1 & ~DAC_DAC_STR1_STRSTDATA1) | ((val<<0) & DAC_DAC_STR1_STRSTDATA1); }
static inline uint32_t dac_dac_str1_get_stincdata1(struct DAC_Type* p) { return (p->DAC_STR1 & DAC_DAC_STR1_STINCDATA1) >> 16 ; }
static inline uint32_t dac_dac_str1_get_strstdata1(struct DAC_Type* p) { return (p->DAC_STR1 & DAC_DAC_STR1_STRSTDATA1) >> 0 ; }

// DAC->DAC_STR2 Sawtooth register
enum {
	DAC_DAC_STR2_STINCDATA2 = ((1UL<<16)-1) << 16, // DAC CH2 Sawtooth increment value (12.4 bit format)
	DAC_DAC_STR2_STDIR2 = 1UL<<12, // DAC Channel2 Sawtooth direction setting
	DAC_DAC_STR2_STRSTDATA2 = ((1UL<<12)-1) << 0, // DAC Channel 2 Sawtooth reset value		
};
static inline void dac_dac_str2_set_stincdata2(struct DAC_Type* p, uint32_t val) { p->DAC_STR2 = (p->DAC_STR2 & ~DAC_DAC_STR2_STINCDATA2) | ((val<<16) & DAC_DAC_STR2_STINCDATA2); }
static inline void dac_dac_str2_set_strstdata2(struct DAC_Type* p, uint32_t val) { p->DAC_STR2 = (p->DAC_STR2 & ~DAC_DAC_STR2_STRSTDATA2) | ((val<<0) & DAC_DAC_STR2_STRSTDATA2); }
static inline uint32_t dac_dac_str2_get_stincdata2(struct DAC_Type* p) { return (p->DAC_STR2 & DAC_DAC_STR2_STINCDATA2) >> 16 ; }
static inline uint32_t dac_dac_str2_get_strstdata2(struct DAC_Type* p) { return (p->DAC_STR2 & DAC_DAC_STR2_STRSTDATA2) >> 0 ; }

// DAC->DAC_STMODR Sawtooth Mode register
enum {
	DAC_DAC_STMODR_STINCTRIGSEL2 = ((1UL<<4)-1) << 24, // DAC Channel 2 Sawtooth Increment trigger selection
	DAC_DAC_STMODR_STRSTTRIGSEL2 = ((1UL<<4)-1) << 16, // DAC Channel 1 Sawtooth Reset trigger selection
	DAC_DAC_STMODR_STINCTRIGSEL1 = ((1UL<<4)-1) << 8, // DAC Channel 1 Sawtooth Increment trigger selection
	DAC_DAC_STMODR_STRSTTRIGSEL1 = ((1UL<<4)-1) << 0, // DAC Channel 1 Sawtooth Reset trigger selection		
};
static inline void dac_dac_stmodr_set_stinctrigsel2(struct DAC_Type* p, uint32_t val) { p->DAC_STMODR = (p->DAC_STMODR & ~DAC_DAC_STMODR_STINCTRIGSEL2) | ((val<<24) & DAC_DAC_STMODR_STINCTRIGSEL2); }
static inline void dac_dac_stmodr_set_strsttrigsel2(struct DAC_Type* p, uint32_t val) { p->DAC_STMODR = (p->DAC_STMODR & ~DAC_DAC_STMODR_STRSTTRIGSEL2) | ((val<<16) & DAC_DAC_STMODR_STRSTTRIGSEL2); }
static inline void dac_dac_stmodr_set_stinctrigsel1(struct DAC_Type* p, uint32_t val) { p->DAC_STMODR = (p->DAC_STMODR & ~DAC_DAC_STMODR_STINCTRIGSEL1) | ((val<<8) & DAC_DAC_STMODR_STINCTRIGSEL1); }
static inline void dac_dac_stmodr_set_strsttrigsel1(struct DAC_Type* p, uint32_t val) { p->DAC_STMODR = (p->DAC_STMODR & ~DAC_DAC_STMODR_STRSTTRIGSEL1) | ((val<<0) & DAC_DAC_STMODR_STRSTTRIGSEL1); }
static inline uint32_t dac_dac_stmodr_get_stinctrigsel2(struct DAC_Type* p) { return (p->DAC_STMODR & DAC_DAC_STMODR_STINCTRIGSEL2) >> 24 ; }
static inline uint32_t dac_dac_stmodr_get_strsttrigsel2(struct DAC_Type* p) { return (p->DAC_STMODR & DAC_DAC_STMODR_STRSTTRIGSEL2) >> 16 ; }
static inline uint32_t dac_dac_stmodr_get_stinctrigsel1(struct DAC_Type* p) { return (p->DAC_STMODR & DAC_DAC_STMODR_STINCTRIGSEL1) >> 8 ; }
static inline uint32_t dac_dac_stmodr_get_strsttrigsel1(struct DAC_Type* p) { return (p->DAC_STMODR & DAC_DAC_STMODR_STRSTTRIGSEL1) >> 0 ; }




/* Debug support
There is only one peripheral of type DBGMCU. */
struct DBGMCU_Type {
	__I uint32_t IDCODE; // @0 MCU Device ID Code Register
	__IO uint32_t CR; // @4 Debug MCU Configuration Register
	__IO uint32_t APB1L_FZ; // @8 APB Low Freeze Register 1
	__IO uint32_t APB1H_FZ; // @12 APB Low Freeze Register 2
	__IO uint32_t APB2_FZ; // @16 APB High Freeze Register
};
extern struct DBGMCU_Type	DBGMCU;	// @0xE0042000 

// DBGMCU->IDCODE MCU Device ID Code Register
enum {
	DBGMCU_IDCODE_REV_ID = ((1UL<<16)-1) << 16, // Revision Identifier
	DBGMCU_IDCODE_DEV_ID = ((1UL<<12)-1) << 0, // Device Identifier		
};
static inline uint32_t dbgmcu_idcode_get_rev_id(void) { return (DBGMCU.IDCODE & DBGMCU_IDCODE_REV_ID) >> 16 ; }
static inline uint32_t dbgmcu_idcode_get_dev_id(void) { return (DBGMCU.IDCODE & DBGMCU_IDCODE_DEV_ID) >> 0 ; }

// DBGMCU->CR Debug MCU Configuration Register
enum {
	DBGMCU_CR_TRACE_MODE = ((1UL<<2)-1) << 6, // Trace pin assignment control
	DBGMCU_CR_TRACE_IOEN = 1UL<<5, // Trace pin assignment control
	DBGMCU_CR_DBG_STANDBY = 1UL<<2, // Debug Standby Mode
	DBGMCU_CR_DBG_STOP = 1UL<<1, // Debug Stop Mode
	DBGMCU_CR_DBG_SLEEP = 1UL<<0, // Debug Sleep Mode		
};
static inline void dbgmcu_cr_set_trace_mode(uint32_t val) { DBGMCU.CR = (DBGMCU.CR & ~DBGMCU_CR_TRACE_MODE) | ((val<<6) & DBGMCU_CR_TRACE_MODE); }
static inline uint32_t dbgmcu_cr_get_trace_mode(void) { return (DBGMCU.CR & DBGMCU_CR_TRACE_MODE) >> 6 ; }

// DBGMCU->APB1L_FZ APB Low Freeze Register 1
enum {
	DBGMCU_APB1L_FZ_DBG_LPTIMER_STOP = 1UL<<31, // LPTIM1 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C3_STOP = 1UL<<30, // I2C3 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C2_STOP = 1UL<<22, // I2C2 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C1_STOP = 1UL<<21, // I2C1 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_IWDG_STOP = 1UL<<12, // Debug Independent Wachdog stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_WWDG_STOP = 1UL<<11, // Debug Window Wachdog stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_RTC_STOP = 1UL<<10, // Debug RTC stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_TIM7_STOP = 1UL<<5, // TIM7 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIMER6_STOP = 1UL<<4, // Debug Timer 6 stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_TIM5_STOP = 1UL<<3, // TIM5 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIM4_STOP = 1UL<<2, // TIM4 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIM3_STOP = 1UL<<1, // TIM3 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIMER2_STOP = 1UL<<0, // Debug Timer 2 stopped when Core is halted		
};

// DBGMCU->APB1H_FZ APB Low Freeze Register 2
enum {
	DBGMCU_APB1H_FZ_DBG_I2C4_STOP = 1UL<<1, // DBG_I2C4_STOP		
};

// DBGMCU->APB2_FZ APB High Freeze Register
enum {
	DBGMCU_APB2_FZ_DBG_HRTIM3_STOP = 1UL<<29, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM2_STOP = 1UL<<28, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM1_STOP = 1UL<<27, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM0_STOP = 1UL<<26, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_TIM20_STOP = 1UL<<20, // TIM20counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM17_STOP = 1UL<<18, // TIM17 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM16_STOP = 1UL<<17, // TIM16 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM15_STOP = 1UL<<16, // TIM15 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM8_STOP = 1UL<<13, // TIM8 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM1_STOP = 1UL<<11, // TIM1 counter stopped when core is halted		
};

/* DMA controller */
struct DMA_Type {
	__I uint32_t ISR; // @0 interrupt status register
	__O uint32_t IFCR; // @4 DMA interrupt flag clear register
	__IO uint32_t CCR1; // @8 DMA channel 1 configuration register
	__IO uint32_t CNDTR1; // @12 channel x number of data to transfer register
	__IO uint32_t CPAR1; // @16 DMA channel x peripheral address register
	__IO uint32_t CMAR1; // @20 DMA channel x memory address register
	 uint8_t RESERVED0[4]; // @24 
	__IO uint32_t CCR2; // @28 DMA channel 2 configuration register
	__IO uint32_t CNDTR2; // @32 channel x number of data to transfer register
	__IO uint32_t CPAR2; // @36 DMA channel x peripheral address register
	__IO uint32_t CMAR2; // @40 DMA channel x memory address register
	 uint8_t RESERVED1[4]; // @44 
	__IO uint32_t CCR3; // @48 DMA channel 3 configuration register
	__IO uint32_t CNDTR3; // @52 channel x number of data to transfer register
	__IO uint32_t CPAR3; // @56 DMA channel x peripheral address register
	__IO uint32_t CMAR3; // @60 DMA channel x memory address register
	 uint8_t RESERVED2[4]; // @64 
	__IO uint32_t CCR4; // @68 DMA channel 3 configuration register
	__IO uint32_t CNDTR4; // @72 channel x number of data to transfer register
	__IO uint32_t CPAR4; // @76 DMA channel x peripheral address register
	__IO uint32_t CMAR4; // @80 DMA channel x memory address register
	 uint8_t RESERVED3[4]; // @84 
	__IO uint32_t CCR5; // @88 DMA channel 4 configuration register
	__IO uint32_t CNDTR5; // @92 channel x number of data to transfer register
	__IO uint32_t CPAR5; // @96 DMA channel x peripheral address register
	__IO uint32_t CMAR5; // @100 DMA channel x memory address register
	 uint8_t RESERVED4[4]; // @104 
	__IO uint32_t CCR6; // @108 DMA channel 5 configuration register
	__IO uint32_t CNDTR6; // @112 channel x number of data to transfer register
	__IO uint32_t CPAR6; // @116 DMA channel x peripheral address register
	__IO uint32_t CMAR6; // @120 DMA channel x memory address register
	 uint8_t RESERVED5[4]; // @124 
	__IO uint32_t CCR7; // @128 DMA channel 6 configuration register
	__IO uint32_t CNDTR7; // @132 channel x number of data to transfer register
	__IO uint32_t CPAR7; // @136 DMA channel x peripheral address register
	__IO uint32_t CMAR7; // @140 DMA channel x memory address register
	 uint8_t RESERVED6[4]; // @144 
	__IO uint32_t CCR8; // @148 DMA channel 7 configuration register
	__IO uint32_t CNDTR8; // @152 channel x number of data to transfer register
	__IO uint32_t CPAR8; // @156 DMA channel x peripheral address register
	__IO uint32_t CMAR8; // @160 DMA channel x memory address register
};
extern struct DMA_Type	DMA1;	// @0x40020000 
extern struct DMA_Type 	DMA2;	// @0x40020400

// DMA->ISR interrupt status register
enum {
	DMA_ISR_TEIF8 = 1UL<<31, // TEIF8
	DMA_ISR_HTIF8 = 1UL<<30, // HTIF8
	DMA_ISR_TCIF8 = 1UL<<29, // TCIF8
	DMA_ISR_GIF8 = 1UL<<28, // GIF8
	DMA_ISR_TEIF7 = 1UL<<27, // TEIF7
	DMA_ISR_HTIF7 = 1UL<<26, // HTIF7
	DMA_ISR_TCIF7 = 1UL<<25, // TCIF7
	DMA_ISR_GIF7 = 1UL<<24, // GIF7
	DMA_ISR_TEIF6 = 1UL<<23, // TEIF6
	DMA_ISR_HTIF6 = 1UL<<22, // HTIF6
	DMA_ISR_TCIF6 = 1UL<<21, // TCIF6
	DMA_ISR_GIF6 = 1UL<<20, // GIF6
	DMA_ISR_TEIF5 = 1UL<<19, // TEIF5
	DMA_ISR_HTIF5 = 1UL<<18, // HTIF5
	DMA_ISR_TCIF5 = 1UL<<17, // TCIF5
	DMA_ISR_GIF5 = 1UL<<16, // GIF5
	DMA_ISR_TEIF4 = 1UL<<15, // TEIF4
	DMA_ISR_HTIF4 = 1UL<<14, // HTIF4
	DMA_ISR_TCIF4 = 1UL<<13, // TCIF4
	DMA_ISR_GIF4 = 1UL<<12, // GIF4
	DMA_ISR_TEIF3 = 1UL<<11, // TEIF3
	DMA_ISR_HTIF3 = 1UL<<10, // HTIF3
	DMA_ISR_TCIF3 = 1UL<<9, // TCIF3
	DMA_ISR_GIF3 = 1UL<<8, // GIF3
	DMA_ISR_TEIF2 = 1UL<<7, // TEIF2
	DMA_ISR_HTIF2 = 1UL<<6, // HTIF2
	DMA_ISR_TCIF2 = 1UL<<5, // TCIF2
	DMA_ISR_GIF2 = 1UL<<4, // GIF2
	DMA_ISR_TEIF1 = 1UL<<3, // TEIF1
	DMA_ISR_HTIF1 = 1UL<<2, // HTIF1
	DMA_ISR_TCIF1 = 1UL<<1, // TCIF1
	DMA_ISR_GIF1 = 1UL<<0, // GIF1		
};

// DMA->IFCR DMA interrupt flag clear register
enum {
	DMA_IFCR_TEIF8 = 1UL<<31, // TEIF8
	DMA_IFCR_HTIF8 = 1UL<<30, // HTIF8
	DMA_IFCR_TCIF8 = 1UL<<29, // TCIF8
	DMA_IFCR_GIF8 = 1UL<<28, // GIF8
	DMA_IFCR_TEIF7 = 1UL<<27, // TEIF7
	DMA_IFCR_HTIF7 = 1UL<<26, // HTIF7
	DMA_IFCR_TCIF7 = 1UL<<25, // TCIF7
	DMA_IFCR_GIF7 = 1UL<<24, // GIF7
	DMA_IFCR_TEIF6 = 1UL<<23, // TEIF6
	DMA_IFCR_HTIF6 = 1UL<<22, // HTIF6
	DMA_IFCR_TCIF6 = 1UL<<21, // TCIF6
	DMA_IFCR_GIF6 = 1UL<<20, // GIF6
	DMA_IFCR_TEIF5 = 1UL<<19, // TEIF5
	DMA_IFCR_HTIF5 = 1UL<<18, // HTIF5
	DMA_IFCR_TCIF5 = 1UL<<17, // TCIF5
	DMA_IFCR_GIF5 = 1UL<<16, // GIF5
	DMA_IFCR_TEIF4 = 1UL<<15, // TEIF4
	DMA_IFCR_HTIF4 = 1UL<<14, // HTIF4
	DMA_IFCR_TCIF4 = 1UL<<13, // TCIF4
	DMA_IFCR_GIF4 = 1UL<<12, // GIF4
	DMA_IFCR_TEIF3 = 1UL<<11, // TEIF3
	DMA_IFCR_HTIF3 = 1UL<<10, // HTIF3
	DMA_IFCR_TCIF3 = 1UL<<9, // TCIF3
	DMA_IFCR_GIF3 = 1UL<<8, // GIF3
	DMA_IFCR_TEIF2 = 1UL<<7, // TEIF2
	DMA_IFCR_HTIF2 = 1UL<<6, // HTIF2
	DMA_IFCR_TCIF2 = 1UL<<5, // TCIF2
	DMA_IFCR_GIF2 = 1UL<<4, // GIF2
	DMA_IFCR_TEIF1 = 1UL<<3, // TEIF1
	DMA_IFCR_HTIF1 = 1UL<<2, // HTIF1
	DMA_IFCR_TCIF1 = 1UL<<1, // TCIF1
	DMA_IFCR_GIF1 = 1UL<<0, // GIF1		
};

// DMA->CCR1 DMA channel 1 configuration register
enum {
	DMA_CCR1_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR1_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR1_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR1_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR1_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR1_MINC = 1UL<<7, // MINC
	DMA_CCR1_PINC = 1UL<<6, // PINC
	DMA_CCR1_CIRC = 1UL<<5, // CIRC
	DMA_CCR1_DIR = 1UL<<4, // DIR
	DMA_CCR1_TEIE = 1UL<<3, // TEIE
	DMA_CCR1_HTIE = 1UL<<2, // HTIE
	DMA_CCR1_TCIE = 1UL<<1, // TCIE
	DMA_CCR1_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr1_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_RESVZ) | ((val<<16) & DMA_CCR1_RESVZ); }
static inline void dma_ccr1_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_PL) | ((val<<12) & DMA_CCR1_PL); }
static inline void dma_ccr1_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_MSIZE) | ((val<<10) & DMA_CCR1_MSIZE); }
static inline void dma_ccr1_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_PSIZE) | ((val<<8) & DMA_CCR1_PSIZE); }
static inline uint32_t dma_ccr1_get_resvz(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr1_get_pl(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_PL) >> 12 ; }
static inline uint32_t dma_ccr1_get_msize(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr1_get_psize(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_PSIZE) >> 8 ; }

// DMA->CCR2 DMA channel 2 configuration register
enum {
	DMA_CCR2_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR2_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR2_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR2_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR2_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR2_MINC = 1UL<<7, // MINC
	DMA_CCR2_PINC = 1UL<<6, // PINC
	DMA_CCR2_CIRC = 1UL<<5, // CIRC
	DMA_CCR2_DIR = 1UL<<4, // DIR
	DMA_CCR2_TEIE = 1UL<<3, // TEIE
	DMA_CCR2_HTIE = 1UL<<2, // HTIE
	DMA_CCR2_TCIE = 1UL<<1, // TCIE
	DMA_CCR2_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr2_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_RESVZ) | ((val<<16) & DMA_CCR2_RESVZ); }
static inline void dma_ccr2_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_PL) | ((val<<12) & DMA_CCR2_PL); }
static inline void dma_ccr2_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_MSIZE) | ((val<<10) & DMA_CCR2_MSIZE); }
static inline void dma_ccr2_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_PSIZE) | ((val<<8) & DMA_CCR2_PSIZE); }
static inline uint32_t dma_ccr2_get_resvz(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr2_get_pl(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_PL) >> 12 ; }
static inline uint32_t dma_ccr2_get_msize(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr2_get_psize(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_PSIZE) >> 8 ; }

// DMA->CCR3 DMA channel 3 configuration register
enum {
	DMA_CCR3_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR3_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR3_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR3_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR3_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR3_MINC = 1UL<<7, // MINC
	DMA_CCR3_PINC = 1UL<<6, // PINC
	DMA_CCR3_CIRC = 1UL<<5, // CIRC
	DMA_CCR3_DIR = 1UL<<4, // DIR
	DMA_CCR3_TEIE = 1UL<<3, // TEIE
	DMA_CCR3_HTIE = 1UL<<2, // HTIE
	DMA_CCR3_TCIE = 1UL<<1, // TCIE
	DMA_CCR3_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr3_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_RESVZ) | ((val<<16) & DMA_CCR3_RESVZ); }
static inline void dma_ccr3_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_PL) | ((val<<12) & DMA_CCR3_PL); }
static inline void dma_ccr3_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_MSIZE) | ((val<<10) & DMA_CCR3_MSIZE); }
static inline void dma_ccr3_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_PSIZE) | ((val<<8) & DMA_CCR3_PSIZE); }
static inline uint32_t dma_ccr3_get_resvz(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr3_get_pl(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_PL) >> 12 ; }
static inline uint32_t dma_ccr3_get_msize(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr3_get_psize(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_PSIZE) >> 8 ; }

// DMA->CCR4 DMA channel 3 configuration register
enum {
	DMA_CCR4_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR4_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR4_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR4_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR4_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR4_MINC = 1UL<<7, // MINC
	DMA_CCR4_PINC = 1UL<<6, // PINC
	DMA_CCR4_CIRC = 1UL<<5, // CIRC
	DMA_CCR4_DIR = 1UL<<4, // DIR
	DMA_CCR4_TEIE = 1UL<<3, // TEIE
	DMA_CCR4_HTIE = 1UL<<2, // HTIE
	DMA_CCR4_TCIE = 1UL<<1, // TCIE
	DMA_CCR4_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr4_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_RESVZ) | ((val<<16) & DMA_CCR4_RESVZ); }
static inline void dma_ccr4_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_PL) | ((val<<12) & DMA_CCR4_PL); }
static inline void dma_ccr4_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_MSIZE) | ((val<<10) & DMA_CCR4_MSIZE); }
static inline void dma_ccr4_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_PSIZE) | ((val<<8) & DMA_CCR4_PSIZE); }
static inline uint32_t dma_ccr4_get_resvz(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr4_get_pl(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_PL) >> 12 ; }
static inline uint32_t dma_ccr4_get_msize(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr4_get_psize(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_PSIZE) >> 8 ; }

// DMA->CCR5 DMA channel 4 configuration register
enum {
	DMA_CCR5_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR5_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR5_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR5_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR5_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR5_MINC = 1UL<<7, // MINC
	DMA_CCR5_PINC = 1UL<<6, // PINC
	DMA_CCR5_CIRC = 1UL<<5, // CIRC
	DMA_CCR5_DIR = 1UL<<4, // DIR
	DMA_CCR5_TEIE = 1UL<<3, // TEIE
	DMA_CCR5_HTIE = 1UL<<2, // HTIE
	DMA_CCR5_TCIE = 1UL<<1, // TCIE
	DMA_CCR5_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr5_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_RESVZ) | ((val<<16) & DMA_CCR5_RESVZ); }
static inline void dma_ccr5_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_PL) | ((val<<12) & DMA_CCR5_PL); }
static inline void dma_ccr5_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_MSIZE) | ((val<<10) & DMA_CCR5_MSIZE); }
static inline void dma_ccr5_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_PSIZE) | ((val<<8) & DMA_CCR5_PSIZE); }
static inline uint32_t dma_ccr5_get_resvz(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr5_get_pl(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_PL) >> 12 ; }
static inline uint32_t dma_ccr5_get_msize(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr5_get_psize(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_PSIZE) >> 8 ; }

// DMA->CCR6 DMA channel 5 configuration register
enum {
	DMA_CCR6_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR6_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR6_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR6_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR6_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR6_MINC = 1UL<<7, // MINC
	DMA_CCR6_PINC = 1UL<<6, // PINC
	DMA_CCR6_CIRC = 1UL<<5, // CIRC
	DMA_CCR6_DIR = 1UL<<4, // DIR
	DMA_CCR6_TEIE = 1UL<<3, // TEIE
	DMA_CCR6_HTIE = 1UL<<2, // HTIE
	DMA_CCR6_TCIE = 1UL<<1, // TCIE
	DMA_CCR6_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr6_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_RESVZ) | ((val<<16) & DMA_CCR6_RESVZ); }
static inline void dma_ccr6_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_PL) | ((val<<12) & DMA_CCR6_PL); }
static inline void dma_ccr6_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_MSIZE) | ((val<<10) & DMA_CCR6_MSIZE); }
static inline void dma_ccr6_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_PSIZE) | ((val<<8) & DMA_CCR6_PSIZE); }
static inline uint32_t dma_ccr6_get_resvz(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr6_get_pl(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_PL) >> 12 ; }
static inline uint32_t dma_ccr6_get_msize(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr6_get_psize(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_PSIZE) >> 8 ; }

// DMA->CCR7 DMA channel 6 configuration register
enum {
	DMA_CCR7_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR7_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR7_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR7_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR7_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR7_MINC = 1UL<<7, // MINC
	DMA_CCR7_PINC = 1UL<<6, // PINC
	DMA_CCR7_CIRC = 1UL<<5, // CIRC
	DMA_CCR7_DIR = 1UL<<4, // DIR
	DMA_CCR7_TEIE = 1UL<<3, // TEIE
	DMA_CCR7_HTIE = 1UL<<2, // HTIE
	DMA_CCR7_TCIE = 1UL<<1, // TCIE
	DMA_CCR7_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr7_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_RESVZ) | ((val<<16) & DMA_CCR7_RESVZ); }
static inline void dma_ccr7_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_PL) | ((val<<12) & DMA_CCR7_PL); }
static inline void dma_ccr7_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_MSIZE) | ((val<<10) & DMA_CCR7_MSIZE); }
static inline void dma_ccr7_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_PSIZE) | ((val<<8) & DMA_CCR7_PSIZE); }
static inline uint32_t dma_ccr7_get_resvz(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr7_get_pl(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_PL) >> 12 ; }
static inline uint32_t dma_ccr7_get_msize(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr7_get_psize(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_PSIZE) >> 8 ; }

// DMA->CCR8 DMA channel 7 configuration register
enum {
	DMA_CCR8_RESVZ = ((1UL<<16)-1) << 16, // force 32 bit width
	DMA_CCR8_MEM2MEM = 1UL<<14, // MEM2MEM
	DMA_CCR8_PL = ((1UL<<2)-1) << 12, // PL
	DMA_CCR8_MSIZE = ((1UL<<2)-1) << 10, // MSIZE
	DMA_CCR8_PSIZE = ((1UL<<2)-1) << 8, // PSIZE
	DMA_CCR8_MINC = 1UL<<7, // MINC
	DMA_CCR8_PINC = 1UL<<6, // PINC
	DMA_CCR8_CIRC = 1UL<<5, // CIRC
	DMA_CCR8_DIR = 1UL<<4, // DIR
	DMA_CCR8_TEIE = 1UL<<3, // TEIE
	DMA_CCR8_HTIE = 1UL<<2, // HTIE
	DMA_CCR8_TCIE = 1UL<<1, // TCIE
	DMA_CCR8_EN = 1UL<<0, // channel enable		
};
static inline void dma_ccr8_set_resvz(struct DMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~DMA_CCR8_RESVZ) | ((val<<16) & DMA_CCR8_RESVZ); }
static inline void dma_ccr8_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~DMA_CCR8_PL) | ((val<<12) & DMA_CCR8_PL); }
static inline void dma_ccr8_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~DMA_CCR8_MSIZE) | ((val<<10) & DMA_CCR8_MSIZE); }
static inline void dma_ccr8_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~DMA_CCR8_PSIZE) | ((val<<8) & DMA_CCR8_PSIZE); }
static inline uint32_t dma_ccr8_get_resvz(struct DMA_Type* p) { return (p->CCR8 & DMA_CCR8_RESVZ) >> 16 ; }
static inline uint32_t dma_ccr8_get_pl(struct DMA_Type* p) { return (p->CCR8 & DMA_CCR8_PL) >> 12 ; }
static inline uint32_t dma_ccr8_get_msize(struct DMA_Type* p) { return (p->CCR8 & DMA_CCR8_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr8_get_psize(struct DMA_Type* p) { return (p->CCR8 & DMA_CCR8_PSIZE) >> 8 ; }


/* DMAMUX
There is only one peripheral of type DMAMUX. */
struct DMAMUX_Type {
	__IO uint32_t C0CR; // @0 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C1CR; // @4 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C2CR; // @8 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C3CR; // @12 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C4CR; // @16 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C5CR; // @20 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C6CR; // @24 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C7CR; // @28 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C8CR; // @32 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C9CR; // @36 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C10CR; // @40 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C11CR; // @44 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C12CR; // @48 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C13CR; // @52 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C14CR; // @56 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C15CR; // @60 DMAMux - DMA request line multiplexer channel x control register
	 uint8_t RESERVED0[64]; // @64 
	__I uint32_t CSR; // @128 DMAMUX request line multiplexer interrupt channel status register
	__O uint32_t CFR; // @132 DMAMUX request line multiplexer interrupt clear flag register
	 uint8_t RESERVED1[120]; // @136 
	__IO uint32_t RG0CR; // @256 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG1CR; // @260 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG2CR; // @264 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG3CR; // @268 DMAMux - DMA request generator channel x control register
	 uint8_t RESERVED2[48]; // @272 
	__I uint32_t RGSR; // @320 DMAMux - DMA request generator status register
	__O uint32_t RGCFR; // @324 DMAMux - DMA request generator clear flag register
};
extern struct DMAMUX_Type	DMAMUX;	// @0x40020800 

// DMAMUX->C0CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C0CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C0CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C0CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C0CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C0CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C0CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C0CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c0cr_set_sync_id(uint32_t val) { DMAMUX.C0CR = (DMAMUX.C0CR & ~DMAMUX_C0CR_SYNC_ID) | ((val<<24) & DMAMUX_C0CR_SYNC_ID); }
static inline void dmamux_c0cr_set_nbreq(uint32_t val) { DMAMUX.C0CR = (DMAMUX.C0CR & ~DMAMUX_C0CR_NBREQ) | ((val<<19) & DMAMUX_C0CR_NBREQ); }
static inline void dmamux_c0cr_set_spol(uint32_t val) { DMAMUX.C0CR = (DMAMUX.C0CR & ~DMAMUX_C0CR_SPOL) | ((val<<17) & DMAMUX_C0CR_SPOL); }
static inline void dmamux_c0cr_set_dmareq_id(uint32_t val) { DMAMUX.C0CR = (DMAMUX.C0CR & ~DMAMUX_C0CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C0CR_DMAREQ_ID); }
static inline uint32_t dmamux_c0cr_get_sync_id(void) { return (DMAMUX.C0CR & DMAMUX_C0CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c0cr_get_nbreq(void) { return (DMAMUX.C0CR & DMAMUX_C0CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c0cr_get_spol(void) { return (DMAMUX.C0CR & DMAMUX_C0CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c0cr_get_dmareq_id(void) { return (DMAMUX.C0CR & DMAMUX_C0CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C1CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C1CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C1CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C1CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C1CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C1CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C1CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C1CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c1cr_set_sync_id(uint32_t val) { DMAMUX.C1CR = (DMAMUX.C1CR & ~DMAMUX_C1CR_SYNC_ID) | ((val<<24) & DMAMUX_C1CR_SYNC_ID); }
static inline void dmamux_c1cr_set_nbreq(uint32_t val) { DMAMUX.C1CR = (DMAMUX.C1CR & ~DMAMUX_C1CR_NBREQ) | ((val<<19) & DMAMUX_C1CR_NBREQ); }
static inline void dmamux_c1cr_set_spol(uint32_t val) { DMAMUX.C1CR = (DMAMUX.C1CR & ~DMAMUX_C1CR_SPOL) | ((val<<17) & DMAMUX_C1CR_SPOL); }
static inline void dmamux_c1cr_set_dmareq_id(uint32_t val) { DMAMUX.C1CR = (DMAMUX.C1CR & ~DMAMUX_C1CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C1CR_DMAREQ_ID); }
static inline uint32_t dmamux_c1cr_get_sync_id(void) { return (DMAMUX.C1CR & DMAMUX_C1CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c1cr_get_nbreq(void) { return (DMAMUX.C1CR & DMAMUX_C1CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c1cr_get_spol(void) { return (DMAMUX.C1CR & DMAMUX_C1CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c1cr_get_dmareq_id(void) { return (DMAMUX.C1CR & DMAMUX_C1CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C2CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C2CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C2CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C2CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C2CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C2CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C2CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C2CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c2cr_set_sync_id(uint32_t val) { DMAMUX.C2CR = (DMAMUX.C2CR & ~DMAMUX_C2CR_SYNC_ID) | ((val<<24) & DMAMUX_C2CR_SYNC_ID); }
static inline void dmamux_c2cr_set_nbreq(uint32_t val) { DMAMUX.C2CR = (DMAMUX.C2CR & ~DMAMUX_C2CR_NBREQ) | ((val<<19) & DMAMUX_C2CR_NBREQ); }
static inline void dmamux_c2cr_set_spol(uint32_t val) { DMAMUX.C2CR = (DMAMUX.C2CR & ~DMAMUX_C2CR_SPOL) | ((val<<17) & DMAMUX_C2CR_SPOL); }
static inline void dmamux_c2cr_set_dmareq_id(uint32_t val) { DMAMUX.C2CR = (DMAMUX.C2CR & ~DMAMUX_C2CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C2CR_DMAREQ_ID); }
static inline uint32_t dmamux_c2cr_get_sync_id(void) { return (DMAMUX.C2CR & DMAMUX_C2CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c2cr_get_nbreq(void) { return (DMAMUX.C2CR & DMAMUX_C2CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c2cr_get_spol(void) { return (DMAMUX.C2CR & DMAMUX_C2CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c2cr_get_dmareq_id(void) { return (DMAMUX.C2CR & DMAMUX_C2CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C3CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C3CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C3CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C3CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C3CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C3CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C3CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C3CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c3cr_set_sync_id(uint32_t val) { DMAMUX.C3CR = (DMAMUX.C3CR & ~DMAMUX_C3CR_SYNC_ID) | ((val<<24) & DMAMUX_C3CR_SYNC_ID); }
static inline void dmamux_c3cr_set_nbreq(uint32_t val) { DMAMUX.C3CR = (DMAMUX.C3CR & ~DMAMUX_C3CR_NBREQ) | ((val<<19) & DMAMUX_C3CR_NBREQ); }
static inline void dmamux_c3cr_set_spol(uint32_t val) { DMAMUX.C3CR = (DMAMUX.C3CR & ~DMAMUX_C3CR_SPOL) | ((val<<17) & DMAMUX_C3CR_SPOL); }
static inline void dmamux_c3cr_set_dmareq_id(uint32_t val) { DMAMUX.C3CR = (DMAMUX.C3CR & ~DMAMUX_C3CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C3CR_DMAREQ_ID); }
static inline uint32_t dmamux_c3cr_get_sync_id(void) { return (DMAMUX.C3CR & DMAMUX_C3CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c3cr_get_nbreq(void) { return (DMAMUX.C3CR & DMAMUX_C3CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c3cr_get_spol(void) { return (DMAMUX.C3CR & DMAMUX_C3CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c3cr_get_dmareq_id(void) { return (DMAMUX.C3CR & DMAMUX_C3CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C4CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C4CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C4CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C4CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C4CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C4CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C4CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C4CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c4cr_set_sync_id(uint32_t val) { DMAMUX.C4CR = (DMAMUX.C4CR & ~DMAMUX_C4CR_SYNC_ID) | ((val<<24) & DMAMUX_C4CR_SYNC_ID); }
static inline void dmamux_c4cr_set_nbreq(uint32_t val) { DMAMUX.C4CR = (DMAMUX.C4CR & ~DMAMUX_C4CR_NBREQ) | ((val<<19) & DMAMUX_C4CR_NBREQ); }
static inline void dmamux_c4cr_set_spol(uint32_t val) { DMAMUX.C4CR = (DMAMUX.C4CR & ~DMAMUX_C4CR_SPOL) | ((val<<17) & DMAMUX_C4CR_SPOL); }
static inline void dmamux_c4cr_set_dmareq_id(uint32_t val) { DMAMUX.C4CR = (DMAMUX.C4CR & ~DMAMUX_C4CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C4CR_DMAREQ_ID); }
static inline uint32_t dmamux_c4cr_get_sync_id(void) { return (DMAMUX.C4CR & DMAMUX_C4CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c4cr_get_nbreq(void) { return (DMAMUX.C4CR & DMAMUX_C4CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c4cr_get_spol(void) { return (DMAMUX.C4CR & DMAMUX_C4CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c4cr_get_dmareq_id(void) { return (DMAMUX.C4CR & DMAMUX_C4CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C5CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C5CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C5CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C5CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C5CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C5CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C5CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C5CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c5cr_set_sync_id(uint32_t val) { DMAMUX.C5CR = (DMAMUX.C5CR & ~DMAMUX_C5CR_SYNC_ID) | ((val<<24) & DMAMUX_C5CR_SYNC_ID); }
static inline void dmamux_c5cr_set_nbreq(uint32_t val) { DMAMUX.C5CR = (DMAMUX.C5CR & ~DMAMUX_C5CR_NBREQ) | ((val<<19) & DMAMUX_C5CR_NBREQ); }
static inline void dmamux_c5cr_set_spol(uint32_t val) { DMAMUX.C5CR = (DMAMUX.C5CR & ~DMAMUX_C5CR_SPOL) | ((val<<17) & DMAMUX_C5CR_SPOL); }
static inline void dmamux_c5cr_set_dmareq_id(uint32_t val) { DMAMUX.C5CR = (DMAMUX.C5CR & ~DMAMUX_C5CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C5CR_DMAREQ_ID); }
static inline uint32_t dmamux_c5cr_get_sync_id(void) { return (DMAMUX.C5CR & DMAMUX_C5CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c5cr_get_nbreq(void) { return (DMAMUX.C5CR & DMAMUX_C5CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c5cr_get_spol(void) { return (DMAMUX.C5CR & DMAMUX_C5CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c5cr_get_dmareq_id(void) { return (DMAMUX.C5CR & DMAMUX_C5CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C6CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C6CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C6CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C6CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C6CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C6CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C6CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C6CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c6cr_set_sync_id(uint32_t val) { DMAMUX.C6CR = (DMAMUX.C6CR & ~DMAMUX_C6CR_SYNC_ID) | ((val<<24) & DMAMUX_C6CR_SYNC_ID); }
static inline void dmamux_c6cr_set_nbreq(uint32_t val) { DMAMUX.C6CR = (DMAMUX.C6CR & ~DMAMUX_C6CR_NBREQ) | ((val<<19) & DMAMUX_C6CR_NBREQ); }
static inline void dmamux_c6cr_set_spol(uint32_t val) { DMAMUX.C6CR = (DMAMUX.C6CR & ~DMAMUX_C6CR_SPOL) | ((val<<17) & DMAMUX_C6CR_SPOL); }
static inline void dmamux_c6cr_set_dmareq_id(uint32_t val) { DMAMUX.C6CR = (DMAMUX.C6CR & ~DMAMUX_C6CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C6CR_DMAREQ_ID); }
static inline uint32_t dmamux_c6cr_get_sync_id(void) { return (DMAMUX.C6CR & DMAMUX_C6CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c6cr_get_nbreq(void) { return (DMAMUX.C6CR & DMAMUX_C6CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c6cr_get_spol(void) { return (DMAMUX.C6CR & DMAMUX_C6CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c6cr_get_dmareq_id(void) { return (DMAMUX.C6CR & DMAMUX_C6CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C7CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C7CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C7CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C7CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C7CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C7CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C7CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C7CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c7cr_set_sync_id(uint32_t val) { DMAMUX.C7CR = (DMAMUX.C7CR & ~DMAMUX_C7CR_SYNC_ID) | ((val<<24) & DMAMUX_C7CR_SYNC_ID); }
static inline void dmamux_c7cr_set_nbreq(uint32_t val) { DMAMUX.C7CR = (DMAMUX.C7CR & ~DMAMUX_C7CR_NBREQ) | ((val<<19) & DMAMUX_C7CR_NBREQ); }
static inline void dmamux_c7cr_set_spol(uint32_t val) { DMAMUX.C7CR = (DMAMUX.C7CR & ~DMAMUX_C7CR_SPOL) | ((val<<17) & DMAMUX_C7CR_SPOL); }
static inline void dmamux_c7cr_set_dmareq_id(uint32_t val) { DMAMUX.C7CR = (DMAMUX.C7CR & ~DMAMUX_C7CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C7CR_DMAREQ_ID); }
static inline uint32_t dmamux_c7cr_get_sync_id(void) { return (DMAMUX.C7CR & DMAMUX_C7CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c7cr_get_nbreq(void) { return (DMAMUX.C7CR & DMAMUX_C7CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c7cr_get_spol(void) { return (DMAMUX.C7CR & DMAMUX_C7CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c7cr_get_dmareq_id(void) { return (DMAMUX.C7CR & DMAMUX_C7CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C8CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C8CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C8CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C8CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C8CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C8CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C8CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C8CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c8cr_set_sync_id(uint32_t val) { DMAMUX.C8CR = (DMAMUX.C8CR & ~DMAMUX_C8CR_SYNC_ID) | ((val<<24) & DMAMUX_C8CR_SYNC_ID); }
static inline void dmamux_c8cr_set_nbreq(uint32_t val) { DMAMUX.C8CR = (DMAMUX.C8CR & ~DMAMUX_C8CR_NBREQ) | ((val<<19) & DMAMUX_C8CR_NBREQ); }
static inline void dmamux_c8cr_set_spol(uint32_t val) { DMAMUX.C8CR = (DMAMUX.C8CR & ~DMAMUX_C8CR_SPOL) | ((val<<17) & DMAMUX_C8CR_SPOL); }
static inline void dmamux_c8cr_set_dmareq_id(uint32_t val) { DMAMUX.C8CR = (DMAMUX.C8CR & ~DMAMUX_C8CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C8CR_DMAREQ_ID); }
static inline uint32_t dmamux_c8cr_get_sync_id(void) { return (DMAMUX.C8CR & DMAMUX_C8CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c8cr_get_nbreq(void) { return (DMAMUX.C8CR & DMAMUX_C8CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c8cr_get_spol(void) { return (DMAMUX.C8CR & DMAMUX_C8CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c8cr_get_dmareq_id(void) { return (DMAMUX.C8CR & DMAMUX_C8CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C9CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C9CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C9CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C9CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C9CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C9CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C9CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C9CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c9cr_set_sync_id(uint32_t val) { DMAMUX.C9CR = (DMAMUX.C9CR & ~DMAMUX_C9CR_SYNC_ID) | ((val<<24) & DMAMUX_C9CR_SYNC_ID); }
static inline void dmamux_c9cr_set_nbreq(uint32_t val) { DMAMUX.C9CR = (DMAMUX.C9CR & ~DMAMUX_C9CR_NBREQ) | ((val<<19) & DMAMUX_C9CR_NBREQ); }
static inline void dmamux_c9cr_set_spol(uint32_t val) { DMAMUX.C9CR = (DMAMUX.C9CR & ~DMAMUX_C9CR_SPOL) | ((val<<17) & DMAMUX_C9CR_SPOL); }
static inline void dmamux_c9cr_set_dmareq_id(uint32_t val) { DMAMUX.C9CR = (DMAMUX.C9CR & ~DMAMUX_C9CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C9CR_DMAREQ_ID); }
static inline uint32_t dmamux_c9cr_get_sync_id(void) { return (DMAMUX.C9CR & DMAMUX_C9CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c9cr_get_nbreq(void) { return (DMAMUX.C9CR & DMAMUX_C9CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c9cr_get_spol(void) { return (DMAMUX.C9CR & DMAMUX_C9CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c9cr_get_dmareq_id(void) { return (DMAMUX.C9CR & DMAMUX_C9CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C10CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C10CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C10CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C10CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C10CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C10CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C10CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C10CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c10cr_set_sync_id(uint32_t val) { DMAMUX.C10CR = (DMAMUX.C10CR & ~DMAMUX_C10CR_SYNC_ID) | ((val<<24) & DMAMUX_C10CR_SYNC_ID); }
static inline void dmamux_c10cr_set_nbreq(uint32_t val) { DMAMUX.C10CR = (DMAMUX.C10CR & ~DMAMUX_C10CR_NBREQ) | ((val<<19) & DMAMUX_C10CR_NBREQ); }
static inline void dmamux_c10cr_set_spol(uint32_t val) { DMAMUX.C10CR = (DMAMUX.C10CR & ~DMAMUX_C10CR_SPOL) | ((val<<17) & DMAMUX_C10CR_SPOL); }
static inline void dmamux_c10cr_set_dmareq_id(uint32_t val) { DMAMUX.C10CR = (DMAMUX.C10CR & ~DMAMUX_C10CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C10CR_DMAREQ_ID); }
static inline uint32_t dmamux_c10cr_get_sync_id(void) { return (DMAMUX.C10CR & DMAMUX_C10CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c10cr_get_nbreq(void) { return (DMAMUX.C10CR & DMAMUX_C10CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c10cr_get_spol(void) { return (DMAMUX.C10CR & DMAMUX_C10CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c10cr_get_dmareq_id(void) { return (DMAMUX.C10CR & DMAMUX_C10CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C11CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C11CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C11CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C11CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C11CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C11CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C11CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C11CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c11cr_set_sync_id(uint32_t val) { DMAMUX.C11CR = (DMAMUX.C11CR & ~DMAMUX_C11CR_SYNC_ID) | ((val<<24) & DMAMUX_C11CR_SYNC_ID); }
static inline void dmamux_c11cr_set_nbreq(uint32_t val) { DMAMUX.C11CR = (DMAMUX.C11CR & ~DMAMUX_C11CR_NBREQ) | ((val<<19) & DMAMUX_C11CR_NBREQ); }
static inline void dmamux_c11cr_set_spol(uint32_t val) { DMAMUX.C11CR = (DMAMUX.C11CR & ~DMAMUX_C11CR_SPOL) | ((val<<17) & DMAMUX_C11CR_SPOL); }
static inline void dmamux_c11cr_set_dmareq_id(uint32_t val) { DMAMUX.C11CR = (DMAMUX.C11CR & ~DMAMUX_C11CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C11CR_DMAREQ_ID); }
static inline uint32_t dmamux_c11cr_get_sync_id(void) { return (DMAMUX.C11CR & DMAMUX_C11CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c11cr_get_nbreq(void) { return (DMAMUX.C11CR & DMAMUX_C11CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c11cr_get_spol(void) { return (DMAMUX.C11CR & DMAMUX_C11CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c11cr_get_dmareq_id(void) { return (DMAMUX.C11CR & DMAMUX_C11CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C12CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C12CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C12CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C12CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C12CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C12CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C12CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C12CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c12cr_set_sync_id(uint32_t val) { DMAMUX.C12CR = (DMAMUX.C12CR & ~DMAMUX_C12CR_SYNC_ID) | ((val<<24) & DMAMUX_C12CR_SYNC_ID); }
static inline void dmamux_c12cr_set_nbreq(uint32_t val) { DMAMUX.C12CR = (DMAMUX.C12CR & ~DMAMUX_C12CR_NBREQ) | ((val<<19) & DMAMUX_C12CR_NBREQ); }
static inline void dmamux_c12cr_set_spol(uint32_t val) { DMAMUX.C12CR = (DMAMUX.C12CR & ~DMAMUX_C12CR_SPOL) | ((val<<17) & DMAMUX_C12CR_SPOL); }
static inline void dmamux_c12cr_set_dmareq_id(uint32_t val) { DMAMUX.C12CR = (DMAMUX.C12CR & ~DMAMUX_C12CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C12CR_DMAREQ_ID); }
static inline uint32_t dmamux_c12cr_get_sync_id(void) { return (DMAMUX.C12CR & DMAMUX_C12CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c12cr_get_nbreq(void) { return (DMAMUX.C12CR & DMAMUX_C12CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c12cr_get_spol(void) { return (DMAMUX.C12CR & DMAMUX_C12CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c12cr_get_dmareq_id(void) { return (DMAMUX.C12CR & DMAMUX_C12CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C13CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C13CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C13CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C13CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C13CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C13CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C13CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C13CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c13cr_set_sync_id(uint32_t val) { DMAMUX.C13CR = (DMAMUX.C13CR & ~DMAMUX_C13CR_SYNC_ID) | ((val<<24) & DMAMUX_C13CR_SYNC_ID); }
static inline void dmamux_c13cr_set_nbreq(uint32_t val) { DMAMUX.C13CR = (DMAMUX.C13CR & ~DMAMUX_C13CR_NBREQ) | ((val<<19) & DMAMUX_C13CR_NBREQ); }
static inline void dmamux_c13cr_set_spol(uint32_t val) { DMAMUX.C13CR = (DMAMUX.C13CR & ~DMAMUX_C13CR_SPOL) | ((val<<17) & DMAMUX_C13CR_SPOL); }
static inline void dmamux_c13cr_set_dmareq_id(uint32_t val) { DMAMUX.C13CR = (DMAMUX.C13CR & ~DMAMUX_C13CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C13CR_DMAREQ_ID); }
static inline uint32_t dmamux_c13cr_get_sync_id(void) { return (DMAMUX.C13CR & DMAMUX_C13CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c13cr_get_nbreq(void) { return (DMAMUX.C13CR & DMAMUX_C13CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c13cr_get_spol(void) { return (DMAMUX.C13CR & DMAMUX_C13CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c13cr_get_dmareq_id(void) { return (DMAMUX.C13CR & DMAMUX_C13CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C14CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C14CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C14CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C14CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C14CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C14CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C14CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C14CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c14cr_set_sync_id(uint32_t val) { DMAMUX.C14CR = (DMAMUX.C14CR & ~DMAMUX_C14CR_SYNC_ID) | ((val<<24) & DMAMUX_C14CR_SYNC_ID); }
static inline void dmamux_c14cr_set_nbreq(uint32_t val) { DMAMUX.C14CR = (DMAMUX.C14CR & ~DMAMUX_C14CR_NBREQ) | ((val<<19) & DMAMUX_C14CR_NBREQ); }
static inline void dmamux_c14cr_set_spol(uint32_t val) { DMAMUX.C14CR = (DMAMUX.C14CR & ~DMAMUX_C14CR_SPOL) | ((val<<17) & DMAMUX_C14CR_SPOL); }
static inline void dmamux_c14cr_set_dmareq_id(uint32_t val) { DMAMUX.C14CR = (DMAMUX.C14CR & ~DMAMUX_C14CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C14CR_DMAREQ_ID); }
static inline uint32_t dmamux_c14cr_get_sync_id(void) { return (DMAMUX.C14CR & DMAMUX_C14CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c14cr_get_nbreq(void) { return (DMAMUX.C14CR & DMAMUX_C14CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c14cr_get_spol(void) { return (DMAMUX.C14CR & DMAMUX_C14CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c14cr_get_dmareq_id(void) { return (DMAMUX.C14CR & DMAMUX_C14CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->C15CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C15CR_SYNC_ID = ((1UL<<5)-1) << 24, // Synchronization input selected
	DMAMUX_C15CR_NBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C15CR_SPOL = ((1UL<<2)-1) << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C15CR_SE = 1UL<<16, // Synchronous operating mode enable/disable
	DMAMUX_C15CR_EGE = 1UL<<9, // Event generation enable/disable
	DMAMUX_C15CR_SOIE = 1UL<<8, // Interrupt enable at synchronization event overrun
	DMAMUX_C15CR_DMAREQ_ID = ((1UL<<7)-1) << 0, // Input DMA request line selected		
};
static inline void dmamux_c15cr_set_sync_id(uint32_t val) { DMAMUX.C15CR = (DMAMUX.C15CR & ~DMAMUX_C15CR_SYNC_ID) | ((val<<24) & DMAMUX_C15CR_SYNC_ID); }
static inline void dmamux_c15cr_set_nbreq(uint32_t val) { DMAMUX.C15CR = (DMAMUX.C15CR & ~DMAMUX_C15CR_NBREQ) | ((val<<19) & DMAMUX_C15CR_NBREQ); }
static inline void dmamux_c15cr_set_spol(uint32_t val) { DMAMUX.C15CR = (DMAMUX.C15CR & ~DMAMUX_C15CR_SPOL) | ((val<<17) & DMAMUX_C15CR_SPOL); }
static inline void dmamux_c15cr_set_dmareq_id(uint32_t val) { DMAMUX.C15CR = (DMAMUX.C15CR & ~DMAMUX_C15CR_DMAREQ_ID) | ((val<<0) & DMAMUX_C15CR_DMAREQ_ID); }
static inline uint32_t dmamux_c15cr_get_sync_id(void) { return (DMAMUX.C15CR & DMAMUX_C15CR_SYNC_ID) >> 24 ; }
static inline uint32_t dmamux_c15cr_get_nbreq(void) { return (DMAMUX.C15CR & DMAMUX_C15CR_NBREQ) >> 19 ; }
static inline uint32_t dmamux_c15cr_get_spol(void) { return (DMAMUX.C15CR & DMAMUX_C15CR_SPOL) >> 17 ; }
static inline uint32_t dmamux_c15cr_get_dmareq_id(void) { return (DMAMUX.C15CR & DMAMUX_C15CR_DMAREQ_ID) >> 0 ; }

// DMAMUX->CSR DMAMUX request line multiplexer interrupt channel status register
enum {
	DMAMUX_CSR_SOF = ((1UL<<16)-1) << 0, // Synchronization overrun event flag		
};
static inline uint32_t dmamux_csr_get_sof(void) { return (DMAMUX.CSR & DMAMUX_CSR_SOF) >> 0 ; }

// DMAMUX->CFR DMAMUX request line multiplexer interrupt clear flag register
enum {
	DMAMUX_CFR_CSOF = ((1UL<<16)-1) << 0, // Clear synchronization overrun event flag		
};
static inline void dmamux_cfr_set_csof(uint32_t val) { DMAMUX.CFR = (DMAMUX.CFR & ~DMAMUX_CFR_CSOF) | ((val<<0) & DMAMUX_CFR_CSOF); }
static inline uint32_t dmamux_cfr_get_csof(void) { return (DMAMUX.CFR & DMAMUX_CFR_CSOF) >> 0 ; }

// DMAMUX->RG0CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG0CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG0CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG0CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG0CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG0CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
static inline void dmamux_rg0cr_set_gnbreq(uint32_t val) { DMAMUX.RG0CR = (DMAMUX.RG0CR & ~DMAMUX_RG0CR_GNBREQ) | ((val<<19) & DMAMUX_RG0CR_GNBREQ); }
static inline void dmamux_rg0cr_set_gpol(uint32_t val) { DMAMUX.RG0CR = (DMAMUX.RG0CR & ~DMAMUX_RG0CR_GPOL) | ((val<<17) & DMAMUX_RG0CR_GPOL); }
static inline void dmamux_rg0cr_set_sig_id(uint32_t val) { DMAMUX.RG0CR = (DMAMUX.RG0CR & ~DMAMUX_RG0CR_SIG_ID) | ((val<<0) & DMAMUX_RG0CR_SIG_ID); }
static inline uint32_t dmamux_rg0cr_get_gnbreq(void) { return (DMAMUX.RG0CR & DMAMUX_RG0CR_GNBREQ) >> 19 ; }
static inline uint32_t dmamux_rg0cr_get_gpol(void) { return (DMAMUX.RG0CR & DMAMUX_RG0CR_GPOL) >> 17 ; }
static inline uint32_t dmamux_rg0cr_get_sig_id(void) { return (DMAMUX.RG0CR & DMAMUX_RG0CR_SIG_ID) >> 0 ; }

// DMAMUX->RG1CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG1CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG1CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG1CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG1CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG1CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
static inline void dmamux_rg1cr_set_gnbreq(uint32_t val) { DMAMUX.RG1CR = (DMAMUX.RG1CR & ~DMAMUX_RG1CR_GNBREQ) | ((val<<19) & DMAMUX_RG1CR_GNBREQ); }
static inline void dmamux_rg1cr_set_gpol(uint32_t val) { DMAMUX.RG1CR = (DMAMUX.RG1CR & ~DMAMUX_RG1CR_GPOL) | ((val<<17) & DMAMUX_RG1CR_GPOL); }
static inline void dmamux_rg1cr_set_sig_id(uint32_t val) { DMAMUX.RG1CR = (DMAMUX.RG1CR & ~DMAMUX_RG1CR_SIG_ID) | ((val<<0) & DMAMUX_RG1CR_SIG_ID); }
static inline uint32_t dmamux_rg1cr_get_gnbreq(void) { return (DMAMUX.RG1CR & DMAMUX_RG1CR_GNBREQ) >> 19 ; }
static inline uint32_t dmamux_rg1cr_get_gpol(void) { return (DMAMUX.RG1CR & DMAMUX_RG1CR_GPOL) >> 17 ; }
static inline uint32_t dmamux_rg1cr_get_sig_id(void) { return (DMAMUX.RG1CR & DMAMUX_RG1CR_SIG_ID) >> 0 ; }

// DMAMUX->RG2CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG2CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG2CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG2CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG2CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG2CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
static inline void dmamux_rg2cr_set_gnbreq(uint32_t val) { DMAMUX.RG2CR = (DMAMUX.RG2CR & ~DMAMUX_RG2CR_GNBREQ) | ((val<<19) & DMAMUX_RG2CR_GNBREQ); }
static inline void dmamux_rg2cr_set_gpol(uint32_t val) { DMAMUX.RG2CR = (DMAMUX.RG2CR & ~DMAMUX_RG2CR_GPOL) | ((val<<17) & DMAMUX_RG2CR_GPOL); }
static inline void dmamux_rg2cr_set_sig_id(uint32_t val) { DMAMUX.RG2CR = (DMAMUX.RG2CR & ~DMAMUX_RG2CR_SIG_ID) | ((val<<0) & DMAMUX_RG2CR_SIG_ID); }
static inline uint32_t dmamux_rg2cr_get_gnbreq(void) { return (DMAMUX.RG2CR & DMAMUX_RG2CR_GNBREQ) >> 19 ; }
static inline uint32_t dmamux_rg2cr_get_gpol(void) { return (DMAMUX.RG2CR & DMAMUX_RG2CR_GPOL) >> 17 ; }
static inline uint32_t dmamux_rg2cr_get_sig_id(void) { return (DMAMUX.RG2CR & DMAMUX_RG2CR_SIG_ID) >> 0 ; }

// DMAMUX->RG3CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG3CR_GNBREQ = ((1UL<<5)-1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG3CR_GPOL = ((1UL<<2)-1) << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG3CR_GE = 1UL<<16, // DMA request generator channel enable/disable
	DMAMUX_RG3CR_OIE = 1UL<<8, // Interrupt enable at trigger event overrun
	DMAMUX_RG3CR_SIG_ID = ((1UL<<5)-1) << 0, // DMA request trigger input selected		
};
static inline void dmamux_rg3cr_set_gnbreq(uint32_t val) { DMAMUX.RG3CR = (DMAMUX.RG3CR & ~DMAMUX_RG3CR_GNBREQ) | ((val<<19) & DMAMUX_RG3CR_GNBREQ); }
static inline void dmamux_rg3cr_set_gpol(uint32_t val) { DMAMUX.RG3CR = (DMAMUX.RG3CR & ~DMAMUX_RG3CR_GPOL) | ((val<<17) & DMAMUX_RG3CR_GPOL); }
static inline void dmamux_rg3cr_set_sig_id(uint32_t val) { DMAMUX.RG3CR = (DMAMUX.RG3CR & ~DMAMUX_RG3CR_SIG_ID) | ((val<<0) & DMAMUX_RG3CR_SIG_ID); }
static inline uint32_t dmamux_rg3cr_get_gnbreq(void) { return (DMAMUX.RG3CR & DMAMUX_RG3CR_GNBREQ) >> 19 ; }
static inline uint32_t dmamux_rg3cr_get_gpol(void) { return (DMAMUX.RG3CR & DMAMUX_RG3CR_GPOL) >> 17 ; }
static inline uint32_t dmamux_rg3cr_get_sig_id(void) { return (DMAMUX.RG3CR & DMAMUX_RG3CR_SIG_ID) >> 0 ; }

// DMAMUX->RGSR DMAMux - DMA request generator status register
enum {
	DMAMUX_RGSR_OF = ((1UL<<4)-1) << 0, // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.		
};
static inline uint32_t dmamux_rgsr_get_of(void) { return (DMAMUX.RGSR & DMAMUX_RGSR_OF) >> 0 ; }

// DMAMUX->RGCFR DMAMux - DMA request generator clear flag register
enum {
	DMAMUX_RGCFR_COF = ((1UL<<4)-1) << 0, // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.		
};
static inline void dmamux_rgcfr_set_cof(uint32_t val) { DMAMUX.RGCFR = (DMAMUX.RGCFR & ~DMAMUX_RGCFR_COF) | ((val<<0) & DMAMUX_RGCFR_COF); }
static inline uint32_t dmamux_rgcfr_get_cof(void) { return (DMAMUX.RGCFR & DMAMUX_RGCFR_COF) >> 0 ; }

/* External interrupt/event controller
There is only one peripheral of type EXTI. */
struct EXTI_Type {
	__IO uint32_t IMR1; // @0 Interrupt mask register
	__IO uint32_t EMR1; // @4 Event mask register
	__IO uint32_t RTSR1; // @8 Rising Trigger selection register
	__IO uint32_t FTSR1; // @12 Falling Trigger selection register
	__IO uint32_t SWIER1; // @16 Software interrupt event register
	__IO uint32_t PR1; // @20 Pending register
	 uint8_t RESERVED0[8]; // @24 
	__IO uint32_t IMR2; // @32 Interrupt mask register
	__IO uint32_t EMR2; // @36 Event mask register
	__IO uint32_t RTSR2; // @40 Rising Trigger selection register
	__IO uint32_t FTSR2; // @44 Falling Trigger selection register
	__IO uint32_t SWIER2; // @48 Software interrupt event register
	__IO uint32_t PR2; // @52 Pending register
};
extern struct EXTI_Type	EXTI;	// @0x40010400 

// EXTI->RTSR1 Rising Trigger selection register
enum {
	EXTI_RTSR1_RT = ((1UL<<3)-1) << 29, // RT
	EXTI_RTSR1_RT22 = 1UL<<22, // Rising trigger event configuration of line 22
	EXTI_RTSR1_RT21 = 1UL<<21, // Rising trigger event configuration of line 21
	EXTI_RTSR1_RT20 = 1UL<<20, // Rising trigger event configuration of line 20
	EXTI_RTSR1_RT19 = 1UL<<19, // Rising trigger event configuration of line 19
	EXTI_RTSR1_RT18 = 1UL<<18, // Rising trigger event configuration of line 18
	EXTI_RTSR1_RT16 = 1UL<<16, // Rising trigger event configuration of line 16
	EXTI_RTSR1_RT15 = 1UL<<15, // Rising trigger event configuration of line 15
	EXTI_RTSR1_RT14 = 1UL<<14, // Rising trigger event configuration of line 14
	EXTI_RTSR1_RT13 = 1UL<<13, // Rising trigger event configuration of line 13
	EXTI_RTSR1_RT12 = 1UL<<12, // Rising trigger event configuration of line 12
	EXTI_RTSR1_RT11 = 1UL<<11, // Rising trigger event configuration of line 11
	EXTI_RTSR1_RT10 = 1UL<<10, // Rising trigger event configuration of line 10
	EXTI_RTSR1_RT9 = 1UL<<9, // Rising trigger event configuration of line 9
	EXTI_RTSR1_RT8 = 1UL<<8, // Rising trigger event configuration of line 8
	EXTI_RTSR1_RT7 = 1UL<<7, // Rising trigger event configuration of line 7
	EXTI_RTSR1_RT6 = 1UL<<6, // Rising trigger event configuration of line 6
	EXTI_RTSR1_RT5 = 1UL<<5, // Rising trigger event configuration of line 5
	EXTI_RTSR1_RT4 = 1UL<<4, // Rising trigger event configuration of line 4
	EXTI_RTSR1_RT3 = 1UL<<3, // Rising trigger event configuration of line 3
	EXTI_RTSR1_RT2 = 1UL<<2, // Rising trigger event configuration of line 2
	EXTI_RTSR1_RT1 = 1UL<<1, // Rising trigger event configuration of line 1
	EXTI_RTSR1_RT0 = 1UL<<0, // Rising trigger event configuration of line 0		
};
static inline void exti_rtsr1_set_rt(uint32_t val) { EXTI.RTSR1 = (EXTI.RTSR1 & ~EXTI_RTSR1_RT) | ((val<<29) & EXTI_RTSR1_RT); }
static inline uint32_t exti_rtsr1_get_rt(void) { return (EXTI.RTSR1 & EXTI_RTSR1_RT) >> 29 ; }

// EXTI->FTSR1 Falling Trigger selection register
enum {
	EXTI_FTSR1_FT22 = 1UL<<22, // Falling trigger event configuration of line 22
	EXTI_FTSR1_FT21 = 1UL<<21, // Falling trigger event configuration of line 21
	EXTI_FTSR1_FT20 = 1UL<<20, // Falling trigger event configuration of line 20
	EXTI_FTSR1_FT19 = 1UL<<19, // Falling trigger event configuration of line 19
	EXTI_FTSR1_FT18 = 1UL<<18, // Falling trigger event configuration of line 18
	EXTI_FTSR1_FT16 = 1UL<<16, // Falling trigger event configuration of line 16
	EXTI_FTSR1_FT15 = 1UL<<15, // Falling trigger event configuration of line 15
	EXTI_FTSR1_FT14 = 1UL<<14, // Falling trigger event configuration of line 14
	EXTI_FTSR1_FT13 = 1UL<<13, // Falling trigger event configuration of line 13
	EXTI_FTSR1_FT12 = 1UL<<12, // Falling trigger event configuration of line 12
	EXTI_FTSR1_FT11 = 1UL<<11, // Falling trigger event configuration of line 11
	EXTI_FTSR1_FT10 = 1UL<<10, // Falling trigger event configuration of line 10
	EXTI_FTSR1_FT9 = 1UL<<9, // Falling trigger event configuration of line 9
	EXTI_FTSR1_FT8 = 1UL<<8, // Falling trigger event configuration of line 8
	EXTI_FTSR1_FT7 = 1UL<<7, // Falling trigger event configuration of line 7
	EXTI_FTSR1_FT6 = 1UL<<6, // Falling trigger event configuration of line 6
	EXTI_FTSR1_FT5 = 1UL<<5, // Falling trigger event configuration of line 5
	EXTI_FTSR1_FT4 = 1UL<<4, // Falling trigger event configuration of line 4
	EXTI_FTSR1_FT3 = 1UL<<3, // Falling trigger event configuration of line 3
	EXTI_FTSR1_FT2 = 1UL<<2, // Falling trigger event configuration of line 2
	EXTI_FTSR1_FT1 = 1UL<<1, // Falling trigger event configuration of line 1
	EXTI_FTSR1_FT0 = 1UL<<0, // Falling trigger event configuration of line 0		
};

// EXTI->SWIER1 Software interrupt event register
enum {
	EXTI_SWIER1_SWI22 = 1UL<<22, // Software Interrupt on line 22
	EXTI_SWIER1_SWI21 = 1UL<<21, // Software Interrupt on line 21
	EXTI_SWIER1_SWI20 = 1UL<<20, // Software Interrupt on line 20
	EXTI_SWIER1_SWI19 = 1UL<<19, // Software Interrupt on line 19
	EXTI_SWIER1_SWI18 = 1UL<<18, // Software Interrupt on line 18
	EXTI_SWIER1_SWI16 = 1UL<<16, // Software Interrupt on line 16
	EXTI_SWIER1_SWI15 = 1UL<<15, // Software Interrupt on line 15
	EXTI_SWIER1_SWI14 = 1UL<<14, // Software Interrupt on line 14
	EXTI_SWIER1_SWI13 = 1UL<<13, // Software Interrupt on line 13
	EXTI_SWIER1_SWI12 = 1UL<<12, // Software Interrupt on line 12
	EXTI_SWIER1_SWI11 = 1UL<<11, // Software Interrupt on line 11
	EXTI_SWIER1_SWI10 = 1UL<<10, // Software Interrupt on line 10
	EXTI_SWIER1_SWI9 = 1UL<<9, // Software Interrupt on line 9
	EXTI_SWIER1_SWI8 = 1UL<<8, // Software Interrupt on line 8
	EXTI_SWIER1_SWI7 = 1UL<<7, // Software Interrupt on line 7
	EXTI_SWIER1_SWI6 = 1UL<<6, // Software Interrupt on line 6
	EXTI_SWIER1_SWI5 = 1UL<<5, // Software Interrupt on line 5
	EXTI_SWIER1_SWI4 = 1UL<<4, // Software Interrupt on line 4
	EXTI_SWIER1_SWI3 = 1UL<<3, // Software Interrupt on line 3
	EXTI_SWIER1_SWI2 = 1UL<<2, // Software Interrupt on line 2
	EXTI_SWIER1_SWI1 = 1UL<<1, // Software Interrupt on line 1
	EXTI_SWIER1_SWI0 = 1UL<<0, // Software Interrupt on line 0		
};

// EXTI->PR1 Pending register
enum {
	EXTI_PR1_PIF22 = 1UL<<22, // Pending bit 22
	EXTI_PR1_PIF21 = 1UL<<21, // Pending bit 21
	EXTI_PR1_PIF20 = 1UL<<20, // Pending bit 20
	EXTI_PR1_PIF19 = 1UL<<19, // Pending bit 19
	EXTI_PR1_PIF18 = 1UL<<18, // Pending bit 18
	EXTI_PR1_PIF16 = 1UL<<16, // Pending bit 16
	EXTI_PR1_PIF15 = 1UL<<15, // Pending bit 15
	EXTI_PR1_PIF14 = 1UL<<14, // Pending bit 14
	EXTI_PR1_PIF13 = 1UL<<13, // Pending bit 13
	EXTI_PR1_PIF12 = 1UL<<12, // Pending bit 12
	EXTI_PR1_PIF11 = 1UL<<11, // Pending bit 11
	EXTI_PR1_PIF10 = 1UL<<10, // Pending bit 10
	EXTI_PR1_PIF9 = 1UL<<9, // Pending bit 9
	EXTI_PR1_PIF8 = 1UL<<8, // Pending bit 8
	EXTI_PR1_PIF7 = 1UL<<7, // Pending bit 7
	EXTI_PR1_PIF6 = 1UL<<6, // Pending bit 6
	EXTI_PR1_PIF5 = 1UL<<5, // Pending bit 5
	EXTI_PR1_PIF4 = 1UL<<4, // Pending bit 4
	EXTI_PR1_PIF3 = 1UL<<3, // Pending bit 3
	EXTI_PR1_PIF2 = 1UL<<2, // Pending bit 2
	EXTI_PR1_PIF1 = 1UL<<1, // Pending bit 1
	EXTI_PR1_PIF0 = 1UL<<0, // Pending bit 0		
};

// EXTI->IMR2 Interrupt mask register
enum {
	EXTI_IMR2_IMX  = ((1UL<<12)-1) << 0, // Merged Interrupt Mask on external/internal line 43		
};
static inline void exti_imr2_set_imx (uint32_t val) { EXTI.IMR2 = (EXTI.IMR2 & ~EXTI_IMR2_IMX ) | ((val<<0) & EXTI_IMR2_IMX ); }
static inline uint32_t exti_imr2_get_imx (void) { return (EXTI.IMR2 & EXTI_IMR2_IMX ) >> 0 ; }

// EXTI->EMR2 Event mask register
enum {
	EXTI_EMR2_EMX  = ((1UL<<9)-1) << 0, // Merged Event mask on external/internal line 40		
};
static inline void exti_emr2_set_emx (uint32_t val) { EXTI.EMR2 = (EXTI.EMR2 & ~EXTI_EMR2_EMX ) | ((val<<0) & EXTI_EMR2_EMX ); }
static inline uint32_t exti_emr2_get_emx (void) { return (EXTI.EMR2 & EXTI_EMR2_EMX ) >> 0 ; }

// EXTI->RTSR2 Rising Trigger selection register
enum {
	EXTI_RTSR2_RT41 = 1UL<<9, // Rising trigger event configuration bit of line 41
	EXTI_RTSR2_RT40 = 1UL<<8, // Rising trigger event configuration bit of line 40
	EXTI_RTSR2_RT39 = 1UL<<7, // Rising trigger event configuration bit of line 39
	EXTI_RTSR2_RT38 = 1UL<<6, // Rising trigger event configuration bit of line 38
	EXTI_RTSR2_RT33 = 1UL<<1, // Rising trigger event configuration bit of line 32
	EXTI_RTSR2_RT32 = 1UL<<0, // Rising trigger event configuration bit of line 32		
};

// EXTI->FTSR2 Falling Trigger selection register
enum {
	EXTI_FTSR2_FT38 = 1UL<<6, // Falling trigger event configuration bit of line 38
	EXTI_FTSR2_FT37 = 1UL<<5, // Falling trigger event configuration bit of line 37
	EXTI_FTSR2_FT36 = 1UL<<4, // Falling trigger event configuration bit of line 36
	EXTI_FTSR2_FT35 = 1UL<<3, // Falling trigger event configuration bit of line 35		
};

// EXTI->SWIER2 Software interrupt event register
enum {
	EXTI_SWIER2_SWI38 = 1UL<<6, // Software interrupt on line 38
	EXTI_SWIER2_SWI37 = 1UL<<5, // Software interrupt on line 37
	EXTI_SWIER2_SWI36 = 1UL<<4, // Software interrupt on line 36
	EXTI_SWIER2_SWI35 = 1UL<<3, // Software interrupt on line 35		
};

// EXTI->PR2 Pending register
enum {
	EXTI_PR2_PIF38 = 1UL<<6, // Pending interrupt flag on line 38
	EXTI_PR2_PIF37 = 1UL<<5, // Pending interrupt flag on line 37
	EXTI_PR2_PIF36 = 1UL<<4, // Pending interrupt flag on line 36
	EXTI_PR2_PIF35 = 1UL<<3, // Pending interrupt flag on line 35		
};

/* FDCAN */
struct FDCAN_Type {
	__I uint32_t CREL; // @0 FDCAN Core Release Register
	__I uint32_t ENDN; // @4 FDCAN Core Release Register
	 uint8_t RESERVED0[4]; // @8 
	__IO uint32_t DBTP; // @12 This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in the range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
	__IO uint32_t TEST; // @16 Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
	__IO uint32_t RWD; // @20 The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM Watchdog Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when the Message RAM signals successful completion by activating its READY output. In case there is no response from the Message RAM until the counter has counted down to 0, the counter stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
	__IO uint32_t CCCR; // @24 For details about setting and resetting of single bits see Software initialization.
	__IO uint32_t NBTP; // @28 FDCAN_NBTP
	__IO uint32_t TSCC; // @32 FDCAN Timestamp Counter Configuration Register
	__I uint32_t TSCV; // @36 FDCAN Timestamp Counter Value Register
	__IO uint32_t TOCC; // @40 FDCAN Timeout Counter Configuration Register
	__I uint32_t TOCV; // @44 FDCAN Timeout Counter Value Register
	 uint8_t RESERVED1[16]; // @48 
	__I uint32_t ECR; // @64 FDCAN Error Counter Register
	__IO uint32_t PSR; // @68 FDCAN Protocol Status Register
	__IO uint32_t TDCR; // @72 FDCAN Transmitter Delay Compensation Register
	 uint8_t RESERVED2[4]; // @76 
	__IO uint32_t IR; // @80 The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
	__IO uint32_t IE; // @84 The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be signaled on an interrupt line.
	__IO uint32_t ILS; // @88 The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the Interrupt Register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via ILE[EINT0] and ILE[EINT1].
	__IO uint32_t ILE; // @92 Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
	 uint8_t RESERVED3[32]; // @96 
	__IO uint32_t RXGFC; // @128 Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for standard and extended messages as described in Figure706: Standard Message ID filter path and Figure707: Extended Message ID filter path.
	__IO uint32_t XIDAM; // @132 FDCAN Extended ID and Mask Register
	__I uint32_t HPMS; // @136 This register is updated every time a Message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
	 uint8_t RESERVED4[4]; // @140 
	__I uint32_t RXF0S; // @144 FDCAN Rx FIFO 0 Status Register
	__IO uint32_t RXF0A; // @148 CAN Rx FIFO 0 Acknowledge Register
	__I uint32_t RXF1S; // @152 FDCAN Rx FIFO 1 Status Register
	__IO uint32_t RXF1A; // @156 FDCAN Rx FIFO 1 Acknowledge Register
	 uint8_t RESERVED5[32]; // @160 
	__IO uint32_t TXBC; // @192 FDCAN Tx Buffer Configuration Register
	__I uint32_t TXFQS; // @196 The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the effect of Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
	__I uint32_t TXBRP; // @200 FDCAN Tx Buffer Request Pending Register
	__IO uint32_t TXBAR; // @204 FDCAN Tx Buffer Add Request Register
	__IO uint32_t TXBCR; // @208 FDCAN Tx Buffer Cancellation Request Register
	__I uint32_t TXBTO; // @212 FDCAN Tx Buffer Transmission Occurred Register
	__I uint32_t TXBCF; // @216 FDCAN Tx Buffer Cancellation Finished Register
	__IO uint32_t TXBTIE; // @220 FDCAN Tx Buffer Transmission Interrupt Enable Register
	__IO uint32_t TXBCIE; // @224 FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
	__I uint32_t TXEFS; // @228 FDCAN Tx Event FIFO Status Register
	__IO uint32_t TXEFA; // @232 FDCAN Tx Event FIFO Acknowledge Register
	 uint8_t RESERVED6[20]; // @236 
	__IO uint32_t CKDIV; // @256 FDCAN CFG clock divider register
};
extern struct FDCAN_Type	FDCAN1;	// @0x40006400 
extern struct FDCAN_Type 	FDCAN2;	// @0x40006800
extern struct FDCAN_Type 	FDCAN3;	// @0x40006C00

// FDCAN->CREL FDCAN Core Release Register
enum {
	FDCAN_CREL_REL = ((1UL<<4)-1) << 28, // REL
	FDCAN_CREL_STEP = ((1UL<<4)-1) << 24, // STEP
	FDCAN_CREL_SUBSTEP = ((1UL<<4)-1) << 20, // SUBSTEP
	FDCAN_CREL_YEAR = ((1UL<<4)-1) << 16, // YEAR
	FDCAN_CREL_MON = ((1UL<<8)-1) << 8, // MON
	FDCAN_CREL_DAY = ((1UL<<8)-1) << 0, // DAY		
};
static inline uint32_t fdcan_crel_get_rel(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_REL) >> 28 ; }
static inline uint32_t fdcan_crel_get_step(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_STEP) >> 24 ; }
static inline uint32_t fdcan_crel_get_substep(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_SUBSTEP) >> 20 ; }
static inline uint32_t fdcan_crel_get_year(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_YEAR) >> 16 ; }
static inline uint32_t fdcan_crel_get_mon(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_MON) >> 8 ; }
static inline uint32_t fdcan_crel_get_day(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_DAY) >> 0 ; }

// FDCAN->DBTP This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in the range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
enum {
	FDCAN_DBTP_TDC = 1UL<<23, // TDC
	FDCAN_DBTP_DBRP = ((1UL<<5)-1) << 16, // DBRP
	FDCAN_DBTP_DTSEG1 = ((1UL<<5)-1) << 8, // DTSEG1
	FDCAN_DBTP_DTSEG2 = ((1UL<<4)-1) << 4, // DTSEG2
	FDCAN_DBTP_DSJW = ((1UL<<4)-1) << 0, // DSJW		
};
static inline void fdcan_dbtp_set_dbrp(struct FDCAN_Type* p, uint32_t val) { p->DBTP = (p->DBTP & ~FDCAN_DBTP_DBRP) | ((val<<16) & FDCAN_DBTP_DBRP); }
static inline void fdcan_dbtp_set_dtseg1(struct FDCAN_Type* p, uint32_t val) { p->DBTP = (p->DBTP & ~FDCAN_DBTP_DTSEG1) | ((val<<8) & FDCAN_DBTP_DTSEG1); }
static inline void fdcan_dbtp_set_dtseg2(struct FDCAN_Type* p, uint32_t val) { p->DBTP = (p->DBTP & ~FDCAN_DBTP_DTSEG2) | ((val<<4) & FDCAN_DBTP_DTSEG2); }
static inline void fdcan_dbtp_set_dsjw(struct FDCAN_Type* p, uint32_t val) { p->DBTP = (p->DBTP & ~FDCAN_DBTP_DSJW) | ((val<<0) & FDCAN_DBTP_DSJW); }
static inline uint32_t fdcan_dbtp_get_dbrp(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DBRP) >> 16 ; }
static inline uint32_t fdcan_dbtp_get_dtseg1(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DTSEG1) >> 8 ; }
static inline uint32_t fdcan_dbtp_get_dtseg2(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DTSEG2) >> 4 ; }
static inline uint32_t fdcan_dbtp_get_dsjw(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DSJW) >> 0 ; }

// FDCAN->TEST Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
enum {
	FDCAN_TEST_RX = 1UL<<7, // RX
	FDCAN_TEST_TX = ((1UL<<2)-1) << 5, // TX
	FDCAN_TEST_LBCK = 1UL<<4, // LBCK		
};
static inline void fdcan_test_set_tx(struct FDCAN_Type* p, uint32_t val) { p->TEST = (p->TEST & ~FDCAN_TEST_TX) | ((val<<5) & FDCAN_TEST_TX); }
static inline uint32_t fdcan_test_get_tx(struct FDCAN_Type* p) { return (p->TEST & FDCAN_TEST_TX) >> 5 ; }

// FDCAN->RWD The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM Watchdog Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when the Message RAM signals successful completion by activating its READY output. In case there is no response from the Message RAM until the counter has counted down to 0, the counter stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
enum {
	FDCAN_RWD_WDV = ((1UL<<8)-1) << 8, // WDV
	FDCAN_RWD_WDC = ((1UL<<8)-1) << 0, // WDC		
};
static inline void fdcan_rwd_set_wdv(struct FDCAN_Type* p, uint32_t val) { p->RWD = (p->RWD & ~FDCAN_RWD_WDV) | ((val<<8) & FDCAN_RWD_WDV); }
static inline void fdcan_rwd_set_wdc(struct FDCAN_Type* p, uint32_t val) { p->RWD = (p->RWD & ~FDCAN_RWD_WDC) | ((val<<0) & FDCAN_RWD_WDC); }
static inline uint32_t fdcan_rwd_get_wdv(struct FDCAN_Type* p) { return (p->RWD & FDCAN_RWD_WDV) >> 8 ; }
static inline uint32_t fdcan_rwd_get_wdc(struct FDCAN_Type* p) { return (p->RWD & FDCAN_RWD_WDC) >> 0 ; }

// FDCAN->CCCR For details about setting and resetting of single bits see Software initialization.
enum {
	FDCAN_CCCR_NISO = 1UL<<15, // NISO
	FDCAN_CCCR_TXP = 1UL<<14, // TXP
	FDCAN_CCCR_EFBI = 1UL<<13, // EFBI
	FDCAN_CCCR_PXHD = 1UL<<12, // PXHD
	FDCAN_CCCR_BRSE = 1UL<<9, // BRSE
	FDCAN_CCCR_FDOE = 1UL<<8, // FDOE
	FDCAN_CCCR_TEST = 1UL<<7, // TEST
	FDCAN_CCCR_DAR = 1UL<<6, // DAR
	FDCAN_CCCR_MON = 1UL<<5, // MON
	FDCAN_CCCR_CSR = 1UL<<4, // CSR
	FDCAN_CCCR_CSA = 1UL<<3, // CSA
	FDCAN_CCCR_ASM = 1UL<<2, // ASM
	FDCAN_CCCR_CCE = 1UL<<1, // CCE
	FDCAN_CCCR_INIT = 1UL<<0, // INIT		
};

// FDCAN->NBTP FDCAN_NBTP
enum {
	FDCAN_NBTP_NSJW = ((1UL<<7)-1) << 25, // NSJW
	FDCAN_NBTP_NBRP = ((1UL<<9)-1) << 16, // NBRP
	FDCAN_NBTP_NTSEG1 = ((1UL<<8)-1) << 8, // NTSEG1
	FDCAN_NBTP_NTSEG2 = ((1UL<<7)-1) << 0, // NTSEG2		
};
static inline void fdcan_nbtp_set_nsjw(struct FDCAN_Type* p, uint32_t val) { p->NBTP = (p->NBTP & ~FDCAN_NBTP_NSJW) | ((val<<25) & FDCAN_NBTP_NSJW); }
static inline void fdcan_nbtp_set_nbrp(struct FDCAN_Type* p, uint32_t val) { p->NBTP = (p->NBTP & ~FDCAN_NBTP_NBRP) | ((val<<16) & FDCAN_NBTP_NBRP); }
static inline void fdcan_nbtp_set_ntseg1(struct FDCAN_Type* p, uint32_t val) { p->NBTP = (p->NBTP & ~FDCAN_NBTP_NTSEG1) | ((val<<8) & FDCAN_NBTP_NTSEG1); }
static inline void fdcan_nbtp_set_ntseg2(struct FDCAN_Type* p, uint32_t val) { p->NBTP = (p->NBTP & ~FDCAN_NBTP_NTSEG2) | ((val<<0) & FDCAN_NBTP_NTSEG2); }
static inline uint32_t fdcan_nbtp_get_nsjw(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NSJW) >> 25 ; }
static inline uint32_t fdcan_nbtp_get_nbrp(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NBRP) >> 16 ; }
static inline uint32_t fdcan_nbtp_get_ntseg1(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NTSEG1) >> 8 ; }
static inline uint32_t fdcan_nbtp_get_ntseg2(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NTSEG2) >> 0 ; }

// FDCAN->TSCC FDCAN Timestamp Counter Configuration Register
enum {
	FDCAN_TSCC_TCP = ((1UL<<4)-1) << 16, // TCP
	FDCAN_TSCC_TSS = ((1UL<<2)-1) << 0, // TSS		
};
static inline void fdcan_tscc_set_tcp(struct FDCAN_Type* p, uint32_t val) { p->TSCC = (p->TSCC & ~FDCAN_TSCC_TCP) | ((val<<16) & FDCAN_TSCC_TCP); }
static inline void fdcan_tscc_set_tss(struct FDCAN_Type* p, uint32_t val) { p->TSCC = (p->TSCC & ~FDCAN_TSCC_TSS) | ((val<<0) & FDCAN_TSCC_TSS); }
static inline uint32_t fdcan_tscc_get_tcp(struct FDCAN_Type* p) { return (p->TSCC & FDCAN_TSCC_TCP) >> 16 ; }
static inline uint32_t fdcan_tscc_get_tss(struct FDCAN_Type* p) { return (p->TSCC & FDCAN_TSCC_TSS) >> 0 ; }

// FDCAN->TSCV FDCAN Timestamp Counter Value Register
enum {
	FDCAN_TSCV_TSC = ((1UL<<16)-1) << 0, // TSC		
};
static inline uint32_t fdcan_tscv_get_tsc(struct FDCAN_Type* p) { return (p->TSCV & FDCAN_TSCV_TSC) >> 0 ; }

// FDCAN->TOCC FDCAN Timeout Counter Configuration Register
enum {
	FDCAN_TOCC_TOP = ((1UL<<16)-1) << 16, // TOP
	FDCAN_TOCC_TOS = ((1UL<<2)-1) << 1, // TOS
	FDCAN_TOCC_ETOC = 1UL<<0, // ETOC		
};
static inline void fdcan_tocc_set_top(struct FDCAN_Type* p, uint32_t val) { p->TOCC = (p->TOCC & ~FDCAN_TOCC_TOP) | ((val<<16) & FDCAN_TOCC_TOP); }
static inline void fdcan_tocc_set_tos(struct FDCAN_Type* p, uint32_t val) { p->TOCC = (p->TOCC & ~FDCAN_TOCC_TOS) | ((val<<1) & FDCAN_TOCC_TOS); }
static inline uint32_t fdcan_tocc_get_top(struct FDCAN_Type* p) { return (p->TOCC & FDCAN_TOCC_TOP) >> 16 ; }
static inline uint32_t fdcan_tocc_get_tos(struct FDCAN_Type* p) { return (p->TOCC & FDCAN_TOCC_TOS) >> 1 ; }

// FDCAN->TOCV FDCAN Timeout Counter Value Register
enum {
	FDCAN_TOCV_TOC = ((1UL<<16)-1) << 0, // TOC		
};
static inline uint32_t fdcan_tocv_get_toc(struct FDCAN_Type* p) { return (p->TOCV & FDCAN_TOCV_TOC) >> 0 ; }

// FDCAN->ECR FDCAN Error Counter Register
enum {
	FDCAN_ECR_CEL = ((1UL<<8)-1) << 16, // CEL
	FDCAN_ECR_RP = 1UL<<15, // RP
	FDCAN_ECR_REC = ((1UL<<7)-1) << 8, // TREC
	FDCAN_ECR_TEC = ((1UL<<8)-1) << 0, // TEC		
};
static inline uint32_t fdcan_ecr_get_cel(struct FDCAN_Type* p) { return (p->ECR & FDCAN_ECR_CEL) >> 16 ; }
static inline uint32_t fdcan_ecr_get_rec(struct FDCAN_Type* p) { return (p->ECR & FDCAN_ECR_REC) >> 8 ; }
static inline uint32_t fdcan_ecr_get_tec(struct FDCAN_Type* p) { return (p->ECR & FDCAN_ECR_TEC) >> 0 ; }

// FDCAN->PSR FDCAN Protocol Status Register
enum {
	FDCAN_PSR_TDCV = ((1UL<<7)-1) << 16, // TDCV
	FDCAN_PSR_PXE = 1UL<<14, // PXE
	FDCAN_PSR_REDL = 1UL<<13, // REDL
	FDCAN_PSR_RBRS = 1UL<<12, // RBRS
	FDCAN_PSR_RESI = 1UL<<11, // RESI
	FDCAN_PSR_DLEC = ((1UL<<3)-1) << 8, // DLEC
	FDCAN_PSR_BO = 1UL<<7, // BO
	FDCAN_PSR_EW = 1UL<<6, // EW
	FDCAN_PSR_EP = 1UL<<5, // EP
	FDCAN_PSR_ACT = ((1UL<<2)-1) << 3, // ACT
	FDCAN_PSR_LEC = ((1UL<<3)-1) << 0, // LEC		
};
static inline void fdcan_psr_set_tdcv(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_TDCV) | ((val<<16) & FDCAN_PSR_TDCV); }
static inline void fdcan_psr_set_dlec(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_DLEC) | ((val<<8) & FDCAN_PSR_DLEC); }
static inline void fdcan_psr_set_act(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_ACT) | ((val<<3) & FDCAN_PSR_ACT); }
static inline void fdcan_psr_set_lec(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_LEC) | ((val<<0) & FDCAN_PSR_LEC); }
static inline uint32_t fdcan_psr_get_tdcv(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_TDCV) >> 16 ; }
static inline uint32_t fdcan_psr_get_dlec(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_DLEC) >> 8 ; }
static inline uint32_t fdcan_psr_get_act(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_ACT) >> 3 ; }
static inline uint32_t fdcan_psr_get_lec(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_LEC) >> 0 ; }

// FDCAN->TDCR FDCAN Transmitter Delay Compensation Register
enum {
	FDCAN_TDCR_TDCO = ((1UL<<7)-1) << 8, // TDCO
	FDCAN_TDCR_TDCF = ((1UL<<7)-1) << 0, // TDCF		
};
static inline void fdcan_tdcr_set_tdco(struct FDCAN_Type* p, uint32_t val) { p->TDCR = (p->TDCR & ~FDCAN_TDCR_TDCO) | ((val<<8) & FDCAN_TDCR_TDCO); }
static inline void fdcan_tdcr_set_tdcf(struct FDCAN_Type* p, uint32_t val) { p->TDCR = (p->TDCR & ~FDCAN_TDCR_TDCF) | ((val<<0) & FDCAN_TDCR_TDCF); }
static inline uint32_t fdcan_tdcr_get_tdco(struct FDCAN_Type* p) { return (p->TDCR & FDCAN_TDCR_TDCO) >> 8 ; }
static inline uint32_t fdcan_tdcr_get_tdcf(struct FDCAN_Type* p) { return (p->TDCR & FDCAN_TDCR_TDCF) >> 0 ; }

// FDCAN->IR The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
enum {
	FDCAN_IR_ARA = 1UL<<23, // ARA
	FDCAN_IR_PED = 1UL<<22, // PED
	FDCAN_IR_PEA = 1UL<<21, // PEA
	FDCAN_IR_WDI = 1UL<<20, // WDI
	FDCAN_IR_BO = 1UL<<19, // BO
	FDCAN_IR_EW = 1UL<<18, // EW
	FDCAN_IR_EP = 1UL<<17, // EP
	FDCAN_IR_ELO = 1UL<<16, // ELO
	FDCAN_IR_TOO = 1UL<<15, // TOO
	FDCAN_IR_MRAF = 1UL<<14, // MRAF
	FDCAN_IR_TSW = 1UL<<13, // TSW
	FDCAN_IR_TEFL = 1UL<<12, // TEFL
	FDCAN_IR_TEFF = 1UL<<11, // TEFF
	FDCAN_IR_TEFN = 1UL<<10, // TEFN
	FDCAN_IR_TFE = 1UL<<9, // TFE
	FDCAN_IR_TCF = 1UL<<8, // TCF
	FDCAN_IR_TC = 1UL<<7, // TC
	FDCAN_IR_HPM = 1UL<<6, // HPM
	FDCAN_IR_RF1L = 1UL<<5, // RF1L
	FDCAN_IR_RF1F = 1UL<<4, // RF1F
	FDCAN_IR_RF1N = 1UL<<3, // RF1N
	FDCAN_IR_RF0L = 1UL<<2, // RF0L
	FDCAN_IR_RF0F = 1UL<<1, // RF0F
	FDCAN_IR_RF0N = 1UL<<0, // RF0N		
};

// FDCAN->IE The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be signaled on an interrupt line.
enum {
	FDCAN_IE_ARAE = 1UL<<23, // ARAE
	FDCAN_IE_PEDE = 1UL<<22, // PEDE
	FDCAN_IE_PEAE = 1UL<<21, // PEAE
	FDCAN_IE_WDIE = 1UL<<20, // WDIE
	FDCAN_IE_BOE = 1UL<<19, // BOE
	FDCAN_IE_EWE = 1UL<<18, // EWE
	FDCAN_IE_EPE = 1UL<<17, // EPE
	FDCAN_IE_ELOE = 1UL<<16, // ELOE
	FDCAN_IE_TOOE = 1UL<<15, // TOOE
	FDCAN_IE_MRAFE = 1UL<<14, // MRAFE
	FDCAN_IE_TSWE = 1UL<<13, // TSWE
	FDCAN_IE_TEFLE = 1UL<<12, // TEFLE
	FDCAN_IE_TEFFE = 1UL<<11, // TEFFE
	FDCAN_IE_TEFNE = 1UL<<10, // TEFNE
	FDCAN_IE_TFEE = 1UL<<9, // TFEE
	FDCAN_IE_TCFE = 1UL<<8, // TCFE
	FDCAN_IE_TCE = 1UL<<7, // TCE
	FDCAN_IE_HPME = 1UL<<6, // HPME
	FDCAN_IE_RF1LE = 1UL<<5, // RF1LE
	FDCAN_IE_RF1FE = 1UL<<4, // RF1FE
	FDCAN_IE_RF1NE = 1UL<<3, // RF1NE
	FDCAN_IE_RF0LE = 1UL<<2, // RF0LE
	FDCAN_IE_RF0FE = 1UL<<1, // RF0FE
	FDCAN_IE_RF0NE = 1UL<<0, // RF0NE		
};

// FDCAN->ILS The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the Interrupt Register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via ILE[EINT0] and ILE[EINT1].
enum {
	FDCAN_ILS_PERR = 1UL<<6, // PERR
	FDCAN_ILS_BERR = 1UL<<5, // BERR
	FDCAN_ILS_MISC = 1UL<<4, // MISC
	FDCAN_ILS_TFERR = 1UL<<3, // TFERR
	FDCAN_ILS_SMSG = 1UL<<2, // SMSG
	FDCAN_ILS_RXFIFO1 = 1UL<<1, // RxFIFO1
	FDCAN_ILS_RXFIFO0 = 1UL<<0, // RxFIFO0		
};

// FDCAN->ILE Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
enum {
	FDCAN_ILE_EINTX  = ((1UL<<2)-1) << 0, // Merged EINT1		
};
static inline void fdcan_ile_set_eintx (struct FDCAN_Type* p, uint32_t val) { p->ILE = (p->ILE & ~FDCAN_ILE_EINTX ) | ((val<<0) & FDCAN_ILE_EINTX ); }
static inline uint32_t fdcan_ile_get_eintx (struct FDCAN_Type* p) { return (p->ILE & FDCAN_ILE_EINTX ) >> 0 ; }

// FDCAN->RXGFC Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for standard and extended messages as described in Figure706: Standard Message ID filter path and Figure707: Extended Message ID filter path.
enum {
	FDCAN_RXGFC_LSE = ((1UL<<4)-1) << 24, // LSE
	FDCAN_RXGFC_LSS = ((1UL<<5)-1) << 16, // LSS
	FDCAN_RXGFC_F0OM = 1UL<<9, // F0OM
	FDCAN_RXGFC_F1OM = 1UL<<8, // F1OM
	FDCAN_RXGFC_ANFS = ((1UL<<2)-1) << 4, // ANFS
	FDCAN_RXGFC_ANFE = ((1UL<<2)-1) << 2, // ANFE
	FDCAN_RXGFC_RRFS = 1UL<<1, // RRFS
	FDCAN_RXGFC_RRFE = 1UL<<0, // RRFE		
};
static inline void fdcan_rxgfc_set_lse(struct FDCAN_Type* p, uint32_t val) { p->RXGFC = (p->RXGFC & ~FDCAN_RXGFC_LSE) | ((val<<24) & FDCAN_RXGFC_LSE); }
static inline void fdcan_rxgfc_set_lss(struct FDCAN_Type* p, uint32_t val) { p->RXGFC = (p->RXGFC & ~FDCAN_RXGFC_LSS) | ((val<<16) & FDCAN_RXGFC_LSS); }
static inline void fdcan_rxgfc_set_anfs(struct FDCAN_Type* p, uint32_t val) { p->RXGFC = (p->RXGFC & ~FDCAN_RXGFC_ANFS) | ((val<<4) & FDCAN_RXGFC_ANFS); }
static inline void fdcan_rxgfc_set_anfe(struct FDCAN_Type* p, uint32_t val) { p->RXGFC = (p->RXGFC & ~FDCAN_RXGFC_ANFE) | ((val<<2) & FDCAN_RXGFC_ANFE); }
static inline uint32_t fdcan_rxgfc_get_lse(struct FDCAN_Type* p) { return (p->RXGFC & FDCAN_RXGFC_LSE) >> 24 ; }
static inline uint32_t fdcan_rxgfc_get_lss(struct FDCAN_Type* p) { return (p->RXGFC & FDCAN_RXGFC_LSS) >> 16 ; }
static inline uint32_t fdcan_rxgfc_get_anfs(struct FDCAN_Type* p) { return (p->RXGFC & FDCAN_RXGFC_ANFS) >> 4 ; }
static inline uint32_t fdcan_rxgfc_get_anfe(struct FDCAN_Type* p) { return (p->RXGFC & FDCAN_RXGFC_ANFE) >> 2 ; }

// FDCAN->XIDAM FDCAN Extended ID and Mask Register
enum {
	FDCAN_XIDAM_EIDM = ((1UL<<29)-1) << 0, // EIDM		
};
static inline void fdcan_xidam_set_eidm(struct FDCAN_Type* p, uint32_t val) { p->XIDAM = (p->XIDAM & ~FDCAN_XIDAM_EIDM) | ((val<<0) & FDCAN_XIDAM_EIDM); }
static inline uint32_t fdcan_xidam_get_eidm(struct FDCAN_Type* p) { return (p->XIDAM & FDCAN_XIDAM_EIDM) >> 0 ; }

// FDCAN->HPMS This register is updated every time a Message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
enum {
	FDCAN_HPMS_FLST = 1UL<<15, // FLST
	FDCAN_HPMS_FIDX = ((1UL<<5)-1) << 8, // FIDX
	FDCAN_HPMS_MSI = ((1UL<<2)-1) << 6, // MSI
	FDCAN_HPMS_BIDX = ((1UL<<3)-1) << 0, // BIDX		
};
static inline uint32_t fdcan_hpms_get_fidx(struct FDCAN_Type* p) { return (p->HPMS & FDCAN_HPMS_FIDX) >> 8 ; }
static inline uint32_t fdcan_hpms_get_msi(struct FDCAN_Type* p) { return (p->HPMS & FDCAN_HPMS_MSI) >> 6 ; }
static inline uint32_t fdcan_hpms_get_bidx(struct FDCAN_Type* p) { return (p->HPMS & FDCAN_HPMS_BIDX) >> 0 ; }

// FDCAN->RXF0S FDCAN Rx FIFO 0 Status Register
enum {
	FDCAN_RXF0S_RF0L = 1UL<<25, // RF0L
	FDCAN_RXF0S_F0F = 1UL<<24, // F0F
	FDCAN_RXF0S_F0PI = ((1UL<<2)-1) << 16, // F0PI
	FDCAN_RXF0S_F0GI = ((1UL<<2)-1) << 8, // F0GI
	FDCAN_RXF0S_F0FL = ((1UL<<4)-1) << 0, // F0FL		
};
static inline uint32_t fdcan_rxf0s_get_f0pi(struct FDCAN_Type* p) { return (p->RXF0S & FDCAN_RXF0S_F0PI) >> 16 ; }
static inline uint32_t fdcan_rxf0s_get_f0gi(struct FDCAN_Type* p) { return (p->RXF0S & FDCAN_RXF0S_F0GI) >> 8 ; }
static inline uint32_t fdcan_rxf0s_get_f0fl(struct FDCAN_Type* p) { return (p->RXF0S & FDCAN_RXF0S_F0FL) >> 0 ; }

// FDCAN->RXF0A CAN Rx FIFO 0 Acknowledge Register
enum {
	FDCAN_RXF0A_F0AI = ((1UL<<3)-1) << 0, // F0AI		
};
static inline void fdcan_rxf0a_set_f0ai(struct FDCAN_Type* p, uint32_t val) { p->RXF0A = (p->RXF0A & ~FDCAN_RXF0A_F0AI) | ((val<<0) & FDCAN_RXF0A_F0AI); }
static inline uint32_t fdcan_rxf0a_get_f0ai(struct FDCAN_Type* p) { return (p->RXF0A & FDCAN_RXF0A_F0AI) >> 0 ; }

// FDCAN->RXF1S FDCAN Rx FIFO 1 Status Register
enum {
	FDCAN_RXF1S_RF1L = 1UL<<25, // RF1L
	FDCAN_RXF1S_F1F = 1UL<<24, // F1F
	FDCAN_RXF1S_F1PI = ((1UL<<2)-1) << 16, // F1PI
	FDCAN_RXF1S_F1GI = ((1UL<<2)-1) << 8, // F1GI
	FDCAN_RXF1S_F1FL = ((1UL<<4)-1) << 0, // F1FL		
};
static inline uint32_t fdcan_rxf1s_get_f1pi(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_F1PI) >> 16 ; }
static inline uint32_t fdcan_rxf1s_get_f1gi(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_F1GI) >> 8 ; }
static inline uint32_t fdcan_rxf1s_get_f1fl(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_F1FL) >> 0 ; }

// FDCAN->RXF1A FDCAN Rx FIFO 1 Acknowledge Register
enum {
	FDCAN_RXF1A_F1AI = ((1UL<<3)-1) << 0, // F1AI		
};
static inline void fdcan_rxf1a_set_f1ai(struct FDCAN_Type* p, uint32_t val) { p->RXF1A = (p->RXF1A & ~FDCAN_RXF1A_F1AI) | ((val<<0) & FDCAN_RXF1A_F1AI); }
static inline uint32_t fdcan_rxf1a_get_f1ai(struct FDCAN_Type* p) { return (p->RXF1A & FDCAN_RXF1A_F1AI) >> 0 ; }

// FDCAN->TXBC FDCAN Tx Buffer Configuration Register
enum {
	FDCAN_TXBC_TFQM = 1UL<<24, // TFQM		
};

// FDCAN->TXFQS The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the effect of Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
enum {
	FDCAN_TXFQS_TFQF = 1UL<<21, // TFQF
	FDCAN_TXFQS_TFQPI = ((1UL<<2)-1) << 16, // TFQPI
	FDCAN_TXFQS_TFGI = ((1UL<<2)-1) << 8, // TFGI
	FDCAN_TXFQS_TFFL = ((1UL<<3)-1) << 0, // TFFL		
};
static inline uint32_t fdcan_txfqs_get_tfqpi(struct FDCAN_Type* p) { return (p->TXFQS & FDCAN_TXFQS_TFQPI) >> 16 ; }
static inline uint32_t fdcan_txfqs_get_tfgi(struct FDCAN_Type* p) { return (p->TXFQS & FDCAN_TXFQS_TFGI) >> 8 ; }
static inline uint32_t fdcan_txfqs_get_tffl(struct FDCAN_Type* p) { return (p->TXFQS & FDCAN_TXFQS_TFFL) >> 0 ; }

// FDCAN->TXBRP FDCAN Tx Buffer Request Pending Register
enum {
	FDCAN_TXBRP_TRP = ((1UL<<3)-1) << 0, // TRP		
};
static inline uint32_t fdcan_txbrp_get_trp(struct FDCAN_Type* p) { return (p->TXBRP & FDCAN_TXBRP_TRP) >> 0 ; }

// FDCAN->TXBAR FDCAN Tx Buffer Add Request Register
enum {
	FDCAN_TXBAR_AR = ((1UL<<3)-1) << 0, // AR		
};
static inline void fdcan_txbar_set_ar(struct FDCAN_Type* p, uint32_t val) { p->TXBAR = (p->TXBAR & ~FDCAN_TXBAR_AR) | ((val<<0) & FDCAN_TXBAR_AR); }
static inline uint32_t fdcan_txbar_get_ar(struct FDCAN_Type* p) { return (p->TXBAR & FDCAN_TXBAR_AR) >> 0 ; }

// FDCAN->TXBCR FDCAN Tx Buffer Cancellation Request Register
enum {
	FDCAN_TXBCR_CR = ((1UL<<3)-1) << 0, // CR		
};
static inline void fdcan_txbcr_set_cr(struct FDCAN_Type* p, uint32_t val) { p->TXBCR = (p->TXBCR & ~FDCAN_TXBCR_CR) | ((val<<0) & FDCAN_TXBCR_CR); }
static inline uint32_t fdcan_txbcr_get_cr(struct FDCAN_Type* p) { return (p->TXBCR & FDCAN_TXBCR_CR) >> 0 ; }

// FDCAN->TXBTO FDCAN Tx Buffer Transmission Occurred Register
enum {
	FDCAN_TXBTO_TO = ((1UL<<3)-1) << 0, // TO		
};
static inline uint32_t fdcan_txbto_get_to(struct FDCAN_Type* p) { return (p->TXBTO & FDCAN_TXBTO_TO) >> 0 ; }

// FDCAN->TXBCF FDCAN Tx Buffer Cancellation Finished Register
enum {
	FDCAN_TXBCF_CF = ((1UL<<3)-1) << 0, // CF		
};
static inline uint32_t fdcan_txbcf_get_cf(struct FDCAN_Type* p) { return (p->TXBCF & FDCAN_TXBCF_CF) >> 0 ; }

// FDCAN->TXBTIE FDCAN Tx Buffer Transmission Interrupt Enable Register
enum {
	FDCAN_TXBTIE_TIE = ((1UL<<3)-1) << 0, // TIE		
};
static inline void fdcan_txbtie_set_tie(struct FDCAN_Type* p, uint32_t val) { p->TXBTIE = (p->TXBTIE & ~FDCAN_TXBTIE_TIE) | ((val<<0) & FDCAN_TXBTIE_TIE); }
static inline uint32_t fdcan_txbtie_get_tie(struct FDCAN_Type* p) { return (p->TXBTIE & FDCAN_TXBTIE_TIE) >> 0 ; }

// FDCAN->TXBCIE FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
enum {
	FDCAN_TXBCIE_CFIE = ((1UL<<3)-1) << 0, // CFIE		
};
static inline void fdcan_txbcie_set_cfie(struct FDCAN_Type* p, uint32_t val) { p->TXBCIE = (p->TXBCIE & ~FDCAN_TXBCIE_CFIE) | ((val<<0) & FDCAN_TXBCIE_CFIE); }
static inline uint32_t fdcan_txbcie_get_cfie(struct FDCAN_Type* p) { return (p->TXBCIE & FDCAN_TXBCIE_CFIE) >> 0 ; }

// FDCAN->TXEFS FDCAN Tx Event FIFO Status Register
enum {
	FDCAN_TXEFS_TEFL = 1UL<<25, // TEFL
	FDCAN_TXEFS_EFF = 1UL<<24, // EFF
	FDCAN_TXEFS_EFPI = ((1UL<<2)-1) << 16, // EFPI
	FDCAN_TXEFS_EFGI = ((1UL<<2)-1) << 8, // EFGI
	FDCAN_TXEFS_EFFL = ((1UL<<3)-1) << 0, // EFFL		
};
static inline uint32_t fdcan_txefs_get_efpi(struct FDCAN_Type* p) { return (p->TXEFS & FDCAN_TXEFS_EFPI) >> 16 ; }
static inline uint32_t fdcan_txefs_get_efgi(struct FDCAN_Type* p) { return (p->TXEFS & FDCAN_TXEFS_EFGI) >> 8 ; }
static inline uint32_t fdcan_txefs_get_effl(struct FDCAN_Type* p) { return (p->TXEFS & FDCAN_TXEFS_EFFL) >> 0 ; }

// FDCAN->TXEFA FDCAN Tx Event FIFO Acknowledge Register
enum {
	FDCAN_TXEFA_EFAI = ((1UL<<2)-1) << 0, // EFAI		
};
static inline void fdcan_txefa_set_efai(struct FDCAN_Type* p, uint32_t val) { p->TXEFA = (p->TXEFA & ~FDCAN_TXEFA_EFAI) | ((val<<0) & FDCAN_TXEFA_EFAI); }
static inline uint32_t fdcan_txefa_get_efai(struct FDCAN_Type* p) { return (p->TXEFA & FDCAN_TXEFA_EFAI) >> 0 ; }

// FDCAN->CKDIV FDCAN CFG clock divider register
enum {
	FDCAN_CKDIV_PDIV = ((1UL<<4)-1) << 0, // input clock divider. the APB clock could be divided prior to be used by the CAN sub		
};
static inline void fdcan_ckdiv_set_pdiv(struct FDCAN_Type* p, uint32_t val) { p->CKDIV = (p->CKDIV & ~FDCAN_CKDIV_PDIV) | ((val<<0) & FDCAN_CKDIV_PDIV); }
static inline uint32_t fdcan_ckdiv_get_pdiv(struct FDCAN_Type* p) { return (p->CKDIV & FDCAN_CKDIV_PDIV) >> 0 ; }



struct FDCANs_Message_RAM_Type {
	__IO uint32_t DUM; // @0 Dummy definition
};
extern struct FDCANs_Message_RAM_Type	FDCANs_Message_RAM;	// @0x4000A400 

/* Flash
There is only one peripheral of type FLASH. */
struct FLASH_Type {
	__IO uint32_t ACR; // @0 Access control register
	__O uint32_t PDKEYR; // @4 Power down key register
	__O uint32_t KEYR; // @8 Flash key register
	__O uint32_t OPTKEYR; // @12 Option byte key register
	__IO uint32_t SR; // @16 Status register
	__IO uint32_t CR; // @20 Flash control register
	__IO uint32_t ECCR; // @24 Flash ECC register
	 uint8_t RESERVED0[4]; // @28 
	__IO uint32_t OPTR; // @32 Flash option register
	__IO uint32_t PCROP1SR; // @36 Flash Bank 1 PCROP Start address register
	__IO uint32_t PCROP1ER; // @40 Flash Bank 1 PCROP End address register
	__IO uint32_t WRP1AR; // @44 Flash Bank 1 WRP area A address register
	__IO uint32_t WRP1BR; // @48 Flash Bank 1 WRP area B address register
	 uint8_t RESERVED1[60]; // @52 
	__IO uint32_t SEC1R; // @112 securable area bank1 register
};
extern struct FLASH_Type	FLASH;	// @0x40022000 

// FLASH->ACR Access control register
enum {
	FLASH_ACR_DBG_SWEN = 1UL<<18, // Debug software enable
	FLASH_ACR_SLEEP_PD = 1UL<<14, // Flash Power-down mode during Low-power sleep mode
	FLASH_ACR_RUN_PD = 1UL<<13, // Flash Power-down mode during Low-power run mode
	FLASH_ACR_DCRST = 1UL<<12, // Data cache reset
	FLASH_ACR_ICRST = 1UL<<11, // Instruction cache reset
	FLASH_ACR_DCEN = 1UL<<10, // Data cache enable
	FLASH_ACR_ICEN = 1UL<<9, // Instruction cache enable
	FLASH_ACR_PRFTEN = 1UL<<8, // Prefetch enable
	FLASH_ACR_LATENCY = ((1UL<<4)-1) << 0, // Latency		
};
static inline void flash_acr_set_latency(uint32_t val) { FLASH.ACR = (FLASH.ACR & ~FLASH_ACR_LATENCY) | ((val<<0) & FLASH_ACR_LATENCY); }
static inline uint32_t flash_acr_get_latency(void) { return (FLASH.ACR & FLASH_ACR_LATENCY) >> 0 ; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY = 1UL<<16, // Busy
	FLASH_SR_OPTVERR = 1UL<<15, // Option validity error
	FLASH_SR_RDERR = 1UL<<14, // PCROP read error
	FLASH_SR_FASTERR = 1UL<<9, // Fast programming error
	FLASH_SR_MISERR = 1UL<<8, // Fast programming data miss error
	FLASH_SR_PGSERR = 1UL<<7, // Programming sequence error
	FLASH_SR_SIZERR = 1UL<<6, // Size error
	FLASH_SR_PGAERR = 1UL<<5, // Programming alignment error
	FLASH_SR_WRPERR = 1UL<<4, // Write protected error
	FLASH_SR_PROGERR = 1UL<<3, // Programming error
	FLASH_SR_OPERR = 1UL<<1, // Operation error
	FLASH_SR_EOP = 1UL<<0, // End of operation		
};

// FLASH->CR Flash control register
enum {
	FLASH_CR_LOCK = 1UL<<31, // FLASH_CR Lock
	FLASH_CR_OPTLOCK = 1UL<<30, // Options Lock
	FLASH_CR_SEC_PROT1 = 1UL<<28, // SEC_PROT1
	FLASH_CR_OBL_LAUNCH = 1UL<<27, // Force the option byte loading
	FLASH_CR_RDERRIE = 1UL<<26, // PCROP read error interrupt enable
	FLASH_CR_ERRIE = 1UL<<25, // Error interrupt enable
	FLASH_CR_EOPIE = 1UL<<24, // End of operation interrupt enable
	FLASH_CR_FSTPG = 1UL<<18, // Fast programming
	FLASH_CR_OPTSTRT = 1UL<<17, // Options modification start
	FLASH_CR_STRT = 1UL<<16, // Start
	FLASH_CR_PNB = ((1UL<<7)-1) << 3, // Page number
	FLASH_CR_MER1 = 1UL<<2, // Bank 1 Mass erase
	FLASH_CR_PER = 1UL<<1, // Page erase
	FLASH_CR_PG = 1UL<<0, // Programming		
};
static inline void flash_cr_set_pnb(uint32_t val) { FLASH.CR = (FLASH.CR & ~FLASH_CR_PNB) | ((val<<3) & FLASH_CR_PNB); }
static inline uint32_t flash_cr_get_pnb(void) { return (FLASH.CR & FLASH_CR_PNB) >> 3 ; }

// FLASH->ECCR Flash ECC register
enum {
	FLASH_ECCR_ECCD = 1UL<<31, // ECC detection
	FLASH_ECCR_ECCC = 1UL<<30, // ECC correction
	FLASH_ECCR_ECCD2 = 1UL<<29, // ECC2 detection
	FLASH_ECCR_ECCC2 = 1UL<<28, // ECC correction
	FLASH_ECCR_ECCIE = 1UL<<24, // ECCIE
	FLASH_ECCR_SYSF_ECC = 1UL<<22, // SYSF_ECC
	FLASH_ECCR_BK_ECC = 1UL<<21, // BK_ECC
	FLASH_ECCR_ADDR_ECC = ((1UL<<19)-1) << 0, // ECC fail address		
};
static inline void flash_eccr_set_addr_ecc(uint32_t val) { FLASH.ECCR = (FLASH.ECCR & ~FLASH_ECCR_ADDR_ECC) | ((val<<0) & FLASH_ECCR_ADDR_ECC); }
static inline uint32_t flash_eccr_get_addr_ecc(void) { return (FLASH.ECCR & FLASH_ECCR_ADDR_ECC) >> 0 ; }

// FLASH->OPTR Flash option register
enum {
	FLASH_OPTR_IRHEN = 1UL<<30, // IRHEN
	FLASH_OPTR_NRST_MODE = ((1UL<<2)-1) << 28, // NRST_MODE
	FLASH_OPTR_NBOOT0 = 1UL<<27, // nBOOT0
	FLASH_OPTR_NSWBOOT0 = 1UL<<26, // nSWBOOT0
	FLASH_OPTR_CCMSRAM_RST = 1UL<<25, // CCM SRAM Erase when system reset
	FLASH_OPTR_SRAM2_PE = 1UL<<24, // SRAM2 parity check enable
	FLASH_OPTR_NBOOT1 = 1UL<<23, // Boot configuration
	FLASH_OPTR_DBANK = 1UL<<22, // DBANK
	FLASH_OPTR_BFB2 = 1UL<<20, // Dual-bank boot
	FLASH_OPTR_WWDG_SW = 1UL<<19, // Window watchdog selection
	FLASH_OPTR_IWDG_STDBY = 1UL<<18, // Independent watchdog counter freeze in Standby mode
	FLASH_OPTR_IWDG_STOP = 1UL<<17, // Independent watchdog counter freeze in Stop mode
	FLASH_OPTR_IWDG_SW = 1UL<<16, // Independent watchdog selection
	FLASH_OPTR_NRST_SHDW = 1UL<<14, // nRST_SHDW
	FLASH_OPTR_NRST_STDBY = 1UL<<13, // nRST_STDBY
	FLASH_OPTR_NRST_STOP = 1UL<<12, // nRST_STOP
	FLASH_OPTR_BOR_LEV = ((1UL<<3)-1) << 8, // BOR reset Level
	FLASH_OPTR_RDP = ((1UL<<8)-1) << 0, // Read protection level		
};
static inline void flash_optr_set_nrst_mode(uint32_t val) { FLASH.OPTR = (FLASH.OPTR & ~FLASH_OPTR_NRST_MODE) | ((val<<28) & FLASH_OPTR_NRST_MODE); }
static inline void flash_optr_set_bor_lev(uint32_t val) { FLASH.OPTR = (FLASH.OPTR & ~FLASH_OPTR_BOR_LEV) | ((val<<8) & FLASH_OPTR_BOR_LEV); }
static inline void flash_optr_set_rdp(uint32_t val) { FLASH.OPTR = (FLASH.OPTR & ~FLASH_OPTR_RDP) | ((val<<0) & FLASH_OPTR_RDP); }
static inline uint32_t flash_optr_get_nrst_mode(void) { return (FLASH.OPTR & FLASH_OPTR_NRST_MODE) >> 28 ; }
static inline uint32_t flash_optr_get_bor_lev(void) { return (FLASH.OPTR & FLASH_OPTR_BOR_LEV) >> 8 ; }
static inline uint32_t flash_optr_get_rdp(void) { return (FLASH.OPTR & FLASH_OPTR_RDP) >> 0 ; }

// FLASH->PCROP1SR Flash Bank 1 PCROP Start address register
enum {
	FLASH_PCROP1SR_PCROP1_STRT = ((1UL<<15)-1) << 0, // Bank 1 PCROP area start offset		
};
static inline void flash_pcrop1sr_set_pcrop1_strt(uint32_t val) { FLASH.PCROP1SR = (FLASH.PCROP1SR & ~FLASH_PCROP1SR_PCROP1_STRT) | ((val<<0) & FLASH_PCROP1SR_PCROP1_STRT); }
static inline uint32_t flash_pcrop1sr_get_pcrop1_strt(void) { return (FLASH.PCROP1SR & FLASH_PCROP1SR_PCROP1_STRT) >> 0 ; }

// FLASH->PCROP1ER Flash Bank 1 PCROP End address register
enum {
	FLASH_PCROP1ER_PCROP_RDP = 1UL<<31, // PCROP area preserved when RDP level decreased
	FLASH_PCROP1ER_PCROP1_END = ((1UL<<15)-1) << 0, // Bank 1 PCROP area end offset		
};
static inline void flash_pcrop1er_set_pcrop1_end(uint32_t val) { FLASH.PCROP1ER = (FLASH.PCROP1ER & ~FLASH_PCROP1ER_PCROP1_END) | ((val<<0) & FLASH_PCROP1ER_PCROP1_END); }
static inline uint32_t flash_pcrop1er_get_pcrop1_end(void) { return (FLASH.PCROP1ER & FLASH_PCROP1ER_PCROP1_END) >> 0 ; }

// FLASH->WRP1AR Flash Bank 1 WRP area A address register
enum {
	FLASH_WRP1AR_WRP1A_END = ((1UL<<7)-1) << 16, // Bank 1 WRP first area A end offset
	FLASH_WRP1AR_WRP1A_STRT = ((1UL<<7)-1) << 0, // Bank 1 WRP first area start offset		
};
static inline void flash_wrp1ar_set_wrp1a_end(uint32_t val) { FLASH.WRP1AR = (FLASH.WRP1AR & ~FLASH_WRP1AR_WRP1A_END) | ((val<<16) & FLASH_WRP1AR_WRP1A_END); }
static inline void flash_wrp1ar_set_wrp1a_strt(uint32_t val) { FLASH.WRP1AR = (FLASH.WRP1AR & ~FLASH_WRP1AR_WRP1A_STRT) | ((val<<0) & FLASH_WRP1AR_WRP1A_STRT); }
static inline uint32_t flash_wrp1ar_get_wrp1a_end(void) { return (FLASH.WRP1AR & FLASH_WRP1AR_WRP1A_END) >> 16 ; }
static inline uint32_t flash_wrp1ar_get_wrp1a_strt(void) { return (FLASH.WRP1AR & FLASH_WRP1AR_WRP1A_STRT) >> 0 ; }

// FLASH->WRP1BR Flash Bank 1 WRP area B address register
enum {
	FLASH_WRP1BR_WRP1B_END = ((1UL<<7)-1) << 16, // Bank 1 WRP second area B start offset
	FLASH_WRP1BR_WRP1B_STRT = ((1UL<<7)-1) << 0, // Bank 1 WRP second area B end offset		
};
static inline void flash_wrp1br_set_wrp1b_end(uint32_t val) { FLASH.WRP1BR = (FLASH.WRP1BR & ~FLASH_WRP1BR_WRP1B_END) | ((val<<16) & FLASH_WRP1BR_WRP1B_END); }
static inline void flash_wrp1br_set_wrp1b_strt(uint32_t val) { FLASH.WRP1BR = (FLASH.WRP1BR & ~FLASH_WRP1BR_WRP1B_STRT) | ((val<<0) & FLASH_WRP1BR_WRP1B_STRT); }
static inline uint32_t flash_wrp1br_get_wrp1b_end(void) { return (FLASH.WRP1BR & FLASH_WRP1BR_WRP1B_END) >> 16 ; }
static inline uint32_t flash_wrp1br_get_wrp1b_strt(void) { return (FLASH.WRP1BR & FLASH_WRP1BR_WRP1B_STRT) >> 0 ; }

// FLASH->SEC1R securable area bank1 register
enum {
	FLASH_SEC1R_BOOT_LOCK = 1UL<<16, // BOOT_LOCK
	FLASH_SEC1R_SEC_SIZE1 = ((1UL<<8)-1) << 0, // SEC_SIZE1		
};
static inline void flash_sec1r_set_sec_size1(uint32_t val) { FLASH.SEC1R = (FLASH.SEC1R & ~FLASH_SEC1R_SEC_SIZE1) | ((val<<0) & FLASH_SEC1R_SEC_SIZE1); }
static inline uint32_t flash_sec1r_get_sec_size1(void) { return (FLASH.SEC1R & FLASH_SEC1R_SEC_SIZE1) >> 0 ; }

/* Filter Math Accelerator
There is only one peripheral of type FMAC. */
struct FMAC_Type {
	__IO uint32_t X1BUFCFG; // @0 FMAC X1 Buffer Configuration register
	__IO uint32_t X2BUFCFG; // @4 FMAC X2 Buffer Configuration register
	__IO uint32_t YBUFCFG; // @8 FMAC Y Buffer Configuration register
	__IO uint32_t PARAM; // @12 FMAC Parameter register
	__IO uint32_t CR; // @16 FMAC Control register
	__I uint32_t SR; // @20 FMAC Status register
	__O uint32_t WDATA; // @24 FMAC Write Data register
	__I uint32_t RDATA; // @28 FMAC Read Data register
};
extern struct FMAC_Type	FMAC;	// @0x40021400 

// FMAC->X1BUFCFG FMAC X1 Buffer Configuration register
enum {
	FMAC_X1BUFCFG_FULL_WM = ((1UL<<2)-1) << 24, // FULL_WM
	FMAC_X1BUFCFG_X1_BUF_SIZE = ((1UL<<8)-1) << 8, // X1_BUF_SIZE
	FMAC_X1BUFCFG_X1_BASE = ((1UL<<8)-1) << 0, // X1_BASE		
};
static inline void fmac_x1bufcfg_set_full_wm(uint32_t val) { FMAC.X1BUFCFG = (FMAC.X1BUFCFG & ~FMAC_X1BUFCFG_FULL_WM) | ((val<<24) & FMAC_X1BUFCFG_FULL_WM); }
static inline void fmac_x1bufcfg_set_x1_buf_size(uint32_t val) { FMAC.X1BUFCFG = (FMAC.X1BUFCFG & ~FMAC_X1BUFCFG_X1_BUF_SIZE) | ((val<<8) & FMAC_X1BUFCFG_X1_BUF_SIZE); }
static inline void fmac_x1bufcfg_set_x1_base(uint32_t val) { FMAC.X1BUFCFG = (FMAC.X1BUFCFG & ~FMAC_X1BUFCFG_X1_BASE) | ((val<<0) & FMAC_X1BUFCFG_X1_BASE); }
static inline uint32_t fmac_x1bufcfg_get_full_wm(void) { return (FMAC.X1BUFCFG & FMAC_X1BUFCFG_FULL_WM) >> 24 ; }
static inline uint32_t fmac_x1bufcfg_get_x1_buf_size(void) { return (FMAC.X1BUFCFG & FMAC_X1BUFCFG_X1_BUF_SIZE) >> 8 ; }
static inline uint32_t fmac_x1bufcfg_get_x1_base(void) { return (FMAC.X1BUFCFG & FMAC_X1BUFCFG_X1_BASE) >> 0 ; }

// FMAC->X2BUFCFG FMAC X2 Buffer Configuration register
enum {
	FMAC_X2BUFCFG_X2_BUF_SIZE = ((1UL<<8)-1) << 8, // X1_BUF_SIZE
	FMAC_X2BUFCFG_X2_BASE = ((1UL<<8)-1) << 0, // X1_BASE		
};
static inline void fmac_x2bufcfg_set_x2_buf_size(uint32_t val) { FMAC.X2BUFCFG = (FMAC.X2BUFCFG & ~FMAC_X2BUFCFG_X2_BUF_SIZE) | ((val<<8) & FMAC_X2BUFCFG_X2_BUF_SIZE); }
static inline void fmac_x2bufcfg_set_x2_base(uint32_t val) { FMAC.X2BUFCFG = (FMAC.X2BUFCFG & ~FMAC_X2BUFCFG_X2_BASE) | ((val<<0) & FMAC_X2BUFCFG_X2_BASE); }
static inline uint32_t fmac_x2bufcfg_get_x2_buf_size(void) { return (FMAC.X2BUFCFG & FMAC_X2BUFCFG_X2_BUF_SIZE) >> 8 ; }
static inline uint32_t fmac_x2bufcfg_get_x2_base(void) { return (FMAC.X2BUFCFG & FMAC_X2BUFCFG_X2_BASE) >> 0 ; }

// FMAC->YBUFCFG FMAC Y Buffer Configuration register
enum {
	FMAC_YBUFCFG_EMPTY_WM = ((1UL<<2)-1) << 24, // EMPTY_WM
	FMAC_YBUFCFG_Y_BUF_SIZE = ((1UL<<8)-1) << 8, // X1_BUF_SIZE
	FMAC_YBUFCFG_Y_BASE = ((1UL<<8)-1) << 0, // X1_BASE		
};
static inline void fmac_ybufcfg_set_empty_wm(uint32_t val) { FMAC.YBUFCFG = (FMAC.YBUFCFG & ~FMAC_YBUFCFG_EMPTY_WM) | ((val<<24) & FMAC_YBUFCFG_EMPTY_WM); }
static inline void fmac_ybufcfg_set_y_buf_size(uint32_t val) { FMAC.YBUFCFG = (FMAC.YBUFCFG & ~FMAC_YBUFCFG_Y_BUF_SIZE) | ((val<<8) & FMAC_YBUFCFG_Y_BUF_SIZE); }
static inline void fmac_ybufcfg_set_y_base(uint32_t val) { FMAC.YBUFCFG = (FMAC.YBUFCFG & ~FMAC_YBUFCFG_Y_BASE) | ((val<<0) & FMAC_YBUFCFG_Y_BASE); }
static inline uint32_t fmac_ybufcfg_get_empty_wm(void) { return (FMAC.YBUFCFG & FMAC_YBUFCFG_EMPTY_WM) >> 24 ; }
static inline uint32_t fmac_ybufcfg_get_y_buf_size(void) { return (FMAC.YBUFCFG & FMAC_YBUFCFG_Y_BUF_SIZE) >> 8 ; }
static inline uint32_t fmac_ybufcfg_get_y_base(void) { return (FMAC.YBUFCFG & FMAC_YBUFCFG_Y_BASE) >> 0 ; }

// FMAC->PARAM FMAC Parameter register
enum {
	FMAC_PARAM_START = 1UL<<31, // START
	FMAC_PARAM_FUNC = ((1UL<<7)-1) << 24, // FUNC
	FMAC_PARAM_R = ((1UL<<8)-1) << 16, // R
	FMAC_PARAM_Q = ((1UL<<8)-1) << 8, // Q
	FMAC_PARAM_P = ((1UL<<8)-1) << 0, // P		
};
static inline void fmac_param_set_func(uint32_t val) { FMAC.PARAM = (FMAC.PARAM & ~FMAC_PARAM_FUNC) | ((val<<24) & FMAC_PARAM_FUNC); }
static inline void fmac_param_set_r(uint32_t val) { FMAC.PARAM = (FMAC.PARAM & ~FMAC_PARAM_R) | ((val<<16) & FMAC_PARAM_R); }
static inline void fmac_param_set_q(uint32_t val) { FMAC.PARAM = (FMAC.PARAM & ~FMAC_PARAM_Q) | ((val<<8) & FMAC_PARAM_Q); }
static inline void fmac_param_set_p(uint32_t val) { FMAC.PARAM = (FMAC.PARAM & ~FMAC_PARAM_P) | ((val<<0) & FMAC_PARAM_P); }
static inline uint32_t fmac_param_get_func(void) { return (FMAC.PARAM & FMAC_PARAM_FUNC) >> 24 ; }
static inline uint32_t fmac_param_get_r(void) { return (FMAC.PARAM & FMAC_PARAM_R) >> 16 ; }
static inline uint32_t fmac_param_get_q(void) { return (FMAC.PARAM & FMAC_PARAM_Q) >> 8 ; }
static inline uint32_t fmac_param_get_p(void) { return (FMAC.PARAM & FMAC_PARAM_P) >> 0 ; }

// FMAC->CR FMAC Control register
enum {
	FMAC_CR_RESET = 1UL<<16, // RESET
	FMAC_CR_CLIPEN = 1UL<<15, // CLIPEN
	FMAC_CR_DMAWEN = 1UL<<9, // DMAWEN
	FMAC_CR_DMAREN = 1UL<<8, // DMAREN
	FMAC_CR_SATIEN = 1UL<<4, // SATIEN
	FMAC_CR_UNFLIEN = 1UL<<3, // UNFLIEN
	FMAC_CR_OVFLIEN = 1UL<<2, // OVFLIEN
	FMAC_CR_WIEN = 1UL<<1, // WIEN
	FMAC_CR_RIEN = 1UL<<0, // RIEN		
};

// FMAC->SR FMAC Status register
enum {
	FMAC_SR_SAT = 1UL<<10, // SAT
	FMAC_SR_UNFL = 1UL<<9, // UNFL
	FMAC_SR_OVFL = 1UL<<8, // OVFL
	FMAC_SR_X1FULL = 1UL<<1, // X1FULL
	FMAC_SR_YEMPTY = 1UL<<0, // YEMPTY		
};

// FMAC->WDATA FMAC Write Data register
enum {
	FMAC_WDATA_WDATA = ((1UL<<16)-1) << 0, // WDATA		
};
static inline void fmac_wdata_set_wdata(uint32_t val) { FMAC.WDATA = (FMAC.WDATA & ~FMAC_WDATA_WDATA) | ((val<<0) & FMAC_WDATA_WDATA); }
static inline uint32_t fmac_wdata_get_wdata(void) { return (FMAC.WDATA & FMAC_WDATA_WDATA) >> 0 ; }

// FMAC->RDATA FMAC Read Data register
enum {
	FMAC_RDATA_RDATA = ((1UL<<16)-1) << 0, // RDATA		
};
static inline uint32_t fmac_rdata_get_rdata(void) { return (FMAC.RDATA & FMAC_RDATA_RDATA) >> 0 ; }

/* Flexible memory controller
There is only one peripheral of type FMC. */
struct FMC_Type {
	__IO uint32_t BCR1; // @0 SRAM/NOR-Flash chip-select control register 1
	__IO uint32_t BTR1; // @4 SRAM/NOR-Flash chip-select timing register 1
	__IO uint32_t BCR2; // @8 SRAM/NOR-Flash chip-select control register 2
	__IO uint32_t BTR2; // @12 SRAM/NOR-Flash chip-select timing register 2
	__IO uint32_t BCR3; // @16 SRAM/NOR-Flash chip-select control register 3
	__IO uint32_t BTR3; // @20 SRAM/NOR-Flash chip-select timing register 3
	__IO uint32_t BCR4; // @24 SRAM/NOR-Flash chip-select control register 4
	__IO uint32_t BTR4; // @28 SRAM/NOR-Flash chip-select timing register 4
	__IO uint32_t PCSCNTR; // @32 PSRAM chip select counter register
	 uint8_t RESERVED0[92]; // @36 
	__IO uint32_t PCR; // @128 PC Card/NAND Flash control register 3
	__IO uint32_t SR; // @132 FIFO status and interrupt register 3
	__IO uint32_t PMEM; // @136 Common memory space timing register 3
	__IO uint32_t PATT; // @140 Attribute memory space timing register 3
	 uint8_t RESERVED1[4]; // @144 
	__I uint32_t ECCR; // @148 ECC result register 3
	 uint8_t RESERVED2[108]; // @152 
	__IO uint32_t BWTR1; // @260 SRAM/NOR-Flash write timing registers 1
	 uint8_t RESERVED3[4]; // @264 
	__IO uint32_t BWTR2; // @268 SRAM/NOR-Flash write timing registers 2
	 uint8_t RESERVED4[4]; // @272 
	__IO uint32_t BWTR3; // @276 SRAM/NOR-Flash write timing registers 3
	 uint8_t RESERVED5[4]; // @280 
	__IO uint32_t BWTR4; // @284 SRAM/NOR-Flash write timing registers 4
};
extern struct FMC_Type	FMC;	// @0xA0000000 

// FMC->BCR1 SRAM/NOR-Flash chip-select control register 1
enum {
	FMC_BCR1_NBLSET = ((1UL<<2)-1) << 22, // NBLSET
	FMC_BCR1_WFDIS = 1UL<<21, // WFDIS
	FMC_BCR1_CCLKEN = 1UL<<20, // CCLKEN
	FMC_BCR1_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR1_CPSIZE = ((1UL<<3)-1) << 16, // CPSIZE
	FMC_BCR1_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR1_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR1_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR1_WREN = 1UL<<12, // WREN
	FMC_BCR1_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR1_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR1_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR1_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR1_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR1_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR1_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR1_MBKEN = 1UL<<0, // MBKEN		
};
static inline void fmc_bcr1_set_nblset(uint32_t val) { FMC.BCR1 = (FMC.BCR1 & ~FMC_BCR1_NBLSET) | ((val<<22) & FMC_BCR1_NBLSET); }
static inline void fmc_bcr1_set_cpsize(uint32_t val) { FMC.BCR1 = (FMC.BCR1 & ~FMC_BCR1_CPSIZE) | ((val<<16) & FMC_BCR1_CPSIZE); }
static inline void fmc_bcr1_set_mwid(uint32_t val) { FMC.BCR1 = (FMC.BCR1 & ~FMC_BCR1_MWID) | ((val<<4) & FMC_BCR1_MWID); }
static inline void fmc_bcr1_set_mtyp(uint32_t val) { FMC.BCR1 = (FMC.BCR1 & ~FMC_BCR1_MTYP) | ((val<<2) & FMC_BCR1_MTYP); }
static inline uint32_t fmc_bcr1_get_nblset(void) { return (FMC.BCR1 & FMC_BCR1_NBLSET) >> 22 ; }
static inline uint32_t fmc_bcr1_get_cpsize(void) { return (FMC.BCR1 & FMC_BCR1_CPSIZE) >> 16 ; }
static inline uint32_t fmc_bcr1_get_mwid(void) { return (FMC.BCR1 & FMC_BCR1_MWID) >> 4 ; }
static inline uint32_t fmc_bcr1_get_mtyp(void) { return (FMC.BCR1 & FMC_BCR1_MTYP) >> 2 ; }

// FMC->BTR1 SRAM/NOR-Flash chip-select timing register 1
enum {
	FMC_BTR1_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BTR1_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR1_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR1_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR1_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR1_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR1_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR1_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_btr1_set_datahld(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_DATAHLD) | ((val<<30) & FMC_BTR1_DATAHLD); }
static inline void fmc_btr1_set_accmod(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_ACCMOD) | ((val<<28) & FMC_BTR1_ACCMOD); }
static inline void fmc_btr1_set_datlat(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_DATLAT) | ((val<<24) & FMC_BTR1_DATLAT); }
static inline void fmc_btr1_set_clkdiv(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_CLKDIV) | ((val<<20) & FMC_BTR1_CLKDIV); }
static inline void fmc_btr1_set_busturn(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_BUSTURN) | ((val<<16) & FMC_BTR1_BUSTURN); }
static inline void fmc_btr1_set_datast(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_DATAST) | ((val<<8) & FMC_BTR1_DATAST); }
static inline void fmc_btr1_set_addhld(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_ADDHLD) | ((val<<4) & FMC_BTR1_ADDHLD); }
static inline void fmc_btr1_set_addset(uint32_t val) { FMC.BTR1 = (FMC.BTR1 & ~FMC_BTR1_ADDSET) | ((val<<0) & FMC_BTR1_ADDSET); }
static inline uint32_t fmc_btr1_get_datahld(void) { return (FMC.BTR1 & FMC_BTR1_DATAHLD) >> 30 ; }
static inline uint32_t fmc_btr1_get_accmod(void) { return (FMC.BTR1 & FMC_BTR1_ACCMOD) >> 28 ; }
static inline uint32_t fmc_btr1_get_datlat(void) { return (FMC.BTR1 & FMC_BTR1_DATLAT) >> 24 ; }
static inline uint32_t fmc_btr1_get_clkdiv(void) { return (FMC.BTR1 & FMC_BTR1_CLKDIV) >> 20 ; }
static inline uint32_t fmc_btr1_get_busturn(void) { return (FMC.BTR1 & FMC_BTR1_BUSTURN) >> 16 ; }
static inline uint32_t fmc_btr1_get_datast(void) { return (FMC.BTR1 & FMC_BTR1_DATAST) >> 8 ; }
static inline uint32_t fmc_btr1_get_addhld(void) { return (FMC.BTR1 & FMC_BTR1_ADDHLD) >> 4 ; }
static inline uint32_t fmc_btr1_get_addset(void) { return (FMC.BTR1 & FMC_BTR1_ADDSET) >> 0 ; }

// FMC->BCR2 SRAM/NOR-Flash chip-select control register 2
enum {
	FMC_BCR2_NBLSET = ((1UL<<2)-1) << 22, // NBLSET
	FMC_BCR2_WFDIS = 1UL<<21, // WFDIS
	FMC_BCR2_CCLKEN = 1UL<<20, // CCLKEN
	FMC_BCR2_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR2_CPSIZE = ((1UL<<3)-1) << 16, // CPSIZE
	FMC_BCR2_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR2_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR2_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR2_WREN = 1UL<<12, // WREN
	FMC_BCR2_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR2_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR2_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR2_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR2_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR2_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR2_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR2_MBKEN = 1UL<<0, // MBKEN		
};
static inline void fmc_bcr2_set_nblset(uint32_t val) { FMC.BCR2 = (FMC.BCR2 & ~FMC_BCR2_NBLSET) | ((val<<22) & FMC_BCR2_NBLSET); }
static inline void fmc_bcr2_set_cpsize(uint32_t val) { FMC.BCR2 = (FMC.BCR2 & ~FMC_BCR2_CPSIZE) | ((val<<16) & FMC_BCR2_CPSIZE); }
static inline void fmc_bcr2_set_mwid(uint32_t val) { FMC.BCR2 = (FMC.BCR2 & ~FMC_BCR2_MWID) | ((val<<4) & FMC_BCR2_MWID); }
static inline void fmc_bcr2_set_mtyp(uint32_t val) { FMC.BCR2 = (FMC.BCR2 & ~FMC_BCR2_MTYP) | ((val<<2) & FMC_BCR2_MTYP); }
static inline uint32_t fmc_bcr2_get_nblset(void) { return (FMC.BCR2 & FMC_BCR2_NBLSET) >> 22 ; }
static inline uint32_t fmc_bcr2_get_cpsize(void) { return (FMC.BCR2 & FMC_BCR2_CPSIZE) >> 16 ; }
static inline uint32_t fmc_bcr2_get_mwid(void) { return (FMC.BCR2 & FMC_BCR2_MWID) >> 4 ; }
static inline uint32_t fmc_bcr2_get_mtyp(void) { return (FMC.BCR2 & FMC_BCR2_MTYP) >> 2 ; }

// FMC->BTR2 SRAM/NOR-Flash chip-select timing register 2
enum {
	FMC_BTR2_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BTR2_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR2_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR2_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR2_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR2_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR2_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR2_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_btr2_set_datahld(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_DATAHLD) | ((val<<30) & FMC_BTR2_DATAHLD); }
static inline void fmc_btr2_set_accmod(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_ACCMOD) | ((val<<28) & FMC_BTR2_ACCMOD); }
static inline void fmc_btr2_set_datlat(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_DATLAT) | ((val<<24) & FMC_BTR2_DATLAT); }
static inline void fmc_btr2_set_clkdiv(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_CLKDIV) | ((val<<20) & FMC_BTR2_CLKDIV); }
static inline void fmc_btr2_set_busturn(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_BUSTURN) | ((val<<16) & FMC_BTR2_BUSTURN); }
static inline void fmc_btr2_set_datast(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_DATAST) | ((val<<8) & FMC_BTR2_DATAST); }
static inline void fmc_btr2_set_addhld(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_ADDHLD) | ((val<<4) & FMC_BTR2_ADDHLD); }
static inline void fmc_btr2_set_addset(uint32_t val) { FMC.BTR2 = (FMC.BTR2 & ~FMC_BTR2_ADDSET) | ((val<<0) & FMC_BTR2_ADDSET); }
static inline uint32_t fmc_btr2_get_datahld(void) { return (FMC.BTR2 & FMC_BTR2_DATAHLD) >> 30 ; }
static inline uint32_t fmc_btr2_get_accmod(void) { return (FMC.BTR2 & FMC_BTR2_ACCMOD) >> 28 ; }
static inline uint32_t fmc_btr2_get_datlat(void) { return (FMC.BTR2 & FMC_BTR2_DATLAT) >> 24 ; }
static inline uint32_t fmc_btr2_get_clkdiv(void) { return (FMC.BTR2 & FMC_BTR2_CLKDIV) >> 20 ; }
static inline uint32_t fmc_btr2_get_busturn(void) { return (FMC.BTR2 & FMC_BTR2_BUSTURN) >> 16 ; }
static inline uint32_t fmc_btr2_get_datast(void) { return (FMC.BTR2 & FMC_BTR2_DATAST) >> 8 ; }
static inline uint32_t fmc_btr2_get_addhld(void) { return (FMC.BTR2 & FMC_BTR2_ADDHLD) >> 4 ; }
static inline uint32_t fmc_btr2_get_addset(void) { return (FMC.BTR2 & FMC_BTR2_ADDSET) >> 0 ; }

// FMC->BCR3 SRAM/NOR-Flash chip-select control register 3
enum {
	FMC_BCR3_NBLSET = ((1UL<<2)-1) << 22, // NBLSET
	FMC_BCR3_WFDIS = 1UL<<21, // WFDIS
	FMC_BCR3_CCLKEN = 1UL<<20, // CCLKEN
	FMC_BCR3_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR3_CPSIZE = ((1UL<<3)-1) << 16, // CPSIZE
	FMC_BCR3_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR3_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR3_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR3_WREN = 1UL<<12, // WREN
	FMC_BCR3_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR3_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR3_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR3_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR3_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR3_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR3_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR3_MBKEN = 1UL<<0, // MBKEN		
};
static inline void fmc_bcr3_set_nblset(uint32_t val) { FMC.BCR3 = (FMC.BCR3 & ~FMC_BCR3_NBLSET) | ((val<<22) & FMC_BCR3_NBLSET); }
static inline void fmc_bcr3_set_cpsize(uint32_t val) { FMC.BCR3 = (FMC.BCR3 & ~FMC_BCR3_CPSIZE) | ((val<<16) & FMC_BCR3_CPSIZE); }
static inline void fmc_bcr3_set_mwid(uint32_t val) { FMC.BCR3 = (FMC.BCR3 & ~FMC_BCR3_MWID) | ((val<<4) & FMC_BCR3_MWID); }
static inline void fmc_bcr3_set_mtyp(uint32_t val) { FMC.BCR3 = (FMC.BCR3 & ~FMC_BCR3_MTYP) | ((val<<2) & FMC_BCR3_MTYP); }
static inline uint32_t fmc_bcr3_get_nblset(void) { return (FMC.BCR3 & FMC_BCR3_NBLSET) >> 22 ; }
static inline uint32_t fmc_bcr3_get_cpsize(void) { return (FMC.BCR3 & FMC_BCR3_CPSIZE) >> 16 ; }
static inline uint32_t fmc_bcr3_get_mwid(void) { return (FMC.BCR3 & FMC_BCR3_MWID) >> 4 ; }
static inline uint32_t fmc_bcr3_get_mtyp(void) { return (FMC.BCR3 & FMC_BCR3_MTYP) >> 2 ; }

// FMC->BTR3 SRAM/NOR-Flash chip-select timing register 3
enum {
	FMC_BTR3_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BTR3_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR3_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR3_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR3_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR3_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR3_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR3_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_btr3_set_datahld(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_DATAHLD) | ((val<<30) & FMC_BTR3_DATAHLD); }
static inline void fmc_btr3_set_accmod(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_ACCMOD) | ((val<<28) & FMC_BTR3_ACCMOD); }
static inline void fmc_btr3_set_datlat(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_DATLAT) | ((val<<24) & FMC_BTR3_DATLAT); }
static inline void fmc_btr3_set_clkdiv(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_CLKDIV) | ((val<<20) & FMC_BTR3_CLKDIV); }
static inline void fmc_btr3_set_busturn(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_BUSTURN) | ((val<<16) & FMC_BTR3_BUSTURN); }
static inline void fmc_btr3_set_datast(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_DATAST) | ((val<<8) & FMC_BTR3_DATAST); }
static inline void fmc_btr3_set_addhld(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_ADDHLD) | ((val<<4) & FMC_BTR3_ADDHLD); }
static inline void fmc_btr3_set_addset(uint32_t val) { FMC.BTR3 = (FMC.BTR3 & ~FMC_BTR3_ADDSET) | ((val<<0) & FMC_BTR3_ADDSET); }
static inline uint32_t fmc_btr3_get_datahld(void) { return (FMC.BTR3 & FMC_BTR3_DATAHLD) >> 30 ; }
static inline uint32_t fmc_btr3_get_accmod(void) { return (FMC.BTR3 & FMC_BTR3_ACCMOD) >> 28 ; }
static inline uint32_t fmc_btr3_get_datlat(void) { return (FMC.BTR3 & FMC_BTR3_DATLAT) >> 24 ; }
static inline uint32_t fmc_btr3_get_clkdiv(void) { return (FMC.BTR3 & FMC_BTR3_CLKDIV) >> 20 ; }
static inline uint32_t fmc_btr3_get_busturn(void) { return (FMC.BTR3 & FMC_BTR3_BUSTURN) >> 16 ; }
static inline uint32_t fmc_btr3_get_datast(void) { return (FMC.BTR3 & FMC_BTR3_DATAST) >> 8 ; }
static inline uint32_t fmc_btr3_get_addhld(void) { return (FMC.BTR3 & FMC_BTR3_ADDHLD) >> 4 ; }
static inline uint32_t fmc_btr3_get_addset(void) { return (FMC.BTR3 & FMC_BTR3_ADDSET) >> 0 ; }

// FMC->BCR4 SRAM/NOR-Flash chip-select control register 4
enum {
	FMC_BCR4_NBLSET = ((1UL<<2)-1) << 22, // NBLSET
	FMC_BCR4_WFDIS = 1UL<<21, // WFDIS
	FMC_BCR4_CCLKEN = 1UL<<20, // CCLKEN
	FMC_BCR4_CBURSTRW = 1UL<<19, // CBURSTRW
	FMC_BCR4_CPSIZE = ((1UL<<3)-1) << 16, // CPSIZE
	FMC_BCR4_ASYNCWAIT = 1UL<<15, // ASYNCWAIT
	FMC_BCR4_EXTMOD = 1UL<<14, // EXTMOD
	FMC_BCR4_WAITEN = 1UL<<13, // WAITEN
	FMC_BCR4_WREN = 1UL<<12, // WREN
	FMC_BCR4_WAITCFG = 1UL<<11, // WAITCFG
	FMC_BCR4_WAITPOL = 1UL<<9, // WAITPOL
	FMC_BCR4_BURSTEN = 1UL<<8, // BURSTEN
	FMC_BCR4_FACCEN = 1UL<<6, // FACCEN
	FMC_BCR4_MWID = ((1UL<<2)-1) << 4, // MWID
	FMC_BCR4_MTYP = ((1UL<<2)-1) << 2, // MTYP
	FMC_BCR4_MUXEN = 1UL<<1, // MUXEN
	FMC_BCR4_MBKEN = 1UL<<0, // MBKEN		
};
static inline void fmc_bcr4_set_nblset(uint32_t val) { FMC.BCR4 = (FMC.BCR4 & ~FMC_BCR4_NBLSET) | ((val<<22) & FMC_BCR4_NBLSET); }
static inline void fmc_bcr4_set_cpsize(uint32_t val) { FMC.BCR4 = (FMC.BCR4 & ~FMC_BCR4_CPSIZE) | ((val<<16) & FMC_BCR4_CPSIZE); }
static inline void fmc_bcr4_set_mwid(uint32_t val) { FMC.BCR4 = (FMC.BCR4 & ~FMC_BCR4_MWID) | ((val<<4) & FMC_BCR4_MWID); }
static inline void fmc_bcr4_set_mtyp(uint32_t val) { FMC.BCR4 = (FMC.BCR4 & ~FMC_BCR4_MTYP) | ((val<<2) & FMC_BCR4_MTYP); }
static inline uint32_t fmc_bcr4_get_nblset(void) { return (FMC.BCR4 & FMC_BCR4_NBLSET) >> 22 ; }
static inline uint32_t fmc_bcr4_get_cpsize(void) { return (FMC.BCR4 & FMC_BCR4_CPSIZE) >> 16 ; }
static inline uint32_t fmc_bcr4_get_mwid(void) { return (FMC.BCR4 & FMC_BCR4_MWID) >> 4 ; }
static inline uint32_t fmc_bcr4_get_mtyp(void) { return (FMC.BCR4 & FMC_BCR4_MTYP) >> 2 ; }

// FMC->BTR4 SRAM/NOR-Flash chip-select timing register 4
enum {
	FMC_BTR4_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BTR4_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BTR4_DATLAT = ((1UL<<4)-1) << 24, // DATLAT
	FMC_BTR4_CLKDIV = ((1UL<<4)-1) << 20, // CLKDIV
	FMC_BTR4_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BTR4_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BTR4_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BTR4_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_btr4_set_datahld(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_DATAHLD) | ((val<<30) & FMC_BTR4_DATAHLD); }
static inline void fmc_btr4_set_accmod(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_ACCMOD) | ((val<<28) & FMC_BTR4_ACCMOD); }
static inline void fmc_btr4_set_datlat(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_DATLAT) | ((val<<24) & FMC_BTR4_DATLAT); }
static inline void fmc_btr4_set_clkdiv(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_CLKDIV) | ((val<<20) & FMC_BTR4_CLKDIV); }
static inline void fmc_btr4_set_busturn(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_BUSTURN) | ((val<<16) & FMC_BTR4_BUSTURN); }
static inline void fmc_btr4_set_datast(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_DATAST) | ((val<<8) & FMC_BTR4_DATAST); }
static inline void fmc_btr4_set_addhld(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_ADDHLD) | ((val<<4) & FMC_BTR4_ADDHLD); }
static inline void fmc_btr4_set_addset(uint32_t val) { FMC.BTR4 = (FMC.BTR4 & ~FMC_BTR4_ADDSET) | ((val<<0) & FMC_BTR4_ADDSET); }
static inline uint32_t fmc_btr4_get_datahld(void) { return (FMC.BTR4 & FMC_BTR4_DATAHLD) >> 30 ; }
static inline uint32_t fmc_btr4_get_accmod(void) { return (FMC.BTR4 & FMC_BTR4_ACCMOD) >> 28 ; }
static inline uint32_t fmc_btr4_get_datlat(void) { return (FMC.BTR4 & FMC_BTR4_DATLAT) >> 24 ; }
static inline uint32_t fmc_btr4_get_clkdiv(void) { return (FMC.BTR4 & FMC_BTR4_CLKDIV) >> 20 ; }
static inline uint32_t fmc_btr4_get_busturn(void) { return (FMC.BTR4 & FMC_BTR4_BUSTURN) >> 16 ; }
static inline uint32_t fmc_btr4_get_datast(void) { return (FMC.BTR4 & FMC_BTR4_DATAST) >> 8 ; }
static inline uint32_t fmc_btr4_get_addhld(void) { return (FMC.BTR4 & FMC_BTR4_ADDHLD) >> 4 ; }
static inline uint32_t fmc_btr4_get_addset(void) { return (FMC.BTR4 & FMC_BTR4_ADDSET) >> 0 ; }

// FMC->PCSCNTR PSRAM chip select counter register
enum {
	FMC_PCSCNTR_CNTB4EN = 1UL<<19, // CNTB4EN
	FMC_PCSCNTR_CNTB3EN = 1UL<<18, // CNTB3EN
	FMC_PCSCNTR_CNTB2EN = 1UL<<17, // CNTB2EN
	FMC_PCSCNTR_CNTB1EN = 1UL<<16, // CNTB1EN
	FMC_PCSCNTR_CSCOUNT = ((1UL<<16)-1) << 0, // CSCOUNT		
};
static inline void fmc_pcscntr_set_cscount(uint32_t val) { FMC.PCSCNTR = (FMC.PCSCNTR & ~FMC_PCSCNTR_CSCOUNT) | ((val<<0) & FMC_PCSCNTR_CSCOUNT); }
static inline uint32_t fmc_pcscntr_get_cscount(void) { return (FMC.PCSCNTR & FMC_PCSCNTR_CSCOUNT) >> 0 ; }

// FMC->PCR PC Card/NAND Flash control register 3
enum {
	FMC_PCR_ECCPS = ((1UL<<3)-1) << 17, // ECCPS
	FMC_PCR_TAR = ((1UL<<4)-1) << 13, // TAR
	FMC_PCR_TCLR = ((1UL<<4)-1) << 9, // TCLR
	FMC_PCR_ECCEN = 1UL<<6, // ECCEN
	FMC_PCR_PWID = ((1UL<<2)-1) << 4, // PWID
	FMC_PCR_PTYP = 1UL<<3, // PTYP
	FMC_PCR_PBKEN = 1UL<<2, // PBKEN
	FMC_PCR_PWAITEN = 1UL<<1, // PWAITEN		
};
static inline void fmc_pcr_set_eccps(uint32_t val) { FMC.PCR = (FMC.PCR & ~FMC_PCR_ECCPS) | ((val<<17) & FMC_PCR_ECCPS); }
static inline void fmc_pcr_set_tar(uint32_t val) { FMC.PCR = (FMC.PCR & ~FMC_PCR_TAR) | ((val<<13) & FMC_PCR_TAR); }
static inline void fmc_pcr_set_tclr(uint32_t val) { FMC.PCR = (FMC.PCR & ~FMC_PCR_TCLR) | ((val<<9) & FMC_PCR_TCLR); }
static inline void fmc_pcr_set_pwid(uint32_t val) { FMC.PCR = (FMC.PCR & ~FMC_PCR_PWID) | ((val<<4) & FMC_PCR_PWID); }
static inline uint32_t fmc_pcr_get_eccps(void) { return (FMC.PCR & FMC_PCR_ECCPS) >> 17 ; }
static inline uint32_t fmc_pcr_get_tar(void) { return (FMC.PCR & FMC_PCR_TAR) >> 13 ; }
static inline uint32_t fmc_pcr_get_tclr(void) { return (FMC.PCR & FMC_PCR_TCLR) >> 9 ; }
static inline uint32_t fmc_pcr_get_pwid(void) { return (FMC.PCR & FMC_PCR_PWID) >> 4 ; }

// FMC->SR FIFO status and interrupt register 3
enum {
	FMC_SR_FEMPT = 1UL<<6, // FEMPT
	FMC_SR_IFEN = 1UL<<5, // IFEN
	FMC_SR_ILEN = 1UL<<4, // ILEN
	FMC_SR_IREN = 1UL<<3, // IREN
	FMC_SR_IFS = 1UL<<2, // IFS
	FMC_SR_ILS = 1UL<<1, // ILS
	FMC_SR_IRS = 1UL<<0, // IRS		
};

// FMC->PMEM Common memory space timing register 3
enum {
	FMC_PMEM_MEMHIZX = ((1UL<<8)-1) << 24, // MEMHIZx
	FMC_PMEM_MEMHOLDX = ((1UL<<8)-1) << 16, // MEMHOLDx
	FMC_PMEM_MEMWAITX = ((1UL<<8)-1) << 8, // MEMWAITx
	FMC_PMEM_MEMSETX = ((1UL<<8)-1) << 0, // MEMSETx		
};
static inline void fmc_pmem_set_memhizx(uint32_t val) { FMC.PMEM = (FMC.PMEM & ~FMC_PMEM_MEMHIZX) | ((val<<24) & FMC_PMEM_MEMHIZX); }
static inline void fmc_pmem_set_memholdx(uint32_t val) { FMC.PMEM = (FMC.PMEM & ~FMC_PMEM_MEMHOLDX) | ((val<<16) & FMC_PMEM_MEMHOLDX); }
static inline void fmc_pmem_set_memwaitx(uint32_t val) { FMC.PMEM = (FMC.PMEM & ~FMC_PMEM_MEMWAITX) | ((val<<8) & FMC_PMEM_MEMWAITX); }
static inline void fmc_pmem_set_memsetx(uint32_t val) { FMC.PMEM = (FMC.PMEM & ~FMC_PMEM_MEMSETX) | ((val<<0) & FMC_PMEM_MEMSETX); }
static inline uint32_t fmc_pmem_get_memhizx(void) { return (FMC.PMEM & FMC_PMEM_MEMHIZX) >> 24 ; }
static inline uint32_t fmc_pmem_get_memholdx(void) { return (FMC.PMEM & FMC_PMEM_MEMHOLDX) >> 16 ; }
static inline uint32_t fmc_pmem_get_memwaitx(void) { return (FMC.PMEM & FMC_PMEM_MEMWAITX) >> 8 ; }
static inline uint32_t fmc_pmem_get_memsetx(void) { return (FMC.PMEM & FMC_PMEM_MEMSETX) >> 0 ; }

// FMC->PATT Attribute memory space timing register 3
enum {
	FMC_PATT_ATTHIZX = ((1UL<<8)-1) << 24, // ATTHIZx
	FMC_PATT_ATTHOLDX = ((1UL<<8)-1) << 16, // ATTHOLDx
	FMC_PATT_ATTWAITX = ((1UL<<8)-1) << 8, // ATTWAITx
	FMC_PATT_ATTSETX = ((1UL<<8)-1) << 0, // ATTSETx		
};
static inline void fmc_patt_set_atthizx(uint32_t val) { FMC.PATT = (FMC.PATT & ~FMC_PATT_ATTHIZX) | ((val<<24) & FMC_PATT_ATTHIZX); }
static inline void fmc_patt_set_attholdx(uint32_t val) { FMC.PATT = (FMC.PATT & ~FMC_PATT_ATTHOLDX) | ((val<<16) & FMC_PATT_ATTHOLDX); }
static inline void fmc_patt_set_attwaitx(uint32_t val) { FMC.PATT = (FMC.PATT & ~FMC_PATT_ATTWAITX) | ((val<<8) & FMC_PATT_ATTWAITX); }
static inline void fmc_patt_set_attsetx(uint32_t val) { FMC.PATT = (FMC.PATT & ~FMC_PATT_ATTSETX) | ((val<<0) & FMC_PATT_ATTSETX); }
static inline uint32_t fmc_patt_get_atthizx(void) { return (FMC.PATT & FMC_PATT_ATTHIZX) >> 24 ; }
static inline uint32_t fmc_patt_get_attholdx(void) { return (FMC.PATT & FMC_PATT_ATTHOLDX) >> 16 ; }
static inline uint32_t fmc_patt_get_attwaitx(void) { return (FMC.PATT & FMC_PATT_ATTWAITX) >> 8 ; }
static inline uint32_t fmc_patt_get_attsetx(void) { return (FMC.PATT & FMC_PATT_ATTSETX) >> 0 ; }

// FMC->BWTR1 SRAM/NOR-Flash write timing registers 1
enum {
	FMC_BWTR1_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BWTR1_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR1_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BWTR1_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR1_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR1_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_bwtr1_set_datahld(uint32_t val) { FMC.BWTR1 = (FMC.BWTR1 & ~FMC_BWTR1_DATAHLD) | ((val<<30) & FMC_BWTR1_DATAHLD); }
static inline void fmc_bwtr1_set_accmod(uint32_t val) { FMC.BWTR1 = (FMC.BWTR1 & ~FMC_BWTR1_ACCMOD) | ((val<<28) & FMC_BWTR1_ACCMOD); }
static inline void fmc_bwtr1_set_busturn(uint32_t val) { FMC.BWTR1 = (FMC.BWTR1 & ~FMC_BWTR1_BUSTURN) | ((val<<16) & FMC_BWTR1_BUSTURN); }
static inline void fmc_bwtr1_set_datast(uint32_t val) { FMC.BWTR1 = (FMC.BWTR1 & ~FMC_BWTR1_DATAST) | ((val<<8) & FMC_BWTR1_DATAST); }
static inline void fmc_bwtr1_set_addhld(uint32_t val) { FMC.BWTR1 = (FMC.BWTR1 & ~FMC_BWTR1_ADDHLD) | ((val<<4) & FMC_BWTR1_ADDHLD); }
static inline void fmc_bwtr1_set_addset(uint32_t val) { FMC.BWTR1 = (FMC.BWTR1 & ~FMC_BWTR1_ADDSET) | ((val<<0) & FMC_BWTR1_ADDSET); }
static inline uint32_t fmc_bwtr1_get_datahld(void) { return (FMC.BWTR1 & FMC_BWTR1_DATAHLD) >> 30 ; }
static inline uint32_t fmc_bwtr1_get_accmod(void) { return (FMC.BWTR1 & FMC_BWTR1_ACCMOD) >> 28 ; }
static inline uint32_t fmc_bwtr1_get_busturn(void) { return (FMC.BWTR1 & FMC_BWTR1_BUSTURN) >> 16 ; }
static inline uint32_t fmc_bwtr1_get_datast(void) { return (FMC.BWTR1 & FMC_BWTR1_DATAST) >> 8 ; }
static inline uint32_t fmc_bwtr1_get_addhld(void) { return (FMC.BWTR1 & FMC_BWTR1_ADDHLD) >> 4 ; }
static inline uint32_t fmc_bwtr1_get_addset(void) { return (FMC.BWTR1 & FMC_BWTR1_ADDSET) >> 0 ; }

// FMC->BWTR2 SRAM/NOR-Flash write timing registers 2
enum {
	FMC_BWTR2_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BWTR2_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR2_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BWTR2_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR2_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR2_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_bwtr2_set_datahld(uint32_t val) { FMC.BWTR2 = (FMC.BWTR2 & ~FMC_BWTR2_DATAHLD) | ((val<<30) & FMC_BWTR2_DATAHLD); }
static inline void fmc_bwtr2_set_accmod(uint32_t val) { FMC.BWTR2 = (FMC.BWTR2 & ~FMC_BWTR2_ACCMOD) | ((val<<28) & FMC_BWTR2_ACCMOD); }
static inline void fmc_bwtr2_set_busturn(uint32_t val) { FMC.BWTR2 = (FMC.BWTR2 & ~FMC_BWTR2_BUSTURN) | ((val<<16) & FMC_BWTR2_BUSTURN); }
static inline void fmc_bwtr2_set_datast(uint32_t val) { FMC.BWTR2 = (FMC.BWTR2 & ~FMC_BWTR2_DATAST) | ((val<<8) & FMC_BWTR2_DATAST); }
static inline void fmc_bwtr2_set_addhld(uint32_t val) { FMC.BWTR2 = (FMC.BWTR2 & ~FMC_BWTR2_ADDHLD) | ((val<<4) & FMC_BWTR2_ADDHLD); }
static inline void fmc_bwtr2_set_addset(uint32_t val) { FMC.BWTR2 = (FMC.BWTR2 & ~FMC_BWTR2_ADDSET) | ((val<<0) & FMC_BWTR2_ADDSET); }
static inline uint32_t fmc_bwtr2_get_datahld(void) { return (FMC.BWTR2 & FMC_BWTR2_DATAHLD) >> 30 ; }
static inline uint32_t fmc_bwtr2_get_accmod(void) { return (FMC.BWTR2 & FMC_BWTR2_ACCMOD) >> 28 ; }
static inline uint32_t fmc_bwtr2_get_busturn(void) { return (FMC.BWTR2 & FMC_BWTR2_BUSTURN) >> 16 ; }
static inline uint32_t fmc_bwtr2_get_datast(void) { return (FMC.BWTR2 & FMC_BWTR2_DATAST) >> 8 ; }
static inline uint32_t fmc_bwtr2_get_addhld(void) { return (FMC.BWTR2 & FMC_BWTR2_ADDHLD) >> 4 ; }
static inline uint32_t fmc_bwtr2_get_addset(void) { return (FMC.BWTR2 & FMC_BWTR2_ADDSET) >> 0 ; }

// FMC->BWTR3 SRAM/NOR-Flash write timing registers 3
enum {
	FMC_BWTR3_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BWTR3_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR3_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BWTR3_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR3_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR3_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_bwtr3_set_datahld(uint32_t val) { FMC.BWTR3 = (FMC.BWTR3 & ~FMC_BWTR3_DATAHLD) | ((val<<30) & FMC_BWTR3_DATAHLD); }
static inline void fmc_bwtr3_set_accmod(uint32_t val) { FMC.BWTR3 = (FMC.BWTR3 & ~FMC_BWTR3_ACCMOD) | ((val<<28) & FMC_BWTR3_ACCMOD); }
static inline void fmc_bwtr3_set_busturn(uint32_t val) { FMC.BWTR3 = (FMC.BWTR3 & ~FMC_BWTR3_BUSTURN) | ((val<<16) & FMC_BWTR3_BUSTURN); }
static inline void fmc_bwtr3_set_datast(uint32_t val) { FMC.BWTR3 = (FMC.BWTR3 & ~FMC_BWTR3_DATAST) | ((val<<8) & FMC_BWTR3_DATAST); }
static inline void fmc_bwtr3_set_addhld(uint32_t val) { FMC.BWTR3 = (FMC.BWTR3 & ~FMC_BWTR3_ADDHLD) | ((val<<4) & FMC_BWTR3_ADDHLD); }
static inline void fmc_bwtr3_set_addset(uint32_t val) { FMC.BWTR3 = (FMC.BWTR3 & ~FMC_BWTR3_ADDSET) | ((val<<0) & FMC_BWTR3_ADDSET); }
static inline uint32_t fmc_bwtr3_get_datahld(void) { return (FMC.BWTR3 & FMC_BWTR3_DATAHLD) >> 30 ; }
static inline uint32_t fmc_bwtr3_get_accmod(void) { return (FMC.BWTR3 & FMC_BWTR3_ACCMOD) >> 28 ; }
static inline uint32_t fmc_bwtr3_get_busturn(void) { return (FMC.BWTR3 & FMC_BWTR3_BUSTURN) >> 16 ; }
static inline uint32_t fmc_bwtr3_get_datast(void) { return (FMC.BWTR3 & FMC_BWTR3_DATAST) >> 8 ; }
static inline uint32_t fmc_bwtr3_get_addhld(void) { return (FMC.BWTR3 & FMC_BWTR3_ADDHLD) >> 4 ; }
static inline uint32_t fmc_bwtr3_get_addset(void) { return (FMC.BWTR3 & FMC_BWTR3_ADDSET) >> 0 ; }

// FMC->BWTR4 SRAM/NOR-Flash write timing registers 4
enum {
	FMC_BWTR4_DATAHLD = ((1UL<<2)-1) << 30, // DATAHLD
	FMC_BWTR4_ACCMOD = ((1UL<<2)-1) << 28, // ACCMOD
	FMC_BWTR4_BUSTURN = ((1UL<<4)-1) << 16, // BUSTURN
	FMC_BWTR4_DATAST = ((1UL<<8)-1) << 8, // DATAST
	FMC_BWTR4_ADDHLD = ((1UL<<4)-1) << 4, // ADDHLD
	FMC_BWTR4_ADDSET = ((1UL<<4)-1) << 0, // ADDSET		
};
static inline void fmc_bwtr4_set_datahld(uint32_t val) { FMC.BWTR4 = (FMC.BWTR4 & ~FMC_BWTR4_DATAHLD) | ((val<<30) & FMC_BWTR4_DATAHLD); }
static inline void fmc_bwtr4_set_accmod(uint32_t val) { FMC.BWTR4 = (FMC.BWTR4 & ~FMC_BWTR4_ACCMOD) | ((val<<28) & FMC_BWTR4_ACCMOD); }
static inline void fmc_bwtr4_set_busturn(uint32_t val) { FMC.BWTR4 = (FMC.BWTR4 & ~FMC_BWTR4_BUSTURN) | ((val<<16) & FMC_BWTR4_BUSTURN); }
static inline void fmc_bwtr4_set_datast(uint32_t val) { FMC.BWTR4 = (FMC.BWTR4 & ~FMC_BWTR4_DATAST) | ((val<<8) & FMC_BWTR4_DATAST); }
static inline void fmc_bwtr4_set_addhld(uint32_t val) { FMC.BWTR4 = (FMC.BWTR4 & ~FMC_BWTR4_ADDHLD) | ((val<<4) & FMC_BWTR4_ADDHLD); }
static inline void fmc_bwtr4_set_addset(uint32_t val) { FMC.BWTR4 = (FMC.BWTR4 & ~FMC_BWTR4_ADDSET) | ((val<<0) & FMC_BWTR4_ADDSET); }
static inline uint32_t fmc_bwtr4_get_datahld(void) { return (FMC.BWTR4 & FMC_BWTR4_DATAHLD) >> 30 ; }
static inline uint32_t fmc_bwtr4_get_accmod(void) { return (FMC.BWTR4 & FMC_BWTR4_ACCMOD) >> 28 ; }
static inline uint32_t fmc_bwtr4_get_busturn(void) { return (FMC.BWTR4 & FMC_BWTR4_BUSTURN) >> 16 ; }
static inline uint32_t fmc_bwtr4_get_datast(void) { return (FMC.BWTR4 & FMC_BWTR4_DATAST) >> 8 ; }
static inline uint32_t fmc_bwtr4_get_addhld(void) { return (FMC.BWTR4 & FMC_BWTR4_ADDHLD) >> 4 ; }
static inline uint32_t fmc_bwtr4_get_addset(void) { return (FMC.BWTR4 & FMC_BWTR4_ADDSET) >> 0 ; }

/* Floting point unit
There is only one peripheral of type FPU. */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};
extern struct FPU_Type	FPU;	// @0xE000EF34 

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN = 1UL<<31, // ASPEN
	FPU_FPCCR_LSPEN = 1UL<<30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL<<8, // MONRDY
	FPU_FPCCR_BFRDY = 1UL<<6, // BFRDY
	FPU_FPCCR_MMRDY = 1UL<<5, // MMRDY
	FPU_FPCCR_HFRDY = 1UL<<4, // HFRDY
	FPU_FPCCR_THREAD = 1UL<<3, // THREAD
	FPU_FPCCR_USER = 1UL<<1, // USER
	FPU_FPCCR_LSPACT = 1UL<<0, // LSPACT		
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL<<29)-1) << 3, // Location of unpopulated floating-point		
};
static inline void fpu_fpcar_set_address(uint32_t val) { FPU.FPCAR = (FPU.FPCAR & ~FPU_FPCAR_ADDRESS) | ((val<<3) & FPU_FPCAR_ADDRESS); }
static inline uint32_t fpu_fpcar_get_address(void) { return (FPU.FPCAR & FPU_FPCAR_ADDRESS) >> 3 ; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N = 1UL<<31, // Negative condition code flag
	FPU_FPSCR_Z = 1UL<<30, // Zero condition code flag
	FPU_FPSCR_C = 1UL<<29, // Carry condition code flag
	FPU_FPSCR_V = 1UL<<28, // Overflow condition code flag
	FPU_FPSCR_AHP = 1UL<<26, // Alternative half-precision control bit
	FPU_FPSCR_DN = 1UL<<25, // Default NaN mode control bit
	FPU_FPSCR_FZ = 1UL<<24, // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL<<2)-1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC = 1UL<<7, // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC = 1UL<<4, // Inexact cumulative exception bit
	FPU_FPSCR_UFC = 1UL<<3, // Underflow cumulative exception bit
	FPU_FPSCR_OFC = 1UL<<2, // Overflow cumulative exception bit
	FPU_FPSCR_DZC = 1UL<<1, // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC = 1UL<<0, // Invalid operation cumulative exception bit		
};
static inline void fpu_fpscr_set_rmode(uint32_t val) { FPU.FPSCR = (FPU.FPSCR & ~FPU_FPSCR_RMODE) | ((val<<22) & FPU_FPSCR_RMODE); }
static inline uint32_t fpu_fpscr_get_rmode(void) { return (FPU.FPSCR & FPU_FPSCR_RMODE) >> 22 ; }

/* Floating point unit CPACR
There is only one peripheral of type FPU_CPACR. */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};
extern struct FPU_CPACR_Type	FPU_CPACR;	// @0xE000ED88 

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL<<4)-1) << 20, // CP		
};
static inline void fpu_cpacr_cpacr_set_cp(uint32_t val) { FPU_CPACR.CPACR = (FPU_CPACR.CPACR & ~FPU_CPACR_CPACR_CP) | ((val<<20) & FPU_CPACR_CPACR_CP); }
static inline uint32_t fpu_cpacr_cpacr_get_cp(void) { return (FPU_CPACR.CPACR & FPU_CPACR_CPACR_CP) >> 20 ; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER; // @0 GPIO port mode register
	__IO uint32_t OTYPER; // @4 GPIO port output type register
	__IO uint32_t OSPEEDR; // @8 GPIO port output speed register
	__IO uint32_t PUPDR; // @12 GPIO port pull-up/pull-down register
	__I uint32_t IDR; // @16 GPIO port input data register
	__IO uint32_t ODR; // @20 GPIO port output data register
	__O uint32_t BSRR; // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR; // @28 GPIO port configuration lock register
	__IO uint32_t AFRL; // @32 GPIO alternate function low register
	__IO uint32_t AFRH; // @36 GPIO alternate function high register
	__O uint32_t BRR; // @40 GPIO port bit reset register
};
extern struct GPIOA_Type	GPIOA;	// @0x48000000 
extern struct GPIOA_Type 	GPIOB;	// @0x48000400
extern struct GPIOA_Type 	GPIOC;	// @0x48000800
extern struct GPIOA_Type 	GPIOD;	// @0x48000C00
extern struct GPIOA_Type 	GPIOE;	// @0x48001000
extern struct GPIOA_Type 	GPIOF;	// @0x48001400
extern struct GPIOA_Type 	GPIOG;	// @0x48001800

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
static inline void gpioa_moder_set_moder15(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val<<30) & GPIOA_MODER_MODER15); }
static inline void gpioa_moder_set_moder14(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val<<28) & GPIOA_MODER_MODER14); }
static inline void gpioa_moder_set_moder13(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val<<26) & GPIOA_MODER_MODER13); }
static inline void gpioa_moder_set_moder12(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val<<24) & GPIOA_MODER_MODER12); }
static inline void gpioa_moder_set_moder11(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val<<22) & GPIOA_MODER_MODER11); }
static inline void gpioa_moder_set_moder10(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val<<20) & GPIOA_MODER_MODER10); }
static inline void gpioa_moder_set_moder9(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val<<18) & GPIOA_MODER_MODER9); }
static inline void gpioa_moder_set_moder8(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val<<16) & GPIOA_MODER_MODER8); }
static inline void gpioa_moder_set_moder7(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val<<14) & GPIOA_MODER_MODER7); }
static inline void gpioa_moder_set_moder6(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val<<12) & GPIOA_MODER_MODER6); }
static inline void gpioa_moder_set_moder5(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val<<10) & GPIOA_MODER_MODER5); }
static inline void gpioa_moder_set_moder4(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val<<8) & GPIOA_MODER_MODER4); }
static inline void gpioa_moder_set_moder3(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val<<6) & GPIOA_MODER_MODER3); }
static inline void gpioa_moder_set_moder2(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val<<4) & GPIOA_MODER_MODER2); }
static inline void gpioa_moder_set_moder1(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val<<2) & GPIOA_MODER_MODER1); }
static inline void gpioa_moder_set_moder0(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val<<0) & GPIOA_MODER_MODER0); }
static inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30 ; }
static inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28 ; }
static inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26 ; }
static inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24 ; }
static inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22 ; }
static inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20 ; }
static inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18 ; }
static inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16 ; }
static inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14 ; }
static inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12 ; }
static inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10 ; }
static inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8 ; }
static inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6 ; }
static inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4 ; }
static inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2 ; }
static inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0 ; }

// GPIOA->OTYPER GPIO port output type register
enum {
	GPIOA_OTYPER_OTX  = ((1UL<<16)-1) << 0, // Merged Port x configuration bits (y = 0..15)		
};
static inline void gpioa_otyper_set_otx (struct GPIOA_Type* p, uint32_t val) { p->OTYPER = (p->OTYPER & ~GPIOA_OTYPER_OTX ) | ((val<<0) & GPIOA_OTYPER_OTX ); }
static inline uint32_t gpioa_otyper_get_otx (struct GPIOA_Type* p) { return (p->OTYPER & GPIOA_OTYPER_OTX ) >> 0 ; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
static inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val<<30) & GPIOA_OSPEEDR_OSPEEDR15); }
static inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val<<28) & GPIOA_OSPEEDR_OSPEEDR14); }
static inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val<<26) & GPIOA_OSPEEDR_OSPEEDR13); }
static inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val<<24) & GPIOA_OSPEEDR_OSPEEDR12); }
static inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val<<22) & GPIOA_OSPEEDR_OSPEEDR11); }
static inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val<<20) & GPIOA_OSPEEDR_OSPEEDR10); }
static inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val<<18) & GPIOA_OSPEEDR_OSPEEDR9); }
static inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val<<16) & GPIOA_OSPEEDR_OSPEEDR8); }
static inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val<<14) & GPIOA_OSPEEDR_OSPEEDR7); }
static inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val<<12) & GPIOA_OSPEEDR_OSPEEDR6); }
static inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val<<10) & GPIOA_OSPEEDR_OSPEEDR5); }
static inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val<<8) & GPIOA_OSPEEDR_OSPEEDR4); }
static inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val<<6) & GPIOA_OSPEEDR_OSPEEDR3); }
static inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val<<4) & GPIOA_OSPEEDR_OSPEEDR2); }
static inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val<<2) & GPIOA_OSPEEDR_OSPEEDR1); }
static inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val<<0) & GPIOA_OSPEEDR_OSPEEDR0); }
static inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2 ; }
static inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0 ; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
static inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val<<30) & GPIOA_PUPDR_PUPDR15); }
static inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val<<28) & GPIOA_PUPDR_PUPDR14); }
static inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val<<26) & GPIOA_PUPDR_PUPDR13); }
static inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val<<24) & GPIOA_PUPDR_PUPDR12); }
static inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val<<22) & GPIOA_PUPDR_PUPDR11); }
static inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val<<20) & GPIOA_PUPDR_PUPDR10); }
static inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val<<18) & GPIOA_PUPDR_PUPDR9); }
static inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val<<16) & GPIOA_PUPDR_PUPDR8); }
static inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val<<14) & GPIOA_PUPDR_PUPDR7); }
static inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val<<12) & GPIOA_PUPDR_PUPDR6); }
static inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val<<10) & GPIOA_PUPDR_PUPDR5); }
static inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val<<8) & GPIOA_PUPDR_PUPDR4); }
static inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val<<6) & GPIOA_PUPDR_PUPDR3); }
static inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val<<4) & GPIOA_PUPDR_PUPDR2); }
static inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val<<2) & GPIOA_PUPDR_PUPDR1); }
static inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val<<0) & GPIOA_PUPDR_PUPDR0); }
static inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30 ; }
static inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28 ; }
static inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26 ; }
static inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24 ; }
static inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22 ; }
static inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20 ; }
static inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18 ; }
static inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16 ; }
static inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14 ; }
static inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12 ; }
static inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10 ; }
static inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8 ; }
static inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6 ; }
static inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4 ; }
static inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2 ; }
static inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0 ; }

// GPIOA->IDR GPIO port input data register
enum {
	GPIOA_IDR_IDRX  = ((1UL<<16)-1) << 0, // Merged Port input data (y = 0..15)		
};
static inline uint32_t gpioa_idr_get_idrx (struct GPIOA_Type* p) { return (p->IDR & GPIOA_IDR_IDRX ) >> 0 ; }

// GPIOA->ODR GPIO port output data register
enum {
	GPIOA_ODR_ODRX  = ((1UL<<16)-1) << 0, // Merged Port output data (y = 0..15)		
};
static inline void gpioa_odr_set_odrx (struct GPIOA_Type* p, uint32_t val) { p->ODR = (p->ODR & ~GPIOA_ODR_ODRX ) | ((val<<0) & GPIOA_ODR_ODRX ); }
static inline uint32_t gpioa_odr_get_odrx (struct GPIOA_Type* p) { return (p->ODR & GPIOA_ODR_ODRX ) >> 0 ; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL<<31, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL<<30, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL<<29, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL<<28, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL<<27, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL<<26, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9 = 1UL<<25, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8 = 1UL<<24, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7 = 1UL<<23, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6 = 1UL<<22, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5 = 1UL<<21, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4 = 1UL<<20, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3 = 1UL<<19, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2 = 1UL<<18, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1 = 1UL<<17, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0 = 1UL<<16, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL<<15, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL<<14, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL<<13, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL<<12, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL<<11, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL<<10, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9 = 1UL<<9, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8 = 1UL<<8, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7 = 1UL<<7, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6 = 1UL<<6, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5 = 1UL<<5, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4 = 1UL<<4, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3 = 1UL<<3, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2 = 1UL<<2, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1 = 1UL<<1, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0 = 1UL<<0, // Port x set bit y (y= 0..15)		
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK = 1UL<<16, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL<<15, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL<<14, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL<<13, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL<<12, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL<<11, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL<<10, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9 = 1UL<<9, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8 = 1UL<<8, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7 = 1UL<<7, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6 = 1UL<<6, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5 = 1UL<<5, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4 = 1UL<<4, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3 = 1UL<<3, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2 = 1UL<<2, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1 = 1UL<<1, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0 = 1UL<<0, // Port x lock bit y (y= 0..15)		
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFRL7 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL6 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL5 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL4 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL3 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL2 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL1 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL0 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 0..7)		
};
static inline void gpioa_afrl_set_afrl7(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL7) | ((val<<28) & GPIOA_AFRL_AFRL7); }
static inline void gpioa_afrl_set_afrl6(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL6) | ((val<<24) & GPIOA_AFRL_AFRL6); }
static inline void gpioa_afrl_set_afrl5(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL5) | ((val<<20) & GPIOA_AFRL_AFRL5); }
static inline void gpioa_afrl_set_afrl4(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL4) | ((val<<16) & GPIOA_AFRL_AFRL4); }
static inline void gpioa_afrl_set_afrl3(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL3) | ((val<<12) & GPIOA_AFRL_AFRL3); }
static inline void gpioa_afrl_set_afrl2(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL2) | ((val<<8) & GPIOA_AFRL_AFRL2); }
static inline void gpioa_afrl_set_afrl1(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL1) | ((val<<4) & GPIOA_AFRL_AFRL1); }
static inline void gpioa_afrl_set_afrl0(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL0) | ((val<<0) & GPIOA_AFRL_AFRL0); }
static inline uint32_t gpioa_afrl_get_afrl7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL7) >> 28 ; }
static inline uint32_t gpioa_afrl_get_afrl6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL6) >> 24 ; }
static inline uint32_t gpioa_afrl_get_afrl5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL5) >> 20 ; }
static inline uint32_t gpioa_afrl_get_afrl4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL4) >> 16 ; }
static inline uint32_t gpioa_afrl_get_afrl3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL3) >> 12 ; }
static inline uint32_t gpioa_afrl_get_afrl2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL2) >> 8 ; }
static inline uint32_t gpioa_afrl_get_afrl1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL1) >> 4 ; }
static inline uint32_t gpioa_afrl_get_afrl0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL0) >> 0 ; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFRH15 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH14 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH13 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH12 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH11 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH10 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH9 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH8 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 8..15)		
};
static inline void gpioa_afrh_set_afrh15(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH15) | ((val<<28) & GPIOA_AFRH_AFRH15); }
static inline void gpioa_afrh_set_afrh14(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH14) | ((val<<24) & GPIOA_AFRH_AFRH14); }
static inline void gpioa_afrh_set_afrh13(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH13) | ((val<<20) & GPIOA_AFRH_AFRH13); }
static inline void gpioa_afrh_set_afrh12(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH12) | ((val<<16) & GPIOA_AFRH_AFRH12); }
static inline void gpioa_afrh_set_afrh11(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH11) | ((val<<12) & GPIOA_AFRH_AFRH11); }
static inline void gpioa_afrh_set_afrh10(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH10) | ((val<<8) & GPIOA_AFRH_AFRH10); }
static inline void gpioa_afrh_set_afrh9(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH9) | ((val<<4) & GPIOA_AFRH_AFRH9); }
static inline void gpioa_afrh_set_afrh8(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH8) | ((val<<0) & GPIOA_AFRH_AFRH8); }
static inline uint32_t gpioa_afrh_get_afrh15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH15) >> 28 ; }
static inline uint32_t gpioa_afrh_get_afrh14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH14) >> 24 ; }
static inline uint32_t gpioa_afrh_get_afrh13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH13) >> 20 ; }
static inline uint32_t gpioa_afrh_get_afrh12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH12) >> 16 ; }
static inline uint32_t gpioa_afrh_get_afrh11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH11) >> 12 ; }
static inline uint32_t gpioa_afrh_get_afrh10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH10) >> 8 ; }
static inline uint32_t gpioa_afrh_get_afrh9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH9) >> 4 ; }
static inline uint32_t gpioa_afrh_get_afrh8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH8) >> 0 ; }

// GPIOA->BRR GPIO port bit reset register
enum {
	GPIOA_BRR_BRX  = ((1UL<<16)-1) << 0, // Merged Port Reset bit		
};
static inline void gpioa_brr_set_brx (struct GPIOA_Type* p, uint32_t val) { p->BRR = (p->BRR & ~GPIOA_BRR_BRX ) | ((val<<0) & GPIOA_BRR_BRX ); }
static inline uint32_t gpioa_brr_get_brx (struct GPIOA_Type* p) { return (p->BRR & GPIOA_BRR_BRX ) >> 0 ; }







/* WinWATCHDOG
There is only one peripheral of type IWDG. */
struct IWDG_Type {
	__O uint32_t KR; // @0 Key register
	__IO uint32_t PR; // @4 Prescaler register
	__IO uint32_t RLR; // @8 Reload register
	__I uint32_t SR; // @12 Status register
	__IO uint32_t WINR; // @16 Window register
};
extern struct IWDG_Type	IWDG;	// @0x40003000 

// IWDG->KR Key register
enum {
	IWDG_KR_KEY = ((1UL<<16)-1) << 0, // Key value (write only, read 0x0000)		
};
static inline void iwdg_kr_set_key(uint32_t val) { IWDG.KR = (IWDG.KR & ~IWDG_KR_KEY) | ((val<<0) & IWDG_KR_KEY); }
static inline uint32_t iwdg_kr_get_key(void) { return (IWDG.KR & IWDG_KR_KEY) >> 0 ; }

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL<<3)-1) << 0, // Prescaler divider		
};
static inline void iwdg_pr_set_pr(uint32_t val) { IWDG.PR = (IWDG.PR & ~IWDG_PR_PR) | ((val<<0) & IWDG_PR_PR); }
static inline uint32_t iwdg_pr_get_pr(void) { return (IWDG.PR & IWDG_PR_PR) >> 0 ; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL<<12)-1) << 0, // Watchdog counter reload value		
};
static inline void iwdg_rlr_set_rl(uint32_t val) { IWDG.RLR = (IWDG.RLR & ~IWDG_RLR_RL) | ((val<<0) & IWDG_RLR_RL); }
static inline uint32_t iwdg_rlr_get_rl(void) { return (IWDG.RLR & IWDG_RLR_RL) >> 0 ; }

// IWDG->SR Status register
enum {
	IWDG_SR_WVU = 1UL<<2, // Watchdog counter window value update
	IWDG_SR_RVU = 1UL<<1, // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL<<0, // Watchdog prescaler value update		
};

// IWDG->WINR Window register
enum {
	IWDG_WINR_WIN = ((1UL<<12)-1) << 0, // Watchdog counter window value		
};
static inline void iwdg_winr_set_win(uint32_t val) { IWDG.WINR = (IWDG.WINR & ~IWDG_WINR_WIN) | ((val<<0) & IWDG_WINR_WIN); }
static inline uint32_t iwdg_winr_get_win(void) { return (IWDG.WINR & IWDG_WINR_WIN) >> 0 ; }

/* Universal synchronous asynchronous receiver transmitter
There is only one peripheral of type LPUART. */
struct LPUART_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint32_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[8]; // @16 
	__O uint32_t RQR; // @24 Request register
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint32_t RDR; // @36 Receive data register
	__IO uint32_t TDR; // @40 Transmit data register
	__IO uint32_t PRESC; // @44 Prescaler register
};
extern struct LPUART_Type	LPUART1;	// @0x40008000 

// LPUART->CR1 Control register 1
enum {
	LPUART_CR1_RXFFIE = 1UL<<31, // RXFFIE
	LPUART_CR1_TXFEIE = 1UL<<30, // TXFEIE
	LPUART_CR1_FIFOEN = 1UL<<29, // FIFOEN
	LPUART_CR1_M1 = 1UL<<28, // Word length
	LPUART_CR1_DEAT4 = 1UL<<25, // Driver Enable assertion time
	LPUART_CR1_DEAT3 = 1UL<<24, // DEAT3
	LPUART_CR1_DEAT2 = 1UL<<23, // DEAT2
	LPUART_CR1_DEAT1 = 1UL<<22, // DEAT1
	LPUART_CR1_DEAT0 = 1UL<<21, // DEAT0
	LPUART_CR1_DEDT4 = 1UL<<20, // Driver Enable de-assertion time
	LPUART_CR1_DEDT3 = 1UL<<19, // DEDT3
	LPUART_CR1_DEDT2 = 1UL<<18, // DEDT2
	LPUART_CR1_DEDT1 = 1UL<<17, // DEDT1
	LPUART_CR1_DEDT0 = 1UL<<16, // DEDT0
	LPUART_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	LPUART_CR1_MME = 1UL<<13, // Mute mode enable
	LPUART_CR1_M0 = 1UL<<12, // Word length
	LPUART_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	LPUART_CR1_PCE = 1UL<<10, // Parity control enable
	LPUART_CR1_PS = 1UL<<9, // Parity selection
	LPUART_CR1_PEIE = 1UL<<8, // PE interrupt enable
	LPUART_CR1_TXEIE = 1UL<<7, // interrupt enable
	LPUART_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	LPUART_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	LPUART_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	LPUART_CR1_TE = 1UL<<3, // Transmitter enable
	LPUART_CR1_RE = 1UL<<2, // Receiver enable
	LPUART_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	LPUART_CR1_UE = 1UL<<0, // USART enable		
};

// LPUART->CR2 Control register 2
enum {
	LPUART_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	LPUART_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	LPUART_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	LPUART_CR2_TAINV = 1UL<<18, // Binary data inversion
	LPUART_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	LPUART_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	LPUART_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	LPUART_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	LPUART_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
static inline void lpuart_cr2_set_add4_7(uint32_t val) { LPUART1.CR2 = (LPUART1.CR2 & ~LPUART_CR2_ADD4_7) | ((val<<28) & LPUART_CR2_ADD4_7); }
static inline void lpuart_cr2_set_add0_3(uint32_t val) { LPUART1.CR2 = (LPUART1.CR2 & ~LPUART_CR2_ADD0_3) | ((val<<24) & LPUART_CR2_ADD0_3); }
static inline void lpuart_cr2_set_stop(uint32_t val) { LPUART1.CR2 = (LPUART1.CR2 & ~LPUART_CR2_STOP) | ((val<<12) & LPUART_CR2_STOP); }
static inline uint32_t lpuart_cr2_get_add4_7(void) { return (LPUART1.CR2 & LPUART_CR2_ADD4_7) >> 28 ; }
static inline uint32_t lpuart_cr2_get_add0_3(void) { return (LPUART1.CR2 & LPUART_CR2_ADD0_3) >> 24 ; }
static inline uint32_t lpuart_cr2_get_stop(void) { return (LPUART1.CR2 & LPUART_CR2_STOP) >> 12 ; }

// LPUART->CR3 Control register 3
enum {
	LPUART_CR3_TXFTCFG = ((1UL<<3)-1) << 29, // TXFTCFG
	LPUART_CR3_RXFTIE = 1UL<<28, // RXFTIE
	LPUART_CR3_RXFTCFG = ((1UL<<3)-1) << 25, // RXFTCFG
	LPUART_CR3_TXFTIE = 1UL<<23, // TXFTIE
	LPUART_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	LPUART_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	LPUART_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	LPUART_CR3_DEM = 1UL<<14, // Driver enable mode
	LPUART_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	LPUART_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	LPUART_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	LPUART_CR3_CTSE = 1UL<<9, // CTS enable
	LPUART_CR3_RTSE = 1UL<<8, // RTS enable
	LPUART_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	LPUART_CR3_DMAR = 1UL<<6, // DMA enable receiver
	LPUART_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	LPUART_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
static inline void lpuart_cr3_set_txftcfg(uint32_t val) { LPUART1.CR3 = (LPUART1.CR3 & ~LPUART_CR3_TXFTCFG) | ((val<<29) & LPUART_CR3_TXFTCFG); }
static inline void lpuart_cr3_set_rxftcfg(uint32_t val) { LPUART1.CR3 = (LPUART1.CR3 & ~LPUART_CR3_RXFTCFG) | ((val<<25) & LPUART_CR3_RXFTCFG); }
static inline void lpuart_cr3_set_wus(uint32_t val) { LPUART1.CR3 = (LPUART1.CR3 & ~LPUART_CR3_WUS) | ((val<<20) & LPUART_CR3_WUS); }
static inline uint32_t lpuart_cr3_get_txftcfg(void) { return (LPUART1.CR3 & LPUART_CR3_TXFTCFG) >> 29 ; }
static inline uint32_t lpuart_cr3_get_rxftcfg(void) { return (LPUART1.CR3 & LPUART_CR3_RXFTCFG) >> 25 ; }
static inline uint32_t lpuart_cr3_get_wus(void) { return (LPUART1.CR3 & LPUART_CR3_WUS) >> 20 ; }

// LPUART->BRR Baud rate register
enum {
	LPUART_BRR_BRR = ((1UL<<20)-1) << 0, // BRR		
};
static inline void lpuart_brr_set_brr(uint32_t val) { LPUART1.BRR = (LPUART1.BRR & ~LPUART_BRR_BRR) | ((val<<0) & LPUART_BRR_BRR); }
static inline uint32_t lpuart_brr_get_brr(void) { return (LPUART1.BRR & LPUART_BRR_BRR) >> 0 ; }

// LPUART->RQR Request register
enum {
	LPUART_RQR_TXFRQ = 1UL<<4, // TXFRQ
	LPUART_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	LPUART_RQR_MMRQ = 1UL<<2, // Mute mode request
	LPUART_RQR_SBKRQ = 1UL<<1, // Send break request		
};

// LPUART->ISR Interrupt & status register
enum {
	LPUART_ISR_TXFT = 1UL<<27, // TXFT
	LPUART_ISR_RXFT = 1UL<<26, // RXFT
	LPUART_ISR_RXFF = 1UL<<24, // RXFF
	LPUART_ISR_TXFE = 1UL<<23, // TXFE
	LPUART_ISR_REACK = 1UL<<22, // REACK
	LPUART_ISR_TEACK = 1UL<<21, // TEACK
	LPUART_ISR_WUF = 1UL<<20, // WUF
	LPUART_ISR_RWU = 1UL<<19, // RWU
	LPUART_ISR_SBKF = 1UL<<18, // SBKF
	LPUART_ISR_CMF = 1UL<<17, // CMF
	LPUART_ISR_BUSY = 1UL<<16, // BUSY
	LPUART_ISR_CTS = 1UL<<10, // CTS
	LPUART_ISR_CTSIF = 1UL<<9, // CTSIF
	LPUART_ISR_TXE = 1UL<<7, // TXE
	LPUART_ISR_TC = 1UL<<6, // TC
	LPUART_ISR_RXNE = 1UL<<5, // RXNE
	LPUART_ISR_IDLE = 1UL<<4, // IDLE
	LPUART_ISR_ORE = 1UL<<3, // ORE
	LPUART_ISR_NF = 1UL<<2, // NF
	LPUART_ISR_FE = 1UL<<1, // FE
	LPUART_ISR_PE = 1UL<<0, // PE		
};

// LPUART->ICR Interrupt flag clear register
enum {
	LPUART_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	LPUART_ICR_CMCF = 1UL<<17, // Character match clear flag
	LPUART_ICR_CTSCF = 1UL<<9, // CTS clear flag
	LPUART_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	LPUART_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	LPUART_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	LPUART_ICR_NCF = 1UL<<2, // Noise detected clear flag
	LPUART_ICR_FECF = 1UL<<1, // Framing error clear flag
	LPUART_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// LPUART->RDR Receive data register
enum {
	LPUART_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
static inline uint32_t lpuart_rdr_get_rdr(void) { return (LPUART1.RDR & LPUART_RDR_RDR) >> 0 ; }

// LPUART->TDR Transmit data register
enum {
	LPUART_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
static inline void lpuart_tdr_set_tdr(uint32_t val) { LPUART1.TDR = (LPUART1.TDR & ~LPUART_TDR_TDR) | ((val<<0) & LPUART_TDR_TDR); }
static inline uint32_t lpuart_tdr_get_tdr(void) { return (LPUART1.TDR & LPUART_TDR_TDR) >> 0 ; }

// LPUART->PRESC Prescaler register
enum {
	LPUART_PRESC_PRESCALER = ((1UL<<4)-1) << 0, // PRESCALER		
};
static inline void lpuart_presc_set_prescaler(uint32_t val) { LPUART1.PRESC = (LPUART1.PRESC & ~LPUART_PRESC_PRESCALER) | ((val<<0) & LPUART_PRESC_PRESCALER); }
static inline uint32_t lpuart_presc_get_prescaler(void) { return (LPUART1.PRESC & LPUART_PRESC_PRESCALER) >> 0 ; }

/* Memory protection unit
There is only one peripheral of type MPU. */
struct MPU_Type {
	__I uint32_t TYPER; // @0 MPU type register
	__IO uint32_t CTRL; // @4 MPU control register
	__IO uint32_t RNR; // @8 MPU region number register
	__IO uint32_t RBAR; // @12 MPU region base address register
	__IO uint32_t RASR; // @16 MPU region attribute and size register
};
extern struct MPU_Type	MPU;	// @0xE000E084 

// MPU->TYPER MPU type register
enum {
	MPU_TYPER_IREGION = ((1UL<<8)-1) << 16, // Number of MPU instruction regions
	MPU_TYPER_DREGION = ((1UL<<8)-1) << 8, // Number of MPU data regions
	MPU_TYPER_SEPARATE = 1UL<<0, // Separate flag		
};
static inline uint32_t mpu_typer_get_iregion(void) { return (MPU.TYPER & MPU_TYPER_IREGION) >> 16 ; }
static inline uint32_t mpu_typer_get_dregion(void) { return (MPU.TYPER & MPU_TYPER_DREGION) >> 8 ; }

// MPU->CTRL MPU control register
enum {
	MPU_CTRL_PRIVDEFENA = 1UL<<2, // Enable priviliged software access to default memory map
	MPU_CTRL_HFNMIENA = 1UL<<1, // Enables the operation of MPU during hard fault
	MPU_CTRL_ENABLE = 1UL<<0, // Enables the MPU		
};

// MPU->RNR MPU region number register
enum {
	MPU_RNR_REGION = ((1UL<<8)-1) << 0, // MPU region		
};
static inline void mpu_rnr_set_region(uint32_t val) { MPU.RNR = (MPU.RNR & ~MPU_RNR_REGION) | ((val<<0) & MPU_RNR_REGION); }
static inline uint32_t mpu_rnr_get_region(void) { return (MPU.RNR & MPU_RNR_REGION) >> 0 ; }

// MPU->RBAR MPU region base address register
enum {
	MPU_RBAR_ADDR = ((1UL<<27)-1) << 5, // Region base address field
	MPU_RBAR_VALID = 1UL<<4, // MPU region number valid
	MPU_RBAR_REGION = ((1UL<<4)-1) << 0, // MPU region field		
};
static inline void mpu_rbar_set_addr(uint32_t val) { MPU.RBAR = (MPU.RBAR & ~MPU_RBAR_ADDR) | ((val<<5) & MPU_RBAR_ADDR); }
static inline void mpu_rbar_set_region(uint32_t val) { MPU.RBAR = (MPU.RBAR & ~MPU_RBAR_REGION) | ((val<<0) & MPU_RBAR_REGION); }
static inline uint32_t mpu_rbar_get_addr(void) { return (MPU.RBAR & MPU_RBAR_ADDR) >> 5 ; }
static inline uint32_t mpu_rbar_get_region(void) { return (MPU.RBAR & MPU_RBAR_REGION) >> 0 ; }

// MPU->RASR MPU region attribute and size register
enum {
	MPU_RASR_XN = 1UL<<28, // Instruction access disable bit
	MPU_RASR_AP = ((1UL<<3)-1) << 24, // Access permission
	MPU_RASR_TEX = ((1UL<<3)-1) << 19, // memory attribute
	MPU_RASR_S = 1UL<<18, // Shareable memory attribute
	MPU_RASR_C = 1UL<<17, // memory attribute
	MPU_RASR_B = 1UL<<16, // memory attribute
	MPU_RASR_SRD = ((1UL<<8)-1) << 8, // Subregion disable bits
	MPU_RASR_SIZE = ((1UL<<5)-1) << 1, // Size of the MPU protection region
	MPU_RASR_ENABLE = 1UL<<0, // Region enable bit.		
};
static inline void mpu_rasr_set_ap(uint32_t val) { MPU.RASR = (MPU.RASR & ~MPU_RASR_AP) | ((val<<24) & MPU_RASR_AP); }
static inline void mpu_rasr_set_tex(uint32_t val) { MPU.RASR = (MPU.RASR & ~MPU_RASR_TEX) | ((val<<19) & MPU_RASR_TEX); }
static inline void mpu_rasr_set_srd(uint32_t val) { MPU.RASR = (MPU.RASR & ~MPU_RASR_SRD) | ((val<<8) & MPU_RASR_SRD); }
static inline void mpu_rasr_set_size(uint32_t val) { MPU.RASR = (MPU.RASR & ~MPU_RASR_SIZE) | ((val<<1) & MPU_RASR_SIZE); }
static inline uint32_t mpu_rasr_get_ap(void) { return (MPU.RASR & MPU_RASR_AP) >> 24 ; }
static inline uint32_t mpu_rasr_get_tex(void) { return (MPU.RASR & MPU_RASR_TEX) >> 19 ; }
static inline uint32_t mpu_rasr_get_srd(void) { return (MPU.RASR & MPU_RASR_SRD) >> 8 ; }
static inline uint32_t mpu_rasr_get_size(void) { return (MPU.RASR & MPU_RASR_SIZE) >> 1 ; }

/* Nested Vectored Interrupt Controller
There is only one peripheral of type NVIC. */
struct NVIC_Type {
	__IO uint32_t ISER0; // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1; // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2; // @8 Interrupt Set-Enable Register
	__IO uint32_t ISER3; // @12 Interrupt Set-Enable Register
	 uint8_t RESERVED0[112]; // @16 
	__IO uint32_t ICER0; // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1; // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2; // @136 Interrupt Clear-Enable Register
	__IO uint32_t ICER3; // @140 Interrupt Clear-Enable Register
	 uint8_t RESERVED1[112]; // @144 
	__IO uint32_t ISPR0; // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1; // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2; // @264 Interrupt Set-Pending Register
	__IO uint32_t ISPR3; // @268 Interrupt Set-Pending Register
	 uint8_t RESERVED2[112]; // @272 
	__IO uint32_t ICPR0; // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1; // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2; // @392 Interrupt Clear-Pending Register
	__IO uint32_t ICPR3; // @396 Interrupt Clear-Pending Register
	 uint8_t RESERVED3[112]; // @400 
	__I uint32_t IABR0; // @512 Interrupt Active Bit Register
	__I uint32_t IABR1; // @516 Interrupt Active Bit Register
	__I uint32_t IABR2; // @520 Interrupt Active Bit Register
	__I uint32_t IABR3; // @524 Interrupt Active Bit Register
	 uint8_t RESERVED4[240]; // @528 
	__IO uint32_t IPR0; // @768 Interrupt Priority Register
	__IO uint32_t IPR1; // @772 Interrupt Priority Register
	__IO uint32_t IPR2; // @776 Interrupt Priority Register
	__IO uint32_t IPR3; // @780 Interrupt Priority Register
	__IO uint32_t IPR4; // @784 Interrupt Priority Register
	__IO uint32_t IPR5; // @788 Interrupt Priority Register
	__IO uint32_t IPR6; // @792 Interrupt Priority Register
	__IO uint32_t IPR7; // @796 Interrupt Priority Register
	__IO uint32_t IPR8; // @800 Interrupt Priority Register
	__IO uint32_t IPR9; // @804 Interrupt Priority Register
	__IO uint32_t IPR10; // @808 Interrupt Priority Register
	__IO uint32_t IPR11; // @812 Interrupt Priority Register
	__IO uint32_t IPR12; // @816 Interrupt Priority Register
	__IO uint32_t IPR13; // @820 Interrupt Priority Register
	__IO uint32_t IPR14; // @824 Interrupt Priority Register
	__IO uint32_t IPR15; // @828 Interrupt Priority Register
	__IO uint32_t IPR16; // @832 Interrupt Priority Register
	__IO uint32_t IPR17; // @836 Interrupt Priority Register
	__IO uint32_t IPR18; // @840 Interrupt Priority Register
	__IO uint32_t IPR19; // @844 Interrupt Priority Register
	__IO uint32_t IPR20; // @848 Interrupt Priority Register
	__IO uint32_t IPR21; // @852 Interrupt Priority Register
	__IO uint32_t IPR22; // @856 Interrupt Priority Register
	__IO uint32_t IPR23; // @860 Interrupt Priority Register
	__IO uint32_t IPR24; // @864 Interrupt Priority Register
	__IO uint32_t IPR25; // @868 Interrupt Priority Register
};
extern struct NVIC_Type	NVIC;	// @0xE000E100 

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr0_set_ipr_n3(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N3) | ((val<<24) & NVIC_IPR0_IPR_N3); }
static inline void nvic_ipr0_set_ipr_n2(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N2) | ((val<<16) & NVIC_IPR0_IPR_N2); }
static inline void nvic_ipr0_set_ipr_n1(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N1) | ((val<<8) & NVIC_IPR0_IPR_N1); }
static inline void nvic_ipr0_set_ipr_n0(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N0) | ((val<<0) & NVIC_IPR0_IPR_N0); }
static inline uint32_t nvic_ipr0_get_ipr_n3(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr0_get_ipr_n2(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr0_get_ipr_n1(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr0_get_ipr_n0(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N0) >> 0 ; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr1_set_ipr_n3(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N3) | ((val<<24) & NVIC_IPR1_IPR_N3); }
static inline void nvic_ipr1_set_ipr_n2(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N2) | ((val<<16) & NVIC_IPR1_IPR_N2); }
static inline void nvic_ipr1_set_ipr_n1(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N1) | ((val<<8) & NVIC_IPR1_IPR_N1); }
static inline void nvic_ipr1_set_ipr_n0(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N0) | ((val<<0) & NVIC_IPR1_IPR_N0); }
static inline uint32_t nvic_ipr1_get_ipr_n3(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr1_get_ipr_n2(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr1_get_ipr_n1(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr1_get_ipr_n0(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N0) >> 0 ; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr2_set_ipr_n3(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N3) | ((val<<24) & NVIC_IPR2_IPR_N3); }
static inline void nvic_ipr2_set_ipr_n2(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N2) | ((val<<16) & NVIC_IPR2_IPR_N2); }
static inline void nvic_ipr2_set_ipr_n1(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N1) | ((val<<8) & NVIC_IPR2_IPR_N1); }
static inline void nvic_ipr2_set_ipr_n0(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N0) | ((val<<0) & NVIC_IPR2_IPR_N0); }
static inline uint32_t nvic_ipr2_get_ipr_n3(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr2_get_ipr_n2(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr2_get_ipr_n1(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr2_get_ipr_n0(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N0) >> 0 ; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr3_set_ipr_n3(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N3) | ((val<<24) & NVIC_IPR3_IPR_N3); }
static inline void nvic_ipr3_set_ipr_n2(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N2) | ((val<<16) & NVIC_IPR3_IPR_N2); }
static inline void nvic_ipr3_set_ipr_n1(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N1) | ((val<<8) & NVIC_IPR3_IPR_N1); }
static inline void nvic_ipr3_set_ipr_n0(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N0) | ((val<<0) & NVIC_IPR3_IPR_N0); }
static inline uint32_t nvic_ipr3_get_ipr_n3(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr3_get_ipr_n2(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr3_get_ipr_n1(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr3_get_ipr_n0(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N0) >> 0 ; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr4_set_ipr_n3(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N3) | ((val<<24) & NVIC_IPR4_IPR_N3); }
static inline void nvic_ipr4_set_ipr_n2(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N2) | ((val<<16) & NVIC_IPR4_IPR_N2); }
static inline void nvic_ipr4_set_ipr_n1(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N1) | ((val<<8) & NVIC_IPR4_IPR_N1); }
static inline void nvic_ipr4_set_ipr_n0(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N0) | ((val<<0) & NVIC_IPR4_IPR_N0); }
static inline uint32_t nvic_ipr4_get_ipr_n3(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr4_get_ipr_n2(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr4_get_ipr_n1(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr4_get_ipr_n0(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N0) >> 0 ; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr5_set_ipr_n3(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N3) | ((val<<24) & NVIC_IPR5_IPR_N3); }
static inline void nvic_ipr5_set_ipr_n2(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N2) | ((val<<16) & NVIC_IPR5_IPR_N2); }
static inline void nvic_ipr5_set_ipr_n1(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N1) | ((val<<8) & NVIC_IPR5_IPR_N1); }
static inline void nvic_ipr5_set_ipr_n0(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N0) | ((val<<0) & NVIC_IPR5_IPR_N0); }
static inline uint32_t nvic_ipr5_get_ipr_n3(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr5_get_ipr_n2(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr5_get_ipr_n1(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr5_get_ipr_n0(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N0) >> 0 ; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr6_set_ipr_n3(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N3) | ((val<<24) & NVIC_IPR6_IPR_N3); }
static inline void nvic_ipr6_set_ipr_n2(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N2) | ((val<<16) & NVIC_IPR6_IPR_N2); }
static inline void nvic_ipr6_set_ipr_n1(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N1) | ((val<<8) & NVIC_IPR6_IPR_N1); }
static inline void nvic_ipr6_set_ipr_n0(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N0) | ((val<<0) & NVIC_IPR6_IPR_N0); }
static inline uint32_t nvic_ipr6_get_ipr_n3(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr6_get_ipr_n2(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr6_get_ipr_n1(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr6_get_ipr_n0(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N0) >> 0 ; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr7_set_ipr_n3(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N3) | ((val<<24) & NVIC_IPR7_IPR_N3); }
static inline void nvic_ipr7_set_ipr_n2(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N2) | ((val<<16) & NVIC_IPR7_IPR_N2); }
static inline void nvic_ipr7_set_ipr_n1(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N1) | ((val<<8) & NVIC_IPR7_IPR_N1); }
static inline void nvic_ipr7_set_ipr_n0(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N0) | ((val<<0) & NVIC_IPR7_IPR_N0); }
static inline uint32_t nvic_ipr7_get_ipr_n3(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr7_get_ipr_n2(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr7_get_ipr_n1(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr7_get_ipr_n0(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N0) >> 0 ; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr8_set_ipr_n3(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N3) | ((val<<24) & NVIC_IPR8_IPR_N3); }
static inline void nvic_ipr8_set_ipr_n2(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N2) | ((val<<16) & NVIC_IPR8_IPR_N2); }
static inline void nvic_ipr8_set_ipr_n1(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N1) | ((val<<8) & NVIC_IPR8_IPR_N1); }
static inline void nvic_ipr8_set_ipr_n0(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N0) | ((val<<0) & NVIC_IPR8_IPR_N0); }
static inline uint32_t nvic_ipr8_get_ipr_n3(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr8_get_ipr_n2(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr8_get_ipr_n1(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr8_get_ipr_n0(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N0) >> 0 ; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr9_set_ipr_n3(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N3) | ((val<<24) & NVIC_IPR9_IPR_N3); }
static inline void nvic_ipr9_set_ipr_n2(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N2) | ((val<<16) & NVIC_IPR9_IPR_N2); }
static inline void nvic_ipr9_set_ipr_n1(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N1) | ((val<<8) & NVIC_IPR9_IPR_N1); }
static inline void nvic_ipr9_set_ipr_n0(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N0) | ((val<<0) & NVIC_IPR9_IPR_N0); }
static inline uint32_t nvic_ipr9_get_ipr_n3(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr9_get_ipr_n2(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr9_get_ipr_n1(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr9_get_ipr_n0(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N0) >> 0 ; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr10_set_ipr_n3(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N3) | ((val<<24) & NVIC_IPR10_IPR_N3); }
static inline void nvic_ipr10_set_ipr_n2(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N2) | ((val<<16) & NVIC_IPR10_IPR_N2); }
static inline void nvic_ipr10_set_ipr_n1(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N1) | ((val<<8) & NVIC_IPR10_IPR_N1); }
static inline void nvic_ipr10_set_ipr_n0(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N0) | ((val<<0) & NVIC_IPR10_IPR_N0); }
static inline uint32_t nvic_ipr10_get_ipr_n3(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr10_get_ipr_n2(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr10_get_ipr_n1(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr10_get_ipr_n0(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N0) >> 0 ; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr11_set_ipr_n3(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N3) | ((val<<24) & NVIC_IPR11_IPR_N3); }
static inline void nvic_ipr11_set_ipr_n2(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N2) | ((val<<16) & NVIC_IPR11_IPR_N2); }
static inline void nvic_ipr11_set_ipr_n1(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N1) | ((val<<8) & NVIC_IPR11_IPR_N1); }
static inline void nvic_ipr11_set_ipr_n0(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N0) | ((val<<0) & NVIC_IPR11_IPR_N0); }
static inline uint32_t nvic_ipr11_get_ipr_n3(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr11_get_ipr_n2(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr11_get_ipr_n1(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr11_get_ipr_n0(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N0) >> 0 ; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr12_set_ipr_n3(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N3) | ((val<<24) & NVIC_IPR12_IPR_N3); }
static inline void nvic_ipr12_set_ipr_n2(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N2) | ((val<<16) & NVIC_IPR12_IPR_N2); }
static inline void nvic_ipr12_set_ipr_n1(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N1) | ((val<<8) & NVIC_IPR12_IPR_N1); }
static inline void nvic_ipr12_set_ipr_n0(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N0) | ((val<<0) & NVIC_IPR12_IPR_N0); }
static inline uint32_t nvic_ipr12_get_ipr_n3(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr12_get_ipr_n2(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr12_get_ipr_n1(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr12_get_ipr_n0(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N0) >> 0 ; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr13_set_ipr_n3(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N3) | ((val<<24) & NVIC_IPR13_IPR_N3); }
static inline void nvic_ipr13_set_ipr_n2(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N2) | ((val<<16) & NVIC_IPR13_IPR_N2); }
static inline void nvic_ipr13_set_ipr_n1(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N1) | ((val<<8) & NVIC_IPR13_IPR_N1); }
static inline void nvic_ipr13_set_ipr_n0(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N0) | ((val<<0) & NVIC_IPR13_IPR_N0); }
static inline uint32_t nvic_ipr13_get_ipr_n3(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr13_get_ipr_n2(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr13_get_ipr_n1(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr13_get_ipr_n0(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N0) >> 0 ; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr14_set_ipr_n3(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N3) | ((val<<24) & NVIC_IPR14_IPR_N3); }
static inline void nvic_ipr14_set_ipr_n2(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N2) | ((val<<16) & NVIC_IPR14_IPR_N2); }
static inline void nvic_ipr14_set_ipr_n1(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N1) | ((val<<8) & NVIC_IPR14_IPR_N1); }
static inline void nvic_ipr14_set_ipr_n0(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N0) | ((val<<0) & NVIC_IPR14_IPR_N0); }
static inline uint32_t nvic_ipr14_get_ipr_n3(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr14_get_ipr_n2(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr14_get_ipr_n1(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr14_get_ipr_n0(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N0) >> 0 ; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr15_set_ipr_n3(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N3) | ((val<<24) & NVIC_IPR15_IPR_N3); }
static inline void nvic_ipr15_set_ipr_n2(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N2) | ((val<<16) & NVIC_IPR15_IPR_N2); }
static inline void nvic_ipr15_set_ipr_n1(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N1) | ((val<<8) & NVIC_IPR15_IPR_N1); }
static inline void nvic_ipr15_set_ipr_n0(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N0) | ((val<<0) & NVIC_IPR15_IPR_N0); }
static inline uint32_t nvic_ipr15_get_ipr_n3(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr15_get_ipr_n2(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr15_get_ipr_n1(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr15_get_ipr_n0(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N0) >> 0 ; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr16_set_ipr_n3(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N3) | ((val<<24) & NVIC_IPR16_IPR_N3); }
static inline void nvic_ipr16_set_ipr_n2(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N2) | ((val<<16) & NVIC_IPR16_IPR_N2); }
static inline void nvic_ipr16_set_ipr_n1(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N1) | ((val<<8) & NVIC_IPR16_IPR_N1); }
static inline void nvic_ipr16_set_ipr_n0(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N0) | ((val<<0) & NVIC_IPR16_IPR_N0); }
static inline uint32_t nvic_ipr16_get_ipr_n3(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr16_get_ipr_n2(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr16_get_ipr_n1(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr16_get_ipr_n0(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N0) >> 0 ; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr17_set_ipr_n3(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N3) | ((val<<24) & NVIC_IPR17_IPR_N3); }
static inline void nvic_ipr17_set_ipr_n2(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N2) | ((val<<16) & NVIC_IPR17_IPR_N2); }
static inline void nvic_ipr17_set_ipr_n1(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N1) | ((val<<8) & NVIC_IPR17_IPR_N1); }
static inline void nvic_ipr17_set_ipr_n0(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N0) | ((val<<0) & NVIC_IPR17_IPR_N0); }
static inline uint32_t nvic_ipr17_get_ipr_n3(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr17_get_ipr_n2(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr17_get_ipr_n1(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr17_get_ipr_n0(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N0) >> 0 ; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr18_set_ipr_n3(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N3) | ((val<<24) & NVIC_IPR18_IPR_N3); }
static inline void nvic_ipr18_set_ipr_n2(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N2) | ((val<<16) & NVIC_IPR18_IPR_N2); }
static inline void nvic_ipr18_set_ipr_n1(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N1) | ((val<<8) & NVIC_IPR18_IPR_N1); }
static inline void nvic_ipr18_set_ipr_n0(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N0) | ((val<<0) & NVIC_IPR18_IPR_N0); }
static inline uint32_t nvic_ipr18_get_ipr_n3(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr18_get_ipr_n2(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr18_get_ipr_n1(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr18_get_ipr_n0(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N0) >> 0 ; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr19_set_ipr_n3(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N3) | ((val<<24) & NVIC_IPR19_IPR_N3); }
static inline void nvic_ipr19_set_ipr_n2(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N2) | ((val<<16) & NVIC_IPR19_IPR_N2); }
static inline void nvic_ipr19_set_ipr_n1(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N1) | ((val<<8) & NVIC_IPR19_IPR_N1); }
static inline void nvic_ipr19_set_ipr_n0(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N0) | ((val<<0) & NVIC_IPR19_IPR_N0); }
static inline uint32_t nvic_ipr19_get_ipr_n3(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr19_get_ipr_n2(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr19_get_ipr_n1(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr19_get_ipr_n0(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N0) >> 0 ; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr20_set_ipr_n3(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N3) | ((val<<24) & NVIC_IPR20_IPR_N3); }
static inline void nvic_ipr20_set_ipr_n2(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N2) | ((val<<16) & NVIC_IPR20_IPR_N2); }
static inline void nvic_ipr20_set_ipr_n1(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N1) | ((val<<8) & NVIC_IPR20_IPR_N1); }
static inline void nvic_ipr20_set_ipr_n0(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N0) | ((val<<0) & NVIC_IPR20_IPR_N0); }
static inline uint32_t nvic_ipr20_get_ipr_n3(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr20_get_ipr_n2(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr20_get_ipr_n1(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr20_get_ipr_n0(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N0) >> 0 ; }

/* Nested vectored interrupt controller
There is only one peripheral of type NVIC_STIR. */
struct NVIC_STIR_Type {
	__IO uint32_t STIR; // @0 Software trigger interrupt register
};
extern struct NVIC_STIR_Type	NVIC_STIR;	// @0xE000EF00 

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL<<9)-1) << 0, // Software generated interrupt ID		
};
static inline void nvic_stir_stir_set_intid(uint32_t val) { NVIC_STIR.STIR = (NVIC_STIR.STIR & ~NVIC_STIR_STIR_INTID) | ((val<<0) & NVIC_STIR_STIR_INTID); }
static inline uint32_t nvic_stir_stir_get_intid(void) { return (NVIC_STIR.STIR & NVIC_STIR_STIR_INTID) >> 0 ; }

/* Operational amplifiers
There is only one peripheral of type OPAMP. */
struct OPAMP_Type {
	__IO uint32_t OPAMP1_CSR; // @0 OPAMP1 control/status register
	__IO uint32_t OPAMP2_CSR; // @4 OPAMP2 control/status register
	__IO uint32_t OPAMP3_CSR; // @8 OPAMP3 control/status register
	__IO uint32_t OPAMP4_CSR; // @12 OPAMP4 control/status register
	__IO uint32_t OPAMP5_CSR; // @16 OPAMP5 control/status register
	__IO uint32_t OPAMP6_CSR; // @20 OPAMP6 control/status register
	__IO uint32_t OPAMP1_TCMR; // @24 OPAMP1 control/status register
	__IO uint32_t OPAMP2_TCMR; // @28 OPAMP2 control/status register
	__IO uint32_t OPAMP3_TCMR; // @32 OPAMP3 control/status register
	__IO uint32_t OPAMP4_TCMR; // @36 OPAMP4 control/status register
	__IO uint32_t OPAMP5_TCMR; // @40 OPAMP5 control/status register
	__IO uint32_t OPAMP6_TCMR; // @44 OPAMP6 control/status register
};
extern struct OPAMP_Type	OPAMP;	// @0x40010300 

// OPAMP->OPAMP1_CSR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_CSR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP1_CSR_CALOUT = 1UL<<30, // CALOUT
	OPAMP_OPAMP1_CSR_TRIMOFFSETN = ((1UL<<5)-1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP1_CSR_TRIMOFFSETP = ((1UL<<5)-1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP1_CSR_PGA_GAIN = ((1UL<<5)-1) << 14, // PGA_GAIN
	OPAMP_OPAMP1_CSR_CALSEL = ((1UL<<2)-1) << 12, // CALSEL
	OPAMP_OPAMP1_CSR_CALON = 1UL<<11, // CALON
	OPAMP_OPAMP1_CSR_OPAINTOEN = 1UL<<8, // OPAINTOEN
	OPAMP_OPAMP1_CSR_OPAHSM = 1UL<<7, // OPAHSM
	OPAMP_OPAMP1_CSR_VM_SEL = ((1UL<<2)-1) << 5, // VM_SEL
	OPAMP_OPAMP1_CSR_USERTRIM = 1UL<<4, // USERTRIM
	OPAMP_OPAMP1_CSR_VP_SEL = ((1UL<<2)-1) << 2, // VP_SEL
	OPAMP_OPAMP1_CSR_FORCE_VP = 1UL<<1, // FORCE_VP
	OPAMP_OPAMP1_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
static inline void opamp_opamp1_csr_set_trimoffsetn(uint32_t val) { OPAMP.OPAMP1_CSR = (OPAMP.OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_TRIMOFFSETN) | ((val<<24) & OPAMP_OPAMP1_CSR_TRIMOFFSETN); }
static inline void opamp_opamp1_csr_set_trimoffsetp(uint32_t val) { OPAMP.OPAMP1_CSR = (OPAMP.OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_TRIMOFFSETP) | ((val<<19) & OPAMP_OPAMP1_CSR_TRIMOFFSETP); }
static inline void opamp_opamp1_csr_set_pga_gain(uint32_t val) { OPAMP.OPAMP1_CSR = (OPAMP.OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP1_CSR_PGA_GAIN); }
static inline void opamp_opamp1_csr_set_calsel(uint32_t val) { OPAMP.OPAMP1_CSR = (OPAMP.OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP1_CSR_CALSEL); }
static inline void opamp_opamp1_csr_set_vm_sel(uint32_t val) { OPAMP.OPAMP1_CSR = (OPAMP.OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP1_CSR_VM_SEL); }
static inline void opamp_opamp1_csr_set_vp_sel(uint32_t val) { OPAMP.OPAMP1_CSR = (OPAMP.OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP1_CSR_VP_SEL); }
static inline uint32_t opamp_opamp1_csr_get_trimoffsetn(void) { return (OPAMP.OPAMP1_CSR & OPAMP_OPAMP1_CSR_TRIMOFFSETN) >> 24 ; }
static inline uint32_t opamp_opamp1_csr_get_trimoffsetp(void) { return (OPAMP.OPAMP1_CSR & OPAMP_OPAMP1_CSR_TRIMOFFSETP) >> 19 ; }
static inline uint32_t opamp_opamp1_csr_get_pga_gain(void) { return (OPAMP.OPAMP1_CSR & OPAMP_OPAMP1_CSR_PGA_GAIN) >> 14 ; }
static inline uint32_t opamp_opamp1_csr_get_calsel(void) { return (OPAMP.OPAMP1_CSR & OPAMP_OPAMP1_CSR_CALSEL) >> 12 ; }
static inline uint32_t opamp_opamp1_csr_get_vm_sel(void) { return (OPAMP.OPAMP1_CSR & OPAMP_OPAMP1_CSR_VM_SEL) >> 5 ; }
static inline uint32_t opamp_opamp1_csr_get_vp_sel(void) { return (OPAMP.OPAMP1_CSR & OPAMP_OPAMP1_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP2_CSR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_CSR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP2_CSR_CALOUT = 1UL<<30, // CALOUT
	OPAMP_OPAMP2_CSR_TRIMOFFSETN = ((1UL<<5)-1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP2_CSR_TRIMOFFSETP = ((1UL<<5)-1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP2_CSR_PGA_GAIN = ((1UL<<5)-1) << 14, // PGA_GAIN
	OPAMP_OPAMP2_CSR_CALSEL = ((1UL<<2)-1) << 12, // CALSEL
	OPAMP_OPAMP2_CSR_CALON = 1UL<<11, // CALON
	OPAMP_OPAMP2_CSR_OPAINTOEN = 1UL<<8, // OPAINTOEN
	OPAMP_OPAMP2_CSR_OPAHSM = 1UL<<7, // OPAHSM
	OPAMP_OPAMP2_CSR_VM_SEL = ((1UL<<2)-1) << 5, // VM_SEL
	OPAMP_OPAMP2_CSR_USERTRIM = 1UL<<4, // USERTRIM
	OPAMP_OPAMP2_CSR_VP_SEL = ((1UL<<2)-1) << 2, // VP_SEL
	OPAMP_OPAMP2_CSR_FORCE_VP = 1UL<<1, // FORCE_VP
	OPAMP_OPAMP2_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
static inline void opamp_opamp2_csr_set_trimoffsetn(uint32_t val) { OPAMP.OPAMP2_CSR = (OPAMP.OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_TRIMOFFSETN) | ((val<<24) & OPAMP_OPAMP2_CSR_TRIMOFFSETN); }
static inline void opamp_opamp2_csr_set_trimoffsetp(uint32_t val) { OPAMP.OPAMP2_CSR = (OPAMP.OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_TRIMOFFSETP) | ((val<<19) & OPAMP_OPAMP2_CSR_TRIMOFFSETP); }
static inline void opamp_opamp2_csr_set_pga_gain(uint32_t val) { OPAMP.OPAMP2_CSR = (OPAMP.OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP2_CSR_PGA_GAIN); }
static inline void opamp_opamp2_csr_set_calsel(uint32_t val) { OPAMP.OPAMP2_CSR = (OPAMP.OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP2_CSR_CALSEL); }
static inline void opamp_opamp2_csr_set_vm_sel(uint32_t val) { OPAMP.OPAMP2_CSR = (OPAMP.OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP2_CSR_VM_SEL); }
static inline void opamp_opamp2_csr_set_vp_sel(uint32_t val) { OPAMP.OPAMP2_CSR = (OPAMP.OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP2_CSR_VP_SEL); }
static inline uint32_t opamp_opamp2_csr_get_trimoffsetn(void) { return (OPAMP.OPAMP2_CSR & OPAMP_OPAMP2_CSR_TRIMOFFSETN) >> 24 ; }
static inline uint32_t opamp_opamp2_csr_get_trimoffsetp(void) { return (OPAMP.OPAMP2_CSR & OPAMP_OPAMP2_CSR_TRIMOFFSETP) >> 19 ; }
static inline uint32_t opamp_opamp2_csr_get_pga_gain(void) { return (OPAMP.OPAMP2_CSR & OPAMP_OPAMP2_CSR_PGA_GAIN) >> 14 ; }
static inline uint32_t opamp_opamp2_csr_get_calsel(void) { return (OPAMP.OPAMP2_CSR & OPAMP_OPAMP2_CSR_CALSEL) >> 12 ; }
static inline uint32_t opamp_opamp2_csr_get_vm_sel(void) { return (OPAMP.OPAMP2_CSR & OPAMP_OPAMP2_CSR_VM_SEL) >> 5 ; }
static inline uint32_t opamp_opamp2_csr_get_vp_sel(void) { return (OPAMP.OPAMP2_CSR & OPAMP_OPAMP2_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP3_CSR OPAMP3 control/status register
enum {
	OPAMP_OPAMP3_CSR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP3_CSR_CALOUT = 1UL<<30, // CALOUT
	OPAMP_OPAMP3_CSR_TRIMOFFSETN = ((1UL<<5)-1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP3_CSR_TRIMOFFSETP = ((1UL<<5)-1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP3_CSR_PGA_GAIN = ((1UL<<5)-1) << 14, // PGA_GAIN
	OPAMP_OPAMP3_CSR_CALSEL = ((1UL<<2)-1) << 12, // CALSEL
	OPAMP_OPAMP3_CSR_CALON = 1UL<<11, // CALON
	OPAMP_OPAMP3_CSR_OPAINTOEN = 1UL<<8, // OPAINTOEN
	OPAMP_OPAMP3_CSR_OPAHSM = 1UL<<7, // OPAHSM
	OPAMP_OPAMP3_CSR_VM_SEL = ((1UL<<2)-1) << 5, // VM_SEL
	OPAMP_OPAMP3_CSR_USERTRIM = 1UL<<4, // USERTRIM
	OPAMP_OPAMP3_CSR_VP_SEL = ((1UL<<2)-1) << 2, // VP_SEL
	OPAMP_OPAMP3_CSR_FORCE_VP = 1UL<<1, // FORCE_VP
	OPAMP_OPAMP3_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
static inline void opamp_opamp3_csr_set_trimoffsetn(uint32_t val) { OPAMP.OPAMP3_CSR = (OPAMP.OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_TRIMOFFSETN) | ((val<<24) & OPAMP_OPAMP3_CSR_TRIMOFFSETN); }
static inline void opamp_opamp3_csr_set_trimoffsetp(uint32_t val) { OPAMP.OPAMP3_CSR = (OPAMP.OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_TRIMOFFSETP) | ((val<<19) & OPAMP_OPAMP3_CSR_TRIMOFFSETP); }
static inline void opamp_opamp3_csr_set_pga_gain(uint32_t val) { OPAMP.OPAMP3_CSR = (OPAMP.OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP3_CSR_PGA_GAIN); }
static inline void opamp_opamp3_csr_set_calsel(uint32_t val) { OPAMP.OPAMP3_CSR = (OPAMP.OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP3_CSR_CALSEL); }
static inline void opamp_opamp3_csr_set_vm_sel(uint32_t val) { OPAMP.OPAMP3_CSR = (OPAMP.OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP3_CSR_VM_SEL); }
static inline void opamp_opamp3_csr_set_vp_sel(uint32_t val) { OPAMP.OPAMP3_CSR = (OPAMP.OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP3_CSR_VP_SEL); }
static inline uint32_t opamp_opamp3_csr_get_trimoffsetn(void) { return (OPAMP.OPAMP3_CSR & OPAMP_OPAMP3_CSR_TRIMOFFSETN) >> 24 ; }
static inline uint32_t opamp_opamp3_csr_get_trimoffsetp(void) { return (OPAMP.OPAMP3_CSR & OPAMP_OPAMP3_CSR_TRIMOFFSETP) >> 19 ; }
static inline uint32_t opamp_opamp3_csr_get_pga_gain(void) { return (OPAMP.OPAMP3_CSR & OPAMP_OPAMP3_CSR_PGA_GAIN) >> 14 ; }
static inline uint32_t opamp_opamp3_csr_get_calsel(void) { return (OPAMP.OPAMP3_CSR & OPAMP_OPAMP3_CSR_CALSEL) >> 12 ; }
static inline uint32_t opamp_opamp3_csr_get_vm_sel(void) { return (OPAMP.OPAMP3_CSR & OPAMP_OPAMP3_CSR_VM_SEL) >> 5 ; }
static inline uint32_t opamp_opamp3_csr_get_vp_sel(void) { return (OPAMP.OPAMP3_CSR & OPAMP_OPAMP3_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP4_CSR OPAMP4 control/status register
enum {
	OPAMP_OPAMP4_CSR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP4_CSR_CALOUT = 1UL<<30, // CALOUT
	OPAMP_OPAMP4_CSR_TRIMOFFSETN = ((1UL<<5)-1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP4_CSR_TRIMOFFSETP = ((1UL<<5)-1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP4_CSR_PGA_GAIN = ((1UL<<5)-1) << 14, // PGA_GAIN
	OPAMP_OPAMP4_CSR_CALSEL = ((1UL<<2)-1) << 12, // CALSEL
	OPAMP_OPAMP4_CSR_CALON = 1UL<<11, // CALON
	OPAMP_OPAMP4_CSR_OPAINTOEN = 1UL<<8, // OPAINTOEN
	OPAMP_OPAMP4_CSR_OPAHSM = 1UL<<7, // OPAHSM
	OPAMP_OPAMP4_CSR_VM_SEL = ((1UL<<2)-1) << 5, // VM_SEL
	OPAMP_OPAMP4_CSR_USERTRIM = 1UL<<4, // USERTRIM
	OPAMP_OPAMP4_CSR_VP_SEL = ((1UL<<2)-1) << 2, // VP_SEL
	OPAMP_OPAMP4_CSR_FORCE_VP = 1UL<<1, // FORCE_VP
	OPAMP_OPAMP4_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
static inline void opamp_opamp4_csr_set_trimoffsetn(uint32_t val) { OPAMP.OPAMP4_CSR = (OPAMP.OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_TRIMOFFSETN) | ((val<<24) & OPAMP_OPAMP4_CSR_TRIMOFFSETN); }
static inline void opamp_opamp4_csr_set_trimoffsetp(uint32_t val) { OPAMP.OPAMP4_CSR = (OPAMP.OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_TRIMOFFSETP) | ((val<<19) & OPAMP_OPAMP4_CSR_TRIMOFFSETP); }
static inline void opamp_opamp4_csr_set_pga_gain(uint32_t val) { OPAMP.OPAMP4_CSR = (OPAMP.OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP4_CSR_PGA_GAIN); }
static inline void opamp_opamp4_csr_set_calsel(uint32_t val) { OPAMP.OPAMP4_CSR = (OPAMP.OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP4_CSR_CALSEL); }
static inline void opamp_opamp4_csr_set_vm_sel(uint32_t val) { OPAMP.OPAMP4_CSR = (OPAMP.OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP4_CSR_VM_SEL); }
static inline void opamp_opamp4_csr_set_vp_sel(uint32_t val) { OPAMP.OPAMP4_CSR = (OPAMP.OPAMP4_CSR & ~OPAMP_OPAMP4_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP4_CSR_VP_SEL); }
static inline uint32_t opamp_opamp4_csr_get_trimoffsetn(void) { return (OPAMP.OPAMP4_CSR & OPAMP_OPAMP4_CSR_TRIMOFFSETN) >> 24 ; }
static inline uint32_t opamp_opamp4_csr_get_trimoffsetp(void) { return (OPAMP.OPAMP4_CSR & OPAMP_OPAMP4_CSR_TRIMOFFSETP) >> 19 ; }
static inline uint32_t opamp_opamp4_csr_get_pga_gain(void) { return (OPAMP.OPAMP4_CSR & OPAMP_OPAMP4_CSR_PGA_GAIN) >> 14 ; }
static inline uint32_t opamp_opamp4_csr_get_calsel(void) { return (OPAMP.OPAMP4_CSR & OPAMP_OPAMP4_CSR_CALSEL) >> 12 ; }
static inline uint32_t opamp_opamp4_csr_get_vm_sel(void) { return (OPAMP.OPAMP4_CSR & OPAMP_OPAMP4_CSR_VM_SEL) >> 5 ; }
static inline uint32_t opamp_opamp4_csr_get_vp_sel(void) { return (OPAMP.OPAMP4_CSR & OPAMP_OPAMP4_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP5_CSR OPAMP5 control/status register
enum {
	OPAMP_OPAMP5_CSR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP5_CSR_CALOUT = 1UL<<30, // CALOUT
	OPAMP_OPAMP5_CSR_TRIMOFFSETN = ((1UL<<5)-1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP5_CSR_TRIMOFFSETP = ((1UL<<5)-1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP5_CSR_PGA_GAIN = ((1UL<<5)-1) << 14, // PGA_GAIN
	OPAMP_OPAMP5_CSR_CALSEL = ((1UL<<2)-1) << 12, // CALSEL
	OPAMP_OPAMP5_CSR_CALON = 1UL<<11, // CALON
	OPAMP_OPAMP5_CSR_OPAINTOEN = 1UL<<8, // OPAINTOEN
	OPAMP_OPAMP5_CSR_OPAHSM = 1UL<<7, // OPAHSM
	OPAMP_OPAMP5_CSR_VM_SEL = ((1UL<<2)-1) << 5, // VM_SEL
	OPAMP_OPAMP5_CSR_USERTRIM = 1UL<<4, // USERTRIM
	OPAMP_OPAMP5_CSR_VP_SEL = ((1UL<<2)-1) << 2, // VP_SEL
	OPAMP_OPAMP5_CSR_FORCE_VP = 1UL<<1, // FORCE_VP
	OPAMP_OPAMP5_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
static inline void opamp_opamp5_csr_set_trimoffsetn(uint32_t val) { OPAMP.OPAMP5_CSR = (OPAMP.OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_TRIMOFFSETN) | ((val<<24) & OPAMP_OPAMP5_CSR_TRIMOFFSETN); }
static inline void opamp_opamp5_csr_set_trimoffsetp(uint32_t val) { OPAMP.OPAMP5_CSR = (OPAMP.OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_TRIMOFFSETP) | ((val<<19) & OPAMP_OPAMP5_CSR_TRIMOFFSETP); }
static inline void opamp_opamp5_csr_set_pga_gain(uint32_t val) { OPAMP.OPAMP5_CSR = (OPAMP.OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP5_CSR_PGA_GAIN); }
static inline void opamp_opamp5_csr_set_calsel(uint32_t val) { OPAMP.OPAMP5_CSR = (OPAMP.OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP5_CSR_CALSEL); }
static inline void opamp_opamp5_csr_set_vm_sel(uint32_t val) { OPAMP.OPAMP5_CSR = (OPAMP.OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP5_CSR_VM_SEL); }
static inline void opamp_opamp5_csr_set_vp_sel(uint32_t val) { OPAMP.OPAMP5_CSR = (OPAMP.OPAMP5_CSR & ~OPAMP_OPAMP5_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP5_CSR_VP_SEL); }
static inline uint32_t opamp_opamp5_csr_get_trimoffsetn(void) { return (OPAMP.OPAMP5_CSR & OPAMP_OPAMP5_CSR_TRIMOFFSETN) >> 24 ; }
static inline uint32_t opamp_opamp5_csr_get_trimoffsetp(void) { return (OPAMP.OPAMP5_CSR & OPAMP_OPAMP5_CSR_TRIMOFFSETP) >> 19 ; }
static inline uint32_t opamp_opamp5_csr_get_pga_gain(void) { return (OPAMP.OPAMP5_CSR & OPAMP_OPAMP5_CSR_PGA_GAIN) >> 14 ; }
static inline uint32_t opamp_opamp5_csr_get_calsel(void) { return (OPAMP.OPAMP5_CSR & OPAMP_OPAMP5_CSR_CALSEL) >> 12 ; }
static inline uint32_t opamp_opamp5_csr_get_vm_sel(void) { return (OPAMP.OPAMP5_CSR & OPAMP_OPAMP5_CSR_VM_SEL) >> 5 ; }
static inline uint32_t opamp_opamp5_csr_get_vp_sel(void) { return (OPAMP.OPAMP5_CSR & OPAMP_OPAMP5_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP6_CSR OPAMP6 control/status register
enum {
	OPAMP_OPAMP6_CSR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP6_CSR_CALOUT = 1UL<<30, // CALOUT
	OPAMP_OPAMP6_CSR_TRIMOFFSETN = ((1UL<<5)-1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP6_CSR_TRIMOFFSETP = ((1UL<<5)-1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP6_CSR_PGA_GAIN = ((1UL<<5)-1) << 14, // PGA_GAIN
	OPAMP_OPAMP6_CSR_CALSEL = ((1UL<<2)-1) << 12, // CALSEL
	OPAMP_OPAMP6_CSR_CALON = 1UL<<11, // CALON
	OPAMP_OPAMP6_CSR_OPAINTOEN = 1UL<<8, // OPAINTOEN
	OPAMP_OPAMP6_CSR_OPAHSM = 1UL<<7, // OPAHSM
	OPAMP_OPAMP6_CSR_VM_SEL = ((1UL<<2)-1) << 5, // VM_SEL
	OPAMP_OPAMP6_CSR_USERTRIM = 1UL<<4, // USERTRIM
	OPAMP_OPAMP6_CSR_VP_SEL = ((1UL<<2)-1) << 2, // VP_SEL
	OPAMP_OPAMP6_CSR_FORCE_VP = 1UL<<1, // FORCE_VP
	OPAMP_OPAMP6_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
static inline void opamp_opamp6_csr_set_trimoffsetn(uint32_t val) { OPAMP.OPAMP6_CSR = (OPAMP.OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_TRIMOFFSETN) | ((val<<24) & OPAMP_OPAMP6_CSR_TRIMOFFSETN); }
static inline void opamp_opamp6_csr_set_trimoffsetp(uint32_t val) { OPAMP.OPAMP6_CSR = (OPAMP.OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_TRIMOFFSETP) | ((val<<19) & OPAMP_OPAMP6_CSR_TRIMOFFSETP); }
static inline void opamp_opamp6_csr_set_pga_gain(uint32_t val) { OPAMP.OPAMP6_CSR = (OPAMP.OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_PGA_GAIN) | ((val<<14) & OPAMP_OPAMP6_CSR_PGA_GAIN); }
static inline void opamp_opamp6_csr_set_calsel(uint32_t val) { OPAMP.OPAMP6_CSR = (OPAMP.OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_CALSEL) | ((val<<12) & OPAMP_OPAMP6_CSR_CALSEL); }
static inline void opamp_opamp6_csr_set_vm_sel(uint32_t val) { OPAMP.OPAMP6_CSR = (OPAMP.OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_VM_SEL) | ((val<<5) & OPAMP_OPAMP6_CSR_VM_SEL); }
static inline void opamp_opamp6_csr_set_vp_sel(uint32_t val) { OPAMP.OPAMP6_CSR = (OPAMP.OPAMP6_CSR & ~OPAMP_OPAMP6_CSR_VP_SEL) | ((val<<2) & OPAMP_OPAMP6_CSR_VP_SEL); }
static inline uint32_t opamp_opamp6_csr_get_trimoffsetn(void) { return (OPAMP.OPAMP6_CSR & OPAMP_OPAMP6_CSR_TRIMOFFSETN) >> 24 ; }
static inline uint32_t opamp_opamp6_csr_get_trimoffsetp(void) { return (OPAMP.OPAMP6_CSR & OPAMP_OPAMP6_CSR_TRIMOFFSETP) >> 19 ; }
static inline uint32_t opamp_opamp6_csr_get_pga_gain(void) { return (OPAMP.OPAMP6_CSR & OPAMP_OPAMP6_CSR_PGA_GAIN) >> 14 ; }
static inline uint32_t opamp_opamp6_csr_get_calsel(void) { return (OPAMP.OPAMP6_CSR & OPAMP_OPAMP6_CSR_CALSEL) >> 12 ; }
static inline uint32_t opamp_opamp6_csr_get_vm_sel(void) { return (OPAMP.OPAMP6_CSR & OPAMP_OPAMP6_CSR_VM_SEL) >> 5 ; }
static inline uint32_t opamp_opamp6_csr_get_vp_sel(void) { return (OPAMP.OPAMP6_CSR & OPAMP_OPAMP6_CSR_VP_SEL) >> 2 ; }

// OPAMP->OPAMP1_TCMR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_TCMR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP1_TCMR_T20CM_EN = 1UL<<5, // T20CM_EN
	OPAMP_OPAMP1_TCMR_T8CM_EN = 1UL<<4, // T8CM_EN
	OPAMP_OPAMP1_TCMR_T1CM_EN = 1UL<<3, // T1CM_EN
	OPAMP_OPAMP1_TCMR_VPS_SEL = ((1UL<<2)-1) << 1, // VPS_SEL
	OPAMP_OPAMP1_TCMR_VMS_SEL = 1UL<<0, // VMS_SEL		
};
static inline void opamp_opamp1_tcmr_set_vps_sel(uint32_t val) { OPAMP.OPAMP1_TCMR = (OPAMP.OPAMP1_TCMR & ~OPAMP_OPAMP1_TCMR_VPS_SEL) | ((val<<1) & OPAMP_OPAMP1_TCMR_VPS_SEL); }
static inline uint32_t opamp_opamp1_tcmr_get_vps_sel(void) { return (OPAMP.OPAMP1_TCMR & OPAMP_OPAMP1_TCMR_VPS_SEL) >> 1 ; }

// OPAMP->OPAMP2_TCMR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_TCMR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP2_TCMR_T20CM_EN = 1UL<<5, // T20CM_EN
	OPAMP_OPAMP2_TCMR_T8CM_EN = 1UL<<4, // T8CM_EN
	OPAMP_OPAMP2_TCMR_T1CM_EN = 1UL<<3, // T1CM_EN
	OPAMP_OPAMP2_TCMR_VPS_SEL = ((1UL<<2)-1) << 1, // VPS_SEL
	OPAMP_OPAMP2_TCMR_VMS_SEL = 1UL<<0, // VMS_SEL		
};
static inline void opamp_opamp2_tcmr_set_vps_sel(uint32_t val) { OPAMP.OPAMP2_TCMR = (OPAMP.OPAMP2_TCMR & ~OPAMP_OPAMP2_TCMR_VPS_SEL) | ((val<<1) & OPAMP_OPAMP2_TCMR_VPS_SEL); }
static inline uint32_t opamp_opamp2_tcmr_get_vps_sel(void) { return (OPAMP.OPAMP2_TCMR & OPAMP_OPAMP2_TCMR_VPS_SEL) >> 1 ; }

// OPAMP->OPAMP3_TCMR OPAMP3 control/status register
enum {
	OPAMP_OPAMP3_TCMR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP3_TCMR_T20CM_EN = 1UL<<5, // T20CM_EN
	OPAMP_OPAMP3_TCMR_T8CM_EN = 1UL<<4, // T8CM_EN
	OPAMP_OPAMP3_TCMR_T1CM_EN = 1UL<<3, // T1CM_EN
	OPAMP_OPAMP3_TCMR_VPS_SEL = ((1UL<<2)-1) << 1, // VPS_SEL
	OPAMP_OPAMP3_TCMR_VMS_SEL = 1UL<<0, // VMS_SEL		
};
static inline void opamp_opamp3_tcmr_set_vps_sel(uint32_t val) { OPAMP.OPAMP3_TCMR = (OPAMP.OPAMP3_TCMR & ~OPAMP_OPAMP3_TCMR_VPS_SEL) | ((val<<1) & OPAMP_OPAMP3_TCMR_VPS_SEL); }
static inline uint32_t opamp_opamp3_tcmr_get_vps_sel(void) { return (OPAMP.OPAMP3_TCMR & OPAMP_OPAMP3_TCMR_VPS_SEL) >> 1 ; }

// OPAMP->OPAMP4_TCMR OPAMP4 control/status register
enum {
	OPAMP_OPAMP4_TCMR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP4_TCMR_T20CM_EN = 1UL<<5, // T20CM_EN
	OPAMP_OPAMP4_TCMR_T8CM_EN = 1UL<<4, // T8CM_EN
	OPAMP_OPAMP4_TCMR_T1CM_EN = 1UL<<3, // T1CM_EN
	OPAMP_OPAMP4_TCMR_VPS_SEL = ((1UL<<2)-1) << 1, // VPS_SEL
	OPAMP_OPAMP4_TCMR_VMS_SEL = 1UL<<0, // VMS_SEL		
};
static inline void opamp_opamp4_tcmr_set_vps_sel(uint32_t val) { OPAMP.OPAMP4_TCMR = (OPAMP.OPAMP4_TCMR & ~OPAMP_OPAMP4_TCMR_VPS_SEL) | ((val<<1) & OPAMP_OPAMP4_TCMR_VPS_SEL); }
static inline uint32_t opamp_opamp4_tcmr_get_vps_sel(void) { return (OPAMP.OPAMP4_TCMR & OPAMP_OPAMP4_TCMR_VPS_SEL) >> 1 ; }

// OPAMP->OPAMP5_TCMR OPAMP5 control/status register
enum {
	OPAMP_OPAMP5_TCMR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP5_TCMR_T20CM_EN = 1UL<<5, // T20CM_EN
	OPAMP_OPAMP5_TCMR_T8CM_EN = 1UL<<4, // T8CM_EN
	OPAMP_OPAMP5_TCMR_T1CM_EN = 1UL<<3, // T1CM_EN
	OPAMP_OPAMP5_TCMR_VPS_SEL = ((1UL<<2)-1) << 1, // VPS_SEL
	OPAMP_OPAMP5_TCMR_VMS_SEL = 1UL<<0, // VMS_SEL		
};
static inline void opamp_opamp5_tcmr_set_vps_sel(uint32_t val) { OPAMP.OPAMP5_TCMR = (OPAMP.OPAMP5_TCMR & ~OPAMP_OPAMP5_TCMR_VPS_SEL) | ((val<<1) & OPAMP_OPAMP5_TCMR_VPS_SEL); }
static inline uint32_t opamp_opamp5_tcmr_get_vps_sel(void) { return (OPAMP.OPAMP5_TCMR & OPAMP_OPAMP5_TCMR_VPS_SEL) >> 1 ; }

// OPAMP->OPAMP6_TCMR OPAMP6 control/status register
enum {
	OPAMP_OPAMP6_TCMR_LOCK = 1UL<<31, // LOCK
	OPAMP_OPAMP6_TCMR_T20CM_EN = 1UL<<5, // T20CM_EN
	OPAMP_OPAMP6_TCMR_T8CM_EN = 1UL<<4, // T8CM_EN
	OPAMP_OPAMP6_TCMR_T1CM_EN = 1UL<<3, // T1CM_EN
	OPAMP_OPAMP6_TCMR_VPS_SEL = ((1UL<<2)-1) << 1, // VPS_SEL
	OPAMP_OPAMP6_TCMR_VMS_SEL = 1UL<<0, // VMS_SEL		
};
static inline void opamp_opamp6_tcmr_set_vps_sel(uint32_t val) { OPAMP.OPAMP6_TCMR = (OPAMP.OPAMP6_TCMR & ~OPAMP_OPAMP6_TCMR_VPS_SEL) | ((val<<1) & OPAMP_OPAMP6_TCMR_VPS_SEL); }
static inline uint32_t opamp_opamp6_tcmr_get_vps_sel(void) { return (OPAMP.OPAMP6_TCMR & OPAMP_OPAMP6_TCMR_VPS_SEL) >> 1 ; }

/* Power control
There is only one peripheral of type PWR. */
struct PWR_Type {
	__IO uint32_t CR1; // @0 Power control register 1
	__IO uint32_t CR2; // @4 Power control register 2
	__IO uint32_t CR3; // @8 Power control register 3
	__IO uint32_t CR4; // @12 Power control register 4
	__IO uint32_t SR1; // @16 Power status register 1
	__IO uint32_t SR2; // @20 Power status register 2
	__IO uint32_t SCR; // @24 Power status clear register
	 uint8_t RESERVED0[4]; // @28 
	__IO uint32_t PUCRA; // @32 Power Port A pull-up control register
	__IO uint32_t PDCRA; // @36 Power Port A pull-down control register
	__IO uint32_t PUCRB; // @40 Power Port B pull-up control register
	__IO uint32_t PDCRB; // @44 Power Port B pull-down control register
	__IO uint32_t PUCRC; // @48 Power Port C pull-up control register
	__IO uint32_t PDCRC; // @52 Power Port C pull-down control register
	__IO uint32_t PUCRD; // @56 Power Port D pull-up control register
	__IO uint32_t PDCRD; // @60 Power Port D pull-down control register
	__IO uint32_t PUCRE; // @64 Power Port E pull-up control register
	__IO uint32_t PDCRE; // @68 Power Port E pull-down control register
	__IO uint32_t PUCRF; // @72 Power Port F pull-up control register
	__IO uint32_t PDCRF; // @76 Power Port F pull-down control register
	__IO uint32_t PUCRG; // @80 Power Port G pull-up control register
	__IO uint32_t PDCRG; // @84 Power Port G pull-down control register
	 uint8_t RESERVED1[40]; // @88 
	__IO uint32_t CR5; // @128 Power control register
};
extern struct PWR_Type	PWR;	// @0x40007000 

// PWR->CR1 Power control register 1
enum {
	PWR_CR1_LPR = 1UL<<14, // Low-power run When this bit is set, the regulator is switched from main mode (MR) to low-power mode (LPR).
	PWR_CR1_VOS = ((1UL<<2)-1) << 9, // Voltage scaling range selection
	PWR_CR1_DBP = 1UL<<8, // Disable backup domain write protection In reset state, the RTC and backup registers are protected against parasitic write access. This bit must be set to enable write access to these registers.
	PWR_CR1_FPD_STOP = 1UL<<3, // FPD_STOP
	PWR_CR1_LPMS = ((1UL<<3)-1) << 0, // Low-power mode selection These bits select the low-power mode entered when CPU enters the deepsleep mode. 1xx: Shutdown mode Note: In Standby mode, SRAM2 can be preserved or not, depending on RRS bit configuration in PWR_CR3.		
};
static inline void pwr_cr1_set_vos(uint32_t val) { PWR.CR1 = (PWR.CR1 & ~PWR_CR1_VOS) | ((val<<9) & PWR_CR1_VOS); }
static inline void pwr_cr1_set_lpms(uint32_t val) { PWR.CR1 = (PWR.CR1 & ~PWR_CR1_LPMS) | ((val<<0) & PWR_CR1_LPMS); }
static inline uint32_t pwr_cr1_get_vos(void) { return (PWR.CR1 & PWR_CR1_VOS) >> 9 ; }
static inline uint32_t pwr_cr1_get_lpms(void) { return (PWR.CR1 & PWR_CR1_LPMS) >> 0 ; }

// PWR->CR2 Power control register 2
enum {
	PWR_CR2_PVMEN2 = 1UL<<7, // Peripheral voltage monitoring 4 enable: V<sub>DDA</sub> vs. DAC 1MSPS /DAC 15MSPS min voltage.
	PWR_CR2_PVMEN1 = 1UL<<6, // Peripheral voltage monitoring 3 enable: V<sub>DDA</sub> vs. ADC/COMP min voltage 1.62V
	PWR_CR2_PVDLS = ((1UL<<3)-1) << 1, // Programmable voltage detector level selection. These bits select the PVD falling threshold: Note: These bits are write-protected when the PVDL bit is set in the SYSCFG_CFGR2 register. The protection can be reset only by a system reset.
	PWR_CR2_PVDE = 1UL<<0, // Programmable voltage detector enable Note: This bit is write-protected when the PVDL bit is set in the SYSCFG_CFGR2 register. The protection can be reset only by a system reset.		
};
static inline void pwr_cr2_set_pvdls(uint32_t val) { PWR.CR2 = (PWR.CR2 & ~PWR_CR2_PVDLS) | ((val<<1) & PWR_CR2_PVDLS); }
static inline uint32_t pwr_cr2_get_pvdls(void) { return (PWR.CR2 & PWR_CR2_PVDLS) >> 1 ; }

// PWR->CR3 Power control register 3
enum {
	PWR_CR3_EIWUL = 1UL<<15, // Enable internal wakeup line
	PWR_CR3_UCPD1_DBDIS = 1UL<<14, // USB Type-C and Power Delivery Dead Battery disable. After exiting reset, the USB Type-C “dead battery” behavior is enabled, which may have a pull-down effect on CC1 and CC2 pins. It is recommended to disable it in all cases, either to stop this pull-down or to hand over control to the UCPD1 (which should therefore be initialized before doing the disable).
	PWR_CR3_UCPD1_STDBY = 1UL<<13, // UCPD1_STDBY USB Type-C and Power Delivery standby mode.
	PWR_CR3_APC = 1UL<<10, // Apply pull-up and pull-down configuration When this bit is set, the I/O pull-up and pull-down configurations defined in the PWR_PUCRx and PWR_PDCRx registers are applied. When this bit is cleared, the PWR_PUCRx and PWR_PDCRx registers are not applied to the I/Os.
	PWR_CR3_RRS = 1UL<<8, // SRAM2 retention in Standby mode
	PWR_CR3_EWUP5 = 1UL<<4, // Enable Wakeup pin WKUP5 When this bit is set, the external wakeup pin WKUP5 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP5 bit in the PWR_CR4 register.
	PWR_CR3_EWUP4 = 1UL<<3, // Enable Wakeup pin WKUP4 When this bit is set, the external wakeup pin WKUP4 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register.
	PWR_CR3_EWUP3 = 1UL<<2, // Enable Wakeup pin WKUP3 When this bit is set, the external wakeup pin WKUP3 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit in the PWR_CR4 register.
	PWR_CR3_EWUP2 = 1UL<<1, // Enable Wakeup pin WKUP2 When this bit is set, the external wakeup pin WKUP2 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit in the PWR_CR4 register.
	PWR_CR3_EWUP1 = 1UL<<0, // Enable Wakeup pin WKUP1 When this bit is set, the external wakeup pin WKUP1 is enabled and triggers a wakeup from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit in the PWR_CR4 register.		
};

// PWR->CR4 Power control register 4
enum {
	PWR_CR4_VBRS = 1UL<<9, // V<sub>BAT</sub> battery charging resistor selection
	PWR_CR4_VBE = 1UL<<8, // V<sub>BAT</sub> battery charging enable
	PWR_CR4_WP5 = 1UL<<4, // Wakeup pin WKUP5 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP5
	PWR_CR4_WP4 = 1UL<<3, // Wakeup pin WKUP4 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP4
	PWR_CR4_WP3 = 1UL<<2, // Wakeup pin WKUP3 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP3
	PWR_CR4_WP2 = 1UL<<1, // Wakeup pin WKUP2 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP2
	PWR_CR4_WP1 = 1UL<<0, // Wakeup pin WKUP1 polarity This bit defines the polarity used for an event detection on external wake-up pin, WKUP1		
};

// PWR->SR1 Power status register 1
enum {
	PWR_SR1_WUFI = 1UL<<15, // Wakeup flag internal This bit is set when a wakeup is detected on the internal wakeup line. It is cleared when all internal wakeup sources are cleared.
	PWR_SR1_SBF = 1UL<<8, // Standby flag This bit is set by hardware when the device enters the Standby mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset.
	PWR_SR1_WUF5 = 1UL<<4, // Wakeup flag 5 This bit is set when a wakeup event is detected on wakeup pin, WKUP5. It is cleared by writing ‘1’ in the CWUF5 bit of the PWR_SCR register.
	PWR_SR1_WUF4 = 1UL<<3, // Wakeup flag 4 This bit is set when a wakeup event is detected on wakeup pin,WKUP4. It is cleared by writing ‘1’ in the CWUF4 bit of the PWR_SCR register.
	PWR_SR1_WUF3 = 1UL<<2, // Wakeup flag 3 This bit is set when a wakeup event is detected on wakeup pin, WKUP3. It is cleared by writing ‘1’ in the CWUF3 bit of the PWR_SCR register.
	PWR_SR1_WUF2 = 1UL<<1, // Wakeup flag 2 This bit is set when a wakeup event is detected on wakeup pin, WKUP2. It is cleared by writing ‘1’ in the CWUF2 bit of the PWR_SCR register.
	PWR_SR1_WUF1 = 1UL<<0, // Wakeup flag 1 This bit is set when a wakeup event is detected on wakeup pin, WKUP1. It is cleared by writing ‘1’ in the CWUF1 bit of the PWR_SCR register.		
};

// PWR->SR2 Power status register 2
enum {
	PWR_SR2_PVMO2 = 1UL<<15, // Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.8 V Note: PVMO2 is cleared when PVM2 is disabled (PVME = 0). After enabling PVM2, the PVM2 output is valid after the PVM2 wakeup time.
	PWR_SR2_PVMO1 = 1UL<<14, // Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.62 V Note: PVMO1 is cleared when PVM1 is disabled (PVME = 0). After enabling PVM1, the PVM1 output is valid after the PVM1 wakeup time.
	PWR_SR2_PVDO = 1UL<<11, // Programmable voltage detector output
	PWR_SR2_VOSF = 1UL<<10, // Voltage scaling flag A delay is required for the internal regulator to be ready after the voltage scaling has been changed. VOSF indicates that the regulator reached the voltage level defined with VOS bits of the PWR_CR1 register.
	PWR_SR2_REGLPF = 1UL<<9, // Low-power regulator flag This bit is set by hardware when the MCU is in Low-power run mode. When the MCU exits the Low-power run mode, this bit remains at 1 until the regulator is ready in main mode. A polling on this bit must be done before increasing the product frequency. This bit is cleared by hardware when the regulator is ready.
	PWR_SR2_REGLPS = 1UL<<8, // Low-power regulator started This bit provides the information whether the low-power regulator is ready after a power-on reset or a Standby/Shutdown. If the Standby mode is entered while REGLPS bit is still cleared, the wakeup from Standby mode time may be increased.		
};

// PWR->SCR Power status clear register
enum {
	PWR_SCR_CSBF = 1UL<<8, // Clear standby flag Setting this bit clears the SBF flag in the PWR_SR1 register.
	PWR_SCR_CWUF5 = 1UL<<4, // Clear wakeup flag 5 Setting this bit clears the WUF5 flag in the PWR_SR1 register.
	PWR_SCR_CWUF4 = 1UL<<3, // Clear wakeup flag 4 Setting this bit clears the WUF4 flag in the PWR_SR1 register.
	PWR_SCR_CWUF3 = 1UL<<2, // Clear wakeup flag 3 Setting this bit clears the WUF3 flag in the PWR_SR1 register.
	PWR_SCR_CWUF2 = 1UL<<1, // Clear wakeup flag 2 Setting this bit clears the WUF2 flag in the PWR_SR1 register.
	PWR_SCR_CWUF1 = 1UL<<0, // Clear wakeup flag 1 Setting this bit clears the WUF1 flag in the PWR_SR1 register.		
};

// PWR->PUCRA Power Port A pull-up control register
enum {
	PWR_PUCRA_PU15 = 1UL<<15, // Port A pull-up bit 15 When set, this bit activates the pull-up on PA[15] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PD15 bit is also set.
	PWR_PUCRA_PU13 = 1UL<<13, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU12 = 1UL<<12, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU11 = 1UL<<11, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU10 = 1UL<<10, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU9 = 1UL<<9, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU8 = 1UL<<8, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU7 = 1UL<<7, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU6 = 1UL<<6, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU5 = 1UL<<5, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU4 = 1UL<<4, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU3 = 1UL<<3, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU2 = 1UL<<2, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU1 = 1UL<<1, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.
	PWR_PUCRA_PU0 = 1UL<<0, // Port A pull-up bit y (y=0..13) When set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};

// PWR->PDCRA Power Port A pull-down control register
enum {
	PWR_PDCRA_PD14 = 1UL<<14, // Port A pull-down bit 14 When set, this bit activates the pull-down on PA[14] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD12 = 1UL<<12, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD11 = 1UL<<11, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD10 = 1UL<<10, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD9 = 1UL<<9, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD8 = 1UL<<8, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD7 = 1UL<<7, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD6 = 1UL<<6, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD5 = 1UL<<5, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD4 = 1UL<<4, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD3 = 1UL<<3, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD2 = 1UL<<2, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD1 = 1UL<<1, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRA_PD0 = 1UL<<0, // Port A pull-down bit y (y=0..12) When set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register.		
};

// PWR->PUCRB Power Port B pull-up control register
enum {
	PWR_PUCRB_PUX  = ((1UL<<16)-1) << 0, // Merged Port B pull-up bit y (y=0..15) When set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};
static inline void pwr_pucrb_set_pux (uint32_t val) { PWR.PUCRB = (PWR.PUCRB & ~PWR_PUCRB_PUX ) | ((val<<0) & PWR_PUCRB_PUX ); }
static inline uint32_t pwr_pucrb_get_pux (void) { return (PWR.PUCRB & PWR_PUCRB_PUX ) >> 0 ; }

// PWR->PDCRB Power Port B pull-down control register
enum {
	PWR_PDCRB_PD15 = 1UL<<15, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD14 = 1UL<<14, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD13 = 1UL<<13, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD12 = 1UL<<12, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD11 = 1UL<<11, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD10 = 1UL<<10, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD9 = 1UL<<9, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD8 = 1UL<<8, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD7 = 1UL<<7, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD6 = 1UL<<6, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD5 = 1UL<<5, // Port B pull-down bit y (y=5..15) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD3 = 1UL<<3, // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD2 = 1UL<<2, // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD1 = 1UL<<1, // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.
	PWR_PDCRB_PD0 = 1UL<<0, // Port B pull-down bit y (y=0..3) When set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register.		
};

// PWR->PUCRC Power Port C pull-up control register
enum {
	PWR_PUCRC_PUX  = ((1UL<<16)-1) << 0, // Merged Port C pull-up bit y (y=0..15) When set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};
static inline void pwr_pucrc_set_pux (uint32_t val) { PWR.PUCRC = (PWR.PUCRC & ~PWR_PUCRC_PUX ) | ((val<<0) & PWR_PUCRC_PUX ); }
static inline uint32_t pwr_pucrc_get_pux (void) { return (PWR.PUCRC & PWR_PUCRC_PUX ) >> 0 ; }

// PWR->PDCRC Power Port C pull-down control register
enum {
	PWR_PDCRC_PDX  = ((1UL<<16)-1) << 0, // Merged Port C pull-down bit y (y=0..15) When set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register.		
};
static inline void pwr_pdcrc_set_pdx (uint32_t val) { PWR.PDCRC = (PWR.PDCRC & ~PWR_PDCRC_PDX ) | ((val<<0) & PWR_PDCRC_PDX ); }
static inline uint32_t pwr_pdcrc_get_pdx (void) { return (PWR.PDCRC & PWR_PDCRC_PDX ) >> 0 ; }

// PWR->PUCRD Power Port D pull-up control register
enum {
	PWR_PUCRD_PUX  = ((1UL<<16)-1) << 0, // Merged Port D pull-up bit y (y=0..15) When set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};
static inline void pwr_pucrd_set_pux (uint32_t val) { PWR.PUCRD = (PWR.PUCRD & ~PWR_PUCRD_PUX ) | ((val<<0) & PWR_PUCRD_PUX ); }
static inline uint32_t pwr_pucrd_get_pux (void) { return (PWR.PUCRD & PWR_PUCRD_PUX ) >> 0 ; }

// PWR->PDCRD Power Port D pull-down control register
enum {
	PWR_PDCRD_PDX  = ((1UL<<16)-1) << 0, // Merged Port D pull-down bit y (y=0..15) When set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register.		
};
static inline void pwr_pdcrd_set_pdx (uint32_t val) { PWR.PDCRD = (PWR.PDCRD & ~PWR_PDCRD_PDX ) | ((val<<0) & PWR_PDCRD_PDX ); }
static inline uint32_t pwr_pdcrd_get_pdx (void) { return (PWR.PDCRD & PWR_PDCRD_PDX ) >> 0 ; }

// PWR->PUCRE Power Port E pull-up control register
enum {
	PWR_PUCRE_PUX  = ((1UL<<16)-1) << 0, // Merged Port E pull-up bit y (y=0..15) When set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};
static inline void pwr_pucre_set_pux (uint32_t val) { PWR.PUCRE = (PWR.PUCRE & ~PWR_PUCRE_PUX ) | ((val<<0) & PWR_PUCRE_PUX ); }
static inline uint32_t pwr_pucre_get_pux (void) { return (PWR.PUCRE & PWR_PUCRE_PUX ) >> 0 ; }

// PWR->PDCRE Power Port E pull-down control register
enum {
	PWR_PDCRE_PDX  = ((1UL<<16)-1) << 0, // Merged Port E pull-down bit y (y=0..15) When set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register.		
};
static inline void pwr_pdcre_set_pdx (uint32_t val) { PWR.PDCRE = (PWR.PDCRE & ~PWR_PDCRE_PDX ) | ((val<<0) & PWR_PDCRE_PDX ); }
static inline uint32_t pwr_pdcre_get_pdx (void) { return (PWR.PDCRE & PWR_PDCRE_PDX ) >> 0 ; }

// PWR->PUCRF Power Port F pull-up control register
enum {
	PWR_PUCRF_PUX  = ((1UL<<16)-1) << 0, // Merged Port F pull-up bit y (y=0..15) When set, this bit activates the pull-up on PF[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};
static inline void pwr_pucrf_set_pux (uint32_t val) { PWR.PUCRF = (PWR.PUCRF & ~PWR_PUCRF_PUX ) | ((val<<0) & PWR_PUCRF_PUX ); }
static inline uint32_t pwr_pucrf_get_pux (void) { return (PWR.PUCRF & PWR_PUCRF_PUX ) >> 0 ; }

// PWR->PDCRF Power Port F pull-down control register
enum {
	PWR_PDCRF_PDX  = ((1UL<<16)-1) << 0, // Merged Port F pull-down bit y (y=0..15) When set, this bit activates the pull-down on PF[y] when APC bit is set in PWR_CR3 register.		
};
static inline void pwr_pdcrf_set_pdx (uint32_t val) { PWR.PDCRF = (PWR.PDCRF & ~PWR_PDCRF_PDX ) | ((val<<0) & PWR_PDCRF_PDX ); }
static inline uint32_t pwr_pdcrf_get_pdx (void) { return (PWR.PDCRF & PWR_PDCRF_PDX ) >> 0 ; }

// PWR->PUCRG Power Port G pull-up control register
enum {
	PWR_PUCRG_PUX  = ((1UL<<11)-1) << 0, // Merged Port G pull-up bit y (y=0..10) When set, this bit activates the pull-up on PG[y] when APC bit is set in PWR_CR3 register. The pull-up is not activated if the corresponding PDy bit is also set.		
};
static inline void pwr_pucrg_set_pux (uint32_t val) { PWR.PUCRG = (PWR.PUCRG & ~PWR_PUCRG_PUX ) | ((val<<0) & PWR_PUCRG_PUX ); }
static inline uint32_t pwr_pucrg_get_pux (void) { return (PWR.PUCRG & PWR_PUCRG_PUX ) >> 0 ; }

// PWR->PDCRG Power Port G pull-down control register
enum {
	PWR_PDCRG_PDX  = ((1UL<<11)-1) << 0, // Merged Port G pull-down bit y (y=0..10) When set, this bit activates the pull-down on PG[y] when APC bit is set in PWR_CR3 register.		
};
static inline void pwr_pdcrg_set_pdx (uint32_t val) { PWR.PDCRG = (PWR.PDCRG & ~PWR_PDCRG_PDX ) | ((val<<0) & PWR_PDCRG_PDX ); }
static inline uint32_t pwr_pdcrg_get_pdx (void) { return (PWR.PDCRG & PWR_PDCRG_PDX ) >> 0 ; }

// PWR->CR5 Power control register
enum {
	PWR_CR5_R1MODE = 1UL<<8, // Main regular range 1 mode This bit is only valid for the main regulator in range 1 and has no effect on range 2. It is recommended to reset this bit when the system frequency is greater than 150 MHz. Refer to		
};

/* Reset and clock control
There is only one peripheral of type RCC. */
struct RCC_Type {
	__IO uint32_t CR; // @0 Clock control register
	__IO uint32_t ICSCR; // @4 Internal clock sources calibration register
	__IO uint32_t CFGR; // @8 Clock configuration register
	__IO uint32_t PLLCFGR; // @12 PLL configuration register
	 uint8_t RESERVED0[8]; // @16 
	__IO uint32_t CIER; // @24 Clock interrupt enable register
	__IO uint32_t CIFR; // @28 Clock interrupt flag register
	__IO uint32_t CICR; // @32 Clock interrupt clear register
	 uint8_t RESERVED1[4]; // @36 
	__IO uint32_t AHB1RSTR; // @40 AHB1 peripheral reset register
	__IO uint32_t AHB2RSTR; // @44 AHB2 peripheral reset register
	__IO uint32_t AHB3RSTR; // @48 AHB3 peripheral reset register
	 uint8_t RESERVED2[4]; // @52 
	__IO uint32_t APB1RSTR1; // @56 APB1 peripheral reset register 1
	__IO uint32_t APB1RSTR2; // @60 APB1 peripheral reset register 2
	__IO uint32_t APB2RSTR; // @64 APB2 peripheral reset register
	 uint8_t RESERVED3[4]; // @68 
	__IO uint32_t AHB1ENR; // @72 AHB1 peripheral clock enable register
	__IO uint32_t AHB2ENR; // @76 AHB2 peripheral clock enable register
	__IO uint32_t AHB3ENR; // @80 AHB3 peripheral clock enable register
	 uint8_t RESERVED4[4]; // @84 
	__IO uint32_t APB1ENR1; // @88 APB1 peripheral clock enable register 1
	__IO uint32_t APB1ENR2; // @92 APB1 peripheral clock enable register 2
	__IO uint32_t APB2ENR; // @96 APB2 peripheral clock enable register
	 uint8_t RESERVED5[4]; // @100 
	__IO uint32_t AHB1SMENR; // @104 AHB1 peripheral clocks enable in Sleep and Stop modes register
	__IO uint32_t AHB2SMENR; // @108 AHB2 peripheral clocks enable in Sleep and Stop modes register
	__IO uint32_t AHB3SMENR; // @112 AHB3 peripheral clocks enable in Sleep and Stop modes register
	 uint8_t RESERVED6[4]; // @116 
	__IO uint32_t APB1SMENR1; // @120 APB1 peripheral clocks enable in Sleep and Stop modes register 1
	__IO uint32_t APB1SMENR2; // @124 APB1 peripheral clocks enable in Sleep and Stop modes register 2
	__IO uint32_t APB2SMENR; // @128 APB2 peripheral clocks enable in Sleep and Stop modes register
	 uint8_t RESERVED7[4]; // @132 
	__IO uint32_t CCIPR; // @136 Peripherals independent clock configuration register
	 uint8_t RESERVED8[4]; // @140 
	__IO uint32_t BDCR; // @144 RTC domain control register
	__IO uint32_t CSR; // @148 Control/status register
	__IO uint32_t CRRCR; // @152 Clock recovery RC register
	__IO uint32_t CCIPR2; // @156 Peripherals independent clock configuration register
};
extern struct RCC_Type	RCC;	// @0x40021000 

// RCC->CR Clock control register
enum {
	RCC_CR_PLLRDY = 1UL<<25, // Main PLL clock ready flag Set by hardware to indicate that the main PLL is locked.
	RCC_CR_PLLON = 1UL<<24, // Main PLL enable Set and cleared by software to enable the main PLL. Cleared by hardware when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the PLL clock is used as the system clock.
	RCC_CR_CSSON = 1UL<<19, // Clock security system enable Set by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset.
	RCC_CR_HSEBYP = 1UL<<18, // HSE crystal oscillator bypass Set and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device. The HSEBYP bit can be written only if the HSE oscillator is disabled.
	RCC_CR_HSERDY = 1UL<<17, // HSE clock ready flag Set by hardware to indicate that the HSE oscillator is stable. Note: Once the HSEON bit is cleared, HSERDY goes low after 6 HSE clock cycles.
	RCC_CR_HSEON = 1UL<<16, // HSE clock enable Set and cleared by software. Cleared by hardware to stop the HSE oscillator when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock.
	RCC_CR_HSIRDY = 1UL<<10, // HSI16 clock ready flag Set by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION. Note: Once the HSION bit is cleared, HSIRDY goes low after 6 HSI16 clock cycles.
	RCC_CR_HSIKERON = 1UL<<9, // HSI16 always enable for peripheral kernels. Set and cleared by software to force HSI16 ON even in Stop modes. The HSI16 can only feed USARTs and I<sup>2</sup>Cs peripherals configured with HSI16 as kernel clock. Keeping the HSI16 ON in Stop mode allows to avoid slowing down the communication speed because of the HSI16 startup time. This bit has no effect on HSION value.
	RCC_CR_HSION = 1UL<<8, // HSI16 clock enable Set and cleared by software. Cleared by hardware to stop the HSI16 oscillator when entering Stop, Standby or Shutdown mode. Set by hardware to force the HSI16 oscillator ON when STOPWUCK=1 or HSIASFS = 1 when leaving Stop modes, or in case of failure of the HSE crystal oscillator. This bit is set by hardware if the HSI16 is used directly or indirectly as system clock.		
};

// RCC->ICSCR Internal clock sources calibration register
enum {
	RCC_ICSCR_HSITRIM = ((1UL<<7)-1) << 24, // HSI16 clock trimming These bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI16. The default value is 16, which, when added to the HSICAL value, should trim the HSI16 to 16 MHz � 1 %.
	RCC_ICSCR_HSICAL = ((1UL<<8)-1) << 16, // HSI16 clock calibration These bits are initialized at startup with the factory-programmed HSI16 calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value.		
};
static inline void rcc_icscr_set_hsitrim(uint32_t val) { RCC.ICSCR = (RCC.ICSCR & ~RCC_ICSCR_HSITRIM) | ((val<<24) & RCC_ICSCR_HSITRIM); }
static inline void rcc_icscr_set_hsical(uint32_t val) { RCC.ICSCR = (RCC.ICSCR & ~RCC_ICSCR_HSICAL) | ((val<<16) & RCC_ICSCR_HSICAL); }
static inline uint32_t rcc_icscr_get_hsitrim(void) { return (RCC.ICSCR & RCC_ICSCR_HSITRIM) >> 24 ; }
static inline uint32_t rcc_icscr_get_hsical(void) { return (RCC.ICSCR & RCC_ICSCR_HSICAL) >> 16 ; }

// RCC->CFGR Clock configuration register
enum {
	RCC_CFGR_MCOPRE = ((1UL<<3)-1) << 28, // Microcontroller clock output prescaler These bits are set and cleared by software. It is highly recommended to change this prescaler before MCO output is enabled. Others: not allowed
	RCC_CFGR_MCOSEL = ((1UL<<4)-1) << 24, // Microcontroller clock output Set and cleared by software. Others: Reserved Note: This clock output may have some truncated cycles at startup or during MCO clock source switching.
	RCC_CFGR_PPRE2 = ((1UL<<3)-1) << 11, // APB2 prescaler Set and cleared by software to control the division factor of the APB2 clock (PCLK2). 0xx: HCLK not divided
	RCC_CFGR_PPRE1 = ((1UL<<3)-1) << 8, // APB1 prescaler Set and cleared by software to control the division factor of the APB1 clock (PCLK1). 0xx: HCLK not divided
	RCC_CFGR_HPRE = ((1UL<<4)-1) << 4, // AHB prescaler Set and cleared by software to control the division factor of the AHB clock. Note: Depending on the device voltage range, the software has to set correctly these bits to ensure that the system frequency does not exceed the maximum allowed frequency (for more details please refer to Section 6.1.5: Dynamic voltage scaling management). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value has been taken into account. 0xxx: SYSCLK not divided
	RCC_CFGR_SWS = ((1UL<<2)-1) << 2, // System clock switch status Set and cleared by hardware to indicate which clock source is used as system clock.
	RCC_CFGR_SW = ((1UL<<2)-1) << 0, // System clock switch Set and cleared by software to select system clock source (SYSCLK). Configured by hardware to force HSI16 oscillator selection when exiting stop and standby modes or in case of failure of the HSE oscillator.		
};
static inline void rcc_cfgr_set_mcopre(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_MCOPRE) | ((val<<28) & RCC_CFGR_MCOPRE); }
static inline void rcc_cfgr_set_mcosel(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_MCOSEL) | ((val<<24) & RCC_CFGR_MCOSEL); }
static inline void rcc_cfgr_set_ppre2(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_PPRE2) | ((val<<11) & RCC_CFGR_PPRE2); }
static inline void rcc_cfgr_set_ppre1(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_PPRE1) | ((val<<8) & RCC_CFGR_PPRE1); }
static inline void rcc_cfgr_set_hpre(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_HPRE) | ((val<<4) & RCC_CFGR_HPRE); }
static inline void rcc_cfgr_set_sws(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_SWS) | ((val<<2) & RCC_CFGR_SWS); }
static inline void rcc_cfgr_set_sw(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_SW) | ((val<<0) & RCC_CFGR_SW); }
static inline uint32_t rcc_cfgr_get_mcopre(void) { return (RCC.CFGR & RCC_CFGR_MCOPRE) >> 28 ; }
static inline uint32_t rcc_cfgr_get_mcosel(void) { return (RCC.CFGR & RCC_CFGR_MCOSEL) >> 24 ; }
static inline uint32_t rcc_cfgr_get_ppre2(void) { return (RCC.CFGR & RCC_CFGR_PPRE2) >> 11 ; }
static inline uint32_t rcc_cfgr_get_ppre1(void) { return (RCC.CFGR & RCC_CFGR_PPRE1) >> 8 ; }
static inline uint32_t rcc_cfgr_get_hpre(void) { return (RCC.CFGR & RCC_CFGR_HPRE) >> 4 ; }
static inline uint32_t rcc_cfgr_get_sws(void) { return (RCC.CFGR & RCC_CFGR_SWS) >> 2 ; }
static inline uint32_t rcc_cfgr_get_sw(void) { return (RCC.CFGR & RCC_CFGR_SW) >> 0 ; }

// RCC->PLLCFGR PLL configuration register
enum {
	RCC_PLLCFGR_PLLPDIV = ((1UL<<5)-1) << 27, // Main PLLP division factor Set and cleared by software to control the PLL “P” frequency. PLL “P” output clock frequency = VCO frequency / PLLPDIV. ....
	RCC_PLLCFGR_PLLR = ((1UL<<2)-1) << 25, // Main PLL division factor for PLL “R” clock (system clock) Set and cleared by software to control the frequency of the main PLL output clock PLLCLK. This output can be selected as system clock. These bits can be written only if PLL is disabled. PLL “R” output clock frequency = VCO frequency / PLLR with PLLR = 2, 4, 6, or 8 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
	RCC_PLLCFGR_PLLREN = 1UL<<24, // PLL “R” clock output enable Set and reset by software to enable the PLL “R” clock output of the PLL (used as system clock). This bit cannot be written when PLL “R” clock output of the PLL is used as System Clock. In order to save power, when the PLL “R” clock output of the PLL is not used, the value of PLLREN should be 0.
	RCC_PLLCFGR_PLLQ = ((1UL<<2)-1) << 21, // Main PLL division factor for PLL “Q” clock. Set and cleared by software to control the frequency of the main PLL output clock PLL “Q” clock. This output can be selected for USB, RNG, SAI (48 MHz clock). These bits can be written only if PLL is disabled. PLL “Q” output clock frequency = VCO frequency / PLLQ with PLLQ = 2, 4, 6, or 8 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
	RCC_PLLCFGR_PLLQEN = 1UL<<20, // Main PLL “Q” clock output enable Set and reset by software to enable the PLL “Q” clock output of the PLL. In order to save power, when the PLL “Q” clock output of the PLL is not used, the value of PLLQEN should be 0.
	RCC_PLLCFGR_PLLP = 1UL<<17, // Main PLL division factor for PLL “P” clock. Set and cleared by software to control the frequency of the main PLL output clock PLL “P” clock. These bits can be written only if PLL is disabled. When the PLLPDIV[4:0] is set to “00000”PLL “P” output clock frequency = VCO frequency / PLLP with PLLP =7, or 17 Note: The software has to set these bits correctly not to exceed 170 MHz on this domain.
	RCC_PLLCFGR_PLLPEN = 1UL<<16, // Main PLL PLL “P” clock output enable Set and reset by software to enable the PLL “P” clock output of the PLL. In order to save power, when the PLL “P” clock output of the PLL is not used, the value of PLLPEN should be 0.
	RCC_PLLCFGR_PLLN = ((1UL<<7)-1) << 8, // Main PLL multiplication factor for VCO Set and cleared by software to control the multiplication factor of the VCO. These bits can be written only when the PLL is disabled. VCO output frequency = VCO input frequency x PLLN with 8 =< PLLN =< 127 ... ... Note: The software has to set correctly these bits to assure that the VCO output frequency is within the range defined in the device datasheet.
	RCC_PLLCFGR_PLLM = ((1UL<<4)-1) << 4, // Division factor for the main PLL input clock Set and cleared by software to divide the PLL input clock before the VCO. These bits can be written only when all PLLs are disabled. VCO input frequency = PLL input clock frequency / PLLM with 1 <= PLLM <= 16 ... Note: The software has to set these bits correctly to ensure that the VCO input frequency is within the range defined in the device datasheet.
	RCC_PLLCFGR_PLLSRC = ((1UL<<2)-1) << 0, // Main PLL entry clock source Set and cleared by software to select PLL clock source. These bits can be written only when PLL is disabled. In order to save power, when no PLL is used, the value of PLLSRC should be 00.		
};
static inline void rcc_pllcfgr_set_pllpdiv(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLPDIV) | ((val<<27) & RCC_PLLCFGR_PLLPDIV); }
static inline void rcc_pllcfgr_set_pllr(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLR) | ((val<<25) & RCC_PLLCFGR_PLLR); }
static inline void rcc_pllcfgr_set_pllq(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLQ) | ((val<<21) & RCC_PLLCFGR_PLLQ); }
static inline void rcc_pllcfgr_set_plln(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLN) | ((val<<8) & RCC_PLLCFGR_PLLN); }
static inline void rcc_pllcfgr_set_pllm(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLM) | ((val<<4) & RCC_PLLCFGR_PLLM); }
static inline void rcc_pllcfgr_set_pllsrc(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLSRC) | ((val<<0) & RCC_PLLCFGR_PLLSRC); }
static inline uint32_t rcc_pllcfgr_get_pllpdiv(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLPDIV) >> 27 ; }
static inline uint32_t rcc_pllcfgr_get_pllr(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLR) >> 25 ; }
static inline uint32_t rcc_pllcfgr_get_pllq(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLQ) >> 21 ; }
static inline uint32_t rcc_pllcfgr_get_plln(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLN) >> 8 ; }
static inline uint32_t rcc_pllcfgr_get_pllm(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLM) >> 4 ; }
static inline uint32_t rcc_pllcfgr_get_pllsrc(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 0 ; }

// RCC->CIER Clock interrupt enable register
enum {
	RCC_CIER_HSI48RDYIE = 1UL<<10, // HSI48 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the internal HSI48 oscillator.
	RCC_CIER_LSECSSIE = 1UL<<9, // LSE clock security system interrupt enable Set and cleared by software to enable/disable interrupt caused by the clock security system on LSE.
	RCC_CIER_PLLRDYIE = 1UL<<5, // PLL ready interrupt enable Set and cleared by software to enable/disable interrupt caused by PLL lock.
	RCC_CIER_HSERDYIE = 1UL<<4, // HSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization.
	RCC_CIER_HSIRDYIE = 1UL<<3, // HSI16 ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.
	RCC_CIER_LSERDYIE = 1UL<<1, // LSE ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.
	RCC_CIER_LSIRDYIE = 1UL<<0, // LSI ready interrupt enable Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization.		
};

// RCC->CIFR Clock interrupt flag register
enum {
	RCC_CIFR_HSI48RDYF = 1UL<<10, // HSI48 ready interrupt flag Set by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set in a response to setting the HSI48ON (refer to Clock recovery RC register (RCC_CRRCR)). Cleared by software setting the HSI48RDYC bit.
	RCC_CIFR_LSECSSF = 1UL<<9, // LSE Clock security system interrupt flag Set by hardware when a failure is detected in the LSE oscillator. Cleared by software setting the LSECSSC bit.
	RCC_CIFR_CSSF = 1UL<<8, // Clock security system interrupt flag Set by hardware when a failure is detected in the HSE oscillator. Cleared by software setting the CSSC bit.
	RCC_CIFR_PLLRDYF = 1UL<<5, // PLL ready interrupt flag Set by hardware when the PLL locks and PLLRDYDIE is set. Cleared by software setting the PLLRDYC bit.
	RCC_CIFR_HSERDYF = 1UL<<4, // HSE ready interrupt flag Set by hardware when the HSE clock becomes stable and HSERDYDIE is set. Cleared by software setting the HSERDYC bit.
	RCC_CIFR_HSIRDYF = 1UL<<3, // HSI16 ready interrupt flag Set by hardware when the HSI16 clock becomes stable and HSIRDYDIE is set in a response to setting the HSION (refer to Clock control register (RCC_CR)). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated. Cleared by software setting the HSIRDYC bit.
	RCC_CIFR_LSERDYF = 1UL<<1, // LSE ready interrupt flag Set by hardware when the LSE clock becomes stable and LSERDYDIE is set. Cleared by software setting the LSERDYC bit.
	RCC_CIFR_LSIRDYF = 1UL<<0, // LSI ready interrupt flag Set by hardware when the LSI clock becomes stable and LSIRDYDIE is set. Cleared by software setting the LSIRDYC bit.		
};

// RCC->CICR Clock interrupt clear register
enum {
	RCC_CICR_HSI48RDYC = 1UL<<10, // HSI48 oscillator ready interrupt clear This bit is set by software to clear the HSI48RDYF flag.
	RCC_CICR_LSECSSC = 1UL<<9, // LSE Clock security system interrupt clear This bit is set by software to clear the LSECSSF flag.
	RCC_CICR_CSSC = 1UL<<8, // Clock security system interrupt clear This bit is set by software to clear the CSSF flag.
	RCC_CICR_PLLRDYC = 1UL<<5, // PLL ready interrupt clear This bit is set by software to clear the PLLRDYF flag.
	RCC_CICR_HSERDYC = 1UL<<4, // HSE ready interrupt clear This bit is set by software to clear the HSERDYF flag.
	RCC_CICR_HSIRDYC = 1UL<<3, // HSI16 ready interrupt clear This bit is set software to clear the HSIRDYF flag.
	RCC_CICR_LSERDYC = 1UL<<1, // LSE ready interrupt clear This bit is set by software to clear the LSERDYF flag.
	RCC_CICR_LSIRDYC = 1UL<<0, // LSI ready interrupt clear This bit is set by software to clear the LSIRDYF flag.		
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_CRCRST = 1UL<<12, // CRC reset Set and cleared by software.
	RCC_AHB1RSTR_FLASHRST = 1UL<<8, // Flash memory interface reset Set and cleared by software. This bit can be activated only when the Flash memory is in power down mode.
	RCC_AHB1RSTR_FMACRST = 1UL<<4, // Set and cleared by software
	RCC_AHB1RSTR_CORDICRST = 1UL<<3, // Set and cleared by software
	RCC_AHB1RSTR_DMAMUX1RST = 1UL<<2, // Set and cleared by software.
	RCC_AHB1RSTR_DMA2RST = 1UL<<1, // DMA2 reset Set and cleared by software.
	RCC_AHB1RSTR_DMA1RST = 1UL<<0, // DMA1 reset Set and cleared by software.		
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_RNGRST = 1UL<<26, // RNG reset Set and cleared by software.
	RCC_AHB2RSTR_AESRST = 1UL<<24, // AESRST reset Set and cleared by software.
	RCC_AHB2RSTR_DAC4RST = 1UL<<19, // DAC4 reset Set and cleared by software.
	RCC_AHB2RSTR_DAC3RST = 1UL<<18, // DAC3 reset Set and cleared by software.
	RCC_AHB2RSTR_DAC2RST = 1UL<<17, // DAC2 reset Set and cleared by software.
	RCC_AHB2RSTR_DAC1RST = 1UL<<16, // DAC1 reset Set and cleared by software.
	RCC_AHB2RSTR_ADC345RST = 1UL<<14, // ADC345 reset Set and cleared by software.
	RCC_AHB2RSTR_ADC12RST = 1UL<<13, // ADC12 reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOGRST = 1UL<<6, // IO port G reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOFRST = 1UL<<5, // IO port F reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOERST = 1UL<<4, // IO port E reset Set and cleared by software.
	RCC_AHB2RSTR_GPIODRST = 1UL<<3, // IO port D reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOCRST = 1UL<<2, // IO port C reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOBRST = 1UL<<1, // IO port B reset Set and cleared by software.
	RCC_AHB2RSTR_GPIOARST = 1UL<<0, // IO port A reset Set and cleared by software.		
};

// RCC->AHB3RSTR AHB3 peripheral reset register
enum {
	RCC_AHB3RSTR_QSPIRST = 1UL<<8, // QUADSPI reset Set and cleared by software.
	RCC_AHB3RSTR_FMCRST = 1UL<<0, // Flexible static memory controller reset Set and cleared by software.		
};

// RCC->APB1RSTR1 APB1 peripheral reset register 1
enum {
	RCC_APB1RSTR1_LPTIM1RST = 1UL<<31, // Low Power Timer 1 reset Set and cleared by software.
	RCC_APB1RSTR1_I2C3RST = 1UL<<30, // I2C3 reset Set and cleared by software.
	RCC_APB1RSTR1_PWRRST = 1UL<<28, // Power interface reset Set and cleared by software.
	RCC_APB1RSTR1_FDCANRST = 1UL<<25, // FDCAN reset Set and reset by software.
	RCC_APB1RSTR1_USBRST = 1UL<<23, // USB device reset Set and reset by software.
	RCC_APB1RSTR1_I2C2RST = 1UL<<22, // I2C2 reset Set and cleared by software.
	RCC_APB1RSTR1_I2C1RST = 1UL<<21, // I2C1 reset Set and cleared by software.
	RCC_APB1RSTR1_UART5RST = 1UL<<20, // UART5 reset Set and cleared by software.
	RCC_APB1RSTR1_UART4RST = 1UL<<19, // UART4 reset Set and cleared by software.
	RCC_APB1RSTR1_USART3RST = 1UL<<18, // USART3 reset Set and cleared by software.
	RCC_APB1RSTR1_USART2RST = 1UL<<17, // USART2 reset Set and cleared by software.
	RCC_APB1RSTR1_SPI3RST = 1UL<<15, // SPI3 reset Set and cleared by software.
	RCC_APB1RSTR1_SPI2RST = 1UL<<14, // SPI2 reset Set and cleared by software.
	RCC_APB1RSTR1_CRSRST = 1UL<<8, // CRS reset Set and cleared by software.
	RCC_APB1RSTR1_TIM7RST = 1UL<<5, // TIM7 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM6RST = 1UL<<4, // TIM6 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM5RST = 1UL<<3, // TIM5 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM4RST = 1UL<<2, // TIM3 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM3RST = 1UL<<1, // TIM3 timer reset Set and cleared by software.
	RCC_APB1RSTR1_TIM2RST = 1UL<<0, // TIM2 timer reset Set and cleared by software.		
};

// RCC->APB1RSTR2 APB1 peripheral reset register 2
enum {
	RCC_APB1RSTR2_UCPD1RST = 1UL<<8, // UCPD1 reset Set and cleared by software.
	RCC_APB1RSTR2_I2C4RST = 1UL<<1, // I2C4 reset Set and cleared by software
	RCC_APB1RSTR2_LPUART1RST = 1UL<<0, // Low-power UART 1 reset Set and cleared by software.		
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_HRTIM1RST = 1UL<<26, // HRTIM1 reset Set and cleared by software.
	RCC_APB2RSTR_SAI1RST = 1UL<<21, // Serial audio interface 1 (SAI1) reset Set and cleared by software.
	RCC_APB2RSTR_TIM20RST = 1UL<<20, // TIM20 reset Set and cleared by software.
	RCC_APB2RSTR_TIM17RST = 1UL<<18, // TIM17 timer reset Set and cleared by software.
	RCC_APB2RSTR_TIM16RST = 1UL<<17, // TIM16 timer reset Set and cleared by software.
	RCC_APB2RSTR_TIM15RST = 1UL<<16, // TIM15 timer reset Set and cleared by software.
	RCC_APB2RSTR_SPI4RST = 1UL<<15, // SPI4 reset Set and cleared by software.
	RCC_APB2RSTR_USART1RST = 1UL<<14, // USART1 reset Set and cleared by software.
	RCC_APB2RSTR_TIM8RST = 1UL<<13, // TIM8 timer reset Set and cleared by software.
	RCC_APB2RSTR_SPI1RST = 1UL<<12, // SPI1 reset Set and cleared by software.
	RCC_APB2RSTR_TIM1RST = 1UL<<11, // TIM1 timer reset Set and cleared by software.
	RCC_APB2RSTR_SYSCFGRST = 1UL<<0, // SYSCFG + COMP + OPAMP + VREFBUF reset		
};

// RCC->AHB1ENR AHB1 peripheral clock enable register
enum {
	RCC_AHB1ENR_CRCEN = 1UL<<12, // CRC clock enable Set and cleared by software.
	RCC_AHB1ENR_FLASHEN = 1UL<<8, // Flash memory interface clock enable Set and cleared by software. This bit can be disabled only when the Flash is in power down mode.
	RCC_AHB1ENR_FMACEN = 1UL<<4, // FMAC enable Set and reset by software.
	RCC_AHB1ENR_CORDICEN = 1UL<<3, // CORDIC clock enable Set and reset by software.
	RCC_AHB1ENR_DMAMUX1EN = 1UL<<2, // DMAMUX1 clock enable Set and reset by software.
	RCC_AHB1ENR_DMA2EN = 1UL<<1, // DMA2 clock enable Set and cleared by software.
	RCC_AHB1ENR_DMA1EN = 1UL<<0, // DMA1 clock enable Set and cleared by software.		
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_RNGEN = 1UL<<26, // RNG enable Set and cleared by software.
	RCC_AHB2ENR_AESEN = 1UL<<24, // AES clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC4EN = 1UL<<19, // DAC4 clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC3EN = 1UL<<18, // DAC3 clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC2EN = 1UL<<17, // DAC2 clock enable Set and cleared by software.
	RCC_AHB2ENR_DAC1EN = 1UL<<16, // DAC1 clock enable Set and cleared by software.
	RCC_AHB2ENR_ADC345EN = 1UL<<14, // ADC345 clock enable Set and cleared by software
	RCC_AHB2ENR_ADC12EN = 1UL<<13, // ADC12 clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOGEN = 1UL<<6, // IO port G clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOFEN = 1UL<<5, // IO port F clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOEEN = 1UL<<4, // IO port E clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIODEN = 1UL<<3, // IO port D clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOCEN = 1UL<<2, // IO port C clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOBEN = 1UL<<1, // IO port B clock enable Set and cleared by software.
	RCC_AHB2ENR_GPIOAEN = 1UL<<0, // IO port A clock enable Set and cleared by software.		
};

// RCC->AHB3ENR AHB3 peripheral clock enable register
enum {
	RCC_AHB3ENR_QSPIEN = 1UL<<8, // QUADSPI memory interface clock enable Set and cleared by software.
	RCC_AHB3ENR_FMCEN = 1UL<<0, // Flexible static memory controller clock enable Set and cleared by software.		
};

// RCC->APB1ENR1 APB1 peripheral clock enable register 1
enum {
	RCC_APB1ENR1_LPTIM1EN = 1UL<<31, // Low power timer 1 clock enable Set and cleared by software.
	RCC_APB1ENR1_I2C3EN = 1UL<<30, // I2C3 clock enable Set and cleared by software.
	RCC_APB1ENR1_PWREN = 1UL<<28, // Power interface clock enable Set and cleared by software.
	RCC_APB1ENR1_FDCANEN = 1UL<<25, // FDCAN clock enable Set and cleared by software.
	RCC_APB1ENR1_USBEN = 1UL<<23, // USB device clock enable Set and cleared by software.
	RCC_APB1ENR1_I2C2EN = 1UL<<22, // I2C2 clock enable Set and cleared by software.
	RCC_APB1ENR1_I2C1EN = 1UL<<21, // I2C1 clock enable Set and cleared by software.
	RCC_APB1ENR1_UART5EN = 1UL<<20, // UART5 clock enable Set and cleared by software.
	RCC_APB1ENR1_UART4EN = 1UL<<19, // UART4 clock enable Set and cleared by software.
	RCC_APB1ENR1_USART3EN = 1UL<<18, // USART3 clock enable Set and cleared by software.
	RCC_APB1ENR1_USART2EN = 1UL<<17, // USART2 clock enable Set and cleared by software.
	RCC_APB1ENR1_SPI3EN = 1UL<<15, // SPI3 clock enable Set and cleared by software.
	RCC_APB1ENR1_SPI2EN = 1UL<<14, // SPI2 clock enable Set and cleared by software.
	RCC_APB1ENR1_WWDGEN = 1UL<<11, // Window watchdog clock enable Set by software to enable the window watchdog clock. Reset by hardware system reset. This bit can also be set by hardware if the WWDG_SW option bit is reset.
	RCC_APB1ENR1_RTCAPBEN = 1UL<<10, // RTC APB clock enable Set and cleared by software
	RCC_APB1ENR1_CRSEN = 1UL<<8, // CRS Recovery System clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM7EN = 1UL<<5, // TIM7 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM6EN = 1UL<<4, // TIM6 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM5EN = 1UL<<3, // TIM5 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM4EN = 1UL<<2, // TIM4 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM3EN = 1UL<<1, // TIM3 timer clock enable Set and cleared by software.
	RCC_APB1ENR1_TIM2EN = 1UL<<0, // TIM2 timer clock enable Set and cleared by software.		
};

// RCC->APB1ENR2 APB1 peripheral clock enable register 2
enum {
	RCC_APB1ENR2_UCPD1EN = 1UL<<8, // UCPD1 clock enable Set and cleared by software.
	RCC_APB1ENR2_I2C4EN = 1UL<<1, // I2C4 clock enable Set and cleared by software
	RCC_APB1ENR2_LPUART1EN = 1UL<<0, // Low power UART 1 clock enable Set and cleared by software.		
};

// RCC->APB2ENR APB2 peripheral clock enable register
enum {
	RCC_APB2ENR_HRTIM1EN = 1UL<<26, // HRTIM1 clock enable Set and cleared by software.
	RCC_APB2ENR_SAI1EN = 1UL<<21, // SAI1 clock enable Set and cleared by software.
	RCC_APB2ENR_TIM20EN = 1UL<<20, // TIM20 timer clock enable Set and cleared by software.
	RCC_APB2ENR_TIM17EN = 1UL<<18, // TIM17 timer clock enable Set and cleared by software.
	RCC_APB2ENR_TIM16EN = 1UL<<17, // TIM16 timer clock enable Set and cleared by software.
	RCC_APB2ENR_TIM15EN = 1UL<<16, // TIM15 timer clock enable Set and cleared by software.
	RCC_APB2ENR_SPI4EN = 1UL<<15, // SPI4 clock enable Set and cleared by software.
	RCC_APB2ENR_USART1EN = 1UL<<14, // USART1clock enable Set and cleared by software.
	RCC_APB2ENR_TIM8EN = 1UL<<13, // TIM8 timer clock enable Set and cleared by software.
	RCC_APB2ENR_SPI1EN = 1UL<<12, // SPI1 clock enable Set and cleared by software.
	RCC_APB2ENR_TIM1EN = 1UL<<11, // TIM1 timer clock enable Set and cleared by software.
	RCC_APB2ENR_SYSCFGEN = 1UL<<0, // SYSCFG + COMP + VREFBUF + OPAMP clock enable Set and cleared by software.		
};

// RCC->AHB1SMENR AHB1 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB1SMENR_CRCSMEN = 1UL<<12, // CRC clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB1SMENR_SRAM1SMEN = 1UL<<9, // SRAM1 interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB1SMENR_FLASHSMEN = 1UL<<8, // Flash memory interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB1SMENR_FMACSMEN = 1UL<<4, // FMACSM clock enable. Set and cleared by software.
	RCC_AHB1SMENR_CORDICSMEN = 1UL<<3, // CORDICSM clock enable. Set and cleared by software.
	RCC_AHB1SMENR_DMAMUX1SMEN = 1UL<<2, // DMAMUX1 clock enable during Sleep and Stop modes. Set and cleared by software.
	RCC_AHB1SMENR_DMA2SMEN = 1UL<<1, // DMA2 clocks enable during Sleep and Stop modes Set and cleared by software during Sleep mode.
	RCC_AHB1SMENR_DMA1SMEN = 1UL<<0, // DMA1 clocks enable during Sleep and Stop modes Set and cleared by software.		
};

// RCC->AHB2SMENR AHB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB2SMENR_RNGEN = 1UL<<26, // RNG enable Set and cleared by software.
	RCC_AHB2SMENR_AESSMEN = 1UL<<24, // AESM clocks enable Set and cleared by software.
	RCC_AHB2SMENR_DAC4SMEN = 1UL<<19, // DAC4 clock enable Set and cleared by software.
	RCC_AHB2SMENR_DAC3SMEN = 1UL<<18, // DAC3 clock enable Set and cleared by software.
	RCC_AHB2SMENR_DAC2SMEN = 1UL<<17, // DAC2 clock enable Set and cleared by software.
	RCC_AHB2SMENR_DAC1SMEN = 1UL<<16, // DAC1 clock enable Set and cleared by software.
	RCC_AHB2SMENR_ADC345SMEN = 1UL<<14, // ADC345 clock enable Set and cleared by software.
	RCC_AHB2SMENR_ADC12SMEN = 1UL<<13, // ADC12 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_SRAM2SMEN = 1UL<<10, // SRAM2 interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_CCMSRAMSMEN = 1UL<<9, // CCM SRAM interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOGSMEN = 1UL<<6, // IO port G clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOFSMEN = 1UL<<5, // IO port F clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOESMEN = 1UL<<4, // IO port E clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIODSMEN = 1UL<<3, // IO port D clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOCSMEN = 1UL<<2, // IO port C clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOBSMEN = 1UL<<1, // IO port B clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB2SMENR_GPIOASMEN = 1UL<<0, // IO port A clocks enable during Sleep and Stop modes Set and cleared by software.		
};

// RCC->AHB3SMENR AHB3 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB3SMENR_QSPISMEN = 1UL<<8, // QUADSPI memory interface clock enable during Sleep and Stop modes Set and cleared by software.
	RCC_AHB3SMENR_FMCSMEN = 1UL<<0, // Flexible static memory controller clocks enable during Sleep and Stop modes Set and cleared by software.		
};

// RCC->APB1SMENR1 APB1 peripheral clocks enable in Sleep and Stop modes register 1
enum {
	RCC_APB1SMENR1_LPTIM1SMEN = 1UL<<31, // Low power timer 1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_I2C3SMEN = 1UL<<30, // I2C3 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_PWRSMEN = 1UL<<28, // Power interface clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_FDCANSMEN = 1UL<<25, // FDCAN clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_USBSMEN = 1UL<<23, // USB device clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_I2C2SMEN = 1UL<<22, // I2C2 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_I2C1SMEN = 1UL<<21, // I2C1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_UART5SMEN = 1UL<<20, // UART5 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_UART4SMEN = 1UL<<19, // UART4 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_USART3SMEN = 1UL<<18, // USART3 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_USART2SMEN = 1UL<<17, // USART2 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_SPI3SMEN = 1UL<<15, // SPI3 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_SPI2SMEN = 1UL<<14, // SPI2 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_WWDGSMEN = 1UL<<11, // Window watchdog clocks enable during Sleep and Stop modes Set and cleared by software. This bit is forced to ‘1’ by hardware when the hardware WWDG option is activated.
	RCC_APB1SMENR1_RTCAPBSMEN = 1UL<<10, // RTC APB clock enable during Sleep and Stop modes Set and cleared by software
	RCC_APB1SMENR1_CRSSMEN = 1UL<<8, // CRS timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM7SMEN = 1UL<<5, // TIM7 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM6SMEN = 1UL<<4, // TIM6 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM5SMEN = 1UL<<3, // TIM5 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM4SMEN = 1UL<<2, // TIM4 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM3SMEN = 1UL<<1, // TIM3 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR1_TIM2SMEN = 1UL<<0, // TIM2 timer clocks enable during Sleep and Stop modes Set and cleared by software.		
};

// RCC->APB1SMENR2 APB1 peripheral clocks enable in Sleep and Stop modes register 2
enum {
	RCC_APB1SMENR2_UCPD1SMEN = 1UL<<8, // UCPD1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB1SMENR2_I2C4SMEN = 1UL<<1, // I2C4 clocks enable during Sleep and Stop modes Set and cleared by software
	RCC_APB1SMENR2_LPUART1SMEN = 1UL<<0, // Low power UART 1 clocks enable during Sleep and Stop modes Set and cleared by software.		
};

// RCC->APB2SMENR APB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_APB2SMENR_HRTIM1SMEN = 1UL<<26, // HRTIM1 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SAI1SMEN = 1UL<<21, // SAI1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM20SMEN = 1UL<<20, // TIM20 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM17SMEN = 1UL<<18, // TIM17 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM16SMEN = 1UL<<17, // TIM16 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM15SMEN = 1UL<<16, // TIM15 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SPI4SMEN = 1UL<<15, // SPI4 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_USART1SMEN = 1UL<<14, // USART1clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM8SMEN = 1UL<<13, // TIM8 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SPI1SMEN = 1UL<<12, // SPI1 clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_TIM1SMEN = 1UL<<11, // TIM1 timer clocks enable during Sleep and Stop modes Set and cleared by software.
	RCC_APB2SMENR_SYSCFGSMEN = 1UL<<0, // SYSCFG + COMP + VREFBUF + OPAMP clocks enable during Sleep and Stop modes Set and cleared by software.		
};

// RCC->CCIPR Peripherals independent clock configuration register
enum {
	RCC_CCIPR_ADC345SEL = ((1UL<<2)-1) << 30, // ADC3/4/5 clock source selection These bits are set and cleared by software to select the clock source used by the ADC345 interface.
	RCC_CCIPR_ADC12SEL = ((1UL<<2)-1) << 28, // ADC1/2 clock source selection These bits are set and cleared by software to select the clock source used by the ADC interface.
	RCC_CCIPR_CLK48SEL = ((1UL<<2)-1) << 26, // 48 MHz clock source selection These bits are set and cleared by software to select the 48 MHz clock source used by USB device FS and RNG.
	RCC_CCIPR_FDCANSEL = ((1UL<<2)-1) << 24, // None
	RCC_CCIPR_I2S23SEL = ((1UL<<2)-1) << 22, // clock source selection These bits are set and cleared by software to select the I2S23 clock source.
	RCC_CCIPR_SAI1SEL = ((1UL<<2)-1) << 20, // clock source selection These bits are set and cleared by software to select the SAI clock source.
	RCC_CCIPR_LPTIM1SEL = ((1UL<<2)-1) << 18, // Low power timer 1 clock source selection These bits are set and cleared by software to select the LPTIM1 clock source.
	RCC_CCIPR_I2C3SEL = ((1UL<<2)-1) << 16, // I2C3 clock source selection These bits are set and cleared by software to select the I2C3 clock source.
	RCC_CCIPR_I2C2SEL = ((1UL<<2)-1) << 14, // I2C2 clock source selection These bits are set and cleared by software to select the I2C2 clock source.
	RCC_CCIPR_I2C1SEL = ((1UL<<2)-1) << 12, // I2C1 clock source selection These bits are set and cleared by software to select the I2C1 clock source.
	RCC_CCIPR_LPUART1SEL = ((1UL<<2)-1) << 10, // LPUART1 clock source selection These bits are set and cleared by software to select the LPUART1 clock source.
	RCC_CCIPR_UART5SEL = ((1UL<<2)-1) << 8, // UART5 clock source selection These bits are set and cleared by software to select the UART5 clock source.
	RCC_CCIPR_UART4SEL = ((1UL<<2)-1) << 6, // UART4 clock source selection This bit is set and cleared by software to select the UART4 clock source.
	RCC_CCIPR_USART3SEL = ((1UL<<2)-1) << 4, // USART3 clock source selection This bit is set and cleared by software to select the USART3 clock source.
	RCC_CCIPR_USART2SEL = ((1UL<<2)-1) << 2, // USART2 clock source selection This bit is set and cleared by software to select the USART2 clock source.
	RCC_CCIPR_USART1SEL = ((1UL<<2)-1) << 0, // USART1 clock source selection This bit is set and cleared by software to select the USART1 clock source.		
};
static inline void rcc_ccipr_set_adc345sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_ADC345SEL) | ((val<<30) & RCC_CCIPR_ADC345SEL); }
static inline void rcc_ccipr_set_adc12sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_ADC12SEL) | ((val<<28) & RCC_CCIPR_ADC12SEL); }
static inline void rcc_ccipr_set_clk48sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_CLK48SEL) | ((val<<26) & RCC_CCIPR_CLK48SEL); }
static inline void rcc_ccipr_set_fdcansel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_FDCANSEL) | ((val<<24) & RCC_CCIPR_FDCANSEL); }
static inline void rcc_ccipr_set_i2s23sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2S23SEL) | ((val<<22) & RCC_CCIPR_I2S23SEL); }
static inline void rcc_ccipr_set_sai1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_SAI1SEL) | ((val<<20) & RCC_CCIPR_SAI1SEL); }
static inline void rcc_ccipr_set_lptim1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_LPTIM1SEL) | ((val<<18) & RCC_CCIPR_LPTIM1SEL); }
static inline void rcc_ccipr_set_i2c3sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2C3SEL) | ((val<<16) & RCC_CCIPR_I2C3SEL); }
static inline void rcc_ccipr_set_i2c2sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2C2SEL) | ((val<<14) & RCC_CCIPR_I2C2SEL); }
static inline void rcc_ccipr_set_i2c1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2C1SEL) | ((val<<12) & RCC_CCIPR_I2C1SEL); }
static inline void rcc_ccipr_set_lpuart1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_LPUART1SEL) | ((val<<10) & RCC_CCIPR_LPUART1SEL); }
static inline void rcc_ccipr_set_uart5sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_UART5SEL) | ((val<<8) & RCC_CCIPR_UART5SEL); }
static inline void rcc_ccipr_set_uart4sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_UART4SEL) | ((val<<6) & RCC_CCIPR_UART4SEL); }
static inline void rcc_ccipr_set_usart3sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART3SEL) | ((val<<4) & RCC_CCIPR_USART3SEL); }
static inline void rcc_ccipr_set_usart2sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART2SEL) | ((val<<2) & RCC_CCIPR_USART2SEL); }
static inline void rcc_ccipr_set_usart1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART1SEL) | ((val<<0) & RCC_CCIPR_USART1SEL); }
static inline uint32_t rcc_ccipr_get_adc345sel(void) { return (RCC.CCIPR & RCC_CCIPR_ADC345SEL) >> 30 ; }
static inline uint32_t rcc_ccipr_get_adc12sel(void) { return (RCC.CCIPR & RCC_CCIPR_ADC12SEL) >> 28 ; }
static inline uint32_t rcc_ccipr_get_clk48sel(void) { return (RCC.CCIPR & RCC_CCIPR_CLK48SEL) >> 26 ; }
static inline uint32_t rcc_ccipr_get_fdcansel(void) { return (RCC.CCIPR & RCC_CCIPR_FDCANSEL) >> 24 ; }
static inline uint32_t rcc_ccipr_get_i2s23sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2S23SEL) >> 22 ; }
static inline uint32_t rcc_ccipr_get_sai1sel(void) { return (RCC.CCIPR & RCC_CCIPR_SAI1SEL) >> 20 ; }
static inline uint32_t rcc_ccipr_get_lptim1sel(void) { return (RCC.CCIPR & RCC_CCIPR_LPTIM1SEL) >> 18 ; }
static inline uint32_t rcc_ccipr_get_i2c3sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2C3SEL) >> 16 ; }
static inline uint32_t rcc_ccipr_get_i2c2sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2C2SEL) >> 14 ; }
static inline uint32_t rcc_ccipr_get_i2c1sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2C1SEL) >> 12 ; }
static inline uint32_t rcc_ccipr_get_lpuart1sel(void) { return (RCC.CCIPR & RCC_CCIPR_LPUART1SEL) >> 10 ; }
static inline uint32_t rcc_ccipr_get_uart5sel(void) { return (RCC.CCIPR & RCC_CCIPR_UART5SEL) >> 8 ; }
static inline uint32_t rcc_ccipr_get_uart4sel(void) { return (RCC.CCIPR & RCC_CCIPR_UART4SEL) >> 6 ; }
static inline uint32_t rcc_ccipr_get_usart3sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART3SEL) >> 4 ; }
static inline uint32_t rcc_ccipr_get_usart2sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART2SEL) >> 2 ; }
static inline uint32_t rcc_ccipr_get_usart1sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART1SEL) >> 0 ; }

// RCC->BDCR RTC domain control register
enum {
	RCC_BDCR_LSCOSEL = 1UL<<25, // Low speed clock output selection Set and cleared by software.
	RCC_BDCR_LSCOEN = 1UL<<24, // Low speed clock output enable Set and cleared by software.
	RCC_BDCR_BDRST = 1UL<<16, // RTC domain software reset Set and cleared by software.
	RCC_BDCR_RTCEN = 1UL<<15, // RTC clock enable Set and cleared by software.
	RCC_BDCR_RTCSEL = ((1UL<<2)-1) << 8, // RTC clock source selection Set by software to select the clock source for the RTC. Once the RTC clock source has been selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The BDRST bit can be used to reset them.
	RCC_BDCR_LSECSSD = 1UL<<6, // CSS on LSE failure Detection Set by hardware to indicate when a failure has been detected by the Clock Security System on the external 32 kHz oscillator (LSE).
	RCC_BDCR_LSECSSON = 1UL<<5, // CSS on LSE enable Set by software to enable the Clock Security System on LSE (32 kHz oscillator). LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected. Once enabled this bit cannot be disabled, except after a LSE failure detection (LSECSSD =1). In that case the software MUST disable the LSECSSON bit.
	RCC_BDCR_LSEDRV = ((1UL<<2)-1) << 3, // LSE oscillator drive capability Set by software to modulate the LSE oscillator’s drive capability. The oscillator is in Xtal mode when it is not in bypass mode.
	RCC_BDCR_LSEBYP = 1UL<<2, // LSE oscillator bypass Set and cleared by software to bypass oscillator in debug mode. This bit can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).
	RCC_BDCR_LSERDY = 1UL<<1, // LSE oscillator ready Set and cleared by hardware to indicate when the external 32 kHz oscillator is stable. After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
	RCC_BDCR_LSEON = 1UL<<0, // LSE oscillator enable Set and cleared by software.		
};
static inline void rcc_bdcr_set_rtcsel(uint32_t val) { RCC.BDCR = (RCC.BDCR & ~RCC_BDCR_RTCSEL) | ((val<<8) & RCC_BDCR_RTCSEL); }
static inline void rcc_bdcr_set_lsedrv(uint32_t val) { RCC.BDCR = (RCC.BDCR & ~RCC_BDCR_LSEDRV) | ((val<<3) & RCC_BDCR_LSEDRV); }
static inline uint32_t rcc_bdcr_get_rtcsel(void) { return (RCC.BDCR & RCC_BDCR_RTCSEL) >> 8 ; }
static inline uint32_t rcc_bdcr_get_lsedrv(void) { return (RCC.BDCR & RCC_BDCR_LSEDRV) >> 3 ; }

// RCC->CSR Control/status register
enum {
	RCC_CSR_LPWRRSTF = 1UL<<31, // Low-power reset flag Set by hardware when a reset occurs due to illegal Stop, Standby or Shutdown mode entry. Cleared by writing to the RMVF bit.
	RCC_CSR_WWDGRSTF = 1UL<<30, // Window watchdog reset flag Set by hardware when a window watchdog reset occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_IWDGRSTF = 1UL<<29, // Independent window watchdog reset flag Set by hardware when an independent watchdog reset domain occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_SFTRSTF = 1UL<<28, // Software reset flag Set by hardware when a software reset occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_BORRSTF = 1UL<<27, // BOR flag Set by hardware when a BOR occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_PINRSTF = 1UL<<26, // Pin reset flag Set by hardware when a reset from the NRST pin occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_OBLRSTF = 1UL<<25, // Option byte loader reset flag Set by hardware when a reset from the Option Byte loading occurs. Cleared by writing to the RMVF bit.
	RCC_CSR_RMVF = 1UL<<23, // Remove reset flag Set by software to clear the reset flags.
	RCC_CSR_LSIRDY = 1UL<<1, // LSI oscillator ready Set and cleared by hardware to indicate when the LSI oscillator is stable. After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
	RCC_CSR_LSION = 1UL<<0, // LSI oscillator enable Set and cleared by software.		
};

// RCC->CRRCR Clock recovery RC register
enum {
	RCC_CRRCR_HSI48CAL = ((1UL<<9)-1) << 7, // HSI48 clock calibration These bits are initialized at startup with the factory-programmed HSI48 calibration trim value. They are ready only.
	RCC_CRRCR_HSI48RDY = 1UL<<1, // HSI48 clock ready flag Set by hardware to indicate that HSI48 oscillator is stable. This bit is set only when HSI48 is enabled by software by setting HSI48ON.
	RCC_CRRCR_HSI48ON = 1UL<<0, // HSI48 clock enable Set and cleared by software. Cleared by hardware to stop the HSI48 when entering in Stop, Standby or Shutdown modes.		
};
static inline void rcc_crrcr_set_hsi48cal(uint32_t val) { RCC.CRRCR = (RCC.CRRCR & ~RCC_CRRCR_HSI48CAL) | ((val<<7) & RCC_CRRCR_HSI48CAL); }
static inline uint32_t rcc_crrcr_get_hsi48cal(void) { return (RCC.CRRCR & RCC_CRRCR_HSI48CAL) >> 7 ; }

// RCC->CCIPR2 Peripherals independent clock configuration register
enum {
	RCC_CCIPR2_QSPISEL = ((1UL<<2)-1) << 20, // QUADSPI clock source selection Set and reset by software.
	RCC_CCIPR2_I2C4SEL = ((1UL<<2)-1) << 0, // I2C4 clock source selection These bits are set and cleared by software to select the I2C4 clock source.		
};
static inline void rcc_ccipr2_set_qspisel(uint32_t val) { RCC.CCIPR2 = (RCC.CCIPR2 & ~RCC_CCIPR2_QSPISEL) | ((val<<20) & RCC_CCIPR2_QSPISEL); }
static inline void rcc_ccipr2_set_i2c4sel(uint32_t val) { RCC.CCIPR2 = (RCC.CCIPR2 & ~RCC_CCIPR2_I2C4SEL) | ((val<<0) & RCC_CCIPR2_I2C4SEL); }
static inline uint32_t rcc_ccipr2_get_qspisel(void) { return (RCC.CCIPR2 & RCC_CCIPR2_QSPISEL) >> 20 ; }
static inline uint32_t rcc_ccipr2_get_i2c4sel(void) { return (RCC.CCIPR2 & RCC_CCIPR2_I2C4SEL) >> 0 ; }

/* Random number generator
There is only one peripheral of type RNG. */
struct RNG_Type {
	__IO uint32_t CR; // @0 control register
	__IO uint32_t SR; // @4 status register
	__I uint32_t DR; // @8 data register
};
extern struct RNG_Type	RNG;	// @0x50060800 

// RNG->CR control register
enum {
	RNG_CR_CED = 1UL<<5, // Clock error detection
	RNG_CR_IE = 1UL<<3, // Interrupt enable
	RNG_CR_RNGEN = 1UL<<2, // Random number generator enable		
};

// RNG->SR status register
enum {
	RNG_SR_SEIS = 1UL<<6, // Seed error interrupt status
	RNG_SR_CEIS = 1UL<<5, // Clock error interrupt status
	RNG_SR_SECS = 1UL<<2, // Seed error current status
	RNG_SR_CECS = 1UL<<1, // Clock error current status
	RNG_SR_DRDY = 1UL<<0, // Data ready		
};

/* Real-time clock
There is only one peripheral of type RTC. */
struct RTC_Type {
	__IO uint32_t TR; // @0 time register
	__IO uint32_t DR; // @4 date register
	__I uint32_t SSR; // @8 sub second register
	__IO uint32_t ICSR; // @12 initialization and status register
	__IO uint32_t PRER; // @16 prescaler register
	__IO uint32_t WUTR; // @20 wakeup timer register
	__IO uint32_t CR; // @24 control register
	 uint8_t RESERVED0[8]; // @28 
	__O uint32_t WPR; // @36 write protection register
	__IO uint32_t CALR; // @40 calibration register
	__O uint32_t SHIFTR; // @44 shift control register
	__I uint32_t TSTR; // @48 time stamp time register
	__I uint32_t TSDR; // @52 time stamp date register
	__I uint32_t TSSSR; // @56 timestamp sub second register
	 uint8_t RESERVED1[4]; // @60 
	__IO uint32_t ALRMAR; // @64 alarm A register
	__IO uint32_t ALRMASSR; // @68 alarm A sub second register
	__IO uint32_t ALRMBR; // @72 alarm B register
	__IO uint32_t ALRMBSSR; // @76 alarm B sub second register
	__I uint32_t SR; // @80 status register
	__I uint32_t MISR; // @84 status register
	 uint8_t RESERVED2[4]; // @88 
	__O uint32_t SCR; // @92 status register
};
extern struct RTC_Type	RTC;	// @0x40002800 

// RTC->TR time register
enum {
	RTC_TR_PM = 1UL<<22, // AM/PM notation
	RTC_TR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline void rtc_tr_set_ht(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_HT) | ((val<<20) & RTC_TR_HT); }
static inline void rtc_tr_set_hu(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_HU) | ((val<<16) & RTC_TR_HU); }
static inline void rtc_tr_set_mnt(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_MNT) | ((val<<12) & RTC_TR_MNT); }
static inline void rtc_tr_set_mnu(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_MNU) | ((val<<8) & RTC_TR_MNU); }
static inline void rtc_tr_set_st(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_ST) | ((val<<4) & RTC_TR_ST); }
static inline void rtc_tr_set_su(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_SU) | ((val<<0) & RTC_TR_SU); }
static inline uint32_t rtc_tr_get_ht(void) { return (RTC.TR & RTC_TR_HT) >> 20 ; }
static inline uint32_t rtc_tr_get_hu(void) { return (RTC.TR & RTC_TR_HU) >> 16 ; }
static inline uint32_t rtc_tr_get_mnt(void) { return (RTC.TR & RTC_TR_MNT) >> 12 ; }
static inline uint32_t rtc_tr_get_mnu(void) { return (RTC.TR & RTC_TR_MNU) >> 8 ; }
static inline uint32_t rtc_tr_get_st(void) { return (RTC.TR & RTC_TR_ST) >> 4 ; }
static inline uint32_t rtc_tr_get_su(void) { return (RTC.TR & RTC_TR_SU) >> 0 ; }

// RTC->DR date register
enum {
	RTC_DR_YT = ((1UL<<4)-1) << 20, // Year tens in BCD format
	RTC_DR_YU = ((1UL<<4)-1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_DR_MT = 1UL<<12, // Month tens in BCD format
	RTC_DR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_DR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_DR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
static inline void rtc_dr_set_yt(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_YT) | ((val<<20) & RTC_DR_YT); }
static inline void rtc_dr_set_yu(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_YU) | ((val<<16) & RTC_DR_YU); }
static inline void rtc_dr_set_wdu(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_WDU) | ((val<<13) & RTC_DR_WDU); }
static inline void rtc_dr_set_mu(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_MU) | ((val<<8) & RTC_DR_MU); }
static inline void rtc_dr_set_dt(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_DT) | ((val<<4) & RTC_DR_DT); }
static inline void rtc_dr_set_du(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_DU) | ((val<<0) & RTC_DR_DU); }
static inline uint32_t rtc_dr_get_yt(void) { return (RTC.DR & RTC_DR_YT) >> 20 ; }
static inline uint32_t rtc_dr_get_yu(void) { return (RTC.DR & RTC_DR_YU) >> 16 ; }
static inline uint32_t rtc_dr_get_wdu(void) { return (RTC.DR & RTC_DR_WDU) >> 13 ; }
static inline uint32_t rtc_dr_get_mu(void) { return (RTC.DR & RTC_DR_MU) >> 8 ; }
static inline uint32_t rtc_dr_get_dt(void) { return (RTC.DR & RTC_DR_DT) >> 4 ; }
static inline uint32_t rtc_dr_get_du(void) { return (RTC.DR & RTC_DR_DU) >> 0 ; }

// RTC->SSR sub second register
enum {
	RTC_SSR_SS = ((1UL<<16)-1) << 0, // Sub second value		
};
static inline uint32_t rtc_ssr_get_ss(void) { return (RTC.SSR & RTC_SSR_SS) >> 0 ; }

// RTC->ICSR initialization and status register
enum {
	RTC_ICSR_RECALPF = 1UL<<16, // Recalibration pending Flag
	RTC_ICSR_INIT = 1UL<<7, // Initialization mode
	RTC_ICSR_INITF = 1UL<<6, // Initialization flag
	RTC_ICSR_RSF = 1UL<<5, // Registers synchronization flag
	RTC_ICSR_INITS = 1UL<<4, // Initialization status flag
	RTC_ICSR_SHPF = 1UL<<3, // Shift operation pending
	RTC_ICSR_WUTWF = 1UL<<2, // Wakeup timer write flag
	RTC_ICSR_ALRBWF = 1UL<<1, // Alarm B write flag
	RTC_ICSR_ALRAWF = 1UL<<0, // Alarm A write flag		
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL<<7)-1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL<<15)-1) << 0, // Synchronous prescaler factor		
};
static inline void rtc_prer_set_prediv_a(uint32_t val) { RTC.PRER = (RTC.PRER & ~RTC_PRER_PREDIV_A) | ((val<<16) & RTC_PRER_PREDIV_A); }
static inline void rtc_prer_set_prediv_s(uint32_t val) { RTC.PRER = (RTC.PRER & ~RTC_PRER_PREDIV_S) | ((val<<0) & RTC_PRER_PREDIV_S); }
static inline uint32_t rtc_prer_get_prediv_a(void) { return (RTC.PRER & RTC_PRER_PREDIV_A) >> 16 ; }
static inline uint32_t rtc_prer_get_prediv_s(void) { return (RTC.PRER & RTC_PRER_PREDIV_S) >> 0 ; }

// RTC->WUTR wakeup timer register
enum {
	RTC_WUTR_WUT = ((1UL<<16)-1) << 0, // Wakeup auto-reload value bits		
};
static inline void rtc_wutr_set_wut(uint32_t val) { RTC.WUTR = (RTC.WUTR & ~RTC_WUTR_WUT) | ((val<<0) & RTC_WUTR_WUT); }
static inline uint32_t rtc_wutr_get_wut(void) { return (RTC.WUTR & RTC_WUTR_WUT) >> 0 ; }

// RTC->CR control register
enum {
	RTC_CR_OUT2EN = 1UL<<31, // OUT2EN
	RTC_CR_TAMPALRM_TYPE = 1UL<<30, // TAMPALRM_TYPE
	RTC_CR_TAMPALRM_PU = 1UL<<29, // TAMPALRM_PU
	RTC_CR_TAMPOE = 1UL<<26, // TAMPOE
	RTC_CR_TAMPTS = 1UL<<25, // TAMPTS
	RTC_CR_ITSE = 1UL<<24, // timestamp on internal event enable
	RTC_CR_COE = 1UL<<23, // Calibration output enable
	RTC_CR_OSEL = ((1UL<<2)-1) << 21, // Output selection
	RTC_CR_POL = 1UL<<20, // Output polarity
	RTC_CR_COSEL = 1UL<<19, // Calibration output selection
	RTC_CR_BKP = 1UL<<18, // Backup
	RTC_CR_SUB1H = 1UL<<17, // Subtract 1 hour (winter time change)
	RTC_CR_ADD1H = 1UL<<16, // Add 1 hour (summer time change)
	RTC_CR_TSIE = 1UL<<15, // Time-stamp interrupt enable
	RTC_CR_WUTIE = 1UL<<14, // Wakeup timer interrupt enable
	RTC_CR_ALRBIE = 1UL<<13, // Alarm B interrupt enable
	RTC_CR_ALRAIE = 1UL<<12, // Alarm A interrupt enable
	RTC_CR_TSE = 1UL<<11, // Time stamp enable
	RTC_CR_WUTE = 1UL<<10, // Wakeup timer enable
	RTC_CR_ALRBE = 1UL<<9, // Alarm B enable
	RTC_CR_ALRAE = 1UL<<8, // Alarm A enable
	RTC_CR_FMT = 1UL<<6, // Hour format
	RTC_CR_BYPSHAD = 1UL<<5, // Bypass the shadow registers
	RTC_CR_REFCKON = 1UL<<4, // Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE = 1UL<<3, // Time-stamp event active edge
	RTC_CR_WCKSEL = ((1UL<<3)-1) << 0, // Wakeup clock selection		
};
static inline void rtc_cr_set_osel(uint32_t val) { RTC.CR = (RTC.CR & ~RTC_CR_OSEL) | ((val<<21) & RTC_CR_OSEL); }
static inline void rtc_cr_set_wcksel(uint32_t val) { RTC.CR = (RTC.CR & ~RTC_CR_WCKSEL) | ((val<<0) & RTC_CR_WCKSEL); }
static inline uint32_t rtc_cr_get_osel(void) { return (RTC.CR & RTC_CR_OSEL) >> 21 ; }
static inline uint32_t rtc_cr_get_wcksel(void) { return (RTC.CR & RTC_CR_WCKSEL) >> 0 ; }

// RTC->WPR write protection register
enum {
	RTC_WPR_KEY = ((1UL<<8)-1) << 0, // Write protection key		
};
static inline void rtc_wpr_set_key(uint32_t val) { RTC.WPR = (RTC.WPR & ~RTC_WPR_KEY) | ((val<<0) & RTC_WPR_KEY); }
static inline uint32_t rtc_wpr_get_key(void) { return (RTC.WPR & RTC_WPR_KEY) >> 0 ; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP = 1UL<<15, // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8 = 1UL<<14, // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL<<13, // Use a 16-second calibration cycle period
	RTC_CALR_CALM = ((1UL<<9)-1) << 0, // Calibration minus		
};
static inline void rtc_calr_set_calm(uint32_t val) { RTC.CALR = (RTC.CALR & ~RTC_CALR_CALM) | ((val<<0) & RTC_CALR_CALM); }
static inline uint32_t rtc_calr_get_calm(void) { return (RTC.CALR & RTC_CALR_CALM) >> 0 ; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL<<31, // Add one second
	RTC_SHIFTR_SUBFS = ((1UL<<15)-1) << 0, // Subtract a fraction of a second		
};
static inline void rtc_shiftr_set_subfs(uint32_t val) { RTC.SHIFTR = (RTC.SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val<<0) & RTC_SHIFTR_SUBFS); }
static inline uint32_t rtc_shiftr_get_subfs(void) { return (RTC.SHIFTR & RTC_SHIFTR_SUBFS) >> 0 ; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM = 1UL<<22, // AM/PM notation
	RTC_TSTR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TSTR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TSTR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline uint32_t rtc_tstr_get_ht(void) { return (RTC.TSTR & RTC_TSTR_HT) >> 20 ; }
static inline uint32_t rtc_tstr_get_hu(void) { return (RTC.TSTR & RTC_TSTR_HU) >> 16 ; }
static inline uint32_t rtc_tstr_get_mnt(void) { return (RTC.TSTR & RTC_TSTR_MNT) >> 12 ; }
static inline uint32_t rtc_tstr_get_mnu(void) { return (RTC.TSTR & RTC_TSTR_MNU) >> 8 ; }
static inline uint32_t rtc_tstr_get_st(void) { return (RTC.TSTR & RTC_TSTR_ST) >> 4 ; }
static inline uint32_t rtc_tstr_get_su(void) { return (RTC.TSTR & RTC_TSTR_SU) >> 0 ; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_TSDR_MT = 1UL<<12, // Month tens in BCD format
	RTC_TSDR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_TSDR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_TSDR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
static inline uint32_t rtc_tsdr_get_wdu(void) { return (RTC.TSDR & RTC_TSDR_WDU) >> 13 ; }
static inline uint32_t rtc_tsdr_get_mu(void) { return (RTC.TSDR & RTC_TSDR_MU) >> 8 ; }
static inline uint32_t rtc_tsdr_get_dt(void) { return (RTC.TSDR & RTC_TSDR_DT) >> 4 ; }
static inline uint32_t rtc_tsdr_get_du(void) { return (RTC.TSDR & RTC_TSDR_DU) >> 0 ; }

// RTC->TSSSR timestamp sub second register
enum {
	RTC_TSSSR_SS = ((1UL<<16)-1) << 0, // Sub second value		
};
static inline uint32_t rtc_tsssr_get_ss(void) { return (RTC.TSSSR & RTC_TSSSR_SS) >> 0 ; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4 = 1UL<<31, // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMAR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3 = 1UL<<23, // Alarm A hours mask
	RTC_ALRMAR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMAR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2 = 1UL<<15, // Alarm A minutes mask
	RTC_ALRMAR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMAR_MSK1 = 1UL<<7, // Alarm A seconds mask
	RTC_ALRMAR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMAR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline void rtc_alrmar_set_dt(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_DT) | ((val<<28) & RTC_ALRMAR_DT); }
static inline void rtc_alrmar_set_du(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_DU) | ((val<<24) & RTC_ALRMAR_DU); }
static inline void rtc_alrmar_set_ht(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_HT) | ((val<<20) & RTC_ALRMAR_HT); }
static inline void rtc_alrmar_set_hu(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_HU) | ((val<<16) & RTC_ALRMAR_HU); }
static inline void rtc_alrmar_set_mnt(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_MNT) | ((val<<12) & RTC_ALRMAR_MNT); }
static inline void rtc_alrmar_set_mnu(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_MNU) | ((val<<8) & RTC_ALRMAR_MNU); }
static inline void rtc_alrmar_set_st(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_ST) | ((val<<4) & RTC_ALRMAR_ST); }
static inline void rtc_alrmar_set_su(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_SU) | ((val<<0) & RTC_ALRMAR_SU); }
static inline uint32_t rtc_alrmar_get_dt(void) { return (RTC.ALRMAR & RTC_ALRMAR_DT) >> 28 ; }
static inline uint32_t rtc_alrmar_get_du(void) { return (RTC.ALRMAR & RTC_ALRMAR_DU) >> 24 ; }
static inline uint32_t rtc_alrmar_get_ht(void) { return (RTC.ALRMAR & RTC_ALRMAR_HT) >> 20 ; }
static inline uint32_t rtc_alrmar_get_hu(void) { return (RTC.ALRMAR & RTC_ALRMAR_HU) >> 16 ; }
static inline uint32_t rtc_alrmar_get_mnt(void) { return (RTC.ALRMAR & RTC_ALRMAR_MNT) >> 12 ; }
static inline uint32_t rtc_alrmar_get_mnu(void) { return (RTC.ALRMAR & RTC_ALRMAR_MNU) >> 8 ; }
static inline uint32_t rtc_alrmar_get_st(void) { return (RTC.ALRMAR & RTC_ALRMAR_ST) >> 4 ; }
static inline uint32_t rtc_alrmar_get_su(void) { return (RTC.ALRMAR & RTC_ALRMAR_SU) >> 0 ; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
static inline void rtc_alrmassr_set_maskss(uint32_t val) { RTC.ALRMASSR = (RTC.ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val<<24) & RTC_ALRMASSR_MASKSS); }
static inline void rtc_alrmassr_set_ss(uint32_t val) { RTC.ALRMASSR = (RTC.ALRMASSR & ~RTC_ALRMASSR_SS) | ((val<<0) & RTC_ALRMASSR_SS); }
static inline uint32_t rtc_alrmassr_get_maskss(void) { return (RTC.ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24 ; }
static inline uint32_t rtc_alrmassr_get_ss(void) { return (RTC.ALRMASSR & RTC_ALRMASSR_SS) >> 0 ; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4 = 1UL<<31, // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMBR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3 = 1UL<<23, // Alarm B hours mask
	RTC_ALRMBR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMBR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2 = 1UL<<15, // Alarm B minutes mask
	RTC_ALRMBR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMBR_MSK1 = 1UL<<7, // Alarm B seconds mask
	RTC_ALRMBR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMBR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline void rtc_alrmbr_set_dt(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_DT) | ((val<<28) & RTC_ALRMBR_DT); }
static inline void rtc_alrmbr_set_du(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_DU) | ((val<<24) & RTC_ALRMBR_DU); }
static inline void rtc_alrmbr_set_ht(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_HT) | ((val<<20) & RTC_ALRMBR_HT); }
static inline void rtc_alrmbr_set_hu(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_HU) | ((val<<16) & RTC_ALRMBR_HU); }
static inline void rtc_alrmbr_set_mnt(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_MNT) | ((val<<12) & RTC_ALRMBR_MNT); }
static inline void rtc_alrmbr_set_mnu(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_MNU) | ((val<<8) & RTC_ALRMBR_MNU); }
static inline void rtc_alrmbr_set_st(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_ST) | ((val<<4) & RTC_ALRMBR_ST); }
static inline void rtc_alrmbr_set_su(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_SU) | ((val<<0) & RTC_ALRMBR_SU); }
static inline uint32_t rtc_alrmbr_get_dt(void) { return (RTC.ALRMBR & RTC_ALRMBR_DT) >> 28 ; }
static inline uint32_t rtc_alrmbr_get_du(void) { return (RTC.ALRMBR & RTC_ALRMBR_DU) >> 24 ; }
static inline uint32_t rtc_alrmbr_get_ht(void) { return (RTC.ALRMBR & RTC_ALRMBR_HT) >> 20 ; }
static inline uint32_t rtc_alrmbr_get_hu(void) { return (RTC.ALRMBR & RTC_ALRMBR_HU) >> 16 ; }
static inline uint32_t rtc_alrmbr_get_mnt(void) { return (RTC.ALRMBR & RTC_ALRMBR_MNT) >> 12 ; }
static inline uint32_t rtc_alrmbr_get_mnu(void) { return (RTC.ALRMBR & RTC_ALRMBR_MNU) >> 8 ; }
static inline uint32_t rtc_alrmbr_get_st(void) { return (RTC.ALRMBR & RTC_ALRMBR_ST) >> 4 ; }
static inline uint32_t rtc_alrmbr_get_su(void) { return (RTC.ALRMBR & RTC_ALRMBR_SU) >> 0 ; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
static inline void rtc_alrmbssr_set_maskss(uint32_t val) { RTC.ALRMBSSR = (RTC.ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val<<24) & RTC_ALRMBSSR_MASKSS); }
static inline void rtc_alrmbssr_set_ss(uint32_t val) { RTC.ALRMBSSR = (RTC.ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val<<0) & RTC_ALRMBSSR_SS); }
static inline uint32_t rtc_alrmbssr_get_maskss(void) { return (RTC.ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24 ; }
static inline uint32_t rtc_alrmbssr_get_ss(void) { return (RTC.ALRMBSSR & RTC_ALRMBSSR_SS) >> 0 ; }

// RTC->SR status register
enum {
	RTC_SR_ITSF = 1UL<<5, // ITSF
	RTC_SR_TSOVF = 1UL<<4, // TSOVF
	RTC_SR_TSF = 1UL<<3, // TSF
	RTC_SR_WUTF = 1UL<<2, // WUTF
	RTC_SR_ALRBF = 1UL<<1, // ALRBF
	RTC_SR_ALRAF = 1UL<<0, // ALRAF		
};

// RTC->MISR status register
enum {
	RTC_MISR_ITSMF = 1UL<<5, // ITSMF
	RTC_MISR_TSOVMF = 1UL<<4, // TSOVMF
	RTC_MISR_TSMF = 1UL<<3, // TSMF
	RTC_MISR_WUTMF = 1UL<<2, // WUTMF
	RTC_MISR_ALRBMF = 1UL<<1, // ALRBMF
	RTC_MISR_ALRAMF = 1UL<<0, // ALRAMF		
};

// RTC->SCR status register
enum {
	RTC_SCR_CITSF = 1UL<<5, // CITSF
	RTC_SCR_CTSOVF = 1UL<<4, // CTSOVF
	RTC_SCR_CTSF = 1UL<<3, // CTSF
	RTC_SCR_CWUTF = 1UL<<2, // CWUTF
	RTC_SCR_CALRBF = 1UL<<1, // CALRBF
	RTC_SCR_CALRAF = 1UL<<0, // CALRAF		
};

/* System control block
There is only one peripheral of type SCB. */
struct SCB_Type {
	__I uint32_t CPUID; // @0 CPUID base register
	__IO uint32_t ICSR; // @4 Interrupt control and state register
	__IO uint32_t VTOR; // @8 Vector table offset register
	__IO uint32_t AIRCR; // @12 Application interrupt and reset control register
	__IO uint32_t SCR; // @16 System control register
	__IO uint32_t CCR; // @20 Configuration and control register
	__IO uint32_t SHPR1; // @24 System handler priority registers
	__IO uint32_t SHPR2; // @28 System handler priority registers
	__IO uint32_t SHPR3; // @32 System handler priority registers
	__IO uint32_t SHCSR; // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR; // @44 Hard fault status register
	 uint8_t RESERVED0[4]; // @48 
	__IO uint32_t MMFAR; // @52 Memory management fault address register
	__IO uint32_t BFAR; // @56 Bus fault address register
	__IO uint32_t AFSR; // @60 Auxiliary fault status register
};
extern struct SCB_Type	SCB;	// @0xE000ED00 

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL<<8)-1) << 24, // Implementer code
	SCB_CPUID_VARIANT = ((1UL<<4)-1) << 20, // Variant number
	SCB_CPUID_CONSTANT = ((1UL<<4)-1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO = ((1UL<<12)-1) << 4, // Part number of the processor
	SCB_CPUID_REVISION = ((1UL<<4)-1) << 0, // Revision number		
};
static inline uint32_t scb_cpuid_get_implementer(void) { return (SCB.CPUID & SCB_CPUID_IMPLEMENTER) >> 24 ; }
static inline uint32_t scb_cpuid_get_variant(void) { return (SCB.CPUID & SCB_CPUID_VARIANT) >> 20 ; }
static inline uint32_t scb_cpuid_get_constant(void) { return (SCB.CPUID & SCB_CPUID_CONSTANT) >> 16 ; }
static inline uint32_t scb_cpuid_get_partno(void) { return (SCB.CPUID & SCB_CPUID_PARTNO) >> 4 ; }
static inline uint32_t scb_cpuid_get_revision(void) { return (SCB.CPUID & SCB_CPUID_REVISION) >> 0 ; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET = 1UL<<31, // NMI set-pending bit.
	SCB_ICSR_PENDSVSET = 1UL<<28, // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR = 1UL<<27, // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET = 1UL<<26, // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR = 1UL<<25, // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING = 1UL<<22, // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL<<7)-1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE = 1UL<<11, // Return to base level
	SCB_ICSR_VECTACTIVE = ((1UL<<9)-1) << 0, // Active vector		
};
static inline void scb_icsr_set_vectpending(uint32_t val) { SCB.ICSR = (SCB.ICSR & ~SCB_ICSR_VECTPENDING) | ((val<<12) & SCB_ICSR_VECTPENDING); }
static inline void scb_icsr_set_vectactive(uint32_t val) { SCB.ICSR = (SCB.ICSR & ~SCB_ICSR_VECTACTIVE) | ((val<<0) & SCB_ICSR_VECTACTIVE); }
static inline uint32_t scb_icsr_get_vectpending(void) { return (SCB.ICSR & SCB_ICSR_VECTPENDING) >> 12 ; }
static inline uint32_t scb_icsr_get_vectactive(void) { return (SCB.ICSR & SCB_ICSR_VECTACTIVE) >> 0 ; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL<<21)-1) << 9, // Vector table base offset field		
};
static inline void scb_vtor_set_tbloff(uint32_t val) { SCB.VTOR = (SCB.VTOR & ~SCB_VTOR_TBLOFF) | ((val<<9) & SCB_VTOR_TBLOFF); }
static inline uint32_t scb_vtor_get_tbloff(void) { return (SCB.VTOR & SCB_VTOR_TBLOFF) >> 9 ; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT = ((1UL<<16)-1) << 16, // Register key
	SCB_AIRCR_ENDIANESS = 1UL<<15, // ENDIANESS
	SCB_AIRCR_PRIGROUP = ((1UL<<3)-1) << 8, // PRIGROUP
	SCB_AIRCR_SYSRESETREQ = 1UL<<2, // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL<<1, // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET = 1UL<<0, // VECTRESET		
};
static inline void scb_aircr_set_vectkeystat(uint32_t val) { SCB.AIRCR = (SCB.AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val<<16) & SCB_AIRCR_VECTKEYSTAT); }
static inline void scb_aircr_set_prigroup(uint32_t val) { SCB.AIRCR = (SCB.AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val<<8) & SCB_AIRCR_PRIGROUP); }
static inline uint32_t scb_aircr_get_vectkeystat(void) { return (SCB.AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16 ; }
static inline uint32_t scb_aircr_get_prigroup(void) { return (SCB.AIRCR & SCB_AIRCR_PRIGROUP) >> 8 ; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND = 1UL<<4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP = 1UL<<2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL<<1, // SLEEPONEXIT		
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN = 1UL<<9, // STKALIGN
	SCB_CCR_BFHFNMIGN = 1UL<<8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP = 1UL<<4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP = 1UL<<3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND = 1UL<<1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL<<0, // Configures how the processor enters Thread mode		
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL<<8)-1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL<<8)-1) << 8, // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL<<8)-1) << 0, // Priority of system handler 4		
};
static inline void scb_shpr1_set_pri_6(uint32_t val) { SCB.SHPR1 = (SCB.SHPR1 & ~SCB_SHPR1_PRI_6) | ((val<<16) & SCB_SHPR1_PRI_6); }
static inline void scb_shpr1_set_pri_5(uint32_t val) { SCB.SHPR1 = (SCB.SHPR1 & ~SCB_SHPR1_PRI_5) | ((val<<8) & SCB_SHPR1_PRI_5); }
static inline void scb_shpr1_set_pri_4(uint32_t val) { SCB.SHPR1 = (SCB.SHPR1 & ~SCB_SHPR1_PRI_4) | ((val<<0) & SCB_SHPR1_PRI_4); }
static inline uint32_t scb_shpr1_get_pri_6(void) { return (SCB.SHPR1 & SCB_SHPR1_PRI_6) >> 16 ; }
static inline uint32_t scb_shpr1_get_pri_5(void) { return (SCB.SHPR1 & SCB_SHPR1_PRI_5) >> 8 ; }
static inline uint32_t scb_shpr1_get_pri_4(void) { return (SCB.SHPR1 & SCB_SHPR1_PRI_4) >> 0 ; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL<<8)-1) << 24, // Priority of system handler 11		
};
static inline void scb_shpr2_set_pri_11(uint32_t val) { SCB.SHPR2 = (SCB.SHPR2 & ~SCB_SHPR2_PRI_11) | ((val<<24) & SCB_SHPR2_PRI_11); }
static inline uint32_t scb_shpr2_get_pri_11(void) { return (SCB.SHPR2 & SCB_SHPR2_PRI_11) >> 24 ; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL<<8)-1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL<<8)-1) << 16, // Priority of system handler 14		
};
static inline void scb_shpr3_set_pri_15(uint32_t val) { SCB.SHPR3 = (SCB.SHPR3 & ~SCB_SHPR3_PRI_15) | ((val<<24) & SCB_SHPR3_PRI_15); }
static inline void scb_shpr3_set_pri_14(uint32_t val) { SCB.SHPR3 = (SCB.SHPR3 & ~SCB_SHPR3_PRI_14) | ((val<<16) & SCB_SHPR3_PRI_14); }
static inline uint32_t scb_shpr3_get_pri_15(void) { return (SCB.SHPR3 & SCB_SHPR3_PRI_15) >> 24 ; }
static inline uint32_t scb_shpr3_get_pri_14(void) { return (SCB.SHPR3 & SCB_SHPR3_PRI_14) >> 16 ; }

// SCB->SHCSR System handler control and state register
enum {
	SCB_SHCSR_USGFAULTENA = 1UL<<18, // Usage fault enable bit
	SCB_SHCSR_BUSFAULTENA = 1UL<<17, // Bus fault enable bit
	SCB_SHCSR_MEMFAULTENA = 1UL<<16, // Memory management fault enable bit
	SCB_SHCSR_SVCALLPENDED = 1UL<<15, // SVC call pending bit
	SCB_SHCSR_BUSFAULTPENDED = 1UL<<14, // Bus fault exception pending bit
	SCB_SHCSR_MEMFAULTPENDED = 1UL<<13, // Memory management fault exception pending bit
	SCB_SHCSR_USGFAULTPENDED = 1UL<<12, // Usage fault exception pending bit
	SCB_SHCSR_SYSTICKACT = 1UL<<11, // SysTick exception active bit
	SCB_SHCSR_PENDSVACT = 1UL<<10, // PendSV exception active bit
	SCB_SHCSR_MONITORACT = 1UL<<8, // Debug monitor active bit
	SCB_SHCSR_SVCALLACT = 1UL<<7, // SVC call active bit
	SCB_SHCSR_USGFAULTACT = 1UL<<3, // Usage fault exception active bit
	SCB_SHCSR_BUSFAULTACT = 1UL<<1, // Bus fault exception active bit
	SCB_SHCSR_MEMFAULTACT = 1UL<<0, // Memory management fault exception active bit		
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 1UL<<25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 1UL<<24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 1UL<<19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 1UL<<18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 1UL<<17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 1UL<<16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 1UL<<15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 1UL<<13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 1UL<<12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 1UL<<11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL<<10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 1UL<<9, // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 1UL<<8, // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 1UL<<7, // Memory Management Fault Address Register (MMAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 1UL<<5, // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 1UL<<4, // Memory manager fault on stacking for exception entry.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 1UL<<3, // Memory manager fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 1UL<<1, // Instruction access violation flag		
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL<<31, // Reserved for Debug use
	SCB_HFSR_FORCED = 1UL<<30, // Forced hard fault
	SCB_HFSR_VECTTBL = 1UL<<1, // Vector table hard fault		
};

/* System control block ACTLR
There is only one peripheral of type SCB_ACTLR. */
struct SCB_ACTLR_Type {
	__IO uint32_t ACTRL; // @0 Auxiliary control register
};
extern struct SCB_ACTLR_Type	SCB_ACTLR;	// @0xE000E008 

// SCB_ACTLR->ACTRL Auxiliary control register
enum {
	SCB_ACTLR_ACTRL_DISOOFP = 1UL<<9, // DISOOFP
	SCB_ACTLR_ACTRL_DISFPCA = 1UL<<8, // DISFPCA
	SCB_ACTLR_ACTRL_DISFOLD = 1UL<<2, // DISFOLD
	SCB_ACTLR_ACTRL_DISDEFWBUF = 1UL<<1, // DISDEFWBUF
	SCB_ACTLR_ACTRL_DISMCYCINT = 1UL<<0, // DISMCYCINT		
};

/* Serial peripheral interface/Inter-IC sound */
struct SPI_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	__IO uint32_t SR; // @8 status register
	__IO uint32_t DR; // @12 data register
	__IO uint32_t CRCPR; // @16 CRC polynomial register
	__I uint32_t RXCRCR; // @20 RX CRC register
	__I uint32_t TXCRCR; // @24 TX CRC register
	__IO uint32_t I2SCFGR; // @28 configuration register
	__IO uint32_t I2SPR; // @32 prescaler register
};
extern struct SPI_Type	SPI1;	// @0x40013000 
extern struct SPI_Type 	SPI2;	// @0x40003800
extern struct SPI_Type 	SPI3;	// @0x40003C00
extern struct SPI_Type 	SPI4;	// @0x40013C00

// SPI->CR1 control register 1
enum {
	SPI_CR1_BIDIMODE = 1UL<<15, // Bidirectional data mode enable
	SPI_CR1_BIDIOE = 1UL<<14, // Output enable in bidirectional mode
	SPI_CR1_CRCEN = 1UL<<13, // Hardware CRC calculation enable
	SPI_CR1_CRCNEXT = 1UL<<12, // CRC transfer next
	SPI_CR1_DFF = 1UL<<11, // Data frame format
	SPI_CR1_RXONLY = 1UL<<10, // Receive only
	SPI_CR1_SSM = 1UL<<9, // Software slave management
	SPI_CR1_SSI = 1UL<<8, // Internal slave select
	SPI_CR1_LSBFIRST = 1UL<<7, // Frame format
	SPI_CR1_SPE = 1UL<<6, // SPI enable
	SPI_CR1_BR = ((1UL<<3)-1) << 3, // Baud rate control
	SPI_CR1_MSTR = 1UL<<2, // Master selection
	SPI_CR1_CPOL = 1UL<<1, // Clock polarity
	SPI_CR1_CPHA = 1UL<<0, // Clock phase		
};
static inline void spi_cr1_set_br(struct SPI_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI_CR1_BR) | ((val<<3) & SPI_CR1_BR); }
static inline uint32_t spi_cr1_get_br(struct SPI_Type* p) { return (p->CR1 & SPI_CR1_BR) >> 3 ; }

// SPI->CR2 control register 2
enum {
	SPI_CR2_LDMA_TX = 1UL<<14, // Last DMA transfer for transmission
	SPI_CR2_LDMA_RX = 1UL<<13, // Last DMA transfer for reception
	SPI_CR2_FRXTH = 1UL<<12, // FIFO reception threshold
	SPI_CR2_DS = ((1UL<<4)-1) << 8, // Data size
	SPI_CR2_TXEIE = 1UL<<7, // Tx buffer empty interrupt enable
	SPI_CR2_RXNEIE = 1UL<<6, // RX buffer not empty interrupt enable
	SPI_CR2_ERRIE = 1UL<<5, // Error interrupt enable
	SPI_CR2_FRF = 1UL<<4, // Frame format
	SPI_CR2_NSSP = 1UL<<3, // NSS pulse management
	SPI_CR2_SSOE = 1UL<<2, // SS output enable
	SPI_CR2_TXDMAEN = 1UL<<1, // Tx buffer DMA enable
	SPI_CR2_RXDMAEN = 1UL<<0, // Rx buffer DMA enable		
};
static inline void spi_cr2_set_ds(struct SPI_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI_CR2_DS) | ((val<<8) & SPI_CR2_DS); }
static inline uint32_t spi_cr2_get_ds(struct SPI_Type* p) { return (p->CR2 & SPI_CR2_DS) >> 8 ; }

// SPI->SR status register
enum {
	SPI_SR_FTLVL = ((1UL<<2)-1) << 11, // FIFO transmission level
	SPI_SR_FRLVL = ((1UL<<2)-1) << 9, // FIFO reception level
	SPI_SR_TIFRFE = 1UL<<8, // TI frame format error
	SPI_SR_BSY = 1UL<<7, // Busy flag
	SPI_SR_OVR = 1UL<<6, // Overrun flag
	SPI_SR_MODF = 1UL<<5, // Mode fault
	SPI_SR_CRCERR = 1UL<<4, // CRC error flag
	SPI_SR_TXE = 1UL<<1, // Transmit buffer empty
	SPI_SR_RXNE = 1UL<<0, // Receive buffer not empty		
};
static inline void spi_sr_set_ftlvl(struct SPI_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI_SR_FTLVL) | ((val<<11) & SPI_SR_FTLVL); }
static inline void spi_sr_set_frlvl(struct SPI_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI_SR_FRLVL) | ((val<<9) & SPI_SR_FRLVL); }
static inline uint32_t spi_sr_get_ftlvl(struct SPI_Type* p) { return (p->SR & SPI_SR_FTLVL) >> 11 ; }
static inline uint32_t spi_sr_get_frlvl(struct SPI_Type* p) { return (p->SR & SPI_SR_FRLVL) >> 9 ; }

// SPI->DR data register
enum {
	SPI_DR_DR = ((1UL<<16)-1) << 0, // Data register		
};
static inline void spi_dr_set_dr(struct SPI_Type* p, uint32_t val) { p->DR = (p->DR & ~SPI_DR_DR) | ((val<<0) & SPI_DR_DR); }
static inline uint32_t spi_dr_get_dr(struct SPI_Type* p) { return (p->DR & SPI_DR_DR) >> 0 ; }

// SPI->CRCPR CRC polynomial register
enum {
	SPI_CRCPR_CRCPOLY = ((1UL<<16)-1) << 0, // CRC polynomial register		
};
static inline void spi_crcpr_set_crcpoly(struct SPI_Type* p, uint32_t val) { p->CRCPR = (p->CRCPR & ~SPI_CRCPR_CRCPOLY) | ((val<<0) & SPI_CRCPR_CRCPOLY); }
static inline uint32_t spi_crcpr_get_crcpoly(struct SPI_Type* p) { return (p->CRCPR & SPI_CRCPR_CRCPOLY) >> 0 ; }

// SPI->RXCRCR RX CRC register
enum {
	SPI_RXCRCR_RXCRC = ((1UL<<16)-1) << 0, // Rx CRC register		
};
static inline uint32_t spi_rxcrcr_get_rxcrc(struct SPI_Type* p) { return (p->RXCRCR & SPI_RXCRCR_RXCRC) >> 0 ; }

// SPI->TXCRCR TX CRC register
enum {
	SPI_TXCRCR_TXCRC = ((1UL<<16)-1) << 0, // Tx CRC register		
};
static inline uint32_t spi_txcrcr_get_txcrc(struct SPI_Type* p) { return (p->TXCRCR & SPI_TXCRCR_TXCRC) >> 0 ; }

// SPI->I2SCFGR configuration register
enum {
	SPI_I2SCFGR_I2SMOD = 1UL<<11, // I2SMOD
	SPI_I2SCFGR_I2SE = 1UL<<10, // I2SE
	SPI_I2SCFGR_I2SCFG = ((1UL<<2)-1) << 8, // I2SCFG
	SPI_I2SCFGR_PCMSYNC = 1UL<<7, // PCMSYNC
	SPI_I2SCFGR_I2SSTD = ((1UL<<2)-1) << 4, // I2SSTD
	SPI_I2SCFGR_CKPOL = 1UL<<3, // CKPOL
	SPI_I2SCFGR_DATLEN = ((1UL<<2)-1) << 1, // DATLEN
	SPI_I2SCFGR_CHLEN = 1UL<<0, // CHLEN		
};
static inline void spi_i2scfgr_set_i2scfg(struct SPI_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI_I2SCFGR_I2SCFG) | ((val<<8) & SPI_I2SCFGR_I2SCFG); }
static inline void spi_i2scfgr_set_i2sstd(struct SPI_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI_I2SCFGR_I2SSTD) | ((val<<4) & SPI_I2SCFGR_I2SSTD); }
static inline void spi_i2scfgr_set_datlen(struct SPI_Type* p, uint32_t val) { p->I2SCFGR = (p->I2SCFGR & ~SPI_I2SCFGR_DATLEN) | ((val<<1) & SPI_I2SCFGR_DATLEN); }
static inline uint32_t spi_i2scfgr_get_i2scfg(struct SPI_Type* p) { return (p->I2SCFGR & SPI_I2SCFGR_I2SCFG) >> 8 ; }
static inline uint32_t spi_i2scfgr_get_i2sstd(struct SPI_Type* p) { return (p->I2SCFGR & SPI_I2SCFGR_I2SSTD) >> 4 ; }
static inline uint32_t spi_i2scfgr_get_datlen(struct SPI_Type* p) { return (p->I2SCFGR & SPI_I2SCFGR_DATLEN) >> 1 ; }

// SPI->I2SPR prescaler register
enum {
	SPI_I2SPR_MCKOE = 1UL<<9, // MCKOE
	SPI_I2SPR_ODD = 1UL<<8, // ODD
	SPI_I2SPR_I2SDIV = ((1UL<<8)-1) << 0, // I2SDIV		
};
static inline void spi_i2spr_set_i2sdiv(struct SPI_Type* p, uint32_t val) { p->I2SPR = (p->I2SPR & ~SPI_I2SPR_I2SDIV) | ((val<<0) & SPI_I2SPR_I2SDIV); }
static inline uint32_t spi_i2spr_get_i2sdiv(struct SPI_Type* p) { return (p->I2SPR & SPI_I2SPR_I2SDIV) >> 0 ; }




/* SysTick timer
There is only one peripheral of type STK. */
struct STK_Type {
	__IO uint32_t CTRL; // @0 SysTick control and status register
	__IO uint32_t LOAD; // @4 SysTick reload value register
	__IO uint32_t VAL; // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};
extern struct STK_Type	STK;	// @0xE000E010 

// STK->CTRL SysTick control and status register
enum {
	STK_CTRL_COUNTFLAG = 1UL<<16, // COUNTFLAG
	STK_CTRL_CLKSOURCE = 1UL<<2, // Clock source selection
	STK_CTRL_TICKINT = 1UL<<1, // SysTick exception request enable
	STK_CTRL_ENABLE = 1UL<<0, // Counter enable		
};

// STK->LOAD SysTick reload value register
enum {
	STK_LOAD_RELOAD = ((1UL<<24)-1) << 0, // RELOAD value		
};
static inline void stk_load_set_reload(uint32_t val) { STK.LOAD = (STK.LOAD & ~STK_LOAD_RELOAD) | ((val<<0) & STK_LOAD_RELOAD); }
static inline uint32_t stk_load_get_reload(void) { return (STK.LOAD & STK_LOAD_RELOAD) >> 0 ; }

// STK->VAL SysTick current value register
enum {
	STK_VAL_CURRENT = ((1UL<<24)-1) << 0, // Current counter value		
};
static inline void stk_val_set_current(uint32_t val) { STK.VAL = (STK.VAL & ~STK_VAL_CURRENT) | ((val<<0) & STK_VAL_CURRENT); }
static inline uint32_t stk_val_get_current(void) { return (STK.VAL & STK_VAL_CURRENT) >> 0 ; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL<<31, // NOREF flag. Reads as zero
	STK_CALIB_SKEW = 1UL<<30, // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL<<24)-1) << 0, // Calibration value		
};
static inline void stk_calib_set_tenms(uint32_t val) { STK.CALIB = (STK.CALIB & ~STK_CALIB_TENMS) | ((val<<0) & STK_CALIB_TENMS); }
static inline uint32_t stk_calib_get_tenms(void) { return (STK.CALIB & STK_CALIB_TENMS) >> 0 ; }

/* System configuration controller
There is only one peripheral of type SYSCFG. */
struct SYSCFG_Type {
	__IO uint32_t MEMRMP; // @0 Remap Memory register
	__IO uint32_t CFGR1; // @4 peripheral mode configuration register
	__IO uint32_t EXTICR1; // @8 external interrupt configuration register 1
	__IO uint32_t EXTICR2; // @12 external interrupt configuration register 2
	__IO uint32_t EXTICR3; // @16 external interrupt configuration register 3
	__IO uint32_t EXTICR4; // @20 external interrupt configuration register 4
	__IO uint32_t SCSR; // @24 CCM SRAM control and status register
	__IO uint32_t CFGR2; // @28 configuration register 2
	__IO uint32_t SWPR; // @32 SRAM Write protection register 1
	__O uint32_t SKR; // @36 SRAM2 Key Register
};
extern struct SYSCFG_Type	SYSCFG;	// @0x40010000 

// SYSCFG->MEMRMP Remap Memory register
enum {
	SYSCFG_MEMRMP_FB_MODE = 1UL<<8, // User Flash Bank mode
	SYSCFG_MEMRMP_MEM_MODE = ((1UL<<3)-1) << 0, // Memory mapping selection		
};
static inline void syscfg_memrmp_set_mem_mode(uint32_t val) { SYSCFG.MEMRMP = (SYSCFG.MEMRMP & ~SYSCFG_MEMRMP_MEM_MODE) | ((val<<0) & SYSCFG_MEMRMP_MEM_MODE); }
static inline uint32_t syscfg_memrmp_get_mem_mode(void) { return (SYSCFG.MEMRMP & SYSCFG_MEMRMP_MEM_MODE) >> 0 ; }

// SYSCFG->CFGR1 peripheral mode configuration register
enum {
	SYSCFG_CFGR1_FPU_IE = ((1UL<<6)-1) << 26, // FPU Interrupts Enable
	SYSCFG_CFGR1_I2C4_FMP = 1UL<<23, // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C3_FMP = 1UL<<22, // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C2_FMP = 1UL<<21, // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C1_FMP = 1UL<<20, // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C_PB9_FMP = 1UL<<19, // FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB8_FMP = 1UL<<18, // FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB7_FMP = 1UL<<17, // FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB6_FMP = 1UL<<16, // FM+ drive capability on PB6
	SYSCFG_CFGR1_ANASWVDD = 1UL<<9, // GPIO analog switch control voltage selection
	SYSCFG_CFGR1_BOOSTEN = 1UL<<8, // BOOSTEN		
};
static inline void syscfg_cfgr1_set_fpu_ie(uint32_t val) { SYSCFG.CFGR1 = (SYSCFG.CFGR1 & ~SYSCFG_CFGR1_FPU_IE) | ((val<<26) & SYSCFG_CFGR1_FPU_IE); }
static inline uint32_t syscfg_cfgr1_get_fpu_ie(void) { return (SYSCFG.CFGR1 & SYSCFG_CFGR1_FPU_IE) >> 26 ; }

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI2 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI1 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI0 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 0 to 3)		
};
static inline void syscfg_exticr1_set_exti3(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val<<12) & SYSCFG_EXTICR1_EXTI3); }
static inline void syscfg_exticr1_set_exti2(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val<<8) & SYSCFG_EXTICR1_EXTI2); }
static inline void syscfg_exticr1_set_exti1(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val<<4) & SYSCFG_EXTICR1_EXTI1); }
static inline void syscfg_exticr1_set_exti0(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val<<0) & SYSCFG_EXTICR1_EXTI0); }
static inline uint32_t syscfg_exticr1_get_exti3(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12 ; }
static inline uint32_t syscfg_exticr1_get_exti2(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8 ; }
static inline uint32_t syscfg_exticr1_get_exti1(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4 ; }
static inline uint32_t syscfg_exticr1_get_exti0(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0 ; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI6 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI5 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI4 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 4 to 7)		
};
static inline void syscfg_exticr2_set_exti7(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val<<12) & SYSCFG_EXTICR2_EXTI7); }
static inline void syscfg_exticr2_set_exti6(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val<<8) & SYSCFG_EXTICR2_EXTI6); }
static inline void syscfg_exticr2_set_exti5(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val<<4) & SYSCFG_EXTICR2_EXTI5); }
static inline void syscfg_exticr2_set_exti4(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val<<0) & SYSCFG_EXTICR2_EXTI4); }
static inline uint32_t syscfg_exticr2_get_exti7(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12 ; }
static inline uint32_t syscfg_exticr2_get_exti6(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8 ; }
static inline uint32_t syscfg_exticr2_get_exti5(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4 ; }
static inline uint32_t syscfg_exticr2_get_exti4(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0 ; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI10 = ((1UL<<4)-1) << 8, // EXTI10
	SYSCFG_EXTICR3_EXTI9 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI8 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 8 to 11)		
};
static inline void syscfg_exticr3_set_exti11(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val<<12) & SYSCFG_EXTICR3_EXTI11); }
static inline void syscfg_exticr3_set_exti10(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val<<8) & SYSCFG_EXTICR3_EXTI10); }
static inline void syscfg_exticr3_set_exti9(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val<<4) & SYSCFG_EXTICR3_EXTI9); }
static inline void syscfg_exticr3_set_exti8(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val<<0) & SYSCFG_EXTICR3_EXTI8); }
static inline uint32_t syscfg_exticr3_get_exti11(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12 ; }
static inline uint32_t syscfg_exticr3_get_exti10(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8 ; }
static inline uint32_t syscfg_exticr3_get_exti9(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4 ; }
static inline uint32_t syscfg_exticr3_get_exti8(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0 ; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL<<4)-1) << 12, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI14 = ((1UL<<4)-1) << 8, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI13 = ((1UL<<4)-1) << 4, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI12 = ((1UL<<4)-1) << 0, // EXTI x configuration (x = 12 to 15)		
};
static inline void syscfg_exticr4_set_exti15(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val<<12) & SYSCFG_EXTICR4_EXTI15); }
static inline void syscfg_exticr4_set_exti14(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val<<8) & SYSCFG_EXTICR4_EXTI14); }
static inline void syscfg_exticr4_set_exti13(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val<<4) & SYSCFG_EXTICR4_EXTI13); }
static inline void syscfg_exticr4_set_exti12(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val<<0) & SYSCFG_EXTICR4_EXTI12); }
static inline uint32_t syscfg_exticr4_get_exti15(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12 ; }
static inline uint32_t syscfg_exticr4_get_exti14(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8 ; }
static inline uint32_t syscfg_exticr4_get_exti13(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4 ; }
static inline uint32_t syscfg_exticr4_get_exti12(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0 ; }

// SYSCFG->SCSR CCM SRAM control and status register
enum {
	SYSCFG_SCSR_CCMBSY = 1UL<<1, // CCM SRAM busy by erase operation
	SYSCFG_SCSR_CCMER = 1UL<<0, // CCM SRAM Erase		
};

// SYSCFG->CFGR2 configuration register 2
enum {
	SYSCFG_CFGR2_SPF = 1UL<<8, // SRAM Parity Flag
	SYSCFG_CFGR2_ECCL = 1UL<<3, // ECC Lock
	SYSCFG_CFGR2_PVDL = 1UL<<2, // PVD Lock
	SYSCFG_CFGR2_SPL = 1UL<<1, // SRAM Parity Lock
	SYSCFG_CFGR2_CLL = 1UL<<0, // Core Lockup Lock		
};

// SYSCFG->SKR SRAM2 Key Register
enum {
	SYSCFG_SKR_KEY = ((1UL<<8)-1) << 0, // SRAM2 Key for software erase		
};
static inline void syscfg_skr_set_key(uint32_t val) { SYSCFG.SKR = (SYSCFG.SKR & ~SYSCFG_SKR_KEY) | ((val<<0) & SYSCFG_SKR_KEY); }
static inline uint32_t syscfg_skr_get_key(void) { return (SYSCFG.SKR & SYSCFG_SKR_KEY) >> 0 ; }

/* Advanced-timers */
struct TIM1_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint32_t DIER; // @12 DMA/Interrupt enable register
	__IO uint32_t SR; // @16 status register
	__O uint32_t EGR; // @20 event generation register
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint32_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	union {  // @28
		__IO uint32_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint32_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	__IO uint32_t CCER; // @32 capture/compare enable register
	__IO uint32_t CNT; // @36 counter
	__IO uint32_t PSC; // @40 prescaler
	__IO uint32_t ARR; // @44 auto-reload register
	__IO uint32_t RCR; // @48 repetition counter register
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint32_t CCR5; // @72 capture/compare register 4
	__IO uint32_t CCR6; // @76 capture/compare register 4
	__IO uint32_t CCMR3_Output; // @80 capture/compare mode register 2 (output mode)
	__IO uint32_t DTR2; // @84 timer Deadtime Register 2
	__IO uint32_t ECR; // @88 DMA control register
	__IO uint32_t TISEL; // @92 TIM timer input selection register
	__IO uint32_t AF1; // @96 TIM alternate function option register 1
	__IO uint32_t AF2; // @100 TIM alternate function option register 2
	 uint8_t RESERVED0[884]; // @104 
	__IO uint32_t DCR; // @988 control register
	__IO uint32_t DMAR; // @992 DMA address for full transfer
};
extern struct TIM1_Type	TIM1;	// @0x40012C00 Also: TIM6_Type
extern struct TIM1_Type 	TIM2;	// @0x40000000
extern struct TIM1_Type 	TIM20;	// @0x40015000
extern struct TIM1_Type 	TIM3;	// @0x40000400
extern struct TIM1_Type 	TIM4;	// @0x40000800
extern struct TIM1_Type 	TIM5;	// @0x40000C00
extern struct TIM1_Type 	TIM8;	// @0x40013400

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_DITHEN = 1UL<<12, // Dithering Enable
	TIM1_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM1_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM1_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR = 1UL<<4, // Direction
	TIM1_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM1_CR1_URS = 1UL<<2, // Update request source
	TIM1_CR1_UDIS = 1UL<<1, // Update disable
	TIM1_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val<<8) & TIM1_CR1_CKD); }
static inline void tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val<<5) & TIM1_CR1_CMS); }
static inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8 ; }
static inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5 ; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_MMS_3 = 1UL<<25, // Master mode selection - bit 3
	TIM1_CR2_MMS2 = ((1UL<<4)-1) << 20, // Master mode selection 2
	TIM1_CR2_OIS6 = 1UL<<18, // Output Idle state 6 (OC6 output)
	TIM1_CR2_OIS5 = 1UL<<16, // Output Idle state 5 (OC5 output)
	TIM1_CR2_OIS4N = 1UL<<15, // Output Idle state 4 (OC4N output)
	TIM1_CR2_OIS4 = 1UL<<14, // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL<<13, // Output Idle state 3
	TIM1_CR2_OIS3 = 1UL<<12, // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL<<11, // Output Idle state 2
	TIM1_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM1_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM1_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM1_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM1_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM1_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM1_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
static inline void tim1_cr2_set_mms2(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS2) | ((val<<20) & TIM1_CR2_MMS2); }
static inline void tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val<<4) & TIM1_CR2_MMS); }
static inline uint32_t tim1_cr2_get_mms2(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS2) >> 20 ; }
static inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4 ; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_SMSPS = 1UL<<25, // SMS Preload Source
	TIM1_SMCR_SMSPE = 1UL<<24, // SMS Preload Enable
	TIM1_SMCR_TS_4_3 = ((1UL<<2)-1) << 20, // Trigger selection - bit 4:3
	TIM1_SMCR_SMS_3 = 1UL<<16, // Slave mode selection - bit 3
	TIM1_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM1_SMCR_ECE = 1UL<<14, // External clock enable
	TIM1_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM1_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM1_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM1_SMCR_OCCS = 1UL<<3, // OCREF clear selection
	TIM1_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
static inline void tim1_smcr_set_ts_4_3(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS_4_3) | ((val<<20) & TIM1_SMCR_TS_4_3); }
static inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val<<12) & TIM1_SMCR_ETPS); }
static inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val<<8) & TIM1_SMCR_ETF); }
static inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val<<4) & TIM1_SMCR_TS); }
static inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val<<0) & TIM1_SMCR_SMS); }
static inline uint32_t tim1_smcr_get_ts_4_3(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS_4_3) >> 20 ; }
static inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12 ; }
static inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8 ; }
static inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 4 ; }
static inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0 ; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TERRIE = 1UL<<23, // Transition Error interrupt enable
	TIM1_DIER_IERRIE = 1UL<<22, // Index Error interrupt enable
	TIM1_DIER_DIRIE = 1UL<<21, // Direction Change interrupt enable
	TIM1_DIER_IDXIE = 1UL<<20, // Index interrupt enable
	TIM1_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM1_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM1_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM1->SR status register
enum {
	TIM1_SR_TERRF = 1UL<<23, // Transition Error interrupt flag
	TIM1_SR_IERRF = 1UL<<22, // Index Error interrupt flag
	TIM1_SR_DIRF = 1UL<<21, // Direction Change interrupt flag
	TIM1_SR_IDXF = 1UL<<20, // Index interrupt flag
	TIM1_SR_CC6IF = 1UL<<17, // Compare 6 interrupt flag
	TIM1_SR_CC5IF = 1UL<<16, // Compare 5 interrupt flag
	TIM1_SR_SBIF = 1UL<<13, // System Break interrupt flag
	TIM1_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM1_SR_B2IF = 1UL<<8, // Break 2 interrupt flag
	TIM1_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM1_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM1_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM1_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_B2G = 1UL<<8, // Break 2 generation
	TIM1_EGR_BG = 1UL<<7, // Break generation
	TIM1_EGR_TG = 1UL<<6, // Trigger generation
	TIM1_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM1_EGR_UG = 1UL<<0, // Update generation		
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM1_CCMR1_OUTPUT_OC2M); }
static inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM1_CCMR1_OUTPUT_CC2S); }
static inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM1_CCMR1_OUTPUT_OC1M); }
static inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM1_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12 ; }
static inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8 ; }
static inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4M_3 = 1UL<<24, // Output Compare 4 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC3M_3 = 1UL<<16, // Output Compare 3 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
static inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM1_CCMR2_OUTPUT_OC4M); }
static inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM1_CCMR2_OUTPUT_CC4S); }
static inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM1_CCMR2_OUTPUT_OC3M); }
static inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM1_CCMR2_OUTPUT_CC3S); }
static inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12 ; }
static inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8 ; }
static inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4 ; }
static inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC6P = 1UL<<21, // Capture/Compare 6 output polarity
	TIM1_CCER_CC6E = 1UL<<20, // Capture/Compare 6 output enable
	TIM1_CCER_CC5P = 1UL<<17, // Capture/Compare 5 output polarity
	TIM1_CCER_CC5E = 1UL<<16, // Capture/Compare 5 output enable
	TIM1_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 complementary output polarity
	TIM1_CCER_CC4NE = 1UL<<14, // Capture/Compare 4 complementary output enable
	TIM1_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL<<10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL<<6, // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM1->CNT counter
enum {
	TIM1_CNT_UIFCPY = 1UL<<31, // UIFCPY
	TIM1_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
static inline void tim1_cnt_set_cnt(struct TIM1_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM1_CNT_CNT) | ((val<<0) & TIM1_CNT_CNT); }
static inline uint32_t tim1_cnt_get_cnt(struct TIM1_Type* p) { return (p->CNT & TIM1_CNT_CNT) >> 0 ; }

// TIM1->PSC prescaler
enum {
	TIM1_PSC_PSC = ((1UL<<16)-1) << 0, // Prescaler value		
};
static inline void tim1_psc_set_psc(struct TIM1_Type* p, uint32_t val) { p->PSC = (p->PSC & ~TIM1_PSC_PSC) | ((val<<0) & TIM1_PSC_PSC); }
static inline uint32_t tim1_psc_get_psc(struct TIM1_Type* p) { return (p->PSC & TIM1_PSC_PSC) >> 0 ; }

// TIM1->ARR auto-reload register
enum {
	TIM1_ARR_ARR = ((1UL<<16)-1) << 0, // Auto-reload value		
};
static inline void tim1_arr_set_arr(struct TIM1_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM1_ARR_ARR) | ((val<<0) & TIM1_ARR_ARR); }
static inline uint32_t tim1_arr_get_arr(struct TIM1_Type* p) { return (p->ARR & TIM1_ARR_ARR) >> 0 ; }

// TIM1->RCR repetition counter register
enum {
	TIM1_RCR_REP = ((1UL<<16)-1) << 0, // Repetition counter value		
};
static inline void tim1_rcr_set_rep(struct TIM1_Type* p, uint32_t val) { p->RCR = (p->RCR & ~TIM1_RCR_REP) | ((val<<0) & TIM1_RCR_REP); }
static inline uint32_t tim1_rcr_get_rep(struct TIM1_Type* p) { return (p->RCR & TIM1_RCR_REP) >> 0 ; }

// TIM1->CCR1 capture/compare register 1
enum {
	TIM1_CCR1_CCR1 = ((1UL<<16)-1) << 0, // Capture/Compare 1 value		
};
static inline void tim1_ccr1_set_ccr1(struct TIM1_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM1_CCR1_CCR1) | ((val<<0) & TIM1_CCR1_CCR1); }
static inline uint32_t tim1_ccr1_get_ccr1(struct TIM1_Type* p) { return (p->CCR1 & TIM1_CCR1_CCR1) >> 0 ; }

// TIM1->CCR2 capture/compare register 2
enum {
	TIM1_CCR2_CCR2 = ((1UL<<16)-1) << 0, // Capture/Compare 2 value		
};
static inline void tim1_ccr2_set_ccr2(struct TIM1_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM1_CCR2_CCR2) | ((val<<0) & TIM1_CCR2_CCR2); }
static inline uint32_t tim1_ccr2_get_ccr2(struct TIM1_Type* p) { return (p->CCR2 & TIM1_CCR2_CCR2) >> 0 ; }

// TIM1->CCR3 capture/compare register 3
enum {
	TIM1_CCR3_CCR3 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
static inline void tim1_ccr3_set_ccr3(struct TIM1_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM1_CCR3_CCR3) | ((val<<0) & TIM1_CCR3_CCR3); }
static inline uint32_t tim1_ccr3_get_ccr3(struct TIM1_Type* p) { return (p->CCR3 & TIM1_CCR3_CCR3) >> 0 ; }

// TIM1->CCR4 capture/compare register 4
enum {
	TIM1_CCR4_CCR4 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
static inline void tim1_ccr4_set_ccr4(struct TIM1_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM1_CCR4_CCR4) | ((val<<0) & TIM1_CCR4_CCR4); }
static inline uint32_t tim1_ccr4_get_ccr4(struct TIM1_Type* p) { return (p->CCR4 & TIM1_CCR4_CCR4) >> 0 ; }

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_BK2ID = 1UL<<29, // BK2ID
	TIM1_BDTR_BKBID = 1UL<<28, // BKBID
	TIM1_BDTR_BK2DSRM = 1UL<<27, // BK2DSRM
	TIM1_BDTR_BKDSRM = 1UL<<26, // BKDSRM
	TIM1_BDTR_BK2P = 1UL<<25, // Break 2 polarity
	TIM1_BDTR_BK2E = 1UL<<24, // Break 2 Enable
	TIM1_BDTR_BK2F = ((1UL<<4)-1) << 20, // Break 2 filter
	TIM1_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM1_BDTR_MOE = 1UL<<15, // Main output enable
	TIM1_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM1_BDTR_BKP = 1UL<<13, // Break polarity
	TIM1_BDTR_BKE = 1UL<<12, // Break enable
	TIM1_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM1_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim1_bdtr_set_bk2f(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BK2F) | ((val<<20) & TIM1_BDTR_BK2F); }
static inline void tim1_bdtr_set_bkf(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BKF) | ((val<<16) & TIM1_BDTR_BKF); }
static inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val<<8) & TIM1_BDTR_LOCK); }
static inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val<<0) & TIM1_BDTR_DTG); }
static inline uint32_t tim1_bdtr_get_bk2f(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BK2F) >> 20 ; }
static inline uint32_t tim1_bdtr_get_bkf(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BKF) >> 16 ; }
static inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8 ; }
static inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0 ; }

// TIM1->CCR5 capture/compare register 4
enum {
	TIM1_CCR5_GC5C3 = 1UL<<31, // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL<<30, // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL<<29, // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
static inline void tim1_ccr5_set_ccr5(struct TIM1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val<<0) & TIM1_CCR5_CCR5); }
static inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type* p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0 ; }

// TIM1->CCR6 capture/compare register 4
enum {
	TIM1_CCR6_CCR6 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
static inline void tim1_ccr6_set_ccr6(struct TIM1_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~TIM1_CCR6_CCR6) | ((val<<0) & TIM1_CCR6_CCR6); }
static inline uint32_t tim1_ccr6_get_ccr6(struct TIM1_Type* p) { return (p->CCR6 & TIM1_CCR6_CCR6) >> 0 ; }

// TIM1->CCMR3_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M_BIT3 = 1UL<<24, // Output Compare 6 mode bit 3
	TIM1_CCMR3_OUTPUT_OC5M_BIT3 = ((1UL<<3)-1) << 16, // Output Compare 5 mode bit 3
	TIM1_CCMR3_OUTPUT_OC6CE = 1UL<<15, // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M = ((1UL<<3)-1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE = 1UL<<11, // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE = 1UL<<10, // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE = 1UL<<7, // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M = ((1UL<<3)-1) << 4, // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE = 1UL<<3, // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE = 1UL<<2, // Output compare 5 fast enable		
};
static inline void tim1_ccmr3_output_set_oc5m_bit3(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M_BIT3) | ((val<<16) & TIM1_CCMR3_OUTPUT_OC5M_BIT3); }
static inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val<<12) & TIM1_CCMR3_OUTPUT_OC6M); }
static inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val<<4) & TIM1_CCMR3_OUTPUT_OC5M); }
static inline uint32_t tim1_ccmr3_output_get_oc5m_bit3(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M_BIT3) >> 16 ; }
static inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12 ; }
static inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4 ; }

// TIM1->DTR2 timer Deadtime Register 2
enum {
	TIM1_DTR2_DTPE = 1UL<<17, // Deadtime Preload Enable
	TIM1_DTR2_DTAE = 1UL<<16, // Deadtime Asymmetric Enable
	TIM1_DTR2_DTGF = ((1UL<<8)-1) << 0, // Dead-time falling edge generator setup		
};
static inline void tim1_dtr2_set_dtgf(struct TIM1_Type* p, uint32_t val) { p->DTR2 = (p->DTR2 & ~TIM1_DTR2_DTGF) | ((val<<0) & TIM1_DTR2_DTGF); }
static inline uint32_t tim1_dtr2_get_dtgf(struct TIM1_Type* p) { return (p->DTR2 & TIM1_DTR2_DTGF) >> 0 ; }

// TIM1->ECR DMA control register
enum {
	TIM1_ECR_PWPRSC = ((1UL<<3)-1) << 24, // Pulse Width prescaler
	TIM1_ECR_PW = ((1UL<<8)-1) << 16, // Pulse width
	TIM1_ECR_IPOS = ((1UL<<2)-1) << 6, // Index Positioning
	TIM1_ECR_FIDX = 1UL<<5, // First Index
	TIM1_ECR_IBLK = ((1UL<<2)-1) << 3, // Index Blanking
	TIM1_ECR_IDIR = ((1UL<<2)-1) << 1, // Index Direction
	TIM1_ECR_IE = 1UL<<0, // Index Enable		
};
static inline void tim1_ecr_set_pwprsc(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_PWPRSC) | ((val<<24) & TIM1_ECR_PWPRSC); }
static inline void tim1_ecr_set_pw(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_PW) | ((val<<16) & TIM1_ECR_PW); }
static inline void tim1_ecr_set_ipos(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_IPOS) | ((val<<6) & TIM1_ECR_IPOS); }
static inline void tim1_ecr_set_iblk(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_IBLK) | ((val<<3) & TIM1_ECR_IBLK); }
static inline void tim1_ecr_set_idir(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_IDIR) | ((val<<1) & TIM1_ECR_IDIR); }
static inline uint32_t tim1_ecr_get_pwprsc(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_PWPRSC) >> 24 ; }
static inline uint32_t tim1_ecr_get_pw(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_PW) >> 16 ; }
static inline uint32_t tim1_ecr_get_ipos(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_IPOS) >> 6 ; }
static inline uint32_t tim1_ecr_get_iblk(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_IBLK) >> 3 ; }
static inline uint32_t tim1_ecr_get_idir(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_IDIR) >> 1 ; }

// TIM1->TISEL TIM timer input selection register
enum {
	TIM1_TISEL_TI4SEL = ((1UL<<4)-1) << 24, // TI4[0] to TI4[15] input selection
	TIM1_TISEL_TI3SEL = ((1UL<<4)-1) << 16, // TI3[0] to TI3[15] input selection
	TIM1_TISEL_TI2SEL = ((1UL<<4)-1) << 8, // TI2[0] to TI2[15] input selection
	TIM1_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // TI1[0] to TI1[15] input selection		
};
static inline void tim1_tisel_set_ti4sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI4SEL) | ((val<<24) & TIM1_TISEL_TI4SEL); }
static inline void tim1_tisel_set_ti3sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI3SEL) | ((val<<16) & TIM1_TISEL_TI3SEL); }
static inline void tim1_tisel_set_ti2sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI2SEL) | ((val<<8) & TIM1_TISEL_TI2SEL); }
static inline void tim1_tisel_set_ti1sel(struct TIM1_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM1_TISEL_TI1SEL) | ((val<<0) & TIM1_TISEL_TI1SEL); }
static inline uint32_t tim1_tisel_get_ti4sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI4SEL) >> 24 ; }
static inline uint32_t tim1_tisel_get_ti3sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI3SEL) >> 16 ; }
static inline uint32_t tim1_tisel_get_ti2sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI2SEL) >> 8 ; }
static inline uint32_t tim1_tisel_get_ti1sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI1SEL) >> 0 ; }

// TIM1->AF1 TIM alternate function option register 1
enum {
	TIM1_AF1_ETRSEL = ((1UL<<4)-1) << 14, // ETR source selection
	TIM1_AF1_BKCMP4P = 1UL<<13, // BRK COMP4 input polarity
	TIM1_AF1_BKCMP3P = 1UL<<12, // BRK COMP3 input polarity
	TIM1_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM1_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM1_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM1_AF1_BKCMP7E = 1UL<<7, // BRK COMP7 enable
	TIM1_AF1_BKCMP6E = 1UL<<6, // BRK COMP6 enable
	TIM1_AF1_BKCMP5E = 1UL<<5, // BRK COMP5 enable
	TIM1_AF1_BKCMP4E = 1UL<<4, // BRK COMP4 enable
	TIM1_AF1_BKCMP3E = 1UL<<3, // BRK COMP3 enable
	TIM1_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM1_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM1_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};
static inline void tim1_af1_set_etrsel(struct TIM1_Type* p, uint32_t val) { p->AF1 = (p->AF1 & ~TIM1_AF1_ETRSEL) | ((val<<14) & TIM1_AF1_ETRSEL); }
static inline uint32_t tim1_af1_get_etrsel(struct TIM1_Type* p) { return (p->AF1 & TIM1_AF1_ETRSEL) >> 14 ; }

// TIM1->AF2 TIM alternate function option register 2
enum {
	TIM1_AF2_OCRSEL = ((1UL<<3)-1) << 16, // OCREF_CLR source selection
	TIM1_AF2_BK2CMP4P = 1UL<<13, // BRK2 COMP4 input polarity
	TIM1_AF2_BK2CMP3P = 1UL<<12, // BRK2 COMP3 input polarity
	TIM1_AF2_BK2CMP2P = 1UL<<11, // BRK2 COMP2 input polarity
	TIM1_AF2_BK2CMP1P = 1UL<<10, // BRK2 COMP1 input polarity
	TIM1_AF2_BK2INP = 1UL<<9, // BRK2 BKIN input polarity
	TIM1_AF2_BK2CMP7E = 1UL<<7, // BRK2 COMP7 enable
	TIM1_AF2_BK2CMP6E = 1UL<<6, // BRK2 COMP6 enable
	TIM1_AF2_BK2CMP5E = 1UL<<5, // BRK2 COMP5 enable
	TIM1_AF2_BK2CMP4E = 1UL<<4, // BRK2 COMP4 enable
	TIM1_AF2_BK2CMP3E = 1UL<<3, // BRK2 COMP3 enable
	TIM1_AF2_BK2CMP2E = 1UL<<2, // BRK2 COMP2 enable
	TIM1_AF2_BK2CMP1E = 1UL<<1, // BRK2 COMP1 enable
	TIM1_AF2_BKINE = 1UL<<0, // BRK BKIN input enable		
};
static inline void tim1_af2_set_ocrsel(struct TIM1_Type* p, uint32_t val) { p->AF2 = (p->AF2 & ~TIM1_AF2_OCRSEL) | ((val<<16) & TIM1_AF2_OCRSEL); }
static inline uint32_t tim1_af2_get_ocrsel(struct TIM1_Type* p) { return (p->AF2 & TIM1_AF2_OCRSEL) >> 16 ; }

// TIM1->DCR control register
enum {
	TIM1_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val<<8) & TIM1_DCR_DBL); }
static inline void tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val<<0) & TIM1_DCR_DBA); }
static inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8 ; }
static inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0 ; }

// Valid Casts:
 
static inline struct TIM6_Type* TIM1_as_TIM6_Type(struct TIM1_Type* p) { return (struct TIM6_Type*)p; }


/* General purpose timers
There is only one peripheral of type TIM15. */
struct TIM15_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	__IO uint32_t SMCR; // @8 slave mode control register
	__IO uint32_t DIER; // @12 DMA/Interrupt enable register
	__IO uint32_t SR; // @16 status register
	__O uint32_t EGR; // @20 event generation register
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint32_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED0[4]; // @28 
	__IO uint32_t CCER; // @32 capture/compare enable register
	__IO uint32_t CNT; // @36 counter
	__IO uint32_t PSC; // @40 prescaler
	__IO uint32_t ARR; // @44 auto-reload register
	__IO uint32_t RCR; // @48 repetition counter register
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED1[8]; // @60 
	__IO uint32_t BDTR; // @68 break and dead-time register
	 uint8_t RESERVED2[12]; // @72 
	__IO uint32_t DTR2; // @84 timer Deadtime Register 2
	 uint8_t RESERVED3[4]; // @88 
	__IO uint32_t TISEL; // @92 TIM timer input selection register
	__IO uint32_t AF1; // @96 TIM alternate function option register 1
	__IO uint32_t AF2; // @100 TIM alternate function option register 2
	 uint8_t RESERVED4[884]; // @104 
	__IO uint32_t DCR; // @988 DMA control register
	__IO uint32_t DMAR; // @992 DMA address for full transfer
};
extern struct TIM15_Type	TIM15;	// @0x40014000 Also: TIM6_Type

// TIM15->CR1 control register 1
enum {
	TIM15_CR1_DITHEN = 1UL<<12, // Dithering Enable
	TIM15_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM15_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM15_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM15_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM15_CR1_URS = 1UL<<2, // Update request source
	TIM15_CR1_UDIS = 1UL<<1, // Update disable
	TIM15_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim15_cr1_set_ckd(uint32_t val) { TIM15.CR1 = (TIM15.CR1 & ~TIM15_CR1_CKD) | ((val<<8) & TIM15_CR1_CKD); }
static inline uint32_t tim15_cr1_get_ckd(void) { return (TIM15.CR1 & TIM15_CR1_CKD) >> 8 ; }

// TIM15->CR2 control register 2
enum {
	TIM15_CR2_OIS2 = 1UL<<10, // Output idle state 2 (OC2 output)
	TIM15_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM15_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM15_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM15_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM15_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM15_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM15_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
static inline void tim15_cr2_set_mms(uint32_t val) { TIM15.CR2 = (TIM15.CR2 & ~TIM15_CR2_MMS) | ((val<<4) & TIM15_CR2_MMS); }
static inline uint32_t tim15_cr2_get_mms(void) { return (TIM15.CR2 & TIM15_CR2_MMS) >> 4 ; }

// TIM15->SMCR slave mode control register
enum {
	TIM15_SMCR_TS_4_3 = ((1UL<<2)-1) << 20, // Trigger selection - bit 4:3
	TIM15_SMCR_SMS_3 = 1UL<<16, // Slave mode selection - bit 3
	TIM15_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM15_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM15_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
static inline void tim15_smcr_set_ts_4_3(uint32_t val) { TIM15.SMCR = (TIM15.SMCR & ~TIM15_SMCR_TS_4_3) | ((val<<20) & TIM15_SMCR_TS_4_3); }
static inline void tim15_smcr_set_ts(uint32_t val) { TIM15.SMCR = (TIM15.SMCR & ~TIM15_SMCR_TS) | ((val<<4) & TIM15_SMCR_TS); }
static inline void tim15_smcr_set_sms(uint32_t val) { TIM15.SMCR = (TIM15.SMCR & ~TIM15_SMCR_SMS) | ((val<<0) & TIM15_SMCR_SMS); }
static inline uint32_t tim15_smcr_get_ts_4_3(void) { return (TIM15.SMCR & TIM15_SMCR_TS_4_3) >> 20 ; }
static inline uint32_t tim15_smcr_get_ts(void) { return (TIM15.SMCR & TIM15_SMCR_TS) >> 4 ; }
static inline uint32_t tim15_smcr_get_sms(void) { return (TIM15.SMCR & TIM15_SMCR_SMS) >> 0 ; }

// TIM15->DIER DMA/Interrupt enable register
enum {
	TIM15_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM15_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM15_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM15_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM15_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM15_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM15_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM15_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM15_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM15_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM15_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM15->SR status register
enum {
	TIM15_SR_CC2OF = 1UL<<10, // Capture/Compare 2 overcapture flag
	TIM15_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM15_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM15_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM15_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM15_SR_CC2IF = 1UL<<2, // Capture/compare 2 interrupt flag
	TIM15_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM15_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM15->EGR event generation register
enum {
	TIM15_EGR_BG = 1UL<<7, // Break generation
	TIM15_EGR_TG = 1UL<<6, // Trigger generation
	TIM15_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM15_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM15_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM15_EGR_UG = 1UL<<0, // Update generation		
};

// TIM15->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM15_CCMR1_OUTPUT_OC2M_3 = 1UL<<24, // Output Compare 2 mode - bit 3
	TIM15_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // OC2M
	TIM15_CCMR1_OUTPUT_OC2PE = 1UL<<11, // OC2PE
	TIM15_CCMR1_OUTPUT_OC2FE = 1UL<<10, // OC2FE
	TIM15_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // CC2S
	TIM15_CCMR1_OUTPUT_OC1CE = 1UL<<7, // OC1CE
	TIM15_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM15_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM15_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim15_ccmr1_output_set_oc2m(uint32_t val) { TIM15.CCMR1_Output = (TIM15.CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM15_CCMR1_OUTPUT_OC2M); }
static inline void tim15_ccmr1_output_set_cc2s(uint32_t val) { TIM15.CCMR1_Output = (TIM15.CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM15_CCMR1_OUTPUT_CC2S); }
static inline void tim15_ccmr1_output_set_oc1m(uint32_t val) { TIM15.CCMR1_Output = (TIM15.CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM15_CCMR1_OUTPUT_OC1M); }
static inline void tim15_ccmr1_output_set_cc1s(uint32_t val) { TIM15.CCMR1_Output = (TIM15.CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM15_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim15_ccmr1_output_get_oc2m(void) { return (TIM15.CCMR1_Output & TIM15_CCMR1_OUTPUT_OC2M) >> 12 ; }
static inline uint32_t tim15_ccmr1_output_get_cc2s(void) { return (TIM15.CCMR1_Output & TIM15_CCMR1_OUTPUT_CC2S) >> 8 ; }
static inline uint32_t tim15_ccmr1_output_get_oc1m(void) { return (TIM15.CCMR1_Output & TIM15_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim15_ccmr1_output_get_cc1s(void) { return (TIM15.CCMR1_Output & TIM15_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM15->CCER capture/compare enable register
enum {
	TIM15_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 complementary output polarity
	TIM15_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output polarity
	TIM15_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM15_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM15_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM15->CNT counter
enum {
	TIM15_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM15_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
static inline void tim15_cnt_set_cnt(uint32_t val) { TIM15.CNT = (TIM15.CNT & ~TIM15_CNT_CNT) | ((val<<0) & TIM15_CNT_CNT); }
static inline uint32_t tim15_cnt_get_cnt(void) { return (TIM15.CNT & TIM15_CNT_CNT) >> 0 ; }

// TIM15->PSC prescaler
enum {
	TIM15_PSC_PSC = ((1UL<<16)-1) << 0, // Prescaler value		
};
static inline void tim15_psc_set_psc(uint32_t val) { TIM15.PSC = (TIM15.PSC & ~TIM15_PSC_PSC) | ((val<<0) & TIM15_PSC_PSC); }
static inline uint32_t tim15_psc_get_psc(void) { return (TIM15.PSC & TIM15_PSC_PSC) >> 0 ; }

// TIM15->ARR auto-reload register
enum {
	TIM15_ARR_ARR = ((1UL<<16)-1) << 0, // Auto-reload value		
};
static inline void tim15_arr_set_arr(uint32_t val) { TIM15.ARR = (TIM15.ARR & ~TIM15_ARR_ARR) | ((val<<0) & TIM15_ARR_ARR); }
static inline uint32_t tim15_arr_get_arr(void) { return (TIM15.ARR & TIM15_ARR_ARR) >> 0 ; }

// TIM15->RCR repetition counter register
enum {
	TIM15_RCR_REP = ((1UL<<8)-1) << 0, // Repetition counter value		
};
static inline void tim15_rcr_set_rep(uint32_t val) { TIM15.RCR = (TIM15.RCR & ~TIM15_RCR_REP) | ((val<<0) & TIM15_RCR_REP); }
static inline uint32_t tim15_rcr_get_rep(void) { return (TIM15.RCR & TIM15_RCR_REP) >> 0 ; }

// TIM15->CCR1 capture/compare register 1
enum {
	TIM15_CCR1_CCR1 = ((1UL<<16)-1) << 0, // Capture/Compare 1 value		
};
static inline void tim15_ccr1_set_ccr1(uint32_t val) { TIM15.CCR1 = (TIM15.CCR1 & ~TIM15_CCR1_CCR1) | ((val<<0) & TIM15_CCR1_CCR1); }
static inline uint32_t tim15_ccr1_get_ccr1(void) { return (TIM15.CCR1 & TIM15_CCR1_CCR1) >> 0 ; }

// TIM15->CCR2 capture/compare register 2
enum {
	TIM15_CCR2_CCR2 = ((1UL<<16)-1) << 0, // Capture/Compare 1 value		
};
static inline void tim15_ccr2_set_ccr2(uint32_t val) { TIM15.CCR2 = (TIM15.CCR2 & ~TIM15_CCR2_CCR2) | ((val<<0) & TIM15_CCR2_CCR2); }
static inline uint32_t tim15_ccr2_get_ccr2(void) { return (TIM15.CCR2 & TIM15_CCR2_CCR2) >> 0 ; }

// TIM15->BDTR break and dead-time register
enum {
	TIM15_BDTR_BKBID = 1UL<<28, // BKBID
	TIM15_BDTR_BKDSRM = 1UL<<26, // BKDSRM
	TIM15_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM15_BDTR_MOE = 1UL<<15, // Main output enable
	TIM15_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM15_BDTR_BKP = 1UL<<13, // Break polarity
	TIM15_BDTR_BKE = 1UL<<12, // Break enable
	TIM15_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM15_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM15_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM15_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim15_bdtr_set_bkf(uint32_t val) { TIM15.BDTR = (TIM15.BDTR & ~TIM15_BDTR_BKF) | ((val<<16) & TIM15_BDTR_BKF); }
static inline void tim15_bdtr_set_lock(uint32_t val) { TIM15.BDTR = (TIM15.BDTR & ~TIM15_BDTR_LOCK) | ((val<<8) & TIM15_BDTR_LOCK); }
static inline void tim15_bdtr_set_dtg(uint32_t val) { TIM15.BDTR = (TIM15.BDTR & ~TIM15_BDTR_DTG) | ((val<<0) & TIM15_BDTR_DTG); }
static inline uint32_t tim15_bdtr_get_bkf(void) { return (TIM15.BDTR & TIM15_BDTR_BKF) >> 16 ; }
static inline uint32_t tim15_bdtr_get_lock(void) { return (TIM15.BDTR & TIM15_BDTR_LOCK) >> 8 ; }
static inline uint32_t tim15_bdtr_get_dtg(void) { return (TIM15.BDTR & TIM15_BDTR_DTG) >> 0 ; }

// TIM15->DTR2 timer Deadtime Register 2
enum {
	TIM15_DTR2_DTPE = 1UL<<17, // Deadtime Preload Enable
	TIM15_DTR2_DTAE = 1UL<<16, // Deadtime Asymmetric Enable
	TIM15_DTR2_DTGF = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim15_dtr2_set_dtgf(uint32_t val) { TIM15.DTR2 = (TIM15.DTR2 & ~TIM15_DTR2_DTGF) | ((val<<0) & TIM15_DTR2_DTGF); }
static inline uint32_t tim15_dtr2_get_dtgf(void) { return (TIM15.DTR2 & TIM15_DTR2_DTGF) >> 0 ; }

// TIM15->TISEL TIM timer input selection register
enum {
	TIM15_TISEL_TI2SEL = ((1UL<<4)-1) << 8, // TI2[0] to TI2[15] input selection
	TIM15_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // TI1[0] to TI1[15] input selection		
};
static inline void tim15_tisel_set_ti2sel(uint32_t val) { TIM15.TISEL = (TIM15.TISEL & ~TIM15_TISEL_TI2SEL) | ((val<<8) & TIM15_TISEL_TI2SEL); }
static inline void tim15_tisel_set_ti1sel(uint32_t val) { TIM15.TISEL = (TIM15.TISEL & ~TIM15_TISEL_TI1SEL) | ((val<<0) & TIM15_TISEL_TI1SEL); }
static inline uint32_t tim15_tisel_get_ti2sel(void) { return (TIM15.TISEL & TIM15_TISEL_TI2SEL) >> 8 ; }
static inline uint32_t tim15_tisel_get_ti1sel(void) { return (TIM15.TISEL & TIM15_TISEL_TI1SEL) >> 0 ; }

// TIM15->AF1 TIM alternate function option register 1
enum {
	TIM15_AF1_BKCMP4P = 1UL<<13, // BRK COMP4 input polarity
	TIM15_AF1_BKCMP3P = 1UL<<12, // BRK COMP3 input polarity
	TIM15_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM15_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM15_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM15_AF1_BKCMP7E = 1UL<<7, // BRK COMP7 enable
	TIM15_AF1_BKCMP6E = 1UL<<6, // BRK COMP6 enable
	TIM15_AF1_BKCMP5E = 1UL<<5, // BRK COMP5 enable
	TIM15_AF1_BKCMP4E = 1UL<<4, // BRK COMP4 enable
	TIM15_AF1_BKCMP3E = 1UL<<3, // BRK COMP3 enable
	TIM15_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM15_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM15_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM15->AF2 TIM alternate function option register 2
enum {
	TIM15_AF2_OCRSEL = ((1UL<<3)-1) << 16, // OCREF_CLR source selection		
};
static inline void tim15_af2_set_ocrsel(uint32_t val) { TIM15.AF2 = (TIM15.AF2 & ~TIM15_AF2_OCRSEL) | ((val<<16) & TIM15_AF2_OCRSEL); }
static inline uint32_t tim15_af2_get_ocrsel(void) { return (TIM15.AF2 & TIM15_AF2_OCRSEL) >> 16 ; }

// TIM15->DCR DMA control register
enum {
	TIM15_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM15_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim15_dcr_set_dbl(uint32_t val) { TIM15.DCR = (TIM15.DCR & ~TIM15_DCR_DBL) | ((val<<8) & TIM15_DCR_DBL); }
static inline void tim15_dcr_set_dba(uint32_t val) { TIM15.DCR = (TIM15.DCR & ~TIM15_DCR_DBA) | ((val<<0) & TIM15_DCR_DBA); }
static inline uint32_t tim15_dcr_get_dbl(void) { return (TIM15.DCR & TIM15_DCR_DBL) >> 8 ; }
static inline uint32_t tim15_dcr_get_dba(void) { return (TIM15.DCR & TIM15_DCR_DBA) >> 0 ; }

// Valid Casts:
 
static inline struct TIM6_Type* TIM15_as_TIM6_Type(struct TIM15_Type* p) { return (struct TIM6_Type*)p; }


/* General purpose timers */
struct TIM16_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	 uint8_t RESERVED0[4]; // @8 
	__IO uint32_t DIER; // @12 DMA/Interrupt enable register
	__IO uint32_t SR; // @16 status register
	__O uint32_t EGR; // @20 event generation register
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint32_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED1[4]; // @28 
	__IO uint32_t CCER; // @32 capture/compare enable register
	__IO uint32_t CNT; // @36 counter
	__IO uint32_t PSC; // @40 prescaler
	__IO uint32_t ARR; // @44 auto-reload register
	__IO uint32_t RCR; // @48 repetition counter register
	__IO uint32_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED2[12]; // @56 
	__IO uint32_t BDTR; // @68 break and dead-time register
	 uint8_t RESERVED3[12]; // @72 
	__IO uint32_t DTR2; // @84 timer Deadtime Register 2
	 uint8_t RESERVED4[4]; // @88 
	__IO uint32_t TISEL; // @92 TIM timer input selection register
	__IO uint32_t AF1; // @96 TIM alternate function option register 1
	__IO uint32_t AF2; // @100 TIM alternate function option register 2
	__IO uint32_t OR1; // @104 TIM option register 1
	 uint8_t RESERVED5[880]; // @108 
	__IO uint32_t DCR; // @988 DMA control register
	__IO uint32_t DMAR; // @992 DMA address for full transfer
};
extern struct TIM16_Type	TIM16;	// @0x40014400 
extern struct TIM16_Type 	TIM17;	// @0x40014800

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_DITHEN = 1UL<<12, // Dithering Enable
	TIM16_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM16_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM16_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM16_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM16_CR1_URS = 1UL<<2, // Update request source
	TIM16_CR1_UDIS = 1UL<<1, // Update disable
	TIM16_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim16_cr1_set_ckd(struct TIM16_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM16_CR1_CKD) | ((val<<8) & TIM16_CR1_CKD); }
static inline uint32_t tim16_cr1_get_ckd(struct TIM16_Type* p) { return (p->CR1 & TIM16_CR1_CKD) >> 8 ; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM16_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM16_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM16_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM16_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM16_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM16_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM16_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM16_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM16_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM16_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG = 1UL<<7, // Break generation
	TIM16_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM16_EGR_UG = 1UL<<0, // Update generation		
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_3 = 1UL<<16, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim16_ccmr1_output_set_oc1m(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM16_CCMR1_OUTPUT_OC1M); }
static inline void tim16_ccmr1_output_set_cc1s(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM16_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim16_ccmr1_output_get_oc1m(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim16_ccmr1_output_get_cc1s(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM16_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
static inline void tim16_cnt_set_cnt(struct TIM16_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM16_CNT_CNT) | ((val<<0) & TIM16_CNT_CNT); }
static inline uint32_t tim16_cnt_get_cnt(struct TIM16_Type* p) { return (p->CNT & TIM16_CNT_CNT) >> 0 ; }

// TIM16->PSC prescaler
enum {
	TIM16_PSC_PSC = ((1UL<<16)-1) << 0, // Prescaler value		
};
static inline void tim16_psc_set_psc(struct TIM16_Type* p, uint32_t val) { p->PSC = (p->PSC & ~TIM16_PSC_PSC) | ((val<<0) & TIM16_PSC_PSC); }
static inline uint32_t tim16_psc_get_psc(struct TIM16_Type* p) { return (p->PSC & TIM16_PSC_PSC) >> 0 ; }

// TIM16->ARR auto-reload register
enum {
	TIM16_ARR_ARR = ((1UL<<16)-1) << 0, // Auto-reload value		
};
static inline void tim16_arr_set_arr(struct TIM16_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM16_ARR_ARR) | ((val<<0) & TIM16_ARR_ARR); }
static inline uint32_t tim16_arr_get_arr(struct TIM16_Type* p) { return (p->ARR & TIM16_ARR_ARR) >> 0 ; }

// TIM16->RCR repetition counter register
enum {
	TIM16_RCR_REP = ((1UL<<8)-1) << 0, // Repetition counter value		
};
static inline void tim16_rcr_set_rep(struct TIM16_Type* p, uint32_t val) { p->RCR = (p->RCR & ~TIM16_RCR_REP) | ((val<<0) & TIM16_RCR_REP); }
static inline uint32_t tim16_rcr_get_rep(struct TIM16_Type* p) { return (p->RCR & TIM16_RCR_REP) >> 0 ; }

// TIM16->CCR1 capture/compare register 1
enum {
	TIM16_CCR1_CCR1 = ((1UL<<16)-1) << 0, // Capture/Compare 1 value		
};
static inline void tim16_ccr1_set_ccr1(struct TIM16_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM16_CCR1_CCR1) | ((val<<0) & TIM16_CCR1_CCR1); }
static inline uint32_t tim16_ccr1_get_ccr1(struct TIM16_Type* p) { return (p->CCR1 & TIM16_CCR1_CCR1) >> 0 ; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKBID = 1UL<<28, // BKBID
	TIM16_BDTR_BKDSRM = 1UL<<26, // BKDSRM
	TIM16_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM16_BDTR_MOE = 1UL<<15, // Main output enable
	TIM16_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM16_BDTR_BKP = 1UL<<13, // Break polarity
	TIM16_BDTR_BKE = 1UL<<12, // Break enable
	TIM16_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM16_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM16_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM16_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim16_bdtr_set_bkf(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_BKF) | ((val<<16) & TIM16_BDTR_BKF); }
static inline void tim16_bdtr_set_lock(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_LOCK) | ((val<<8) & TIM16_BDTR_LOCK); }
static inline void tim16_bdtr_set_dtg(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_DTG) | ((val<<0) & TIM16_BDTR_DTG); }
static inline uint32_t tim16_bdtr_get_bkf(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_BKF) >> 16 ; }
static inline uint32_t tim16_bdtr_get_lock(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_LOCK) >> 8 ; }
static inline uint32_t tim16_bdtr_get_dtg(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_DTG) >> 0 ; }

// TIM16->DTR2 timer Deadtime Register 2
enum {
	TIM16_DTR2_DTPE = 1UL<<17, // Deadtime Preload Enable
	TIM16_DTR2_DTAE = 1UL<<16, // Deadtime Asymmetric Enable
	TIM16_DTR2_DTGF = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim16_dtr2_set_dtgf(struct TIM16_Type* p, uint32_t val) { p->DTR2 = (p->DTR2 & ~TIM16_DTR2_DTGF) | ((val<<0) & TIM16_DTR2_DTGF); }
static inline uint32_t tim16_dtr2_get_dtgf(struct TIM16_Type* p) { return (p->DTR2 & TIM16_DTR2_DTGF) >> 0 ; }

// TIM16->TISEL TIM timer input selection register
enum {
	TIM16_TISEL_TI1SEL = ((1UL<<4)-1) << 0, // TI1[0] to TI1[15] input selection		
};
static inline void tim16_tisel_set_ti1sel(struct TIM16_Type* p, uint32_t val) { p->TISEL = (p->TISEL & ~TIM16_TISEL_TI1SEL) | ((val<<0) & TIM16_TISEL_TI1SEL); }
static inline uint32_t tim16_tisel_get_ti1sel(struct TIM16_Type* p) { return (p->TISEL & TIM16_TISEL_TI1SEL) >> 0 ; }

// TIM16->AF1 TIM alternate function option register 1
enum {
	TIM16_AF1_BKCMP4P = 1UL<<13, // BRK COMP4 input polarity
	TIM16_AF1_BKCMP3P = 1UL<<12, // BRK COMP3 input polarity
	TIM16_AF1_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM16_AF1_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM16_AF1_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM16_AF1_BKCMP7E = 1UL<<7, // BRK COMP7 enable
	TIM16_AF1_BKCMP6E = 1UL<<6, // BRK COMP6 enable
	TIM16_AF1_BKCMP5E = 1UL<<5, // BRK COMP5 enable
	TIM16_AF1_BKCMP4E = 1UL<<4, // BRK COMP4 enable
	TIM16_AF1_BKCMP3E = 1UL<<3, // BRK COMP3 enable
	TIM16_AF1_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM16_AF1_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM16_AF1_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// TIM16->AF2 TIM alternate function option register 2
enum {
	TIM16_AF2_OCRSEL = ((1UL<<3)-1) << 16, // OCREF_CLR source selection		
};
static inline void tim16_af2_set_ocrsel(struct TIM16_Type* p, uint32_t val) { p->AF2 = (p->AF2 & ~TIM16_AF2_OCRSEL) | ((val<<16) & TIM16_AF2_OCRSEL); }
static inline uint32_t tim16_af2_get_ocrsel(struct TIM16_Type* p) { return (p->AF2 & TIM16_AF2_OCRSEL) >> 16 ; }

// TIM16->OR1 TIM option register 1
enum {
	TIM16_OR1_HSE32EN = 1UL<<0, // HSE Divided by 32 enable		
};

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM16_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim16_dcr_set_dbl(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBL) | ((val<<8) & TIM16_DCR_DBL); }
static inline void tim16_dcr_set_dba(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBA) | ((val<<0) & TIM16_DCR_DBA); }
static inline uint32_t tim16_dcr_get_dbl(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBL) >> 8 ; }
static inline uint32_t tim16_dcr_get_dba(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBA) >> 0 ; }







/* Basic-timers */
struct TIM6_Type {
	__IO uint32_t CR1; // @0 control register 1
	__IO uint32_t CR2; // @4 control register 2
	 uint8_t RESERVED0[4]; // @8 
	__IO uint32_t DIER; // @12 DMA/Interrupt enable register
	__IO uint32_t SR; // @16 status register
	__O uint32_t EGR; // @20 event generation register
	 uint8_t RESERVED1[12]; // @24 
	__IO uint32_t CNT; // @36 counter
	__IO uint32_t PSC; // @40 prescaler
	__IO uint32_t ARR; // @44 auto-reload register
};
extern struct TIM6_Type	TIM6;	// @0x40001000 
extern struct TIM6_Type 	TIM7;	// @0x40001400

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_DITHEN = 1UL<<12, // Dithering Enable
	TIM6_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM6_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM6_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM6_CR1_URS = 1UL<<2, // Update request source
	TIM6_CR1_UDIS = 1UL<<1, // Update disable
	TIM6_CR1_CEN = 1UL<<0, // Counter enable		
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection		
};
static inline void tim6_cr2_set_mms(struct TIM6_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val<<4) & TIM6_CR2_MMS); }
static inline uint32_t tim6_cr2_get_mms(struct TIM6_Type* p) { return (p->CR2 & TIM6_CR2_MMS) >> 4 ; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM6_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL<<0, // Update generation		
};

// TIM6->CNT counter
enum {
	TIM6_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM6_CNT_CNT = ((1UL<<16)-1) << 0, // Low counter value		
};
static inline void tim6_cnt_set_cnt(struct TIM6_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM6_CNT_CNT) | ((val<<0) & TIM6_CNT_CNT); }
static inline uint32_t tim6_cnt_get_cnt(struct TIM6_Type* p) { return (p->CNT & TIM6_CNT_CNT) >> 0 ; }

// TIM6->PSC prescaler
enum {
	TIM6_PSC_PSC = ((1UL<<16)-1) << 0, // Prescaler value		
};
static inline void tim6_psc_set_psc(struct TIM6_Type* p, uint32_t val) { p->PSC = (p->PSC & ~TIM6_PSC_PSC) | ((val<<0) & TIM6_PSC_PSC); }
static inline uint32_t tim6_psc_get_psc(struct TIM6_Type* p) { return (p->PSC & TIM6_PSC_PSC) >> 0 ; }

// TIM6->ARR auto-reload register
enum {
	TIM6_ARR_ARR = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
static inline void tim6_arr_set_arr(struct TIM6_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM6_ARR_ARR) | ((val<<0) & TIM6_ARR_ARR); }
static inline uint32_t tim6_arr_get_arr(struct TIM6_Type* p) { return (p->ARR & TIM6_ARR_ARR) >> 0 ; }



/* Universal synchronous asynchronous receiver transmitter */
struct USART_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint32_t BRR; // @12 Baud rate register
	__IO uint32_t GTPR; // @16 Guard time and prescaler register
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint32_t RQR; // @24 Request register
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint32_t RDR; // @36 Receive data register
	__IO uint32_t TDR; // @40 Transmit data register
	__IO uint32_t PRESC; // @44 USART prescaler register
};
extern struct USART_Type	USART1;	// @0x40013800 
extern struct USART_Type 	USART2;	// @0x40004400
extern struct USART_Type 	USART3;	// @0x40004800

// USART->CR1 Control register 1
enum {
	USART_CR1_RXFFIE = 1UL<<31, // RXFFIE
	USART_CR1_TXFEIE = 1UL<<30, // TXFEIE
	USART_CR1_FIFOEN = 1UL<<29, // FIFOEN
	USART_CR1_M1 = 1UL<<28, // M1
	USART_CR1_EOBIE = 1UL<<27, // End of Block interrupt enable
	USART_CR1_RTOIE = 1UL<<26, // Receiver timeout interrupt enable
	USART_CR1_DEAT = ((1UL<<5)-1) << 21, // Driver Enable Assertion Time
	USART_CR1_DEDT = ((1UL<<5)-1) << 16, // Driver Enable Deassertion Time
	USART_CR1_OVER8 = 1UL<<15, // Oversampling mode
	USART_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	USART_CR1_MME = 1UL<<13, // Mute mode enable
	USART_CR1_M0 = 1UL<<12, // Word length
	USART_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	USART_CR1_PCE = 1UL<<10, // Parity control enable
	USART_CR1_PS = 1UL<<9, // Parity selection
	USART_CR1_PEIE = 1UL<<8, // PE interrupt enable
	USART_CR1_TXEIE = 1UL<<7, // interrupt enable
	USART_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	USART_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	USART_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	USART_CR1_TE = 1UL<<3, // Transmitter enable
	USART_CR1_RE = 1UL<<2, // Receiver enable
	USART_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	USART_CR1_UE = 1UL<<0, // USART enable		
};
static inline void usart_cr1_set_deat(struct USART_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~USART_CR1_DEAT) | ((val<<21) & USART_CR1_DEAT); }
static inline void usart_cr1_set_dedt(struct USART_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~USART_CR1_DEDT) | ((val<<16) & USART_CR1_DEDT); }
static inline uint32_t usart_cr1_get_deat(struct USART_Type* p) { return (p->CR1 & USART_CR1_DEAT) >> 21 ; }
static inline uint32_t usart_cr1_get_dedt(struct USART_Type* p) { return (p->CR1 & USART_CR1_DEDT) >> 16 ; }

// USART->CR2 Control register 2
enum {
	USART_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	USART_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	USART_CR2_RTOEN = 1UL<<23, // Receiver timeout enable
	USART_CR2_ABRMOD1 = 1UL<<22, // Auto baud rate mode
	USART_CR2_ABRMOD0 = 1UL<<21, // ABRMOD0
	USART_CR2_ABREN = 1UL<<20, // Auto baud rate enable
	USART_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	USART_CR2_TAINV = 1UL<<18, // Binary data inversion
	USART_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	USART_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	USART_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	USART_CR2_LINEN = 1UL<<14, // LIN mode enable
	USART_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	USART_CR2_CLKEN = 1UL<<11, // Clock enable
	USART_CR2_CPOL = 1UL<<10, // Clock polarity
	USART_CR2_CPHA = 1UL<<9, // Clock phase
	USART_CR2_LBCL = 1UL<<8, // Last bit clock pulse
	USART_CR2_LBDIE = 1UL<<6, // LIN break detection interrupt enable
	USART_CR2_LBDL = 1UL<<5, // LIN break detection length
	USART_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection
	USART_CR2_DIS_NSS = 1UL<<3, // DIS_NSS
	USART_CR2_SLVEN = 1UL<<0, // SLVEN		
};
static inline void usart_cr2_set_add4_7(struct USART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART_CR2_ADD4_7) | ((val<<28) & USART_CR2_ADD4_7); }
static inline void usart_cr2_set_add0_3(struct USART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART_CR2_ADD0_3) | ((val<<24) & USART_CR2_ADD0_3); }
static inline void usart_cr2_set_stop(struct USART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART_CR2_STOP) | ((val<<12) & USART_CR2_STOP); }
static inline uint32_t usart_cr2_get_add4_7(struct USART_Type* p) { return (p->CR2 & USART_CR2_ADD4_7) >> 28 ; }
static inline uint32_t usart_cr2_get_add0_3(struct USART_Type* p) { return (p->CR2 & USART_CR2_ADD0_3) >> 24 ; }
static inline uint32_t usart_cr2_get_stop(struct USART_Type* p) { return (p->CR2 & USART_CR2_STOP) >> 12 ; }

// USART->CR3 Control register 3
enum {
	USART_CR3_TXFTCFG = ((1UL<<3)-1) << 29, // TXFTCFG
	USART_CR3_RXFTIE = 1UL<<28, // RXFTIE
	USART_CR3_RXFTCFG = ((1UL<<3)-1) << 25, // RXFTCFG
	USART_CR3_TCBGTIE = 1UL<<24, // TCBGTIE
	USART_CR3_TXFTIE = 1UL<<23, // TXFTIE
	USART_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	USART_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	USART_CR3_SCARCNT = ((1UL<<3)-1) << 17, // Smartcard auto-retry count
	USART_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	USART_CR3_DEM = 1UL<<14, // Driver enable mode
	USART_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	USART_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	USART_CR3_ONEBIT = 1UL<<11, // One sample bit method enable
	USART_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	USART_CR3_CTSE = 1UL<<9, // CTS enable
	USART_CR3_RTSE = 1UL<<8, // RTS enable
	USART_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	USART_CR3_DMAR = 1UL<<6, // DMA enable receiver
	USART_CR3_SCEN = 1UL<<5, // Smartcard mode enable
	USART_CR3_NACK = 1UL<<4, // Smartcard NACK enable
	USART_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	USART_CR3_IRLP = 1UL<<2, // Ir low-power
	USART_CR3_IREN = 1UL<<1, // Ir mode enable
	USART_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
static inline void usart_cr3_set_txftcfg(struct USART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART_CR3_TXFTCFG) | ((val<<29) & USART_CR3_TXFTCFG); }
static inline void usart_cr3_set_rxftcfg(struct USART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART_CR3_RXFTCFG) | ((val<<25) & USART_CR3_RXFTCFG); }
static inline void usart_cr3_set_wus(struct USART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART_CR3_WUS) | ((val<<20) & USART_CR3_WUS); }
static inline void usart_cr3_set_scarcnt(struct USART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART_CR3_SCARCNT) | ((val<<17) & USART_CR3_SCARCNT); }
static inline uint32_t usart_cr3_get_txftcfg(struct USART_Type* p) { return (p->CR3 & USART_CR3_TXFTCFG) >> 29 ; }
static inline uint32_t usart_cr3_get_rxftcfg(struct USART_Type* p) { return (p->CR3 & USART_CR3_RXFTCFG) >> 25 ; }
static inline uint32_t usart_cr3_get_wus(struct USART_Type* p) { return (p->CR3 & USART_CR3_WUS) >> 20 ; }
static inline uint32_t usart_cr3_get_scarcnt(struct USART_Type* p) { return (p->CR3 & USART_CR3_SCARCNT) >> 17 ; }

// USART->BRR Baud rate register
enum {
	USART_BRR_DIV_MANTISSA = ((1UL<<12)-1) << 4, // DIV_Mantissa
	USART_BRR_DIV_FRACTION = ((1UL<<4)-1) << 0, // DIV_Fraction		
};
static inline void usart_brr_set_div_mantissa(struct USART_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART_BRR_DIV_MANTISSA) | ((val<<4) & USART_BRR_DIV_MANTISSA); }
static inline void usart_brr_set_div_fraction(struct USART_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART_BRR_DIV_FRACTION) | ((val<<0) & USART_BRR_DIV_FRACTION); }
static inline uint32_t usart_brr_get_div_mantissa(struct USART_Type* p) { return (p->BRR & USART_BRR_DIV_MANTISSA) >> 4 ; }
static inline uint32_t usart_brr_get_div_fraction(struct USART_Type* p) { return (p->BRR & USART_BRR_DIV_FRACTION) >> 0 ; }

// USART->GTPR Guard time and prescaler register
enum {
	USART_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	USART_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
static inline void usart_gtpr_set_gt(struct USART_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART_GTPR_GT) | ((val<<8) & USART_GTPR_GT); }
static inline void usart_gtpr_set_psc(struct USART_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART_GTPR_PSC) | ((val<<0) & USART_GTPR_PSC); }
static inline uint32_t usart_gtpr_get_gt(struct USART_Type* p) { return (p->GTPR & USART_GTPR_GT) >> 8 ; }
static inline uint32_t usart_gtpr_get_psc(struct USART_Type* p) { return (p->GTPR & USART_GTPR_PSC) >> 0 ; }

// USART->RTOR Receiver timeout register
enum {
	USART_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	USART_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
static inline void usart_rtor_set_blen(struct USART_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART_RTOR_BLEN) | ((val<<24) & USART_RTOR_BLEN); }
static inline void usart_rtor_set_rto(struct USART_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART_RTOR_RTO) | ((val<<0) & USART_RTOR_RTO); }
static inline uint32_t usart_rtor_get_blen(struct USART_Type* p) { return (p->RTOR & USART_RTOR_BLEN) >> 24 ; }
static inline uint32_t usart_rtor_get_rto(struct USART_Type* p) { return (p->RTOR & USART_RTOR_RTO) >> 0 ; }

// USART->RQR Request register
enum {
	USART_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	USART_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	USART_RQR_MMRQ = 1UL<<2, // Mute mode request
	USART_RQR_SBKRQ = 1UL<<1, // Send break request
	USART_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// USART->ISR Interrupt & status register
enum {
	USART_ISR_TXFT = 1UL<<27, // TXFT
	USART_ISR_RXFT = 1UL<<26, // RXFT
	USART_ISR_TCBGT = 1UL<<25, // TCBGT
	USART_ISR_RXFF = 1UL<<24, // RXFF
	USART_ISR_TXFE = 1UL<<23, // TXFE
	USART_ISR_REACK = 1UL<<22, // REACK
	USART_ISR_TEACK = 1UL<<21, // TEACK
	USART_ISR_WUF = 1UL<<20, // WUF
	USART_ISR_RWU = 1UL<<19, // RWU
	USART_ISR_SBKF = 1UL<<18, // SBKF
	USART_ISR_CMF = 1UL<<17, // CMF
	USART_ISR_BUSY = 1UL<<16, // BUSY
	USART_ISR_ABRF = 1UL<<15, // ABRF
	USART_ISR_ABRE = 1UL<<14, // ABRE
	USART_ISR_UDR = 1UL<<13, // UDR
	USART_ISR_EOBF = 1UL<<12, // EOBF
	USART_ISR_RTOF = 1UL<<11, // RTOF
	USART_ISR_CTS = 1UL<<10, // CTS
	USART_ISR_CTSIF = 1UL<<9, // CTSIF
	USART_ISR_LBDF = 1UL<<8, // LBDF
	USART_ISR_TXE = 1UL<<7, // TXE
	USART_ISR_TC = 1UL<<6, // TC
	USART_ISR_RXNE = 1UL<<5, // RXNE
	USART_ISR_IDLE = 1UL<<4, // IDLE
	USART_ISR_ORE = 1UL<<3, // ORE
	USART_ISR_NF = 1UL<<2, // NF
	USART_ISR_FE = 1UL<<1, // FE
	USART_ISR_PE = 1UL<<0, // PE		
};

// USART->ICR Interrupt flag clear register
enum {
	USART_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	USART_ICR_CMCF = 1UL<<17, // Character match clear flag
	USART_ICR_UDRCF = 1UL<<13, // UDRCF
	USART_ICR_EOBCF = 1UL<<12, // End of block clear flag
	USART_ICR_RTOCF = 1UL<<11, // Receiver timeout clear flag
	USART_ICR_CTSCF = 1UL<<9, // CTS clear flag
	USART_ICR_LBDCF = 1UL<<8, // LIN break detection clear flag
	USART_ICR_TCBGTCF = 1UL<<7, // TCBGTCF
	USART_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	USART_ICR_TXFECF = 1UL<<5, // TXFECF
	USART_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	USART_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	USART_ICR_NCF = 1UL<<2, // Noise detected clear flag
	USART_ICR_FECF = 1UL<<1, // Framing error clear flag
	USART_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// USART->RDR Receive data register
enum {
	USART_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
static inline uint32_t usart_rdr_get_rdr(struct USART_Type* p) { return (p->RDR & USART_RDR_RDR) >> 0 ; }

// USART->TDR Transmit data register
enum {
	USART_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
static inline void usart_tdr_set_tdr(struct USART_Type* p, uint32_t val) { p->TDR = (p->TDR & ~USART_TDR_TDR) | ((val<<0) & USART_TDR_TDR); }
static inline uint32_t usart_tdr_get_tdr(struct USART_Type* p) { return (p->TDR & USART_TDR_TDR) >> 0 ; }

// USART->PRESC USART prescaler register
enum {
	USART_PRESC_PRESCALER = ((1UL<<4)-1) << 0, // PRESCALER		
};
static inline void usart_presc_set_prescaler(struct USART_Type* p, uint32_t val) { p->PRESC = (p->PRESC & ~USART_PRESC_PRESCALER) | ((val<<0) & USART_PRESC_PRESCALER); }
static inline uint32_t usart_presc_get_prescaler(struct USART_Type* p) { return (p->PRESC & USART_PRESC_PRESCALER) >> 0 ; }



/* Voltage reference buffer
There is only one peripheral of type VREFBUF. */
struct VREFBUF_Type {
	__IO uint32_t CSR; // @0 VREF_BUF Control and Status Register
	__IO uint32_t CCR; // @4 VREF_BUF Calibration Control Register
};
extern struct VREFBUF_Type	VREFBUF;	// @0x40010030 

// VREFBUF->CSR VREF_BUF Control and Status Register
enum {
	VREFBUF_CSR_VRS = ((1UL<<2)-1) << 4, // Voltage reference scale
	VREFBUF_CSR_VRR = 1UL<<3, // Voltage reference buffer ready
	VREFBUF_CSR_HIZ = 1UL<<1, // High impedence mode for the VREF_BUF
	VREFBUF_CSR_ENVR = 1UL<<0, // Enable Voltage Reference		
};
static inline void vrefbuf_csr_set_vrs(uint32_t val) { VREFBUF.CSR = (VREFBUF.CSR & ~VREFBUF_CSR_VRS) | ((val<<4) & VREFBUF_CSR_VRS); }
static inline uint32_t vrefbuf_csr_get_vrs(void) { return (VREFBUF.CSR & VREFBUF_CSR_VRS) >> 4 ; }

// VREFBUF->CCR VREF_BUF Calibration Control Register
enum {
	VREFBUF_CCR_TRIM = ((1UL<<6)-1) << 0, // Trimming code		
};
static inline void vrefbuf_ccr_set_trim(uint32_t val) { VREFBUF.CCR = (VREFBUF.CCR & ~VREFBUF_CCR_TRIM) | ((val<<0) & VREFBUF_CCR_TRIM); }
static inline uint32_t vrefbuf_ccr_get_trim(void) { return (VREFBUF.CCR & VREFBUF_CCR_TRIM) >> 0 ; }

/* System window watchdog
There is only one peripheral of type WWDG. */
struct WWDG_Type {
	__IO uint32_t CR; // @0 Control register
	__IO uint32_t CFR; // @4 Configuration register
	__IO uint32_t SR; // @8 Status register
};
extern struct WWDG_Type	WWDG;	// @0x40002C00 

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL<<7, // Activation bit
	WWDG_CR_T = ((1UL<<7)-1) << 0, // 7-bit counter (MSB to LSB)		
};
static inline void wwdg_cr_set_t(uint32_t val) { WWDG.CR = (WWDG.CR & ~WWDG_CR_T) | ((val<<0) & WWDG_CR_T); }
static inline uint32_t wwdg_cr_get_t(void) { return (WWDG.CR & WWDG_CR_T) >> 0 ; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_WDGTB = ((1UL<<3)-1) << 11, // Timer base
	WWDG_CFR_EWI = 1UL<<9, // Early wakeup interrupt
	WWDG_CFR_W = ((1UL<<7)-1) << 0, // 7-bit window value		
};
static inline void wwdg_cfr_set_wdgtb(uint32_t val) { WWDG.CFR = (WWDG.CFR & ~WWDG_CFR_WDGTB) | ((val<<11) & WWDG_CFR_WDGTB); }
static inline void wwdg_cfr_set_w(uint32_t val) { WWDG.CFR = (WWDG.CFR & ~WWDG_CFR_W) | ((val<<0) & WWDG_CFR_W); }
static inline uint32_t wwdg_cfr_get_wdgtb(void) { return (WWDG.CFR & WWDG_CFR_WDGTB) >> 11 ; }
static inline uint32_t wwdg_cfr_get_w(void) { return (WWDG.CFR & WWDG_CFR_W) >> 0 ; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL<<0, // Early wakeup interrupt flag		
};


#undef __I
#undef __O
#undef __IO
