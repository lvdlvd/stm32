#pragma once

// Generated enums and structures for device STM32G431xx version 1.0
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ

	//  Cortex-CM4 Processor Exceptions Numbers
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt
	Reserved_3_IRQn       = -13,
	MemoryManagement_IRQn = -12, // 4 Memory Management Interrupt
	BusFault_IRQn         = -11, // 5 Bus Fault Interrupt
	UsageFault_IRQn       = -10, // 6 Usage Fault Interrupt
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 SV Call Interrupt
	DebugMonitor_IRQn     = -4, // 12 Debug Monitor Interrupt
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Pend SV Interrupt
	SysTick_IRQn          = -1, // 15 System Tick Interrupt

	//  Device specific Interrupt Numbers
	WWDG_IRQn             = 0,   // Window Watchdog interrupt
	PVD_PVM_IRQn          = 1,   // PVD through EXTI line detection
	RTC_TAMP_CSS_LSE_IRQn = 2,   // RTC_TAMP_CSS_LSE
	RTC_WKUP_IRQn         = 3,   // RTC Wakeup timer
	FLASH_IRQn            = 4,   // FLASH
	RCC_IRQn              = 5,   // RCC
	EXTI0_IRQn            = 6,   // EXTI Line0 interrupt
	EXTI1_IRQn            = 7,   // EXTI Line1 interrupt
	EXTI2_IRQn            = 8,   // EXTI Line2 interrupt
	EXTI3_IRQn            = 9,   // EXTI Line3 interrupt
	EXTI4_IRQn            = 10,  // EXTI Line4 interrupt
	DMA1_CH1_IRQn         = 11,  // DMA1 channel 1 interrupt
	DMA1_CH2_IRQn         = 12,  // DMA1 channel 2 interrupt
	DMA1_CH3_IRQn         = 13,  // DMA1 channel 3 interrupt
	DMA1_CH4_IRQn         = 14,  // DMA1 channel 4 interrupt
	DMA1_CH5_IRQn         = 15,  // DMA1 channel 5 interrupt
	DMA1_CH6_IRQn         = 16,  // DMA1 channel 6 interrupt
	ADC1_2_IRQn           = 18,  // ADC1 and ADC2 global interrupt
	USB_HP_IRQn           = 19,  // USB_HP
	USB_LP_IRQn           = 20,  // USB_LP
	fdcan1_intr1_it_IRQn  = 21,  // fdcan1_intr1_it
	fdcan1_intr0_it_IRQn  = 22,  // fdcan1_intr0_it
	EXTI9_5_IRQn          = 23,  // EXTI9_5
	TIM1_BRK_TIM15_IRQn   = 24,  // TIM1_BRK_TIM15
	TIM1_UP_TIM16_IRQn    = 25,  // TIM1_UP_TIM16
	TIM1_TRG_COM_IRQn     = 26,  // TIM1_TRG_COM/
	TIM1_CC_IRQn          = 27,  // TIM1 capture compare interrupt
	TIM2_IRQn             = 28,  // TIM2
	TIM3_IRQn             = 29,  // TIM3
	TIM4_IRQn             = 30,  // TIM4
	I2C1_EV_IRQn          = 31,  // I2C1_EV
	I2C1_ER_IRQn          = 32,  // I2C1_ER
	I2C2_EV_IRQn          = 33,  // I2C2_EV
	I2C2_ER_IRQn          = 34,  // I2C2_ER
	SPI1_IRQn             = 35,  // SPI1
	SPI2_IRQn             = 36,  // SPI2
	USART1_IRQn           = 37,  // USART1
	USART2_IRQn           = 38,  // USART2
	USART3_IRQn           = 39,  // USART3
	EXTI15_10_IRQn        = 40,  // EXTI15_10
	RTC_ALARM_IRQn        = 41,  // RTC_ALARM
	USBWakeUP_IRQn        = 42,  // USBWakeUP
	TIM8_BRK_IRQn         = 43,  // TIM8_BRK
	TIM8_UP_IRQn          = 44,  // TIM8_UP
	TIM8_TRG_COM_IRQn     = 45,  // TIM8_TRG_COM
	TIM8_CC_IRQn          = 46,  // TIM8_CC
	LPTIM1_IRQn           = 49,  // LPTIM1
	SPI3_IRQn             = 51,  // SPI3
	UART4_IRQn            = 52,  // UART4
	TIM6_DACUNDER_IRQn    = 54,  // TIM6_DACUNDER
	TIM7_IRQn             = 55,  // TIM7
	DMA2_CH1_IRQn         = 56,  // DMA2_CH1
	DMA2_CH2_IRQn         = 57,  // DMA2_CH2
	DMA2_CH3_IRQn         = 58,  // DMA2_CH3
	DMA2_CH4_IRQn         = 59,  // DMA2_CH4
	DMA2_CH5_IRQn         = 60,  // DMA2_CH5
	UCPD1_IRQn            = 63,  // UCPD1
	COMP1_2_3_IRQn        = 64,  // COMP1_2_3
	COMP4_IRQn            = 65,  // COMP4_5_6
	CRS_IRQn              = 75,  // CRS
	SAI_IRQn              = 76,  // SAI
	FPU_IRQn              = 81,  // Floating point unit interrupt
	AES_IRQn              = 85,  // AES
	RNG_IRQn              = 90,  // RNG
	LPUART_IRQn           = 91,  // LPUART
	I2C3_EV_IRQn          = 92,  // I2C3_EV
	I2C3_ER_IRQn          = 93,  // I2C3_ER
	DMAMUX_OVR_IRQn       = 94,  // DMAMUX_OVR
	DMA2_CH6_IRQn         = 97,  // DMA2_CH6
	Cordic_IRQn           = 100, // Cordic
	FMAC_IRQn             = 101, // FMAC
};

#define __I volatile const // 'read only' permissions
#define __O volatile // 'write only' permissions
#define __IO volatile // 'read / write' permissions

/* Analog-to-Digital Converter */
struct ADC1_Type {
	__IO uint16_t ISR;            // @0 interrupt and status register
	uint8_t       RESERVED0[2];   // @2
	__IO uint16_t IER;            // @4 interrupt enable register
	uint8_t       RESERVED1[2];   // @6
	__IO uint32_t CR;             // @8 control register
	__IO uint32_t CFGR;           // @12 configuration register
	__IO uint32_t CFGR2;          // @16 configuration register
	__IO uint32_t SMPR1;          // @20 sample time register 1
	__IO uint32_t SMPR2;          // @24 sample time register 2
	uint8_t       RESERVED2[4];   // @28
	__IO uint32_t TR1;            // @32 watchdog threshold register 1
	__IO uint32_t TR2;            // @36 watchdog threshold register
	__IO uint32_t TR3;            // @40 watchdog threshold register 3
	uint8_t       RESERVED3[4];   // @44
	__IO uint32_t SQR1;           // @48 regular sequence register 1
	__IO uint32_t SQR2;           // @52 regular sequence register 2
	__IO uint32_t SQR3;           // @56 regular sequence register 3
	__IO uint16_t SQR4;           // @60 regular sequence register 4
	uint8_t       RESERVED4[2];   // @62
	__I uint16_t  DR;             // @64 regular Data Register
	uint8_t       RESERVED5[10];  // @66
	__IO uint32_t JSQR;           // @76 injected sequence register
	uint8_t       RESERVED6[16];  // @80
	__IO uint32_t OFR1;           // @96 offset register 1
	__IO uint32_t OFR2;           // @100 offset register 2
	__IO uint32_t OFR3;           // @104 offset register 3
	__IO uint32_t OFR4;           // @108 offset register 4
	uint8_t       RESERVED7[16];  // @112
	__I uint16_t  JDR1;           // @128 injected data register 1
	uint8_t       RESERVED8[2];   // @130
	__I uint16_t  JDR2;           // @132 injected data register 2
	uint8_t       RESERVED9[2];   // @134
	__I uint16_t  JDR3;           // @136 injected data register 3
	uint8_t       RESERVED10[2];  // @138
	__I uint16_t  JDR4;           // @140 injected data register 4
	uint8_t       RESERVED11[18]; // @142
	__IO uint32_t AWD2CR;         // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR;         // @164 Analog Watchdog 3 Configuration Register
	uint8_t       RESERVED12[8];  // @168
	__IO uint32_t DIFSEL;         // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT;        // @180 Calibration Factors
	uint8_t       RESERVED13[8];  // @184
	__IO uint16_t GCOMP;          // @192 Gain compensation Register
};

// ADC1->ISR interrupt and status register
enum {
	ADC1_ISR_JQOVF = 1UL << 10, // JQOVF
	ADC1_ISR_AWD3  = 1UL << 9,  // AWD3
	ADC1_ISR_AWD2  = 1UL << 8,  // AWD2
	ADC1_ISR_AWD1  = 1UL << 7,  // AWD1
	ADC1_ISR_JEOS  = 1UL << 6,  // JEOS
	ADC1_ISR_JEOC  = 1UL << 5,  // JEOC
	ADC1_ISR_OVR   = 1UL << 4,  // OVR
	ADC1_ISR_EOS   = 1UL << 3,  // EOS
	ADC1_ISR_EOC   = 1UL << 2,  // EOC
	ADC1_ISR_EOSMP = 1UL << 1,  // EOSMP
	ADC1_ISR_ADRDY = 1UL << 0,  // ADRDY
};

// ADC1->IER interrupt enable register
enum {
	ADC1_IER_JQOVFIE = 1UL << 10, // JQOVFIE
	ADC1_IER_AWD3IE  = 1UL << 9,  // AWD3IE
	ADC1_IER_AWD2IE  = 1UL << 8,  // AWD2IE
	ADC1_IER_AWD1IE  = 1UL << 7,  // AWD1IE
	ADC1_IER_JEOSIE  = 1UL << 6,  // JEOSIE
	ADC1_IER_JEOCIE  = 1UL << 5,  // JEOCIE
	ADC1_IER_OVRIE   = 1UL << 4,  // OVRIE
	ADC1_IER_EOSIE   = 1UL << 3,  // EOSIE
	ADC1_IER_EOCIE   = 1UL << 2,  // EOCIE
	ADC1_IER_EOSMPIE = 1UL << 1,  // EOSMPIE
	ADC1_IER_ADRDYIE = 1UL << 0,  // ADRDYIE
};

// ADC1->CR control register
enum {
	ADC1_CR_ADCAL    = 1UL << 31, // ADCAL
	ADC1_CR_ADCALDIF = 1UL << 30, // ADCALDIF
	ADC1_CR_DEEPPWD  = 1UL << 29, // DEEPPWD
	ADC1_CR_ADVREGEN = 1UL << 28, // ADVREGEN
	ADC1_CR_JADSTP   = 1UL << 5,  // JADSTP
	ADC1_CR_ADSTP    = 1UL << 4,  // ADSTP
	ADC1_CR_JADSTART = 1UL << 3,  // JADSTART
	ADC1_CR_ADSTART  = 1UL << 2,  // ADSTART
	ADC1_CR_ADDIS    = 1UL << 1,  // ADDIS
	ADC1_CR_ADEN     = 1UL << 0,  // ADEN
};

// ADC1->CFGR configuration register
enum {
	ADC1_CFGR_JQDIS    = 1UL << 31,              // Injected Queue disable
	ADC1_CFGR_AWDCH1CH = ((1UL << 5) - 1) << 26, // AWDCH1CH
	ADC1_CFGR_JAUTO    = 1UL << 25,              // JAUTO
	ADC1_CFGR_JAWD1EN  = 1UL << 24,              // JAWD1EN
	ADC1_CFGR_AWD1EN   = 1UL << 23,              // AWD1EN
	ADC1_CFGR_AWD1SGL  = 1UL << 22,              // AWD1SGL
	ADC1_CFGR_JQM      = 1UL << 21,              // JQM
	ADC1_CFGR_JDISCEN  = 1UL << 20,              // JDISCEN
	ADC1_CFGR_DISCNUM  = ((1UL << 3) - 1) << 17, // DISCNUM
	ADC1_CFGR_DISCEN   = 1UL << 16,              // DISCEN
	ADC1_CFGR_ALIGN    = 1UL << 15,              // ALIGN
	ADC1_CFGR_AUTDLY   = 1UL << 14,              // AUTDLY
	ADC1_CFGR_CONT     = 1UL << 13,              // CONT
	ADC1_CFGR_OVRMOD   = 1UL << 12,              // OVRMOD
	ADC1_CFGR_EXTEN    = ((1UL << 2) - 1) << 10, // EXTEN
	ADC1_CFGR_EXTSEL   = ((1UL << 4) - 1) << 6,  // EXTSEL
	ADC1_CFGR_ALIGN_5  = 1UL << 5,               // ALIGN_5
	ADC1_CFGR_RES      = ((1UL << 2) - 1) << 3,  // RES
	ADC1_CFGR_DMACFG   = 1UL << 1,               // DMACFG
	ADC1_CFGR_DMAEN    = 1UL << 0,               // DMAEN
};
inline void adc1_cfgr_set_awdch1ch(struct ADC1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_AWDCH1CH) | ((val << 26) & ADC1_CFGR_AWDCH1CH);
}
inline void adc1_cfgr_set_discnum(struct ADC1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_DISCNUM) | ((val << 17) & ADC1_CFGR_DISCNUM);
}
inline void adc1_cfgr_set_exten(struct ADC1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_EXTEN) | ((val << 10) & ADC1_CFGR_EXTEN);
}
inline void adc1_cfgr_set_extsel(struct ADC1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~ADC1_CFGR_EXTSEL) | ((val << 6) & ADC1_CFGR_EXTSEL);
}
inline void adc1_cfgr_set_res(struct ADC1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC1_CFGR_RES) | ((val << 3) & ADC1_CFGR_RES); }
inline uint32_t adc1_cfgr_get_awdch1ch(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_AWDCH1CH) >> 26; }
inline uint32_t adc1_cfgr_get_discnum(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_DISCNUM) >> 17; }
inline uint32_t adc1_cfgr_get_exten(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_EXTEN) >> 10; }
inline uint32_t adc1_cfgr_get_extsel(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_EXTSEL) >> 6; }
inline uint32_t adc1_cfgr_get_res(struct ADC1_Type* p) { return (p->CFGR & ADC1_CFGR_RES) >> 3; }

// ADC1->CFGR2 configuration register
enum {
	ADC1_CFGR2_SMPTRIG = 1UL << 27,             // SMPTRIG
	ADC1_CFGR2_BULB    = 1UL << 26,             // BULB
	ADC1_CFGR2_SWTRIG  = 1UL << 25,             // SWTRIG
	ADC1_CFGR2_GCOMP   = 1UL << 16,             // GCOMP
	ADC1_CFGR2_ROVSM   = 1UL << 10,             // EXTEN
	ADC1_CFGR2_TROVS   = 1UL << 9,              // Triggered Regular Oversampling
	ADC1_CFGR2_OVSS    = ((1UL << 4) - 1) << 5, // ALIGN
	ADC1_CFGR2_OVSR    = ((1UL << 3) - 1) << 2, // RES
	ADC1_CFGR2_JOVSE   = 1UL << 1,              // DMACFG
	ADC1_CFGR2_ROVSE   = 1UL << 0,              // DMAEN
};
inline void adc1_cfgr2_set_ovss(struct ADC1_Type* p, uint32_t val) {
	p->CFGR2 = (p->CFGR2 & ~ADC1_CFGR2_OVSS) | ((val << 5) & ADC1_CFGR2_OVSS);
}
inline void adc1_cfgr2_set_ovsr(struct ADC1_Type* p, uint32_t val) {
	p->CFGR2 = (p->CFGR2 & ~ADC1_CFGR2_OVSR) | ((val << 2) & ADC1_CFGR2_OVSR);
}
inline uint32_t adc1_cfgr2_get_ovss(struct ADC1_Type* p) { return (p->CFGR2 & ADC1_CFGR2_OVSS) >> 5; }
inline uint32_t adc1_cfgr2_get_ovsr(struct ADC1_Type* p) { return (p->CFGR2 & ADC1_CFGR2_OVSR) >> 2; }

// ADC1->SMPR1 sample time register 1
enum {
	ADC1_SMPR1_SMPPLUS = 1UL << 31,              // Addition of one clock cycle to the sampling time
	ADC1_SMPR1_SMP9    = ((1UL << 3) - 1) << 27, // SMP9
	ADC1_SMPR1_SMP8    = ((1UL << 3) - 1) << 24, // SMP8
	ADC1_SMPR1_SMP7    = ((1UL << 3) - 1) << 21, // SMP7
	ADC1_SMPR1_SMP6    = ((1UL << 3) - 1) << 18, // SMP6
	ADC1_SMPR1_SMP5    = ((1UL << 3) - 1) << 15, // SMP5
	ADC1_SMPR1_SMP4    = ((1UL << 3) - 1) << 12, // SMP4
	ADC1_SMPR1_SMP3    = ((1UL << 3) - 1) << 9,  // SMP3
	ADC1_SMPR1_SMP2    = ((1UL << 3) - 1) << 6,  // SMP2
	ADC1_SMPR1_SMP1    = ((1UL << 3) - 1) << 3,  // SMP1
	ADC1_SMPR1_SMP0    = ((1UL << 3) - 1) << 0,  // SMP0
};
inline void adc1_smpr1_set_smp9(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP9) | ((val << 27) & ADC1_SMPR1_SMP9);
}
inline void adc1_smpr1_set_smp8(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP8) | ((val << 24) & ADC1_SMPR1_SMP8);
}
inline void adc1_smpr1_set_smp7(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP7) | ((val << 21) & ADC1_SMPR1_SMP7);
}
inline void adc1_smpr1_set_smp6(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP6) | ((val << 18) & ADC1_SMPR1_SMP6);
}
inline void adc1_smpr1_set_smp5(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP5) | ((val << 15) & ADC1_SMPR1_SMP5);
}
inline void adc1_smpr1_set_smp4(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP4) | ((val << 12) & ADC1_SMPR1_SMP4);
}
inline void adc1_smpr1_set_smp3(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP3) | ((val << 9) & ADC1_SMPR1_SMP3);
}
inline void adc1_smpr1_set_smp2(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP2) | ((val << 6) & ADC1_SMPR1_SMP2);
}
inline void adc1_smpr1_set_smp1(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP1) | ((val << 3) & ADC1_SMPR1_SMP1);
}
inline void adc1_smpr1_set_smp0(struct ADC1_Type* p, uint32_t val) {
	p->SMPR1 = (p->SMPR1 & ~ADC1_SMPR1_SMP0) | ((val << 0) & ADC1_SMPR1_SMP0);
}
inline uint32_t adc1_smpr1_get_smp9(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP9) >> 27; }
inline uint32_t adc1_smpr1_get_smp8(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP8) >> 24; }
inline uint32_t adc1_smpr1_get_smp7(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP7) >> 21; }
inline uint32_t adc1_smpr1_get_smp6(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP6) >> 18; }
inline uint32_t adc1_smpr1_get_smp5(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP5) >> 15; }
inline uint32_t adc1_smpr1_get_smp4(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP4) >> 12; }
inline uint32_t adc1_smpr1_get_smp3(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP3) >> 9; }
inline uint32_t adc1_smpr1_get_smp2(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP2) >> 6; }
inline uint32_t adc1_smpr1_get_smp1(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP1) >> 3; }
inline uint32_t adc1_smpr1_get_smp0(struct ADC1_Type* p) { return (p->SMPR1 & ADC1_SMPR1_SMP0) >> 0; }

// ADC1->SMPR2 sample time register 2
enum {
	ADC1_SMPR2_SMP18 = ((1UL << 3) - 1) << 24, // SMP18
	ADC1_SMPR2_SMP17 = ((1UL << 3) - 1) << 21, // SMP17
	ADC1_SMPR2_SMP16 = ((1UL << 3) - 1) << 18, // SMP16
	ADC1_SMPR2_SMP15 = ((1UL << 3) - 1) << 15, // SMP15
	ADC1_SMPR2_SMP14 = ((1UL << 3) - 1) << 12, // SMP14
	ADC1_SMPR2_SMP13 = ((1UL << 3) - 1) << 9,  // SMP13
	ADC1_SMPR2_SMP12 = ((1UL << 3) - 1) << 6,  // SMP12
	ADC1_SMPR2_SMP11 = ((1UL << 3) - 1) << 3,  // SMP11
	ADC1_SMPR2_SMP10 = ((1UL << 3) - 1) << 0,  // SMP10
};
inline void adc1_smpr2_set_smp18(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP18) | ((val << 24) & ADC1_SMPR2_SMP18);
}
inline void adc1_smpr2_set_smp17(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP17) | ((val << 21) & ADC1_SMPR2_SMP17);
}
inline void adc1_smpr2_set_smp16(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP16) | ((val << 18) & ADC1_SMPR2_SMP16);
}
inline void adc1_smpr2_set_smp15(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP15) | ((val << 15) & ADC1_SMPR2_SMP15);
}
inline void adc1_smpr2_set_smp14(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP14) | ((val << 12) & ADC1_SMPR2_SMP14);
}
inline void adc1_smpr2_set_smp13(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP13) | ((val << 9) & ADC1_SMPR2_SMP13);
}
inline void adc1_smpr2_set_smp12(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP12) | ((val << 6) & ADC1_SMPR2_SMP12);
}
inline void adc1_smpr2_set_smp11(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP11) | ((val << 3) & ADC1_SMPR2_SMP11);
}
inline void adc1_smpr2_set_smp10(struct ADC1_Type* p, uint32_t val) {
	p->SMPR2 = (p->SMPR2 & ~ADC1_SMPR2_SMP10) | ((val << 0) & ADC1_SMPR2_SMP10);
}
inline uint32_t adc1_smpr2_get_smp18(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP18) >> 24; }
inline uint32_t adc1_smpr2_get_smp17(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP17) >> 21; }
inline uint32_t adc1_smpr2_get_smp16(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP16) >> 18; }
inline uint32_t adc1_smpr2_get_smp15(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP15) >> 15; }
inline uint32_t adc1_smpr2_get_smp14(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP14) >> 12; }
inline uint32_t adc1_smpr2_get_smp13(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP13) >> 9; }
inline uint32_t adc1_smpr2_get_smp12(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP12) >> 6; }
inline uint32_t adc1_smpr2_get_smp11(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP11) >> 3; }
inline uint32_t adc1_smpr2_get_smp10(struct ADC1_Type* p) { return (p->SMPR2 & ADC1_SMPR2_SMP10) >> 0; }

// ADC1->TR1 watchdog threshold register 1
enum {
	ADC1_TR1_HT1     = ((1UL << 12) - 1) << 16, // HT1
	ADC1_TR1_AWDFILT = ((1UL << 3) - 1) << 12,  // AWDFILT
	ADC1_TR1_LT1     = ((1UL << 12) - 1) << 0,  // LT1
};
inline void adc1_tr1_set_ht1(struct ADC1_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC1_TR1_HT1) | ((val << 16) & ADC1_TR1_HT1); }
inline void adc1_tr1_set_awdfilt(struct ADC1_Type* p, uint32_t val) {
	p->TR1 = (p->TR1 & ~ADC1_TR1_AWDFILT) | ((val << 12) & ADC1_TR1_AWDFILT);
}
inline void     adc1_tr1_set_lt1(struct ADC1_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC1_TR1_LT1) | ((val << 0) & ADC1_TR1_LT1); }
inline uint32_t adc1_tr1_get_ht1(struct ADC1_Type* p) { return (p->TR1 & ADC1_TR1_HT1) >> 16; }
inline uint32_t adc1_tr1_get_awdfilt(struct ADC1_Type* p) { return (p->TR1 & ADC1_TR1_AWDFILT) >> 12; }
inline uint32_t adc1_tr1_get_lt1(struct ADC1_Type* p) { return (p->TR1 & ADC1_TR1_LT1) >> 0; }

// ADC1->TR2 watchdog threshold register
enum {
	ADC1_TR2_HT2 = ((1UL << 8) - 1) << 16, // HT2
	ADC1_TR2_LT2 = ((1UL << 8) - 1) << 0,  // LT2
};
inline void     adc1_tr2_set_ht2(struct ADC1_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC1_TR2_HT2) | ((val << 16) & ADC1_TR2_HT2); }
inline void     adc1_tr2_set_lt2(struct ADC1_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC1_TR2_LT2) | ((val << 0) & ADC1_TR2_LT2); }
inline uint32_t adc1_tr2_get_ht2(struct ADC1_Type* p) { return (p->TR2 & ADC1_TR2_HT2) >> 16; }
inline uint32_t adc1_tr2_get_lt2(struct ADC1_Type* p) { return (p->TR2 & ADC1_TR2_LT2) >> 0; }

// ADC1->TR3 watchdog threshold register 3
enum {
	ADC1_TR3_HT3 = ((1UL << 8) - 1) << 16, // HT3
	ADC1_TR3_LT3 = ((1UL << 8) - 1) << 0,  // LT3
};
inline void     adc1_tr3_set_ht3(struct ADC1_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC1_TR3_HT3) | ((val << 16) & ADC1_TR3_HT3); }
inline void     adc1_tr3_set_lt3(struct ADC1_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC1_TR3_LT3) | ((val << 0) & ADC1_TR3_LT3); }
inline uint32_t adc1_tr3_get_ht3(struct ADC1_Type* p) { return (p->TR3 & ADC1_TR3_HT3) >> 16; }
inline uint32_t adc1_tr3_get_lt3(struct ADC1_Type* p) { return (p->TR3 & ADC1_TR3_LT3) >> 0; }

// ADC1->SQR1 regular sequence register 1
enum {
	ADC1_SQR1_SQ4 = ((1UL << 5) - 1) << 24, // SQ4
	ADC1_SQR1_SQ3 = ((1UL << 5) - 1) << 18, // SQ3
	ADC1_SQR1_SQ2 = ((1UL << 5) - 1) << 12, // SQ2
	ADC1_SQR1_SQ1 = ((1UL << 5) - 1) << 6,  // SQ1
	ADC1_SQR1_L   = ((1UL << 4) - 1) << 0,  // Regular channel sequence length
};
inline void adc1_sqr1_set_sq4(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ4) | ((val << 24) & ADC1_SQR1_SQ4); }
inline void adc1_sqr1_set_sq3(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ3) | ((val << 18) & ADC1_SQR1_SQ3); }
inline void adc1_sqr1_set_sq2(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ2) | ((val << 12) & ADC1_SQR1_SQ2); }
inline void adc1_sqr1_set_sq1(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_SQ1) | ((val << 6) & ADC1_SQR1_SQ1); }
inline void adc1_sqr1_set_l(struct ADC1_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC1_SQR1_L) | ((val << 0) & ADC1_SQR1_L); }
inline uint32_t adc1_sqr1_get_sq4(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ4) >> 24; }
inline uint32_t adc1_sqr1_get_sq3(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ3) >> 18; }
inline uint32_t adc1_sqr1_get_sq2(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ2) >> 12; }
inline uint32_t adc1_sqr1_get_sq1(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_SQ1) >> 6; }
inline uint32_t adc1_sqr1_get_l(struct ADC1_Type* p) { return (p->SQR1 & ADC1_SQR1_L) >> 0; }

// ADC1->SQR2 regular sequence register 2
enum {
	ADC1_SQR2_SQ9 = ((1UL << 5) - 1) << 24, // SQ9
	ADC1_SQR2_SQ8 = ((1UL << 5) - 1) << 18, // SQ8
	ADC1_SQR2_SQ7 = ((1UL << 5) - 1) << 12, // SQ7
	ADC1_SQR2_SQ6 = ((1UL << 5) - 1) << 6,  // SQ6
	ADC1_SQR2_SQ5 = ((1UL << 5) - 1) << 0,  // SQ5
};
inline void adc1_sqr2_set_sq9(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ9) | ((val << 24) & ADC1_SQR2_SQ9); }
inline void adc1_sqr2_set_sq8(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ8) | ((val << 18) & ADC1_SQR2_SQ8); }
inline void adc1_sqr2_set_sq7(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ7) | ((val << 12) & ADC1_SQR2_SQ7); }
inline void adc1_sqr2_set_sq6(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ6) | ((val << 6) & ADC1_SQR2_SQ6); }
inline void adc1_sqr2_set_sq5(struct ADC1_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC1_SQR2_SQ5) | ((val << 0) & ADC1_SQR2_SQ5); }
inline uint32_t adc1_sqr2_get_sq9(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ9) >> 24; }
inline uint32_t adc1_sqr2_get_sq8(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ8) >> 18; }
inline uint32_t adc1_sqr2_get_sq7(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ7) >> 12; }
inline uint32_t adc1_sqr2_get_sq6(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ6) >> 6; }
inline uint32_t adc1_sqr2_get_sq5(struct ADC1_Type* p) { return (p->SQR2 & ADC1_SQR2_SQ5) >> 0; }

// ADC1->SQR3 regular sequence register 3
enum {
	ADC1_SQR3_SQ14 = ((1UL << 5) - 1) << 24, // SQ14
	ADC1_SQR3_SQ13 = ((1UL << 5) - 1) << 18, // SQ13
	ADC1_SQR3_SQ12 = ((1UL << 5) - 1) << 12, // SQ12
	ADC1_SQR3_SQ11 = ((1UL << 5) - 1) << 6,  // SQ11
	ADC1_SQR3_SQ10 = ((1UL << 5) - 1) << 0,  // SQ10
};
inline void adc1_sqr3_set_sq14(struct ADC1_Type* p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ14) | ((val << 24) & ADC1_SQR3_SQ14);
}
inline void adc1_sqr3_set_sq13(struct ADC1_Type* p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ13) | ((val << 18) & ADC1_SQR3_SQ13);
}
inline void adc1_sqr3_set_sq12(struct ADC1_Type* p, uint32_t val) {
	p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ12) | ((val << 12) & ADC1_SQR3_SQ12);
}
inline void adc1_sqr3_set_sq11(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ11) | ((val << 6) & ADC1_SQR3_SQ11); }
inline void adc1_sqr3_set_sq10(struct ADC1_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC1_SQR3_SQ10) | ((val << 0) & ADC1_SQR3_SQ10); }
inline uint32_t adc1_sqr3_get_sq14(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ14) >> 24; }
inline uint32_t adc1_sqr3_get_sq13(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ13) >> 18; }
inline uint32_t adc1_sqr3_get_sq12(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ12) >> 12; }
inline uint32_t adc1_sqr3_get_sq11(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ11) >> 6; }
inline uint32_t adc1_sqr3_get_sq10(struct ADC1_Type* p) { return (p->SQR3 & ADC1_SQR3_SQ10) >> 0; }

// ADC1->SQR4 regular sequence register 4
enum {
	ADC1_SQR4_SQ16 = ((1UL << 5) - 1) << 6, // SQ16
	ADC1_SQR4_SQ15 = ((1UL << 5) - 1) << 0, // SQ15
};
inline void adc1_sqr4_set_sq16(struct ADC1_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC1_SQR4_SQ16) | ((val << 6) & ADC1_SQR4_SQ16); }
inline void adc1_sqr4_set_sq15(struct ADC1_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC1_SQR4_SQ15) | ((val << 0) & ADC1_SQR4_SQ15); }
inline uint32_t adc1_sqr4_get_sq16(struct ADC1_Type* p) { return (p->SQR4 & ADC1_SQR4_SQ16) >> 6; }
inline uint32_t adc1_sqr4_get_sq15(struct ADC1_Type* p) { return (p->SQR4 & ADC1_SQR4_SQ15) >> 0; }

// ADC1->JSQR injected sequence register
enum {
	ADC1_JSQR_JSQ4    = ((1UL << 5) - 1) << 27, // JSQ4
	ADC1_JSQR_JSQ3    = ((1UL << 5) - 1) << 21, // JSQ3
	ADC1_JSQR_JSQ2    = ((1UL << 5) - 1) << 15, // JSQ2
	ADC1_JSQR_JSQ1    = ((1UL << 5) - 1) << 9,  // JSQ1
	ADC1_JSQR_JEXTEN  = ((1UL << 2) - 1) << 7,  // JEXTEN
	ADC1_JSQR_JEXTSEL = ((1UL << 5) - 1) << 2,  // JEXTSEL
	ADC1_JSQR_JL      = ((1UL << 2) - 1) << 0,  // JL
};
inline void adc1_jsqr_set_jsq4(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ4) | ((val << 27) & ADC1_JSQR_JSQ4);
}
inline void adc1_jsqr_set_jsq3(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ3) | ((val << 21) & ADC1_JSQR_JSQ3);
}
inline void adc1_jsqr_set_jsq2(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ2) | ((val << 15) & ADC1_JSQR_JSQ2);
}
inline void adc1_jsqr_set_jsq1(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JSQ1) | ((val << 9) & ADC1_JSQR_JSQ1); }
inline void adc1_jsqr_set_jexten(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JEXTEN) | ((val << 7) & ADC1_JSQR_JEXTEN);
}
inline void adc1_jsqr_set_jextsel(struct ADC1_Type* p, uint32_t val) {
	p->JSQR = (p->JSQR & ~ADC1_JSQR_JEXTSEL) | ((val << 2) & ADC1_JSQR_JEXTSEL);
}
inline void     adc1_jsqr_set_jl(struct ADC1_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC1_JSQR_JL) | ((val << 0) & ADC1_JSQR_JL); }
inline uint32_t adc1_jsqr_get_jsq4(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ4) >> 27; }
inline uint32_t adc1_jsqr_get_jsq3(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ3) >> 21; }
inline uint32_t adc1_jsqr_get_jsq2(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ2) >> 15; }
inline uint32_t adc1_jsqr_get_jsq1(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JSQ1) >> 9; }
inline uint32_t adc1_jsqr_get_jexten(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JEXTEN) >> 7; }
inline uint32_t adc1_jsqr_get_jextsel(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JEXTSEL) >> 2; }
inline uint32_t adc1_jsqr_get_jl(struct ADC1_Type* p) { return (p->JSQR & ADC1_JSQR_JL) >> 0; }

// ADC1->OFR1 offset register 1
enum {
	ADC1_OFR1_OFFSET1_EN = 1UL << 31,              // OFFSET1_EN
	ADC1_OFR1_OFFSET1_CH = ((1UL << 5) - 1) << 26, // OFFSET1_CH
	ADC1_OFR1_SATEN      = 1UL << 25,              // SATEN
	ADC1_OFR1_OFFSETPOS  = 1UL << 24,              // OFFSETPOS
	ADC1_OFR1_OFFSET1    = ((1UL << 12) - 1) << 0, // OFFSET1
};
inline void adc1_ofr1_set_offset1_ch(struct ADC1_Type* p, uint32_t val) {
	p->OFR1 = (p->OFR1 & ~ADC1_OFR1_OFFSET1_CH) | ((val << 26) & ADC1_OFR1_OFFSET1_CH);
}
inline void adc1_ofr1_set_offset1(struct ADC1_Type* p, uint32_t val) {
	p->OFR1 = (p->OFR1 & ~ADC1_OFR1_OFFSET1) | ((val << 0) & ADC1_OFR1_OFFSET1);
}
inline uint32_t adc1_ofr1_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR1 & ADC1_OFR1_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr1_get_offset1(struct ADC1_Type* p) { return (p->OFR1 & ADC1_OFR1_OFFSET1) >> 0; }

// ADC1->OFR2 offset register 2
enum {
	ADC1_OFR2_OFFSET1_EN = 1UL << 31,              // OFFSET1_EN
	ADC1_OFR2_OFFSET1_CH = ((1UL << 5) - 1) << 26, // OFFSET1_CH
	ADC1_OFR2_SATEN      = 1UL << 25,              // SATEN
	ADC1_OFR2_OFFSETPOS  = 1UL << 24,              // OFFSETPOS
	ADC1_OFR2_OFFSET1    = ((1UL << 12) - 1) << 0, // OFFSET1
};
inline void adc1_ofr2_set_offset1_ch(struct ADC1_Type* p, uint32_t val) {
	p->OFR2 = (p->OFR2 & ~ADC1_OFR2_OFFSET1_CH) | ((val << 26) & ADC1_OFR2_OFFSET1_CH);
}
inline void adc1_ofr2_set_offset1(struct ADC1_Type* p, uint32_t val) {
	p->OFR2 = (p->OFR2 & ~ADC1_OFR2_OFFSET1) | ((val << 0) & ADC1_OFR2_OFFSET1);
}
inline uint32_t adc1_ofr2_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR2 & ADC1_OFR2_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr2_get_offset1(struct ADC1_Type* p) { return (p->OFR2 & ADC1_OFR2_OFFSET1) >> 0; }

// ADC1->OFR3 offset register 3
enum {
	ADC1_OFR3_OFFSET1_EN = 1UL << 31,              // OFFSET1_EN
	ADC1_OFR3_OFFSET1_CH = ((1UL << 5) - 1) << 26, // OFFSET1_CH
	ADC1_OFR3_SATEN      = 1UL << 25,              // SATEN
	ADC1_OFR3_OFFSETPOS  = 1UL << 24,              // OFFSETPOS
	ADC1_OFR3_OFFSET1    = ((1UL << 12) - 1) << 0, // OFFSET1
};
inline void adc1_ofr3_set_offset1_ch(struct ADC1_Type* p, uint32_t val) {
	p->OFR3 = (p->OFR3 & ~ADC1_OFR3_OFFSET1_CH) | ((val << 26) & ADC1_OFR3_OFFSET1_CH);
}
inline void adc1_ofr3_set_offset1(struct ADC1_Type* p, uint32_t val) {
	p->OFR3 = (p->OFR3 & ~ADC1_OFR3_OFFSET1) | ((val << 0) & ADC1_OFR3_OFFSET1);
}
inline uint32_t adc1_ofr3_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR3 & ADC1_OFR3_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr3_get_offset1(struct ADC1_Type* p) { return (p->OFR3 & ADC1_OFR3_OFFSET1) >> 0; }

// ADC1->OFR4 offset register 4
enum {
	ADC1_OFR4_OFFSET1_EN = 1UL << 31,              // OFFSET1_EN
	ADC1_OFR4_OFFSET1_CH = ((1UL << 5) - 1) << 26, // OFFSET1_CH
	ADC1_OFR4_SATEN      = 1UL << 25,              // SATEN
	ADC1_OFR4_OFFSETPOS  = 1UL << 24,              // OFFSETPOS
	ADC1_OFR4_OFFSET1    = ((1UL << 12) - 1) << 0, // OFFSET1
};
inline void adc1_ofr4_set_offset1_ch(struct ADC1_Type* p, uint32_t val) {
	p->OFR4 = (p->OFR4 & ~ADC1_OFR4_OFFSET1_CH) | ((val << 26) & ADC1_OFR4_OFFSET1_CH);
}
inline void adc1_ofr4_set_offset1(struct ADC1_Type* p, uint32_t val) {
	p->OFR4 = (p->OFR4 & ~ADC1_OFR4_OFFSET1) | ((val << 0) & ADC1_OFR4_OFFSET1);
}
inline uint32_t adc1_ofr4_get_offset1_ch(struct ADC1_Type* p) { return (p->OFR4 & ADC1_OFR4_OFFSET1_CH) >> 26; }
inline uint32_t adc1_ofr4_get_offset1(struct ADC1_Type* p) { return (p->OFR4 & ADC1_OFR4_OFFSET1) >> 0; }

// ADC1->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC1_AWD2CR_AWD2CH = ((1UL << 19) - 1) << 0, // AWD2CH
};
inline void adc1_awd2cr_set_awd2ch(struct ADC1_Type* p, uint32_t val) {
	p->AWD2CR = (p->AWD2CR & ~ADC1_AWD2CR_AWD2CH) | ((val << 0) & ADC1_AWD2CR_AWD2CH);
}
inline uint32_t adc1_awd2cr_get_awd2ch(struct ADC1_Type* p) { return (p->AWD2CR & ADC1_AWD2CR_AWD2CH) >> 0; }

// ADC1->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC1_AWD3CR_AWD3CH = ((1UL << 19) - 1) << 0, // AWD3CH
};
inline void adc1_awd3cr_set_awd3ch(struct ADC1_Type* p, uint32_t val) {
	p->AWD3CR = (p->AWD3CR & ~ADC1_AWD3CR_AWD3CH) | ((val << 0) & ADC1_AWD3CR_AWD3CH);
}
inline uint32_t adc1_awd3cr_get_awd3ch(struct ADC1_Type* p) { return (p->AWD3CR & ADC1_AWD3CR_AWD3CH) >> 0; }

// ADC1->DIFSEL Differential Mode Selection Register 2
enum {
	ADC1_DIFSEL_DIFSEL_1_18 = ((1UL << 18) - 1) << 1, // Differential mode for channels 15 to 1
	ADC1_DIFSEL_DIFSEL_0    = 1UL << 0,               // Differential mode for channels 0
};
inline void adc1_difsel_set_difsel_1_18(struct ADC1_Type* p, uint32_t val) {
	p->DIFSEL = (p->DIFSEL & ~ADC1_DIFSEL_DIFSEL_1_18) | ((val << 1) & ADC1_DIFSEL_DIFSEL_1_18);
}
inline uint32_t adc1_difsel_get_difsel_1_18(struct ADC1_Type* p) { return (p->DIFSEL & ADC1_DIFSEL_DIFSEL_1_18) >> 1; }

// ADC1->CALFACT Calibration Factors
enum {
	ADC1_CALFACT_CALFACT_D = ((1UL << 7) - 1) << 16, // CALFACT_D
	ADC1_CALFACT_CALFACT_S = ((1UL << 7) - 1) << 0,  // CALFACT_S
};
inline void adc1_calfact_set_calfact_d(struct ADC1_Type* p, uint32_t val) {
	p->CALFACT = (p->CALFACT & ~ADC1_CALFACT_CALFACT_D) | ((val << 16) & ADC1_CALFACT_CALFACT_D);
}
inline void adc1_calfact_set_calfact_s(struct ADC1_Type* p, uint32_t val) {
	p->CALFACT = (p->CALFACT & ~ADC1_CALFACT_CALFACT_S) | ((val << 0) & ADC1_CALFACT_CALFACT_S);
}
inline uint32_t adc1_calfact_get_calfact_d(struct ADC1_Type* p) { return (p->CALFACT & ADC1_CALFACT_CALFACT_D) >> 16; }
inline uint32_t adc1_calfact_get_calfact_s(struct ADC1_Type* p) { return (p->CALFACT & ADC1_CALFACT_CALFACT_S) >> 0; }

// ADC1->GCOMP Gain compensation Register
enum {
	ADC1_GCOMP_GCOMPCOEFF = ((1UL << 14) - 1) << 0, // GCOMPCOEFF
};
inline void adc1_gcomp_set_gcompcoeff(struct ADC1_Type* p, uint32_t val) {
	p->GCOMP = (p->GCOMP & ~ADC1_GCOMP_GCOMPCOEFF) | ((val << 0) & ADC1_GCOMP_GCOMPCOEFF);
}
inline uint32_t adc1_gcomp_get_gcompcoeff(struct ADC1_Type* p) { return (p->GCOMP & ADC1_GCOMP_GCOMPCOEFF) >> 0; }

/* Analog-to-Digital Converter */
struct ADC12_Common_Type {
	__I uint32_t  CSR;          // @0 ADC Common status register
	uint8_t       RESERVED0[4]; // @4
	__IO uint32_t CCR;          // @8 ADC common control register
	__I uint32_t  CDR;          // @12 ADC common regular data register for dual and triple modes
};

// ADC12_Common->CSR ADC Common status register
enum {
	ADC12_COMMON_CSR_JQOVF_SLV  = 1UL << 26, // Injected Context Queue Overflow flag of the slave ADC
	ADC12_COMMON_CSR_AWD3_SLV   = 1UL << 25, // Analog watchdog 3 flag of the slave ADC
	ADC12_COMMON_CSR_AWD2_SLV   = 1UL << 24, // Analog watchdog 2 flag of the slave ADC
	ADC12_COMMON_CSR_AWD1_SLV   = 1UL << 23, // Analog watchdog 1 flag of the slave ADC
	ADC12_COMMON_CSR_JEOS_SLV   = 1UL << 22, // End of injected sequence flag of the slave ADC
	ADC12_COMMON_CSR_JEOC_SLV   = 1UL << 21, // End of injected conversion flag of the slave ADC
	ADC12_COMMON_CSR_OVR_SLV    = 1UL << 20, // Overrun flag of the slave ADC
	ADC12_COMMON_CSR_EOS_SLV    = 1UL << 19, // End of regular sequence flag of the slave ADC
	ADC12_COMMON_CSR_EOC_SLV    = 1UL << 18, // End of regular conversion of the slave ADC
	ADC12_COMMON_CSR_EOSMP_SLV  = 1UL << 17, // EOSMP_SLV
	ADC12_COMMON_CSR_ADRDY_SLV  = 1UL << 16, // ADRDY_SLV
	ADC12_COMMON_CSR_JQOVF_MST  = 1UL << 10, // JQOVF_MST
	ADC12_COMMON_CSR_AWD3_MST   = 1UL << 9,  // AWD3_MST
	ADC12_COMMON_CSR_AWD2_MST   = 1UL << 8,  // AWD2_MST
	ADC12_COMMON_CSR_AWD1_MST   = 1UL << 7,  // AWD1_MST
	ADC12_COMMON_CSR_JEOS_MST   = 1UL << 6,  // JEOS_MST
	ADC12_COMMON_CSR_JEOC_MST   = 1UL << 5,  // JEOC_MST
	ADC12_COMMON_CSR_OVR_MST    = 1UL << 4,  // OVR_MST
	ADC12_COMMON_CSR_EOS_MST    = 1UL << 3,  // EOS_MST
	ADC12_COMMON_CSR_EOC_MST    = 1UL << 2,  // EOC_MST
	ADC12_COMMON_CSR_EOSMP_MST  = 1UL << 1,  // EOSMP_MST
	ADC12_COMMON_CSR_ADDRDY_MST = 1UL << 0,  // ADDRDY_MST
};

// ADC12_Common->CCR ADC common control register
enum {
	ADC12_COMMON_CCR_CH18SEL = 1UL << 24,              // CH18 selection
	ADC12_COMMON_CCR_CH17SEL = 1UL << 23,              // CH17 selection
	ADC12_COMMON_CCR_VREFEN  = 1UL << 22,              // VREFINT enable
	ADC12_COMMON_CCR_PRESC   = ((1UL << 4) - 1) << 18, // ADC prescaler
	ADC12_COMMON_CCR_CKMODE  = ((1UL << 2) - 1) << 16, // ADC clock mode
	ADC12_COMMON_CCR_MDMA    = ((1UL << 2) - 1) << 14, // Direct memory access mode for multi ADC mode
	ADC12_COMMON_CCR_DMACFG  = 1UL << 13,              // DMA configuration (for multi-ADC mode)
	ADC12_COMMON_CCR_DELAY   = ((1UL << 4) - 1) << 8,  // Delay between 2 sampling phases
	ADC12_COMMON_CCR_DUAL    = ((1UL << 5) - 1) << 0,  // Dual ADC mode selection
};
inline void adc12_common_ccr_set_presc(struct ADC12_Common_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_PRESC) | ((val << 18) & ADC12_COMMON_CCR_PRESC);
}
inline void adc12_common_ccr_set_ckmode(struct ADC12_Common_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_CKMODE) | ((val << 16) & ADC12_COMMON_CCR_CKMODE);
}
inline void adc12_common_ccr_set_mdma(struct ADC12_Common_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_MDMA) | ((val << 14) & ADC12_COMMON_CCR_MDMA);
}
inline void adc12_common_ccr_set_delay(struct ADC12_Common_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_DELAY) | ((val << 8) & ADC12_COMMON_CCR_DELAY);
}
inline void adc12_common_ccr_set_dual(struct ADC12_Common_Type* p, uint32_t val) {
	p->CCR = (p->CCR & ~ADC12_COMMON_CCR_DUAL) | ((val << 0) & ADC12_COMMON_CCR_DUAL);
}
inline uint32_t adc12_common_ccr_get_presc(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_PRESC) >> 18; }
inline uint32_t adc12_common_ccr_get_ckmode(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_CKMODE) >> 16; }
inline uint32_t adc12_common_ccr_get_mdma(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_MDMA) >> 14; }
inline uint32_t adc12_common_ccr_get_delay(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_DELAY) >> 8; }
inline uint32_t adc12_common_ccr_get_dual(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_DUAL) >> 0; }

// ADC12_Common->CDR ADC common regular data register for dual and triple modes
enum {
	ADC12_COMMON_CDR_RDATA_SLV = ((1UL << 16) - 1) << 16, // Regular data of the slave ADC
	ADC12_COMMON_CDR_RDATA_MST = ((1UL << 16) - 1) << 0,  // Regular data of the master ADC
};
inline uint32_t adc12_common_cdr_get_rdata_slv(struct ADC12_Common_Type* p) { return (p->CDR & ADC12_COMMON_CDR_RDATA_SLV) >> 16; }
inline uint32_t adc12_common_cdr_get_rdata_mst(struct ADC12_Common_Type* p) { return (p->CDR & ADC12_COMMON_CDR_RDATA_MST) >> 0; }

/* Advanced encryption standard hardware accelerator */
struct AES_Type {
	__IO uint32_t CR;           // @0 control register
	__I uint8_t   SR;           // @4 status register
	uint8_t       RESERVED0[3]; // @5
	__IO uint32_t DINR;         // @8 data input register
	__I uint32_t  DOUTR;        // @12 data output register
	__IO uint32_t KEYR0;        // @16 key register 0
	__IO uint32_t KEYR1;        // @20 key register 1
	__IO uint32_t KEYR2;        // @24 key register 2
	__IO uint32_t KEYR3;        // @28 key register 3
	__IO uint32_t IVR0;         // @32 initialization vector register 0
	__IO uint32_t IVR1;         // @36 initialization vector register 1
	__IO uint32_t IVR2;         // @40 initialization vector register 2
	__IO uint32_t IVR3;         // @44 initialization vector register 3
	__IO uint32_t KEYR4;        // @48 key register 4
	__IO uint32_t KEYR5;        // @52 key register 5
	__IO uint32_t KEYR6;        // @56 key register 6
	__IO uint32_t KEYR7;        // @60 key register 7
	__IO uint32_t SUSP0R;       // @64 suspend registers
	__IO uint32_t SUSP1R;       // @68 suspend registers
	__IO uint32_t SUSP2R;       // @72 suspend registers
	__IO uint32_t SUSP3R;       // @76 suspend registers
	__IO uint32_t SUSP4R;       // @80 suspend registers
	__IO uint32_t SUSP5R;       // @84 suspend registers
	__IO uint32_t SUSP6R;       // @88 suspend registers
	__IO uint32_t SUSP7R;       // @92 suspend registers
};

// AES->CR control register
enum {
	AES_CR_NPBLB    = ((1UL << 4) - 1) << 20, // NPBLB
	AES_CR_KEYSIZE  = 1UL << 18,              // KEYSIZE
	AES_CR_CHMOD_2  = 1UL << 16,              // CHMOD_2
	AES_CR_GCMPH    = ((1UL << 2) - 1) << 13, // GCMPH
	AES_CR_DMAOUTEN = 1UL << 12,              // Enable DMA management of data output phase
	AES_CR_DMAINEN  = 1UL << 11,              // Enable DMA management of data input phase
	AES_CR_ERRIE    = 1UL << 10,              // Error interrupt enable
	AES_CR_CCFIE    = 1UL << 9,               // CCF flag interrupt enable
	AES_CR_ERRC     = 1UL << 8,               // Error clear
	AES_CR_CCFC     = 1UL << 7,               // Computation Complete Flag Clear
	AES_CR_CHMOD    = ((1UL << 2) - 1) << 5,  // AES chaining mode
	AES_CR_MODE     = ((1UL << 2) - 1) << 3,  // AES operating mode
	AES_CR_DATATYPE = ((1UL << 2) - 1) << 1,  // Data type selection (for data in and data out to/from the cryptographic block)
	AES_CR_EN       = 1UL << 0,               // AES enable
};
inline void aes_cr_set_npblb(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_NPBLB) | ((val << 20) & AES_CR_NPBLB); }
inline void aes_cr_set_gcmph(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_GCMPH) | ((val << 13) & AES_CR_GCMPH); }
inline void aes_cr_set_chmod(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_CHMOD) | ((val << 5) & AES_CR_CHMOD); }
inline void aes_cr_set_mode(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_MODE) | ((val << 3) & AES_CR_MODE); }
inline void aes_cr_set_datatype(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_DATATYPE) | ((val << 1) & AES_CR_DATATYPE); }
inline uint32_t aes_cr_get_npblb(struct AES_Type* p) { return (p->CR & AES_CR_NPBLB) >> 20; }
inline uint32_t aes_cr_get_gcmph(struct AES_Type* p) { return (p->CR & AES_CR_GCMPH) >> 13; }
inline uint32_t aes_cr_get_chmod(struct AES_Type* p) { return (p->CR & AES_CR_CHMOD) >> 5; }
inline uint32_t aes_cr_get_mode(struct AES_Type* p) { return (p->CR & AES_CR_MODE) >> 3; }
inline uint32_t aes_cr_get_datatype(struct AES_Type* p) { return (p->CR & AES_CR_DATATYPE) >> 1; }

// AES->SR status register
enum {
	AES_SR_BUSY  = 1UL << 3, // BUSY
	AES_SR_WRERR = 1UL << 2, // Write error flag
	AES_SR_RDERR = 1UL << 1, // Read error flag
	AES_SR_CCF   = 1UL << 0, // Computation complete flag
};

/* Comparator control and status register */
struct COMP_Type {
	__IO uint32_t COMP_C1CSR; // @0 Comparator control/status register
	__IO uint32_t COMP_C2CSR; // @4 Comparator control/status register
	__IO uint32_t COMP_C3CSR; // @8 Comparator control/status register
	__IO uint32_t COMP_C4CSR; // @12 Comparator control/status register
};

// COMP->COMP_C1CSR Comparator control/status register
enum {
	COMP_COMP_C1CSR_LOCK             = 1UL << 31,              // LOCK
	COMP_COMP_C1CSR_VALUE            = 1UL << 30,              // VALUE
	COMP_COMP_C1CSR_SCALEN           = 1UL << 23,              // SCALEN
	COMP_COMP_C1CSR_BRGEN            = 1UL << 22,              // BRGEN
	COMP_COMP_C1CSR_BLANKSEL         = ((1UL << 3) - 1) << 19, // BLANKSEL
	COMP_COMP_C1CSR_HYST             = ((1UL << 3) - 1) << 16, // HYST
	COMP_COMP_C1CSR_POL              = 1UL << 15,              // POL
	COMP_COMP_C1CSR_INPSEL           = 1UL << 8,               // INPSEL
	COMP_COMP_C1CSR_INMSEL           = ((1UL << 3) - 1) << 4,  // INMSEL
	COMP_COMP_C1CSR_COMP_DEGLITCH_EN = 1UL << 1,               // COMP_DEGLITCH_EN
	COMP_COMP_C1CSR_EN               = 1UL << 0,               // EN
};
inline void comp_comp_c1csr_set_blanksel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C1CSR = (p->COMP_C1CSR & ~COMP_COMP_C1CSR_BLANKSEL) | ((val << 19) & COMP_COMP_C1CSR_BLANKSEL);
}
inline void comp_comp_c1csr_set_hyst(struct COMP_Type* p, uint32_t val) {
	p->COMP_C1CSR = (p->COMP_C1CSR & ~COMP_COMP_C1CSR_HYST) | ((val << 16) & COMP_COMP_C1CSR_HYST);
}
inline void comp_comp_c1csr_set_inmsel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C1CSR = (p->COMP_C1CSR & ~COMP_COMP_C1CSR_INMSEL) | ((val << 4) & COMP_COMP_C1CSR_INMSEL);
}
inline uint32_t comp_comp_c1csr_get_blanksel(struct COMP_Type* p) { return (p->COMP_C1CSR & COMP_COMP_C1CSR_BLANKSEL) >> 19; }
inline uint32_t comp_comp_c1csr_get_hyst(struct COMP_Type* p) { return (p->COMP_C1CSR & COMP_COMP_C1CSR_HYST) >> 16; }
inline uint32_t comp_comp_c1csr_get_inmsel(struct COMP_Type* p) { return (p->COMP_C1CSR & COMP_COMP_C1CSR_INMSEL) >> 4; }

// COMP->COMP_C2CSR Comparator control/status register
enum {
	COMP_COMP_C2CSR_LOCK             = 1UL << 31,              // LOCK
	COMP_COMP_C2CSR_VALUE            = 1UL << 30,              // VALUE
	COMP_COMP_C2CSR_SCALEN           = 1UL << 23,              // SCALEN
	COMP_COMP_C2CSR_BRGEN            = 1UL << 22,              // BRGEN
	COMP_COMP_C2CSR_BLANKSEL         = ((1UL << 3) - 1) << 19, // BLANKSEL
	COMP_COMP_C2CSR_HYST             = ((1UL << 3) - 1) << 16, // HYST
	COMP_COMP_C2CSR_POL              = 1UL << 15,              // POL
	COMP_COMP_C2CSR_INPSEL           = 1UL << 8,               // INPSEL
	COMP_COMP_C2CSR_INMSEL           = ((1UL << 3) - 1) << 4,  // INMSEL
	COMP_COMP_C2CSR_COMP_DEGLITCH_EN = 1UL << 1,               // COMP_DEGLITCH_EN
	COMP_COMP_C2CSR_EN               = 1UL << 0,               // EN
};
inline void comp_comp_c2csr_set_blanksel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C2CSR = (p->COMP_C2CSR & ~COMP_COMP_C2CSR_BLANKSEL) | ((val << 19) & COMP_COMP_C2CSR_BLANKSEL);
}
inline void comp_comp_c2csr_set_hyst(struct COMP_Type* p, uint32_t val) {
	p->COMP_C2CSR = (p->COMP_C2CSR & ~COMP_COMP_C2CSR_HYST) | ((val << 16) & COMP_COMP_C2CSR_HYST);
}
inline void comp_comp_c2csr_set_inmsel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C2CSR = (p->COMP_C2CSR & ~COMP_COMP_C2CSR_INMSEL) | ((val << 4) & COMP_COMP_C2CSR_INMSEL);
}
inline uint32_t comp_comp_c2csr_get_blanksel(struct COMP_Type* p) { return (p->COMP_C2CSR & COMP_COMP_C2CSR_BLANKSEL) >> 19; }
inline uint32_t comp_comp_c2csr_get_hyst(struct COMP_Type* p) { return (p->COMP_C2CSR & COMP_COMP_C2CSR_HYST) >> 16; }
inline uint32_t comp_comp_c2csr_get_inmsel(struct COMP_Type* p) { return (p->COMP_C2CSR & COMP_COMP_C2CSR_INMSEL) >> 4; }

// COMP->COMP_C3CSR Comparator control/status register
enum {
	COMP_COMP_C3CSR_LOCK             = 1UL << 31,              // LOCK
	COMP_COMP_C3CSR_VALUE            = 1UL << 30,              // VALUE
	COMP_COMP_C3CSR_SCALEN           = 1UL << 23,              // SCALEN
	COMP_COMP_C3CSR_BRGEN            = 1UL << 22,              // BRGEN
	COMP_COMP_C3CSR_BLANKSEL         = ((1UL << 3) - 1) << 19, // BLANKSEL
	COMP_COMP_C3CSR_HYST             = ((1UL << 3) - 1) << 16, // HYST
	COMP_COMP_C3CSR_POL              = 1UL << 15,              // POL
	COMP_COMP_C3CSR_INPSEL           = 1UL << 8,               // INPSEL
	COMP_COMP_C3CSR_INMSEL           = ((1UL << 3) - 1) << 4,  // INMSEL
	COMP_COMP_C3CSR_COMP_DEGLITCH_EN = 1UL << 1,               // COMP_DEGLITCH_EN
	COMP_COMP_C3CSR_EN               = 1UL << 0,               // EN
};
inline void comp_comp_c3csr_set_blanksel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C3CSR = (p->COMP_C3CSR & ~COMP_COMP_C3CSR_BLANKSEL) | ((val << 19) & COMP_COMP_C3CSR_BLANKSEL);
}
inline void comp_comp_c3csr_set_hyst(struct COMP_Type* p, uint32_t val) {
	p->COMP_C3CSR = (p->COMP_C3CSR & ~COMP_COMP_C3CSR_HYST) | ((val << 16) & COMP_COMP_C3CSR_HYST);
}
inline void comp_comp_c3csr_set_inmsel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C3CSR = (p->COMP_C3CSR & ~COMP_COMP_C3CSR_INMSEL) | ((val << 4) & COMP_COMP_C3CSR_INMSEL);
}
inline uint32_t comp_comp_c3csr_get_blanksel(struct COMP_Type* p) { return (p->COMP_C3CSR & COMP_COMP_C3CSR_BLANKSEL) >> 19; }
inline uint32_t comp_comp_c3csr_get_hyst(struct COMP_Type* p) { return (p->COMP_C3CSR & COMP_COMP_C3CSR_HYST) >> 16; }
inline uint32_t comp_comp_c3csr_get_inmsel(struct COMP_Type* p) { return (p->COMP_C3CSR & COMP_COMP_C3CSR_INMSEL) >> 4; }

// COMP->COMP_C4CSR Comparator control/status register
enum {
	COMP_COMP_C4CSR_LOCK             = 1UL << 31,              // LOCK
	COMP_COMP_C4CSR_VALUE            = 1UL << 30,              // VALUE
	COMP_COMP_C4CSR_SCALEN           = 1UL << 23,              // SCALEN
	COMP_COMP_C4CSR_BRGEN            = 1UL << 22,              // BRGEN
	COMP_COMP_C4CSR_BLANKSEL         = ((1UL << 3) - 1) << 19, // BLANKSEL
	COMP_COMP_C4CSR_HYST             = ((1UL << 3) - 1) << 16, // HYST
	COMP_COMP_C4CSR_POL              = 1UL << 15,              // POL
	COMP_COMP_C4CSR_INPSEL           = 1UL << 8,               // INPSEL
	COMP_COMP_C4CSR_INMSEL           = ((1UL << 3) - 1) << 4,  // INMSEL
	COMP_COMP_C4CSR_COMP_DEGLITCH_EN = 1UL << 1,               // COMP_DEGLITCH_EN
	COMP_COMP_C4CSR_EN               = 1UL << 0,               // EN
};
inline void comp_comp_c4csr_set_blanksel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C4CSR = (p->COMP_C4CSR & ~COMP_COMP_C4CSR_BLANKSEL) | ((val << 19) & COMP_COMP_C4CSR_BLANKSEL);
}
inline void comp_comp_c4csr_set_hyst(struct COMP_Type* p, uint32_t val) {
	p->COMP_C4CSR = (p->COMP_C4CSR & ~COMP_COMP_C4CSR_HYST) | ((val << 16) & COMP_COMP_C4CSR_HYST);
}
inline void comp_comp_c4csr_set_inmsel(struct COMP_Type* p, uint32_t val) {
	p->COMP_C4CSR = (p->COMP_C4CSR & ~COMP_COMP_C4CSR_INMSEL) | ((val << 4) & COMP_COMP_C4CSR_INMSEL);
}
inline uint32_t comp_comp_c4csr_get_blanksel(struct COMP_Type* p) { return (p->COMP_C4CSR & COMP_COMP_C4CSR_BLANKSEL) >> 19; }
inline uint32_t comp_comp_c4csr_get_hyst(struct COMP_Type* p) { return (p->COMP_C4CSR & COMP_COMP_C4CSR_HYST) >> 16; }
inline uint32_t comp_comp_c4csr_get_inmsel(struct COMP_Type* p) { return (p->COMP_C4CSR & COMP_COMP_C4CSR_INMSEL) >> 4; }

/* CORDIC Co-processor */
struct CORDIC_Type {
	__IO uint32_t CSR;   // @0 CORDIC Control Status register
	__IO uint32_t WDATA; // @4 FMAC Write Data register
	__I uint32_t  RDATA; // @8 FMAC Read Data register
};

// CORDIC->CSR CORDIC Control Status register
enum {
	CORDIC_CSR_RRDY      = 1UL << 31,             // RRDY
	CORDIC_CSR_ARGSIZE   = 1UL << 22,             // ARGSIZE
	CORDIC_CSR_RESSIZE   = 1UL << 21,             // RESSIZE
	CORDIC_CSR_NARGS     = 1UL << 20,             // NARGS
	CORDIC_CSR_NRES      = 1UL << 19,             // NRES
	CORDIC_CSR_DMAWEN    = 1UL << 18,             // DMAWEN
	CORDIC_CSR_DMAREN    = 1UL << 17,             // DMAREN
	CORDIC_CSR_IEN       = 1UL << 16,             // IEN
	CORDIC_CSR_SCALE     = ((1UL << 3) - 1) << 8, // SCALE
	CORDIC_CSR_PRECISION = ((1UL << 4) - 1) << 4, // PRECISION
	CORDIC_CSR_FUNC      = ((1UL << 4) - 1) << 0, // FUNC
};
inline void cordic_csr_set_scale(struct CORDIC_Type* p, uint32_t val) {
	p->CSR = (p->CSR & ~CORDIC_CSR_SCALE) | ((val << 8) & CORDIC_CSR_SCALE);
}
inline void cordic_csr_set_precision(struct CORDIC_Type* p, uint32_t val) {
	p->CSR = (p->CSR & ~CORDIC_CSR_PRECISION) | ((val << 4) & CORDIC_CSR_PRECISION);
}
inline void cordic_csr_set_func(struct CORDIC_Type* p, uint32_t val) {
	p->CSR = (p->CSR & ~CORDIC_CSR_FUNC) | ((val << 0) & CORDIC_CSR_FUNC);
}
inline uint32_t cordic_csr_get_scale(struct CORDIC_Type* p) { return (p->CSR & CORDIC_CSR_SCALE) >> 8; }
inline uint32_t cordic_csr_get_precision(struct CORDIC_Type* p) { return (p->CSR & CORDIC_CSR_PRECISION) >> 4; }
inline uint32_t cordic_csr_get_func(struct CORDIC_Type* p) { return (p->CSR & CORDIC_CSR_FUNC) >> 0; }

/* Cyclic redundancy check calculation unit */
struct CRC_Type {
	__IO uint32_t DR;           // @0 Data register
	__IO uint32_t IDR;          // @4 Independent data register
	__IO uint8_t  CR;           // @8 Control register
	uint8_t       RESERVED0[7]; // @9
	__IO uint32_t INIT;         // @16 Initial CRC value
	__IO uint32_t POL;          // @20 polynomial
};

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT  = 1UL << 7,              // Reverse output data
	CRC_CR_REV_IN   = ((1UL << 2) - 1) << 5, // Reverse input data
	CRC_CR_POLYSIZE = ((1UL << 2) - 1) << 3, // Polynomial size
	CRC_CR_RESET    = 1UL << 0,              // RESET bit
};
inline void crc_cr_set_rev_in(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_REV_IN) | ((val << 5) & CRC_CR_REV_IN); }
inline void crc_cr_set_polysize(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_POLYSIZE) | ((val << 3) & CRC_CR_POLYSIZE); }
inline uint32_t crc_cr_get_rev_in(struct CRC_Type* p) { return (p->CR & CRC_CR_REV_IN) >> 5; }
inline uint32_t crc_cr_get_polysize(struct CRC_Type* p) { return (p->CR & CRC_CR_POLYSIZE) >> 3; }

/* CRS */
struct CRS_Type {
	__IO uint16_t CR;           // @0 CRS control register
	uint8_t       RESERVED0[2]; // @2
	__IO uint32_t CFGR; // @4 This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR).
	                    // When the counter is enabled, this register is write-protected.
	__I uint32_t ISR;   // @8 CRS interrupt and status register
	__IO uint8_t ICR;   // @12 CRS interrupt flag clear register
};

// CRS->CR CRS control register
enum {
	CRS_CR_TRIM = ((1UL << 7) - 1)
	              << 8, // HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator.
	                    // They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the
	                    // HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is
	                    // around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency.
	                    // When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
	CRS_CR_SWSYNC = 1UL << 7, // Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is
	                          // automatically cleared by hardware.
	CRS_CR_AUTOTRIMEN =
	    1UL << 6, // Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured
	              // frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be
	              // adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to
	              // Section7.3.4: Frequency error evaluation and automatic trimming for more details.
	CRS_CR_CEN = 1UL << 5, // Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When
	                       // this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
	CRS_CR_ESYNCIE    = 1UL << 3, // Expected SYNC interrupt enable
	CRS_CR_ERRIE      = 1UL << 2, // Synchronization or trimming error interrupt enable
	CRS_CR_SYNCWARNIE = 1UL << 1, // SYNC warning interrupt enable
	CRS_CR_SYNCOKIE   = 1UL << 0, // SYNC event OK interrupt enable
};
inline void     crs_cr_set_trim(struct CRS_Type* p, uint32_t val) { p->CR = (p->CR & ~CRS_CR_TRIM) | ((val << 8) & CRS_CR_TRIM); }
inline uint32_t crs_cr_get_trim(struct CRS_Type* p) { return (p->CR & CRS_CR_TRIM) >> 8; }

// CRS->CFGR This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter
// is enabled, this register is write-protected.
enum {
	CRS_CFGR_SYNCPOL =
	    1UL
	    << 31, // SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
	CRS_CFGR_SYNCSRC =
	    ((1UL << 2) - 1)
	    << 28, // SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using
	           // USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host.
	           // No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock
	           // precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
	CRS_CFGR_SYNCDIV = ((1UL << 3) - 1)
	                   << 24, // SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
	CRS_CFGR_FELIM = ((1UL << 8) - 1) << 16, // Frequency error limit FELIM contains the value to be used to evaluate the captured frequency
	                                         // error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4:
	                                         // Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
	CRS_CFGR_RELOAD =
	    ((1UL << 16) - 1) << 0, // Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC
	                            // event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
};
inline void crs_cfgr_set_syncsrc(struct CRS_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCSRC) | ((val << 28) & CRS_CFGR_SYNCSRC);
}
inline void crs_cfgr_set_syncdiv(struct CRS_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCDIV) | ((val << 24) & CRS_CFGR_SYNCDIV);
}
inline void crs_cfgr_set_felim(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_FELIM) | ((val << 16) & CRS_CFGR_FELIM); }
inline void crs_cfgr_set_reload(struct CRS_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~CRS_CFGR_RELOAD) | ((val << 0) & CRS_CFGR_RELOAD);
}
inline uint32_t crs_cfgr_get_syncsrc(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_SYNCSRC) >> 28; }
inline uint32_t crs_cfgr_get_syncdiv(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_SYNCDIV) >> 24; }
inline uint32_t crs_cfgr_get_felim(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_FELIM) >> 16; }
inline uint32_t crs_cfgr_get_reload(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_RELOAD) >> 0; }

// CRS->ISR CRS interrupt and status register
enum {
	CRS_ISR_FECAP = ((1UL << 16) - 1)
	                << 16, // Frequency error capture FECAP is the frequency error counter value latched in the time ofthe last SYNC event.
	                       // Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
	CRS_ISR_FEDIR = 1UL << 15,   // Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the
	                             // time of the last SYNC event. It shows whether the actual frequency is below or above the target.
	CRS_ISR_TRIMOVF = 1UL << 10, // Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over-
	                             // or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register.
	                             // It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCMISS =
	    1UL << 9, // SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was
	              // detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too
	              // high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the
	              // frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in
	              // the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_SYNCERR =
	    1UL
	    << 8, // SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error
	          // is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be
	          // compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE
	          // bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
	CRS_ISR_ESYNCF = 1UL << 3, // Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An
	                           // interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by
	                           // setting the ESYNCC bit in the CRS_ICR register.
	CRS_ISR_ERRF = 1UL << 2, // Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical
	                         // OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the
	                         // CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register,
	                         // which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
	CRS_ISR_SYNCWARNF =
	    1UL << 1, // SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3,
	              // but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two
	              // steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software
	              // by setting the SYNCWARNC bit in the CRS_ICR register.
	CRS_ISR_SYNCOKF =
	    1UL << 0, // SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means
	              // that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to
	              // compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is
	              // cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
};
inline uint32_t crs_isr_get_fecap(struct CRS_Type* p) { return (p->ISR & CRS_ISR_FECAP) >> 16; }

// CRS->ICR CRS interrupt flag clear register
enum {
	CRS_ICR_ESYNCC = 1UL << 3, // Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
	CRS_ICR_ERRC   = 1UL << 2, // Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the
	                           // ERRF flag in the CRS_ISR register.
	CRS_ICR_SYNCWARNC = 1UL << 1, // SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
	CRS_ICR_SYNCOKC   = 1UL << 0, // SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
};

/* Digital-to-analog converter */
struct DAC1_Type {
	__IO uint32_t DAC_CR;       // @0 DAC control register
	__O uint32_t  DAC_SWTRGR;   // @4 DAC software trigger register
	__IO uint32_t DAC_DHR12R1;  // @8 DAC channel1 12-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12L1;  // @12 DAC channel1 12-bit left aligned data holding register
	__IO uint16_t DAC_DHR8R1;   // @16 DAC channel1 8-bit right aligned data holding register
	uint8_t       RESERVED0[2]; // @18
	__IO uint32_t DAC_DHR12R2;  // @20 DAC channel2 12-bit right aligned data holding register
	__IO uint32_t DAC_DHR12L2;  // @24 DAC channel2 12-bit left aligned data holding register
	__IO uint16_t DAC_DHR8R2;   // @28 DAC channel2 8-bit right-aligned data holding register
	uint8_t       RESERVED1[2]; // @30
	__IO uint32_t DAC_DHR12RD;  // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DAC_DHR12LD;  // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint16_t DAC_DHR8RD;   // @40 DUAL DAC 8-bit right aligned data holding register
	uint8_t       RESERVED2[2]; // @42
	__I uint32_t  DAC_DOR1;     // @44 DAC channel1 data output register
	__I uint32_t  DAC_DOR2;     // @48 DAC channel2 data output register
	__IO uint32_t DAC_SR;       // @52 DAC status register
	__IO uint32_t DAC_CCR;      // @56 DAC calibration control register
	__IO uint32_t DAC_MCR;      // @60 DAC mode control register
	__IO uint16_t DAC_SHSR1;    // @64 DAC Sample and Hold sample time register 1
	uint8_t       RESERVED3[2]; // @66
	__IO uint16_t DAC_SHSR2;    // @68 DAC Sample and Hold sample time register 2
	uint8_t       RESERVED4[2]; // @70
	__IO uint32_t DAC_SHHR;     // @72 DAC Sample and Hold hold time register
	__IO uint32_t DAC_SHRR;     // @76 DAC Sample and Hold refresh time register
	uint8_t       RESERVED5[8]; // @80
	__IO uint32_t DAC_STR1;     // @88 Sawtooth register
	__IO uint32_t DAC_STR2;     // @92 Sawtooth register
	__IO uint32_t DAC_STMODR;   // @96 Sawtooth Mode register
};

// DAC1->DAC_CR DAC control register
enum {
	DAC1_DAC_CR_CEN2 = 1UL << 30, // DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel
	                              // 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be
	                              // entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC1_DAC_CR_DMAUDRIE2 = 1UL << 29, // DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
	DAC1_DAC_CR_DMAEN2    = 1UL << 28, // DAC channel2 DMA enable This bit is set and cleared by software.
	DAC1_DAC_CR_MAMP2 =
	    ((1UL << 4) - 1)
	    << 24, // DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or
	           // amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC1_DAC_CR_WAVE2 =
	    ((1UL << 2) - 1) << 22, // DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle
	                            // wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
	DAC1_DAC_CR_TSEL2 = ((1UL << 4) - 1) << 18, // DAC channel2 trigger selection These bits select the external event used to trigger DAC
	                                            // channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
	DAC1_DAC_CR_TEN2 = 1UL << 17,               // DAC channel2 trigger enable
	DAC1_DAC_CR_EN2  = 1UL << 16, // DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
	DAC1_DAC_CR_CEN1 = 1UL << 14, // DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel
	                              // 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be
	                              // entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
	DAC1_DAC_CR_DMAUDRIE1 = 1UL << 13, // DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
	DAC1_DAC_CR_DMAEN1    = 1UL << 12, // DAC channel1 DMA enable This bit is set and cleared by software.
	DAC1_DAC_CR_MAMP1 =
	    ((1UL << 4) - 1)
	    << 8, // DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude
	          // in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
	DAC1_DAC_CR_WAVE1 = ((1UL << 2) - 1) << 6, // DAC channel1 noise/triangle wave generation enable These bits are set and cleared by
	                                           // software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC1_DAC_CR_TSEL1 = ((1UL << 4) - 1) << 2, // DAC channel1 trigger selection These bits select the external event used to trigger DAC
	                                           // channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
	DAC1_DAC_CR_TEN1 = 1UL << 1,               // DAC channel1 trigger enable
	DAC1_DAC_CR_EN1  = 1UL << 0, // DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
};
inline void dac1_dac_cr_set_mamp2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_MAMP2) | ((val << 24) & DAC1_DAC_CR_MAMP2);
}
inline void dac1_dac_cr_set_wave2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_WAVE2) | ((val << 22) & DAC1_DAC_CR_WAVE2);
}
inline void dac1_dac_cr_set_tsel2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_TSEL2) | ((val << 18) & DAC1_DAC_CR_TSEL2);
}
inline void dac1_dac_cr_set_mamp1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_MAMP1) | ((val << 8) & DAC1_DAC_CR_MAMP1);
}
inline void dac1_dac_cr_set_wave1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_WAVE1) | ((val << 6) & DAC1_DAC_CR_WAVE1);
}
inline void dac1_dac_cr_set_tsel1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CR = (p->DAC_CR & ~DAC1_DAC_CR_TSEL1) | ((val << 2) & DAC1_DAC_CR_TSEL1);
}
inline uint32_t dac1_dac_cr_get_mamp2(struct DAC1_Type* p) { return (p->DAC_CR & DAC1_DAC_CR_MAMP2) >> 24; }
inline uint32_t dac1_dac_cr_get_wave2(struct DAC1_Type* p) { return (p->DAC_CR & DAC1_DAC_CR_WAVE2) >> 22; }
inline uint32_t dac1_dac_cr_get_tsel2(struct DAC1_Type* p) { return (p->DAC_CR & DAC1_DAC_CR_TSEL2) >> 18; }
inline uint32_t dac1_dac_cr_get_mamp1(struct DAC1_Type* p) { return (p->DAC_CR & DAC1_DAC_CR_MAMP1) >> 8; }
inline uint32_t dac1_dac_cr_get_wave1(struct DAC1_Type* p) { return (p->DAC_CR & DAC1_DAC_CR_WAVE1) >> 6; }
inline uint32_t dac1_dac_cr_get_tsel1(struct DAC1_Type* p) { return (p->DAC_CR & DAC1_DAC_CR_TSEL1) >> 2; }

// DAC1->DAC_SWTRGR DAC software trigger register
enum {
	DAC1_DAC_SWTRGR_SWTRIGB2 = 1UL << 17, // DAC channel2 software trigger B
	DAC1_DAC_SWTRGR_SWTRIGB1 = 1UL << 16, // DAC channel1 software trigger B
	DAC1_DAC_SWTRGR_SWTRIG2  = 1UL << 1, // DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger
	                                     // mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2
	                                     // register value has been loaded into the DAC_DOR2 register.
	DAC1_DAC_SWTRGR_SWTRIG1 = 1UL << 0,  // DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger
	                                     // mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1
	                                     // register value has been loaded into the DAC_DOR1 register.
};

// DAC1->DAC_DHR12R1 DAC channel1 12-bit right-aligned data holding register
enum {
	DAC1_DAC_DHR12R1_DACC1DHRB = ((1UL << 12) - 1) << 16, // DAC channel1 12-bit right-aligned data B
	DAC1_DAC_DHR12R1_DACC1DHR =
	    ((1UL << 12) - 1)
	    << 0, // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12r1_set_dacc1dhrb(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12R1 = (p->DAC_DHR12R1 & ~DAC1_DAC_DHR12R1_DACC1DHRB) | ((val << 16) & DAC1_DAC_DHR12R1_DACC1DHRB);
}
inline void dac1_dac_dhr12r1_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12R1 = (p->DAC_DHR12R1 & ~DAC1_DAC_DHR12R1_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR12R1_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12r1_get_dacc1dhrb(struct DAC1_Type* p) { return (p->DAC_DHR12R1 & DAC1_DAC_DHR12R1_DACC1DHRB) >> 16; }
inline uint32_t dac1_dac_dhr12r1_get_dacc1dhr(struct DAC1_Type* p) { return (p->DAC_DHR12R1 & DAC1_DAC_DHR12R1_DACC1DHR) >> 0; }

// DAC1->DAC_DHR12L1 DAC channel1 12-bit left aligned data holding register
enum {
	DAC1_DAC_DHR12L1_DACC1DHRB = ((1UL << 12) - 1) << 20, // DAC channel1 12-bit left-aligned data B
	DAC1_DAC_DHR12L1_DACC1DHR =
	    ((1UL << 12) - 1)
	    << 4, // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12l1_set_dacc1dhrb(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12L1 = (p->DAC_DHR12L1 & ~DAC1_DAC_DHR12L1_DACC1DHRB) | ((val << 20) & DAC1_DAC_DHR12L1_DACC1DHRB);
}
inline void dac1_dac_dhr12l1_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12L1 = (p->DAC_DHR12L1 & ~DAC1_DAC_DHR12L1_DACC1DHR) | ((val << 4) & DAC1_DAC_DHR12L1_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12l1_get_dacc1dhrb(struct DAC1_Type* p) { return (p->DAC_DHR12L1 & DAC1_DAC_DHR12L1_DACC1DHRB) >> 20; }
inline uint32_t dac1_dac_dhr12l1_get_dacc1dhr(struct DAC1_Type* p) { return (p->DAC_DHR12L1 & DAC1_DAC_DHR12L1_DACC1DHR) >> 4; }

// DAC1->DAC_DHR8R1 DAC channel1 8-bit right aligned data holding register
enum {
	DAC1_DAC_DHR8R1_DACC1DHRB = ((1UL << 8) - 1) << 8, // DAC channel1 8-bit right-aligned data
	DAC1_DAC_DHR8R1_DACC1DHR =
	    ((1UL << 8) - 1)
	    << 0, // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
};
inline void dac1_dac_dhr8r1_set_dacc1dhrb(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR8R1 = (p->DAC_DHR8R1 & ~DAC1_DAC_DHR8R1_DACC1DHRB) | ((val << 8) & DAC1_DAC_DHR8R1_DACC1DHRB);
}
inline void dac1_dac_dhr8r1_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR8R1 = (p->DAC_DHR8R1 & ~DAC1_DAC_DHR8R1_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR8R1_DACC1DHR);
}
inline uint32_t dac1_dac_dhr8r1_get_dacc1dhrb(struct DAC1_Type* p) { return (p->DAC_DHR8R1 & DAC1_DAC_DHR8R1_DACC1DHRB) >> 8; }
inline uint32_t dac1_dac_dhr8r1_get_dacc1dhr(struct DAC1_Type* p) { return (p->DAC_DHR8R1 & DAC1_DAC_DHR8R1_DACC1DHR) >> 0; }

// DAC1->DAC_DHR12R2 DAC channel2 12-bit right aligned data holding register
enum {
	DAC1_DAC_DHR12R2_DACC2DHRB = ((1UL << 12) - 1) << 16, // DAC channel2 12-bit right-aligned data
	DAC1_DAC_DHR12R2_DACC2DHR =
	    ((1UL << 12) - 1)
	    << 0, // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
};
inline void dac1_dac_dhr12r2_set_dacc2dhrb(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12R2 = (p->DAC_DHR12R2 & ~DAC1_DAC_DHR12R2_DACC2DHRB) | ((val << 16) & DAC1_DAC_DHR12R2_DACC2DHRB);
}
inline void dac1_dac_dhr12r2_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12R2 = (p->DAC_DHR12R2 & ~DAC1_DAC_DHR12R2_DACC2DHR) | ((val << 0) & DAC1_DAC_DHR12R2_DACC2DHR);
}
inline uint32_t dac1_dac_dhr12r2_get_dacc2dhrb(struct DAC1_Type* p) { return (p->DAC_DHR12R2 & DAC1_DAC_DHR12R2_DACC2DHRB) >> 16; }
inline uint32_t dac1_dac_dhr12r2_get_dacc2dhr(struct DAC1_Type* p) { return (p->DAC_DHR12R2 & DAC1_DAC_DHR12R2_DACC2DHR) >> 0; }

// DAC1->DAC_DHR12L2 DAC channel2 12-bit left aligned data holding register
enum {
	DAC1_DAC_DHR12L2_DACC2DHRB = ((1UL << 12) - 1) << 20, // DAC channel2 12-bit left-aligned data B
	DAC1_DAC_DHR12L2_DACC2DHR =
	    ((1UL << 12) - 1)
	    << 4, // DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
};
inline void dac1_dac_dhr12l2_set_dacc2dhrb(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12L2 = (p->DAC_DHR12L2 & ~DAC1_DAC_DHR12L2_DACC2DHRB) | ((val << 20) & DAC1_DAC_DHR12L2_DACC2DHRB);
}
inline void dac1_dac_dhr12l2_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12L2 = (p->DAC_DHR12L2 & ~DAC1_DAC_DHR12L2_DACC2DHR) | ((val << 4) & DAC1_DAC_DHR12L2_DACC2DHR);
}
inline uint32_t dac1_dac_dhr12l2_get_dacc2dhrb(struct DAC1_Type* p) { return (p->DAC_DHR12L2 & DAC1_DAC_DHR12L2_DACC2DHRB) >> 20; }
inline uint32_t dac1_dac_dhr12l2_get_dacc2dhr(struct DAC1_Type* p) { return (p->DAC_DHR12L2 & DAC1_DAC_DHR12L2_DACC2DHR) >> 4; }

// DAC1->DAC_DHR8R2 DAC channel2 8-bit right-aligned data holding register
enum {
	DAC1_DAC_DHR8R2_DACC2DHRB = ((1UL << 8) - 1) << 8, // DAC channel2 8-bit right-aligned data
	DAC1_DAC_DHR8R2_DACC2DHR =
	    ((1UL << 8) - 1)
	    << 0, // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
};
inline void dac1_dac_dhr8r2_set_dacc2dhrb(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR8R2 = (p->DAC_DHR8R2 & ~DAC1_DAC_DHR8R2_DACC2DHRB) | ((val << 8) & DAC1_DAC_DHR8R2_DACC2DHRB);
}
inline void dac1_dac_dhr8r2_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR8R2 = (p->DAC_DHR8R2 & ~DAC1_DAC_DHR8R2_DACC2DHR) | ((val << 0) & DAC1_DAC_DHR8R2_DACC2DHR);
}
inline uint32_t dac1_dac_dhr8r2_get_dacc2dhrb(struct DAC1_Type* p) { return (p->DAC_DHR8R2 & DAC1_DAC_DHR8R2_DACC2DHRB) >> 8; }
inline uint32_t dac1_dac_dhr8r2_get_dacc2dhr(struct DAC1_Type* p) { return (p->DAC_DHR8R2 & DAC1_DAC_DHR8R2_DACC2DHR) >> 0; }

// DAC1->DAC_DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC1_DAC_DHR12RD_DACC2DHR =
	    ((1UL << 12) - 1)
	    << 16, // DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
	DAC1_DAC_DHR12RD_DACC1DHR =
	    ((1UL << 12) - 1)
	    << 0, // DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12rd_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12RD = (p->DAC_DHR12RD & ~DAC1_DAC_DHR12RD_DACC2DHR) | ((val << 16) & DAC1_DAC_DHR12RD_DACC2DHR);
}
inline void dac1_dac_dhr12rd_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12RD = (p->DAC_DHR12RD & ~DAC1_DAC_DHR12RD_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR12RD_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12rd_get_dacc2dhr(struct DAC1_Type* p) { return (p->DAC_DHR12RD & DAC1_DAC_DHR12RD_DACC2DHR) >> 16; }
inline uint32_t dac1_dac_dhr12rd_get_dacc1dhr(struct DAC1_Type* p) { return (p->DAC_DHR12RD & DAC1_DAC_DHR12RD_DACC1DHR) >> 0; }

// DAC1->DAC_DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC1_DAC_DHR12LD_DACC2DHR =
	    ((1UL << 12) - 1)
	    << 20, // DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
	DAC1_DAC_DHR12LD_DACC1DHR =
	    ((1UL << 12) - 1)
	    << 4, // DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
};
inline void dac1_dac_dhr12ld_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12LD = (p->DAC_DHR12LD & ~DAC1_DAC_DHR12LD_DACC2DHR) | ((val << 20) & DAC1_DAC_DHR12LD_DACC2DHR);
}
inline void dac1_dac_dhr12ld_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR12LD = (p->DAC_DHR12LD & ~DAC1_DAC_DHR12LD_DACC1DHR) | ((val << 4) & DAC1_DAC_DHR12LD_DACC1DHR);
}
inline uint32_t dac1_dac_dhr12ld_get_dacc2dhr(struct DAC1_Type* p) { return (p->DAC_DHR12LD & DAC1_DAC_DHR12LD_DACC2DHR) >> 20; }
inline uint32_t dac1_dac_dhr12ld_get_dacc1dhr(struct DAC1_Type* p) { return (p->DAC_DHR12LD & DAC1_DAC_DHR12LD_DACC1DHR) >> 4; }

// DAC1->DAC_DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC1_DAC_DHR8RD_DACC2DHR =
	    ((1UL << 8) - 1)
	    << 8, // DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
	DAC1_DAC_DHR8RD_DACC1DHR =
	    ((1UL << 8) - 1)
	    << 0, // DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
};
inline void dac1_dac_dhr8rd_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR8RD = (p->DAC_DHR8RD & ~DAC1_DAC_DHR8RD_DACC2DHR) | ((val << 8) & DAC1_DAC_DHR8RD_DACC2DHR);
}
inline void dac1_dac_dhr8rd_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) {
	p->DAC_DHR8RD = (p->DAC_DHR8RD & ~DAC1_DAC_DHR8RD_DACC1DHR) | ((val << 0) & DAC1_DAC_DHR8RD_DACC1DHR);
}
inline uint32_t dac1_dac_dhr8rd_get_dacc2dhr(struct DAC1_Type* p) { return (p->DAC_DHR8RD & DAC1_DAC_DHR8RD_DACC2DHR) >> 8; }
inline uint32_t dac1_dac_dhr8rd_get_dacc1dhr(struct DAC1_Type* p) { return (p->DAC_DHR8RD & DAC1_DAC_DHR8RD_DACC1DHR) >> 0; }

// DAC1->DAC_DOR1 DAC channel1 data output register
enum {
	DAC1_DAC_DOR1_DACC1DORB = ((1UL << 12) - 1) << 16, // DAC channel1 data output
	DAC1_DAC_DOR1_DACC1DOR =
	    ((1UL << 12) - 1) << 0, // DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
};
inline uint32_t dac1_dac_dor1_get_dacc1dorb(struct DAC1_Type* p) { return (p->DAC_DOR1 & DAC1_DAC_DOR1_DACC1DORB) >> 16; }
inline uint32_t dac1_dac_dor1_get_dacc1dor(struct DAC1_Type* p) { return (p->DAC_DOR1 & DAC1_DAC_DOR1_DACC1DOR) >> 0; }

// DAC1->DAC_DOR2 DAC channel2 data output register
enum {
	DAC1_DAC_DOR2_DACC2DORB = ((1UL << 12) - 1) << 16, // DAC channel2 data output
	DAC1_DAC_DOR2_DACC2DOR =
	    ((1UL << 12) - 1) << 0, // DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
};
inline uint32_t dac1_dac_dor2_get_dacc2dorb(struct DAC1_Type* p) { return (p->DAC_DOR2 & DAC1_DAC_DOR2_DACC2DORB) >> 16; }
inline uint32_t dac1_dac_dor2_get_dacc2dor(struct DAC1_Type* p) { return (p->DAC_DOR2 & DAC1_DAC_DOR2_DACC2DOR) >> 0; }

// DAC1->DAC_SR DAC status register
enum {
	DAC1_DAC_SR_BWST2 = 1UL << 31, // DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold
	                               // mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware
	                               // when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
	DAC1_DAC_SR_CAL_FLAG2 = 1UL << 30, // DAC Channel 2 calibration offset status This bit is set and cleared by hardware
	DAC1_DAC_SR_DMAUDR2 =
	    1UL << 29, // DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC1_DAC_SR_DORSTAT2 = 1UL << 28, // DAC channel 2 output register status bit
	DAC1_DAC_SR_DAC2RDY  = 1UL << 27, // DAC channel 2 ready status bit
	DAC1_DAC_SR_BWST1    = 1UL << 15, // DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold
	                               // mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware
	                               // when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
	DAC1_DAC_SR_CAL_FLAG1 = 1UL << 14, // DAC Channel 1 calibration offset status This bit is set and cleared by hardware
	DAC1_DAC_SR_DMAUDR1 =
	    1UL << 13, // DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
	DAC1_DAC_SR_DORSTAT1 = 1UL << 12, // DAC channel1 output register status bit
	DAC1_DAC_SR_DAC1RDY  = 1UL << 11, // DAC channel1 ready status bit
};

// DAC1->DAC_CCR DAC calibration control register
enum {
	DAC1_DAC_CCR_OTRIM2 = ((1UL << 5) - 1) << 16, // DAC Channel 2 offset trimming value
	DAC1_DAC_CCR_OTRIM1 = ((1UL << 5) - 1) << 0,  // DAC Channel 1 offset trimming value
};
inline void dac1_dac_ccr_set_otrim2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CCR = (p->DAC_CCR & ~DAC1_DAC_CCR_OTRIM2) | ((val << 16) & DAC1_DAC_CCR_OTRIM2);
}
inline void dac1_dac_ccr_set_otrim1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_CCR = (p->DAC_CCR & ~DAC1_DAC_CCR_OTRIM1) | ((val << 0) & DAC1_DAC_CCR_OTRIM1);
}
inline uint32_t dac1_dac_ccr_get_otrim2(struct DAC1_Type* p) { return (p->DAC_CCR & DAC1_DAC_CCR_OTRIM2) >> 16; }
inline uint32_t dac1_dac_ccr_get_otrim1(struct DAC1_Type* p) { return (p->DAC_CCR & DAC1_DAC_CCR_OTRIM1) >> 0; }

// DAC1->DAC_MCR DAC mode control register
enum {
	DAC1_DAC_MCR_SINFORMAT2 = 1UL << 25, // Enable signed format for DAC channel2
	DAC1_DAC_MCR_DMADOUBLE2 = 1UL << 24, // DAC Channel2 DMA double data mode
	DAC1_DAC_MCR_MODE2 =
	    ((1UL << 3) - 1)
	    << 16, // DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0
	           // and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared
	           // by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
	DAC1_DAC_MCR_HFSEL      = ((1UL << 2) - 1) << 14, // High frequency interface mode selection
	DAC1_DAC_MCR_SINFORMAT1 = 1UL << 9,               // Enable signed format for DAC channel1
	DAC1_DAC_MCR_DMADOUBLE1 = 1UL << 8,               // DAC Channel1 DMA double data mode
	DAC1_DAC_MCR_MODE1 =
	    ((1UL << 3) - 1)
	    << 0, // DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0
	          // and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by
	          // software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
};
inline void dac1_dac_mcr_set_mode2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_MCR = (p->DAC_MCR & ~DAC1_DAC_MCR_MODE2) | ((val << 16) & DAC1_DAC_MCR_MODE2);
}
inline void dac1_dac_mcr_set_hfsel(struct DAC1_Type* p, uint32_t val) {
	p->DAC_MCR = (p->DAC_MCR & ~DAC1_DAC_MCR_HFSEL) | ((val << 14) & DAC1_DAC_MCR_HFSEL);
}
inline void dac1_dac_mcr_set_mode1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_MCR = (p->DAC_MCR & ~DAC1_DAC_MCR_MODE1) | ((val << 0) & DAC1_DAC_MCR_MODE1);
}
inline uint32_t dac1_dac_mcr_get_mode2(struct DAC1_Type* p) { return (p->DAC_MCR & DAC1_DAC_MCR_MODE2) >> 16; }
inline uint32_t dac1_dac_mcr_get_hfsel(struct DAC1_Type* p) { return (p->DAC_MCR & DAC1_DAC_MCR_HFSEL) >> 14; }
inline uint32_t dac1_dac_mcr_get_mode1(struct DAC1_Type* p) { return (p->DAC_MCR & DAC1_DAC_MCR_MODE1) >> 0; }

// DAC1->DAC_SHSR1 DAC Sample and Hold sample time register 1
enum {
	DAC1_DAC_SHSR1_TSAMPLE1 = ((1UL << 10) - 1)
	                          << 0, // DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the
	                                // DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done
	                                // only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
};
inline void dac1_dac_shsr1_set_tsample1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_SHSR1 = (p->DAC_SHSR1 & ~DAC1_DAC_SHSR1_TSAMPLE1) | ((val << 0) & DAC1_DAC_SHSR1_TSAMPLE1);
}
inline uint32_t dac1_dac_shsr1_get_tsample1(struct DAC1_Type* p) { return (p->DAC_SHSR1 & DAC1_DAC_SHSR1_TSAMPLE1) >> 0; }

// DAC1->DAC_SHSR2 DAC Sample and Hold sample time register 2
enum {
	DAC1_DAC_SHSR2_TSAMPLE2 = ((1UL << 10) - 1)
	                          << 0, // DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the
	                                // DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done
	                                // only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
};
inline void dac1_dac_shsr2_set_tsample2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_SHSR2 = (p->DAC_SHSR2 & ~DAC1_DAC_SHSR2_TSAMPLE2) | ((val << 0) & DAC1_DAC_SHSR2_TSAMPLE2);
}
inline uint32_t dac1_dac_shsr2_get_tsample2(struct DAC1_Type* p) { return (p->DAC_SHSR2 & DAC1_DAC_SHSR2_TSAMPLE2) >> 0; }

// DAC1->DAC_SHHR DAC Sample and Hold hold time register
enum {
	DAC1_DAC_SHHR_THOLD2 =
	    ((1UL << 10) - 1) << 16, // DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
	DAC1_DAC_SHHR_THOLD1 =
	    ((1UL << 10) - 1) << 0, // DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
};
inline void dac1_dac_shhr_set_thold2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_SHHR = (p->DAC_SHHR & ~DAC1_DAC_SHHR_THOLD2) | ((val << 16) & DAC1_DAC_SHHR_THOLD2);
}
inline void dac1_dac_shhr_set_thold1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_SHHR = (p->DAC_SHHR & ~DAC1_DAC_SHHR_THOLD1) | ((val << 0) & DAC1_DAC_SHHR_THOLD1);
}
inline uint32_t dac1_dac_shhr_get_thold2(struct DAC1_Type* p) { return (p->DAC_SHHR & DAC1_DAC_SHHR_THOLD2) >> 16; }
inline uint32_t dac1_dac_shhr_get_thold1(struct DAC1_Type* p) { return (p->DAC_SHHR & DAC1_DAC_SHHR_THOLD1) >> 0; }

// DAC1->DAC_SHRR DAC Sample and Hold refresh time register
enum {
	DAC1_DAC_SHRR_TREFRESH2 =
	    ((1UL << 8) - 1) << 16, // DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
	DAC1_DAC_SHRR_TREFRESH1 =
	    ((1UL << 8) - 1) << 0, // DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
};
inline void dac1_dac_shrr_set_trefresh2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_SHRR = (p->DAC_SHRR & ~DAC1_DAC_SHRR_TREFRESH2) | ((val << 16) & DAC1_DAC_SHRR_TREFRESH2);
}
inline void dac1_dac_shrr_set_trefresh1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_SHRR = (p->DAC_SHRR & ~DAC1_DAC_SHRR_TREFRESH1) | ((val << 0) & DAC1_DAC_SHRR_TREFRESH1);
}
inline uint32_t dac1_dac_shrr_get_trefresh2(struct DAC1_Type* p) { return (p->DAC_SHRR & DAC1_DAC_SHRR_TREFRESH2) >> 16; }
inline uint32_t dac1_dac_shrr_get_trefresh1(struct DAC1_Type* p) { return (p->DAC_SHRR & DAC1_DAC_SHRR_TREFRESH1) >> 0; }

// DAC1->DAC_STR1 Sawtooth register
enum {
	DAC1_DAC_STR1_STINCDATA1 = ((1UL << 16) - 1) << 16, // DAC CH1 Sawtooth increment value (12.4 bit format)
	DAC1_DAC_STR1_STDIR1     = 1UL << 12,               // DAC Channel1 Sawtooth direction setting
	DAC1_DAC_STR1_STRSTDATA1 = ((1UL << 12) - 1) << 0,  // DAC Channel 1 Sawtooth reset value
};
inline void dac1_dac_str1_set_stincdata1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STR1 = (p->DAC_STR1 & ~DAC1_DAC_STR1_STINCDATA1) | ((val << 16) & DAC1_DAC_STR1_STINCDATA1);
}
inline void dac1_dac_str1_set_strstdata1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STR1 = (p->DAC_STR1 & ~DAC1_DAC_STR1_STRSTDATA1) | ((val << 0) & DAC1_DAC_STR1_STRSTDATA1);
}
inline uint32_t dac1_dac_str1_get_stincdata1(struct DAC1_Type* p) { return (p->DAC_STR1 & DAC1_DAC_STR1_STINCDATA1) >> 16; }
inline uint32_t dac1_dac_str1_get_strstdata1(struct DAC1_Type* p) { return (p->DAC_STR1 & DAC1_DAC_STR1_STRSTDATA1) >> 0; }

// DAC1->DAC_STR2 Sawtooth register
enum {
	DAC1_DAC_STR2_STINCDATA2 = ((1UL << 16) - 1) << 16, // DAC CH2 Sawtooth increment value (12.4 bit format)
	DAC1_DAC_STR2_STDIR2     = 1UL << 12,               // DAC Channel2 Sawtooth direction setting
	DAC1_DAC_STR2_STRSTDATA2 = ((1UL << 12) - 1) << 0,  // DAC Channel 2 Sawtooth reset value
};
inline void dac1_dac_str2_set_stincdata2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STR2 = (p->DAC_STR2 & ~DAC1_DAC_STR2_STINCDATA2) | ((val << 16) & DAC1_DAC_STR2_STINCDATA2);
}
inline void dac1_dac_str2_set_strstdata2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STR2 = (p->DAC_STR2 & ~DAC1_DAC_STR2_STRSTDATA2) | ((val << 0) & DAC1_DAC_STR2_STRSTDATA2);
}
inline uint32_t dac1_dac_str2_get_stincdata2(struct DAC1_Type* p) { return (p->DAC_STR2 & DAC1_DAC_STR2_STINCDATA2) >> 16; }
inline uint32_t dac1_dac_str2_get_strstdata2(struct DAC1_Type* p) { return (p->DAC_STR2 & DAC1_DAC_STR2_STRSTDATA2) >> 0; }

// DAC1->DAC_STMODR Sawtooth Mode register
enum {
	DAC1_DAC_STMODR_STINCTRIGSEL2 = ((1UL << 4) - 1) << 24, // DAC Channel 2 Sawtooth Increment trigger selection
	DAC1_DAC_STMODR_STRSTTRIGSEL2 = ((1UL << 4) - 1) << 16, // DAC Channel 1 Sawtooth Reset trigger selection
	DAC1_DAC_STMODR_STINCTRIGSEL1 = ((1UL << 4) - 1) << 8,  // DAC Channel 1 Sawtooth Increment trigger selection
	DAC1_DAC_STMODR_STRSTTRIGSEL1 = ((1UL << 4) - 1) << 0,  // DAC Channel 1 Sawtooth Reset trigger selection
};
inline void dac1_dac_stmodr_set_stinctrigsel2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STINCTRIGSEL2) | ((val << 24) & DAC1_DAC_STMODR_STINCTRIGSEL2);
}
inline void dac1_dac_stmodr_set_strsttrigsel2(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STRSTTRIGSEL2) | ((val << 16) & DAC1_DAC_STMODR_STRSTTRIGSEL2);
}
inline void dac1_dac_stmodr_set_stinctrigsel1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STINCTRIGSEL1) | ((val << 8) & DAC1_DAC_STMODR_STINCTRIGSEL1);
}
inline void dac1_dac_stmodr_set_strsttrigsel1(struct DAC1_Type* p, uint32_t val) {
	p->DAC_STMODR = (p->DAC_STMODR & ~DAC1_DAC_STMODR_STRSTTRIGSEL1) | ((val << 0) & DAC1_DAC_STMODR_STRSTTRIGSEL1);
}
inline uint32_t dac1_dac_stmodr_get_stinctrigsel2(struct DAC1_Type* p) { return (p->DAC_STMODR & DAC1_DAC_STMODR_STINCTRIGSEL2) >> 24; }
inline uint32_t dac1_dac_stmodr_get_strsttrigsel2(struct DAC1_Type* p) { return (p->DAC_STMODR & DAC1_DAC_STMODR_STRSTTRIGSEL2) >> 16; }
inline uint32_t dac1_dac_stmodr_get_stinctrigsel1(struct DAC1_Type* p) { return (p->DAC_STMODR & DAC1_DAC_STMODR_STINCTRIGSEL1) >> 8; }
inline uint32_t dac1_dac_stmodr_get_strsttrigsel1(struct DAC1_Type* p) { return (p->DAC_STMODR & DAC1_DAC_STMODR_STRSTTRIGSEL1) >> 0; }

/* Debug support */
struct DBGMCU_Type {
	__I uint32_t  IDCODE;       // @0 MCU Device ID Code Register
	__IO uint8_t  CR;           // @4 Debug MCU Configuration Register
	uint8_t       RESERVED0[3]; // @5
	__IO uint32_t APB1L_FZ;     // @8 APB Low Freeze Register 1
	__IO uint8_t  APB1H_FZ;     // @12 APB Low Freeze Register 2
	uint8_t       RESERVED1[3]; // @13
	__IO uint32_t APB2_FZ;      // @16 APB High Freeze Register
};

// DBGMCU->IDCODE MCU Device ID Code Register
enum {
	DBGMCU_IDCODE_REV_ID = ((1UL << 16) - 1) << 16, // Revision Identifier
	DBGMCU_IDCODE_DEV_ID = ((1UL << 16) - 1) << 0,  // Device Identifier
};
inline uint32_t dbgmcu_idcode_get_rev_id(struct DBGMCU_Type* p) { return (p->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16; }
inline uint32_t dbgmcu_idcode_get_dev_id(struct DBGMCU_Type* p) { return (p->IDCODE & DBGMCU_IDCODE_DEV_ID) >> 0; }

// DBGMCU->CR Debug MCU Configuration Register
enum {
	DBGMCU_CR_TRACE_MODE  = ((1UL << 2) - 1) << 6, // Trace pin assignment control
	DBGMCU_CR_TRACE_IOEN  = 1UL << 5,              // Trace pin assignment control
	DBGMCU_CR_DBG_STANDBY = 1UL << 2,              // Debug Standby Mode
	DBGMCU_CR_DBG_STOP    = 1UL << 1,              // Debug Stop Mode
	DBGMCU_CR_DBG_SLEEP   = 1UL << 0,              // Debug Sleep Mode
};
inline void dbgmcu_cr_set_trace_mode(struct DBGMCU_Type* p, uint32_t val) {
	p->CR = (p->CR & ~DBGMCU_CR_TRACE_MODE) | ((val << 6) & DBGMCU_CR_TRACE_MODE);
}
inline uint32_t dbgmcu_cr_get_trace_mode(struct DBGMCU_Type* p) { return (p->CR & DBGMCU_CR_TRACE_MODE) >> 6; }

// DBGMCU->APB1L_FZ APB Low Freeze Register 1
enum {
	DBGMCU_APB1L_FZ_DBG_LPTIMER_STOP = 1UL << 31, // LPTIM1 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C3_STOP    = 1UL << 30, // I2C3 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C2_STOP    = 1UL << 22, // I2C2 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_I2C1_STOP    = 1UL << 21, // I2C1 SMBUS timeout mode stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_IWDG_STOP    = 1UL << 12, // Debug Independent Wachdog stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_WWDG_STOP    = 1UL << 11, // Debug Window Wachdog stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_RTC_STOP     = 1UL << 10, // Debug RTC stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_TIM7_STOP    = 1UL << 5,  // TIM7 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIMER6_STOP  = 1UL << 4,  // Debug Timer 6 stopped when Core is halted
	DBGMCU_APB1L_FZ_DBG_TIM5_STOP    = 1UL << 3,  // TIM5 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIM4_STOP    = 1UL << 2,  // TIM4 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIM3_STOP    = 1UL << 1,  // TIM3 counter stopped when core is halted
	DBGMCU_APB1L_FZ_DBG_TIMER2_STOP  = 1UL << 0,  // Debug Timer 2 stopped when Core is halted
};

// DBGMCU->APB1H_FZ APB Low Freeze Register 2
enum {
	DBGMCU_APB1H_FZ_DBG_I2C4_STOP = 1UL << 1, // DBG_I2C4_STOP
};

// DBGMCU->APB2_FZ APB High Freeze Register
enum {
	DBGMCU_APB2_FZ_DBG_HRTIM3_STOP = 1UL << 29, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM2_STOP = 1UL << 28, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM1_STOP = 1UL << 27, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_HRTIM0_STOP = 1UL << 26, // DBG_HRTIM0_STOP
	DBGMCU_APB2_FZ_DBG_TIM20_STOP  = 1UL << 20, // TIM20counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM17_STOP  = 1UL << 18, // TIM17 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM16_STOP  = 1UL << 17, // TIM16 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM15_STOP  = 1UL << 16, // TIM15 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM8_STOP   = 1UL << 13, // TIM8 counter stopped when core is halted
	DBGMCU_APB2_FZ_DBG_TIM1_STOP   = 1UL << 11, // TIM1 counter stopped when core is halted
};

/* DMA controller */
struct DMA1_Type {
	__I uint32_t  ISR;           // @0 interrupt status register
	__O uint32_t  IFCR;          // @4 DMA interrupt flag clear register
	__IO uint16_t CCR1;          // @8 DMA channel 1 configuration register
	uint8_t       RESERVED0[2];  // @10
	__IO uint16_t CNDTR1;        // @12 channel x number of data to transfer register
	uint8_t       RESERVED1[2];  // @14
	__IO uint32_t CPAR1;         // @16 DMA channel x peripheral address register
	__IO uint32_t CMAR1;         // @20 DMA channel x memory address register
	uint8_t       RESERVED2[4];  // @24
	__IO uint16_t CCR2;          // @28 DMA channel 2 configuration register
	uint8_t       RESERVED3[2];  // @30
	__IO uint16_t CNDTR2;        // @32 channel x number of data to transfer register
	uint8_t       RESERVED4[2];  // @34
	__IO uint32_t CPAR2;         // @36 DMA channel x peripheral address register
	__IO uint32_t CMAR2;         // @40 DMA channel x memory address register
	uint8_t       RESERVED5[4];  // @44
	__IO uint16_t CCR3;          // @48 DMA channel 3 configuration register
	uint8_t       RESERVED6[2];  // @50
	__IO uint16_t CNDTR3;        // @52 channel x number of data to transfer register
	uint8_t       RESERVED7[2];  // @54
	__IO uint32_t CPAR3;         // @56 DMA channel x peripheral address register
	__IO uint32_t CMAR3;         // @60 DMA channel x memory address register
	uint8_t       RESERVED8[4];  // @64
	__IO uint16_t CCR4;          // @68 DMA channel 3 configuration register
	uint8_t       RESERVED9[2];  // @70
	__IO uint16_t CNDTR4;        // @72 channel x number of data to transfer register
	uint8_t       RESERVED10[2]; // @74
	__IO uint32_t CPAR4;         // @76 DMA channel x peripheral address register
	__IO uint32_t CMAR4;         // @80 DMA channel x memory address register
	uint8_t       RESERVED11[4]; // @84
	__IO uint16_t CCR5;          // @88 DMA channel 4 configuration register
	uint8_t       RESERVED12[2]; // @90
	__IO uint16_t CNDTR5;        // @92 channel x number of data to transfer register
	uint8_t       RESERVED13[2]; // @94
	__IO uint32_t CPAR5;         // @96 DMA channel x peripheral address register
	__IO uint32_t CMAR5;         // @100 DMA channel x memory address register
	uint8_t       RESERVED14[4]; // @104
	__IO uint16_t CCR6;          // @108 DMA channel 5 configuration register
	uint8_t       RESERVED15[2]; // @110
	__IO uint16_t CNDTR6;        // @112 channel x number of data to transfer register
	uint8_t       RESERVED16[2]; // @114
	__IO uint32_t CPAR6;         // @116 DMA channel x peripheral address register
	__IO uint32_t CMAR6;         // @120 DMA channel x memory address register
	uint8_t       RESERVED17[4]; // @124
	__IO uint16_t CCR7;          // @128 DMA channel 6 configuration register
	uint8_t       RESERVED18[2]; // @130
	__IO uint16_t CNDTR7;        // @132 channel x number of data to transfer register
	uint8_t       RESERVED19[2]; // @134
	__IO uint32_t CPAR7;         // @136 DMA channel x peripheral address register
	__IO uint32_t CMAR7;         // @140 DMA channel x memory address register
	uint8_t       RESERVED20[4]; // @144
	__IO uint16_t CCR8;          // @148 DMA channel 7 configuration register
	uint8_t       RESERVED21[2]; // @150
	__IO uint16_t CNDTR8;        // @152 channel x number of data to transfer register
	uint8_t       RESERVED22[2]; // @154
	__IO uint32_t CPAR8;         // @156 DMA channel x peripheral address register
	__IO uint32_t CMAR8;         // @160 DMA channel x memory address register
};

// DMA1->ISR interrupt status register
enum {
	DMA1_ISR_TEIF8 = 1UL << 31, // TEIF8
	DMA1_ISR_HTIF8 = 1UL << 30, // HTIF8
	DMA1_ISR_TCIF8 = 1UL << 29, // TCIF8
	DMA1_ISR_GIF8  = 1UL << 28, // GIF8
	DMA1_ISR_TEIF7 = 1UL << 27, // TEIF7
	DMA1_ISR_HTIF7 = 1UL << 26, // HTIF7
	DMA1_ISR_TCIF7 = 1UL << 25, // TCIF7
	DMA1_ISR_GIF7  = 1UL << 24, // GIF7
	DMA1_ISR_TEIF6 = 1UL << 23, // TEIF6
	DMA1_ISR_HTIF6 = 1UL << 22, // HTIF6
	DMA1_ISR_TCIF6 = 1UL << 21, // TCIF6
	DMA1_ISR_GIF6  = 1UL << 20, // GIF6
	DMA1_ISR_TEIF5 = 1UL << 19, // TEIF5
	DMA1_ISR_HTIF5 = 1UL << 18, // HTIF5
	DMA1_ISR_TCIF5 = 1UL << 17, // TCIF5
	DMA1_ISR_GIF5  = 1UL << 16, // GIF5
	DMA1_ISR_TEIF4 = 1UL << 15, // TEIF4
	DMA1_ISR_HTIF4 = 1UL << 14, // HTIF4
	DMA1_ISR_TCIF4 = 1UL << 13, // TCIF4
	DMA1_ISR_GIF4  = 1UL << 12, // GIF4
	DMA1_ISR_TEIF3 = 1UL << 11, // TEIF3
	DMA1_ISR_HTIF3 = 1UL << 10, // HTIF3
	DMA1_ISR_TCIF3 = 1UL << 9,  // TCIF3
	DMA1_ISR_GIF3  = 1UL << 8,  // GIF3
	DMA1_ISR_TEIF2 = 1UL << 7,  // TEIF2
	DMA1_ISR_HTIF2 = 1UL << 6,  // HTIF2
	DMA1_ISR_TCIF2 = 1UL << 5,  // TCIF2
	DMA1_ISR_GIF2  = 1UL << 4,  // GIF2
	DMA1_ISR_TEIF1 = 1UL << 3,  // TEIF1
	DMA1_ISR_HTIF1 = 1UL << 2,  // HTIF1
	DMA1_ISR_TCIF1 = 1UL << 1,  // TCIF1
	DMA1_ISR_GIF1  = 1UL << 0,  // GIF1
};

// DMA1->IFCR DMA interrupt flag clear register
enum {
	DMA1_IFCR_TEIF8 = 1UL << 31, // TEIF8
	DMA1_IFCR_HTIF8 = 1UL << 30, // HTIF8
	DMA1_IFCR_TCIF8 = 1UL << 29, // TCIF8
	DMA1_IFCR_GIF8  = 1UL << 28, // GIF8
	DMA1_IFCR_TEIF7 = 1UL << 27, // TEIF7
	DMA1_IFCR_HTIF7 = 1UL << 26, // HTIF7
	DMA1_IFCR_TCIF7 = 1UL << 25, // TCIF7
	DMA1_IFCR_GIF7  = 1UL << 24, // GIF7
	DMA1_IFCR_TEIF6 = 1UL << 23, // TEIF6
	DMA1_IFCR_HTIF6 = 1UL << 22, // HTIF6
	DMA1_IFCR_TCIF6 = 1UL << 21, // TCIF6
	DMA1_IFCR_GIF6  = 1UL << 20, // GIF6
	DMA1_IFCR_TEIF5 = 1UL << 19, // TEIF5
	DMA1_IFCR_HTIF5 = 1UL << 18, // HTIF5
	DMA1_IFCR_TCIF5 = 1UL << 17, // TCIF5
	DMA1_IFCR_GIF5  = 1UL << 16, // GIF5
	DMA1_IFCR_TEIF4 = 1UL << 15, // TEIF4
	DMA1_IFCR_HTIF4 = 1UL << 14, // HTIF4
	DMA1_IFCR_TCIF4 = 1UL << 13, // TCIF4
	DMA1_IFCR_GIF4  = 1UL << 12, // GIF4
	DMA1_IFCR_TEIF3 = 1UL << 11, // TEIF3
	DMA1_IFCR_HTIF3 = 1UL << 10, // HTIF3
	DMA1_IFCR_TCIF3 = 1UL << 9,  // TCIF3
	DMA1_IFCR_GIF3  = 1UL << 8,  // GIF3
	DMA1_IFCR_TEIF2 = 1UL << 7,  // TEIF2
	DMA1_IFCR_HTIF2 = 1UL << 6,  // HTIF2
	DMA1_IFCR_TCIF2 = 1UL << 5,  // TCIF2
	DMA1_IFCR_GIF2  = 1UL << 4,  // GIF2
	DMA1_IFCR_TEIF1 = 1UL << 3,  // TEIF1
	DMA1_IFCR_HTIF1 = 1UL << 2,  // HTIF1
	DMA1_IFCR_TCIF1 = 1UL << 1,  // TCIF1
	DMA1_IFCR_GIF1  = 1UL << 0,  // GIF1
};

// DMA1->CCR1 DMA channel 1 configuration register
enum {
	DMA1_CCR1_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR1_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR1_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR1_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR1_MINC    = 1UL << 7,               // MINC
	DMA1_CCR1_PINC    = 1UL << 6,               // PINC
	DMA1_CCR1_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR1_DIR     = 1UL << 4,               // DIR
	DMA1_CCR1_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR1_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR1_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR1_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr1_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA1_CCR1_PL) | ((val << 12) & DMA1_CCR1_PL); }
inline void dma1_ccr1_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~DMA1_CCR1_MSIZE) | ((val << 10) & DMA1_CCR1_MSIZE);
}
inline void dma1_ccr1_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR1 = (p->CCR1 & ~DMA1_CCR1_PSIZE) | ((val << 8) & DMA1_CCR1_PSIZE);
}
inline uint32_t dma1_ccr1_get_pl(struct DMA1_Type* p) { return (p->CCR1 & DMA1_CCR1_PL) >> 12; }
inline uint32_t dma1_ccr1_get_msize(struct DMA1_Type* p) { return (p->CCR1 & DMA1_CCR1_MSIZE) >> 10; }
inline uint32_t dma1_ccr1_get_psize(struct DMA1_Type* p) { return (p->CCR1 & DMA1_CCR1_PSIZE) >> 8; }

// DMA1->CCR2 DMA channel 2 configuration register
enum {
	DMA1_CCR2_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR2_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR2_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR2_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR2_MINC    = 1UL << 7,               // MINC
	DMA1_CCR2_PINC    = 1UL << 6,               // PINC
	DMA1_CCR2_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR2_DIR     = 1UL << 4,               // DIR
	DMA1_CCR2_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR2_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR2_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR2_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr2_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA1_CCR2_PL) | ((val << 12) & DMA1_CCR2_PL); }
inline void dma1_ccr2_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~DMA1_CCR2_MSIZE) | ((val << 10) & DMA1_CCR2_MSIZE);
}
inline void dma1_ccr2_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR2 = (p->CCR2 & ~DMA1_CCR2_PSIZE) | ((val << 8) & DMA1_CCR2_PSIZE);
}
inline uint32_t dma1_ccr2_get_pl(struct DMA1_Type* p) { return (p->CCR2 & DMA1_CCR2_PL) >> 12; }
inline uint32_t dma1_ccr2_get_msize(struct DMA1_Type* p) { return (p->CCR2 & DMA1_CCR2_MSIZE) >> 10; }
inline uint32_t dma1_ccr2_get_psize(struct DMA1_Type* p) { return (p->CCR2 & DMA1_CCR2_PSIZE) >> 8; }

// DMA1->CCR3 DMA channel 3 configuration register
enum {
	DMA1_CCR3_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR3_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR3_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR3_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR3_MINC    = 1UL << 7,               // MINC
	DMA1_CCR3_PINC    = 1UL << 6,               // PINC
	DMA1_CCR3_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR3_DIR     = 1UL << 4,               // DIR
	DMA1_CCR3_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR3_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR3_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR3_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr3_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA1_CCR3_PL) | ((val << 12) & DMA1_CCR3_PL); }
inline void dma1_ccr3_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~DMA1_CCR3_MSIZE) | ((val << 10) & DMA1_CCR3_MSIZE);
}
inline void dma1_ccr3_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR3 = (p->CCR3 & ~DMA1_CCR3_PSIZE) | ((val << 8) & DMA1_CCR3_PSIZE);
}
inline uint32_t dma1_ccr3_get_pl(struct DMA1_Type* p) { return (p->CCR3 & DMA1_CCR3_PL) >> 12; }
inline uint32_t dma1_ccr3_get_msize(struct DMA1_Type* p) { return (p->CCR3 & DMA1_CCR3_MSIZE) >> 10; }
inline uint32_t dma1_ccr3_get_psize(struct DMA1_Type* p) { return (p->CCR3 & DMA1_CCR3_PSIZE) >> 8; }

// DMA1->CCR4 DMA channel 3 configuration register
enum {
	DMA1_CCR4_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR4_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR4_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR4_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR4_MINC    = 1UL << 7,               // MINC
	DMA1_CCR4_PINC    = 1UL << 6,               // PINC
	DMA1_CCR4_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR4_DIR     = 1UL << 4,               // DIR
	DMA1_CCR4_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR4_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR4_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR4_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr4_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA1_CCR4_PL) | ((val << 12) & DMA1_CCR4_PL); }
inline void dma1_ccr4_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~DMA1_CCR4_MSIZE) | ((val << 10) & DMA1_CCR4_MSIZE);
}
inline void dma1_ccr4_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR4 = (p->CCR4 & ~DMA1_CCR4_PSIZE) | ((val << 8) & DMA1_CCR4_PSIZE);
}
inline uint32_t dma1_ccr4_get_pl(struct DMA1_Type* p) { return (p->CCR4 & DMA1_CCR4_PL) >> 12; }
inline uint32_t dma1_ccr4_get_msize(struct DMA1_Type* p) { return (p->CCR4 & DMA1_CCR4_MSIZE) >> 10; }
inline uint32_t dma1_ccr4_get_psize(struct DMA1_Type* p) { return (p->CCR4 & DMA1_CCR4_PSIZE) >> 8; }

// DMA1->CCR5 DMA channel 4 configuration register
enum {
	DMA1_CCR5_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR5_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR5_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR5_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR5_MINC    = 1UL << 7,               // MINC
	DMA1_CCR5_PINC    = 1UL << 6,               // PINC
	DMA1_CCR5_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR5_DIR     = 1UL << 4,               // DIR
	DMA1_CCR5_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR5_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR5_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR5_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr5_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA1_CCR5_PL) | ((val << 12) & DMA1_CCR5_PL); }
inline void dma1_ccr5_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR5 = (p->CCR5 & ~DMA1_CCR5_MSIZE) | ((val << 10) & DMA1_CCR5_MSIZE);
}
inline void dma1_ccr5_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR5 = (p->CCR5 & ~DMA1_CCR5_PSIZE) | ((val << 8) & DMA1_CCR5_PSIZE);
}
inline uint32_t dma1_ccr5_get_pl(struct DMA1_Type* p) { return (p->CCR5 & DMA1_CCR5_PL) >> 12; }
inline uint32_t dma1_ccr5_get_msize(struct DMA1_Type* p) { return (p->CCR5 & DMA1_CCR5_MSIZE) >> 10; }
inline uint32_t dma1_ccr5_get_psize(struct DMA1_Type* p) { return (p->CCR5 & DMA1_CCR5_PSIZE) >> 8; }

// DMA1->CCR6 DMA channel 5 configuration register
enum {
	DMA1_CCR6_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR6_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR6_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR6_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR6_MINC    = 1UL << 7,               // MINC
	DMA1_CCR6_PINC    = 1UL << 6,               // PINC
	DMA1_CCR6_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR6_DIR     = 1UL << 4,               // DIR
	DMA1_CCR6_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR6_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR6_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR6_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr6_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA1_CCR6_PL) | ((val << 12) & DMA1_CCR6_PL); }
inline void dma1_ccr6_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR6 = (p->CCR6 & ~DMA1_CCR6_MSIZE) | ((val << 10) & DMA1_CCR6_MSIZE);
}
inline void dma1_ccr6_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR6 = (p->CCR6 & ~DMA1_CCR6_PSIZE) | ((val << 8) & DMA1_CCR6_PSIZE);
}
inline uint32_t dma1_ccr6_get_pl(struct DMA1_Type* p) { return (p->CCR6 & DMA1_CCR6_PL) >> 12; }
inline uint32_t dma1_ccr6_get_msize(struct DMA1_Type* p) { return (p->CCR6 & DMA1_CCR6_MSIZE) >> 10; }
inline uint32_t dma1_ccr6_get_psize(struct DMA1_Type* p) { return (p->CCR6 & DMA1_CCR6_PSIZE) >> 8; }

// DMA1->CCR7 DMA channel 6 configuration register
enum {
	DMA1_CCR7_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR7_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR7_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR7_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR7_MINC    = 1UL << 7,               // MINC
	DMA1_CCR7_PINC    = 1UL << 6,               // PINC
	DMA1_CCR7_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR7_DIR     = 1UL << 4,               // DIR
	DMA1_CCR7_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR7_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR7_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR7_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr7_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA1_CCR7_PL) | ((val << 12) & DMA1_CCR7_PL); }
inline void dma1_ccr7_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR7 = (p->CCR7 & ~DMA1_CCR7_MSIZE) | ((val << 10) & DMA1_CCR7_MSIZE);
}
inline void dma1_ccr7_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR7 = (p->CCR7 & ~DMA1_CCR7_PSIZE) | ((val << 8) & DMA1_CCR7_PSIZE);
}
inline uint32_t dma1_ccr7_get_pl(struct DMA1_Type* p) { return (p->CCR7 & DMA1_CCR7_PL) >> 12; }
inline uint32_t dma1_ccr7_get_msize(struct DMA1_Type* p) { return (p->CCR7 & DMA1_CCR7_MSIZE) >> 10; }
inline uint32_t dma1_ccr7_get_psize(struct DMA1_Type* p) { return (p->CCR7 & DMA1_CCR7_PSIZE) >> 8; }

// DMA1->CCR8 DMA channel 7 configuration register
enum {
	DMA1_CCR8_MEM2MEM = 1UL << 14,              // MEM2MEM
	DMA1_CCR8_PL      = ((1UL << 2) - 1) << 12, // PL
	DMA1_CCR8_MSIZE   = ((1UL << 2) - 1) << 10, // MSIZE
	DMA1_CCR8_PSIZE   = ((1UL << 2) - 1) << 8,  // PSIZE
	DMA1_CCR8_MINC    = 1UL << 7,               // MINC
	DMA1_CCR8_PINC    = 1UL << 6,               // PINC
	DMA1_CCR8_CIRC    = 1UL << 5,               // CIRC
	DMA1_CCR8_DIR     = 1UL << 4,               // DIR
	DMA1_CCR8_TEIE    = 1UL << 3,               // TEIE
	DMA1_CCR8_HTIE    = 1UL << 2,               // HTIE
	DMA1_CCR8_TCIE    = 1UL << 1,               // TCIE
	DMA1_CCR8_EN      = 1UL << 0,               // channel enable
};
inline void dma1_ccr8_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR8 = (p->CCR8 & ~DMA1_CCR8_PL) | ((val << 12) & DMA1_CCR8_PL); }
inline void dma1_ccr8_set_msize(struct DMA1_Type* p, uint32_t val) {
	p->CCR8 = (p->CCR8 & ~DMA1_CCR8_MSIZE) | ((val << 10) & DMA1_CCR8_MSIZE);
}
inline void dma1_ccr8_set_psize(struct DMA1_Type* p, uint32_t val) {
	p->CCR8 = (p->CCR8 & ~DMA1_CCR8_PSIZE) | ((val << 8) & DMA1_CCR8_PSIZE);
}
inline uint32_t dma1_ccr8_get_pl(struct DMA1_Type* p) { return (p->CCR8 & DMA1_CCR8_PL) >> 12; }
inline uint32_t dma1_ccr8_get_msize(struct DMA1_Type* p) { return (p->CCR8 & DMA1_CCR8_MSIZE) >> 10; }
inline uint32_t dma1_ccr8_get_psize(struct DMA1_Type* p) { return (p->CCR8 & DMA1_CCR8_PSIZE) >> 8; }

/* DMAMUX */
struct DMAMUX_Type {
	__IO uint32_t C0CR;           // @0 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C1CR;           // @4 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C2CR;           // @8 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C3CR;           // @12 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C4CR;           // @16 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C5CR;           // @20 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C6CR;           // @24 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C7CR;           // @28 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C8CR;           // @32 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C9CR;           // @36 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C10CR;          // @40 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C11CR;          // @44 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C12CR;          // @48 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C13CR;          // @52 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C14CR;          // @56 DMAMux - DMA request line multiplexer channel x control register
	__IO uint32_t C15CR;          // @60 DMAMux - DMA request line multiplexer channel x control register
	uint8_t       RESERVED0[64];  // @64
	__I uint16_t  CSR;            // @128 DMAMUX request line multiplexer interrupt channel status register
	uint8_t       RESERVED1[2];   // @130
	__O uint16_t  CFR;            // @132 DMAMUX request line multiplexer interrupt clear flag register
	uint8_t       RESERVED2[122]; // @134
	__IO uint32_t RG0CR;          // @256 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG1CR;          // @260 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG2CR;          // @264 DMAMux - DMA request generator channel x control register
	__IO uint32_t RG3CR;          // @268 DMAMux - DMA request generator channel x control register
	uint8_t       RESERVED3[48];  // @272
	__I uint8_t   RGSR;           // @320 DMAMux - DMA request generator status register
	uint8_t       RESERVED4[3];   // @321
	__O uint8_t   RGCFR;          // @324 DMAMux - DMA request generator clear flag register
};

// DMAMUX->C0CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C0CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C0CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C0CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C0CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C0CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C0CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C0CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c0cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_SYNC_ID) | ((val << 24) & DMAMUX_C0CR_SYNC_ID);
}
inline void dmamux_c0cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_NBREQ) | ((val << 19) & DMAMUX_C0CR_NBREQ);
}
inline void dmamux_c0cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_SPOL) | ((val << 17) & DMAMUX_C0CR_SPOL);
}
inline void dmamux_c0cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C0CR = (p->C0CR & ~DMAMUX_C0CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C0CR_DMAREQ_ID);
}
inline uint32_t dmamux_c0cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c0cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_NBREQ) >> 19; }
inline uint32_t dmamux_c0cr_get_spol(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_SPOL) >> 17; }
inline uint32_t dmamux_c0cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C0CR & DMAMUX_C0CR_DMAREQ_ID) >> 0; }

// DMAMUX->C1CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C1CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C1CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C1CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C1CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C1CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C1CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C1CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c1cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_SYNC_ID) | ((val << 24) & DMAMUX_C1CR_SYNC_ID);
}
inline void dmamux_c1cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_NBREQ) | ((val << 19) & DMAMUX_C1CR_NBREQ);
}
inline void dmamux_c1cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_SPOL) | ((val << 17) & DMAMUX_C1CR_SPOL);
}
inline void dmamux_c1cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C1CR = (p->C1CR & ~DMAMUX_C1CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C1CR_DMAREQ_ID);
}
inline uint32_t dmamux_c1cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c1cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_NBREQ) >> 19; }
inline uint32_t dmamux_c1cr_get_spol(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_SPOL) >> 17; }
inline uint32_t dmamux_c1cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C1CR & DMAMUX_C1CR_DMAREQ_ID) >> 0; }

// DMAMUX->C2CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C2CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C2CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C2CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C2CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C2CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C2CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C2CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c2cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_SYNC_ID) | ((val << 24) & DMAMUX_C2CR_SYNC_ID);
}
inline void dmamux_c2cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_NBREQ) | ((val << 19) & DMAMUX_C2CR_NBREQ);
}
inline void dmamux_c2cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_SPOL) | ((val << 17) & DMAMUX_C2CR_SPOL);
}
inline void dmamux_c2cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C2CR = (p->C2CR & ~DMAMUX_C2CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C2CR_DMAREQ_ID);
}
inline uint32_t dmamux_c2cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c2cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_NBREQ) >> 19; }
inline uint32_t dmamux_c2cr_get_spol(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_SPOL) >> 17; }
inline uint32_t dmamux_c2cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C2CR & DMAMUX_C2CR_DMAREQ_ID) >> 0; }

// DMAMUX->C3CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C3CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C3CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C3CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C3CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C3CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C3CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C3CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c3cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_SYNC_ID) | ((val << 24) & DMAMUX_C3CR_SYNC_ID);
}
inline void dmamux_c3cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_NBREQ) | ((val << 19) & DMAMUX_C3CR_NBREQ);
}
inline void dmamux_c3cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_SPOL) | ((val << 17) & DMAMUX_C3CR_SPOL);
}
inline void dmamux_c3cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C3CR = (p->C3CR & ~DMAMUX_C3CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C3CR_DMAREQ_ID);
}
inline uint32_t dmamux_c3cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c3cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_NBREQ) >> 19; }
inline uint32_t dmamux_c3cr_get_spol(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_SPOL) >> 17; }
inline uint32_t dmamux_c3cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C3CR & DMAMUX_C3CR_DMAREQ_ID) >> 0; }

// DMAMUX->C4CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C4CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C4CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C4CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C4CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C4CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C4CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C4CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c4cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_SYNC_ID) | ((val << 24) & DMAMUX_C4CR_SYNC_ID);
}
inline void dmamux_c4cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_NBREQ) | ((val << 19) & DMAMUX_C4CR_NBREQ);
}
inline void dmamux_c4cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_SPOL) | ((val << 17) & DMAMUX_C4CR_SPOL);
}
inline void dmamux_c4cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C4CR = (p->C4CR & ~DMAMUX_C4CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C4CR_DMAREQ_ID);
}
inline uint32_t dmamux_c4cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c4cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_NBREQ) >> 19; }
inline uint32_t dmamux_c4cr_get_spol(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_SPOL) >> 17; }
inline uint32_t dmamux_c4cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C4CR & DMAMUX_C4CR_DMAREQ_ID) >> 0; }

// DMAMUX->C5CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C5CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C5CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C5CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C5CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C5CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C5CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C5CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c5cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_SYNC_ID) | ((val << 24) & DMAMUX_C5CR_SYNC_ID);
}
inline void dmamux_c5cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_NBREQ) | ((val << 19) & DMAMUX_C5CR_NBREQ);
}
inline void dmamux_c5cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_SPOL) | ((val << 17) & DMAMUX_C5CR_SPOL);
}
inline void dmamux_c5cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C5CR = (p->C5CR & ~DMAMUX_C5CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C5CR_DMAREQ_ID);
}
inline uint32_t dmamux_c5cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c5cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_NBREQ) >> 19; }
inline uint32_t dmamux_c5cr_get_spol(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_SPOL) >> 17; }
inline uint32_t dmamux_c5cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C5CR & DMAMUX_C5CR_DMAREQ_ID) >> 0; }

// DMAMUX->C6CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C6CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C6CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C6CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C6CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C6CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C6CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C6CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c6cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_SYNC_ID) | ((val << 24) & DMAMUX_C6CR_SYNC_ID);
}
inline void dmamux_c6cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_NBREQ) | ((val << 19) & DMAMUX_C6CR_NBREQ);
}
inline void dmamux_c6cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_SPOL) | ((val << 17) & DMAMUX_C6CR_SPOL);
}
inline void dmamux_c6cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C6CR = (p->C6CR & ~DMAMUX_C6CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C6CR_DMAREQ_ID);
}
inline uint32_t dmamux_c6cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c6cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_NBREQ) >> 19; }
inline uint32_t dmamux_c6cr_get_spol(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_SPOL) >> 17; }
inline uint32_t dmamux_c6cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C6CR & DMAMUX_C6CR_DMAREQ_ID) >> 0; }

// DMAMUX->C7CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C7CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C7CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C7CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C7CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C7CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C7CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C7CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c7cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_SYNC_ID) | ((val << 24) & DMAMUX_C7CR_SYNC_ID);
}
inline void dmamux_c7cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_NBREQ) | ((val << 19) & DMAMUX_C7CR_NBREQ);
}
inline void dmamux_c7cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_SPOL) | ((val << 17) & DMAMUX_C7CR_SPOL);
}
inline void dmamux_c7cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C7CR = (p->C7CR & ~DMAMUX_C7CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C7CR_DMAREQ_ID);
}
inline uint32_t dmamux_c7cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C7CR & DMAMUX_C7CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c7cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C7CR & DMAMUX_C7CR_NBREQ) >> 19; }
inline uint32_t dmamux_c7cr_get_spol(struct DMAMUX_Type* p) { return (p->C7CR & DMAMUX_C7CR_SPOL) >> 17; }
inline uint32_t dmamux_c7cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C7CR & DMAMUX_C7CR_DMAREQ_ID) >> 0; }

// DMAMUX->C8CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C8CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C8CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C8CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C8CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C8CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C8CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C8CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c8cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_SYNC_ID) | ((val << 24) & DMAMUX_C8CR_SYNC_ID);
}
inline void dmamux_c8cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_NBREQ) | ((val << 19) & DMAMUX_C8CR_NBREQ);
}
inline void dmamux_c8cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_SPOL) | ((val << 17) & DMAMUX_C8CR_SPOL);
}
inline void dmamux_c8cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C8CR = (p->C8CR & ~DMAMUX_C8CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C8CR_DMAREQ_ID);
}
inline uint32_t dmamux_c8cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C8CR & DMAMUX_C8CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c8cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C8CR & DMAMUX_C8CR_NBREQ) >> 19; }
inline uint32_t dmamux_c8cr_get_spol(struct DMAMUX_Type* p) { return (p->C8CR & DMAMUX_C8CR_SPOL) >> 17; }
inline uint32_t dmamux_c8cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C8CR & DMAMUX_C8CR_DMAREQ_ID) >> 0; }

// DMAMUX->C9CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C9CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C9CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C9CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C9CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C9CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C9CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C9CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c9cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_SYNC_ID) | ((val << 24) & DMAMUX_C9CR_SYNC_ID);
}
inline void dmamux_c9cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_NBREQ) | ((val << 19) & DMAMUX_C9CR_NBREQ);
}
inline void dmamux_c9cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_SPOL) | ((val << 17) & DMAMUX_C9CR_SPOL);
}
inline void dmamux_c9cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C9CR = (p->C9CR & ~DMAMUX_C9CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C9CR_DMAREQ_ID);
}
inline uint32_t dmamux_c9cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C9CR & DMAMUX_C9CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c9cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C9CR & DMAMUX_C9CR_NBREQ) >> 19; }
inline uint32_t dmamux_c9cr_get_spol(struct DMAMUX_Type* p) { return (p->C9CR & DMAMUX_C9CR_SPOL) >> 17; }
inline uint32_t dmamux_c9cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C9CR & DMAMUX_C9CR_DMAREQ_ID) >> 0; }

// DMAMUX->C10CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C10CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C10CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C10CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C10CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C10CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C10CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C10CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c10cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_SYNC_ID) | ((val << 24) & DMAMUX_C10CR_SYNC_ID);
}
inline void dmamux_c10cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_NBREQ) | ((val << 19) & DMAMUX_C10CR_NBREQ);
}
inline void dmamux_c10cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_SPOL) | ((val << 17) & DMAMUX_C10CR_SPOL);
}
inline void dmamux_c10cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C10CR = (p->C10CR & ~DMAMUX_C10CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C10CR_DMAREQ_ID);
}
inline uint32_t dmamux_c10cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C10CR & DMAMUX_C10CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c10cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C10CR & DMAMUX_C10CR_NBREQ) >> 19; }
inline uint32_t dmamux_c10cr_get_spol(struct DMAMUX_Type* p) { return (p->C10CR & DMAMUX_C10CR_SPOL) >> 17; }
inline uint32_t dmamux_c10cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C10CR & DMAMUX_C10CR_DMAREQ_ID) >> 0; }

// DMAMUX->C11CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C11CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C11CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C11CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C11CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C11CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C11CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C11CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c11cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_SYNC_ID) | ((val << 24) & DMAMUX_C11CR_SYNC_ID);
}
inline void dmamux_c11cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_NBREQ) | ((val << 19) & DMAMUX_C11CR_NBREQ);
}
inline void dmamux_c11cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_SPOL) | ((val << 17) & DMAMUX_C11CR_SPOL);
}
inline void dmamux_c11cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C11CR = (p->C11CR & ~DMAMUX_C11CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C11CR_DMAREQ_ID);
}
inline uint32_t dmamux_c11cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C11CR & DMAMUX_C11CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c11cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C11CR & DMAMUX_C11CR_NBREQ) >> 19; }
inline uint32_t dmamux_c11cr_get_spol(struct DMAMUX_Type* p) { return (p->C11CR & DMAMUX_C11CR_SPOL) >> 17; }
inline uint32_t dmamux_c11cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C11CR & DMAMUX_C11CR_DMAREQ_ID) >> 0; }

// DMAMUX->C12CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C12CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C12CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C12CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C12CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C12CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C12CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C12CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c12cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_SYNC_ID) | ((val << 24) & DMAMUX_C12CR_SYNC_ID);
}
inline void dmamux_c12cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_NBREQ) | ((val << 19) & DMAMUX_C12CR_NBREQ);
}
inline void dmamux_c12cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_SPOL) | ((val << 17) & DMAMUX_C12CR_SPOL);
}
inline void dmamux_c12cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C12CR = (p->C12CR & ~DMAMUX_C12CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C12CR_DMAREQ_ID);
}
inline uint32_t dmamux_c12cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C12CR & DMAMUX_C12CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c12cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C12CR & DMAMUX_C12CR_NBREQ) >> 19; }
inline uint32_t dmamux_c12cr_get_spol(struct DMAMUX_Type* p) { return (p->C12CR & DMAMUX_C12CR_SPOL) >> 17; }
inline uint32_t dmamux_c12cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C12CR & DMAMUX_C12CR_DMAREQ_ID) >> 0; }

// DMAMUX->C13CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C13CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C13CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C13CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C13CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C13CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C13CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C13CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c13cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_SYNC_ID) | ((val << 24) & DMAMUX_C13CR_SYNC_ID);
}
inline void dmamux_c13cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_NBREQ) | ((val << 19) & DMAMUX_C13CR_NBREQ);
}
inline void dmamux_c13cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_SPOL) | ((val << 17) & DMAMUX_C13CR_SPOL);
}
inline void dmamux_c13cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C13CR = (p->C13CR & ~DMAMUX_C13CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C13CR_DMAREQ_ID);
}
inline uint32_t dmamux_c13cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C13CR & DMAMUX_C13CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c13cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C13CR & DMAMUX_C13CR_NBREQ) >> 19; }
inline uint32_t dmamux_c13cr_get_spol(struct DMAMUX_Type* p) { return (p->C13CR & DMAMUX_C13CR_SPOL) >> 17; }
inline uint32_t dmamux_c13cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C13CR & DMAMUX_C13CR_DMAREQ_ID) >> 0; }

// DMAMUX->C14CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C14CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C14CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C14CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C14CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C14CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C14CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C14CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c14cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_SYNC_ID) | ((val << 24) & DMAMUX_C14CR_SYNC_ID);
}
inline void dmamux_c14cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_NBREQ) | ((val << 19) & DMAMUX_C14CR_NBREQ);
}
inline void dmamux_c14cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_SPOL) | ((val << 17) & DMAMUX_C14CR_SPOL);
}
inline void dmamux_c14cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C14CR = (p->C14CR & ~DMAMUX_C14CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C14CR_DMAREQ_ID);
}
inline uint32_t dmamux_c14cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C14CR & DMAMUX_C14CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c14cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C14CR & DMAMUX_C14CR_NBREQ) >> 19; }
inline uint32_t dmamux_c14cr_get_spol(struct DMAMUX_Type* p) { return (p->C14CR & DMAMUX_C14CR_SPOL) >> 17; }
inline uint32_t dmamux_c14cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C14CR & DMAMUX_C14CR_DMAREQ_ID) >> 0; }

// DMAMUX->C15CR DMAMux - DMA request line multiplexer channel x control register
enum {
	DMAMUX_C15CR_SYNC_ID = ((1UL << 5) - 1) << 24, // Synchronization input selected
	DMAMUX_C15CR_NBREQ =
	    ((1UL << 5) - 1) << 19, // Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is
	                            // generated. In synchronous mode, it also defines the number of DMA requests to forward after a
	                            // synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1.
	                            // Note: This field can only be written when both SE and EGE bits are reset.
	DMAMUX_C15CR_SPOL =
	    ((1UL << 2) - 1)
	    << 17, // Synchronization event type selector Defines the synchronization event on the selected synchronization input:
	DMAMUX_C15CR_SE        = 1UL << 16,             // Synchronous operating mode enable/disable
	DMAMUX_C15CR_EGE       = 1UL << 9,              // Event generation enable/disable
	DMAMUX_C15CR_SOIE      = 1UL << 8,              // Interrupt enable at synchronization event overrun
	DMAMUX_C15CR_DMAREQ_ID = ((1UL << 7) - 1) << 0, // Input DMA request line selected
};
inline void dmamux_c15cr_set_sync_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_SYNC_ID) | ((val << 24) & DMAMUX_C15CR_SYNC_ID);
}
inline void dmamux_c15cr_set_nbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_NBREQ) | ((val << 19) & DMAMUX_C15CR_NBREQ);
}
inline void dmamux_c15cr_set_spol(struct DMAMUX_Type* p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_SPOL) | ((val << 17) & DMAMUX_C15CR_SPOL);
}
inline void dmamux_c15cr_set_dmareq_id(struct DMAMUX_Type* p, uint32_t val) {
	p->C15CR = (p->C15CR & ~DMAMUX_C15CR_DMAREQ_ID) | ((val << 0) & DMAMUX_C15CR_DMAREQ_ID);
}
inline uint32_t dmamux_c15cr_get_sync_id(struct DMAMUX_Type* p) { return (p->C15CR & DMAMUX_C15CR_SYNC_ID) >> 24; }
inline uint32_t dmamux_c15cr_get_nbreq(struct DMAMUX_Type* p) { return (p->C15CR & DMAMUX_C15CR_NBREQ) >> 19; }
inline uint32_t dmamux_c15cr_get_spol(struct DMAMUX_Type* p) { return (p->C15CR & DMAMUX_C15CR_SPOL) >> 17; }
inline uint32_t dmamux_c15cr_get_dmareq_id(struct DMAMUX_Type* p) { return (p->C15CR & DMAMUX_C15CR_DMAREQ_ID) >> 0; }

// DMAMUX->RG0CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG0CR_GNBREQ = ((1UL << 5) - 1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a
	                                              // trigger event, then stop generating. The actual number of generated DMA requests is
	                                              // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG0CR_GPOL =
	    ((1UL << 2) - 1)
	    << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG0CR_GE     = 1UL << 16,             // DMA request generator channel enable/disable
	DMAMUX_RG0CR_OIE    = 1UL << 8,              // Interrupt enable at trigger event overrun
	DMAMUX_RG0CR_SIG_ID = ((1UL << 5) - 1) << 0, // DMA request trigger input selected
};
inline void dmamux_rg0cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_GNBREQ) | ((val << 19) & DMAMUX_RG0CR_GNBREQ);
}
inline void dmamux_rg0cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) {
	p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_GPOL) | ((val << 17) & DMAMUX_RG0CR_GPOL);
}
inline void dmamux_rg0cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) {
	p->RG0CR = (p->RG0CR & ~DMAMUX_RG0CR_SIG_ID) | ((val << 0) & DMAMUX_RG0CR_SIG_ID);
}
inline uint32_t dmamux_rg0cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG0CR & DMAMUX_RG0CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg0cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG0CR & DMAMUX_RG0CR_GPOL) >> 17; }
inline uint32_t dmamux_rg0cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG0CR & DMAMUX_RG0CR_SIG_ID) >> 0; }

// DMAMUX->RG1CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG1CR_GNBREQ = ((1UL << 5) - 1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a
	                                              // trigger event, then stop generating. The actual number of generated DMA requests is
	                                              // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG1CR_GPOL =
	    ((1UL << 2) - 1)
	    << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG1CR_GE     = 1UL << 16,             // DMA request generator channel enable/disable
	DMAMUX_RG1CR_OIE    = 1UL << 8,              // Interrupt enable at trigger event overrun
	DMAMUX_RG1CR_SIG_ID = ((1UL << 5) - 1) << 0, // DMA request trigger input selected
};
inline void dmamux_rg1cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_GNBREQ) | ((val << 19) & DMAMUX_RG1CR_GNBREQ);
}
inline void dmamux_rg1cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) {
	p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_GPOL) | ((val << 17) & DMAMUX_RG1CR_GPOL);
}
inline void dmamux_rg1cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) {
	p->RG1CR = (p->RG1CR & ~DMAMUX_RG1CR_SIG_ID) | ((val << 0) & DMAMUX_RG1CR_SIG_ID);
}
inline uint32_t dmamux_rg1cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG1CR & DMAMUX_RG1CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg1cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG1CR & DMAMUX_RG1CR_GPOL) >> 17; }
inline uint32_t dmamux_rg1cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG1CR & DMAMUX_RG1CR_SIG_ID) >> 0; }

// DMAMUX->RG2CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG2CR_GNBREQ = ((1UL << 5) - 1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a
	                                              // trigger event, then stop generating. The actual number of generated DMA requests is
	                                              // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG2CR_GPOL =
	    ((1UL << 2) - 1)
	    << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG2CR_GE     = 1UL << 16,             // DMA request generator channel enable/disable
	DMAMUX_RG2CR_OIE    = 1UL << 8,              // Interrupt enable at trigger event overrun
	DMAMUX_RG2CR_SIG_ID = ((1UL << 5) - 1) << 0, // DMA request trigger input selected
};
inline void dmamux_rg2cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_GNBREQ) | ((val << 19) & DMAMUX_RG2CR_GNBREQ);
}
inline void dmamux_rg2cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) {
	p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_GPOL) | ((val << 17) & DMAMUX_RG2CR_GPOL);
}
inline void dmamux_rg2cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) {
	p->RG2CR = (p->RG2CR & ~DMAMUX_RG2CR_SIG_ID) | ((val << 0) & DMAMUX_RG2CR_SIG_ID);
}
inline uint32_t dmamux_rg2cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG2CR & DMAMUX_RG2CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg2cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG2CR & DMAMUX_RG2CR_GPOL) >> 17; }
inline uint32_t dmamux_rg2cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG2CR & DMAMUX_RG2CR_SIG_ID) >> 0; }

// DMAMUX->RG3CR DMAMux - DMA request generator channel x control register
enum {
	DMAMUX_RG3CR_GNBREQ = ((1UL << 5) - 1) << 19, // Number of DMA requests to generate Defines the number of DMA requests generated after a
	                                              // trigger event, then stop generating. The actual number of generated DMA requests is
	                                              // GNBREQ+1. Note: This field can only be written when GE bit is reset.
	DMAMUX_RG3CR_GPOL =
	    ((1UL << 2) - 1)
	    << 17, // DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
	DMAMUX_RG3CR_GE     = 1UL << 16,             // DMA request generator channel enable/disable
	DMAMUX_RG3CR_OIE    = 1UL << 8,              // Interrupt enable at trigger event overrun
	DMAMUX_RG3CR_SIG_ID = ((1UL << 5) - 1) << 0, // DMA request trigger input selected
};
inline void dmamux_rg3cr_set_gnbreq(struct DMAMUX_Type* p, uint32_t val) {
	p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_GNBREQ) | ((val << 19) & DMAMUX_RG3CR_GNBREQ);
}
inline void dmamux_rg3cr_set_gpol(struct DMAMUX_Type* p, uint32_t val) {
	p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_GPOL) | ((val << 17) & DMAMUX_RG3CR_GPOL);
}
inline void dmamux_rg3cr_set_sig_id(struct DMAMUX_Type* p, uint32_t val) {
	p->RG3CR = (p->RG3CR & ~DMAMUX_RG3CR_SIG_ID) | ((val << 0) & DMAMUX_RG3CR_SIG_ID);
}
inline uint32_t dmamux_rg3cr_get_gnbreq(struct DMAMUX_Type* p) { return (p->RG3CR & DMAMUX_RG3CR_GNBREQ) >> 19; }
inline uint32_t dmamux_rg3cr_get_gpol(struct DMAMUX_Type* p) { return (p->RG3CR & DMAMUX_RG3CR_GPOL) >> 17; }
inline uint32_t dmamux_rg3cr_get_sig_id(struct DMAMUX_Type* p) { return (p->RG3CR & DMAMUX_RG3CR_SIG_ID) >> 0; }

// DMAMUX->RGSR DMAMux - DMA request generator status register
enum {
	DMAMUX_RGSR_OF = ((1UL << 4) - 1) << 0, // Trigger event overrun flag The flag is set when a trigger event occurs on DMA request
	                                        // generator channel x, while the DMA request generator counter value is lower than GNBREQ. The
	                                        // flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
};
inline uint32_t dmamux_rgsr_get_of(struct DMAMUX_Type* p) { return (p->RGSR & DMAMUX_RGSR_OF) >> 0; }

// DMAMUX->RGCFR DMAMux - DMA request generator clear flag register
enum {
	DMAMUX_RGCFR_COF = ((1UL << 4) - 1) << 0, // Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun
	                                          // flag OFx in the DMAMUX_RGCSR register.
};
inline void dmamux_rgcfr_set_cof(struct DMAMUX_Type* p, uint32_t val) {
	p->RGCFR = (p->RGCFR & ~DMAMUX_RGCFR_COF) | ((val << 0) & DMAMUX_RGCFR_COF);
}
inline uint32_t dmamux_rgcfr_get_cof(struct DMAMUX_Type* p) { return (p->RGCFR & DMAMUX_RGCFR_COF) >> 0; }

/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t IMR1;         // @0 Interrupt mask register
	__IO uint32_t EMR1;         // @4 Event mask register
	__IO uint32_t RTSR1;        // @8 Rising Trigger selection register
	__IO uint32_t FTSR1;        // @12 Falling Trigger selection register
	__IO uint32_t SWIER1;       // @16 Software interrupt event register
	__IO uint32_t PR1;          // @20 Pending register
	uint8_t       RESERVED0[8]; // @24
	__IO uint16_t IMR2;         // @32 Interrupt mask register
	uint8_t       RESERVED1[2]; // @34
	__IO uint16_t EMR2;         // @36 Event mask register
	uint8_t       RESERVED2[2]; // @38
	__IO uint16_t RTSR2;        // @40 Rising Trigger selection register
	uint8_t       RESERVED3[2]; // @42
	__IO uint8_t  FTSR2;        // @44 Falling Trigger selection register
	uint8_t       RESERVED4[3]; // @45
	__IO uint8_t  SWIER2;       // @48 Software interrupt event register
	uint8_t       RESERVED5[3]; // @49
	__IO uint8_t  PR2;          // @52 Pending register
};

// EXTI->RTSR1 Rising Trigger selection register
enum {
	EXTI_RTSR1_RT   = ((1UL << 3) - 1) << 29, // RT
	EXTI_RTSR1_RT22 = 1UL << 22,              // Rising trigger event configuration of line 22
	EXTI_RTSR1_RT21 = 1UL << 21,              // Rising trigger event configuration of line 21
	EXTI_RTSR1_RT20 = 1UL << 20,              // Rising trigger event configuration of line 20
	EXTI_RTSR1_RT19 = 1UL << 19,              // Rising trigger event configuration of line 19
	EXTI_RTSR1_RT18 = 1UL << 18,              // Rising trigger event configuration of line 18
	EXTI_RTSR1_RT16 = 1UL << 16,              // Rising trigger event configuration of line 16
	EXTI_RTSR1_RT15 = 1UL << 15,              // Rising trigger event configuration of line 15
	EXTI_RTSR1_RT14 = 1UL << 14,              // Rising trigger event configuration of line 14
	EXTI_RTSR1_RT13 = 1UL << 13,              // Rising trigger event configuration of line 13
	EXTI_RTSR1_RT12 = 1UL << 12,              // Rising trigger event configuration of line 12
	EXTI_RTSR1_RT11 = 1UL << 11,              // Rising trigger event configuration of line 11
	EXTI_RTSR1_RT10 = 1UL << 10,              // Rising trigger event configuration of line 10
	EXTI_RTSR1_RT9  = 1UL << 9,               // Rising trigger event configuration of line 9
	EXTI_RTSR1_RT8  = 1UL << 8,               // Rising trigger event configuration of line 8
	EXTI_RTSR1_RT7  = 1UL << 7,               // Rising trigger event configuration of line 7
	EXTI_RTSR1_RT6  = 1UL << 6,               // Rising trigger event configuration of line 6
	EXTI_RTSR1_RT5  = 1UL << 5,               // Rising trigger event configuration of line 5
	EXTI_RTSR1_RT4  = 1UL << 4,               // Rising trigger event configuration of line 4
	EXTI_RTSR1_RT3  = 1UL << 3,               // Rising trigger event configuration of line 3
	EXTI_RTSR1_RT2  = 1UL << 2,               // Rising trigger event configuration of line 2
	EXTI_RTSR1_RT1  = 1UL << 1,               // Rising trigger event configuration of line 1
	EXTI_RTSR1_RT0  = 1UL << 0,               // Rising trigger event configuration of line 0
};
inline void exti_rtsr1_set_rt(struct EXTI_Type* p, uint32_t val) { p->RTSR1 = (p->RTSR1 & ~EXTI_RTSR1_RT) | ((val << 29) & EXTI_RTSR1_RT); }
inline uint32_t exti_rtsr1_get_rt(struct EXTI_Type* p) { return (p->RTSR1 & EXTI_RTSR1_RT) >> 29; }

// EXTI->FTSR1 Falling Trigger selection register
enum {
	EXTI_FTSR1_FT22 = 1UL << 22, // Falling trigger event configuration of line 22
	EXTI_FTSR1_FT21 = 1UL << 21, // Falling trigger event configuration of line 21
	EXTI_FTSR1_FT20 = 1UL << 20, // Falling trigger event configuration of line 20
	EXTI_FTSR1_FT19 = 1UL << 19, // Falling trigger event configuration of line 19
	EXTI_FTSR1_FT18 = 1UL << 18, // Falling trigger event configuration of line 18
	EXTI_FTSR1_FT16 = 1UL << 16, // Falling trigger event configuration of line 16
	EXTI_FTSR1_FT15 = 1UL << 15, // Falling trigger event configuration of line 15
	EXTI_FTSR1_FT14 = 1UL << 14, // Falling trigger event configuration of line 14
	EXTI_FTSR1_FT13 = 1UL << 13, // Falling trigger event configuration of line 13
	EXTI_FTSR1_FT12 = 1UL << 12, // Falling trigger event configuration of line 12
	EXTI_FTSR1_FT11 = 1UL << 11, // Falling trigger event configuration of line 11
	EXTI_FTSR1_FT10 = 1UL << 10, // Falling trigger event configuration of line 10
	EXTI_FTSR1_FT9  = 1UL << 9,  // Falling trigger event configuration of line 9
	EXTI_FTSR1_FT8  = 1UL << 8,  // Falling trigger event configuration of line 8
	EXTI_FTSR1_FT7  = 1UL << 7,  // Falling trigger event configuration of line 7
	EXTI_FTSR1_FT6  = 1UL << 6,  // Falling trigger event configuration of line 6
	EXTI_FTSR1_FT5  = 1UL << 5,  // Falling trigger event configuration of line 5
	EXTI_FTSR1_FT4  = 1UL << 4,  // Falling trigger event configuration of line 4
	EXTI_FTSR1_FT3  = 1UL << 3,  // Falling trigger event configuration of line 3
	EXTI_FTSR1_FT2  = 1UL << 2,  // Falling trigger event configuration of line 2
	EXTI_FTSR1_FT1  = 1UL << 1,  // Falling trigger event configuration of line 1
	EXTI_FTSR1_FT0  = 1UL << 0,  // Falling trigger event configuration of line 0
};

// EXTI->SWIER1 Software interrupt event register
enum {
	EXTI_SWIER1_SWI22 = 1UL << 22, // Software Interrupt on line 22
	EXTI_SWIER1_SWI21 = 1UL << 21, // Software Interrupt on line 21
	EXTI_SWIER1_SWI20 = 1UL << 20, // Software Interrupt on line 20
	EXTI_SWIER1_SWI19 = 1UL << 19, // Software Interrupt on line 19
	EXTI_SWIER1_SWI18 = 1UL << 18, // Software Interrupt on line 18
	EXTI_SWIER1_SWI16 = 1UL << 16, // Software Interrupt on line 16
	EXTI_SWIER1_SWI15 = 1UL << 15, // Software Interrupt on line 15
	EXTI_SWIER1_SWI14 = 1UL << 14, // Software Interrupt on line 14
	EXTI_SWIER1_SWI13 = 1UL << 13, // Software Interrupt on line 13
	EXTI_SWIER1_SWI12 = 1UL << 12, // Software Interrupt on line 12
	EXTI_SWIER1_SWI11 = 1UL << 11, // Software Interrupt on line 11
	EXTI_SWIER1_SWI10 = 1UL << 10, // Software Interrupt on line 10
	EXTI_SWIER1_SWI9  = 1UL << 9,  // Software Interrupt on line 9
	EXTI_SWIER1_SWI8  = 1UL << 8,  // Software Interrupt on line 8
	EXTI_SWIER1_SWI7  = 1UL << 7,  // Software Interrupt on line 7
	EXTI_SWIER1_SWI6  = 1UL << 6,  // Software Interrupt on line 6
	EXTI_SWIER1_SWI5  = 1UL << 5,  // Software Interrupt on line 5
	EXTI_SWIER1_SWI4  = 1UL << 4,  // Software Interrupt on line 4
	EXTI_SWIER1_SWI3  = 1UL << 3,  // Software Interrupt on line 3
	EXTI_SWIER1_SWI2  = 1UL << 2,  // Software Interrupt on line 2
	EXTI_SWIER1_SWI1  = 1UL << 1,  // Software Interrupt on line 1
	EXTI_SWIER1_SWI0  = 1UL << 0,  // Software Interrupt on line 0
};

// EXTI->PR1 Pending register
enum {
	EXTI_PR1_PIF22 = 1UL << 22, // Pending bit 22
	EXTI_PR1_PIF21 = 1UL << 21, // Pending bit 21
	EXTI_PR1_PIF20 = 1UL << 20, // Pending bit 20
	EXTI_PR1_PIF19 = 1UL << 19, // Pending bit 19
	EXTI_PR1_PIF18 = 1UL << 18, // Pending bit 18
	EXTI_PR1_PIF16 = 1UL << 16, // Pending bit 16
	EXTI_PR1_PIF15 = 1UL << 15, // Pending bit 15
	EXTI_PR1_PIF14 = 1UL << 14, // Pending bit 14
	EXTI_PR1_PIF13 = 1UL << 13, // Pending bit 13
	EXTI_PR1_PIF12 = 1UL << 12, // Pending bit 12
	EXTI_PR1_PIF11 = 1UL << 11, // Pending bit 11
	EXTI_PR1_PIF10 = 1UL << 10, // Pending bit 10
	EXTI_PR1_PIF9  = 1UL << 9,  // Pending bit 9
	EXTI_PR1_PIF8  = 1UL << 8,  // Pending bit 8
	EXTI_PR1_PIF7  = 1UL << 7,  // Pending bit 7
	EXTI_PR1_PIF6  = 1UL << 6,  // Pending bit 6
	EXTI_PR1_PIF5  = 1UL << 5,  // Pending bit 5
	EXTI_PR1_PIF4  = 1UL << 4,  // Pending bit 4
	EXTI_PR1_PIF3  = 1UL << 3,  // Pending bit 3
	EXTI_PR1_PIF2  = 1UL << 2,  // Pending bit 2
	EXTI_PR1_PIF1  = 1UL << 1,  // Pending bit 1
	EXTI_PR1_PIF0  = 1UL << 0,  // Pending bit 0
};

// EXTI->IMR2 Interrupt mask register
enum {
	EXTI_IMR2_IMX = ((1UL << 12) - 1) << 0, // Merged Interrupt Mask on external/internal line 43
};
inline void exti_imr2_set_imx(struct EXTI_Type* p, uint32_t val) { p->IMR2 = (p->IMR2 & ~EXTI_IMR2_IMX) | ((val << 0) & EXTI_IMR2_IMX); }
inline uint32_t exti_imr2_get_imx(struct EXTI_Type* p) { return (p->IMR2 & EXTI_IMR2_IMX) >> 0; }

// EXTI->EMR2 Event mask register
enum {
	EXTI_EMR2_EMX = ((1UL << 9) - 1) << 0, // Merged Event mask on external/internal line 40
};
inline void exti_emr2_set_emx(struct EXTI_Type* p, uint32_t val) { p->EMR2 = (p->EMR2 & ~EXTI_EMR2_EMX) | ((val << 0) & EXTI_EMR2_EMX); }
inline uint32_t exti_emr2_get_emx(struct EXTI_Type* p) { return (p->EMR2 & EXTI_EMR2_EMX) >> 0; }

// EXTI->RTSR2 Rising Trigger selection register
enum {
	EXTI_RTSR2_RT41 = 1UL << 9, // Rising trigger event configuration bit of line 41
	EXTI_RTSR2_RT40 = 1UL << 8, // Rising trigger event configuration bit of line 40
	EXTI_RTSR2_RT39 = 1UL << 7, // Rising trigger event configuration bit of line 39
	EXTI_RTSR2_RT38 = 1UL << 6, // Rising trigger event configuration bit of line 38
	EXTI_RTSR2_RT33 = 1UL << 1, // Rising trigger event configuration bit of line 32
	EXTI_RTSR2_RT32 = 1UL << 0, // Rising trigger event configuration bit of line 32
};

// EXTI->FTSR2 Falling Trigger selection register
enum {
	EXTI_FTSR2_FT38 = 1UL << 6, // Falling trigger event configuration bit of line 38
	EXTI_FTSR2_FT37 = 1UL << 5, // Falling trigger event configuration bit of line 37
	EXTI_FTSR2_FT36 = 1UL << 4, // Falling trigger event configuration bit of line 36
	EXTI_FTSR2_FT35 = 1UL << 3, // Falling trigger event configuration bit of line 35
};

// EXTI->SWIER2 Software interrupt event register
enum {
	EXTI_SWIER2_SWI38 = 1UL << 6, // Software interrupt on line 38
	EXTI_SWIER2_SWI37 = 1UL << 5, // Software interrupt on line 37
	EXTI_SWIER2_SWI36 = 1UL << 4, // Software interrupt on line 36
	EXTI_SWIER2_SWI35 = 1UL << 3, // Software interrupt on line 35
};

// EXTI->PR2 Pending register
enum {
	EXTI_PR2_PIF38 = 1UL << 6, // Pending interrupt flag on line 38
	EXTI_PR2_PIF37 = 1UL << 5, // Pending interrupt flag on line 37
	EXTI_PR2_PIF36 = 1UL << 4, // Pending interrupt flag on line 36
	EXTI_PR2_PIF35 = 1UL << 3, // Pending interrupt flag on line 35
};

/* FDCAN */
struct FDCAN_Type {
	__I uint32_t  CREL;         // @0 FDCAN Core Release Register
	__I uint32_t  ENDN;         // @4 FDCAN Core Release Register
	uint8_t       RESERVED0[4]; // @8
	__IO uint32_t DBTP; // @12 This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in
	                    // the range of 4 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock
	                    // periods. tq = (DBRP + 1) FDCAN clock period. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2.
	                    // Therefore the length of the bit time is (programmed values) [DTSEG1 + DTSEG2 + 3] tq or (functional values)
	                    // [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT) is zero, meaning the
	                    // data for the next bit is available at the first clock edge after the sample point.
	__IO uint8_t
	    TEST; // @16 Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are
	          // set to their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are
	          // hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
	uint8_t       RESERVED1[3]; // @17
	__IO uint16_t RWD; // @20 The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM
	                   // Watchdog Counter with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when
	                   // the Message RAM signals successful completion by activating its READY output. In case there is no response from
	                   // the Message RAM until the counter has counted down to 0, the counter stops and interrupt flag IR[WDI] bit is set.
	                   // The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
	uint8_t       RESERVED2[2];  // @22
	__IO uint16_t CCCR;          // @24 For details about setting and resetting of single bits see Software initialization.
	uint8_t       RESERVED3[2];  // @26
	__IO uint32_t NBTP;          // @28 FDCAN_NBTP
	__IO uint32_t TSCC;          // @32 FDCAN Timestamp Counter Configuration Register
	__I uint16_t  TSCV;          // @36 FDCAN Timestamp Counter Value Register
	uint8_t       RESERVED4[2];  // @38
	__IO uint32_t TOCC;          // @40 FDCAN Timeout Counter Configuration Register
	__I uint16_t  TOCV;          // @44 FDCAN Timeout Counter Value Register
	uint8_t       RESERVED5[18]; // @46
	__I uint32_t  ECR;           // @64 FDCAN Error Counter Register
	__IO uint32_t PSR;           // @68 FDCAN Protocol Status Register
	__IO uint16_t TDCR;          // @72 FDCAN Transmitter Delay Compensation Register
	uint8_t       RESERVED6[6];  // @74
	__IO uint32_t IR;  // @80 The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until
	                   // the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no
	                   // effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated.
	                   // The configuration of ILS controls on which interrupt line an interrupt is signaled.
	__IO uint32_t IE;  // @84 The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be
	                   // signaled on an interrupt line.
	__IO uint32_t ILS; // @88 The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the
	                   // Interrupt Register to one of the two module interrupt lines. For interrupt generation the respective interrupt
	                   // line has to be enabled via ILE[EINT0] and ILE[EINT1].
	__IO uint8_t
	        ILE; // @92 Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
	uint8_t RESERVED7[35]; // @93
	__IO uint8_t RXGFC;    // @128 Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for
	                    // standard and extended messages as described in Figure706: Standard Message ID filter path and Figure707: Extended
	                    // Message ID filter path.
	uint8_t       RESERVED8[3]; // @129
	__IO uint32_t XIDAM;        // @132 FDCAN Extended ID and Mask Register
	__I uint16_t
	    HPMS; // @136 This register is updated every time a Message ID filter element configured to generate a priority event match. This
	          // can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
	uint8_t       RESERVED9[6];   // @138
	__IO uint32_t RXF0S;          // @144 FDCAN Rx FIFO 0 Status Register
	__IO uint8_t  RXF0A;          // @148 CAN Rx FIFO 0 Acknowledge Register
	uint8_t       RESERVED10[3];  // @149
	__I uint32_t  RXF1S;          // @152 FDCAN Rx FIFO 1 Status Register
	__IO uint8_t  RXF1A;          // @156 FDCAN Rx FIFO 1 Acknowledge Register
	uint8_t       RESERVED11[35]; // @157
	__IO uint32_t TXBC;           // @192 FDCAN Tx Buffer Configuration Register
	__I uint32_t  TXFQS;  // @196 The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the
	                      // effect of Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
	__I uint32_t  TXBRP;  // @200 FDCAN Tx Buffer Request Pending Register
	__IO uint32_t TXBAR;  // @204 FDCAN Tx Buffer Add Request Register
	__IO uint32_t TXBCR;  // @208 FDCAN Tx Buffer Cancellation Request Register
	__I uint32_t  TXBTO;  // @212 FDCAN Tx Buffer Transmission Occurred Register
	__I uint32_t  TXBCF;  // @216 FDCAN Tx Buffer Cancellation Finished Register
	__IO uint32_t TXBTIE; // @220 FDCAN Tx Buffer Transmission Interrupt Enable Register
	__IO uint32_t TXBCIE; // @224 FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
	__I uint32_t  TXEFS;  // @228 FDCAN Tx Event FIFO Status Register
	__IO uint8_t  TXEFA;  // @232 FDCAN Tx Event FIFO Acknowledge Register
	uint8_t       RESERVED12[23]; // @233
	__IO uint8_t  CKDIV;          // @256 FDCAN CFG clock divider register
};

// FDCAN->CREL FDCAN Core Release Register
enum {
	FDCAN_CREL_REL     = ((1UL << 4) - 1) << 28, // REL
	FDCAN_CREL_STEP    = ((1UL << 4) - 1) << 24, // STEP
	FDCAN_CREL_SUBSTEP = ((1UL << 4) - 1) << 20, // SUBSTEP
	FDCAN_CREL_YEAR    = ((1UL << 4) - 1) << 16, // YEAR
	FDCAN_CREL_MON     = ((1UL << 8) - 1) << 8,  // MON
	FDCAN_CREL_DAY     = ((1UL << 8) - 1) << 0,  // DAY
};
inline uint32_t fdcan_crel_get_rel(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_REL) >> 28; }
inline uint32_t fdcan_crel_get_step(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_STEP) >> 24; }
inline uint32_t fdcan_crel_get_substep(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_SUBSTEP) >> 20; }
inline uint32_t fdcan_crel_get_year(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_YEAR) >> 16; }
inline uint32_t fdcan_crel_get_mon(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_MON) >> 8; }
inline uint32_t fdcan_crel_get_day(struct FDCAN_Type* p) { return (p->CREL & FDCAN_CREL_DAY) >> 0; }

// FDCAN->DBTP This register is only writable if bits CCCR.CCE and CCCR.INIT are set. The CAN bit time may be programed in the range of 4 to
// 25 time quanta. The CAN time quantum may be programmed in the range of 1 to 1024 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock period.
// DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (programmed values) [DTSEG1 +
// DTSEG2 + 3] tq or (functional values) [Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2] tq. The Information Processing Time (IPT) is zero,
// meaning the data for the next bit is available at the first clock edge after the sample point.
enum {
	FDCAN_DBTP_TDC    = 1UL << 23,              // TDC
	FDCAN_DBTP_DBRP   = ((1UL << 5) - 1) << 16, // DBRP
	FDCAN_DBTP_DTSEG1 = ((1UL << 5) - 1) << 8,  // DTSEG1
	FDCAN_DBTP_DTSEG2 = ((1UL << 4) - 1) << 4,  // DTSEG2
	FDCAN_DBTP_DSJW   = ((1UL << 4) - 1) << 0,  // DSJW
};
inline void fdcan_dbtp_set_dbrp(struct FDCAN_Type* p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN_DBTP_DBRP) | ((val << 16) & FDCAN_DBTP_DBRP);
}
inline void fdcan_dbtp_set_dtseg1(struct FDCAN_Type* p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN_DBTP_DTSEG1) | ((val << 8) & FDCAN_DBTP_DTSEG1);
}
inline void fdcan_dbtp_set_dtseg2(struct FDCAN_Type* p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN_DBTP_DTSEG2) | ((val << 4) & FDCAN_DBTP_DTSEG2);
}
inline void fdcan_dbtp_set_dsjw(struct FDCAN_Type* p, uint32_t val) {
	p->DBTP = (p->DBTP & ~FDCAN_DBTP_DSJW) | ((val << 0) & FDCAN_DBTP_DSJW);
}
inline uint32_t fdcan_dbtp_get_dbrp(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DBRP) >> 16; }
inline uint32_t fdcan_dbtp_get_dtseg1(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DTSEG1) >> 8; }
inline uint32_t fdcan_dbtp_get_dtseg2(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DTSEG2) >> 4; }
inline uint32_t fdcan_dbtp_get_dsjw(struct FDCAN_Type* p) { return (p->DBTP & FDCAN_DBTP_DSJW) >> 0; }

// FDCAN->TEST Write access to the Test Register has to be enabled by setting bit CCCR[TEST] to 1 . All Test Register functions are set to
// their reset values when bit CCCR[TEST] is reset. Loop Back mode and software control of Tx pin FDCANx_TX are hardware test modes.
// Programming TX differently from 00 may disturb the message transfer on the CAN bus.
enum {
	FDCAN_TEST_RX   = 1UL << 7,              // RX
	FDCAN_TEST_TX   = ((1UL << 2) - 1) << 5, // TX
	FDCAN_TEST_LBCK = 1UL << 4,              // LBCK
};
inline void fdcan_test_set_tx(struct FDCAN_Type* p, uint32_t val) { p->TEST = (p->TEST & ~FDCAN_TEST_TX) | ((val << 5) & FDCAN_TEST_TX); }
inline uint32_t fdcan_test_get_tx(struct FDCAN_Type* p) { return (p->TEST & FDCAN_TEST_TX) >> 5; }

// FDCAN->RWD The RAM Watchdog monitors the READY output of the Message RAM. A Message RAM access starts the Message RAM Watchdog Counter
// with the value configured by the RWD[WDC] bits. The counter is reloaded with RWD[WDC] bits when the Message RAM signals successful
// completion by activating its READY output. In case there is no response from the Message RAM until the counter has counted down to 0, the
// counter stops and interrupt flag IR[WDI] bit is set. The RAM Watchdog Counter is clocked by the fdcan_pclk clock.
enum {
	FDCAN_RWD_WDV = ((1UL << 8) - 1) << 8, // WDV
	FDCAN_RWD_WDC = ((1UL << 8) - 1) << 0, // WDC
};
inline void     fdcan_rwd_set_wdv(struct FDCAN_Type* p, uint32_t val) { p->RWD = (p->RWD & ~FDCAN_RWD_WDV) | ((val << 8) & FDCAN_RWD_WDV); }
inline void     fdcan_rwd_set_wdc(struct FDCAN_Type* p, uint32_t val) { p->RWD = (p->RWD & ~FDCAN_RWD_WDC) | ((val << 0) & FDCAN_RWD_WDC); }
inline uint32_t fdcan_rwd_get_wdv(struct FDCAN_Type* p) { return (p->RWD & FDCAN_RWD_WDV) >> 8; }
inline uint32_t fdcan_rwd_get_wdc(struct FDCAN_Type* p) { return (p->RWD & FDCAN_RWD_WDC) >> 0; }

// FDCAN->CCCR For details about setting and resetting of single bits see Software initialization.
enum {
	FDCAN_CCCR_NISO = 1UL << 15, // NISO
	FDCAN_CCCR_TXP  = 1UL << 14, // TXP
	FDCAN_CCCR_EFBI = 1UL << 13, // EFBI
	FDCAN_CCCR_PXHD = 1UL << 12, // PXHD
	FDCAN_CCCR_BRSE = 1UL << 9,  // BRSE
	FDCAN_CCCR_FDOE = 1UL << 8,  // FDOE
	FDCAN_CCCR_TEST = 1UL << 7,  // TEST
	FDCAN_CCCR_DAR  = 1UL << 6,  // DAR
	FDCAN_CCCR_MON  = 1UL << 5,  // MON
	FDCAN_CCCR_CSR  = 1UL << 4,  // CSR
	FDCAN_CCCR_CSA  = 1UL << 3,  // CSA
	FDCAN_CCCR_ASM  = 1UL << 2,  // ASM
	FDCAN_CCCR_CCE  = 1UL << 1,  // CCE
	FDCAN_CCCR_INIT = 1UL << 0,  // INIT
};

// FDCAN->NBTP FDCAN_NBTP
enum {
	FDCAN_NBTP_NSJW   = ((1UL << 7) - 1) << 25, // NSJW
	FDCAN_NBTP_NBRP   = ((1UL << 9) - 1) << 16, // NBRP
	FDCAN_NBTP_NTSEG1 = ((1UL << 8) - 1) << 8,  // NTSEG1
	FDCAN_NBTP_TSEG2  = ((1UL << 7) - 1) << 0,  // TSEG2
};
inline void fdcan_nbtp_set_nsjw(struct FDCAN_Type* p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN_NBTP_NSJW) | ((val << 25) & FDCAN_NBTP_NSJW);
}
inline void fdcan_nbtp_set_nbrp(struct FDCAN_Type* p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN_NBTP_NBRP) | ((val << 16) & FDCAN_NBTP_NBRP);
}
inline void fdcan_nbtp_set_ntseg1(struct FDCAN_Type* p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN_NBTP_NTSEG1) | ((val << 8) & FDCAN_NBTP_NTSEG1);
}
inline void fdcan_nbtp_set_tseg2(struct FDCAN_Type* p, uint32_t val) {
	p->NBTP = (p->NBTP & ~FDCAN_NBTP_TSEG2) | ((val << 0) & FDCAN_NBTP_TSEG2);
}
inline uint32_t fdcan_nbtp_get_nsjw(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NSJW) >> 25; }
inline uint32_t fdcan_nbtp_get_nbrp(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NBRP) >> 16; }
inline uint32_t fdcan_nbtp_get_ntseg1(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_NTSEG1) >> 8; }
inline uint32_t fdcan_nbtp_get_tseg2(struct FDCAN_Type* p) { return (p->NBTP & FDCAN_NBTP_TSEG2) >> 0; }

// FDCAN->TSCC FDCAN Timestamp Counter Configuration Register
enum {
	FDCAN_TSCC_TCP = ((1UL << 4) - 1) << 16, // TCP
	FDCAN_TSCC_TSS = ((1UL << 2) - 1) << 0,  // TSS
};
inline void fdcan_tscc_set_tcp(struct FDCAN_Type* p, uint32_t val) {
	p->TSCC = (p->TSCC & ~FDCAN_TSCC_TCP) | ((val << 16) & FDCAN_TSCC_TCP);
}
inline void fdcan_tscc_set_tss(struct FDCAN_Type* p, uint32_t val) {
	p->TSCC = (p->TSCC & ~FDCAN_TSCC_TSS) | ((val << 0) & FDCAN_TSCC_TSS);
}
inline uint32_t fdcan_tscc_get_tcp(struct FDCAN_Type* p) { return (p->TSCC & FDCAN_TSCC_TCP) >> 16; }
inline uint32_t fdcan_tscc_get_tss(struct FDCAN_Type* p) { return (p->TSCC & FDCAN_TSCC_TSS) >> 0; }

// FDCAN->TOCC FDCAN Timeout Counter Configuration Register
enum {
	FDCAN_TOCC_TOP  = ((1UL << 16) - 1) << 16, // TOP
	FDCAN_TOCC_TOS  = ((1UL << 2) - 1) << 1,   // TOS
	FDCAN_TOCC_ETOC = 1UL << 0,                // ETOC
};
inline void fdcan_tocc_set_top(struct FDCAN_Type* p, uint32_t val) {
	p->TOCC = (p->TOCC & ~FDCAN_TOCC_TOP) | ((val << 16) & FDCAN_TOCC_TOP);
}
inline void fdcan_tocc_set_tos(struct FDCAN_Type* p, uint32_t val) {
	p->TOCC = (p->TOCC & ~FDCAN_TOCC_TOS) | ((val << 1) & FDCAN_TOCC_TOS);
}
inline uint32_t fdcan_tocc_get_top(struct FDCAN_Type* p) { return (p->TOCC & FDCAN_TOCC_TOP) >> 16; }
inline uint32_t fdcan_tocc_get_tos(struct FDCAN_Type* p) { return (p->TOCC & FDCAN_TOCC_TOS) >> 1; }

// FDCAN->ECR FDCAN Error Counter Register
enum {
	FDCAN_ECR_CEL  = ((1UL << 8) - 1) << 16, // CEL
	FDCAN_ECR_RP   = 1UL << 15,              // RP
	FDCAN_ECR_TREC = ((1UL << 7) - 1) << 8,  // TREC
	FDCAN_ECR_TEC  = ((1UL << 8) - 1) << 0,  // TEC
};
inline uint32_t fdcan_ecr_get_cel(struct FDCAN_Type* p) { return (p->ECR & FDCAN_ECR_CEL) >> 16; }
inline uint32_t fdcan_ecr_get_trec(struct FDCAN_Type* p) { return (p->ECR & FDCAN_ECR_TREC) >> 8; }
inline uint32_t fdcan_ecr_get_tec(struct FDCAN_Type* p) { return (p->ECR & FDCAN_ECR_TEC) >> 0; }

// FDCAN->PSR FDCAN Protocol Status Register
enum {
	FDCAN_PSR_TDCV = ((1UL << 7) - 1) << 16, // TDCV
	FDCAN_PSR_PXE  = 1UL << 14,              // PXE
	FDCAN_PSR_REDL = 1UL << 13,              // REDL
	FDCAN_PSR_RBRS = 1UL << 12,              // RBRS
	FDCAN_PSR_RESI = 1UL << 11,              // RESI
	FDCAN_PSR_DLEC = ((1UL << 3) - 1) << 8,  // DLEC
	FDCAN_PSR_BO   = 1UL << 7,               // BO
	FDCAN_PSR_EW   = 1UL << 6,               // EW
	FDCAN_PSR_EP   = 1UL << 5,               // EP
	FDCAN_PSR_ACT  = ((1UL << 2) - 1) << 3,  // ACT
	FDCAN_PSR_LEC  = ((1UL << 3) - 1) << 0,  // LEC
};
inline void fdcan_psr_set_tdcv(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_TDCV) | ((val << 16) & FDCAN_PSR_TDCV); }
inline void fdcan_psr_set_dlec(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_DLEC) | ((val << 8) & FDCAN_PSR_DLEC); }
inline void fdcan_psr_set_act(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_ACT) | ((val << 3) & FDCAN_PSR_ACT); }
inline void fdcan_psr_set_lec(struct FDCAN_Type* p, uint32_t val) { p->PSR = (p->PSR & ~FDCAN_PSR_LEC) | ((val << 0) & FDCAN_PSR_LEC); }
inline uint32_t fdcan_psr_get_tdcv(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_TDCV) >> 16; }
inline uint32_t fdcan_psr_get_dlec(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_DLEC) >> 8; }
inline uint32_t fdcan_psr_get_act(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_ACT) >> 3; }
inline uint32_t fdcan_psr_get_lec(struct FDCAN_Type* p) { return (p->PSR & FDCAN_PSR_LEC) >> 0; }

// FDCAN->TDCR FDCAN Transmitter Delay Compensation Register
enum {
	FDCAN_TDCR_TDCO = ((1UL << 7) - 1) << 8, // TDCO
	FDCAN_TDCR_TDCF = ((1UL << 7) - 1) << 0, // TDCF
};
inline void fdcan_tdcr_set_tdco(struct FDCAN_Type* p, uint32_t val) {
	p->TDCR = (p->TDCR & ~FDCAN_TDCR_TDCO) | ((val << 8) & FDCAN_TDCR_TDCO);
}
inline void fdcan_tdcr_set_tdcf(struct FDCAN_Type* p, uint32_t val) {
	p->TDCR = (p->TDCR & ~FDCAN_TDCR_TDCF) | ((val << 0) & FDCAN_TDCR_TDCF);
}
inline uint32_t fdcan_tdcr_get_tdco(struct FDCAN_Type* p) { return (p->TDCR & FDCAN_TDCR_TDCO) >> 8; }
inline uint32_t fdcan_tdcr_get_tdcf(struct FDCAN_Type* p) { return (p->TDCR & FDCAN_TDCR_TDCF) >> 0; }

// FDCAN->IR The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears
// them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the
// register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line
// an interrupt is signaled.
enum {
	FDCAN_IR_ARA  = 1UL << 29, // ARA
	FDCAN_IR_PED  = 1UL << 28, // PED
	FDCAN_IR_PEA  = 1UL << 27, // PEA
	FDCAN_IR_WDI  = 1UL << 26, // WDI
	FDCAN_IR_BO   = 1UL << 25, // BO
	FDCAN_IR_EW   = 1UL << 24, // EW
	FDCAN_IR_EP   = 1UL << 23, // EP
	FDCAN_IR_ELO  = 1UL << 22, // ELO
	FDCAN_IR_DRX  = 1UL << 19, // DRX
	FDCAN_IR_TOO  = 1UL << 18, // TOO
	FDCAN_IR_MRAF = 1UL << 17, // MRAF
	FDCAN_IR_TSW  = 1UL << 16, // TSW
	FDCAN_IR_TEFL = 1UL << 15, // TEFL
	FDCAN_IR_TEFF = 1UL << 14, // TEFF
	FDCAN_IR_TEFW = 1UL << 13, // TEFW
	FDCAN_IR_TEFN = 1UL << 12, // TEFN
	FDCAN_IR_TFE  = 1UL << 11, // TFE
	FDCAN_IR_TCF  = 1UL << 10, // TCF
	FDCAN_IR_TC   = 1UL << 9,  // TC
	FDCAN_IR_HPM  = 1UL << 8,  // HPM
	FDCAN_IR_RF1L = 1UL << 7,  // RF1L
	FDCAN_IR_RF1F = 1UL << 6,  // RF1F
	FDCAN_IR_RF1W = 1UL << 5,  // RF1W
	FDCAN_IR_RF1N = 1UL << 4,  // RF1N
	FDCAN_IR_RF0L = 1UL << 3,  // RF0L
	FDCAN_IR_RF0F = 1UL << 2,  // RF0F
	FDCAN_IR_RF0W = 1UL << 1,  // RF0W
	FDCAN_IR_RF0N = 1UL << 0,  // RF0N
};

// FDCAN->IE The settings in the Interrupt Enable register determine which status changes in the Interrupt Register will be signaled on an
// interrupt line.
enum {
	FDCAN_IE_ARAE  = 1UL << 29, // ARAE
	FDCAN_IE_PEDE  = 1UL << 28, // PEDE
	FDCAN_IE_PEAE  = 1UL << 27, // PEAE
	FDCAN_IE_WDIE  = 1UL << 26, // WDIE
	FDCAN_IE_BOE   = 1UL << 25, // BOE
	FDCAN_IE_EWE   = 1UL << 24, // EWE
	FDCAN_IE_EPE   = 1UL << 23, // EPE
	FDCAN_IE_ELOE  = 1UL << 22, // ELOE
	FDCAN_IE_BEUE  = 1UL << 21, // BEUE
	FDCAN_IE_BECE  = 1UL << 20, // BECE
	FDCAN_IE_DRX   = 1UL << 19, // DRX
	FDCAN_IE_TOOE  = 1UL << 18, // TOOE
	FDCAN_IE_MRAFE = 1UL << 17, // MRAFE
	FDCAN_IE_TSWE  = 1UL << 16, // TSWE
	FDCAN_IE_TEFLE = 1UL << 15, // TEFLE
	FDCAN_IE_TEFFE = 1UL << 14, // TEFFE
	FDCAN_IE_TEFWE = 1UL << 13, // TEFWE
	FDCAN_IE_TEFNE = 1UL << 12, // TEFNE
	FDCAN_IE_TFEE  = 1UL << 11, // TFEE
	FDCAN_IE_TCFE  = 1UL << 10, // TCFE
	FDCAN_IE_TCE   = 1UL << 9,  // TCE
	FDCAN_IE_HPME  = 1UL << 8,  // HPME
	FDCAN_IE_RF1LE = 1UL << 7,  // RF1LE
	FDCAN_IE_RF1FE = 1UL << 6,  // RF1FE
	FDCAN_IE_RF1WE = 1UL << 5,  // RF1WE
	FDCAN_IE_RF1NE = 1UL << 4,  // RF1NE
	FDCAN_IE_RF0LE = 1UL << 3,  // RF0LE
	FDCAN_IE_RF0FE = 1UL << 2,  // RF0FE
	FDCAN_IE_RF0WE = 1UL << 1,  // RF0WE
	FDCAN_IE_RF0NE = 1UL << 0,  // RF0NE
};

// FDCAN->ILS The Interrupt Line Select register assigns an interrupt generated by a specific interrupt flag from the Interrupt Register to
// one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via ILE[EINT0] and
// ILE[EINT1].
enum {
	FDCAN_ILS_ARAL  = 1UL << 29, // ARAL
	FDCAN_ILS_PEDL  = 1UL << 28, // PEDL
	FDCAN_ILS_PEAL  = 1UL << 27, // PEAL
	FDCAN_ILS_WDIL  = 1UL << 26, // WDIL
	FDCAN_ILS_BOL   = 1UL << 25, // BOL
	FDCAN_ILS_EWL   = 1UL << 24, // EWL
	FDCAN_ILS_EPL   = 1UL << 23, // EPL
	FDCAN_ILS_ELOL  = 1UL << 22, // ELOL
	FDCAN_ILS_BEUL  = 1UL << 21, // BEUL
	FDCAN_ILS_BECL  = 1UL << 20, // BECL
	FDCAN_ILS_DRXL  = 1UL << 19, // DRXL
	FDCAN_ILS_TOOL  = 1UL << 18, // TOOL
	FDCAN_ILS_MRAFL = 1UL << 17, // MRAFL
	FDCAN_ILS_TSWL  = 1UL << 16, // TSWL
	FDCAN_ILS_TEFLL = 1UL << 15, // TEFLL
	FDCAN_ILS_TEFFL = 1UL << 14, // TEFFL
	FDCAN_ILS_TEFWL = 1UL << 13, // TEFWL
	FDCAN_ILS_TEFNL = 1UL << 12, // TEFNL
	FDCAN_ILS_TFEL  = 1UL << 11, // TFEL
	FDCAN_ILS_TCFL  = 1UL << 10, // TCFL
	FDCAN_ILS_TCL   = 1UL << 9,  // TCL
	FDCAN_ILS_HPML  = 1UL << 8,  // HPML
	FDCAN_ILS_RF1LL = 1UL << 7,  // RF1LL
	FDCAN_ILS_RF1FL = 1UL << 6,  // RF1FL
	FDCAN_ILS_RF1WL = 1UL << 5,  // RF1WL
	FDCAN_ILS_RF1NL = 1UL << 4,  // RF1NL
	FDCAN_ILS_RF0LL = 1UL << 3,  // RF0LL
	FDCAN_ILS_RF0FL = 1UL << 2,  // RF0FL
	FDCAN_ILS_RF0WL = 1UL << 1,  // RF0WL
	FDCAN_ILS_RF0NL = 1UL << 0,  // RF0NL
};

// FDCAN->ILE Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
enum {
	FDCAN_ILE_EINTX = ((1UL << 2) - 1) << 0, // Merged EINT1
};
inline void fdcan_ile_set_eintx(struct FDCAN_Type* p, uint32_t val) {
	p->ILE = (p->ILE & ~FDCAN_ILE_EINTX) | ((val << 0) & FDCAN_ILE_EINTX);
}
inline uint32_t fdcan_ile_get_eintx(struct FDCAN_Type* p) { return (p->ILE & FDCAN_ILE_EINTX) >> 0; }

// FDCAN->RXGFC Global settings for Message ID filtering. The Global Filter Configuration controls the filter path for standard and extended
// messages as described in Figure706: Standard Message ID filter path and Figure707: Extended Message ID filter path.
enum {
	FDCAN_RXGFC_ANFS = ((1UL << 2) - 1) << 4, // ANFS
	FDCAN_RXGFC_ANFE = ((1UL << 2) - 1) << 2, // ANFE
	FDCAN_RXGFC_RRFS = 1UL << 1,              // RRFS
	FDCAN_RXGFC_RRFE = 1UL << 0,              // RRFE
};
inline void fdcan_rxgfc_set_anfs(struct FDCAN_Type* p, uint32_t val) {
	p->RXGFC = (p->RXGFC & ~FDCAN_RXGFC_ANFS) | ((val << 4) & FDCAN_RXGFC_ANFS);
}
inline void fdcan_rxgfc_set_anfe(struct FDCAN_Type* p, uint32_t val) {
	p->RXGFC = (p->RXGFC & ~FDCAN_RXGFC_ANFE) | ((val << 2) & FDCAN_RXGFC_ANFE);
}
inline uint32_t fdcan_rxgfc_get_anfs(struct FDCAN_Type* p) { return (p->RXGFC & FDCAN_RXGFC_ANFS) >> 4; }
inline uint32_t fdcan_rxgfc_get_anfe(struct FDCAN_Type* p) { return (p->RXGFC & FDCAN_RXGFC_ANFE) >> 2; }

// FDCAN->XIDAM FDCAN Extended ID and Mask Register
enum {
	FDCAN_XIDAM_EIDM = ((1UL << 29) - 1) << 0, // EIDM
};
inline void fdcan_xidam_set_eidm(struct FDCAN_Type* p, uint32_t val) {
	p->XIDAM = (p->XIDAM & ~FDCAN_XIDAM_EIDM) | ((val << 0) & FDCAN_XIDAM_EIDM);
}
inline uint32_t fdcan_xidam_get_eidm(struct FDCAN_Type* p) { return (p->XIDAM & FDCAN_XIDAM_EIDM) >> 0; }

// FDCAN->HPMS This register is updated every time a Message ID filter element configured to generate a priority event match. This can be
// used to monitor the status of incoming high priority messages and to enable fast access to these messages.
enum {
	FDCAN_HPMS_FLST = 1UL << 15,             // FLST
	FDCAN_HPMS_FIDX = ((1UL << 7) - 1) << 8, // FIDX
	FDCAN_HPMS_MSI  = ((1UL << 2) - 1) << 6, // MSI
	FDCAN_HPMS_BIDX = ((1UL << 6) - 1) << 0, // BIDX
};
inline uint32_t fdcan_hpms_get_fidx(struct FDCAN_Type* p) { return (p->HPMS & FDCAN_HPMS_FIDX) >> 8; }
inline uint32_t fdcan_hpms_get_msi(struct FDCAN_Type* p) { return (p->HPMS & FDCAN_HPMS_MSI) >> 6; }
inline uint32_t fdcan_hpms_get_bidx(struct FDCAN_Type* p) { return (p->HPMS & FDCAN_HPMS_BIDX) >> 0; }

// FDCAN->RXF0S FDCAN Rx FIFO 0 Status Register
enum {
	FDCAN_RXF0S_RF0L = 1UL << 25,              // RF0L
	FDCAN_RXF0S_F0F  = 1UL << 24,              // F0F
	FDCAN_RXF0S_F0PI = ((1UL << 6) - 1) << 16, // F0PI
	FDCAN_RXF0S_F0GI = ((1UL << 6) - 1) << 8,  // F0GI
	FDCAN_RXF0S_F0FL = ((1UL << 7) - 1) << 0,  // F0FL
};
inline void fdcan_rxf0s_set_f0pi(struct FDCAN_Type* p, uint32_t val) {
	p->RXF0S = (p->RXF0S & ~FDCAN_RXF0S_F0PI) | ((val << 16) & FDCAN_RXF0S_F0PI);
}
inline void fdcan_rxf0s_set_f0gi(struct FDCAN_Type* p, uint32_t val) {
	p->RXF0S = (p->RXF0S & ~FDCAN_RXF0S_F0GI) | ((val << 8) & FDCAN_RXF0S_F0GI);
}
inline void fdcan_rxf0s_set_f0fl(struct FDCAN_Type* p, uint32_t val) {
	p->RXF0S = (p->RXF0S & ~FDCAN_RXF0S_F0FL) | ((val << 0) & FDCAN_RXF0S_F0FL);
}
inline uint32_t fdcan_rxf0s_get_f0pi(struct FDCAN_Type* p) { return (p->RXF0S & FDCAN_RXF0S_F0PI) >> 16; }
inline uint32_t fdcan_rxf0s_get_f0gi(struct FDCAN_Type* p) { return (p->RXF0S & FDCAN_RXF0S_F0GI) >> 8; }
inline uint32_t fdcan_rxf0s_get_f0fl(struct FDCAN_Type* p) { return (p->RXF0S & FDCAN_RXF0S_F0FL) >> 0; }

// FDCAN->RXF0A CAN Rx FIFO 0 Acknowledge Register
enum {
	FDCAN_RXF0A_F0AI = ((1UL << 6) - 1) << 0, // F0AI
};
inline void fdcan_rxf0a_set_f0ai(struct FDCAN_Type* p, uint32_t val) {
	p->RXF0A = (p->RXF0A & ~FDCAN_RXF0A_F0AI) | ((val << 0) & FDCAN_RXF0A_F0AI);
}
inline uint32_t fdcan_rxf0a_get_f0ai(struct FDCAN_Type* p) { return (p->RXF0A & FDCAN_RXF0A_F0AI) >> 0; }

// FDCAN->RXF1S FDCAN Rx FIFO 1 Status Register
enum {
	FDCAN_RXF1S_DMS  = ((1UL << 2) - 1) << 30, // DMS
	FDCAN_RXF1S_RF1L = 1UL << 25,              // RF1L
	FDCAN_RXF1S_F1F  = 1UL << 24,              // F1F
	FDCAN_RXF1S_F1PI = ((1UL << 6) - 1) << 16, // F1PI
	FDCAN_RXF1S_F1GI = ((1UL << 6) - 1) << 8,  // F1GI
	FDCAN_RXF1S_F1FL = ((1UL << 7) - 1) << 0,  // F1FL
};
inline uint32_t fdcan_rxf1s_get_dms(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_DMS) >> 30; }
inline uint32_t fdcan_rxf1s_get_f1pi(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_F1PI) >> 16; }
inline uint32_t fdcan_rxf1s_get_f1gi(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_F1GI) >> 8; }
inline uint32_t fdcan_rxf1s_get_f1fl(struct FDCAN_Type* p) { return (p->RXF1S & FDCAN_RXF1S_F1FL) >> 0; }

// FDCAN->RXF1A FDCAN Rx FIFO 1 Acknowledge Register
enum {
	FDCAN_RXF1A_F1AI = ((1UL << 6) - 1) << 0, // F1AI
};
inline void fdcan_rxf1a_set_f1ai(struct FDCAN_Type* p, uint32_t val) {
	p->RXF1A = (p->RXF1A & ~FDCAN_RXF1A_F1AI) | ((val << 0) & FDCAN_RXF1A_F1AI);
}
inline uint32_t fdcan_rxf1a_get_f1ai(struct FDCAN_Type* p) { return (p->RXF1A & FDCAN_RXF1A_F1AI) >> 0; }

// FDCAN->TXBC FDCAN Tx Buffer Configuration Register
enum {
	FDCAN_TXBC_TFQM = 1UL << 30,              // TFQM
	FDCAN_TXBC_TFQS = ((1UL << 6) - 1) << 24, // TFQS
	FDCAN_TXBC_NDTB = ((1UL << 6) - 1) << 16, // NDTB
	FDCAN_TXBC_TBSA = ((1UL << 14) - 1) << 2, // TBSA
};
inline void fdcan_txbc_set_tfqs(struct FDCAN_Type* p, uint32_t val) {
	p->TXBC = (p->TXBC & ~FDCAN_TXBC_TFQS) | ((val << 24) & FDCAN_TXBC_TFQS);
}
inline void fdcan_txbc_set_ndtb(struct FDCAN_Type* p, uint32_t val) {
	p->TXBC = (p->TXBC & ~FDCAN_TXBC_NDTB) | ((val << 16) & FDCAN_TXBC_NDTB);
}
inline void fdcan_txbc_set_tbsa(struct FDCAN_Type* p, uint32_t val) {
	p->TXBC = (p->TXBC & ~FDCAN_TXBC_TBSA) | ((val << 2) & FDCAN_TXBC_TBSA);
}
inline uint32_t fdcan_txbc_get_tfqs(struct FDCAN_Type* p) { return (p->TXBC & FDCAN_TXBC_TFQS) >> 24; }
inline uint32_t fdcan_txbc_get_ndtb(struct FDCAN_Type* p) { return (p->TXBC & FDCAN_TXBC_NDTB) >> 16; }
inline uint32_t fdcan_txbc_get_tbsa(struct FDCAN_Type* p) { return (p->TXBC & FDCAN_TXBC_TBSA) >> 2; }

// FDCAN->TXFQS The Tx FIFO/Queue status is related to the pending Tx requests listed in register TXBRP. Therefore the effect of
// Add/Cancellation requests may be delayed due to a running Tx scan (TXBRP not yet updated).
enum {
	FDCAN_TXFQS_TFQF  = 1UL << 21,              // TFQF
	FDCAN_TXFQS_TFQPI = ((1UL << 5) - 1) << 16, // TFQPI
	FDCAN_TXFQS_TFGI  = ((1UL << 5) - 1) << 8,  // TFGI
	FDCAN_TXFQS_TFFL  = ((1UL << 6) - 1) << 0,  // TFFL
};
inline uint32_t fdcan_txfqs_get_tfqpi(struct FDCAN_Type* p) { return (p->TXFQS & FDCAN_TXFQS_TFQPI) >> 16; }
inline uint32_t fdcan_txfqs_get_tfgi(struct FDCAN_Type* p) { return (p->TXFQS & FDCAN_TXFQS_TFGI) >> 8; }
inline uint32_t fdcan_txfqs_get_tffl(struct FDCAN_Type* p) { return (p->TXFQS & FDCAN_TXFQS_TFFL) >> 0; }

// FDCAN->TXEFS FDCAN Tx Event FIFO Status Register
enum {
	FDCAN_TXEFS_TEFL = 1UL << 25,              // TEFL
	FDCAN_TXEFS_EFF  = 1UL << 24,              // EFF
	FDCAN_TXEFS_EFPI = ((1UL << 5) - 1) << 16, // EFPI
	FDCAN_TXEFS_EFGI = ((1UL << 5) - 1) << 8,  // EFGI
	FDCAN_TXEFS_EFFL = ((1UL << 6) - 1) << 0,  // EFFL
};
inline uint32_t fdcan_txefs_get_efpi(struct FDCAN_Type* p) { return (p->TXEFS & FDCAN_TXEFS_EFPI) >> 16; }
inline uint32_t fdcan_txefs_get_efgi(struct FDCAN_Type* p) { return (p->TXEFS & FDCAN_TXEFS_EFGI) >> 8; }
inline uint32_t fdcan_txefs_get_effl(struct FDCAN_Type* p) { return (p->TXEFS & FDCAN_TXEFS_EFFL) >> 0; }

// FDCAN->TXEFA FDCAN Tx Event FIFO Acknowledge Register
enum {
	FDCAN_TXEFA_EFAI = ((1UL << 5) - 1) << 0, // EFAI
};
inline void fdcan_txefa_set_efai(struct FDCAN_Type* p, uint32_t val) {
	p->TXEFA = (p->TXEFA & ~FDCAN_TXEFA_EFAI) | ((val << 0) & FDCAN_TXEFA_EFAI);
}
inline uint32_t fdcan_txefa_get_efai(struct FDCAN_Type* p) { return (p->TXEFA & FDCAN_TXEFA_EFAI) >> 0; }

// FDCAN->CKDIV FDCAN CFG clock divider register
enum {
	FDCAN_CKDIV_PDIV = ((1UL << 4) - 1) << 0, // input clock divider. the APB clock could be divided prior to be used by the CAN sub
};
inline void fdcan_ckdiv_set_pdiv(struct FDCAN_Type* p, uint32_t val) {
	p->CKDIV = (p->CKDIV & ~FDCAN_CKDIV_PDIV) | ((val << 0) & FDCAN_CKDIV_PDIV);
}
inline uint32_t fdcan_ckdiv_get_pdiv(struct FDCAN_Type* p) { return (p->CKDIV & FDCAN_CKDIV_PDIV) >> 0; }

/* Flash */
struct FLASH_Type {
	__IO uint32_t ACR;           // @0 Access control register
	__O uint32_t  PDKEYR;        // @4 Power down key register
	__O uint32_t  KEYR;          // @8 Flash key register
	__O uint32_t  OPTKEYR;       // @12 Option byte key register
	__IO uint32_t SR;            // @16 Status register
	__IO uint32_t CR;            // @20 Flash control register
	__IO uint32_t ECCR;          // @24 Flash ECC register
	uint8_t       RESERVED0[4];  // @28
	__IO uint32_t OPTR;          // @32 Flash option register
	__IO uint16_t PCROP1SR;      // @36 Flash Bank 1 PCROP Start address register
	uint8_t       RESERVED1[2];  // @38
	__IO uint32_t PCROP1ER;      // @40 Flash Bank 1 PCROP End address register
	__IO uint32_t WRP1AR;        // @44 Flash Bank 1 WRP area A address register
	__IO uint32_t WRP1BR;        // @48 Flash Bank 1 WRP area B address register
	uint8_t       RESERVED2[60]; // @52
	__IO uint32_t SEC1R;         // @112 securable area bank1 register
};

// FLASH->ACR Access control register
enum {
	FLASH_ACR_DBG_SWEN = 1UL << 18,             // Debug software enable
	FLASH_ACR_SLEEP_PD = 1UL << 14,             // Flash Power-down mode during Low-power sleep mode
	FLASH_ACR_RUN_PD   = 1UL << 13,             // Flash Power-down mode during Low-power run mode
	FLASH_ACR_DCRST    = 1UL << 12,             // Data cache reset
	FLASH_ACR_ICRST    = 1UL << 11,             // Instruction cache reset
	FLASH_ACR_DCEN     = 1UL << 10,             // Data cache enable
	FLASH_ACR_ICEN     = 1UL << 9,              // Instruction cache enable
	FLASH_ACR_PRFTEN   = 1UL << 8,              // Prefetch enable
	FLASH_ACR_LATENCY  = ((1UL << 4) - 1) << 0, // Latency
};
inline void flash_acr_set_latency(struct FLASH_Type* p, uint32_t val) {
	p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val << 0) & FLASH_ACR_LATENCY);
}
inline uint32_t flash_acr_get_latency(struct FLASH_Type* p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY     = 1UL << 16, // Busy
	FLASH_SR_OPTVERR = 1UL << 15, // Option validity error
	FLASH_SR_RDERR   = 1UL << 14, // PCROP read error
	FLASH_SR_FASTERR = 1UL << 9,  // Fast programming error
	FLASH_SR_MISERR  = 1UL << 8,  // Fast programming data miss error
	FLASH_SR_PGSERR  = 1UL << 7,  // Programming sequence error
	FLASH_SR_SIZERR  = 1UL << 6,  // Size error
	FLASH_SR_PGAERR  = 1UL << 5,  // Programming alignment error
	FLASH_SR_WRPERR  = 1UL << 4,  // Write protected error
	FLASH_SR_PROGERR = 1UL << 3,  // Programming error
	FLASH_SR_OPERR   = 1UL << 1,  // Operation error
	FLASH_SR_EOP     = 1UL << 0,  // End of operation
};

// FLASH->CR Flash control register
enum {
	FLASH_CR_LOCK       = 1UL << 31,             // FLASH_CR Lock
	FLASH_CR_OPTLOCK    = 1UL << 30,             // Options Lock
	FLASH_CR_SEC_PROT1  = 1UL << 28,             // SEC_PROT1
	FLASH_CR_OBL_LAUNCH = 1UL << 27,             // Force the option byte loading
	FLASH_CR_RDERRIE    = 1UL << 26,             // PCROP read error interrupt enable
	FLASH_CR_ERRIE      = 1UL << 25,             // Error interrupt enable
	FLASH_CR_EOPIE      = 1UL << 24,             // End of operation interrupt enable
	FLASH_CR_FSTPG      = 1UL << 18,             // Fast programming
	FLASH_CR_OPTSTRT    = 1UL << 17,             // Options modification start
	FLASH_CR_STRT       = 1UL << 16,             // Start
	FLASH_CR_PNB        = ((1UL << 7) - 1) << 3, // Page number
	FLASH_CR_MER1       = 1UL << 2,              // Bank 1 Mass erase
	FLASH_CR_PER        = 1UL << 1,              // Page erase
	FLASH_CR_PG         = 1UL << 0,              // Programming
};
inline void     flash_cr_set_pnb(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_PNB) | ((val << 3) & FLASH_CR_PNB); }
inline uint32_t flash_cr_get_pnb(struct FLASH_Type* p) { return (p->CR & FLASH_CR_PNB) >> 3; }

// FLASH->ECCR Flash ECC register
enum {
	FLASH_ECCR_ECCD     = 1UL << 31,              // ECC detection
	FLASH_ECCR_ECCC     = 1UL << 30,              // ECC correction
	FLASH_ECCR_ECCD2    = 1UL << 29,              // ECC2 detection
	FLASH_ECCR_ECCC2    = 1UL << 28,              // ECC correction
	FLASH_ECCR_ECCIE    = 1UL << 24,              // ECCIE
	FLASH_ECCR_SYSF_ECC = 1UL << 22,              // SYSF_ECC
	FLASH_ECCR_BK_ECC   = 1UL << 21,              // BK_ECC
	FLASH_ECCR_ADDR_ECC = ((1UL << 19) - 1) << 0, // ECC fail address
};
inline void flash_eccr_set_addr_ecc(struct FLASH_Type* p, uint32_t val) {
	p->ECCR = (p->ECCR & ~FLASH_ECCR_ADDR_ECC) | ((val << 0) & FLASH_ECCR_ADDR_ECC);
}
inline uint32_t flash_eccr_get_addr_ecc(struct FLASH_Type* p) { return (p->ECCR & FLASH_ECCR_ADDR_ECC) >> 0; }

// FLASH->OPTR Flash option register
enum {
	FLASH_OPTR_IRHEN      = 1UL << 30,              // IRHEN
	FLASH_OPTR_NRST_MODE  = ((1UL << 2) - 1) << 28, // NRST_MODE
	FLASH_OPTR_NBOOT0     = 1UL << 27,              // nBOOT0
	FLASH_OPTR_NSWBOOT0   = 1UL << 26,              // nSWBOOT0
	FLASH_OPTR_SRAM2_RST  = 1UL << 25,              // SRAM2 Erase when system reset
	FLASH_OPTR_SRAM2_PE   = 1UL << 24,              // SRAM2 parity check enable
	FLASH_OPTR_NBOOT1     = 1UL << 23,              // Boot configuration
	FLASH_OPTR_WWDG_SW    = 1UL << 19,              // Window watchdog selection
	FLASH_OPTR_IWDG_STDBY = 1UL << 18,              // Independent watchdog counter freeze in Standby mode
	FLASH_OPTR_IWDG_STOP  = 1UL << 17,              // Independent watchdog counter freeze in Stop mode
	FLASH_OPTR_IDWG_SW    = 1UL << 16,              // Independent watchdog selection
	FLASH_OPTR_NRST_SHDW  = 1UL << 14,              // nRST_SHDW
	FLASH_OPTR_NRST_STDBY = 1UL << 13,              // nRST_STDBY
	FLASH_OPTR_NRST_STOP  = 1UL << 12,              // nRST_STOP
	FLASH_OPTR_BOR_LEV    = ((1UL << 3) - 1) << 8,  // BOR reset Level
	FLASH_OPTR_RDP        = ((1UL << 8) - 1) << 0,  // Read protection level
};
inline void flash_optr_set_nrst_mode(struct FLASH_Type* p, uint32_t val) {
	p->OPTR = (p->OPTR & ~FLASH_OPTR_NRST_MODE) | ((val << 28) & FLASH_OPTR_NRST_MODE);
}
inline void flash_optr_set_bor_lev(struct FLASH_Type* p, uint32_t val) {
	p->OPTR = (p->OPTR & ~FLASH_OPTR_BOR_LEV) | ((val << 8) & FLASH_OPTR_BOR_LEV);
}
inline void flash_optr_set_rdp(struct FLASH_Type* p, uint32_t val) {
	p->OPTR = (p->OPTR & ~FLASH_OPTR_RDP) | ((val << 0) & FLASH_OPTR_RDP);
}
inline uint32_t flash_optr_get_nrst_mode(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_NRST_MODE) >> 28; }
inline uint32_t flash_optr_get_bor_lev(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_BOR_LEV) >> 8; }
inline uint32_t flash_optr_get_rdp(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_RDP) >> 0; }

// FLASH->PCROP1SR Flash Bank 1 PCROP Start address register
enum {
	FLASH_PCROP1SR_PCROP1_STRT = ((1UL << 15) - 1) << 0, // Bank 1 PCROP area start offset
};
inline void flash_pcrop1sr_set_pcrop1_strt(struct FLASH_Type* p, uint32_t val) {
	p->PCROP1SR = (p->PCROP1SR & ~FLASH_PCROP1SR_PCROP1_STRT) | ((val << 0) & FLASH_PCROP1SR_PCROP1_STRT);
}
inline uint32_t flash_pcrop1sr_get_pcrop1_strt(struct FLASH_Type* p) { return (p->PCROP1SR & FLASH_PCROP1SR_PCROP1_STRT) >> 0; }

// FLASH->PCROP1ER Flash Bank 1 PCROP End address register
enum {
	FLASH_PCROP1ER_PCROP_RDP  = 1UL << 31,              // PCROP area preserved when RDP level decreased
	FLASH_PCROP1ER_PCROP1_END = ((1UL << 15) - 1) << 0, // Bank 1 PCROP area end offset
};
inline void flash_pcrop1er_set_pcrop1_end(struct FLASH_Type* p, uint32_t val) {
	p->PCROP1ER = (p->PCROP1ER & ~FLASH_PCROP1ER_PCROP1_END) | ((val << 0) & FLASH_PCROP1ER_PCROP1_END);
}
inline uint32_t flash_pcrop1er_get_pcrop1_end(struct FLASH_Type* p) { return (p->PCROP1ER & FLASH_PCROP1ER_PCROP1_END) >> 0; }

// FLASH->WRP1AR Flash Bank 1 WRP area A address register
enum {
	FLASH_WRP1AR_WRP1A_END  = ((1UL << 7) - 1) << 16, // Bank 1 WRP first area A end offset
	FLASH_WRP1AR_WRP1A_STRT = ((1UL << 7) - 1) << 0,  // Bank 1 WRP first area start offset
};
inline void flash_wrp1ar_set_wrp1a_end(struct FLASH_Type* p, uint32_t val) {
	p->WRP1AR = (p->WRP1AR & ~FLASH_WRP1AR_WRP1A_END) | ((val << 16) & FLASH_WRP1AR_WRP1A_END);
}
inline void flash_wrp1ar_set_wrp1a_strt(struct FLASH_Type* p, uint32_t val) {
	p->WRP1AR = (p->WRP1AR & ~FLASH_WRP1AR_WRP1A_STRT) | ((val << 0) & FLASH_WRP1AR_WRP1A_STRT);
}
inline uint32_t flash_wrp1ar_get_wrp1a_end(struct FLASH_Type* p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_END) >> 16; }
inline uint32_t flash_wrp1ar_get_wrp1a_strt(struct FLASH_Type* p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_STRT) >> 0; }

// FLASH->WRP1BR Flash Bank 1 WRP area B address register
enum {
	FLASH_WRP1BR_WRP1B_END  = ((1UL << 7) - 1) << 16, // Bank 1 WRP second area B start offset
	FLASH_WRP1BR_WRP1B_STRT = ((1UL << 7) - 1) << 0,  // Bank 1 WRP second area B end offset
};
inline void flash_wrp1br_set_wrp1b_end(struct FLASH_Type* p, uint32_t val) {
	p->WRP1BR = (p->WRP1BR & ~FLASH_WRP1BR_WRP1B_END) | ((val << 16) & FLASH_WRP1BR_WRP1B_END);
}
inline void flash_wrp1br_set_wrp1b_strt(struct FLASH_Type* p, uint32_t val) {
	p->WRP1BR = (p->WRP1BR & ~FLASH_WRP1BR_WRP1B_STRT) | ((val << 0) & FLASH_WRP1BR_WRP1B_STRT);
}
inline uint32_t flash_wrp1br_get_wrp1b_end(struct FLASH_Type* p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_END) >> 16; }
inline uint32_t flash_wrp1br_get_wrp1b_strt(struct FLASH_Type* p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_STRT) >> 0; }

// FLASH->SEC1R securable area bank1 register
enum {
	FLASH_SEC1R_BOOT_LOCK = 1UL << 16,             // BOOT_LOCK
	FLASH_SEC1R_SEC_SIZE1 = ((1UL << 8) - 1) << 0, // SEC_SIZE1
};
inline void flash_sec1r_set_sec_size1(struct FLASH_Type* p, uint32_t val) {
	p->SEC1R = (p->SEC1R & ~FLASH_SEC1R_SEC_SIZE1) | ((val << 0) & FLASH_SEC1R_SEC_SIZE1);
}
inline uint32_t flash_sec1r_get_sec_size1(struct FLASH_Type* p) { return (p->SEC1R & FLASH_SEC1R_SEC_SIZE1) >> 0; }

/* Filter Math Accelerator */
struct FMAC_Type {
	__IO uint32_t X1BUFCFG;     // @0 FMAC X1 Buffer Configuration register
	__IO uint16_t X2BUFCFG;     // @4 FMAC X2 Buffer Configuration register
	uint8_t       RESERVED0[2]; // @6
	__IO uint32_t YBUFCFG;      // @8 FMAC Y Buffer Configuration register
	__IO uint32_t PARAM;        // @12 FMAC Parameter register
	__IO uint32_t CR;           // @16 FMAC Control register
	__I uint16_t  SR;           // @20 FMAC Status register
	uint8_t       RESERVED1[2]; // @22
	__O uint16_t  WDATA;        // @24 FMAC Write Data register
	uint8_t       RESERVED2[2]; // @26
	__I uint16_t  RDATA;        // @28 FMAC Read Data register
};

// FMAC->X1BUFCFG FMAC X1 Buffer Configuration register
enum {
	FMAC_X1BUFCFG_FULL_WM     = ((1UL << 2) - 1) << 24, // FULL_WM
	FMAC_X1BUFCFG_X1_BUF_SIZE = ((1UL << 8) - 1) << 8,  // X1_BUF_SIZE
	FMAC_X1BUFCFG_X1_BASE     = ((1UL << 8) - 1) << 0,  // X1_BASE
};
inline void fmac_x1bufcfg_set_full_wm(struct FMAC_Type* p, uint32_t val) {
	p->X1BUFCFG = (p->X1BUFCFG & ~FMAC_X1BUFCFG_FULL_WM) | ((val << 24) & FMAC_X1BUFCFG_FULL_WM);
}
inline void fmac_x1bufcfg_set_x1_buf_size(struct FMAC_Type* p, uint32_t val) {
	p->X1BUFCFG = (p->X1BUFCFG & ~FMAC_X1BUFCFG_X1_BUF_SIZE) | ((val << 8) & FMAC_X1BUFCFG_X1_BUF_SIZE);
}
inline void fmac_x1bufcfg_set_x1_base(struct FMAC_Type* p, uint32_t val) {
	p->X1BUFCFG = (p->X1BUFCFG & ~FMAC_X1BUFCFG_X1_BASE) | ((val << 0) & FMAC_X1BUFCFG_X1_BASE);
}
inline uint32_t fmac_x1bufcfg_get_full_wm(struct FMAC_Type* p) { return (p->X1BUFCFG & FMAC_X1BUFCFG_FULL_WM) >> 24; }
inline uint32_t fmac_x1bufcfg_get_x1_buf_size(struct FMAC_Type* p) { return (p->X1BUFCFG & FMAC_X1BUFCFG_X1_BUF_SIZE) >> 8; }
inline uint32_t fmac_x1bufcfg_get_x1_base(struct FMAC_Type* p) { return (p->X1BUFCFG & FMAC_X1BUFCFG_X1_BASE) >> 0; }

// FMAC->X2BUFCFG FMAC X2 Buffer Configuration register
enum {
	FMAC_X2BUFCFG_X2_BUF_SIZE = ((1UL << 8) - 1) << 8, // X1_BUF_SIZE
	FMAC_X2BUFCFG_X2_BASE     = ((1UL << 8) - 1) << 0, // X1_BASE
};
inline void fmac_x2bufcfg_set_x2_buf_size(struct FMAC_Type* p, uint32_t val) {
	p->X2BUFCFG = (p->X2BUFCFG & ~FMAC_X2BUFCFG_X2_BUF_SIZE) | ((val << 8) & FMAC_X2BUFCFG_X2_BUF_SIZE);
}
inline void fmac_x2bufcfg_set_x2_base(struct FMAC_Type* p, uint32_t val) {
	p->X2BUFCFG = (p->X2BUFCFG & ~FMAC_X2BUFCFG_X2_BASE) | ((val << 0) & FMAC_X2BUFCFG_X2_BASE);
}
inline uint32_t fmac_x2bufcfg_get_x2_buf_size(struct FMAC_Type* p) { return (p->X2BUFCFG & FMAC_X2BUFCFG_X2_BUF_SIZE) >> 8; }
inline uint32_t fmac_x2bufcfg_get_x2_base(struct FMAC_Type* p) { return (p->X2BUFCFG & FMAC_X2BUFCFG_X2_BASE) >> 0; }

// FMAC->YBUFCFG FMAC Y Buffer Configuration register
enum {
	FMAC_YBUFCFG_EMPTY_WM   = ((1UL << 2) - 1) << 24, // EMPTY_WM
	FMAC_YBUFCFG_Y_BUF_SIZE = ((1UL << 8) - 1) << 8,  // X1_BUF_SIZE
	FMAC_YBUFCFG_Y_BASE     = ((1UL << 8) - 1) << 0,  // X1_BASE
};
inline void fmac_ybufcfg_set_empty_wm(struct FMAC_Type* p, uint32_t val) {
	p->YBUFCFG = (p->YBUFCFG & ~FMAC_YBUFCFG_EMPTY_WM) | ((val << 24) & FMAC_YBUFCFG_EMPTY_WM);
}
inline void fmac_ybufcfg_set_y_buf_size(struct FMAC_Type* p, uint32_t val) {
	p->YBUFCFG = (p->YBUFCFG & ~FMAC_YBUFCFG_Y_BUF_SIZE) | ((val << 8) & FMAC_YBUFCFG_Y_BUF_SIZE);
}
inline void fmac_ybufcfg_set_y_base(struct FMAC_Type* p, uint32_t val) {
	p->YBUFCFG = (p->YBUFCFG & ~FMAC_YBUFCFG_Y_BASE) | ((val << 0) & FMAC_YBUFCFG_Y_BASE);
}
inline uint32_t fmac_ybufcfg_get_empty_wm(struct FMAC_Type* p) { return (p->YBUFCFG & FMAC_YBUFCFG_EMPTY_WM) >> 24; }
inline uint32_t fmac_ybufcfg_get_y_buf_size(struct FMAC_Type* p) { return (p->YBUFCFG & FMAC_YBUFCFG_Y_BUF_SIZE) >> 8; }
inline uint32_t fmac_ybufcfg_get_y_base(struct FMAC_Type* p) { return (p->YBUFCFG & FMAC_YBUFCFG_Y_BASE) >> 0; }

// FMAC->PARAM FMAC Parameter register
enum {
	FMAC_PARAM_START = 1UL << 31,              // START
	FMAC_PARAM_FUNC  = ((1UL << 7) - 1) << 24, // FUNC
	FMAC_PARAM_R     = ((1UL << 8) - 1) << 16, // R
	FMAC_PARAM_Q     = ((1UL << 8) - 1) << 8,  // Q
	FMAC_PARAM_P     = ((1UL << 8) - 1) << 0,  // P
};
inline void fmac_param_set_func(struct FMAC_Type* p, uint32_t val) {
	p->PARAM = (p->PARAM & ~FMAC_PARAM_FUNC) | ((val << 24) & FMAC_PARAM_FUNC);
}
inline void fmac_param_set_r(struct FMAC_Type* p, uint32_t val) { p->PARAM = (p->PARAM & ~FMAC_PARAM_R) | ((val << 16) & FMAC_PARAM_R); }
inline void fmac_param_set_q(struct FMAC_Type* p, uint32_t val) { p->PARAM = (p->PARAM & ~FMAC_PARAM_Q) | ((val << 8) & FMAC_PARAM_Q); }
inline void fmac_param_set_p(struct FMAC_Type* p, uint32_t val) { p->PARAM = (p->PARAM & ~FMAC_PARAM_P) | ((val << 0) & FMAC_PARAM_P); }
inline uint32_t fmac_param_get_func(struct FMAC_Type* p) { return (p->PARAM & FMAC_PARAM_FUNC) >> 24; }
inline uint32_t fmac_param_get_r(struct FMAC_Type* p) { return (p->PARAM & FMAC_PARAM_R) >> 16; }
inline uint32_t fmac_param_get_q(struct FMAC_Type* p) { return (p->PARAM & FMAC_PARAM_Q) >> 8; }
inline uint32_t fmac_param_get_p(struct FMAC_Type* p) { return (p->PARAM & FMAC_PARAM_P) >> 0; }

// FMAC->CR FMAC Control register
enum {
	FMAC_CR_RESET   = 1UL << 16, // RESET
	FMAC_CR_CLIPEN  = 1UL << 15, // CLIPEN
	FMAC_CR_DMAWEN  = 1UL << 9,  // DMAWEN
	FMAC_CR_DMAREN  = 1UL << 8,  // DMAREN
	FMAC_CR_SATIEN  = 1UL << 4,  // SATIEN
	FMAC_CR_UNFLIEN = 1UL << 3,  // UNFLIEN
	FMAC_CR_OVFLIEN = 1UL << 2,  // OVFLIEN
	FMAC_CR_WIEN    = 1UL << 1,  // WIEN
	FMAC_CR_RIEN    = 1UL << 0,  // RIEN
};

// FMAC->SR FMAC Status register
enum {
	FMAC_SR_SAT    = 1UL << 10, // SAT
	FMAC_SR_UNFL   = 1UL << 9,  // UNFL
	FMAC_SR_OVFL   = 1UL << 8,  // OVFL
	FMAC_SR_X1FULL = 1UL << 1,  // X1FULL
	FMAC_SR_YEMPTY = 1UL << 0,  // YEMPTY
};

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN  = 1UL << 31, // ASPEN
	FPU_FPCCR_LSPEN  = 1UL << 30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL << 8,  // MONRDY
	FPU_FPCCR_BFRDY  = 1UL << 6,  // BFRDY
	FPU_FPCCR_MMRDY  = 1UL << 5,  // MMRDY
	FPU_FPCCR_HFRDY  = 1UL << 4,  // HFRDY
	FPU_FPCCR_THREAD = 1UL << 3,  // THREAD
	FPU_FPCCR_USER   = 1UL << 1,  // USER
	FPU_FPCCR_LSPACT = 1UL << 0,  // LSPACT
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL << 29) - 1) << 3, // Location of unpopulated floating-point
};
inline void fpu_fpcar_set_address(struct FPU_Type* p, uint32_t val) {
	p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val << 3) & FPU_FPCAR_ADDRESS);
}
inline uint32_t fpu_fpcar_get_address(struct FPU_Type* p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N     = 1UL << 31,              // Negative condition code flag
	FPU_FPSCR_Z     = 1UL << 30,              // Zero condition code flag
	FPU_FPSCR_C     = 1UL << 29,              // Carry condition code flag
	FPU_FPSCR_V     = 1UL << 28,              // Overflow condition code flag
	FPU_FPSCR_AHP   = 1UL << 26,              // Alternative half-precision control bit
	FPU_FPSCR_DN    = 1UL << 25,              // Default NaN mode control bit
	FPU_FPSCR_FZ    = 1UL << 24,              // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL << 2) - 1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC   = 1UL << 7,               // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC   = 1UL << 4,               // Inexact cumulative exception bit
	FPU_FPSCR_UFC   = 1UL << 3,               // Underflow cumulative exception bit
	FPU_FPSCR_OFC   = 1UL << 2,               // Overflow cumulative exception bit
	FPU_FPSCR_DZC   = 1UL << 1,               // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC   = 1UL << 0,               // Invalid operation cumulative exception bit
};
inline void fpu_fpscr_set_rmode(struct FPU_Type* p, uint32_t val) {
	p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val << 22) & FPU_FPSCR_RMODE);
}
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type* p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL << 4) - 1) << 20, // CP
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type* p, uint32_t val) {
	p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val << 20) & FPU_CPACR_CPACR_CP);
}
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type* p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER;        // @0 GPIO port mode register
	__IO uint16_t OTYPER;       // @4 GPIO port output type register
	uint8_t       RESERVED0[2]; // @6
	__IO uint32_t OSPEEDR;      // @8 GPIO port output speed register
	__IO uint32_t PUPDR;        // @12 GPIO port pull-up/pull-down register
	__I uint16_t  IDR;          // @16 GPIO port input data register
	uint8_t       RESERVED1[2]; // @18
	__IO uint16_t ODR;          // @20 GPIO port output data register
	uint8_t       RESERVED2[2]; // @22
	__O uint32_t  BSRR;         // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR;         // @28 GPIO port configuration lock register
	__IO uint32_t AFRL;         // @32 GPIO alternate function low register
	__IO uint32_t AFRH;         // @36 GPIO alternate function high register
	__O uint16_t  BRR;          // @40 GPIO port bit reset register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL << 2) - 1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL << 2) - 1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL << 2) - 1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL << 2) - 1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL << 2) - 1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL << 2) - 1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9  = ((1UL << 2) - 1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8  = ((1UL << 2) - 1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7  = ((1UL << 2) - 1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6  = ((1UL << 2) - 1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5  = ((1UL << 2) - 1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4  = ((1UL << 2) - 1) << 8,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3  = ((1UL << 2) - 1) << 6,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2  = ((1UL << 2) - 1) << 4,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1  = ((1UL << 2) - 1) << 2,  // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0  = ((1UL << 2) - 1) << 0,  // Port x configuration bits (y = 0..15)
};
inline void gpioa_moder_set_moder15(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val << 30) & GPIOA_MODER_MODER15);
}
inline void gpioa_moder_set_moder14(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val << 28) & GPIOA_MODER_MODER14);
}
inline void gpioa_moder_set_moder13(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val << 26) & GPIOA_MODER_MODER13);
}
inline void gpioa_moder_set_moder12(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val << 24) & GPIOA_MODER_MODER12);
}
inline void gpioa_moder_set_moder11(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val << 22) & GPIOA_MODER_MODER11);
}
inline void gpioa_moder_set_moder10(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val << 20) & GPIOA_MODER_MODER10);
}
inline void gpioa_moder_set_moder9(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val << 18) & GPIOA_MODER_MODER9);
}
inline void gpioa_moder_set_moder8(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val << 16) & GPIOA_MODER_MODER8);
}
inline void gpioa_moder_set_moder7(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val << 14) & GPIOA_MODER_MODER7);
}
inline void gpioa_moder_set_moder6(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val << 12) & GPIOA_MODER_MODER6);
}
inline void gpioa_moder_set_moder5(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val << 10) & GPIOA_MODER_MODER5);
}
inline void gpioa_moder_set_moder4(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val << 8) & GPIOA_MODER_MODER4);
}
inline void gpioa_moder_set_moder3(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val << 6) & GPIOA_MODER_MODER3);
}
inline void gpioa_moder_set_moder2(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val << 4) & GPIOA_MODER_MODER2);
}
inline void gpioa_moder_set_moder1(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val << 2) & GPIOA_MODER_MODER1);
}
inline void gpioa_moder_set_moder0(struct GPIOA_Type* p, uint32_t val) {
	p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val << 0) & GPIOA_MODER_MODER0);
}
inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30; }
inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28; }
inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26; }
inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24; }
inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22; }
inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20; }
inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18; }
inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16; }
inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14; }
inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12; }
inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10; }
inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8; }
inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6; }
inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4; }
inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2; }
inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL << 2) - 1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL << 2) - 1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL << 2) - 1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL << 2) - 1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL << 2) - 1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL << 2) - 1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9  = ((1UL << 2) - 1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8  = ((1UL << 2) - 1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7  = ((1UL << 2) - 1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6  = ((1UL << 2) - 1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5  = ((1UL << 2) - 1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4  = ((1UL << 2) - 1) << 8,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3  = ((1UL << 2) - 1) << 6,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2  = ((1UL << 2) - 1) << 4,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1  = ((1UL << 2) - 1) << 2,  // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0  = ((1UL << 2) - 1) << 0,  // Port x configuration bits (y = 0..15)
};
inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val << 30) & GPIOA_OSPEEDR_OSPEEDR15);
}
inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val << 28) & GPIOA_OSPEEDR_OSPEEDR14);
}
inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val << 26) & GPIOA_OSPEEDR_OSPEEDR13);
}
inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val << 24) & GPIOA_OSPEEDR_OSPEEDR12);
}
inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val << 22) & GPIOA_OSPEEDR_OSPEEDR11);
}
inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val << 20) & GPIOA_OSPEEDR_OSPEEDR10);
}
inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val << 18) & GPIOA_OSPEEDR_OSPEEDR9);
}
inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val << 16) & GPIOA_OSPEEDR_OSPEEDR8);
}
inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val << 14) & GPIOA_OSPEEDR_OSPEEDR7);
}
inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val << 12) & GPIOA_OSPEEDR_OSPEEDR6);
}
inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val << 10) & GPIOA_OSPEEDR_OSPEEDR5);
}
inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val << 8) & GPIOA_OSPEEDR_OSPEEDR4);
}
inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val << 6) & GPIOA_OSPEEDR_OSPEEDR3);
}
inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val << 4) & GPIOA_OSPEEDR_OSPEEDR2);
}
inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val << 2) & GPIOA_OSPEEDR_OSPEEDR1);
}
inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type* p, uint32_t val) {
	p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val << 0) & GPIOA_OSPEEDR_OSPEEDR0);
}
inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30; }
inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28; }
inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26; }
inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24; }
inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22; }
inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20; }
inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18; }
inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16; }
inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14; }
inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12; }
inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10; }
inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8; }
inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6; }
inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4; }
inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2; }
inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL << 2) - 1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL << 2) - 1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL << 2) - 1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL << 2) - 1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL << 2) - 1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL << 2) - 1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9  = ((1UL << 2) - 1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8  = ((1UL << 2) - 1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7  = ((1UL << 2) - 1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6  = ((1UL << 2) - 1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5  = ((1UL << 2) - 1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4  = ((1UL << 2) - 1) << 8,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3  = ((1UL << 2) - 1) << 6,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2  = ((1UL << 2) - 1) << 4,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1  = ((1UL << 2) - 1) << 2,  // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0  = ((1UL << 2) - 1) << 0,  // Port x configuration bits (y = 0..15)
};
inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val << 30) & GPIOA_PUPDR_PUPDR15);
}
inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val << 28) & GPIOA_PUPDR_PUPDR14);
}
inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val << 26) & GPIOA_PUPDR_PUPDR13);
}
inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val << 24) & GPIOA_PUPDR_PUPDR12);
}
inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val << 22) & GPIOA_PUPDR_PUPDR11);
}
inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val << 20) & GPIOA_PUPDR_PUPDR10);
}
inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val << 18) & GPIOA_PUPDR_PUPDR9);
}
inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val << 16) & GPIOA_PUPDR_PUPDR8);
}
inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val << 14) & GPIOA_PUPDR_PUPDR7);
}
inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val << 12) & GPIOA_PUPDR_PUPDR6);
}
inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val << 10) & GPIOA_PUPDR_PUPDR5);
}
inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val << 8) & GPIOA_PUPDR_PUPDR4);
}
inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val << 6) & GPIOA_PUPDR_PUPDR3);
}
inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val << 4) & GPIOA_PUPDR_PUPDR2);
}
inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val << 2) & GPIOA_PUPDR_PUPDR1);
}
inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type* p, uint32_t val) {
	p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val << 0) & GPIOA_PUPDR_PUPDR0);
}
inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30; }
inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28; }
inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26; }
inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24; }
inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22; }
inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20; }
inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18; }
inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16; }
inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14; }
inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12; }
inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10; }
inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8; }
inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6; }
inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4; }
inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2; }
inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL << 31, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL << 30, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL << 29, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL << 28, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL << 27, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL << 26, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9  = 1UL << 25, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8  = 1UL << 24, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7  = 1UL << 23, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6  = 1UL << 22, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5  = 1UL << 21, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4  = 1UL << 20, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3  = 1UL << 19, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2  = 1UL << 18, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1  = 1UL << 17, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0  = 1UL << 16, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL << 15, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL << 14, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL << 13, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL << 12, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL << 11, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL << 10, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9  = 1UL << 9,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8  = 1UL << 8,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7  = 1UL << 7,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6  = 1UL << 6,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5  = 1UL << 5,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4  = 1UL << 4,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3  = 1UL << 3,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2  = 1UL << 2,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1  = 1UL << 1,  // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0  = 1UL << 0,  // Port x set bit y (y= 0..15)
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK  = 1UL << 16, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL << 15, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL << 14, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL << 13, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL << 12, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL << 11, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL << 10, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9  = 1UL << 9,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8  = 1UL << 8,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7  = 1UL << 7,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6  = 1UL << 6,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5  = 1UL << 5,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4  = 1UL << 4,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3  = 1UL << 3,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2  = 1UL << 2,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1  = 1UL << 1,  // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0  = 1UL << 0,  // Port x lock bit y (y= 0..15)
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFRL7 = ((1UL << 4) - 1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL6 = ((1UL << 4) - 1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL5 = ((1UL << 4) - 1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL4 = ((1UL << 4) - 1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL3 = ((1UL << 4) - 1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL2 = ((1UL << 4) - 1) << 8,  // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL1 = ((1UL << 4) - 1) << 4,  // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL0 = ((1UL << 4) - 1) << 0,  // Alternate function selection for port x bit y (y = 0..7)
};
inline void gpioa_afrl_set_afrl7(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL7) | ((val << 28) & GPIOA_AFRL_AFRL7);
}
inline void gpioa_afrl_set_afrl6(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL6) | ((val << 24) & GPIOA_AFRL_AFRL6);
}
inline void gpioa_afrl_set_afrl5(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL5) | ((val << 20) & GPIOA_AFRL_AFRL5);
}
inline void gpioa_afrl_set_afrl4(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL4) | ((val << 16) & GPIOA_AFRL_AFRL4);
}
inline void gpioa_afrl_set_afrl3(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL3) | ((val << 12) & GPIOA_AFRL_AFRL3);
}
inline void gpioa_afrl_set_afrl2(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL2) | ((val << 8) & GPIOA_AFRL_AFRL2);
}
inline void gpioa_afrl_set_afrl1(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL1) | ((val << 4) & GPIOA_AFRL_AFRL1);
}
inline void gpioa_afrl_set_afrl0(struct GPIOA_Type* p, uint32_t val) {
	p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL0) | ((val << 0) & GPIOA_AFRL_AFRL0);
}
inline uint32_t gpioa_afrl_get_afrl7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL7) >> 28; }
inline uint32_t gpioa_afrl_get_afrl6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL6) >> 24; }
inline uint32_t gpioa_afrl_get_afrl5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL5) >> 20; }
inline uint32_t gpioa_afrl_get_afrl4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL4) >> 16; }
inline uint32_t gpioa_afrl_get_afrl3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL3) >> 12; }
inline uint32_t gpioa_afrl_get_afrl2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL2) >> 8; }
inline uint32_t gpioa_afrl_get_afrl1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL1) >> 4; }
inline uint32_t gpioa_afrl_get_afrl0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL0) >> 0; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFRH15 = ((1UL << 4) - 1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH14 = ((1UL << 4) - 1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH13 = ((1UL << 4) - 1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH12 = ((1UL << 4) - 1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH11 = ((1UL << 4) - 1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH10 = ((1UL << 4) - 1) << 8,  // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH9  = ((1UL << 4) - 1) << 4,  // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH8  = ((1UL << 4) - 1) << 0,  // Alternate function selection for port x bit y (y = 8..15)
};
inline void gpioa_afrh_set_afrh15(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH15) | ((val << 28) & GPIOA_AFRH_AFRH15);
}
inline void gpioa_afrh_set_afrh14(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH14) | ((val << 24) & GPIOA_AFRH_AFRH14);
}
inline void gpioa_afrh_set_afrh13(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH13) | ((val << 20) & GPIOA_AFRH_AFRH13);
}
inline void gpioa_afrh_set_afrh12(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH12) | ((val << 16) & GPIOA_AFRH_AFRH12);
}
inline void gpioa_afrh_set_afrh11(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH11) | ((val << 12) & GPIOA_AFRH_AFRH11);
}
inline void gpioa_afrh_set_afrh10(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH10) | ((val << 8) & GPIOA_AFRH_AFRH10);
}
inline void gpioa_afrh_set_afrh9(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH9) | ((val << 4) & GPIOA_AFRH_AFRH9);
}
inline void gpioa_afrh_set_afrh8(struct GPIOA_Type* p, uint32_t val) {
	p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH8) | ((val << 0) & GPIOA_AFRH_AFRH8);
}
inline uint32_t gpioa_afrh_get_afrh15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH15) >> 28; }
inline uint32_t gpioa_afrh_get_afrh14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH14) >> 24; }
inline uint32_t gpioa_afrh_get_afrh13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH13) >> 20; }
inline uint32_t gpioa_afrh_get_afrh12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH12) >> 16; }
inline uint32_t gpioa_afrh_get_afrh11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH11) >> 12; }
inline uint32_t gpioa_afrh_get_afrh10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH10) >> 8; }
inline uint32_t gpioa_afrh_get_afrh9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH9) >> 4; }
inline uint32_t gpioa_afrh_get_afrh8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH8) >> 0; }

/* Inter-integrated circuit */
struct I2C1_Type {
	__IO uint32_t CR1;          // @0 Control register 1
	__IO uint32_t CR2;          // @4 Control register 2
	__IO uint16_t OAR1;         // @8 Own address register 1
	uint8_t       RESERVED0[2]; // @10
	__IO uint16_t OAR2;         // @12 Own address register 2
	uint8_t       RESERVED1[2]; // @14
	__IO uint32_t TIMINGR;      // @16 Timing register
	__IO uint32_t TIMEOUTR;     // @20 Status register 1
	__IO uint32_t ISR;          // @24 Interrupt and Status register
	__O uint16_t  ICR;          // @28 Interrupt clear register
	uint8_t       RESERVED2[2]; // @30
	__I uint8_t   PECR;         // @32 PEC register
	uint8_t       RESERVED3[3]; // @33
	__I uint8_t   RXDR;         // @36 Receive data register
	uint8_t       RESERVED4[3]; // @37
	__IO uint8_t  TXDR;         // @40 Transmit data register
};

// I2C1->CR1 Control register 1
enum {
	I2C1_CR1_PECEN     = 1UL << 23,             // PEC enable
	I2C1_CR1_ALERTEN   = 1UL << 22,             // SMBUS alert enable
	I2C1_CR1_SMBDEN    = 1UL << 21,             // SMBus Device Default address enable
	I2C1_CR1_SMBHEN    = 1UL << 20,             // SMBus Host address enable
	I2C1_CR1_GCEN      = 1UL << 19,             // General call enable
	I2C1_CR1_WUPEN     = 1UL << 18,             // Wakeup from STOP enable
	I2C1_CR1_NOSTRETCH = 1UL << 17,             // Clock stretching disable
	I2C1_CR1_SBC       = 1UL << 16,             // Slave byte control
	I2C1_CR1_RXDMAEN   = 1UL << 15,             // DMA reception requests enable
	I2C1_CR1_TXDMAEN   = 1UL << 14,             // DMA transmission requests enable
	I2C1_CR1_ANFOFF    = 1UL << 12,             // Analog noise filter OFF
	I2C1_CR1_DNF       = ((1UL << 4) - 1) << 8, // Digital noise filter
	I2C1_CR1_ERRIE     = 1UL << 7,              // Error interrupts enable
	I2C1_CR1_TCIE      = 1UL << 6,              // Transfer Complete interrupt enable
	I2C1_CR1_STOPIE    = 1UL << 5,              // STOP detection Interrupt enable
	I2C1_CR1_NACKIE    = 1UL << 4,              // Not acknowledge received interrupt enable
	I2C1_CR1_ADDRIE    = 1UL << 3,              // Address match interrupt enable (slave only)
	I2C1_CR1_RXIE      = 1UL << 2,              // RX Interrupt enable
	I2C1_CR1_TXIE      = 1UL << 1,              // TX Interrupt enable
	I2C1_CR1_PE        = 1UL << 0,              // Peripheral enable
};
inline void     i2c1_cr1_set_dnf(struct I2C1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C1_CR1_DNF) | ((val << 8) & I2C1_CR1_DNF); }
inline uint32_t i2c1_cr1_get_dnf(struct I2C1_Type* p) { return (p->CR1 & I2C1_CR1_DNF) >> 8; }

// I2C1->CR2 Control register 2
enum {
	I2C1_CR2_PECBYTE = 1UL << 26,              // Packet error checking byte
	I2C1_CR2_AUTOEND = 1UL << 25,              // Automatic end mode (master mode)
	I2C1_CR2_RELOAD  = 1UL << 24,              // NBYTES reload mode
	I2C1_CR2_NBYTES  = ((1UL << 8) - 1) << 16, // Number of bytes
	I2C1_CR2_NACK    = 1UL << 15,              // NACK generation (slave mode)
	I2C1_CR2_STOP    = 1UL << 14,              // Stop generation (master mode)
	I2C1_CR2_START   = 1UL << 13,              // Start generation
	I2C1_CR2_HEAD10R = 1UL << 12,              // 10-bit address header only read direction (master receiver mode)
	I2C1_CR2_ADD10   = 1UL << 11,              // 10-bit addressing mode (master mode)
	I2C1_CR2_RD_WRN  = 1UL << 10,              // Transfer direction (master mode)
	I2C1_CR2_SADD    = ((1UL << 10) - 1) << 0, // Slave address bit (master mode)
};
inline void i2c1_cr2_set_nbytes(struct I2C1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~I2C1_CR2_NBYTES) | ((val << 16) & I2C1_CR2_NBYTES);
}
inline void     i2c1_cr2_set_sadd(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_SADD) | ((val << 0) & I2C1_CR2_SADD); }
inline uint32_t i2c1_cr2_get_nbytes(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_NBYTES) >> 16; }
inline uint32_t i2c1_cr2_get_sadd(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_SADD) >> 0; }

// I2C1->OAR1 Own address register 1
enum {
	I2C1_OAR1_OA1EN   = 1UL << 15,              // Own Address 1 enable
	I2C1_OAR1_OA1MODE = 1UL << 10,              // Own Address 1 10-bit mode
	I2C1_OAR1_OA1     = ((1UL << 10) - 1) << 0, // Interface address
};
inline void i2c1_oar1_set_oa1(struct I2C1_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1) | ((val << 0) & I2C1_OAR1_OA1); }
inline uint32_t i2c1_oar1_get_oa1(struct I2C1_Type* p) { return (p->OAR1 & I2C1_OAR1_OA1) >> 0; }

// I2C1->OAR2 Own address register 2
enum {
	I2C1_OAR2_OA2EN  = 1UL << 15,             // Own Address 2 enable
	I2C1_OAR2_OA2MSK = ((1UL << 3) - 1) << 8, // Own Address 2 masks
	I2C1_OAR2_OA2    = ((1UL << 7) - 1) << 1, // Interface address
};
inline void i2c1_oar2_set_oa2msk(struct I2C1_Type* p, uint32_t val) {
	p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2MSK) | ((val << 8) & I2C1_OAR2_OA2MSK);
}
inline void i2c1_oar2_set_oa2(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2) | ((val << 1) & I2C1_OAR2_OA2); }
inline uint32_t i2c1_oar2_get_oa2msk(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2MSK) >> 8; }
inline uint32_t i2c1_oar2_get_oa2(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2) >> 1; }

// I2C1->TIMINGR Timing register
enum {
	I2C1_TIMINGR_PRESC  = ((1UL << 4) - 1) << 28, // Timing prescaler
	I2C1_TIMINGR_SCLDEL = ((1UL << 4) - 1) << 20, // Data setup time
	I2C1_TIMINGR_SDADEL = ((1UL << 4) - 1) << 16, // Data hold time
	I2C1_TIMINGR_SCLH   = ((1UL << 8) - 1) << 8,  // SCL high period (master mode)
	I2C1_TIMINGR_SCLL   = ((1UL << 8) - 1) << 0,  // SCL low period (master mode)
};
inline void i2c1_timingr_set_presc(struct I2C1_Type* p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_PRESC) | ((val << 28) & I2C1_TIMINGR_PRESC);
}
inline void i2c1_timingr_set_scldel(struct I2C1_Type* p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLDEL) | ((val << 20) & I2C1_TIMINGR_SCLDEL);
}
inline void i2c1_timingr_set_sdadel(struct I2C1_Type* p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SDADEL) | ((val << 16) & I2C1_TIMINGR_SDADEL);
}
inline void i2c1_timingr_set_sclh(struct I2C1_Type* p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLH) | ((val << 8) & I2C1_TIMINGR_SCLH);
}
inline void i2c1_timingr_set_scll(struct I2C1_Type* p, uint32_t val) {
	p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLL) | ((val << 0) & I2C1_TIMINGR_SCLL);
}
inline uint32_t i2c1_timingr_get_presc(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_PRESC) >> 28; }
inline uint32_t i2c1_timingr_get_scldel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLDEL) >> 20; }
inline uint32_t i2c1_timingr_get_sdadel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SDADEL) >> 16; }
inline uint32_t i2c1_timingr_get_sclh(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLH) >> 8; }
inline uint32_t i2c1_timingr_get_scll(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLL) >> 0; }

// I2C1->TIMEOUTR Status register 1
enum {
	I2C1_TIMEOUTR_TEXTEN   = 1UL << 31,               // Extended clock timeout enable
	I2C1_TIMEOUTR_TIMEOUTB = ((1UL << 12) - 1) << 16, // Bus timeout B
	I2C1_TIMEOUTR_TIMOUTEN = 1UL << 15,               // Clock timeout enable
	I2C1_TIMEOUTR_TIDLE    = 1UL << 12,               // Idle clock timeout detection
	I2C1_TIMEOUTR_TIMEOUTA = ((1UL << 12) - 1) << 0,  // Bus timeout A
};
inline void i2c1_timeoutr_set_timeoutb(struct I2C1_Type* p, uint32_t val) {
	p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTB) | ((val << 16) & I2C1_TIMEOUTR_TIMEOUTB);
}
inline void i2c1_timeoutr_set_timeouta(struct I2C1_Type* p, uint32_t val) {
	p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTA) | ((val << 0) & I2C1_TIMEOUTR_TIMEOUTA);
}
inline uint32_t i2c1_timeoutr_get_timeoutb(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTB) >> 16; }
inline uint32_t i2c1_timeoutr_get_timeouta(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTA) >> 0; }

// I2C1->ISR Interrupt and Status register
enum {
	I2C1_ISR_ADDCODE = ((1UL << 7) - 1) << 17, // Address match code (Slave mode)
	I2C1_ISR_DIR     = 1UL << 16,              // Transfer direction (Slave mode)
	I2C1_ISR_BUSY    = 1UL << 15,              // Bus busy
	I2C1_ISR_ALERT   = 1UL << 13,              // SMBus alert
	I2C1_ISR_TIMEOUT = 1UL << 12,              // Timeout or t_low detection flag
	I2C1_ISR_PECERR  = 1UL << 11,              // PEC Error in reception
	I2C1_ISR_OVR     = 1UL << 10,              // Overrun/Underrun (slave mode)
	I2C1_ISR_ARLO    = 1UL << 9,               // Arbitration lost
	I2C1_ISR_BERR    = 1UL << 8,               // Bus error
	I2C1_ISR_TCR     = 1UL << 7,               // Transfer Complete Reload
	I2C1_ISR_TC      = 1UL << 6,               // Transfer Complete (master mode)
	I2C1_ISR_STOPF   = 1UL << 5,               // Stop detection flag
	I2C1_ISR_NACKF   = 1UL << 4,               // Not acknowledge received flag
	I2C1_ISR_ADDR    = 1UL << 3,               // Address matched (slave mode)
	I2C1_ISR_RXNE    = 1UL << 2,               // Receive data register not empty (receivers)
	I2C1_ISR_TXIS    = 1UL << 1,               // Transmit interrupt status (transmitters)
	I2C1_ISR_TXE     = 1UL << 0,               // Transmit data register empty (transmitters)
};
inline void i2c1_isr_set_addcode(struct I2C1_Type* p, uint32_t val) {
	p->ISR = (p->ISR & ~I2C1_ISR_ADDCODE) | ((val << 17) & I2C1_ISR_ADDCODE);
}
inline uint32_t i2c1_isr_get_addcode(struct I2C1_Type* p) { return (p->ISR & I2C1_ISR_ADDCODE) >> 17; }

// I2C1->ICR Interrupt clear register
enum {
	I2C1_ICR_ALERTCF  = 1UL << 13, // Alert flag clear
	I2C1_ICR_TIMOUTCF = 1UL << 12, // Timeout detection flag clear
	I2C1_ICR_PECCF    = 1UL << 11, // PEC Error flag clear
	I2C1_ICR_OVRCF    = 1UL << 10, // Overrun/Underrun flag clear
	I2C1_ICR_ARLOCF   = 1UL << 9,  // Arbitration lost flag clear
	I2C1_ICR_BERRCF   = 1UL << 8,  // Bus error flag clear
	I2C1_ICR_STOPCF   = 1UL << 5,  // Stop detection flag clear
	I2C1_ICR_NACKCF   = 1UL << 4,  // Not Acknowledge flag clear
	I2C1_ICR_ADDRCF   = 1UL << 3,  // Address Matched flag clear
};

/* System window watchdog */
struct IWDG_Type {
	__IO uint8_t  CR;           // @0 Control register
	uint8_t       RESERVED0[3]; // @1
	__IO uint16_t CFR;          // @4 Configuration register
	uint8_t       RESERVED1[2]; // @6
	__IO uint8_t  SR;           // @8 Status register
};

// IWDG->CR Control register
enum {
	IWDG_CR_WDGA = 1UL << 7,              // Activation bit
	IWDG_CR_T    = ((1UL << 7) - 1) << 0, // 7-bit counter (MSB to LSB)
};
inline void     iwdg_cr_set_t(struct IWDG_Type* p, uint32_t val) { p->CR = (p->CR & ~IWDG_CR_T) | ((val << 0) & IWDG_CR_T); }
inline uint32_t iwdg_cr_get_t(struct IWDG_Type* p) { return (p->CR & IWDG_CR_T) >> 0; }

// IWDG->CFR Configuration register
enum {
	IWDG_CFR_WDGTB = ((1UL << 3) - 1) << 11, // Timer base
	IWDG_CFR_EWI   = 1UL << 9,               // Early wakeup interrupt
	IWDG_CFR_W     = ((1UL << 7) - 1) << 0,  // 7-bit window value
};
inline void iwdg_cfr_set_wdgtb(struct IWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~IWDG_CFR_WDGTB) | ((val << 11) & IWDG_CFR_WDGTB); }
inline void iwdg_cfr_set_w(struct IWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~IWDG_CFR_W) | ((val << 0) & IWDG_CFR_W); }
inline uint32_t iwdg_cfr_get_wdgtb(struct IWDG_Type* p) { return (p->CFR & IWDG_CFR_WDGTB) >> 11; }
inline uint32_t iwdg_cfr_get_w(struct IWDG_Type* p) { return (p->CFR & IWDG_CFR_W) >> 0; }

// IWDG->SR Status register
enum {
	IWDG_SR_EWIF = 1UL << 0, // Early wakeup interrupt flag
};

/* Low power timer */
struct LPTIMER1_Type {
	__I uint8_t   ISR;          // @0 Interrupt and Status Register
	uint8_t       RESERVED0[3]; // @1
	__O uint8_t   ICR;          // @4 Interrupt Clear Register
	uint8_t       RESERVED1[3]; // @5
	__IO uint8_t  IER;          // @8 Interrupt Enable Register
	uint8_t       RESERVED2[3]; // @9
	__IO uint32_t CFGR;         // @12 Configuration Register
	__IO uint8_t  CR;           // @16 Control Register
	uint8_t       RESERVED3[3]; // @17
	__IO uint16_t CMP;          // @20 Compare Register
	uint8_t       RESERVED4[2]; // @22
	__IO uint16_t ARR;          // @24 Autoreload Register
	uint8_t       RESERVED5[2]; // @26
	__I uint16_t  CNT;          // @28 Counter Register
	uint8_t       RESERVED6[2]; // @30
	__IO uint8_t  OR;           // @32 option register
};

// LPTIMER1->ISR Interrupt and Status Register
enum {
	LPTIMER1_ISR_DOWN    = 1UL << 6, // Counter direction change up to down
	LPTIMER1_ISR_UP      = 1UL << 5, // Counter direction change down to up
	LPTIMER1_ISR_ARROK   = 1UL << 4, // Autoreload register update OK
	LPTIMER1_ISR_CMPOK   = 1UL << 3, // Compare register update OK
	LPTIMER1_ISR_EXTTRIG = 1UL << 2, // External trigger edge event
	LPTIMER1_ISR_ARRM    = 1UL << 1, // Autoreload match
	LPTIMER1_ISR_CMPM    = 1UL << 0, // Compare match
};

// LPTIMER1->ICR Interrupt Clear Register
enum {
	LPTIMER1_ICR_DOWNCF    = 1UL << 6, // Direction change to down Clear Flag
	LPTIMER1_ICR_UPCF      = 1UL << 5, // Direction change to UP Clear Flag
	LPTIMER1_ICR_ARROKCF   = 1UL << 4, // Autoreload register update OK Clear Flag
	LPTIMER1_ICR_CMPOKCF   = 1UL << 3, // Compare register update OK Clear Flag
	LPTIMER1_ICR_EXTTRIGCF = 1UL << 2, // External trigger valid edge Clear Flag
	LPTIMER1_ICR_ARRMCF    = 1UL << 1, // Autoreload match Clear Flag
	LPTIMER1_ICR_CMPMCF    = 1UL << 0, // compare match Clear Flag
};

// LPTIMER1->IER Interrupt Enable Register
enum {
	LPTIMER1_IER_DOWNIE    = 1UL << 6, // Direction change to down Interrupt Enable
	LPTIMER1_IER_UPIE      = 1UL << 5, // Direction change to UP Interrupt Enable
	LPTIMER1_IER_ARROKIE   = 1UL << 4, // Autoreload register update OK Interrupt Enable
	LPTIMER1_IER_CMPOKIE   = 1UL << 3, // Compare register update OK Interrupt Enable
	LPTIMER1_IER_EXTTRIGIE = 1UL << 2, // External trigger valid edge Interrupt Enable
	LPTIMER1_IER_ARRMIE    = 1UL << 1, // Autoreload match Interrupt Enable
	LPTIMER1_IER_CMPMIE    = 1UL << 0, // Compare match Interrupt Enable
};

// LPTIMER1->CFGR Configuration Register
enum {
	LPTIMER1_CFGR_ENC       = 1UL << 24,              // Encoder mode enable
	LPTIMER1_CFGR_COUNTMODE = 1UL << 23,              // counter mode enabled
	LPTIMER1_CFGR_PRELOAD   = 1UL << 22,              // Registers update mode
	LPTIMER1_CFGR_WAVPOL    = 1UL << 21,              // Waveform shape polarity
	LPTIMER1_CFGR_WAVE      = 1UL << 20,              // Waveform shape
	LPTIMER1_CFGR_TIMOUT    = 1UL << 19,              // Timeout enable
	LPTIMER1_CFGR_TRIGEN    = ((1UL << 2) - 1) << 17, // Trigger enable and polarity
	LPTIMER1_CFGR_TRIGSEL   = ((1UL << 4) - 1) << 13, // Trigger selector
	LPTIMER1_CFGR_PRESC     = ((1UL << 3) - 1) << 9,  // Clock prescaler
	LPTIMER1_CFGR_TRGFLT    = ((1UL << 2) - 1) << 6,  // Configurable digital filter for trigger
	LPTIMER1_CFGR_CKFLT     = ((1UL << 2) - 1) << 3,  // Configurable digital filter for external clock
	LPTIMER1_CFGR_CKPOL     = ((1UL << 2) - 1) << 1,  // Clock Polarity
	LPTIMER1_CFGR_CKSEL     = 1UL << 0,               // Clock selector
};
inline void lptimer1_cfgr_set_trigen(struct LPTIMER1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_TRIGEN) | ((val << 17) & LPTIMER1_CFGR_TRIGEN);
}
inline void lptimer1_cfgr_set_trigsel(struct LPTIMER1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_TRIGSEL) | ((val << 13) & LPTIMER1_CFGR_TRIGSEL);
}
inline void lptimer1_cfgr_set_presc(struct LPTIMER1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_PRESC) | ((val << 9) & LPTIMER1_CFGR_PRESC);
}
inline void lptimer1_cfgr_set_trgflt(struct LPTIMER1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_TRGFLT) | ((val << 6) & LPTIMER1_CFGR_TRGFLT);
}
inline void lptimer1_cfgr_set_ckflt(struct LPTIMER1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_CKFLT) | ((val << 3) & LPTIMER1_CFGR_CKFLT);
}
inline void lptimer1_cfgr_set_ckpol(struct LPTIMER1_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~LPTIMER1_CFGR_CKPOL) | ((val << 1) & LPTIMER1_CFGR_CKPOL);
}
inline uint32_t lptimer1_cfgr_get_trigen(struct LPTIMER1_Type* p) { return (p->CFGR & LPTIMER1_CFGR_TRIGEN) >> 17; }
inline uint32_t lptimer1_cfgr_get_trigsel(struct LPTIMER1_Type* p) { return (p->CFGR & LPTIMER1_CFGR_TRIGSEL) >> 13; }
inline uint32_t lptimer1_cfgr_get_presc(struct LPTIMER1_Type* p) { return (p->CFGR & LPTIMER1_CFGR_PRESC) >> 9; }
inline uint32_t lptimer1_cfgr_get_trgflt(struct LPTIMER1_Type* p) { return (p->CFGR & LPTIMER1_CFGR_TRGFLT) >> 6; }
inline uint32_t lptimer1_cfgr_get_ckflt(struct LPTIMER1_Type* p) { return (p->CFGR & LPTIMER1_CFGR_CKFLT) >> 3; }
inline uint32_t lptimer1_cfgr_get_ckpol(struct LPTIMER1_Type* p) { return (p->CFGR & LPTIMER1_CFGR_CKPOL) >> 1; }

// LPTIMER1->CR Control Register
enum {
	LPTIMER1_CR_RSTARE   = 1UL << 4, // RSTARE
	LPTIMER1_CR_COUNTRST = 1UL << 3, // COUNTRST
	LPTIMER1_CR_CNTSTRT  = 1UL << 2, // Timer start in continuous mode
	LPTIMER1_CR_SNGSTRT  = 1UL << 1, // LPTIM start in single mode
	LPTIMER1_CR_ENABLE   = 1UL << 0, // LPTIM Enable
};

// LPTIMER1->OR option register
enum {
	LPTIMER1_OR_IN2_2_1 = ((1UL << 2) - 1) << 4, // IN2_2_1
	LPTIMER1_OR_IN1_2_1 = ((1UL << 2) - 1) << 2, // IN1_2_1
	LPTIMER1_OR_IN2     = 1UL << 1,              // IN2
	LPTIMER1_OR_IN1     = 1UL << 0,              // IN1
};
inline void lptimer1_or_set_in2_2_1(struct LPTIMER1_Type* p, uint32_t val) {
	p->OR = (p->OR & ~LPTIMER1_OR_IN2_2_1) | ((val << 4) & LPTIMER1_OR_IN2_2_1);
}
inline void lptimer1_or_set_in1_2_1(struct LPTIMER1_Type* p, uint32_t val) {
	p->OR = (p->OR & ~LPTIMER1_OR_IN1_2_1) | ((val << 2) & LPTIMER1_OR_IN1_2_1);
}
inline uint32_t lptimer1_or_get_in2_2_1(struct LPTIMER1_Type* p) { return (p->OR & LPTIMER1_OR_IN2_2_1) >> 4; }
inline uint32_t lptimer1_or_get_in1_2_1(struct LPTIMER1_Type* p) { return (p->OR & LPTIMER1_OR_IN1_2_1) >> 2; }

/* Universal synchronous asynchronous receiver transmitter */
struct LPUART1_Type {
	__IO uint32_t CR1;          // @0 Control register 1
	__IO uint32_t CR2;          // @4 Control register 2
	__IO uint32_t CR3;          // @8 Control register 3
	__IO uint32_t BRR;          // @12 Baud rate register
	uint8_t       RESERVED0[8]; // @16
	__O uint8_t   RQR;          // @24 Request register
	uint8_t       RESERVED1[3]; // @25
	__I uint32_t  ISR;          // @28 Interrupt & status register
	__O uint32_t  ICR;          // @32 Interrupt flag clear register
	__I uint16_t  RDR;          // @36 Receive data register
	uint8_t       RESERVED2[2]; // @38
	__IO uint16_t TDR;          // @40 Transmit data register
	uint8_t       RESERVED3[2]; // @42
	__IO uint8_t  PRESC;        // @44 Prescaler register
};

// LPUART1->CR1 Control register 1
enum {
	LPUART1_CR1_RXFFIE = 1UL << 31, // RXFFIE
	LPUART1_CR1_TXFEIE = 1UL << 30, // TXFEIE
	LPUART1_CR1_FIFOEN = 1UL << 29, // FIFOEN
	LPUART1_CR1_M1     = 1UL << 28, // Word length
	LPUART1_CR1_DEAT4  = 1UL << 25, // Driver Enable assertion time
	LPUART1_CR1_DEAT3  = 1UL << 24, // DEAT3
	LPUART1_CR1_DEAT2  = 1UL << 23, // DEAT2
	LPUART1_CR1_DEAT1  = 1UL << 22, // DEAT1
	LPUART1_CR1_DEAT0  = 1UL << 21, // DEAT0
	LPUART1_CR1_DEDT4  = 1UL << 20, // Driver Enable de-assertion time
	LPUART1_CR1_DEDT3  = 1UL << 19, // DEDT3
	LPUART1_CR1_DEDT2  = 1UL << 18, // DEDT2
	LPUART1_CR1_DEDT1  = 1UL << 17, // DEDT1
	LPUART1_CR1_DEDT0  = 1UL << 16, // DEDT0
	LPUART1_CR1_CMIE   = 1UL << 14, // Character match interrupt enable
	LPUART1_CR1_MME    = 1UL << 13, // Mute mode enable
	LPUART1_CR1_M0     = 1UL << 12, // Word length
	LPUART1_CR1_WAKE   = 1UL << 11, // Receiver wakeup method
	LPUART1_CR1_PCE    = 1UL << 10, // Parity control enable
	LPUART1_CR1_PS     = 1UL << 9,  // Parity selection
	LPUART1_CR1_PEIE   = 1UL << 8,  // PE interrupt enable
	LPUART1_CR1_TXEIE  = 1UL << 7,  // interrupt enable
	LPUART1_CR1_TCIE   = 1UL << 6,  // Transmission complete interrupt enable
	LPUART1_CR1_RXNEIE = 1UL << 5,  // RXNE interrupt enable
	LPUART1_CR1_IDLEIE = 1UL << 4,  // IDLE interrupt enable
	LPUART1_CR1_TE     = 1UL << 3,  // Transmitter enable
	LPUART1_CR1_RE     = 1UL << 2,  // Receiver enable
	LPUART1_CR1_UESM   = 1UL << 1,  // USART enable in Stop mode
	LPUART1_CR1_UE     = 1UL << 0,  // USART enable
};

// LPUART1->CR2 Control register 2
enum {
	LPUART1_CR2_ADD4_7   = ((1UL << 4) - 1) << 28, // Address of the USART node
	LPUART1_CR2_ADD0_3   = ((1UL << 4) - 1) << 24, // Address of the USART node
	LPUART1_CR2_MSBFIRST = 1UL << 19,              // Most significant bit first
	LPUART1_CR2_TAINV    = 1UL << 18,              // Binary data inversion
	LPUART1_CR2_TXINV    = 1UL << 17,              // TX pin active level inversion
	LPUART1_CR2_RXINV    = 1UL << 16,              // RX pin active level inversion
	LPUART1_CR2_SWAP     = 1UL << 15,              // Swap TX/RX pins
	LPUART1_CR2_STOP     = ((1UL << 2) - 1) << 12, // STOP bits
	LPUART1_CR2_ADDM7    = 1UL << 4,               // 7-bit Address Detection/4-bit Address Detection
};
inline void lpuart1_cr2_set_add4_7(struct LPUART1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD4_7) | ((val << 28) & LPUART1_CR2_ADD4_7);
}
inline void lpuart1_cr2_set_add0_3(struct LPUART1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD0_3) | ((val << 24) & LPUART1_CR2_ADD0_3);
}
inline void lpuart1_cr2_set_stop(struct LPUART1_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~LPUART1_CR2_STOP) | ((val << 12) & LPUART1_CR2_STOP);
}
inline uint32_t lpuart1_cr2_get_add4_7(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_ADD4_7) >> 28; }
inline uint32_t lpuart1_cr2_get_add0_3(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_ADD0_3) >> 24; }
inline uint32_t lpuart1_cr2_get_stop(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_STOP) >> 12; }

// LPUART1->CR3 Control register 3
enum {
	LPUART1_CR3_TXFTCFG = ((1UL << 3) - 1) << 29, // TXFTCFG
	LPUART1_CR3_RXFTIE  = 1UL << 28,              // RXFTIE
	LPUART1_CR3_RXFTCFG = ((1UL << 3) - 1) << 25, // RXFTCFG
	LPUART1_CR3_TXFTIE  = 1UL << 23,              // TXFTIE
	LPUART1_CR3_WUFIE   = 1UL << 22,              // Wakeup from Stop mode interrupt enable
	LPUART1_CR3_WUS     = ((1UL << 2) - 1) << 20, // Wakeup from Stop mode interrupt flag selection
	LPUART1_CR3_DEP     = 1UL << 15,              // Driver enable polarity selection
	LPUART1_CR3_DEM     = 1UL << 14,              // Driver enable mode
	LPUART1_CR3_DDRE    = 1UL << 13,              // DMA Disable on Reception Error
	LPUART1_CR3_OVRDIS  = 1UL << 12,              // Overrun Disable
	LPUART1_CR3_CTSIE   = 1UL << 10,              // CTS interrupt enable
	LPUART1_CR3_CTSE    = 1UL << 9,               // CTS enable
	LPUART1_CR3_RTSE    = 1UL << 8,               // RTS enable
	LPUART1_CR3_DMAT    = 1UL << 7,               // DMA enable transmitter
	LPUART1_CR3_DMAR    = 1UL << 6,               // DMA enable receiver
	LPUART1_CR3_HDSEL   = 1UL << 3,               // Half-duplex selection
	LPUART1_CR3_EIE     = 1UL << 0,               // Error interrupt enable
};
inline void lpuart1_cr3_set_txftcfg(struct LPUART1_Type* p, uint32_t val) {
	p->CR3 = (p->CR3 & ~LPUART1_CR3_TXFTCFG) | ((val << 29) & LPUART1_CR3_TXFTCFG);
}
inline void lpuart1_cr3_set_rxftcfg(struct LPUART1_Type* p, uint32_t val) {
	p->CR3 = (p->CR3 & ~LPUART1_CR3_RXFTCFG) | ((val << 25) & LPUART1_CR3_RXFTCFG);
}
inline void lpuart1_cr3_set_wus(struct LPUART1_Type* p, uint32_t val) {
	p->CR3 = (p->CR3 & ~LPUART1_CR3_WUS) | ((val << 20) & LPUART1_CR3_WUS);
}
inline uint32_t lpuart1_cr3_get_txftcfg(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_TXFTCFG) >> 29; }
inline uint32_t lpuart1_cr3_get_rxftcfg(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_RXFTCFG) >> 25; }
inline uint32_t lpuart1_cr3_get_wus(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_WUS) >> 20; }

// LPUART1->BRR Baud rate register
enum {
	LPUART1_BRR_BRR = ((1UL << 20) - 1) << 0, // BRR
};
inline void lpuart1_brr_set_brr(struct LPUART1_Type* p, uint32_t val) {
	p->BRR = (p->BRR & ~LPUART1_BRR_BRR) | ((val << 0) & LPUART1_BRR_BRR);
}
inline uint32_t lpuart1_brr_get_brr(struct LPUART1_Type* p) { return (p->BRR & LPUART1_BRR_BRR) >> 0; }

// LPUART1->RQR Request register
enum {
	LPUART1_RQR_TXFRQ = 1UL << 4, // TXFRQ
	LPUART1_RQR_RXFRQ = 1UL << 3, // Receive data flush request
	LPUART1_RQR_MMRQ  = 1UL << 2, // Mute mode request
	LPUART1_RQR_SBKRQ = 1UL << 1, // Send break request
};

// LPUART1->ISR Interrupt & status register
enum {
	LPUART1_ISR_TXFT  = 1UL << 27, // TXFT
	LPUART1_ISR_RXFT  = 1UL << 26, // RXFT
	LPUART1_ISR_RXFF  = 1UL << 24, // RXFF
	LPUART1_ISR_TXFE  = 1UL << 23, // TXFE
	LPUART1_ISR_REACK = 1UL << 22, // REACK
	LPUART1_ISR_TEACK = 1UL << 21, // TEACK
	LPUART1_ISR_WUF   = 1UL << 20, // WUF
	LPUART1_ISR_RWU   = 1UL << 19, // RWU
	LPUART1_ISR_SBKF  = 1UL << 18, // SBKF
	LPUART1_ISR_CMF   = 1UL << 17, // CMF
	LPUART1_ISR_BUSY  = 1UL << 16, // BUSY
	LPUART1_ISR_CTS   = 1UL << 10, // CTS
	LPUART1_ISR_CTSIF = 1UL << 9,  // CTSIF
	LPUART1_ISR_TXE   = 1UL << 7,  // TXE
	LPUART1_ISR_TC    = 1UL << 6,  // TC
	LPUART1_ISR_RXNE  = 1UL << 5,  // RXNE
	LPUART1_ISR_IDLE  = 1UL << 4,  // IDLE
	LPUART1_ISR_ORE   = 1UL << 3,  // ORE
	LPUART1_ISR_NF    = 1UL << 2,  // NF
	LPUART1_ISR_FE    = 1UL << 1,  // FE
	LPUART1_ISR_PE    = 1UL << 0,  // PE
};

// LPUART1->ICR Interrupt flag clear register
enum {
	LPUART1_ICR_WUCF   = 1UL << 20, // Wakeup from Stop mode clear flag
	LPUART1_ICR_CMCF   = 1UL << 17, // Character match clear flag
	LPUART1_ICR_CTSCF  = 1UL << 9,  // CTS clear flag
	LPUART1_ICR_TCCF   = 1UL << 6,  // Transmission complete clear flag
	LPUART1_ICR_IDLECF = 1UL << 4,  // Idle line detected clear flag
	LPUART1_ICR_ORECF  = 1UL << 3,  // Overrun error clear flag
	LPUART1_ICR_NCF    = 1UL << 2,  // Noise detected clear flag
	LPUART1_ICR_FECF   = 1UL << 1,  // Framing error clear flag
	LPUART1_ICR_PECF   = 1UL << 0,  // Parity error clear flag
};

// LPUART1->RDR Receive data register
enum {
	LPUART1_RDR_RDR = ((1UL << 9) - 1) << 0, // Receive data value
};
inline uint32_t lpuart1_rdr_get_rdr(struct LPUART1_Type* p) { return (p->RDR & LPUART1_RDR_RDR) >> 0; }

// LPUART1->TDR Transmit data register
enum {
	LPUART1_TDR_TDR = ((1UL << 9) - 1) << 0, // Transmit data value
};
inline void lpuart1_tdr_set_tdr(struct LPUART1_Type* p, uint32_t val) {
	p->TDR = (p->TDR & ~LPUART1_TDR_TDR) | ((val << 0) & LPUART1_TDR_TDR);
}
inline uint32_t lpuart1_tdr_get_tdr(struct LPUART1_Type* p) { return (p->TDR & LPUART1_TDR_TDR) >> 0; }

// LPUART1->PRESC Prescaler register
enum {
	LPUART1_PRESC_PRESCALER = ((1UL << 4) - 1) << 0, // PRESCALER
};
inline void lpuart1_presc_set_prescaler(struct LPUART1_Type* p, uint32_t val) {
	p->PRESC = (p->PRESC & ~LPUART1_PRESC_PRESCALER) | ((val << 0) & LPUART1_PRESC_PRESCALER);
}
inline uint32_t lpuart1_presc_get_prescaler(struct LPUART1_Type* p) { return (p->PRESC & LPUART1_PRESC_PRESCALER) >> 0; }

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t  TYPER;        // @0 MPU type register
	__I uint8_t   CTRL;         // @4 MPU control register
	uint8_t       RESERVED0[3]; // @5
	__IO uint8_t  RNR;          // @8 MPU region number register
	uint8_t       RESERVED1[3]; // @9
	__IO uint32_t RBAR;         // @12 MPU region base address register
	__IO uint32_t RASR;         // @16 MPU region attribute and size register
};

// MPU->TYPER MPU type register
enum {
	MPU_TYPER_IREGION  = ((1UL << 8) - 1) << 16, // Number of MPU instruction regions
	MPU_TYPER_DREGION  = ((1UL << 8) - 1) << 8,  // Number of MPU data regions
	MPU_TYPER_SEPARATE = 1UL << 0,               // Separate flag
};
inline uint32_t mpu_typer_get_iregion(struct MPU_Type* p) { return (p->TYPER & MPU_TYPER_IREGION) >> 16; }
inline uint32_t mpu_typer_get_dregion(struct MPU_Type* p) { return (p->TYPER & MPU_TYPER_DREGION) >> 8; }

// MPU->CTRL MPU control register
enum {
	MPU_CTRL_PRIVDEFENA = 1UL << 2, // Enable priviliged software access to default memory map
	MPU_CTRL_HFNMIENA   = 1UL << 1, // Enables the operation of MPU during hard fault
	MPU_CTRL_ENABLE     = 1UL << 0, // Enables the MPU
};

// MPU->RBAR MPU region base address register
enum {
	MPU_RBAR_ADDR   = ((1UL << 27) - 1) << 5, // Region base address field
	MPU_RBAR_VALID  = 1UL << 4,               // MPU region number valid
	MPU_RBAR_REGION = ((1UL << 4) - 1) << 0,  // MPU region field
};
inline void mpu_rbar_set_addr(struct MPU_Type* p, uint32_t val) { p->RBAR = (p->RBAR & ~MPU_RBAR_ADDR) | ((val << 5) & MPU_RBAR_ADDR); }
inline void mpu_rbar_set_region(struct MPU_Type* p, uint32_t val) {
	p->RBAR = (p->RBAR & ~MPU_RBAR_REGION) | ((val << 0) & MPU_RBAR_REGION);
}
inline uint32_t mpu_rbar_get_addr(struct MPU_Type* p) { return (p->RBAR & MPU_RBAR_ADDR) >> 5; }
inline uint32_t mpu_rbar_get_region(struct MPU_Type* p) { return (p->RBAR & MPU_RBAR_REGION) >> 0; }

// MPU->RASR MPU region attribute and size register
enum {
	MPU_RASR_XN     = 1UL << 28,              // Instruction access disable bit
	MPU_RASR_AP     = ((1UL << 3) - 1) << 24, // Access permission
	MPU_RASR_TEX    = ((1UL << 3) - 1) << 19, // memory attribute
	MPU_RASR_S      = 1UL << 18,              // Shareable memory attribute
	MPU_RASR_C      = 1UL << 17,              // memory attribute
	MPU_RASR_B      = 1UL << 16,              // memory attribute
	MPU_RASR_SRD    = ((1UL << 8) - 1) << 8,  // Subregion disable bits
	MPU_RASR_SIZE   = ((1UL << 5) - 1) << 1,  // Size of the MPU protection region
	MPU_RASR_ENABLE = 1UL << 0,               // Region enable bit.
};
inline void     mpu_rasr_set_ap(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_AP) | ((val << 24) & MPU_RASR_AP); }
inline void     mpu_rasr_set_tex(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_TEX) | ((val << 19) & MPU_RASR_TEX); }
inline void     mpu_rasr_set_srd(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_SRD) | ((val << 8) & MPU_RASR_SRD); }
inline void     mpu_rasr_set_size(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_SIZE) | ((val << 1) & MPU_RASR_SIZE); }
inline uint32_t mpu_rasr_get_ap(struct MPU_Type* p) { return (p->RASR & MPU_RASR_AP) >> 24; }
inline uint32_t mpu_rasr_get_tex(struct MPU_Type* p) { return (p->RASR & MPU_RASR_TEX) >> 19; }
inline uint32_t mpu_rasr_get_srd(struct MPU_Type* p) { return (p->RASR & MPU_RASR_SRD) >> 8; }
inline uint32_t mpu_rasr_get_size(struct MPU_Type* p) { return (p->RASR & MPU_RASR_SIZE) >> 1; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER0;           // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1;           // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2;           // @8 Interrupt Set-Enable Register
	__IO uint32_t ISER3;           // @12 Interrupt Set-Enable Register
	uint8_t       RESERVED0[112];  // @16
	__IO uint32_t ICER0;           // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1;           // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2;           // @136 Interrupt Clear-Enable Register
	__IO uint32_t ICER3;           // @140 Interrupt Clear-Enable Register
	uint8_t       RESERVED1[112];  // @144
	__IO uint32_t ISPR0;           // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1;           // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2;           // @264 Interrupt Set-Pending Register
	__IO uint32_t ISPR3;           // @268 Interrupt Set-Pending Register
	uint8_t       RESERVED2[112];  // @272
	__IO uint32_t ICPR0;           // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1;           // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2;           // @392 Interrupt Clear-Pending Register
	__IO uint32_t ICPR3;           // @396 Interrupt Clear-Pending Register
	uint8_t       RESERVED3[112];  // @400
	__I uint32_t  IABR0;           // @512 Interrupt Active Bit Register
	__I uint32_t  IABR1;           // @516 Interrupt Active Bit Register
	__I uint32_t  IABR2;           // @520 Interrupt Active Bit Register
	__I uint32_t  IABR3;           // @524 Interrupt Active Bit Register
	uint8_t       RESERVED4[240];  // @528
	__IO uint32_t IPR0;            // @768 Interrupt Priority Register
	__IO uint32_t IPR1;            // @772 Interrupt Priority Register
	__IO uint32_t IPR2;            // @776 Interrupt Priority Register
	__IO uint32_t IPR3;            // @780 Interrupt Priority Register
	__IO uint32_t IPR4;            // @784 Interrupt Priority Register
	__IO uint32_t IPR5;            // @788 Interrupt Priority Register
	__IO uint32_t IPR6;            // @792 Interrupt Priority Register
	__IO uint32_t IPR7;            // @796 Interrupt Priority Register
	__IO uint32_t IPR8;            // @800 Interrupt Priority Register
	__IO uint32_t IPR9;            // @804 Interrupt Priority Register
	__IO uint32_t IPR10;           // @808 Interrupt Priority Register
	__IO uint32_t IPR11;           // @812 Interrupt Priority Register
	__IO uint32_t IPR12;           // @816 Interrupt Priority Register
	__IO uint32_t IPR13;           // @820 Interrupt Priority Register
	__IO uint32_t IPR14;           // @824 Interrupt Priority Register
	__IO uint32_t IPR15;           // @828 Interrupt Priority Register
	__IO uint32_t IPR16;           // @832 Interrupt Priority Register
	__IO uint32_t IPR17;           // @836 Interrupt Priority Register
	__IO uint32_t IPR18;           // @840 Interrupt Priority Register
	__IO uint32_t IPR19;           // @844 Interrupt Priority Register
	__IO uint32_t IPR20;           // @848 Interrupt Priority Register
	__IO uint32_t IPR21;           // @852 Interrupt Priority Register
	__IO uint32_t IPR22;           // @856 Interrupt Priority Register
	__IO uint32_t IPR23;           // @860 Interrupt Priority Register
	__IO uint32_t IPR24;           // @864 Interrupt Priority Register
	__IO uint32_t IPR25;           // @868 Interrupt Priority Register
	uint8_t       RESERVED5[2712]; // @872
	__IO uint16_t STIR;            // @3584 Software trigger interrupt register
};

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr0_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N3) | ((val << 24) & NVIC_IPR0_IPR_N3);
}
inline void nvic_ipr0_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N2) | ((val << 16) & NVIC_IPR0_IPR_N2);
}
inline void nvic_ipr0_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N1) | ((val << 8) & NVIC_IPR0_IPR_N1);
}
inline void nvic_ipr0_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N0) | ((val << 0) & NVIC_IPR0_IPR_N0);
}
inline uint32_t nvic_ipr0_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N3) >> 24; }
inline uint32_t nvic_ipr0_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N2) >> 16; }
inline uint32_t nvic_ipr0_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N1) >> 8; }
inline uint32_t nvic_ipr0_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N0) >> 0; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr1_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N3) | ((val << 24) & NVIC_IPR1_IPR_N3);
}
inline void nvic_ipr1_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N2) | ((val << 16) & NVIC_IPR1_IPR_N2);
}
inline void nvic_ipr1_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N1) | ((val << 8) & NVIC_IPR1_IPR_N1);
}
inline void nvic_ipr1_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N0) | ((val << 0) & NVIC_IPR1_IPR_N0);
}
inline uint32_t nvic_ipr1_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N3) >> 24; }
inline uint32_t nvic_ipr1_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N2) >> 16; }
inline uint32_t nvic_ipr1_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N1) >> 8; }
inline uint32_t nvic_ipr1_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N0) >> 0; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr2_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N3) | ((val << 24) & NVIC_IPR2_IPR_N3);
}
inline void nvic_ipr2_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N2) | ((val << 16) & NVIC_IPR2_IPR_N2);
}
inline void nvic_ipr2_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N1) | ((val << 8) & NVIC_IPR2_IPR_N1);
}
inline void nvic_ipr2_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N0) | ((val << 0) & NVIC_IPR2_IPR_N0);
}
inline uint32_t nvic_ipr2_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N3) >> 24; }
inline uint32_t nvic_ipr2_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N2) >> 16; }
inline uint32_t nvic_ipr2_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N1) >> 8; }
inline uint32_t nvic_ipr2_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N0) >> 0; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr3_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N3) | ((val << 24) & NVIC_IPR3_IPR_N3);
}
inline void nvic_ipr3_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N2) | ((val << 16) & NVIC_IPR3_IPR_N2);
}
inline void nvic_ipr3_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N1) | ((val << 8) & NVIC_IPR3_IPR_N1);
}
inline void nvic_ipr3_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N0) | ((val << 0) & NVIC_IPR3_IPR_N0);
}
inline uint32_t nvic_ipr3_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N3) >> 24; }
inline uint32_t nvic_ipr3_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N2) >> 16; }
inline uint32_t nvic_ipr3_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N1) >> 8; }
inline uint32_t nvic_ipr3_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N0) >> 0; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr4_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N3) | ((val << 24) & NVIC_IPR4_IPR_N3);
}
inline void nvic_ipr4_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N2) | ((val << 16) & NVIC_IPR4_IPR_N2);
}
inline void nvic_ipr4_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N1) | ((val << 8) & NVIC_IPR4_IPR_N1);
}
inline void nvic_ipr4_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N0) | ((val << 0) & NVIC_IPR4_IPR_N0);
}
inline uint32_t nvic_ipr4_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N3) >> 24; }
inline uint32_t nvic_ipr4_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N2) >> 16; }
inline uint32_t nvic_ipr4_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N1) >> 8; }
inline uint32_t nvic_ipr4_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N0) >> 0; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr5_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N3) | ((val << 24) & NVIC_IPR5_IPR_N3);
}
inline void nvic_ipr5_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N2) | ((val << 16) & NVIC_IPR5_IPR_N2);
}
inline void nvic_ipr5_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N1) | ((val << 8) & NVIC_IPR5_IPR_N1);
}
inline void nvic_ipr5_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N0) | ((val << 0) & NVIC_IPR5_IPR_N0);
}
inline uint32_t nvic_ipr5_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N3) >> 24; }
inline uint32_t nvic_ipr5_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N2) >> 16; }
inline uint32_t nvic_ipr5_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N1) >> 8; }
inline uint32_t nvic_ipr5_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N0) >> 0; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr6_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N3) | ((val << 24) & NVIC_IPR6_IPR_N3);
}
inline void nvic_ipr6_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N2) | ((val << 16) & NVIC_IPR6_IPR_N2);
}
inline void nvic_ipr6_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N1) | ((val << 8) & NVIC_IPR6_IPR_N1);
}
inline void nvic_ipr6_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N0) | ((val << 0) & NVIC_IPR6_IPR_N0);
}
inline uint32_t nvic_ipr6_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N3) >> 24; }
inline uint32_t nvic_ipr6_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N2) >> 16; }
inline uint32_t nvic_ipr6_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N1) >> 8; }
inline uint32_t nvic_ipr6_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N0) >> 0; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr7_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N3) | ((val << 24) & NVIC_IPR7_IPR_N3);
}
inline void nvic_ipr7_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N2) | ((val << 16) & NVIC_IPR7_IPR_N2);
}
inline void nvic_ipr7_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N1) | ((val << 8) & NVIC_IPR7_IPR_N1);
}
inline void nvic_ipr7_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N0) | ((val << 0) & NVIC_IPR7_IPR_N0);
}
inline uint32_t nvic_ipr7_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N3) >> 24; }
inline uint32_t nvic_ipr7_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N2) >> 16; }
inline uint32_t nvic_ipr7_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N1) >> 8; }
inline uint32_t nvic_ipr7_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N0) >> 0; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr8_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N3) | ((val << 24) & NVIC_IPR8_IPR_N3);
}
inline void nvic_ipr8_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N2) | ((val << 16) & NVIC_IPR8_IPR_N2);
}
inline void nvic_ipr8_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N1) | ((val << 8) & NVIC_IPR8_IPR_N1);
}
inline void nvic_ipr8_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N0) | ((val << 0) & NVIC_IPR8_IPR_N0);
}
inline uint32_t nvic_ipr8_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N3) >> 24; }
inline uint32_t nvic_ipr8_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N2) >> 16; }
inline uint32_t nvic_ipr8_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N1) >> 8; }
inline uint32_t nvic_ipr8_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N0) >> 0; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr9_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N3) | ((val << 24) & NVIC_IPR9_IPR_N3);
}
inline void nvic_ipr9_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N2) | ((val << 16) & NVIC_IPR9_IPR_N2);
}
inline void nvic_ipr9_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N1) | ((val << 8) & NVIC_IPR9_IPR_N1);
}
inline void nvic_ipr9_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N0) | ((val << 0) & NVIC_IPR9_IPR_N0);
}
inline uint32_t nvic_ipr9_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N3) >> 24; }
inline uint32_t nvic_ipr9_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N2) >> 16; }
inline uint32_t nvic_ipr9_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N1) >> 8; }
inline uint32_t nvic_ipr9_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N0) >> 0; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr10_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N3) | ((val << 24) & NVIC_IPR10_IPR_N3);
}
inline void nvic_ipr10_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N2) | ((val << 16) & NVIC_IPR10_IPR_N2);
}
inline void nvic_ipr10_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N1) | ((val << 8) & NVIC_IPR10_IPR_N1);
}
inline void nvic_ipr10_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N0) | ((val << 0) & NVIC_IPR10_IPR_N0);
}
inline uint32_t nvic_ipr10_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N3) >> 24; }
inline uint32_t nvic_ipr10_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N2) >> 16; }
inline uint32_t nvic_ipr10_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N1) >> 8; }
inline uint32_t nvic_ipr10_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N0) >> 0; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr11_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N3) | ((val << 24) & NVIC_IPR11_IPR_N3);
}
inline void nvic_ipr11_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N2) | ((val << 16) & NVIC_IPR11_IPR_N2);
}
inline void nvic_ipr11_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N1) | ((val << 8) & NVIC_IPR11_IPR_N1);
}
inline void nvic_ipr11_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N0) | ((val << 0) & NVIC_IPR11_IPR_N0);
}
inline uint32_t nvic_ipr11_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N3) >> 24; }
inline uint32_t nvic_ipr11_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N2) >> 16; }
inline uint32_t nvic_ipr11_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N1) >> 8; }
inline uint32_t nvic_ipr11_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N0) >> 0; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr12_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N3) | ((val << 24) & NVIC_IPR12_IPR_N3);
}
inline void nvic_ipr12_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N2) | ((val << 16) & NVIC_IPR12_IPR_N2);
}
inline void nvic_ipr12_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N1) | ((val << 8) & NVIC_IPR12_IPR_N1);
}
inline void nvic_ipr12_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N0) | ((val << 0) & NVIC_IPR12_IPR_N0);
}
inline uint32_t nvic_ipr12_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N3) >> 24; }
inline uint32_t nvic_ipr12_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N2) >> 16; }
inline uint32_t nvic_ipr12_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N1) >> 8; }
inline uint32_t nvic_ipr12_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N0) >> 0; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr13_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N3) | ((val << 24) & NVIC_IPR13_IPR_N3);
}
inline void nvic_ipr13_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N2) | ((val << 16) & NVIC_IPR13_IPR_N2);
}
inline void nvic_ipr13_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N1) | ((val << 8) & NVIC_IPR13_IPR_N1);
}
inline void nvic_ipr13_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N0) | ((val << 0) & NVIC_IPR13_IPR_N0);
}
inline uint32_t nvic_ipr13_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N3) >> 24; }
inline uint32_t nvic_ipr13_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N2) >> 16; }
inline uint32_t nvic_ipr13_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N1) >> 8; }
inline uint32_t nvic_ipr13_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N0) >> 0; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr14_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N3) | ((val << 24) & NVIC_IPR14_IPR_N3);
}
inline void nvic_ipr14_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N2) | ((val << 16) & NVIC_IPR14_IPR_N2);
}
inline void nvic_ipr14_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N1) | ((val << 8) & NVIC_IPR14_IPR_N1);
}
inline void nvic_ipr14_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N0) | ((val << 0) & NVIC_IPR14_IPR_N0);
}
inline uint32_t nvic_ipr14_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N3) >> 24; }
inline uint32_t nvic_ipr14_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N2) >> 16; }
inline uint32_t nvic_ipr14_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N1) >> 8; }
inline uint32_t nvic_ipr14_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N0) >> 0; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr15_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N3) | ((val << 24) & NVIC_IPR15_IPR_N3);
}
inline void nvic_ipr15_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N2) | ((val << 16) & NVIC_IPR15_IPR_N2);
}
inline void nvic_ipr15_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N1) | ((val << 8) & NVIC_IPR15_IPR_N1);
}
inline void nvic_ipr15_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N0) | ((val << 0) & NVIC_IPR15_IPR_N0);
}
inline uint32_t nvic_ipr15_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N3) >> 24; }
inline uint32_t nvic_ipr15_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N2) >> 16; }
inline uint32_t nvic_ipr15_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N1) >> 8; }
inline uint32_t nvic_ipr15_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N0) >> 0; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr16_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N3) | ((val << 24) & NVIC_IPR16_IPR_N3);
}
inline void nvic_ipr16_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N2) | ((val << 16) & NVIC_IPR16_IPR_N2);
}
inline void nvic_ipr16_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N1) | ((val << 8) & NVIC_IPR16_IPR_N1);
}
inline void nvic_ipr16_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N0) | ((val << 0) & NVIC_IPR16_IPR_N0);
}
inline uint32_t nvic_ipr16_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N3) >> 24; }
inline uint32_t nvic_ipr16_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N2) >> 16; }
inline uint32_t nvic_ipr16_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N1) >> 8; }
inline uint32_t nvic_ipr16_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N0) >> 0; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr17_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N3) | ((val << 24) & NVIC_IPR17_IPR_N3);
}
inline void nvic_ipr17_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N2) | ((val << 16) & NVIC_IPR17_IPR_N2);
}
inline void nvic_ipr17_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N1) | ((val << 8) & NVIC_IPR17_IPR_N1);
}
inline void nvic_ipr17_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N0) | ((val << 0) & NVIC_IPR17_IPR_N0);
}
inline uint32_t nvic_ipr17_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N3) >> 24; }
inline uint32_t nvic_ipr17_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N2) >> 16; }
inline uint32_t nvic_ipr17_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N1) >> 8; }
inline uint32_t nvic_ipr17_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N0) >> 0; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr18_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N3) | ((val << 24) & NVIC_IPR18_IPR_N3);
}
inline void nvic_ipr18_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N2) | ((val << 16) & NVIC_IPR18_IPR_N2);
}
inline void nvic_ipr18_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N1) | ((val << 8) & NVIC_IPR18_IPR_N1);
}
inline void nvic_ipr18_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N0) | ((val << 0) & NVIC_IPR18_IPR_N0);
}
inline uint32_t nvic_ipr18_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N3) >> 24; }
inline uint32_t nvic_ipr18_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N2) >> 16; }
inline uint32_t nvic_ipr18_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N1) >> 8; }
inline uint32_t nvic_ipr18_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N0) >> 0; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr19_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N3) | ((val << 24) & NVIC_IPR19_IPR_N3);
}
inline void nvic_ipr19_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N2) | ((val << 16) & NVIC_IPR19_IPR_N2);
}
inline void nvic_ipr19_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N1) | ((val << 8) & NVIC_IPR19_IPR_N1);
}
inline void nvic_ipr19_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N0) | ((val << 0) & NVIC_IPR19_IPR_N0);
}
inline uint32_t nvic_ipr19_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N3) >> 24; }
inline uint32_t nvic_ipr19_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N2) >> 16; }
inline uint32_t nvic_ipr19_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N1) >> 8; }
inline uint32_t nvic_ipr19_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N0) >> 0; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL << 8) - 1) << 24, // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL << 8) - 1) << 16, // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL << 8) - 1) << 8,  // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL << 8) - 1) << 0,  // IPR_N0
};
inline void nvic_ipr20_set_ipr_n3(struct NVIC_Type* p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N3) | ((val << 24) & NVIC_IPR20_IPR_N3);
}
inline void nvic_ipr20_set_ipr_n2(struct NVIC_Type* p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N2) | ((val << 16) & NVIC_IPR20_IPR_N2);
}
inline void nvic_ipr20_set_ipr_n1(struct NVIC_Type* p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N1) | ((val << 8) & NVIC_IPR20_IPR_N1);
}
inline void nvic_ipr20_set_ipr_n0(struct NVIC_Type* p, uint32_t val) {
	p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N0) | ((val << 0) & NVIC_IPR20_IPR_N0);
}
inline uint32_t nvic_ipr20_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N3) >> 24; }
inline uint32_t nvic_ipr20_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N2) >> 16; }
inline uint32_t nvic_ipr20_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N1) >> 8; }
inline uint32_t nvic_ipr20_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N0) >> 0; }

// NVIC->STIR Software trigger interrupt register
enum {
	NVIC_STIR_INTID = ((1UL << 9) - 1) << 0, // Software generated interrupt ID
};
inline void nvic_stir_set_intid(struct NVIC_Type* p, uint32_t val) {
	p->STIR = (p->STIR & ~NVIC_STIR_INTID) | ((val << 0) & NVIC_STIR_INTID);
}
inline uint32_t nvic_stir_get_intid(struct NVIC_Type* p) { return (p->STIR & NVIC_STIR_INTID) >> 0; }

/* Operational amplifiers */
struct OPAMP_Type {
	__IO uint32_t OPAMP1_CSR;    // @0 OPAMP1 control/status register
	__IO uint32_t OPAMP2_CSR;    // @4 OPAMP2 control/status register
	__IO uint32_t OPAMP3_CSR;    // @8 OPAMP3 control/status register
	uint8_t       RESERVED0[12]; // @12
	__IO uint32_t OPAMP1_TCMR;   // @24 OPAMP1 control/status register
	__IO uint32_t OPAMP2_TCMR;   // @28 OPAMP2 control/status register
	__IO uint32_t OPAMP3_TCMR;   // @32 OPAMP3 control/status register
};

// OPAMP->OPAMP1_CSR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_CSR_LOCK        = 1UL << 31,              // LOCK
	OPAMP_OPAMP1_CSR_CALOUT      = 1UL << 30,              // CALOUT
	OPAMP_OPAMP1_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP1_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP1_CSR_PGA_GAIN    = ((1UL << 5) - 1) << 14, // PGA_GAIN
	OPAMP_OPAMP1_CSR_CALSEL      = ((1UL << 2) - 1) << 12, // CALSEL
	OPAMP_OPAMP1_CSR_CALON       = 1UL << 11,              // CALON
	OPAMP_OPAMP1_CSR_OPAINTOEN   = 1UL << 8,               // OPAINTOEN
	OPAMP_OPAMP1_CSR_OPAHSM      = 1UL << 7,               // OPAHSM
	OPAMP_OPAMP1_CSR_VM_SEL      = ((1UL << 2) - 1) << 5,  // VM_SEL
	OPAMP_OPAMP1_CSR_USERTRIM    = 1UL << 4,               // USERTRIM
	OPAMP_OPAMP1_CSR_VP_SEL      = ((1UL << 2) - 1) << 2,  // VP_SEL
	OPAMP_OPAMP1_CSR_FORCE_VP    = 1UL << 1,               // FORCE_VP
	OPAMP_OPAMP1_CSR_OPAEN       = 1UL << 0,               // Operational amplifier Enable
};
inline void opamp_opamp1_csr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP1_CSR_TRIMOFFSETN);
}
inline void opamp_opamp1_csr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP1_CSR_TRIMOFFSETP);
}
inline void opamp_opamp1_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP1_CSR_PGA_GAIN);
}
inline void opamp_opamp1_csr_set_calsel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP1_CSR_CALSEL);
}
inline void opamp_opamp1_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP1_CSR_VM_SEL);
}
inline void opamp_opamp1_csr_set_vp_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP1_CSR_VP_SEL);
}
inline uint32_t opamp_opamp1_csr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_TRIMOFFSETN) >> 24; }
inline uint32_t opamp_opamp1_csr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_TRIMOFFSETP) >> 19; }
inline uint32_t opamp_opamp1_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp1_csr_get_calsel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp1_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp1_csr_get_vp_sel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP2_CSR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_CSR_LOCK        = 1UL << 31,              // LOCK
	OPAMP_OPAMP2_CSR_CALOUT      = 1UL << 30,              // CALOUT
	OPAMP_OPAMP2_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP2_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP2_CSR_PGA_GAIN    = ((1UL << 5) - 1) << 14, // PGA_GAIN
	OPAMP_OPAMP2_CSR_CALSEL      = ((1UL << 2) - 1) << 12, // CALSEL
	OPAMP_OPAMP2_CSR_CALON       = 1UL << 11,              // CALON
	OPAMP_OPAMP2_CSR_OPAINTOEN   = 1UL << 8,               // OPAINTOEN
	OPAMP_OPAMP2_CSR_OPAHSM      = 1UL << 7,               // OPAHSM
	OPAMP_OPAMP2_CSR_VM_SEL      = ((1UL << 2) - 1) << 5,  // VM_SEL
	OPAMP_OPAMP2_CSR_USERTRIM    = 1UL << 4,               // USERTRIM
	OPAMP_OPAMP2_CSR_VP_SEL      = ((1UL << 2) - 1) << 2,  // VP_SEL
	OPAMP_OPAMP2_CSR_FORCE_VP    = 1UL << 1,               // FORCE_VP
	OPAMP_OPAMP2_CSR_OPAEN       = 1UL << 0,               // Operational amplifier Enable
};
inline void opamp_opamp2_csr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP2_CSR_TRIMOFFSETN);
}
inline void opamp_opamp2_csr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP2_CSR_TRIMOFFSETP);
}
inline void opamp_opamp2_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP2_CSR_PGA_GAIN);
}
inline void opamp_opamp2_csr_set_calsel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP2_CSR_CALSEL);
}
inline void opamp_opamp2_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP2_CSR_VM_SEL);
}
inline void opamp_opamp2_csr_set_vp_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP2_CSR_VP_SEL);
}
inline uint32_t opamp_opamp2_csr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_TRIMOFFSETN) >> 24; }
inline uint32_t opamp_opamp2_csr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_TRIMOFFSETP) >> 19; }
inline uint32_t opamp_opamp2_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp2_csr_get_calsel(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp2_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp2_csr_get_vp_sel(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP3_CSR OPAMP3 control/status register
enum {
	OPAMP_OPAMP3_CSR_LOCK        = 1UL << 31,              // LOCK
	OPAMP_OPAMP3_CSR_CALOUT      = 1UL << 30,              // CALOUT
	OPAMP_OPAMP3_CSR_TRIMOFFSETN = ((1UL << 5) - 1) << 24, // TRIMOFFSETN
	OPAMP_OPAMP3_CSR_TRIMOFFSETP = ((1UL << 5) - 1) << 19, // TRIMOFFSETP
	OPAMP_OPAMP3_CSR_PGA_GAIN    = ((1UL << 5) - 1) << 14, // PGA_GAIN
	OPAMP_OPAMP3_CSR_CALSEL      = ((1UL << 2) - 1) << 12, // CALSEL
	OPAMP_OPAMP3_CSR_CALON       = 1UL << 11,              // CALON
	OPAMP_OPAMP3_CSR_OPAINTOEN   = 1UL << 8,               // OPAINTOEN
	OPAMP_OPAMP3_CSR_OPAHSM      = 1UL << 7,               // OPAHSM
	OPAMP_OPAMP3_CSR_VM_SEL      = ((1UL << 2) - 1) << 5,  // VM_SEL
	OPAMP_OPAMP3_CSR_USERTRIM    = 1UL << 4,               // USERTRIM
	OPAMP_OPAMP3_CSR_VP_SEL      = ((1UL << 2) - 1) << 2,  // VP_SEL
	OPAMP_OPAMP3_CSR_FORCE_VP    = 1UL << 1,               // FORCE_VP
	OPAMP_OPAMP3_CSR_OPAEN       = 1UL << 0,               // Operational amplifier Enable
};
inline void opamp_opamp3_csr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_TRIMOFFSETN) | ((val << 24) & OPAMP_OPAMP3_CSR_TRIMOFFSETN);
}
inline void opamp_opamp3_csr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_TRIMOFFSETP) | ((val << 19) & OPAMP_OPAMP3_CSR_TRIMOFFSETP);
}
inline void opamp_opamp3_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_PGA_GAIN) | ((val << 14) & OPAMP_OPAMP3_CSR_PGA_GAIN);
}
inline void opamp_opamp3_csr_set_calsel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_CALSEL) | ((val << 12) & OPAMP_OPAMP3_CSR_CALSEL);
}
inline void opamp_opamp3_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_VM_SEL) | ((val << 5) & OPAMP_OPAMP3_CSR_VM_SEL);
}
inline void opamp_opamp3_csr_set_vp_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_CSR = (p->OPAMP3_CSR & ~OPAMP_OPAMP3_CSR_VP_SEL) | ((val << 2) & OPAMP_OPAMP3_CSR_VP_SEL);
}
inline uint32_t opamp_opamp3_csr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_TRIMOFFSETN) >> 24; }
inline uint32_t opamp_opamp3_csr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_TRIMOFFSETP) >> 19; }
inline uint32_t opamp_opamp3_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_PGA_GAIN) >> 14; }
inline uint32_t opamp_opamp3_csr_get_calsel(struct OPAMP_Type* p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_CALSEL) >> 12; }
inline uint32_t opamp_opamp3_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_VM_SEL) >> 5; }
inline uint32_t opamp_opamp3_csr_get_vp_sel(struct OPAMP_Type* p) { return (p->OPAMP3_CSR & OPAMP_OPAMP3_CSR_VP_SEL) >> 2; }

// OPAMP->OPAMP1_TCMR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_TCMR_LOCK     = 1UL << 31,             // LOCK
	OPAMP_OPAMP1_TCMR_T20CM_EN = 1UL << 5,              // T20CM_EN
	OPAMP_OPAMP1_TCMR_T8CM_EN  = 1UL << 4,              // T8CM_EN
	OPAMP_OPAMP1_TCMR_T1CM_EN  = 1UL << 3,              // T1CM_EN
	OPAMP_OPAMP1_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1, // VPS_SEL
	OPAMP_OPAMP1_TCMR_VMS_SEL  = 1UL << 0,              // VMS_SEL
};
inline void opamp_opamp1_tcmr_set_vps_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP1_TCMR = (p->OPAMP1_TCMR & ~OPAMP_OPAMP1_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP1_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp1_tcmr_get_vps_sel(struct OPAMP_Type* p) { return (p->OPAMP1_TCMR & OPAMP_OPAMP1_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP2_TCMR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_TCMR_LOCK     = 1UL << 31,             // LOCK
	OPAMP_OPAMP2_TCMR_T20CM_EN = 1UL << 5,              // T20CM_EN
	OPAMP_OPAMP2_TCMR_T8CM_EN  = 1UL << 4,              // T8CM_EN
	OPAMP_OPAMP2_TCMR_T1CM_EN  = 1UL << 3,              // T1CM_EN
	OPAMP_OPAMP2_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1, // VPS_SEL
	OPAMP_OPAMP2_TCMR_VMS_SEL  = 1UL << 0,              // VMS_SEL
};
inline void opamp_opamp2_tcmr_set_vps_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP2_TCMR = (p->OPAMP2_TCMR & ~OPAMP_OPAMP2_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP2_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp2_tcmr_get_vps_sel(struct OPAMP_Type* p) { return (p->OPAMP2_TCMR & OPAMP_OPAMP2_TCMR_VPS_SEL) >> 1; }

// OPAMP->OPAMP3_TCMR OPAMP3 control/status register
enum {
	OPAMP_OPAMP3_TCMR_LOCK     = 1UL << 31,             // LOCK
	OPAMP_OPAMP3_TCMR_T20CM_EN = 1UL << 5,              // T20CM_EN
	OPAMP_OPAMP3_TCMR_T8CM_EN  = 1UL << 4,              // T8CM_EN
	OPAMP_OPAMP3_TCMR_T1CM_EN  = 1UL << 3,              // T1CM_EN
	OPAMP_OPAMP3_TCMR_VPS_SEL  = ((1UL << 2) - 1) << 1, // VPS_SEL
	OPAMP_OPAMP3_TCMR_VMS_SEL  = 1UL << 0,              // VMS_SEL
};
inline void opamp_opamp3_tcmr_set_vps_sel(struct OPAMP_Type* p, uint32_t val) {
	p->OPAMP3_TCMR = (p->OPAMP3_TCMR & ~OPAMP_OPAMP3_TCMR_VPS_SEL) | ((val << 1) & OPAMP_OPAMP3_TCMR_VPS_SEL);
}
inline uint32_t opamp_opamp3_tcmr_get_vps_sel(struct OPAMP_Type* p) { return (p->OPAMP3_TCMR & OPAMP_OPAMP3_TCMR_VPS_SEL) >> 1; }

/* Power control */
struct PWR_Type {
	__IO uint16_t CR1;            // @0 Power control register 1
	uint8_t       RESERVED0[2];   // @2
	__IO uint8_t  CR2;            // @4 Power control register 2
	uint8_t       RESERVED1[3];   // @5
	__IO uint16_t CR3;            // @8 Power control register 3
	uint8_t       RESERVED2[2];   // @10
	__IO uint16_t CR4;            // @12 Power control register 4
	uint8_t       RESERVED3[2];   // @14
	__I uint16_t  SR1;            // @16 Power status register 1
	uint8_t       RESERVED4[2];   // @18
	__I uint16_t  SR2;            // @20 Power status register 2
	uint8_t       RESERVED5[2];   // @22
	__O uint16_t  SCR;            // @24 Power status clear register
	uint8_t       RESERVED6[6];   // @26
	__IO uint16_t PUCRA;          // @32 Power Port A pull-up control register
	uint8_t       RESERVED7[2];   // @34
	__IO uint16_t PDCRA;          // @36 Power Port A pull-down control register
	uint8_t       RESERVED8[2];   // @38
	__IO uint16_t PUCRB;          // @40 Power Port B pull-up control register
	uint8_t       RESERVED9[2];   // @42
	__IO uint16_t PDCRB;          // @44 Power Port B pull-down control register
	uint8_t       RESERVED10[2];  // @46
	__IO uint16_t PUCRC;          // @48 Power Port C pull-up control register
	uint8_t       RESERVED11[2];  // @50
	__IO uint16_t PDCRC;          // @52 Power Port C pull-down control register
	uint8_t       RESERVED12[2];  // @54
	__IO uint16_t PUCRD;          // @56 Power Port D pull-up control register
	uint8_t       RESERVED13[2];  // @58
	__IO uint16_t PDCRD;          // @60 Power Port D pull-down control register
	uint8_t       RESERVED14[2];  // @62
	__IO uint16_t PUCRE;          // @64 Power Port E pull-up control register
	uint8_t       RESERVED15[2];  // @66
	__IO uint16_t PDCRE;          // @68 Power Port E pull-down control register
	uint8_t       RESERVED16[2];  // @70
	__IO uint16_t PUCRF;          // @72 Power Port F pull-up control register
	uint8_t       RESERVED17[2];  // @74
	__IO uint16_t PDCRF;          // @76 Power Port F pull-down control register
	uint8_t       RESERVED18[2];  // @78
	__IO uint16_t PUCRG;          // @80 Power Port G pull-up control register
	uint8_t       RESERVED19[2];  // @82
	__IO uint16_t PDCRG;          // @84 Power Port G pull-down control register
	uint8_t       RESERVED20[42]; // @86
	__IO uint8_t  CR5;            // @128 Power control register 5
};

// PWR->CR1 Power control register 1
enum {
	PWR_CR1_LPR  = 1UL << 14,             // Low-power run
	PWR_CR1_VOS  = ((1UL << 2) - 1) << 9, // Voltage scaling range selection
	PWR_CR1_DBP  = 1UL << 8,              // Disable backup domain write protection
	PWR_CR1_LPMS = ((1UL << 3) - 1) << 0, // Low-power mode selection
};
inline void     pwr_cr1_set_vos(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_VOS) | ((val << 9) & PWR_CR1_VOS); }
inline void     pwr_cr1_set_lpms(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_LPMS) | ((val << 0) & PWR_CR1_LPMS); }
inline uint32_t pwr_cr1_get_vos(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_VOS) >> 9; }
inline uint32_t pwr_cr1_get_lpms(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_LPMS) >> 0; }

// PWR->CR2 Power control register 2
enum {
	PWR_CR2_PVMEN4 = 1UL << 7,              // Peripheral voltage monitoring 4 enable: VDDA vs. OPAMP/DAC min voltage
	PWR_CR2_PVMEN3 = 1UL << 6,              // Peripheral voltage monitoring 3 enable: VDDA vs. ADC min voltage 1.62V
	PWR_CR2_PVMEN2 = 1UL << 5,              // Peripheral voltage monitoring 2 enable: VDDA vs. Fast DAC min voltage
	PWR_CR2_PVMEN1 = 1UL << 4,              // Peripheral voltage monitoring 1 enable: VDDA vs. COMP min voltage
	PWR_CR2_PLS    = ((1UL << 3) - 1) << 1, // Power voltage detector level selection
	PWR_CR2_PVDE   = 1UL << 0,              // Power voltage detector enable
};
inline void     pwr_cr2_set_pls(struct PWR_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~PWR_CR2_PLS) | ((val << 1) & PWR_CR2_PLS); }
inline uint32_t pwr_cr2_get_pls(struct PWR_Type* p) { return (p->CR2 & PWR_CR2_PLS) >> 1; }

// PWR->CR3 Power control register 3
enum {
	PWR_CR3_EIWUL       = 1UL << 15, // Enable external WakeUp line
	PWR_CR3_UCPD1_DBDIS = 1UL << 14, // DBDIS
	PWR_CR3_UCPD1_STDBY = 1UL << 13, // STDBY
	PWR_CR3_APC         = 1UL << 10, // Apply pull-up and pull-down configuration
	PWR_CR3_RRS         = 1UL << 8,  // SRAM2 retention in Standby mode
	PWR_CR3_EWUP5       = 1UL << 4,  // Enable Wakeup pin WKUP5
	PWR_CR3_EWUP4       = 1UL << 3,  // Enable Wakeup pin WKUP4
	PWR_CR3_EWUP3       = 1UL << 2,  // Enable Wakeup pin WKUP3
	PWR_CR3_EWUP2       = 1UL << 1,  // Enable Wakeup pin WKUP2
	PWR_CR3_EWUP1       = 1UL << 0,  // Enable Wakeup pin WKUP1
};

// PWR->CR4 Power control register 4
enum {
	PWR_CR4_VBRS = 1UL << 9, // VBAT battery charging resistor selection
	PWR_CR4_VBE  = 1UL << 8, // VBAT battery charging enable
	PWR_CR4_WP5  = 1UL << 4, // Wakeup pin WKUP5 polarity
	PWR_CR4_WP4  = 1UL << 3, // Wakeup pin WKUP4 polarity
	PWR_CR4_WP3  = 1UL << 2, // Wakeup pin WKUP3 polarity
	PWR_CR4_WP2  = 1UL << 1, // Wakeup pin WKUP2 polarity
	PWR_CR4_WP1  = 1UL << 0, // Wakeup pin WKUP1 polarity
};

// PWR->SR1 Power status register 1
enum {
	PWR_SR1_WUFI = 1UL << 15, // Wakeup flag internal
	PWR_SR1_SBF  = 1UL << 8,  // Standby flag
	PWR_SR1_WUF5 = 1UL << 4,  // Wakeup flag 5
	PWR_SR1_WUF4 = 1UL << 3,  // Wakeup flag 4
	PWR_SR1_WUF3 = 1UL << 2,  // Wakeup flag 3
	PWR_SR1_WUF2 = 1UL << 1,  // Wakeup flag 2
	PWR_SR1_WUF1 = 1UL << 0,  // Wakeup flag 1
};

// PWR->SR2 Power status register 2
enum {
	PWR_SR2_PVMO4  = 1UL << 15, // Peripheral voltage monitoring output: VDDA vs. 2.2 V
	PWR_SR2_PVMO3  = 1UL << 14, // Peripheral voltage monitoring output: VDDA vs. 1.62 V
	PWR_SR2_PVMO2  = 1UL << 13, // Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
	PWR_SR2_PVMO1  = 1UL << 12, // Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
	PWR_SR2_PVDO   = 1UL << 11, // Power voltage detector output
	PWR_SR2_VOSF   = 1UL << 10, // Voltage scaling flag
	PWR_SR2_REGLPF = 1UL << 9,  // Low-power regulator flag
	PWR_SR2_REGLPS = 1UL << 8,  // Low-power regulator started
};

// PWR->SCR Power status clear register
enum {
	PWR_SCR_CSBF  = 1UL << 8, // Clear standby flag
	PWR_SCR_CWUF5 = 1UL << 4, // Clear wakeup flag 5
	PWR_SCR_CWUF4 = 1UL << 3, // Clear wakeup flag 4
	PWR_SCR_CWUF3 = 1UL << 2, // Clear wakeup flag 3
	PWR_SCR_CWUF2 = 1UL << 1, // Clear wakeup flag 2
	PWR_SCR_CWUF1 = 1UL << 0, // Clear wakeup flag 1
};

// PWR->PUCRA Power Port A pull-up control register
enum {
	PWR_PUCRA_PU15 = 1UL << 15, // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU13 = 1UL << 13, // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU12 = 1UL << 12, // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU11 = 1UL << 11, // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU10 = 1UL << 10, // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU9  = 1UL << 9,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU8  = 1UL << 8,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU7  = 1UL << 7,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU6  = 1UL << 6,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU5  = 1UL << 5,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU4  = 1UL << 4,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU3  = 1UL << 3,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU2  = 1UL << 2,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU1  = 1UL << 1,  // Port A pull-up bit y (y=0..15)
	PWR_PUCRA_PU0  = 1UL << 0,  // Port A pull-up bit y (y=0..15)
};

// PWR->PDCRA Power Port A pull-down control register
enum {
	PWR_PDCRA_PD14 = 1UL << 14, // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD12 = 1UL << 12, // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD11 = 1UL << 11, // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD10 = 1UL << 10, // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD9  = 1UL << 9,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD8  = 1UL << 8,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD7  = 1UL << 7,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD6  = 1UL << 6,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD5  = 1UL << 5,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD4  = 1UL << 4,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD3  = 1UL << 3,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD2  = 1UL << 2,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD1  = 1UL << 1,  // Port A pull-down bit y (y=0..15)
	PWR_PDCRA_PD0  = 1UL << 0,  // Port A pull-down bit y (y=0..15)
};

// PWR->PDCRB Power Port B pull-down control register
enum {
	PWR_PDCRB_PD15 = 1UL << 15, // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD14 = 1UL << 14, // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD13 = 1UL << 13, // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD12 = 1UL << 12, // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD11 = 1UL << 11, // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD10 = 1UL << 10, // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD9  = 1UL << 9,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD8  = 1UL << 8,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD7  = 1UL << 7,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD6  = 1UL << 6,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD5  = 1UL << 5,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD3  = 1UL << 3,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD2  = 1UL << 2,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD1  = 1UL << 1,  // Port B pull-down bit y (y=0..15)
	PWR_PDCRB_PD0  = 1UL << 0,  // Port B pull-down bit y (y=0..15)
};

// PWR->PUCRG Power Port G pull-up control register
enum {
	PWR_PUCRG_PUX = ((1UL << 11) - 1) << 0, // Merged Port G pull-up bit y (y=0..15)
};
inline void pwr_pucrg_set_pux(struct PWR_Type* p, uint32_t val) { p->PUCRG = (p->PUCRG & ~PWR_PUCRG_PUX) | ((val << 0) & PWR_PUCRG_PUX); }
inline uint32_t pwr_pucrg_get_pux(struct PWR_Type* p) { return (p->PUCRG & PWR_PUCRG_PUX) >> 0; }

// PWR->PDCRG Power Port G pull-down control register
enum {
	PWR_PDCRG_PDX = ((1UL << 11) - 1) << 0, // Merged Port G pull-down bit y (y=0..15)
};
inline void pwr_pdcrg_set_pdx(struct PWR_Type* p, uint32_t val) { p->PDCRG = (p->PDCRG & ~PWR_PDCRG_PDX) | ((val << 0) & PWR_PDCRG_PDX); }
inline uint32_t pwr_pdcrg_get_pdx(struct PWR_Type* p) { return (p->PDCRG & PWR_PDCRG_PDX) >> 0; }

// PWR->CR5 Power control register 5
enum {
	PWR_CR5_R1MODE = 1UL << 0, // Main regular range 1 mode
};

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR;            // @0 Clock control register
	__IO uint32_t ICSCR;         // @4 Internal clock sources calibration register
	__IO uint32_t CFGR;          // @8 Clock configuration register
	__IO uint32_t PLLSYSCFGR;    // @12 PLL configuration register
	uint8_t       RESERVED0[8];  // @16
	__IO uint16_t CIER;          // @24 Clock interrupt enable register
	uint8_t       RESERVED1[2];  // @26
	__I uint16_t  CIFR;          // @28 Clock interrupt flag register
	uint8_t       RESERVED2[2];  // @30
	__O uint16_t  CICR;          // @32 Clock interrupt clear register
	uint8_t       RESERVED3[6];  // @34
	__IO uint16_t AHB1RSTR;      // @40 AHB1 peripheral reset register
	uint8_t       RESERVED4[2];  // @42
	__IO uint32_t AHB2RSTR;      // @44 AHB2 peripheral reset register
	__IO uint16_t AHB3RSTR;      // @48 AHB3 peripheral reset register
	uint8_t       RESERVED5[6];  // @50
	__IO uint32_t APB1RSTR1;     // @56 APB1 peripheral reset register 1
	__IO uint16_t APB1RSTR2;     // @60 APB1 peripheral reset register 2
	uint8_t       RESERVED6[2];  // @62
	__IO uint32_t APB2RSTR;      // @64 APB2 peripheral reset register
	uint8_t       RESERVED7[4];  // @68
	__IO uint16_t AHB1ENR;       // @72 AHB1 peripheral clock enable register
	uint8_t       RESERVED8[2];  // @74
	__IO uint32_t AHB2ENR;       // @76 AHB2 peripheral clock enable register
	__IO uint16_t AHB3ENR;       // @80 AHB3 peripheral clock enable register
	uint8_t       RESERVED9[6];  // @82
	__IO uint32_t APB1ENR1;      // @88 APB1ENR1
	__IO uint16_t APB1ENR2;      // @92 APB1 peripheral clock enable register 2
	uint8_t       RESERVED10[2]; // @94
	__IO uint32_t APB2ENR;       // @96 APB2ENR
	uint8_t       RESERVED11[4]; // @100
	__IO uint16_t AHB1SMENR;     // @104 AHB1 peripheral clocks enable in Sleep and Stop modes register
	uint8_t       RESERVED12[2]; // @106
	__IO uint32_t AHB2SMENR;     // @108 AHB2 peripheral clocks enable in Sleep and Stop modes register
	__IO uint16_t AHB3SMENR;     // @112 AHB3 peripheral clocks enable in Sleep and Stop modes register
	uint8_t       RESERVED13[6]; // @114
	__IO uint32_t APB1SMENR1;    // @120 APB1SMENR1
	__IO uint16_t APB1SMENR2;    // @124 APB1 peripheral clocks enable in Sleep and Stop modes register 2
	uint8_t       RESERVED14[2]; // @126
	__IO uint32_t APB2SMENR;     // @128 APB2SMENR
	uint8_t       RESERVED15[4]; // @132
	__IO uint32_t CCIPR1;        // @136 CCIPR
	uint8_t       RESERVED16[4]; // @140
	__IO uint32_t BDCR;          // @144 BDCR
	__IO uint32_t CSR;           // @148 CSR
	__IO uint16_t CRRCR;         // @152 Clock recovery RC register
	uint8_t       RESERVED17[2]; // @154
	__IO uint32_t CCIPR2;        // @156 Peripherals independent clock configuration register
};

// RCC->CR Clock control register
enum {
	RCC_CR_PLLSYSRDY = 1UL << 25, // Main PLL clock ready flag
	RCC_CR_PLLSYSON  = 1UL << 24, // Main PLL enable
	RCC_CR_HSECSSON  = 1UL << 19, // Clock security system enable
	RCC_CR_HSEBYP    = 1UL << 18, // HSE crystal oscillator bypass
	RCC_CR_HSERDY    = 1UL << 17, // HSE clock ready flag
	RCC_CR_HSEON     = 1UL << 16, // HSE clock enable
	RCC_CR_HSIRDY    = 1UL << 10, // HSI clock ready flag
	RCC_CR_HSIKERON  = 1UL << 9,  // HSI always enable for peripheral kernels
	RCC_CR_HSION     = 1UL << 8,  // HSI clock enable
};

// RCC->ICSCR Internal clock sources calibration register
enum {
	RCC_ICSCR_HSITRIM = ((1UL << 7) - 1) << 24, // Internal High Speed clock trimming
	RCC_ICSCR_HSICAL0 = ((1UL << 8) - 1) << 16, // Internal High Speed clock Calibration
};
inline void rcc_icscr_set_hsitrim(struct RCC_Type* p, uint32_t val) {
	p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSITRIM) | ((val << 24) & RCC_ICSCR_HSITRIM);
}
inline void rcc_icscr_set_hsical0(struct RCC_Type* p, uint32_t val) {
	p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSICAL0) | ((val << 16) & RCC_ICSCR_HSICAL0);
}
inline uint32_t rcc_icscr_get_hsitrim(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSITRIM) >> 24; }
inline uint32_t rcc_icscr_get_hsical0(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSICAL0) >> 16; }

// RCC->CFGR Clock configuration register
enum {
	RCC_CFGR_MCOPRE = ((1UL << 3) - 1) << 28, // Microcontroller clock output prescaler
	RCC_CFGR_MCOSEL = ((1UL << 4) - 1) << 24, // Microcontroller clock output
	RCC_CFGR_PPRE2  = ((1UL << 3) - 1) << 11, // APB high-speed prescaler (APB2)
	RCC_CFGR_PPRE1  = ((1UL << 3) - 1) << 8,  // PB low-speed prescaler (APB1)
	RCC_CFGR_HPRE   = ((1UL << 4) - 1) << 4,  // AHB prescaler
	RCC_CFGR_SWS    = ((1UL << 2) - 1) << 2,  // System clock switch status
	RCC_CFGR_SW     = ((1UL << 2) - 1) << 0,  // System clock switch
};
inline void rcc_cfgr_set_mcopre(struct RCC_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_MCOPRE) | ((val << 28) & RCC_CFGR_MCOPRE);
}
inline void rcc_cfgr_set_mcosel(struct RCC_Type* p, uint32_t val) {
	p->CFGR = (p->CFGR & ~RCC_CFGR_MCOSEL) | ((val << 24) & RCC_CFGR_MCOSEL);
}
inline void rcc_cfgr_set_ppre2(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE2) | ((val << 11) & RCC_CFGR_PPRE2); }
inline void rcc_cfgr_set_ppre1(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE1) | ((val << 8) & RCC_CFGR_PPRE1); }
inline void rcc_cfgr_set_hpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_HPRE) | ((val << 4) & RCC_CFGR_HPRE); }
inline void rcc_cfgr_set_sws(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val << 2) & RCC_CFGR_SWS); }
inline void rcc_cfgr_set_sw(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val << 0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mcopre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCOPRE) >> 28; }
inline uint32_t rcc_cfgr_get_mcosel(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCOSEL) >> 24; }
inline uint32_t rcc_cfgr_get_ppre2(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE2) >> 11; }
inline uint32_t rcc_cfgr_get_ppre1(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE1) >> 8; }
inline uint32_t rcc_cfgr_get_hpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_HPRE) >> 4; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SWS) >> 2; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SW) >> 0; }

// RCC->PLLSYSCFGR PLL configuration register
enum {
	RCC_PLLSYSCFGR_PLLSYSPDIV = ((1UL << 5) - 1) << 27, // Main PLL division factor for PLLSAI2CLK
	RCC_PLLSYSCFGR_PLLSYSR    = ((1UL << 2) - 1) << 25, // Main PLL division factor for PLLCLK (system clock)
	RCC_PLLSYSCFGR_PLLSYSREN  = 1UL << 24,              // Main PLL PLLCLK output enable
	RCC_PLLSYSCFGR_PLLSYSQ    = ((1UL << 2) - 1) << 21, // Main PLL division factor for PLLUSB1CLK(48 MHz clock)
	RCC_PLLSYSCFGR_PLLSYSQEN  = 1UL << 20,              // Main PLL PLLUSB1CLK output enable
	RCC_PLLSYSCFGR_PLLSYSP    = 1UL << 17,              // Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
	RCC_PLLSYSCFGR_PLLPEN     = 1UL << 16,              // Main PLL PLLSAI3CLK output enable
	RCC_PLLSYSCFGR_PLLSYSN    = ((1UL << 7) - 1) << 8,  // Main PLL multiplication factor for VCO
	RCC_PLLSYSCFGR_PLLSYSM    = ((1UL << 4) - 1) << 4,  // Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
	RCC_PLLSYSCFGR_PLLSRC     = ((1UL << 2) - 1) << 0,  // Main PLL, PLLSAI1 and PLLSAI2 entry clock source
};
inline void rcc_pllsyscfgr_set_pllsyspdiv(struct RCC_Type* p, uint32_t val) {
	p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSYSPDIV) | ((val << 27) & RCC_PLLSYSCFGR_PLLSYSPDIV);
}
inline void rcc_pllsyscfgr_set_pllsysr(struct RCC_Type* p, uint32_t val) {
	p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSYSR) | ((val << 25) & RCC_PLLSYSCFGR_PLLSYSR);
}
inline void rcc_pllsyscfgr_set_pllsysq(struct RCC_Type* p, uint32_t val) {
	p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSYSQ) | ((val << 21) & RCC_PLLSYSCFGR_PLLSYSQ);
}
inline void rcc_pllsyscfgr_set_pllsysn(struct RCC_Type* p, uint32_t val) {
	p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSYSN) | ((val << 8) & RCC_PLLSYSCFGR_PLLSYSN);
}
inline void rcc_pllsyscfgr_set_pllsysm(struct RCC_Type* p, uint32_t val) {
	p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSYSM) | ((val << 4) & RCC_PLLSYSCFGR_PLLSYSM);
}
inline void rcc_pllsyscfgr_set_pllsrc(struct RCC_Type* p, uint32_t val) {
	p->PLLSYSCFGR = (p->PLLSYSCFGR & ~RCC_PLLSYSCFGR_PLLSRC) | ((val << 0) & RCC_PLLSYSCFGR_PLLSRC);
}
inline uint32_t rcc_pllsyscfgr_get_pllsyspdiv(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSYSPDIV) >> 27; }
inline uint32_t rcc_pllsyscfgr_get_pllsysr(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSYSR) >> 25; }
inline uint32_t rcc_pllsyscfgr_get_pllsysq(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSYSQ) >> 21; }
inline uint32_t rcc_pllsyscfgr_get_pllsysn(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSYSN) >> 8; }
inline uint32_t rcc_pllsyscfgr_get_pllsysm(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSYSM) >> 4; }
inline uint32_t rcc_pllsyscfgr_get_pllsrc(struct RCC_Type* p) { return (p->PLLSYSCFGR & RCC_PLLSYSCFGR_PLLSRC) >> 0; }

// RCC->CIER Clock interrupt enable register
enum {
	RCC_CIER_RC48RDYIE   = 1UL << 10, // HSI48 ready interrupt enable
	RCC_CIER_LSECSSIE    = 1UL << 9,  // LSE clock security system interrupt enable
	RCC_CIER_PLLSYSRDYIE = 1UL << 5,  // PLL ready interrupt enable
	RCC_CIER_HSERDYIE    = 1UL << 4,  // HSE ready interrupt enable
	RCC_CIER_HSIRDYIE    = 1UL << 3,  // HSI ready interrupt enable
	RCC_CIER_LSERDYIE    = 1UL << 1,  // LSE ready interrupt enable
	RCC_CIER_LSIRDYIE    = 1UL << 0,  // LSI ready interrupt enable
};

// RCC->CIFR Clock interrupt flag register
enum {
	RCC_CIFR_RC48RDYF   = 1UL << 10, // HSI48 ready interrupt flag
	RCC_CIFR_LSECSSF    = 1UL << 9,  // LSE Clock security system interrupt flag
	RCC_CIFR_HSECSSF    = 1UL << 8,  // Clock security system interrupt flag
	RCC_CIFR_PLLSYSRDYF = 1UL << 5,  // PLL ready interrupt flag
	RCC_CIFR_HSERDYF    = 1UL << 4,  // HSE ready interrupt flag
	RCC_CIFR_HSIRDYF    = 1UL << 3,  // HSI ready interrupt flag
	RCC_CIFR_LSERDYF    = 1UL << 1,  // LSE ready interrupt flag
	RCC_CIFR_LSIRDYF    = 1UL << 0,  // LSI ready interrupt flag
};

// RCC->CICR Clock interrupt clear register
enum {
	RCC_CICR_RC48RDYC   = 1UL << 10, // HSI48 oscillator ready interrupt clear
	RCC_CICR_LSECSSC    = 1UL << 9,  // LSE Clock security system interrupt clear
	RCC_CICR_HSECSSC    = 1UL << 8,  // Clock security system interrupt clear
	RCC_CICR_PLLSYSRDYC = 1UL << 5,  // PLL ready interrupt clear
	RCC_CICR_HSERDYC    = 1UL << 4,  // HSE ready interrupt clear
	RCC_CICR_HSIRDYC    = 1UL << 3,  // HSI ready interrupt clear
	RCC_CICR_LSERDYC    = 1UL << 1,  // LSE ready interrupt clear
	RCC_CICR_LSIRDYC    = 1UL << 0,  // LSI ready interrupt clear
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_CRCRST     = 1UL << 12, // CRC reset
	RCC_AHB1RSTR_FLITFRST_  = 1UL << 8,  // FLITF reset
	RCC_AHB1RSTR_MATRIXRST  = 1UL << 4,  // MATRIX reset
	RCC_AHB1RSTR_CORDICRST  = 1UL << 3,  // CORDIC reset
	RCC_AHB1RSTR_DMAMUX1RST = 1UL << 2,  // DMAMUXRST
	RCC_AHB1RSTR_DMA2RST    = 1UL << 1,  // DMA2 reset
	RCC_AHB1RSTR_DMA1RST    = 1UL << 0,  // DMA1 reset
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_RNGRST     = 1UL << 26, // Random Number Generator module reset
	RCC_AHB2RSTR_CRYPTRST   = 1UL << 24, // Cryptography module reset
	RCC_AHB2RSTR_DAC4RST    = 1UL << 19, // DAC4 interface reset
	RCC_AHB2RSTR_DAC3RST    = 1UL << 18, // DAC3 interface reset
	RCC_AHB2RSTR_DAC2RST    = 1UL << 17, // DAC2 interface reset
	RCC_AHB2RSTR_DAC1RST_   = 1UL << 16, // DAC1 interface reset
	RCC_AHB2RSTR_ADC345RST_ = 1UL << 14, // SAR ADC345 interface reset
	RCC_AHB2RSTR_ADC12RST   = 1UL << 13, // ADC reset
	RCC_AHB2RSTR_GPIOGRST   = 1UL << 6,  // IO port G reset
	RCC_AHB2RSTR_GPIOFRST   = 1UL << 5,  // IO port F reset
	RCC_AHB2RSTR_GPIOERST   = 1UL << 4,  // IO port E reset
	RCC_AHB2RSTR_GPIODRST   = 1UL << 3,  // IO port D reset
	RCC_AHB2RSTR_GPIOCRST   = 1UL << 2,  // IO port C reset
	RCC_AHB2RSTR_GPIOBRST   = 1UL << 1,  // IO port B reset
	RCC_AHB2RSTR_GPIOARST   = 1UL << 0,  // IO port A reset
};

// RCC->AHB3RSTR AHB3 peripheral reset register
enum {
	RCC_AHB3RSTR_QUADSPI1RST = 1UL << 8, // Quad SPI 1 module reset
	RCC_AHB3RSTR_FMCRST      = 1UL << 0, // Flexible memory controller reset
};

// RCC->APB1RSTR1 APB1 peripheral reset register 1
enum {
	RCC_APB1RSTR1_LPTIM1RST = 1UL << 31, // Low Power Timer 1 reset
	RCC_APB1RSTR1_I2C3      = 1UL << 30, // I2C3 interface reset
	RCC_APB1RSTR1_PWRRST    = 1UL << 28, // Power interface reset
	RCC_APB1RSTR1_FDCANRST  = 1UL << 25, // FDCAN reset
	RCC_APB1RSTR1_USBDRST   = 1UL << 23, // USBD reset
	RCC_APB1RSTR1_I2C2RST   = 1UL << 22, // I2C2 reset
	RCC_APB1RSTR1_I2C1RST   = 1UL << 21, // I2C1 reset
	RCC_APB1RSTR1_UART5RST  = 1UL << 20, // UART5 reset
	RCC_APB1RSTR1_UART4RST  = 1UL << 19, // UART4 reset
	RCC_APB1RSTR1_USART3RST = 1UL << 18, // USART3 reset
	RCC_APB1RSTR1_USART2RST = 1UL << 17, // USART2 reset
	RCC_APB1RSTR1_SPI3RST   = 1UL << 15, // SPI3 reset
	RCC_APB1RSTR1_SPI2RST   = 1UL << 14, // SPI2 reset
	RCC_APB1RSTR1_CRSRST    = 1UL << 8,  // Clock recovery system reset
	RCC_APB1RSTR1_TIM7RST   = 1UL << 5,  // TIM7 timer reset
	RCC_APB1RSTR1_TIM6RST   = 1UL << 4,  // TIM6 timer reset
	RCC_APB1RSTR1_TIM5RST   = 1UL << 3,  // TIM5 timer reset
	RCC_APB1RSTR1_TIM4RST   = 1UL << 2,  // TIM3 timer reset
	RCC_APB1RSTR1_TIM3RST   = 1UL << 1,  // TIM3 timer reset
	RCC_APB1RSTR1_TIM2RST   = 1UL << 0,  // TIM2 timer reset
};

// RCC->APB1RSTR2 APB1 peripheral reset register 2
enum {
	RCC_APB1RSTR2_USBPDRST   = 1UL << 8, // USBPD reset
	RCC_APB1RSTR2_I2C4RST    = 1UL << 1, // I2C4 reset
	RCC_APB1RSTR2_LPUART1RST = 1UL << 0, // Low-power UART 1 reset
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_HRTIM1RST = 1UL << 26, // HRTIMER reset
	RCC_APB2RSTR_SAI1RST   = 1UL << 21, // Serial audio interface 1 (SAI1) reset
	RCC_APB2RSTR_TIM20RST  = 1UL << 20, // Timer 20 reset
	RCC_APB2RSTR_TIM17RST  = 1UL << 18, // TIM17 timer reset
	RCC_APB2RSTR_TIM16RST  = 1UL << 17, // TIM16 timer reset
	RCC_APB2RSTR_TIM15RST  = 1UL << 16, // TIM15 timer reset
	RCC_APB2RSTR_SPI4RST   = 1UL << 15, // SPI 4 reset
	RCC_APB2RSTR_USART1RST = 1UL << 14, // USART1 reset
	RCC_APB2RSTR_TIM8RST   = 1UL << 13, // TIM8 timer reset
	RCC_APB2RSTR_SPI1RST   = 1UL << 12, // SPI1 reset
	RCC_APB2RSTR_TIM1RST   = 1UL << 11, // TIM1 timer reset
	RCC_APB2RSTR_SYSCFGRST = 1UL << 0,  // System configuration (SYSCFG) reset
};

// RCC->AHB1ENR AHB1 peripheral clock enable register
enum {
	RCC_AHB1ENR_CRCEN    = 1UL << 12, // CRC clock enable
	RCC_AHB1ENR_FLITFEN  = 1UL << 8,  // FLITF clock enable
	RCC_AHB1ENR_FMACEN   = 1UL << 4,  // FMAC clock enable
	RCC_AHB1ENR_CORDICEN = 1UL << 3,  // CORDIC clock enable
	RCC_AHB1ENR_DMAMUXEN = 1UL << 2,  // DMAMUX clock enable
	RCC_AHB1ENR_DMA2EN   = 1UL << 1,  // DMA2 clock enable
	RCC_AHB1ENR_DMA1EN   = 1UL << 0,  // DMA1 clock enable
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_RNGEN    = 1UL << 26, // Random Number Generator clock enable
	RCC_AHB2ENR_CRYPTEN  = 1UL << 24, // Cryptography clock enable
	RCC_AHB2ENR_DAC4     = 1UL << 19, // DAC4 clock enable
	RCC_AHB2ENR_DAC3     = 1UL << 18, // Random Number Generator clock enable
	RCC_AHB2ENR_DAC2     = 1UL << 17, // HASH clock enable
	RCC_AHB2ENR_DAC1     = 1UL << 16, // AES accelerator clock enable
	RCC_AHB2ENR_ADC345EN = 1UL << 14, // DCMI clock enable
	RCC_AHB2ENR_ADC12EN  = 1UL << 13, // ADC clock enable
	RCC_AHB2ENR_GPIOGEN  = 1UL << 6,  // IO port G clock enable
	RCC_AHB2ENR_GPIOFEN  = 1UL << 5,  // IO port F clock enable
	RCC_AHB2ENR_GPIOEEN  = 1UL << 4,  // IO port E clock enable
	RCC_AHB2ENR_GPIODEN  = 1UL << 3,  // IO port D clock enable
	RCC_AHB2ENR_GPIOCEN  = 1UL << 2,  // IO port C clock enable
	RCC_AHB2ENR_GPIOBEN  = 1UL << 1,  // IO port B clock enable
	RCC_AHB2ENR_GPIOAEN  = 1UL << 0,  // IO port A clock enable
};

// RCC->AHB3ENR AHB3 peripheral clock enable register
enum {
	RCC_AHB3ENR_QUADSPI1EN = 1UL << 8, // Quad SPI 1 module clock enable
	RCC_AHB3ENR_FMCEN      = 1UL << 0, // Flexible memory controller clock enable
};

// RCC->APB1ENR1 APB1ENR1
enum {
	RCC_APB1ENR1_LPTIM1EN = 1UL << 31, // Low power timer 1 clock enable
	RCC_APB1ENR1_I2C3     = 1UL << 30, // OPAMP interface clock enable
	RCC_APB1ENR1_PWREN    = 1UL << 28, // Power interface clock enable
	RCC_APB1ENR1_FDCANEN  = 1UL << 25, // FDCAN clock enable
	RCC_APB1ENR1_USBDEN   = 1UL << 23, // USBDclock enable
	RCC_APB1ENR1_I2C2EN   = 1UL << 22, // I2C2 clock enable
	RCC_APB1ENR1_I2C1EN   = 1UL << 21, // I2C1 clock enable
	RCC_APB1ENR1_UART5EN  = 1UL << 20, // UART5 clock enable
	RCC_APB1ENR1_UART4EN  = 1UL << 19, // UART4 clock enable
	RCC_APB1ENR1_USART3EN = 1UL << 18, // USART3 clock enable
	RCC_APB1ENR1_USART2EN = 1UL << 17, // USART2 clock enable
	RCC_APB1ENR1_SP3EN    = 1UL << 15, // SPI3 clock enable
	RCC_APB1ENR1_SPI2EN   = 1UL << 14, // SPI2 clock enable
	RCC_APB1ENR1_WWDGEN   = 1UL << 11, // Window watchdog clock enable
	RCC_APB1ENR1_RTCAPBEN = 1UL << 10, // RTC APB clock enable
	RCC_APB1ENR1_CRSEN    = 1UL << 8,  // CRSclock enable
	RCC_APB1ENR1_TIM7EN   = 1UL << 5,  // TIM7 timer clock enable
	RCC_APB1ENR1_TIM6EN   = 1UL << 4,  // TIM6 timer clock enable
	RCC_APB1ENR1_TIM5EN   = 1UL << 3,  // TIM5 timer clock enable
	RCC_APB1ENR1_TIM4EN   = 1UL << 2,  // TIM4 timer clock enable
	RCC_APB1ENR1_TIM3EN   = 1UL << 1,  // TIM3 timer clock enable
	RCC_APB1ENR1_TIM2EN   = 1UL << 0,  // TIM2 timer clock enable
};

// RCC->APB1ENR2 APB1 peripheral clock enable register 2
enum {
	RCC_APB1ENR2_USBPDEN   = 1UL << 8, // USBPD clock enable
	RCC_APB1ENR2_I2C4EN    = 1UL << 1, // I2C4 clock enable
	RCC_APB1ENR2_LPUART1EN = 1UL << 0, // Low power UART 1 clock enable
};

// RCC->APB2ENR APB2ENR
enum {
	RCC_APB2ENR_HRTIMEREN = 1UL << 26, // HRTIMER clock enable
	RCC_APB2ENR_SAI1EN    = 1UL << 21, // SAI1 clock enable
	RCC_APB2ENR_TIM20EN   = 1UL << 20, // Timer 20 clock enable
	RCC_APB2ENR_TIM17EN   = 1UL << 18, // TIM17 timer clock enable
	RCC_APB2ENR_TIM16EN   = 1UL << 17, // TIM16 timer clock enable
	RCC_APB2ENR_TIM15EN   = 1UL << 16, // TIM15 timer clock enable
	RCC_APB2ENR_SPI4EN    = 1UL << 15, // SPI 4 clock enable
	RCC_APB2ENR_USART1EN  = 1UL << 14, // USART1clock enable
	RCC_APB2ENR_TIM8EN    = 1UL << 13, // TIM8 timer clock enable
	RCC_APB2ENR_SPI1EN    = 1UL << 12, // SPI1 clock enable
	RCC_APB2ENR_TIM1EN    = 1UL << 11, // TIM1 timer clock enable
	RCC_APB2ENR_SYSCFGEN  = 1UL << 0,  // SYSCFG clock enable
};

// RCC->AHB1SMENR AHB1 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB1SMENR_CRCSMEN     = 1UL << 12, // CRCSMEN
	RCC_AHB1SMENR_SRAM1SMEN   = 1UL << 9,  // SRAM1 interface clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_FLASHSMEN   = 1UL << 8,  // Flash memory interface clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_FMACSMEN    = 1UL << 4,  // FMACSM clock enable
	RCC_AHB1SMENR_CORDICSMEN  = 1UL << 3,  // CORDIC clock enable during sleep mode
	RCC_AHB1SMENR_DMAMUX1SMEN = 1UL << 2,  // DMAMUX clock enable during Sleep and Stop modes
	RCC_AHB1SMENR_DMA2SMEN    = 1UL << 1,  // DMA2 clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_DMA1SMEN    = 1UL << 0,  // DMA1 clocks enable during Sleep and Stop modes
};

// RCC->AHB2SMENR AHB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB2SMENR_RNGSMEN    = 1UL << 26, // Random Number Generator clock enable during sleep mode
	RCC_AHB2SMENR_CRYPTSMEN  = 1UL << 24, // Cryptography clock enable during sleep mode
	RCC_AHB2SMENR_DAC4SMEN   = 1UL << 19, // DAC4 clock enable during sleep mode
	RCC_AHB2SMENR_DAC3SMEN   = 1UL << 18, // DAC3 clock enable during sleep mode
	RCC_AHB2SMENR_DAC2SMEN   = 1UL << 17, // HASH clock enable during Sleep and Stop modes
	RCC_AHB2SMENR_DAC1SMEN   = 1UL << 16, // AES accelerator clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_ADC345SMEN = 1UL << 14, // DCMI clock enable during Sleep and Stop modes
	RCC_AHB2SMENR_AD12CSMEN  = 1UL << 13, // ADC clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_SRAM3SMEN  = 1UL << 10, // SRAM2 interface clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_SRAM2SMEN  = 1UL << 9,  // SRAM2 interface clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOGSMEN  = 1UL << 6,  // IO port G clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOFSMEN  = 1UL << 5,  // IO port F clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOESMEN  = 1UL << 4,  // IO port E clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIODSMEN  = 1UL << 3,  // IO port D clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOCSMEN  = 1UL << 2,  // IO port C clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOBSMEN  = 1UL << 1,  // IO port B clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOASMEN  = 1UL << 0,  // IO port A clocks enable during Sleep and Stop modes
};

// RCC->AHB3SMENR AHB3 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB3SMENR_QUADSPI1SMEN = 1UL << 8, // QUAD SPI 1 module clock enable during sleep mode
	RCC_AHB3SMENR_FMCSMEN      = 1UL << 0, // Flexible memory controller clocks enable during Sleep and Stop modes
};

// RCC->APB1SMENR1 APB1SMENR1
enum {
	RCC_APB1SMENR1_LPTIM1SMEN = 1UL << 31, // Low Power Timer1 clock enable during sleep mode
	RCC_APB1SMENR1_I2C3SMEN_3 = 1UL << 30, // I2C 3 interface clock enable during sleep mode
	RCC_APB1SMENR1_PWRSMEN    = 1UL << 28, // Power interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_FDCANSMEN  = 1UL << 25, // FDCAN clock enable during sleep mode
	RCC_APB1SMENR1_I2C3SMEN   = 1UL << 23, // I2C3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C2SMEN   = 1UL << 22, // I2C2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C1SMEN   = 1UL << 21, // I2C1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_UART5SMEN  = 1UL << 20, // UART5 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_UART4SMEN  = 1UL << 19, // UART4 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USART3SMEN = 1UL << 18, // USART3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USART2SMEN = 1UL << 17, // USART2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_SP3SMEN    = 1UL << 15, // SPI3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_SPI2SMEN   = 1UL << 14, // SPI2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_WWDGSMEN   = 1UL << 11, // Window watchdog clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_RTCAPBSMEN = 1UL << 10, // RTC APB clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_CRSSMEN    = 1UL << 8,  // CRS clock enable during sleep mode
	RCC_APB1SMENR1_TIM7SMEN   = 1UL << 5,  // TIM7 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM6SMEN   = 1UL << 4,  // TIM6 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM5SMEN   = 1UL << 3,  // TIM5 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM4SMEN   = 1UL << 2,  // TIM4 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM3SMEN   = 1UL << 1,  // TIM3 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM2SMEN   = 1UL << 0,  // TIM2 timer clocks enable during Sleep and Stop modes
};

// RCC->APB1SMENR2 APB1 peripheral clocks enable in Sleep and Stop modes register 2
enum {
	RCC_APB1SMENR2_USBPDSMEN   = 1UL << 8, // USB PD clock enable during sleep mode
	RCC_APB1SMENR2_I2C4SMEN    = 1UL << 1, // I2C4 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR2_LPUART1SMEN = 1UL << 0, // Low power UART 1 clocks enable during Sleep and Stop modes
};

// RCC->APB2SMENR APB2SMENR
enum {
	RCC_APB2SMENR_HRTIMERSMEN = 1UL << 26, // HRTIMER clock enable during sleep mode
	RCC_APB2SMENR_SAI1SMEN    = 1UL << 21, // SAI1 clock enable during sleep mode
	RCC_APB2SMENR_TIM20SMEN   = 1UL << 20, // Timer 20clock enable during sleep mode
	RCC_APB2SMENR_TIM17SMEN   = 1UL << 18, // TIM17 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM16SMEN   = 1UL << 17, // TIM16 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM15SMEN   = 1UL << 16, // TIM15 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SPI4SMEN    = 1UL << 15, // SPI4 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_USART1SMEN  = 1UL << 14, // USART1clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM8SMEN    = 1UL << 13, // TIM8 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SPI1SMEN    = 1UL << 12, // SPI1 clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM1SMEN    = 1UL << 11, // TIM1 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SYSCFGSMEN  = 1UL << 0,  // SYSCFG clocks enable during Sleep and Stop modes
};

// RCC->CCIPR1 CCIPR
enum {
	RCC_CCIPR1_ADC345SEL  = ((1UL << 2) - 1) << 30, // ADC3/4/5 clock source selection
	RCC_CCIPR1_ADCSEL     = ((1UL << 2) - 1) << 28, // ADCs clock source selection
	RCC_CCIPR1_CLK48SEL   = ((1UL << 2) - 1) << 26, // 48 MHz clock source selection
	RCC_CCIPR1_FDCANSEL   = ((1UL << 2) - 1) << 24, // SAI2 clock source selection
	RCC_CCIPR1_SPISEL_    = ((1UL << 2) - 1) << 22, // SAI1 clock source selection
	RCC_CCIPR1_SAISEL     = ((1UL << 2) - 1) << 20, // Low power timer 2 clock source selection
	RCC_CCIPR1_LPTIM1SEL  = ((1UL << 2) - 1) << 18, // Low power timer 1 clock source selection
	RCC_CCIPR1_I2C3SEL    = ((1UL << 2) - 1) << 16, // I2C3 clock source selection
	RCC_CCIPR1_I2C2SEL    = ((1UL << 2) - 1) << 14, // I2C2 clock source selection
	RCC_CCIPR1_I2C1SEL    = ((1UL << 2) - 1) << 12, // I2C1 clock source selection
	RCC_CCIPR1_LPUART1SEL = ((1UL << 2) - 1) << 10, // LPUART1 clock source selection
	RCC_CCIPR1_UART5SEL   = ((1UL << 2) - 1) << 8,  // UART5 clock source selection
	RCC_CCIPR1_UART4SEL   = ((1UL << 2) - 1) << 6,  // UART4 clock source selection
	RCC_CCIPR1_USART3SEL  = ((1UL << 2) - 1) << 4,  // USART3 clock source selection
	RCC_CCIPR1_USART2SEL  = ((1UL << 2) - 1) << 2,  // USART2 clock source selection
	RCC_CCIPR1_USART1SEL  = ((1UL << 2) - 1) << 0,  // USART1 clock source selection
};
inline void rcc_ccipr1_set_adc345sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_ADC345SEL) | ((val << 30) & RCC_CCIPR1_ADC345SEL);
}
inline void rcc_ccipr1_set_adcsel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_ADCSEL) | ((val << 28) & RCC_CCIPR1_ADCSEL);
}
inline void rcc_ccipr1_set_clk48sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_CLK48SEL) | ((val << 26) & RCC_CCIPR1_CLK48SEL);
}
inline void rcc_ccipr1_set_fdcansel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_FDCANSEL) | ((val << 24) & RCC_CCIPR1_FDCANSEL);
}
inline void rcc_ccipr1_set_spisel_(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_SPISEL_) | ((val << 22) & RCC_CCIPR1_SPISEL_);
}
inline void rcc_ccipr1_set_saisel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_SAISEL) | ((val << 20) & RCC_CCIPR1_SAISEL);
}
inline void rcc_ccipr1_set_lptim1sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_LPTIM1SEL) | ((val << 18) & RCC_CCIPR1_LPTIM1SEL);
}
inline void rcc_ccipr1_set_i2c3sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_I2C3SEL) | ((val << 16) & RCC_CCIPR1_I2C3SEL);
}
inline void rcc_ccipr1_set_i2c2sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_I2C2SEL) | ((val << 14) & RCC_CCIPR1_I2C2SEL);
}
inline void rcc_ccipr1_set_i2c1sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_I2C1SEL) | ((val << 12) & RCC_CCIPR1_I2C1SEL);
}
inline void rcc_ccipr1_set_lpuart1sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_LPUART1SEL) | ((val << 10) & RCC_CCIPR1_LPUART1SEL);
}
inline void rcc_ccipr1_set_uart5sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_UART5SEL) | ((val << 8) & RCC_CCIPR1_UART5SEL);
}
inline void rcc_ccipr1_set_uart4sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_UART4SEL) | ((val << 6) & RCC_CCIPR1_UART4SEL);
}
inline void rcc_ccipr1_set_usart3sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_USART3SEL) | ((val << 4) & RCC_CCIPR1_USART3SEL);
}
inline void rcc_ccipr1_set_usart2sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_USART2SEL) | ((val << 2) & RCC_CCIPR1_USART2SEL);
}
inline void rcc_ccipr1_set_usart1sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR1 = (p->CCIPR1 & ~RCC_CCIPR1_USART1SEL) | ((val << 0) & RCC_CCIPR1_USART1SEL);
}
inline uint32_t rcc_ccipr1_get_adc345sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_ADC345SEL) >> 30; }
inline uint32_t rcc_ccipr1_get_adcsel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_ADCSEL) >> 28; }
inline uint32_t rcc_ccipr1_get_clk48sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_CLK48SEL) >> 26; }
inline uint32_t rcc_ccipr1_get_fdcansel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_FDCANSEL) >> 24; }
inline uint32_t rcc_ccipr1_get_spisel_(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_SPISEL_) >> 22; }
inline uint32_t rcc_ccipr1_get_saisel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_SAISEL) >> 20; }
inline uint32_t rcc_ccipr1_get_lptim1sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_LPTIM1SEL) >> 18; }
inline uint32_t rcc_ccipr1_get_i2c3sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_I2C3SEL) >> 16; }
inline uint32_t rcc_ccipr1_get_i2c2sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_I2C2SEL) >> 14; }
inline uint32_t rcc_ccipr1_get_i2c1sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_I2C1SEL) >> 12; }
inline uint32_t rcc_ccipr1_get_lpuart1sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_LPUART1SEL) >> 10; }
inline uint32_t rcc_ccipr1_get_uart5sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_UART5SEL) >> 8; }
inline uint32_t rcc_ccipr1_get_uart4sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_UART4SEL) >> 6; }
inline uint32_t rcc_ccipr1_get_usart3sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_USART3SEL) >> 4; }
inline uint32_t rcc_ccipr1_get_usart2sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_USART2SEL) >> 2; }
inline uint32_t rcc_ccipr1_get_usart1sel(struct RCC_Type* p) { return (p->CCIPR1 & RCC_CCIPR1_USART1SEL) >> 0; }

// RCC->BDCR BDCR
enum {
	RCC_BDCR_LSCOSEL  = 1UL << 25,             // Low speed clock output selection
	RCC_BDCR_LSCCOEN  = 1UL << 24,             // Low speed clock output enable
	RCC_BDCR_VSWRST   = 1UL << 16,             // Vswitch domain software reset
	RCC_BDCR_RTCEN    = 1UL << 15,             // RTC clock enable
	RCC_BDCR_RTCSEL   = ((1UL << 2) - 1) << 8, // RTC clock source selection
	RCC_BDCR_LSECSSD  = 1UL << 6,              // LSECSSD
	RCC_BDCR_LSECSSON = 1UL << 5,              // LSECSSON
	RCC_BDCR_LSEDRV   = ((1UL << 2) - 1) << 3, // SE oscillator drive capability
	RCC_BDCR_LSEBYP   = 1UL << 2,              // LSE oscillator bypass
	RCC_BDCR_LSERDY   = 1UL << 1,              // LSE oscillator ready
	RCC_BDCR_LSEON    = 1UL << 0,              // LSE oscillator enable
};
inline void rcc_bdcr_set_rtcsel(struct RCC_Type* p, uint32_t val) {
	p->BDCR = (p->BDCR & ~RCC_BDCR_RTCSEL) | ((val << 8) & RCC_BDCR_RTCSEL);
}
inline void rcc_bdcr_set_lsedrv(struct RCC_Type* p, uint32_t val) {
	p->BDCR = (p->BDCR & ~RCC_BDCR_LSEDRV) | ((val << 3) & RCC_BDCR_LSEDRV);
}
inline uint32_t rcc_bdcr_get_rtcsel(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_RTCSEL) >> 8; }
inline uint32_t rcc_bdcr_get_lsedrv(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_LSEDRV) >> 3; }

// RCC->CSR CSR
enum {
	RCC_CSR_LPWRSTF  = 1UL << 31, // Low-power reset flag
	RCC_CSR_WWDGRSTF = 1UL << 30, // Window watchdog reset flag
	RCC_CSR_WDGRSTF  = 1UL << 29, // Independent window watchdog reset flag
	RCC_CSR_SFTRSTF  = 1UL << 28, // Software reset flag
	RCC_CSR_BORRSTF  = 1UL << 27, // BOR flag
	RCC_CSR_PADRSTF  = 1UL << 26, // Pad reset flag
	RCC_CSR_OBLRSTF  = 1UL << 25, // Option byte loader reset flag
	RCC_CSR_RMVF     = 1UL << 23, // Remove reset flag
	RCC_CSR_LSIRDY   = 1UL << 1,  // LSI oscillator ready
	RCC_CSR_LSION    = 1UL << 0,  // LSI oscillator enable
};

// RCC->CRRCR Clock recovery RC register
enum {
	RCC_CRRCR_RC48CAL = ((1UL << 9) - 1) << 7, // HSI48 clock calibration
	RCC_CRRCR_RC48RDY = 1UL << 1,              // HSI48 clock ready flag
	RCC_CRRCR_RC48ON  = 1UL << 0,              // HSI48 clock enable
};
inline void rcc_crrcr_set_rc48cal(struct RCC_Type* p, uint32_t val) {
	p->CRRCR = (p->CRRCR & ~RCC_CRRCR_RC48CAL) | ((val << 7) & RCC_CRRCR_RC48CAL);
}
inline uint32_t rcc_crrcr_get_rc48cal(struct RCC_Type* p) { return (p->CRRCR & RCC_CRRCR_RC48CAL) >> 7; }

// RCC->CCIPR2 Peripherals independent clock configuration register
enum {
	RCC_CCIPR2_QUADSPISEL = ((1UL << 2) - 1) << 20, // Octospi clock source selection
	RCC_CCIPR2_I2C4SEL    = ((1UL << 2) - 1) << 0,  // I2C4 clock source selection
};
inline void rcc_ccipr2_set_quadspisel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR2 = (p->CCIPR2 & ~RCC_CCIPR2_QUADSPISEL) | ((val << 20) & RCC_CCIPR2_QUADSPISEL);
}
inline void rcc_ccipr2_set_i2c4sel(struct RCC_Type* p, uint32_t val) {
	p->CCIPR2 = (p->CCIPR2 & ~RCC_CCIPR2_I2C4SEL) | ((val << 0) & RCC_CCIPR2_I2C4SEL);
}
inline uint32_t rcc_ccipr2_get_quadspisel(struct RCC_Type* p) { return (p->CCIPR2 & RCC_CCIPR2_QUADSPISEL) >> 20; }
inline uint32_t rcc_ccipr2_get_i2c4sel(struct RCC_Type* p) { return (p->CCIPR2 & RCC_CCIPR2_I2C4SEL) >> 0; }

/* Random number generator */
struct RNG_Type {
	__IO uint8_t CR;           // @0 control register
	uint8_t      RESERVED0[3]; // @1
	__IO uint8_t SR;           // @4 status register
	uint8_t      RESERVED1[3]; // @5
	__I uint32_t DR;           // @8 data register
};

// RNG->CR control register
enum {
	RNG_CR_CED   = 1UL << 5, // Clock error detection
	RNG_CR_IE    = 1UL << 3, // Interrupt enable
	RNG_CR_RNGEN = 1UL << 2, // Random number generator enable
};

// RNG->SR status register
enum {
	RNG_SR_SEIS = 1UL << 6, // Seed error interrupt status
	RNG_SR_CEIS = 1UL << 5, // Clock error interrupt status
	RNG_SR_SECS = 1UL << 2, // Seed error current status
	RNG_SR_CECS = 1UL << 1, // Clock error current status
	RNG_SR_DRDY = 1UL << 0, // Data ready
};

/* Real-time clock */
struct RTC_Type {
	__IO uint32_t TR;           // @0 time register
	__IO uint32_t DR;           // @4 date register
	__I uint16_t  SSR;          // @8 sub second register
	uint8_t       RESERVED0[2]; // @10
	__IO uint32_t ICSR;         // @12 initialization and status register
	__IO uint32_t PRER;         // @16 prescaler register
	__IO uint16_t WUTR;         // @20 wakeup timer register
	uint8_t       RESERVED1[2]; // @22
	__IO uint32_t CR;           // @24 control register
	uint8_t       RESERVED2[8]; // @28
	__O uint8_t   WPR;          // @36 write protection register
	uint8_t       RESERVED3[3]; // @37
	__IO uint16_t CALR;         // @40 calibration register
	uint8_t       RESERVED4[2]; // @42
	__O uint32_t  SHIFTR;       // @44 shift control register
	__I uint32_t  TSTR;         // @48 time stamp time register
	__I uint16_t  TSDR;         // @52 time stamp date register
	uint8_t       RESERVED5[2]; // @54
	__I uint16_t  TSSSR;        // @56 timestamp sub second register
	uint8_t       RESERVED6[6]; // @58
	__IO uint32_t ALRMAR;       // @64 alarm A register
	__IO uint32_t ALRMASSR;     // @68 alarm A sub second register
	__IO uint32_t ALRMBR;       // @72 alarm B register
	__IO uint32_t ALRMBSSR;     // @76 alarm B sub second register
	__I uint8_t   SR;           // @80 status register
	uint8_t       RESERVED7[3]; // @81
	__I uint8_t   MISR;         // @84 status register
	uint8_t       RESERVED8[7]; // @85
	__O uint8_t   SCR;          // @92 status register
};

// RTC->TR time register
enum {
	RTC_TR_PM  = 1UL << 22,              // AM/PM notation
	RTC_TR_HT  = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_TR_HU  = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_TR_ST  = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_TR_SU  = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline void     rtc_tr_set_ht(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HT) | ((val << 20) & RTC_TR_HT); }
inline void     rtc_tr_set_hu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HU) | ((val << 16) & RTC_TR_HU); }
inline void     rtc_tr_set_mnt(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNT) | ((val << 12) & RTC_TR_MNT); }
inline void     rtc_tr_set_mnu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNU) | ((val << 8) & RTC_TR_MNU); }
inline void     rtc_tr_set_st(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_ST) | ((val << 4) & RTC_TR_ST); }
inline void     rtc_tr_set_su(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_SU) | ((val << 0) & RTC_TR_SU); }
inline uint32_t rtc_tr_get_ht(struct RTC_Type* p) { return (p->TR & RTC_TR_HT) >> 20; }
inline uint32_t rtc_tr_get_hu(struct RTC_Type* p) { return (p->TR & RTC_TR_HU) >> 16; }
inline uint32_t rtc_tr_get_mnt(struct RTC_Type* p) { return (p->TR & RTC_TR_MNT) >> 12; }
inline uint32_t rtc_tr_get_mnu(struct RTC_Type* p) { return (p->TR & RTC_TR_MNU) >> 8; }
inline uint32_t rtc_tr_get_st(struct RTC_Type* p) { return (p->TR & RTC_TR_ST) >> 4; }
inline uint32_t rtc_tr_get_su(struct RTC_Type* p) { return (p->TR & RTC_TR_SU) >> 0; }

// RTC->DR date register
enum {
	RTC_DR_YT  = ((1UL << 4) - 1) << 20, // Year tens in BCD format
	RTC_DR_YU  = ((1UL << 4) - 1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL << 3) - 1) << 13, // Week day units
	RTC_DR_MT  = 1UL << 12,              // Month tens in BCD format
	RTC_DR_MU  = ((1UL << 4) - 1) << 8,  // Month units in BCD format
	RTC_DR_DT  = ((1UL << 2) - 1) << 4,  // Date tens in BCD format
	RTC_DR_DU  = ((1UL << 4) - 1) << 0,  // Date units in BCD format
};
inline void     rtc_dr_set_yt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YT) | ((val << 20) & RTC_DR_YT); }
inline void     rtc_dr_set_yu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YU) | ((val << 16) & RTC_DR_YU); }
inline void     rtc_dr_set_wdu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_WDU) | ((val << 13) & RTC_DR_WDU); }
inline void     rtc_dr_set_mu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_MU) | ((val << 8) & RTC_DR_MU); }
inline void     rtc_dr_set_dt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DT) | ((val << 4) & RTC_DR_DT); }
inline void     rtc_dr_set_du(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DU) | ((val << 0) & RTC_DR_DU); }
inline uint32_t rtc_dr_get_yt(struct RTC_Type* p) { return (p->DR & RTC_DR_YT) >> 20; }
inline uint32_t rtc_dr_get_yu(struct RTC_Type* p) { return (p->DR & RTC_DR_YU) >> 16; }
inline uint32_t rtc_dr_get_wdu(struct RTC_Type* p) { return (p->DR & RTC_DR_WDU) >> 13; }
inline uint32_t rtc_dr_get_mu(struct RTC_Type* p) { return (p->DR & RTC_DR_MU) >> 8; }
inline uint32_t rtc_dr_get_dt(struct RTC_Type* p) { return (p->DR & RTC_DR_DT) >> 4; }
inline uint32_t rtc_dr_get_du(struct RTC_Type* p) { return (p->DR & RTC_DR_DU) >> 0; }

// RTC->ICSR initialization and status register
enum {
	RTC_ICSR_RECALPF = 1UL << 16, // Recalibration pending Flag
	RTC_ICSR_INIT    = 1UL << 7,  // Initialization mode
	RTC_ICSR_INITF   = 1UL << 6,  // Initialization flag
	RTC_ICSR_RSF     = 1UL << 5,  // Registers synchronization flag
	RTC_ICSR_INITS   = 1UL << 4,  // Initialization status flag
	RTC_ICSR_SHPF    = 1UL << 3,  // Shift operation pending
	RTC_ICSR_WUTWF   = 1UL << 2,  // Wakeup timer write flag
	RTC_ICSR_ALRBWF  = 1UL << 1,  // Alarm B write flag
	RTC_ICSR_ALRAWF  = 1UL << 0,  // Alarm A write flag
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL << 7) - 1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL << 15) - 1) << 0, // Synchronous prescaler factor
};
inline void rtc_prer_set_prediv_a(struct RTC_Type* p, uint32_t val) {
	p->PRER = (p->PRER & ~RTC_PRER_PREDIV_A) | ((val << 16) & RTC_PRER_PREDIV_A);
}
inline void rtc_prer_set_prediv_s(struct RTC_Type* p, uint32_t val) {
	p->PRER = (p->PRER & ~RTC_PRER_PREDIV_S) | ((val << 0) & RTC_PRER_PREDIV_S);
}
inline uint32_t rtc_prer_get_prediv_a(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_A) >> 16; }
inline uint32_t rtc_prer_get_prediv_s(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_S) >> 0; }

// RTC->CR control register
enum {
	RTC_CR_OUT2EN        = 1UL << 31,              // OUT2EN
	RTC_CR_TAMPALRM_TYPE = 1UL << 30,              // TAMPALRM_TYPE
	RTC_CR_TAMPALRM_PU   = 1UL << 29,              // TAMPALRM_PU
	RTC_CR_TAMPOE        = 1UL << 26,              // TAMPOE
	RTC_CR_TAMPTS        = 1UL << 25,              // TAMPTS
	RTC_CR_ITSE          = 1UL << 24,              // timestamp on internal event enable
	RTC_CR_COE           = 1UL << 23,              // Calibration output enable
	RTC_CR_OSEL          = ((1UL << 2) - 1) << 21, // Output selection
	RTC_CR_POL           = 1UL << 20,              // Output polarity
	RTC_CR_COSEL         = 1UL << 19,              // Calibration output selection
	RTC_CR_BKP           = 1UL << 18,              // Backup
	RTC_CR_SUB1H         = 1UL << 17,              // Subtract 1 hour (winter time change)
	RTC_CR_ADD1H         = 1UL << 16,              // Add 1 hour (summer time change)
	RTC_CR_TSIE          = 1UL << 15,              // Time-stamp interrupt enable
	RTC_CR_WUTIE         = 1UL << 14,              // Wakeup timer interrupt enable
	RTC_CR_ALRBIE        = 1UL << 13,              // Alarm B interrupt enable
	RTC_CR_ALRAIE        = 1UL << 12,              // Alarm A interrupt enable
	RTC_CR_TSE           = 1UL << 11,              // Time stamp enable
	RTC_CR_WUTE          = 1UL << 10,              // Wakeup timer enable
	RTC_CR_ALRBE         = 1UL << 9,               // Alarm B enable
	RTC_CR_ALRAE         = 1UL << 8,               // Alarm A enable
	RTC_CR_FMT           = 1UL << 6,               // Hour format
	RTC_CR_BYPSHAD       = 1UL << 5,               // Bypass the shadow registers
	RTC_CR_REFCKON       = 1UL << 4,               // Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE        = 1UL << 3,               // Time-stamp event active edge
	RTC_CR_WCKSEL        = ((1UL << 3) - 1) << 0,  // Wakeup clock selection
};
inline void     rtc_cr_set_osel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_OSEL) | ((val << 21) & RTC_CR_OSEL); }
inline void     rtc_cr_set_wcksel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_WCKSEL) | ((val << 0) & RTC_CR_WCKSEL); }
inline uint32_t rtc_cr_get_osel(struct RTC_Type* p) { return (p->CR & RTC_CR_OSEL) >> 21; }
inline uint32_t rtc_cr_get_wcksel(struct RTC_Type* p) { return (p->CR & RTC_CR_WCKSEL) >> 0; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP   = 1UL << 15,             // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8  = 1UL << 14,             // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL << 13,             // Use a 16-second calibration cycle period
	RTC_CALR_CALM   = ((1UL << 9) - 1) << 0, // Calibration minus
};
inline void     rtc_calr_set_calm(struct RTC_Type* p, uint32_t val) { p->CALR = (p->CALR & ~RTC_CALR_CALM) | ((val << 0) & RTC_CALR_CALM); }
inline uint32_t rtc_calr_get_calm(struct RTC_Type* p) { return (p->CALR & RTC_CALR_CALM) >> 0; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL << 31,              // Add one second
	RTC_SHIFTR_SUBFS = ((1UL << 15) - 1) << 0, // Subtract a fraction of a second
};
inline void rtc_shiftr_set_subfs(struct RTC_Type* p, uint32_t val) {
	p->SHIFTR = (p->SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val << 0) & RTC_SHIFTR_SUBFS);
}
inline uint32_t rtc_shiftr_get_subfs(struct RTC_Type* p) { return (p->SHIFTR & RTC_SHIFTR_SUBFS) >> 0; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM  = 1UL << 22,              // AM/PM notation
	RTC_TSTR_HT  = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU  = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_TSTR_ST  = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_TSTR_SU  = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline uint32_t rtc_tstr_get_ht(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HT) >> 20; }
inline uint32_t rtc_tstr_get_hu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HU) >> 16; }
inline uint32_t rtc_tstr_get_mnt(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNT) >> 12; }
inline uint32_t rtc_tstr_get_mnu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNU) >> 8; }
inline uint32_t rtc_tstr_get_st(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_ST) >> 4; }
inline uint32_t rtc_tstr_get_su(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_SU) >> 0; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL << 3) - 1) << 13, // Week day units
	RTC_TSDR_MT  = 1UL << 12,              // Month tens in BCD format
	RTC_TSDR_MU  = ((1UL << 4) - 1) << 8,  // Month units in BCD format
	RTC_TSDR_DT  = ((1UL << 2) - 1) << 4,  // Date tens in BCD format
	RTC_TSDR_DU  = ((1UL << 4) - 1) << 0,  // Date units in BCD format
};
inline uint32_t rtc_tsdr_get_wdu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_WDU) >> 13; }
inline uint32_t rtc_tsdr_get_mu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_MU) >> 8; }
inline uint32_t rtc_tsdr_get_dt(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DT) >> 4; }
inline uint32_t rtc_tsdr_get_du(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DU) >> 0; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4  = 1UL << 31,              // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL << 30,              // Week day selection
	RTC_ALRMAR_DT    = ((1UL << 2) - 1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU    = ((1UL << 4) - 1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3  = 1UL << 23,              // Alarm A hours mask
	RTC_ALRMAR_PM    = 1UL << 22,              // AM/PM notation
	RTC_ALRMAR_HT    = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU    = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2  = 1UL << 15,              // Alarm A minutes mask
	RTC_ALRMAR_MNT   = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU   = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_ALRMAR_MSK1  = 1UL << 7,               // Alarm A seconds mask
	RTC_ALRMAR_ST    = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_ALRMAR_SU    = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline void rtc_alrmar_set_dt(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DT) | ((val << 28) & RTC_ALRMAR_DT);
}
inline void rtc_alrmar_set_du(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DU) | ((val << 24) & RTC_ALRMAR_DU);
}
inline void rtc_alrmar_set_ht(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HT) | ((val << 20) & RTC_ALRMAR_HT);
}
inline void rtc_alrmar_set_hu(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HU) | ((val << 16) & RTC_ALRMAR_HU);
}
inline void rtc_alrmar_set_mnt(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNT) | ((val << 12) & RTC_ALRMAR_MNT);
}
inline void rtc_alrmar_set_mnu(struct RTC_Type* p, uint32_t val) {
	p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNU) | ((val << 8) & RTC_ALRMAR_MNU);
}
inline void rtc_alrmar_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_ST) | ((val << 4) & RTC_ALRMAR_ST); }
inline void rtc_alrmar_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_SU) | ((val << 0) & RTC_ALRMAR_SU); }
inline uint32_t rtc_alrmar_get_dt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DT) >> 28; }
inline uint32_t rtc_alrmar_get_du(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DU) >> 24; }
inline uint32_t rtc_alrmar_get_ht(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HT) >> 20; }
inline uint32_t rtc_alrmar_get_hu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HU) >> 16; }
inline uint32_t rtc_alrmar_get_mnt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNT) >> 12; }
inline uint32_t rtc_alrmar_get_mnu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNU) >> 8; }
inline uint32_t rtc_alrmar_get_st(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_ST) >> 4; }
inline uint32_t rtc_alrmar_get_su(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_SU) >> 0; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL << 4) - 1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS     = ((1UL << 15) - 1) << 0, // Sub seconds value
};
inline void rtc_alrmassr_set_maskss(struct RTC_Type* p, uint32_t val) {
	p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val << 24) & RTC_ALRMASSR_MASKSS);
}
inline void rtc_alrmassr_set_ss(struct RTC_Type* p, uint32_t val) {
	p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_SS) | ((val << 0) & RTC_ALRMASSR_SS);
}
inline uint32_t rtc_alrmassr_get_maskss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24; }
inline uint32_t rtc_alrmassr_get_ss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_SS) >> 0; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4  = 1UL << 31,              // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL << 30,              // Week day selection
	RTC_ALRMBR_DT    = ((1UL << 2) - 1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU    = ((1UL << 4) - 1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3  = 1UL << 23,              // Alarm B hours mask
	RTC_ALRMBR_PM    = 1UL << 22,              // AM/PM notation
	RTC_ALRMBR_HT    = ((1UL << 2) - 1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU    = ((1UL << 4) - 1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2  = 1UL << 15,              // Alarm B minutes mask
	RTC_ALRMBR_MNT   = ((1UL << 3) - 1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU   = ((1UL << 4) - 1) << 8,  // Minute units in BCD format
	RTC_ALRMBR_MSK1  = 1UL << 7,               // Alarm B seconds mask
	RTC_ALRMBR_ST    = ((1UL << 3) - 1) << 4,  // Second tens in BCD format
	RTC_ALRMBR_SU    = ((1UL << 4) - 1) << 0,  // Second units in BCD format
};
inline void rtc_alrmbr_set_dt(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DT) | ((val << 28) & RTC_ALRMBR_DT);
}
inline void rtc_alrmbr_set_du(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DU) | ((val << 24) & RTC_ALRMBR_DU);
}
inline void rtc_alrmbr_set_ht(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HT) | ((val << 20) & RTC_ALRMBR_HT);
}
inline void rtc_alrmbr_set_hu(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HU) | ((val << 16) & RTC_ALRMBR_HU);
}
inline void rtc_alrmbr_set_mnt(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNT) | ((val << 12) & RTC_ALRMBR_MNT);
}
inline void rtc_alrmbr_set_mnu(struct RTC_Type* p, uint32_t val) {
	p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNU) | ((val << 8) & RTC_ALRMBR_MNU);
}
inline void rtc_alrmbr_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_ST) | ((val << 4) & RTC_ALRMBR_ST); }
inline void rtc_alrmbr_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_SU) | ((val << 0) & RTC_ALRMBR_SU); }
inline uint32_t rtc_alrmbr_get_dt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DT) >> 28; }
inline uint32_t rtc_alrmbr_get_du(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DU) >> 24; }
inline uint32_t rtc_alrmbr_get_ht(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HT) >> 20; }
inline uint32_t rtc_alrmbr_get_hu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HU) >> 16; }
inline uint32_t rtc_alrmbr_get_mnt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNT) >> 12; }
inline uint32_t rtc_alrmbr_get_mnu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNU) >> 8; }
inline uint32_t rtc_alrmbr_get_st(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_ST) >> 4; }
inline uint32_t rtc_alrmbr_get_su(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_SU) >> 0; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL << 4) - 1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS     = ((1UL << 15) - 1) << 0, // Sub seconds value
};
inline void rtc_alrmbssr_set_maskss(struct RTC_Type* p, uint32_t val) {
	p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val << 24) & RTC_ALRMBSSR_MASKSS);
}
inline void rtc_alrmbssr_set_ss(struct RTC_Type* p, uint32_t val) {
	p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val << 0) & RTC_ALRMBSSR_SS);
}
inline uint32_t rtc_alrmbssr_get_maskss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24; }
inline uint32_t rtc_alrmbssr_get_ss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_SS) >> 0; }

// RTC->SR status register
enum {
	RTC_SR_ITSF  = 1UL << 5, // ITSF
	RTC_SR_TSOVF = 1UL << 4, // TSOVF
	RTC_SR_TSF   = 1UL << 3, // TSF
	RTC_SR_WUTF  = 1UL << 2, // WUTF
	RTC_SR_ALRBF = 1UL << 1, // ALRBF
	RTC_SR_ALRAF = 1UL << 0, // ALRAF
};

// RTC->MISR status register
enum {
	RTC_MISR_ITSMF  = 1UL << 5, // ITSMF
	RTC_MISR_TSOVMF = 1UL << 4, // TSOVMF
	RTC_MISR_TSMF   = 1UL << 3, // TSMF
	RTC_MISR_WUTMF  = 1UL << 2, // WUTMF
	RTC_MISR_ALRBMF = 1UL << 1, // ALRBMF
	RTC_MISR_ALRAMF = 1UL << 0, // ALRAMF
};

// RTC->SCR status register
enum {
	RTC_SCR_CITSF  = 1UL << 5, // CITSF
	RTC_SCR_CTSOVF = 1UL << 4, // CTSOVF
	RTC_SCR_CTSF   = 1UL << 3, // CTSF
	RTC_SCR_CWUTF  = 1UL << 2, // CWUTF
	RTC_SCR_CALRBF = 1UL << 1, // CALRBF
	RTC_SCR_CALRAF = 1UL << 0, // CALRAF
};

/* Serial audio interface */
struct SAI_Type {
	uint8_t       RESERVED0[4]; // @0
	__IO uint32_t ACR1;         // @4 AConfiguration register 1
	__IO uint16_t ACR2;         // @8 AConfiguration register 2
	uint8_t       RESERVED1[2]; // @10
	__IO uint32_t AFRCR;        // @12 AFRCR
	__IO uint32_t ASLOTR;       // @16 ASlot register
	__IO uint8_t  AIM;          // @20 AInterrupt mask register2
	uint8_t       RESERVED2[3]; // @21
	__IO uint32_t ASR;          // @24 AStatus register
	__IO uint8_t  ACLRFR;       // @28 AClear flag register
	uint8_t       RESERVED3[3]; // @29
	__IO uint32_t ADR;          // @32 AData register
	__IO uint32_t BCR1;         // @36 BConfiguration register 1
	__IO uint16_t BCR2;         // @40 BConfiguration register 2
	uint8_t       RESERVED4[2]; // @42
	__IO uint32_t BFRCR;        // @44 BFRCR
	__IO uint32_t BSLOTR;       // @48 BSlot register
	__IO uint8_t  BIM;          // @52 BInterrupt mask register2
	uint8_t       RESERVED5[3]; // @53
	__I uint32_t  BSR;          // @56 BStatus register
	__O uint8_t   BCLRFR;       // @60 BClear flag register
	uint8_t       RESERVED6[3]; // @61
	__IO uint32_t BDR;          // @64 BData register
	__IO uint16_t PDMCR;        // @68 PDM control register
	uint8_t       RESERVED7[2]; // @70
	__IO uint32_t PDMDLY;       // @72 PDM delay register
};

// SAI->ACR1 AConfiguration register 1
enum {
	SAI_ACR1_MCKEN    = 1UL << 27,              // MCKEN
	SAI_ACR1_OSR      = 1UL << 26,              // OSR
	SAI_ACR1_MCJDIV   = ((1UL << 6) - 1) << 20, // Master clock divider
	SAI_ACR1_NODIV    = 1UL << 19,              // No divider
	SAI_ACR1_DMAEN    = 1UL << 17,              // DMA enable
	SAI_ACR1_SAIAEN   = 1UL << 16,              // Audio block A enable
	SAI_ACR1_OUTDRI   = 1UL << 13,              // Output drive
	SAI_ACR1_MONO     = 1UL << 12,              // Mono mode
	SAI_ACR1_SYNCEN   = ((1UL << 2) - 1) << 10, // Synchronization enable
	SAI_ACR1_CKSTR    = 1UL << 9,               // Clock strobing edge
	SAI_ACR1_LSBFIRST = 1UL << 8,               // Least significant bit first
	SAI_ACR1_DS       = ((1UL << 3) - 1) << 5,  // Data size
	SAI_ACR1_PRTCFG   = ((1UL << 2) - 1) << 2,  // Protocol configuration
	SAI_ACR1_MODE     = ((1UL << 2) - 1) << 0,  // Audio block mode
};
inline void sai_acr1_set_mcjdiv(struct SAI_Type* p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_MCJDIV) | ((val << 20) & SAI_ACR1_MCJDIV);
}
inline void sai_acr1_set_syncen(struct SAI_Type* p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_SYNCEN) | ((val << 10) & SAI_ACR1_SYNCEN);
}
inline void sai_acr1_set_ds(struct SAI_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI_ACR1_DS) | ((val << 5) & SAI_ACR1_DS); }
inline void sai_acr1_set_prtcfg(struct SAI_Type* p, uint32_t val) {
	p->ACR1 = (p->ACR1 & ~SAI_ACR1_PRTCFG) | ((val << 2) & SAI_ACR1_PRTCFG);
}
inline void     sai_acr1_set_mode(struct SAI_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI_ACR1_MODE) | ((val << 0) & SAI_ACR1_MODE); }
inline uint32_t sai_acr1_get_mcjdiv(struct SAI_Type* p) { return (p->ACR1 & SAI_ACR1_MCJDIV) >> 20; }
inline uint32_t sai_acr1_get_syncen(struct SAI_Type* p) { return (p->ACR1 & SAI_ACR1_SYNCEN) >> 10; }
inline uint32_t sai_acr1_get_ds(struct SAI_Type* p) { return (p->ACR1 & SAI_ACR1_DS) >> 5; }
inline uint32_t sai_acr1_get_prtcfg(struct SAI_Type* p) { return (p->ACR1 & SAI_ACR1_PRTCFG) >> 2; }
inline uint32_t sai_acr1_get_mode(struct SAI_Type* p) { return (p->ACR1 & SAI_ACR1_MODE) >> 0; }

// SAI->ACR2 AConfiguration register 2
enum {
	SAI_ACR2_COMP    = ((1UL << 2) - 1) << 14, // Companding mode
	SAI_ACR2_CPL     = 1UL << 13,              // Complement bit
	SAI_ACR2_MUTECN  = ((1UL << 6) - 1) << 7,  // Mute counter
	SAI_ACR2_MUTEVAL = 1UL << 6,               // Mute value
	SAI_ACR2_MUTE    = 1UL << 5,               // Mute
	SAI_ACR2_TRIS    = 1UL << 4,               // Tristate management on data line
	SAI_ACR2_FFLUS   = 1UL << 3,               // FIFO flush
	SAI_ACR2_FTH     = ((1UL << 3) - 1) << 0,  // FIFO threshold
};
inline void sai_acr2_set_comp(struct SAI_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI_ACR2_COMP) | ((val << 14) & SAI_ACR2_COMP); }
inline void sai_acr2_set_mutecn(struct SAI_Type* p, uint32_t val) {
	p->ACR2 = (p->ACR2 & ~SAI_ACR2_MUTECN) | ((val << 7) & SAI_ACR2_MUTECN);
}
inline void     sai_acr2_set_fth(struct SAI_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI_ACR2_FTH) | ((val << 0) & SAI_ACR2_FTH); }
inline uint32_t sai_acr2_get_comp(struct SAI_Type* p) { return (p->ACR2 & SAI_ACR2_COMP) >> 14; }
inline uint32_t sai_acr2_get_mutecn(struct SAI_Type* p) { return (p->ACR2 & SAI_ACR2_MUTECN) >> 7; }
inline uint32_t sai_acr2_get_fth(struct SAI_Type* p) { return (p->ACR2 & SAI_ACR2_FTH) >> 0; }

// SAI->AFRCR AFRCR
enum {
	SAI_AFRCR_FSOFF = 1UL << 18,             // Frame synchronization offset
	SAI_AFRCR_FSPOL = 1UL << 17,             // Frame synchronization polarity
	SAI_AFRCR_FSDEF = 1UL << 16,             // Frame synchronization definition
	SAI_AFRCR_FSALL = ((1UL << 7) - 1) << 8, // Frame synchronization active level length
	SAI_AFRCR_FRL   = ((1UL << 8) - 1) << 0, // Frame length
};
inline void sai_afrcr_set_fsall(struct SAI_Type* p, uint32_t val) {
	p->AFRCR = (p->AFRCR & ~SAI_AFRCR_FSALL) | ((val << 8) & SAI_AFRCR_FSALL);
}
inline void sai_afrcr_set_frl(struct SAI_Type* p, uint32_t val) { p->AFRCR = (p->AFRCR & ~SAI_AFRCR_FRL) | ((val << 0) & SAI_AFRCR_FRL); }
inline uint32_t sai_afrcr_get_fsall(struct SAI_Type* p) { return (p->AFRCR & SAI_AFRCR_FSALL) >> 8; }
inline uint32_t sai_afrcr_get_frl(struct SAI_Type* p) { return (p->AFRCR & SAI_AFRCR_FRL) >> 0; }

// SAI->ASLOTR ASlot register
enum {
	SAI_ASLOTR_SLOTEN = ((1UL << 16) - 1) << 16, // Slot enable
	SAI_ASLOTR_NBSLOT = ((1UL << 4) - 1) << 8,   // Number of slots in an audio frame
	SAI_ASLOTR_SLOTSZ = ((1UL << 2) - 1) << 6,   // Slot size
	SAI_ASLOTR_FBOFF  = ((1UL << 5) - 1) << 0,   // First bit offset
};
inline void sai_aslotr_set_sloten(struct SAI_Type* p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_SLOTEN) | ((val << 16) & SAI_ASLOTR_SLOTEN);
}
inline void sai_aslotr_set_nbslot(struct SAI_Type* p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_NBSLOT) | ((val << 8) & SAI_ASLOTR_NBSLOT);
}
inline void sai_aslotr_set_slotsz(struct SAI_Type* p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_SLOTSZ) | ((val << 6) & SAI_ASLOTR_SLOTSZ);
}
inline void sai_aslotr_set_fboff(struct SAI_Type* p, uint32_t val) {
	p->ASLOTR = (p->ASLOTR & ~SAI_ASLOTR_FBOFF) | ((val << 0) & SAI_ASLOTR_FBOFF);
}
inline uint32_t sai_aslotr_get_sloten(struct SAI_Type* p) { return (p->ASLOTR & SAI_ASLOTR_SLOTEN) >> 16; }
inline uint32_t sai_aslotr_get_nbslot(struct SAI_Type* p) { return (p->ASLOTR & SAI_ASLOTR_NBSLOT) >> 8; }
inline uint32_t sai_aslotr_get_slotsz(struct SAI_Type* p) { return (p->ASLOTR & SAI_ASLOTR_SLOTSZ) >> 6; }
inline uint32_t sai_aslotr_get_fboff(struct SAI_Type* p) { return (p->ASLOTR & SAI_ASLOTR_FBOFF) >> 0; }

// SAI->AIM AInterrupt mask register2
enum {
	SAI_AIM_LFSDET   = 1UL << 6, // Late frame synchronization detection interrupt enable
	SAI_AIM_AFSDETIE = 1UL << 5, // Anticipated frame synchronization detection interrupt enable
	SAI_AIM_CNRDYIE  = 1UL << 4, // Codec not ready interrupt enable
	SAI_AIM_FREQIE   = 1UL << 3, // FIFO request interrupt enable
	SAI_AIM_WCKCFG   = 1UL << 2, // Wrong clock configuration interrupt enable
	SAI_AIM_MUTEDET  = 1UL << 1, // Mute detection interrupt enable
	SAI_AIM_OVRUDRIE = 1UL << 0, // Overrun/underrun interrupt enable
};

// SAI->ASR AStatus register
enum {
	SAI_ASR_FLVL    = ((1UL << 3) - 1) << 16, // FIFO level threshold
	SAI_ASR_LFSDET  = 1UL << 6,               // Late frame synchronization detection
	SAI_ASR_AFSDET  = 1UL << 5,               // Anticipated frame synchronization detection
	SAI_ASR_CNRDY   = 1UL << 4,               // Codec not ready
	SAI_ASR_FREQ    = 1UL << 3,               // FIFO request
	SAI_ASR_WCKCFG  = 1UL << 2,               // Wrong clock configuration flag. This bit is read only
	SAI_ASR_MUTEDET = 1UL << 1,               // Mute detection
	SAI_ASR_OVRUDR  = 1UL << 0,               // Overrun / underrun
};
inline void     sai_asr_set_flvl(struct SAI_Type* p, uint32_t val) { p->ASR = (p->ASR & ~SAI_ASR_FLVL) | ((val << 16) & SAI_ASR_FLVL); }
inline uint32_t sai_asr_get_flvl(struct SAI_Type* p) { return (p->ASR & SAI_ASR_FLVL) >> 16; }

// SAI->ACLRFR AClear flag register
enum {
	SAI_ACLRFR_LFSDET  = 1UL << 6, // Clear late frame synchronization detection flag
	SAI_ACLRFR_CAFSDET = 1UL << 5, // Clear anticipated frame synchronization detection flag
	SAI_ACLRFR_CNRDY   = 1UL << 4, // Clear codec not ready flag
	SAI_ACLRFR_WCKCFG  = 1UL << 2, // Clear wrong clock configuration flag
	SAI_ACLRFR_MUTEDET = 1UL << 1, // Mute detection flag
	SAI_ACLRFR_OVRUDR  = 1UL << 0, // Clear overrun / underrun
};

// SAI->BCR1 BConfiguration register 1
enum {
	SAI_BCR1_MCKEN    = 1UL << 27,              // MCKEN
	SAI_BCR1_OSR      = 1UL << 26,              // OSR
	SAI_BCR1_MCJDIV   = ((1UL << 6) - 1) << 20, // Master clock divider
	SAI_BCR1_NODIV    = 1UL << 19,              // No divider
	SAI_BCR1_DMAEN    = 1UL << 17,              // DMA enable
	SAI_BCR1_SAIBEN   = 1UL << 16,              // Audio block B enable
	SAI_BCR1_OUTDRI   = 1UL << 13,              // Output drive
	SAI_BCR1_MONO     = 1UL << 12,              // Mono mode
	SAI_BCR1_SYNCEN   = ((1UL << 2) - 1) << 10, // Synchronization enable
	SAI_BCR1_CKSTR    = 1UL << 9,               // Clock strobing edge
	SAI_BCR1_LSBFIRST = 1UL << 8,               // Least significant bit first
	SAI_BCR1_DS       = ((1UL << 3) - 1) << 5,  // Data size
	SAI_BCR1_PRTCFG   = ((1UL << 2) - 1) << 2,  // Protocol configuration
	SAI_BCR1_MODE     = ((1UL << 2) - 1) << 0,  // Audio block mode
};
inline void sai_bcr1_set_mcjdiv(struct SAI_Type* p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_MCJDIV) | ((val << 20) & SAI_BCR1_MCJDIV);
}
inline void sai_bcr1_set_syncen(struct SAI_Type* p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_SYNCEN) | ((val << 10) & SAI_BCR1_SYNCEN);
}
inline void sai_bcr1_set_ds(struct SAI_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI_BCR1_DS) | ((val << 5) & SAI_BCR1_DS); }
inline void sai_bcr1_set_prtcfg(struct SAI_Type* p, uint32_t val) {
	p->BCR1 = (p->BCR1 & ~SAI_BCR1_PRTCFG) | ((val << 2) & SAI_BCR1_PRTCFG);
}
inline void     sai_bcr1_set_mode(struct SAI_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI_BCR1_MODE) | ((val << 0) & SAI_BCR1_MODE); }
inline uint32_t sai_bcr1_get_mcjdiv(struct SAI_Type* p) { return (p->BCR1 & SAI_BCR1_MCJDIV) >> 20; }
inline uint32_t sai_bcr1_get_syncen(struct SAI_Type* p) { return (p->BCR1 & SAI_BCR1_SYNCEN) >> 10; }
inline uint32_t sai_bcr1_get_ds(struct SAI_Type* p) { return (p->BCR1 & SAI_BCR1_DS) >> 5; }
inline uint32_t sai_bcr1_get_prtcfg(struct SAI_Type* p) { return (p->BCR1 & SAI_BCR1_PRTCFG) >> 2; }
inline uint32_t sai_bcr1_get_mode(struct SAI_Type* p) { return (p->BCR1 & SAI_BCR1_MODE) >> 0; }

// SAI->BCR2 BConfiguration register 2
enum {
	SAI_BCR2_COMP    = ((1UL << 2) - 1) << 14, // Companding mode
	SAI_BCR2_CPL     = 1UL << 13,              // Complement bit
	SAI_BCR2_MUTECN  = ((1UL << 6) - 1) << 7,  // Mute counter
	SAI_BCR2_MUTEVAL = 1UL << 6,               // Mute value
	SAI_BCR2_MUTE    = 1UL << 5,               // Mute
	SAI_BCR2_TRIS    = 1UL << 4,               // Tristate management on data line
	SAI_BCR2_FFLUS   = 1UL << 3,               // FIFO flush
	SAI_BCR2_FTH     = ((1UL << 3) - 1) << 0,  // FIFO threshold
};
inline void sai_bcr2_set_comp(struct SAI_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI_BCR2_COMP) | ((val << 14) & SAI_BCR2_COMP); }
inline void sai_bcr2_set_mutecn(struct SAI_Type* p, uint32_t val) {
	p->BCR2 = (p->BCR2 & ~SAI_BCR2_MUTECN) | ((val << 7) & SAI_BCR2_MUTECN);
}
inline void     sai_bcr2_set_fth(struct SAI_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI_BCR2_FTH) | ((val << 0) & SAI_BCR2_FTH); }
inline uint32_t sai_bcr2_get_comp(struct SAI_Type* p) { return (p->BCR2 & SAI_BCR2_COMP) >> 14; }
inline uint32_t sai_bcr2_get_mutecn(struct SAI_Type* p) { return (p->BCR2 & SAI_BCR2_MUTECN) >> 7; }
inline uint32_t sai_bcr2_get_fth(struct SAI_Type* p) { return (p->BCR2 & SAI_BCR2_FTH) >> 0; }

// SAI->BFRCR BFRCR
enum {
	SAI_BFRCR_FSOFF = 1UL << 18,             // Frame synchronization offset
	SAI_BFRCR_FSPOL = 1UL << 17,             // Frame synchronization polarity
	SAI_BFRCR_FSDEF = 1UL << 16,             // Frame synchronization definition
	SAI_BFRCR_FSALL = ((1UL << 7) - 1) << 8, // Frame synchronization active level length
	SAI_BFRCR_FRL   = ((1UL << 8) - 1) << 0, // Frame length
};
inline void sai_bfrcr_set_fsall(struct SAI_Type* p, uint32_t val) {
	p->BFRCR = (p->BFRCR & ~SAI_BFRCR_FSALL) | ((val << 8) & SAI_BFRCR_FSALL);
}
inline void sai_bfrcr_set_frl(struct SAI_Type* p, uint32_t val) { p->BFRCR = (p->BFRCR & ~SAI_BFRCR_FRL) | ((val << 0) & SAI_BFRCR_FRL); }
inline uint32_t sai_bfrcr_get_fsall(struct SAI_Type* p) { return (p->BFRCR & SAI_BFRCR_FSALL) >> 8; }
inline uint32_t sai_bfrcr_get_frl(struct SAI_Type* p) { return (p->BFRCR & SAI_BFRCR_FRL) >> 0; }

// SAI->BSLOTR BSlot register
enum {
	SAI_BSLOTR_SLOTEN = ((1UL << 16) - 1) << 16, // Slot enable
	SAI_BSLOTR_NBSLOT = ((1UL << 4) - 1) << 8,   // Number of slots in an audio frame
	SAI_BSLOTR_SLOTSZ = ((1UL << 2) - 1) << 6,   // Slot size
	SAI_BSLOTR_FBOFF  = ((1UL << 5) - 1) << 0,   // First bit offset
};
inline void sai_bslotr_set_sloten(struct SAI_Type* p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_SLOTEN) | ((val << 16) & SAI_BSLOTR_SLOTEN);
}
inline void sai_bslotr_set_nbslot(struct SAI_Type* p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_NBSLOT) | ((val << 8) & SAI_BSLOTR_NBSLOT);
}
inline void sai_bslotr_set_slotsz(struct SAI_Type* p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_SLOTSZ) | ((val << 6) & SAI_BSLOTR_SLOTSZ);
}
inline void sai_bslotr_set_fboff(struct SAI_Type* p, uint32_t val) {
	p->BSLOTR = (p->BSLOTR & ~SAI_BSLOTR_FBOFF) | ((val << 0) & SAI_BSLOTR_FBOFF);
}
inline uint32_t sai_bslotr_get_sloten(struct SAI_Type* p) { return (p->BSLOTR & SAI_BSLOTR_SLOTEN) >> 16; }
inline uint32_t sai_bslotr_get_nbslot(struct SAI_Type* p) { return (p->BSLOTR & SAI_BSLOTR_NBSLOT) >> 8; }
inline uint32_t sai_bslotr_get_slotsz(struct SAI_Type* p) { return (p->BSLOTR & SAI_BSLOTR_SLOTSZ) >> 6; }
inline uint32_t sai_bslotr_get_fboff(struct SAI_Type* p) { return (p->BSLOTR & SAI_BSLOTR_FBOFF) >> 0; }

// SAI->BIM BInterrupt mask register2
enum {
	SAI_BIM_LFSDETIE = 1UL << 6, // Late frame synchronization detection interrupt enable
	SAI_BIM_AFSDETIE = 1UL << 5, // Anticipated frame synchronization detection interrupt enable
	SAI_BIM_CNRDYIE  = 1UL << 4, // Codec not ready interrupt enable
	SAI_BIM_FREQIE   = 1UL << 3, // FIFO request interrupt enable
	SAI_BIM_WCKCFG   = 1UL << 2, // Wrong clock configuration interrupt enable
	SAI_BIM_MUTEDET  = 1UL << 1, // Mute detection interrupt enable
	SAI_BIM_OVRUDRIE = 1UL << 0, // Overrun/underrun interrupt enable
};

// SAI->BSR BStatus register
enum {
	SAI_BSR_FLVL    = ((1UL << 3) - 1) << 16, // FIFO level threshold
	SAI_BSR_LFSDET  = 1UL << 6,               // Late frame synchronization detection
	SAI_BSR_AFSDET  = 1UL << 5,               // Anticipated frame synchronization detection
	SAI_BSR_CNRDY   = 1UL << 4,               // Codec not ready
	SAI_BSR_FREQ    = 1UL << 3,               // FIFO request
	SAI_BSR_WCKCFG  = 1UL << 2,               // Wrong clock configuration flag
	SAI_BSR_MUTEDET = 1UL << 1,               // Mute detection
	SAI_BSR_OVRUDR  = 1UL << 0,               // Overrun / underrun
};
inline uint32_t sai_bsr_get_flvl(struct SAI_Type* p) { return (p->BSR & SAI_BSR_FLVL) >> 16; }

// SAI->BCLRFR BClear flag register
enum {
	SAI_BCLRFR_LFSDET  = 1UL << 6, // Clear late frame synchronization detection flag
	SAI_BCLRFR_CAFSDET = 1UL << 5, // Clear anticipated frame synchronization detection flag
	SAI_BCLRFR_CNRDY   = 1UL << 4, // Clear codec not ready flag
	SAI_BCLRFR_WCKCFG  = 1UL << 2, // Clear wrong clock configuration flag
	SAI_BCLRFR_MUTEDET = 1UL << 1, // Mute detection flag
	SAI_BCLRFR_OVRUDR  = 1UL << 0, // Clear overrun / underrun
};

// SAI->PDMCR PDM control register
enum {
	SAI_PDMCR_CKEN4  = 1UL << 11,             // CKEN4
	SAI_PDMCR_CKEN3  = 1UL << 10,             // CKEN3
	SAI_PDMCR_CKEN2  = 1UL << 9,              // CKEN2
	SAI_PDMCR_CKEN1  = 1UL << 8,              // CKEN1
	SAI_PDMCR_MICNBR = ((1UL << 2) - 1) << 4, // MICNBR
	SAI_PDMCR_PDMEN  = 1UL << 0,              // PDMEN
};
inline void sai_pdmcr_set_micnbr(struct SAI_Type* p, uint32_t val) {
	p->PDMCR = (p->PDMCR & ~SAI_PDMCR_MICNBR) | ((val << 4) & SAI_PDMCR_MICNBR);
}
inline uint32_t sai_pdmcr_get_micnbr(struct SAI_Type* p) { return (p->PDMCR & SAI_PDMCR_MICNBR) >> 4; }

// SAI->PDMDLY PDM delay register
enum {
	SAI_PDMDLY_DLYM4R = ((1UL << 3) - 1) << 28, // DLYM4R
	SAI_PDMDLY_DLYM4L = ((1UL << 3) - 1) << 24, // DLYM4L
	SAI_PDMDLY_DLYM3R = ((1UL << 3) - 1) << 20, // DLYM3R
	SAI_PDMDLY_DLYM3L = ((1UL << 3) - 1) << 16, // DLYM3L
	SAI_PDMDLY_DLYM2R = ((1UL << 3) - 1) << 12, // DLYM2R
	SAI_PDMDLY_DLYM2L = ((1UL << 3) - 1) << 8,  // DLYM2L
	SAI_PDMDLY_DLYM1R = ((1UL << 3) - 1) << 4,  // DLYM1R
	SAI_PDMDLY_DLYM1L = ((1UL << 3) - 1) << 0,  // DLYM1L
};
inline void sai_pdmdly_set_dlym4r(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM4R) | ((val << 28) & SAI_PDMDLY_DLYM4R);
}
inline void sai_pdmdly_set_dlym4l(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM4L) | ((val << 24) & SAI_PDMDLY_DLYM4L);
}
inline void sai_pdmdly_set_dlym3r(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM3R) | ((val << 20) & SAI_PDMDLY_DLYM3R);
}
inline void sai_pdmdly_set_dlym3l(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM3L) | ((val << 16) & SAI_PDMDLY_DLYM3L);
}
inline void sai_pdmdly_set_dlym2r(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM2R) | ((val << 12) & SAI_PDMDLY_DLYM2R);
}
inline void sai_pdmdly_set_dlym2l(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM2L) | ((val << 8) & SAI_PDMDLY_DLYM2L);
}
inline void sai_pdmdly_set_dlym1r(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM1R) | ((val << 4) & SAI_PDMDLY_DLYM1R);
}
inline void sai_pdmdly_set_dlym1l(struct SAI_Type* p, uint32_t val) {
	p->PDMDLY = (p->PDMDLY & ~SAI_PDMDLY_DLYM1L) | ((val << 0) & SAI_PDMDLY_DLYM1L);
}
inline uint32_t sai_pdmdly_get_dlym4r(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM4R) >> 28; }
inline uint32_t sai_pdmdly_get_dlym4l(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM4L) >> 24; }
inline uint32_t sai_pdmdly_get_dlym3r(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM3R) >> 20; }
inline uint32_t sai_pdmdly_get_dlym3l(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM3L) >> 16; }
inline uint32_t sai_pdmdly_get_dlym2r(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM2R) >> 12; }
inline uint32_t sai_pdmdly_get_dlym2l(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM2L) >> 8; }
inline uint32_t sai_pdmdly_get_dlym1r(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM1R) >> 4; }
inline uint32_t sai_pdmdly_get_dlym1l(struct SAI_Type* p) { return (p->PDMDLY & SAI_PDMDLY_DLYM1L) >> 0; }

/* System control block */
struct SCB_Type {
	__I uint32_t  CPUID;                // @0 CPUID base register
	__IO uint32_t ICSR;                 // @4 Interrupt control and state register
	__IO uint32_t VTOR;                 // @8 Vector table offset register
	__IO uint32_t AIRCR;                // @12 Application interrupt and reset control register
	__IO uint8_t  SCR;                  // @16 System control register
	uint8_t       RESERVED0[3];         // @17
	__IO uint16_t CCR;                  // @20 Configuration and control register
	uint8_t       RESERVED1[2];         // @22
	__IO uint32_t SHPR1;                // @24 System handler priority registers
	__IO uint32_t SHPR2;                // @28 System handler priority registers
	__IO uint32_t SHPR3;                // @32 System handler priority registers
	__IO uint32_t SHCRS;                // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR;                 // @44 Hard fault status register
	uint8_t       RESERVED2[4];         // @48
	__IO uint32_t MMFAR;                // @52 Memory management fault address register
	__IO uint32_t BFAR;                 // @56 Bus fault address register
	__IO uint32_t AFSR;                 // @60 Auxiliary fault status register
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL << 8) - 1) << 24, // Implementer code
	SCB_CPUID_VARIANT     = ((1UL << 4) - 1) << 20, // Variant number
	SCB_CPUID_CONSTANT    = ((1UL << 4) - 1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO      = ((1UL << 12) - 1) << 4, // Part number of the processor
	SCB_CPUID_REVISION    = ((1UL << 4) - 1) << 0,  // Revision number
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20; }
inline uint32_t scb_cpuid_get_constant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_CONSTANT) >> 16; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET  = 1UL << 31,              // NMI set-pending bit.
	SCB_ICSR_PENDSVSET   = 1UL << 28,              // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR   = 1UL << 27,              // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET   = 1UL << 26,              // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR   = 1UL << 25,              // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING  = 1UL << 22,              // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL << 7) - 1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE   = 1UL << 11,              // Return to base level
	SCB_ICSR_VECTACTIVE  = ((1UL << 9) - 1) << 0,  // Active vector
};
inline void scb_icsr_set_vectpending(struct SCB_Type* p, uint32_t val) {
	p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val << 12) & SCB_ICSR_VECTPENDING);
}
inline void scb_icsr_set_vectactive(struct SCB_Type* p, uint32_t val) {
	p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val << 0) & SCB_ICSR_VECTACTIVE);
}
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL << 21) - 1) << 9, // Vector table base offset field
};
inline void scb_vtor_set_tbloff(struct SCB_Type* p, uint32_t val) {
	p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val << 9) & SCB_VTOR_TBLOFF);
}
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type* p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 9; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT   = ((1UL << 16) - 1) << 16, // Register key
	SCB_AIRCR_ENDIANESS     = 1UL << 15,               // ENDIANESS
	SCB_AIRCR_PRIGROUP      = ((1UL << 3) - 1) << 8,   // PRIGROUP
	SCB_AIRCR_SYSRESETREQ   = 1UL << 2,                // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL << 1,                // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET     = 1UL << 0,                // VECTRESET
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type* p, uint32_t val) {
	p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val << 16) & SCB_AIRCR_VECTKEYSTAT);
}
inline void scb_aircr_set_prigroup(struct SCB_Type* p, uint32_t val) {
	p->AIRCR = (p->AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val << 8) & SCB_AIRCR_PRIGROUP);
}
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16; }
inline uint32_t scb_aircr_get_prigroup(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_PRIGROUP) >> 8; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND  = 1UL << 4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP   = 1UL << 2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL << 1, // SLEEPONEXIT
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN       = 1UL << 9, // STKALIGN
	SCB_CCR_BFHFNMIGN      = 1UL << 8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP      = 1UL << 4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP   = 1UL << 3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND   = 1UL << 1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL << 0, // Configures how the processor enters Thread mode
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL << 8) - 1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL << 8) - 1) << 8,  // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL << 8) - 1) << 0,  // Priority of system handler 4
};
inline void scb_shpr1_set_pri_6(struct SCB_Type* p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_6) | ((val << 16) & SCB_SHPR1_PRI_6);
}
inline void scb_shpr1_set_pri_5(struct SCB_Type* p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_5) | ((val << 8) & SCB_SHPR1_PRI_5);
}
inline void scb_shpr1_set_pri_4(struct SCB_Type* p, uint32_t val) {
	p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_4) | ((val << 0) & SCB_SHPR1_PRI_4);
}
inline uint32_t scb_shpr1_get_pri_6(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_6) >> 16; }
inline uint32_t scb_shpr1_get_pri_5(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_5) >> 8; }
inline uint32_t scb_shpr1_get_pri_4(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_4) >> 0; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL << 8) - 1) << 24, // Priority of system handler 11
};
inline void scb_shpr2_set_pri_11(struct SCB_Type* p, uint32_t val) {
	p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val << 24) & SCB_SHPR2_PRI_11);
}
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type* p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL << 8) - 1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL << 8) - 1) << 16, // Priority of system handler 14
};
inline void scb_shpr3_set_pri_15(struct SCB_Type* p, uint32_t val) {
	p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val << 24) & SCB_SHPR3_PRI_15);
}
inline void scb_shpr3_set_pri_14(struct SCB_Type* p, uint32_t val) {
	p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val << 16) & SCB_SHPR3_PRI_14);
}
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16; }

// SCB->SHCRS System handler control and state register
enum {
	SCB_SHCRS_USGFAULTENA    = 1UL << 18, // Usage fault enable bit
	SCB_SHCRS_BUSFAULTENA    = 1UL << 17, // Bus fault enable bit
	SCB_SHCRS_MEMFAULTENA    = 1UL << 16, // Memory management fault enable bit
	SCB_SHCRS_SVCALLPENDED   = 1UL << 15, // SVC call pending bit
	SCB_SHCRS_BUSFAULTPENDED = 1UL << 14, // Bus fault exception pending bit
	SCB_SHCRS_MEMFAULTPENDED = 1UL << 13, // Memory management fault exception pending bit
	SCB_SHCRS_USGFAULTPENDED = 1UL << 12, // Usage fault exception pending bit
	SCB_SHCRS_SYSTICKACT     = 1UL << 11, // SysTick exception active bit
	SCB_SHCRS_PENDSVACT      = 1UL << 10, // PendSV exception active bit
	SCB_SHCRS_MONITORACT     = 1UL << 8,  // Debug monitor active bit
	SCB_SHCRS_SVCALLACT      = 1UL << 7,  // SVC call active bit
	SCB_SHCRS_USGFAULTACT    = 1UL << 3,  // Usage fault exception active bit
	SCB_SHCRS_BUSFAULTACT    = 1UL << 1,  // Bus fault exception active bit
	SCB_SHCRS_MEMFAULTACT    = 1UL << 0,  // Memory management fault exception active bit
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO   = 1UL << 25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED   = 1UL << 24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP        = 1UL << 19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC       = 1UL << 18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE    = 1UL << 17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR  = 1UL << 16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID   = 1UL << 15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR      = 1UL << 13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR      = 1UL << 12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR    = 1UL << 11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL << 10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR   = 1UL << 9,  // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR     = 1UL << 8,  // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID   = 1UL << 7,  // Memory Management Fault Address Register (MMAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR     = 1UL << 5,  // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR     = 1UL << 4,  // Memory manager fault on stacking for exception entry.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR   = 1UL << 3,  // Memory manager fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL    = 1UL << 1,  // Instruction access violation flag
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL << 31, // Reserved for Debug use
	SCB_HFSR_FORCED   = 1UL << 30, // Forced hard fault
	SCB_HFSR_VECTTBL  = 1UL << 1,  // Vector table hard fault
};

/* System control block ACTLR */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISOOFP    = 1UL << 9, // DISOOFP
	SCB_ACTRL_ACTRL_DISFPCA    = 1UL << 8, // DISFPCA
	SCB_ACTRL_ACTRL_DISFOLD    = 1UL << 2, // DISFOLD
	SCB_ACTRL_ACTRL_DISDEFWBUF = 1UL << 1, // DISDEFWBUF
	SCB_ACTRL_ACTRL_DISMCYCINT = 1UL << 0, // DISMCYCINT
};

/* Serial peripheral interface/Inter-IC sound */
struct SPI1_Type {
	__IO uint16_t CR1;          // @0 control register 1
	uint8_t       RESERVED0[2]; // @2
	__IO uint16_t CR2;          // @4 control register 2
	uint8_t       RESERVED1[2]; // @6
	__IO uint16_t SR;           // @8 status register
	uint8_t       RESERVED2[2]; // @10
	__IO uint16_t DR;           // @12 data register
	uint8_t       RESERVED3[2]; // @14
	__IO uint16_t CRCPR;        // @16 CRC polynomial register
	uint8_t       RESERVED4[2]; // @18
	__I uint16_t  RXCRCR;       // @20 RX CRC register
	uint8_t       RESERVED5[2]; // @22
	__I uint16_t  TXCRCR;       // @24 TX CRC register
	uint8_t       RESERVED6[2]; // @26
	__IO uint16_t I2SCFGR;      // @28 configuration register
	uint8_t       RESERVED7[2]; // @30
	__IO uint16_t I2SPR;        // @32 prescaler register
};

// SPI1->CR1 control register 1
enum {
	SPI1_CR1_BIDIMODE = 1UL << 15,             // Bidirectional data mode enable
	SPI1_CR1_BIDIOE   = 1UL << 14,             // Output enable in bidirectional mode
	SPI1_CR1_CRCEN    = 1UL << 13,             // Hardware CRC calculation enable
	SPI1_CR1_CRCNEXT  = 1UL << 12,             // CRC transfer next
	SPI1_CR1_DFF      = 1UL << 11,             // Data frame format
	SPI1_CR1_RXONLY   = 1UL << 10,             // Receive only
	SPI1_CR1_SSM      = 1UL << 9,              // Software slave management
	SPI1_CR1_SSI      = 1UL << 8,              // Internal slave select
	SPI1_CR1_LSBFIRST = 1UL << 7,              // Frame format
	SPI1_CR1_SPE      = 1UL << 6,              // SPI enable
	SPI1_CR1_BR       = ((1UL << 3) - 1) << 3, // Baud rate control
	SPI1_CR1_MSTR     = 1UL << 2,              // Master selection
	SPI1_CR1_CPOL     = 1UL << 1,              // Clock polarity
	SPI1_CR1_CPHA     = 1UL << 0,              // Clock phase
};
inline void     spi1_cr1_set_br(struct SPI1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI1_CR1_BR) | ((val << 3) & SPI1_CR1_BR); }
inline uint32_t spi1_cr1_get_br(struct SPI1_Type* p) { return (p->CR1 & SPI1_CR1_BR) >> 3; }

// SPI1->CR2 control register 2
enum {
	SPI1_CR2_LDMA_TX = 1UL << 14,             // Last DMA transfer for transmission
	SPI1_CR2_LDMA_RX = 1UL << 13,             // Last DMA transfer for reception
	SPI1_CR2_FRXTH   = 1UL << 12,             // FIFO reception threshold
	SPI1_CR2_DS      = ((1UL << 4) - 1) << 8, // Data size
	SPI1_CR2_TXEIE   = 1UL << 7,              // Tx buffer empty interrupt enable
	SPI1_CR2_RXNEIE  = 1UL << 6,              // RX buffer not empty interrupt enable
	SPI1_CR2_ERRIE   = 1UL << 5,              // Error interrupt enable
	SPI1_CR2_FRF     = 1UL << 4,              // Frame format
	SPI1_CR2_NSSP    = 1UL << 3,              // NSS pulse management
	SPI1_CR2_SSOE    = 1UL << 2,              // SS output enable
	SPI1_CR2_TXDMAEN = 1UL << 1,              // Tx buffer DMA enable
	SPI1_CR2_RXDMAEN = 1UL << 0,              // Rx buffer DMA enable
};
inline void     spi1_cr2_set_ds(struct SPI1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_DS) | ((val << 8) & SPI1_CR2_DS); }
inline uint32_t spi1_cr2_get_ds(struct SPI1_Type* p) { return (p->CR2 & SPI1_CR2_DS) >> 8; }

// SPI1->SR status register
enum {
	SPI1_SR_FTLVL  = ((1UL << 2) - 1) << 11, // FIFO transmission level
	SPI1_SR_FRLVL  = ((1UL << 2) - 1) << 9,  // FIFO reception level
	SPI1_SR_TIFRFE = 1UL << 8,               // TI frame format error
	SPI1_SR_BSY    = 1UL << 7,               // Busy flag
	SPI1_SR_OVR    = 1UL << 6,               // Overrun flag
	SPI1_SR_MODF   = 1UL << 5,               // Mode fault
	SPI1_SR_CRCERR = 1UL << 4,               // CRC error flag
	SPI1_SR_TXE    = 1UL << 1,               // Transmit buffer empty
	SPI1_SR_RXNE   = 1UL << 0,               // Receive buffer not empty
};
inline void     spi1_sr_set_ftlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FTLVL) | ((val << 11) & SPI1_SR_FTLVL); }
inline void     spi1_sr_set_frlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FRLVL) | ((val << 9) & SPI1_SR_FRLVL); }
inline uint32_t spi1_sr_get_ftlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FTLVL) >> 11; }
inline uint32_t spi1_sr_get_frlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FRLVL) >> 9; }

// SPI1->I2SCFGR configuration register
enum {
	SPI1_I2SCFGR_I2SMOD  = 1UL << 11,             // I2SMOD
	SPI1_I2SCFGR_I2SE    = 1UL << 10,             // I2SE
	SPI1_I2SCFGR_I2SCFG  = ((1UL << 2) - 1) << 8, // I2SCFG
	SPI1_I2SCFGR_PCMSYNC = 1UL << 7,              // PCMSYNC
	SPI1_I2SCFGR_I2SSTD  = ((1UL << 2) - 1) << 4, // I2SSTD
	SPI1_I2SCFGR_CKPOL   = 1UL << 3,              // CKPOL
	SPI1_I2SCFGR_DATLEN  = ((1UL << 2) - 1) << 1, // DATLEN
	SPI1_I2SCFGR_CHLEN   = 1UL << 0,              // CHLEN
};
inline void spi1_i2scfgr_set_i2scfg(struct SPI1_Type* p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SCFG) | ((val << 8) & SPI1_I2SCFGR_I2SCFG);
}
inline void spi1_i2scfgr_set_i2sstd(struct SPI1_Type* p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_I2SSTD) | ((val << 4) & SPI1_I2SCFGR_I2SSTD);
}
inline void spi1_i2scfgr_set_datlen(struct SPI1_Type* p, uint32_t val) {
	p->I2SCFGR = (p->I2SCFGR & ~SPI1_I2SCFGR_DATLEN) | ((val << 1) & SPI1_I2SCFGR_DATLEN);
}
inline uint32_t spi1_i2scfgr_get_i2scfg(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SCFG) >> 8; }
inline uint32_t spi1_i2scfgr_get_i2sstd(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_I2SSTD) >> 4; }
inline uint32_t spi1_i2scfgr_get_datlen(struct SPI1_Type* p) { return (p->I2SCFGR & SPI1_I2SCFGR_DATLEN) >> 1; }

// SPI1->I2SPR prescaler register
enum {
	SPI1_I2SPR_MCKOE  = 1UL << 9,              // MCKOE
	SPI1_I2SPR_ODD    = 1UL << 8,              // ODD
	SPI1_I2SPR_I2SDIV = ((1UL << 8) - 1) << 0, // I2SDIV
};
inline void spi1_i2spr_set_i2sdiv(struct SPI1_Type* p, uint32_t val) {
	p->I2SPR = (p->I2SPR & ~SPI1_I2SPR_I2SDIV) | ((val << 0) & SPI1_I2SPR_I2SDIV);
}
inline uint32_t spi1_i2spr_get_i2sdiv(struct SPI1_Type* p) { return (p->I2SPR & SPI1_I2SPR_I2SDIV) >> 0; }

/* SysTick timer */
struct STK_Type {
	__IO uint32_t CTRL;  // @0 SysTick control and status register
	__IO uint32_t LOAD;  // @4 SysTick reload value register
	__IO uint32_t VAL;   // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};

// STK->CTRL SysTick control and status register
enum {
	STK_CTRL_COUNTFLAG = 1UL << 16, // COUNTFLAG
	STK_CTRL_CLKSOURCE = 1UL << 2,  // Clock source selection
	STK_CTRL_TICKINT   = 1UL << 1,  // SysTick exception request enable
	STK_CTRL_ENABLE    = 1UL << 0,  // Counter enable
};

// STK->LOAD SysTick reload value register
enum {
	STK_LOAD_RELOAD = ((1UL << 24) - 1) << 0, // RELOAD value
};
inline void stk_load_set_reload(struct STK_Type* p, uint32_t val) {
	p->LOAD = (p->LOAD & ~STK_LOAD_RELOAD) | ((val << 0) & STK_LOAD_RELOAD);
}
inline uint32_t stk_load_get_reload(struct STK_Type* p) { return (p->LOAD & STK_LOAD_RELOAD) >> 0; }

// STK->VAL SysTick current value register
enum {
	STK_VAL_CURRENT = ((1UL << 24) - 1) << 0, // Current counter value
};
inline void stk_val_set_current(struct STK_Type* p, uint32_t val) { p->VAL = (p->VAL & ~STK_VAL_CURRENT) | ((val << 0) & STK_VAL_CURRENT); }
inline uint32_t stk_val_get_current(struct STK_Type* p) { return (p->VAL & STK_VAL_CURRENT) >> 0; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL << 31,              // NOREF flag. Reads as zero
	STK_CALIB_SKEW  = 1UL << 30,              // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL << 24) - 1) << 0, // Calibration value
};
inline void stk_calib_set_tenms(struct STK_Type* p, uint32_t val) {
	p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val << 0) & STK_CALIB_TENMS);
}
inline uint32_t stk_calib_get_tenms(struct STK_Type* p) { return (p->CALIB & STK_CALIB_TENMS) >> 0; }

/* System configuration controller */
struct SYSCFG_Type {
	__IO uint16_t MEMRMP;       // @0 Remap Memory register
	uint8_t       RESERVED0[2]; // @2
	__IO uint32_t CFGR1;        // @4 peripheral mode configuration register
	__IO uint16_t EXTICR1;      // @8 external interrupt configuration register 1
	uint8_t       RESERVED1[2]; // @10
	__IO uint16_t EXTICR2;      // @12 external interrupt configuration register 2
	uint8_t       RESERVED2[2]; // @14
	__IO uint16_t EXTICR3;      // @16 external interrupt configuration register 3
	uint8_t       RESERVED3[2]; // @18
	__IO uint16_t EXTICR4;      // @20 external interrupt configuration register 4
	uint8_t       RESERVED4[2]; // @22
	__IO uint8_t  SCSR;         // @24 CCM SRAM control and status register
	uint8_t       RESERVED5[3]; // @25
	__IO uint16_t CFGR2;        // @28 configuration register 2
	uint8_t       RESERVED6[2]; // @30
	__IO uint32_t SWPR;         // @32 SRAM Write protection register 1
	__O uint8_t   SKR;          // @36 SRAM2 Key Register
};

// SYSCFG->MEMRMP Remap Memory register
enum {
	SYSCFG_MEMRMP_FB_MODE  = 1UL << 8,              // User Flash Bank mode
	SYSCFG_MEMRMP_MEM_MODE = ((1UL << 3) - 1) << 0, // Memory mapping selection
};
inline void syscfg_memrmp_set_mem_mode(struct SYSCFG_Type* p, uint32_t val) {
	p->MEMRMP = (p->MEMRMP & ~SYSCFG_MEMRMP_MEM_MODE) | ((val << 0) & SYSCFG_MEMRMP_MEM_MODE);
}
inline uint32_t syscfg_memrmp_get_mem_mode(struct SYSCFG_Type* p) { return (p->MEMRMP & SYSCFG_MEMRMP_MEM_MODE) >> 0; }

// SYSCFG->CFGR1 peripheral mode configuration register
enum {
	SYSCFG_CFGR1_FPU_IE      = ((1UL << 6) - 1) << 26, // FPU Interrupts Enable
	SYSCFG_CFGR1_I2C4_FMP    = 1UL << 23,              // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C3_FMP    = 1UL << 22,              // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C2_FMP    = 1UL << 21,              // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C1_FMP    = 1UL << 20,              // I2C1 FM+ drive capability enable
	SYSCFG_CFGR1_I2C_PB9_FMP = 1UL << 19,              // FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB8_FMP = 1UL << 18,              // FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB7_FMP = 1UL << 17,              // FM+ drive capability on PB6
	SYSCFG_CFGR1_I2C_PB6_FMP = 1UL << 16,              // FM+ drive capability on PB6
	SYSCFG_CFGR1_ANASWVDD    = 1UL << 9,               // GPIO analog switch control voltage selection
	SYSCFG_CFGR1_BOOSTEN     = 1UL << 8,               // BOOSTEN
};
inline void syscfg_cfgr1_set_fpu_ie(struct SYSCFG_Type* p, uint32_t val) {
	p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_FPU_IE) | ((val << 26) & SYSCFG_CFGR1_FPU_IE);
}
inline uint32_t syscfg_cfgr1_get_fpu_ie(struct SYSCFG_Type* p) { return (p->CFGR1 & SYSCFG_CFGR1_FPU_IE) >> 26; }

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI2 = ((1UL << 4) - 1) << 8,  // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI1 = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 0 to 3)
	SYSCFG_EXTICR1_EXTI0 = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 0 to 3)
};
inline void syscfg_exticr1_set_exti3(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val << 12) & SYSCFG_EXTICR1_EXTI3);
}
inline void syscfg_exticr1_set_exti2(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val << 8) & SYSCFG_EXTICR1_EXTI2);
}
inline void syscfg_exticr1_set_exti1(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val << 4) & SYSCFG_EXTICR1_EXTI1);
}
inline void syscfg_exticr1_set_exti0(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val << 0) & SYSCFG_EXTICR1_EXTI0);
}
inline uint32_t syscfg_exticr1_get_exti3(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12; }
inline uint32_t syscfg_exticr1_get_exti2(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8; }
inline uint32_t syscfg_exticr1_get_exti1(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4; }
inline uint32_t syscfg_exticr1_get_exti0(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI6 = ((1UL << 4) - 1) << 8,  // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI5 = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 4 to 7)
	SYSCFG_EXTICR2_EXTI4 = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 4 to 7)
};
inline void syscfg_exticr2_set_exti7(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val << 12) & SYSCFG_EXTICR2_EXTI7);
}
inline void syscfg_exticr2_set_exti6(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val << 8) & SYSCFG_EXTICR2_EXTI6);
}
inline void syscfg_exticr2_set_exti5(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val << 4) & SYSCFG_EXTICR2_EXTI5);
}
inline void syscfg_exticr2_set_exti4(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val << 0) & SYSCFG_EXTICR2_EXTI4);
}
inline uint32_t syscfg_exticr2_get_exti7(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12; }
inline uint32_t syscfg_exticr2_get_exti6(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8; }
inline uint32_t syscfg_exticr2_get_exti5(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4; }
inline uint32_t syscfg_exticr2_get_exti4(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI10 = ((1UL << 4) - 1) << 8,  // EXTI10
	SYSCFG_EXTICR3_EXTI9  = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 8 to 11)
	SYSCFG_EXTICR3_EXTI8  = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 8 to 11)
};
inline void syscfg_exticr3_set_exti11(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val << 12) & SYSCFG_EXTICR3_EXTI11);
}
inline void syscfg_exticr3_set_exti10(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val << 8) & SYSCFG_EXTICR3_EXTI10);
}
inline void syscfg_exticr3_set_exti9(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val << 4) & SYSCFG_EXTICR3_EXTI9);
}
inline void syscfg_exticr3_set_exti8(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val << 0) & SYSCFG_EXTICR3_EXTI8);
}
inline uint32_t syscfg_exticr3_get_exti11(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12; }
inline uint32_t syscfg_exticr3_get_exti10(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8; }
inline uint32_t syscfg_exticr3_get_exti9(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4; }
inline uint32_t syscfg_exticr3_get_exti8(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL << 4) - 1) << 12, // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI14 = ((1UL << 4) - 1) << 8,  // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI13 = ((1UL << 4) - 1) << 4,  // EXTI x configuration (x = 12 to 15)
	SYSCFG_EXTICR4_EXTI12 = ((1UL << 4) - 1) << 0,  // EXTI x configuration (x = 12 to 15)
};
inline void syscfg_exticr4_set_exti15(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val << 12) & SYSCFG_EXTICR4_EXTI15);
}
inline void syscfg_exticr4_set_exti14(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val << 8) & SYSCFG_EXTICR4_EXTI14);
}
inline void syscfg_exticr4_set_exti13(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val << 4) & SYSCFG_EXTICR4_EXTI13);
}
inline void syscfg_exticr4_set_exti12(struct SYSCFG_Type* p, uint32_t val) {
	p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val << 0) & SYSCFG_EXTICR4_EXTI12);
}
inline uint32_t syscfg_exticr4_get_exti15(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12; }
inline uint32_t syscfg_exticr4_get_exti14(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8; }
inline uint32_t syscfg_exticr4_get_exti13(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4; }
inline uint32_t syscfg_exticr4_get_exti12(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0; }

// SYSCFG->SCSR CCM SRAM control and status register
enum {
	SYSCFG_SCSR_CCMBSY = 1UL << 1, // CCM SRAM busy by erase operation
	SYSCFG_SCSR_CCMER  = 1UL << 0, // CCM SRAM Erase
};

// SYSCFG->CFGR2 configuration register 2
enum {
	SYSCFG_CFGR2_SPF  = 1UL << 8, // SRAM Parity Flag
	SYSCFG_CFGR2_ECCL = 1UL << 3, // ECC Lock
	SYSCFG_CFGR2_PVDL = 1UL << 2, // PVD Lock
	SYSCFG_CFGR2_SPL  = 1UL << 1, // SRAM Parity Lock
	SYSCFG_CFGR2_CLL  = 1UL << 0, // Core Lockup Lock
};

/* Tamper and backup registers */
struct TAMP_Type {
	__IO uint32_t CR1;            // @0 control register 1
	__IO uint32_t CR2;            // @4 control register 2
	uint8_t       RESERVED0[4];   // @8
	__IO uint8_t  FLTCR;          // @12 TAMP filter control register
	uint8_t       RESERVED1[31];  // @13
	__IO uint32_t IER;            // @44 TAMP interrupt enable register
	__I uint32_t  SR;             // @48 TAMP status register
	__I uint32_t  MISR;           // @52 TAMP masked interrupt status register
	uint8_t       RESERVED2[4];   // @56
	__IO uint32_t SCR;            // @60 TAMP status clear register
	uint8_t       RESERVED3[192]; // @64
	__IO uint32_t BKP0R;          // @256 TAMP backup register
	__IO uint32_t BKP1R;          // @260 TAMP backup register
	__IO uint32_t BKP2R;          // @264 TAMP backup register
	__IO uint32_t BKP3R;          // @268 TAMP backup register
	__IO uint32_t BKP4R;          // @272 TAMP backup register
	__IO uint32_t BKP5R;          // @276 TAMP backup register
	__IO uint32_t BKP6R;          // @280 TAMP backup register
	__IO uint32_t BKP7R;          // @284 TAMP backup register
	__IO uint32_t BKP8R;          // @288 TAMP backup register
	__IO uint32_t BKP9R;          // @292 TAMP backup register
	__IO uint32_t BKP10R;         // @296 TAMP backup register
	__IO uint32_t BKP11R;         // @300 TAMP backup register
	__IO uint32_t BKP12R;         // @304 TAMP backup register
	__IO uint32_t BKP13R;         // @308 TAMP backup register
	__IO uint32_t BKP14R;         // @312 TAMP backup register
	__IO uint32_t BKP15R;         // @316 TAMP backup register
	__IO uint32_t BKP16R;         // @320 TAMP backup register
	__IO uint32_t BKP17R;         // @324 TAMP backup register
	__IO uint32_t BKP18R;         // @328 TAMP backup register
	__IO uint32_t BKP19R;         // @332 TAMP backup register
	__IO uint32_t BKP20R;         // @336 TAMP backup register
	__IO uint32_t BKP21R;         // @340 TAMP backup register
	__IO uint32_t BKP22R;         // @344 TAMP backup register
	__IO uint32_t BKP23R;         // @348 TAMP backup register
	__IO uint32_t BKP24R;         // @352 TAMP backup register
	__IO uint32_t BKP25R;         // @356 TAMP backup register
	__IO uint32_t BKP26R;         // @360 TAMP backup register
	__IO uint32_t BKP27R;         // @364 TAMP backup register
	__IO uint32_t BKP28R;         // @368 TAMP backup register
	__IO uint32_t BKP29R;         // @372 TAMP backup register
	__IO uint32_t BKP30R;         // @376 TAMP backup register
	__IO uint32_t BKP31R;         // @380 TAMP backup register
};

// TAMP->CR1 control register 1
enum {
	TAMP_CR1_ITAMP6E = 1UL << 21, // ITAMP6E
	TAMP_CR1_ITAMP5E = 1UL << 20, // ITAMP5E
	TAMP_CR1_ITAMP4E = 1UL << 19, // ITAMP4E
	TAMP_CR1_ITAMP3E = 1UL << 18, // ITAMP3E
	TAMP_CR1_TAMP3E  = 1UL << 2,  // TAMP2E
	TAMP_CR1_TAMP2E  = 1UL << 1,  // TAMP2E
	TAMP_CR1_TAMP1E  = 1UL << 0,  // TAMP1E
};

// TAMP->CR2 control register 2
enum {
	TAMP_CR2_TAMP3TRG  = 1UL << 26, // TAMP3TRG
	TAMP_CR2_TAMP2TRG  = 1UL << 25, // TAMP2TRG
	TAMP_CR2_TAMP1TRG  = 1UL << 24, // TAMP1TRG
	TAMP_CR2_TAMP3MSK  = 1UL << 18, // TAMP3MSK
	TAMP_CR2_TAMP2MSK  = 1UL << 17, // TAMP2MSK
	TAMP_CR2_TAMP1MSK  = 1UL << 16, // TAMP1MSK
	TAMP_CR2_TAMP3NOER = 1UL << 2,  // TAMP3NOER
	TAMP_CR2_TAMP2NOER = 1UL << 1,  // TAMP2NOER
	TAMP_CR2_TAMP1NOER = 1UL << 0,  // TAMP1NOER
};

// TAMP->FLTCR TAMP filter control register
enum {
	TAMP_FLTCR_TAMPPUDIS = 1UL << 7,              // TAMPPUDIS
	TAMP_FLTCR_TAMPPRCH  = ((1UL << 2) - 1) << 5, // TAMPPRCH
	TAMP_FLTCR_TAMPFLT   = ((1UL << 2) - 1) << 3, // TAMPFLT
	TAMP_FLTCR_TAMPFREQ  = ((1UL << 3) - 1) << 0, // TAMPFREQ
};
inline void tamp_fltcr_set_tampprch(struct TAMP_Type* p, uint32_t val) {
	p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPPRCH) | ((val << 5) & TAMP_FLTCR_TAMPPRCH);
}
inline void tamp_fltcr_set_tampflt(struct TAMP_Type* p, uint32_t val) {
	p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPFLT) | ((val << 3) & TAMP_FLTCR_TAMPFLT);
}
inline void tamp_fltcr_set_tampfreq(struct TAMP_Type* p, uint32_t val) {
	p->FLTCR = (p->FLTCR & ~TAMP_FLTCR_TAMPFREQ) | ((val << 0) & TAMP_FLTCR_TAMPFREQ);
}
inline uint32_t tamp_fltcr_get_tampprch(struct TAMP_Type* p) { return (p->FLTCR & TAMP_FLTCR_TAMPPRCH) >> 5; }
inline uint32_t tamp_fltcr_get_tampflt(struct TAMP_Type* p) { return (p->FLTCR & TAMP_FLTCR_TAMPFLT) >> 3; }
inline uint32_t tamp_fltcr_get_tampfreq(struct TAMP_Type* p) { return (p->FLTCR & TAMP_FLTCR_TAMPFREQ) >> 0; }

// TAMP->IER TAMP interrupt enable register
enum {
	TAMP_IER_ITAMP6IE = 1UL << 21, // ITAMP6IE
	TAMP_IER_ITAMP5IE = 1UL << 20, // ITAMP5IE
	TAMP_IER_ITAMP4IE = 1UL << 19, // ITAMP4IE
	TAMP_IER_ITAMP3IE = 1UL << 18, // ITAMP3IE
	TAMP_IER_TAMP3IE  = 1UL << 2,  // TAMP3IE
	TAMP_IER_TAMP2IE  = 1UL << 1,  // TAMP2IE
	TAMP_IER_TAMP1IE  = 1UL << 0,  // TAMP1IE
};

// TAMP->SR TAMP status register
enum {
	TAMP_SR_ITAMP6F = 1UL << 21, // ITAMP6F
	TAMP_SR_ITAMP5F = 1UL << 20, // ITAMP5F
	TAMP_SR_ITAMP4F = 1UL << 19, // ITAMP4F
	TAMP_SR_ITAMP3F = 1UL << 18, // ITAMP3F
	TAMP_SR_TAMP3F  = 1UL << 2,  // TAMP3F
	TAMP_SR_TAMP2F  = 1UL << 1,  // TAMP2F
	TAMP_SR_TAMP1F  = 1UL << 0,  // TAMP1F
};

// TAMP->MISR TAMP masked interrupt status register
enum {
	TAMP_MISR_ITAMP6MF = 1UL << 21, // ITAMP6MF
	TAMP_MISR_ITAMP5MF = 1UL << 20, // ITAMP5MF
	TAMP_MISR_ITAMP4MF = 1UL << 19, // ITAMP4MF
	TAMP_MISR_ITAMP3MF = 1UL << 18, // ITAMP3MF
	TAMP_MISR_TAMP3MF  = 1UL << 2,  // TAMP3MF
	TAMP_MISR_TAMP2MF  = 1UL << 1,  // TAMP2MF
	TAMP_MISR_TAMP1MF  = 1UL << 0,  // TAMP1MF:
};

// TAMP->SCR TAMP status clear register
enum {
	TAMP_SCR_CITAMP6F = 1UL << 21, // CITAMP6F
	TAMP_SCR_CITAMP5F = 1UL << 20, // CITAMP5F
	TAMP_SCR_CITAMP4F = 1UL << 19, // CITAMP4F
	TAMP_SCR_CITAMP3F = 1UL << 18, // CITAMP3F
	TAMP_SCR_CTAMP3F  = 1UL << 2,  // CTAMP3F
	TAMP_SCR_CTAMP2F  = 1UL << 1,  // CTAMP2F
	TAMP_SCR_CTAMP1F  = 1UL << 0,  // CTAMP1F
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint32_t CR2;              // @4 control register 2
	__IO uint32_t SMCR;             // @8 slave mode control register
	__IO uint32_t DIER;             // @12 DMA/Interrupt enable register
	__IO uint32_t SR;               // @16 status register
	__O uint16_t  EGR;              // @20 event generation register
	uint8_t       RESERVED1[2];     // @22
	union {                         // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	union {                         // @28
		__IO uint32_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input;  // capture/compare mode register 2 (input mode)
	};
	__IO uint32_t CCER;            // @32 capture/compare enable register
	__IO uint32_t CNT;             // @36 counter
	__IO uint16_t PSC;             // @40 prescaler
	uint8_t       RESERVED2[2];    // @42
	__IO uint16_t ARR;             // @44 auto-reload register
	uint8_t       RESERVED3[2];    // @46
	__IO uint16_t RCR;             // @48 repetition counter register
	uint8_t       RESERVED4[2];    // @50
	__IO uint16_t CCR1;            // @52 capture/compare register 1
	uint8_t       RESERVED5[2];    // @54
	__IO uint16_t CCR2;            // @56 capture/compare register 2
	uint8_t       RESERVED6[2];    // @58
	__IO uint16_t CCR3;            // @60 capture/compare register 3
	uint8_t       RESERVED7[2];    // @62
	__IO uint16_t CCR4;            // @64 capture/compare register 4
	uint8_t       RESERVED8[2];    // @66
	__IO uint32_t BDTR;            // @68 break and dead-time register
	__IO uint32_t CCR5;            // @72 capture/compare register 4
	__IO uint16_t CCR6;            // @76 capture/compare register 4
	uint8_t       RESERVED9[2];    // @78
	__IO uint32_t CCMR3_Output;    // @80 capture/compare mode register 2 (output mode)
	__IO uint32_t DTR2;            // @84 timer Deadtime Register 2
	__IO uint32_t ECR;             // @88 DMA control register
	__IO uint32_t TISEL;           // @92 TIM timer input selection register
	__IO uint32_t AF1;             // @96 TIM alternate function option register 1
	__IO uint32_t AF2;             // @100 TIM alternate function option register 2
	uint8_t       RESERVED10[884]; // @104
	__IO uint16_t DCR;             // @988 control register
	uint8_t       RESERVED11[2];   // @990
	__IO uint32_t DMAR;            // @992 DMA address for full transfer
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_DITHEN   = 1UL << 12,             // Dithering Enable
	TIM1_CR1_UIFREMAP = 1UL << 11,             // UIF status bit remapping
	TIM1_CR1_CKD      = ((1UL << 2) - 1) << 8, // Clock division
	TIM1_CR1_ARPE     = 1UL << 7,              // Auto-reload preload enable
	TIM1_CR1_CMS      = ((1UL << 2) - 1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR      = 1UL << 4,              // Direction
	TIM1_CR1_OPM      = 1UL << 3,              // One-pulse mode
	TIM1_CR1_URS      = 1UL << 2,              // Update request source
	TIM1_CR1_UDIS     = 1UL << 1,              // Update disable
	TIM1_CR1_CEN      = 1UL << 0,              // Counter enable
};
inline void     tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val << 8) & TIM1_CR1_CKD); }
inline void     tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val << 5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_MMS_3 = 1UL << 25,              // Master mode selection - bit 3
	TIM1_CR2_MMS2  = ((1UL << 4) - 1) << 20, // Master mode selection 2
	TIM1_CR2_OIS6  = 1UL << 18,              // Output Idle state 6 (OC6 output)
	TIM1_CR2_OIS5  = 1UL << 16,              // Output Idle state 5 (OC5 output)
	TIM1_CR2_OIS4N = 1UL << 15,              // Output Idle state 4 (OC4N output)
	TIM1_CR2_OIS4  = 1UL << 14,              // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL << 13,              // Output Idle state 3
	TIM1_CR2_OIS3  = 1UL << 12,              // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL << 11,              // Output Idle state 2
	TIM1_CR2_OIS2  = 1UL << 10,              // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL << 9,               // Output Idle state 1
	TIM1_CR2_OIS1  = 1UL << 8,               // Output Idle state 1
	TIM1_CR2_TI1S  = 1UL << 7,               // TI1 selection
	TIM1_CR2_MMS   = ((1UL << 3) - 1) << 4,  // Master mode selection
	TIM1_CR2_CCDS  = 1UL << 3,               // Capture/compare DMA selection
	TIM1_CR2_CCUS  = 1UL << 2,               // Capture/compare control update selection
	TIM1_CR2_CCPC  = 1UL << 0,               // Capture/compare preloaded control
};
inline void     tim1_cr2_set_mms2(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS2) | ((val << 20) & TIM1_CR2_MMS2); }
inline void     tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val << 4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms2(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS2) >> 20; }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_SMSPS  = 1UL << 25,              // SMS Preload Source
	TIM1_SMCR_SMSPE  = 1UL << 24,              // SMS Preload Enable
	TIM1_SMCR_TS_4_3 = ((1UL << 2) - 1) << 20, // Trigger selection - bit 4:3
	TIM1_SMCR_SMS_3  = 1UL << 16,              // Slave mode selection - bit 3
	TIM1_SMCR_ETP    = 1UL << 15,              // External trigger polarity
	TIM1_SMCR_ECE    = 1UL << 14,              // External clock enable
	TIM1_SMCR_ETPS   = ((1UL << 2) - 1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF    = ((1UL << 4) - 1) << 8,  // External trigger filter
	TIM1_SMCR_MSM    = 1UL << 7,               // Master/Slave mode
	TIM1_SMCR_TS     = ((1UL << 3) - 1) << 4,  // Trigger selection
	TIM1_SMCR_OCCS   = 1UL << 3,               // OCREF clear selection
	TIM1_SMCR_SMS    = ((1UL << 3) - 1) << 0,  // Slave mode selection
};
inline void tim1_smcr_set_ts_4_3(struct TIM1_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_TS_4_3) | ((val << 20) & TIM1_SMCR_TS_4_3);
}
inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val << 12) & TIM1_SMCR_ETPS);
}
inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val << 8) & TIM1_SMCR_ETF); }
inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val << 4) & TIM1_SMCR_TS); }
inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val << 0) & TIM1_SMCR_SMS); }
inline uint32_t tim1_smcr_get_ts_4_3(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS_4_3) >> 20; }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8; }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 4; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TERRIE = 1UL << 23, // Transition Error interrupt enable
	TIM1_DIER_IERRIE = 1UL << 22, // Index Error interrupt enable
	TIM1_DIER_DIRIE  = 1UL << 21, // Direction Change interrupt enable
	TIM1_DIER_IDXIE  = 1UL << 20, // Index interrupt enable
	TIM1_DIER_TDE    = 1UL << 14, // Trigger DMA request enable
	TIM1_DIER_COMDE  = 1UL << 13, // COM DMA request enable
	TIM1_DIER_CC4DE  = 1UL << 12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE  = 1UL << 11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE  = 1UL << 10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE  = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE    = 1UL << 8,  // Update DMA request enable
	TIM1_DIER_BIE    = 1UL << 7,  // Break interrupt enable
	TIM1_DIER_TIE    = 1UL << 6,  // Trigger interrupt enable
	TIM1_DIER_COMIE  = 1UL << 5,  // COM interrupt enable
	TIM1_DIER_CC4IE  = 1UL << 4,  // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE  = 1UL << 3,  // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE  = 1UL << 2,  // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE  = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE    = 1UL << 0,  // Update interrupt enable
};

// TIM1->SR status register
enum {
	TIM1_SR_TERRF = 1UL << 23, // Transition Error interrupt flag
	TIM1_SR_IERRF = 1UL << 22, // Index Error interrupt flag
	TIM1_SR_DIRF  = 1UL << 21, // Direction Change interrupt flag
	TIM1_SR_IDXF  = 1UL << 20, // Index interrupt flag
	TIM1_SR_CC6IF = 1UL << 17, // Compare 6 interrupt flag
	TIM1_SR_CC5IF = 1UL << 16, // Compare 5 interrupt flag
	TIM1_SR_SBIF  = 1UL << 13, // System Break interrupt flag
	TIM1_SR_CC4OF = 1UL << 12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL << 11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL << 10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM1_SR_B2IF  = 1UL << 8,  // Break 2 interrupt flag
	TIM1_SR_BIF   = 1UL << 7,  // Break interrupt flag
	TIM1_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL << 5,  // COM interrupt flag
	TIM1_SR_CC4IF = 1UL << 4,  // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL << 3,  // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL << 2,  // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM1_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_B2G  = 1UL << 8, // Break 2 generation
	TIM1_EGR_BG   = 1UL << 7, // Break generation
	TIM1_EGR_TG   = 1UL << 6, // Trigger generation
	TIM1_EGR_COMG = 1UL << 5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL << 4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL << 3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM1_EGR_UG   = 1UL << 0, // Update generation
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2M_3 = 1UL << 24,              // Output Compare 2 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC1M_3 = 1UL << 16,              // Output Compare 1 mode - bit 3
	TIM1_CCMR1_OUTPUT_OC2CE  = 1UL << 15,              // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M   = ((1UL << 3) - 1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE  = 1UL << 11,              // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE  = 1UL << 10,              // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S   = ((1UL << 2) - 1) << 8,  // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE  = 1UL << 7,               // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M   = ((1UL << 3) - 1) << 4,  // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE  = 1UL << 3,               // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE  = 1UL << 2,               // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S   = ((1UL << 2) - 1) << 0,  // Capture/Compare 1 selection
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM1_CCMR1_OUTPUT_OC2M);
}
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM1_CCMR1_OUTPUT_CC2S);
}
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM1_CCMR1_OUTPUT_OC1M);
}
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM1_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4M_3 = 1UL << 24,              // Output Compare 4 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC3M_3 = 1UL << 16,              // Output Compare 3 mode - bit 3
	TIM1_CCMR2_OUTPUT_OC4CE  = 1UL << 15,              // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M   = ((1UL << 3) - 1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE  = 1UL << 11,              // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE  = 1UL << 10,              // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S   = ((1UL << 2) - 1) << 8,  // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE  = 1UL << 7,               // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M   = ((1UL << 3) - 1) << 4,  // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE  = 1UL << 3,               // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE  = 1UL << 2,               // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S   = ((1UL << 2) - 1) << 0,  // Capture/Compare 3 selection
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val << 12) & TIM1_CCMR2_OUTPUT_OC4M);
}
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val << 8) & TIM1_CCMR2_OUTPUT_CC4S);
}
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val << 4) & TIM1_CCMR2_OUTPUT_OC3M);
}
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) {
	p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val << 0) & TIM1_CCMR2_OUTPUT_CC3S);
}
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC6P  = 1UL << 21, // Capture/Compare 6 output polarity
	TIM1_CCER_CC6E  = 1UL << 20, // Capture/Compare 6 output enable
	TIM1_CCER_CC5P  = 1UL << 17, // Capture/Compare 5 output polarity
	TIM1_CCER_CC5E  = 1UL << 16, // Capture/Compare 5 output enable
	TIM1_CCER_CC4NP = 1UL << 15, // Capture/Compare 4 complementary output polarity
	TIM1_CCER_CC4NE = 1UL << 14, // Capture/Compare 4 complementary output enable
	TIM1_CCER_CC4P  = 1UL << 13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E  = 1UL << 12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL << 11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL << 10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P  = 1UL << 9,  // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E  = 1UL << 8,  // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL << 7,  // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL << 6,  // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P  = 1UL << 5,  // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E  = 1UL << 4,  // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL << 3,  // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL << 2,  // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P  = 1UL << 1,  // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E  = 1UL << 0,  // Capture/Compare 1 output enable
};

// TIM1->CNT counter
enum {
	TIM1_CNT_UIFCPY = 1UL << 31,              // UIFCPY
	TIM1_CNT_CNT    = ((1UL << 16) - 1) << 0, // counter value
};
inline void     tim1_cnt_set_cnt(struct TIM1_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM1_CNT_CNT) | ((val << 0) & TIM1_CNT_CNT); }
inline uint32_t tim1_cnt_get_cnt(struct TIM1_Type* p) { return (p->CNT & TIM1_CNT_CNT) >> 0; }

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_BK2ID   = 1UL << 29,              // BK2ID
	TIM1_BDTR_BKBID   = 1UL << 28,              // BKBID
	TIM1_BDTR_BK2DSRM = 1UL << 27,              // BK2DSRM
	TIM1_BDTR_BKDSRM  = 1UL << 26,              // BKDSRM
	TIM1_BDTR_BK2P    = 1UL << 25,              // Break 2 polarity
	TIM1_BDTR_BK2E    = 1UL << 24,              // Break 2 Enable
	TIM1_BDTR_BK2F    = ((1UL << 4) - 1) << 20, // Break 2 filter
	TIM1_BDTR_BKF     = ((1UL << 4) - 1) << 16, // Break filter
	TIM1_BDTR_MOE     = 1UL << 15,              // Main output enable
	TIM1_BDTR_AOE     = 1UL << 14,              // Automatic output enable
	TIM1_BDTR_BKP     = 1UL << 13,              // Break polarity
	TIM1_BDTR_BKE     = 1UL << 12,              // Break enable
	TIM1_BDTR_OSSR    = 1UL << 11,              // Off-state selection for Run mode
	TIM1_BDTR_OSSI    = 1UL << 10,              // Off-state selection for Idle mode
	TIM1_BDTR_LOCK    = ((1UL << 2) - 1) << 8,  // Lock configuration
	TIM1_BDTR_DTG     = ((1UL << 8) - 1) << 0,  // Dead-time generator setup
};
inline void tim1_bdtr_set_bk2f(struct TIM1_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM1_BDTR_BK2F) | ((val << 20) & TIM1_BDTR_BK2F);
}
inline void tim1_bdtr_set_bkf(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_BKF) | ((val << 16) & TIM1_BDTR_BKF); }
inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val << 8) & TIM1_BDTR_LOCK); }
inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val << 0) & TIM1_BDTR_DTG); }
inline uint32_t tim1_bdtr_get_bk2f(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BK2F) >> 20; }
inline uint32_t tim1_bdtr_get_bkf(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_BKF) >> 16; }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0; }

// TIM1->CCR5 capture/compare register 4
enum {
	TIM1_CCR5_GC5C3 = 1UL << 31,              // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL << 30,              // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL << 29,              // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5  = ((1UL << 16) - 1) << 0, // Capture/Compare value
};
inline void tim1_ccr5_set_ccr5(struct TIM1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val << 0) & TIM1_CCR5_CCR5); }
inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type* p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0; }

// TIM1->CCMR3_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M_BIT3 = 1UL << 24,              // Output Compare 6 mode bit 3
	TIM1_CCMR3_OUTPUT_OC5M_BIT3 = ((1UL << 3) - 1) << 16, // Output Compare 5 mode bit 3
	TIM1_CCMR3_OUTPUT_OC6CE     = 1UL << 15,              // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M      = ((1UL << 3) - 1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE     = 1UL << 11,              // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE     = 1UL << 10,              // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE     = 1UL << 7,               // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M      = ((1UL << 3) - 1) << 4,  // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE     = 1UL << 3,               // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE     = 1UL << 2,               // Output compare 5 fast enable
};
inline void tim1_ccmr3_output_set_oc5m_bit3(struct TIM1_Type* p, uint32_t val) {
	p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M_BIT3) | ((val << 16) & TIM1_CCMR3_OUTPUT_OC5M_BIT3);
}
inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val << 12) & TIM1_CCMR3_OUTPUT_OC6M);
}
inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type* p, uint32_t val) {
	p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val << 4) & TIM1_CCMR3_OUTPUT_OC5M);
}
inline uint32_t tim1_ccmr3_output_get_oc5m_bit3(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M_BIT3) >> 16; }
inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12; }
inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4; }

// TIM1->DTR2 timer Deadtime Register 2
enum {
	TIM1_DTR2_DTPE = 1UL << 17,             // Deadtime Preload Enable
	TIM1_DTR2_DTAE = 1UL << 16,             // Deadtime Asymmetric Enable
	TIM1_DTR2_DTGF = ((1UL << 8) - 1) << 0, // Dead-time falling edge generator setup
};
inline void tim1_dtr2_set_dtgf(struct TIM1_Type* p, uint32_t val) { p->DTR2 = (p->DTR2 & ~TIM1_DTR2_DTGF) | ((val << 0) & TIM1_DTR2_DTGF); }
inline uint32_t tim1_dtr2_get_dtgf(struct TIM1_Type* p) { return (p->DTR2 & TIM1_DTR2_DTGF) >> 0; }

// TIM1->ECR DMA control register
enum {
	TIM1_ECR_PWPRSC = ((1UL << 3) - 1) << 24, // Pulse Width prescaler
	TIM1_ECR_PW     = ((1UL << 8) - 1) << 16, // Pulse width
	TIM1_ECR_IPOS   = ((1UL << 2) - 1) << 6,  // Index Positioning
	TIM1_ECR_FIDX   = 1UL << 5,               // First Index
	TIM1_ECR_IBLK   = ((1UL << 2) - 1) << 3,  // Index Blanking
	TIM1_ECR_IDIR   = ((1UL << 2) - 1) << 1,  // Index Direction
	TIM1_ECR_IE     = 1UL << 0,               // Index Enable
};
inline void tim1_ecr_set_pwprsc(struct TIM1_Type* p, uint32_t val) {
	p->ECR = (p->ECR & ~TIM1_ECR_PWPRSC) | ((val << 24) & TIM1_ECR_PWPRSC);
}
inline void     tim1_ecr_set_pw(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_PW) | ((val << 16) & TIM1_ECR_PW); }
inline void     tim1_ecr_set_ipos(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_IPOS) | ((val << 6) & TIM1_ECR_IPOS); }
inline void     tim1_ecr_set_iblk(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_IBLK) | ((val << 3) & TIM1_ECR_IBLK); }
inline void     tim1_ecr_set_idir(struct TIM1_Type* p, uint32_t val) { p->ECR = (p->ECR & ~TIM1_ECR_IDIR) | ((val << 1) & TIM1_ECR_IDIR); }
inline uint32_t tim1_ecr_get_pwprsc(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_PWPRSC) >> 24; }
inline uint32_t tim1_ecr_get_pw(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_PW) >> 16; }
inline uint32_t tim1_ecr_get_ipos(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_IPOS) >> 6; }
inline uint32_t tim1_ecr_get_iblk(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_IBLK) >> 3; }
inline uint32_t tim1_ecr_get_idir(struct TIM1_Type* p) { return (p->ECR & TIM1_ECR_IDIR) >> 1; }

// TIM1->TISEL TIM timer input selection register
enum {
	TIM1_TISEL_TI4SEL = ((1UL << 4) - 1) << 24, // TI4[0] to TI4[15] input selection
	TIM1_TISEL_TI3SEL = ((1UL << 4) - 1) << 16, // TI3[0] to TI3[15] input selection
	TIM1_TISEL_TI2SEL = ((1UL << 4) - 1) << 8,  // TI2[0] to TI2[15] input selection
	TIM1_TISEL_TI1SEL = ((1UL << 4) - 1) << 0,  // TI1[0] to TI1[15] input selection
};
inline void tim1_tisel_set_ti4sel(struct TIM1_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI4SEL) | ((val << 24) & TIM1_TISEL_TI4SEL);
}
inline void tim1_tisel_set_ti3sel(struct TIM1_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI3SEL) | ((val << 16) & TIM1_TISEL_TI3SEL);
}
inline void tim1_tisel_set_ti2sel(struct TIM1_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI2SEL) | ((val << 8) & TIM1_TISEL_TI2SEL);
}
inline void tim1_tisel_set_ti1sel(struct TIM1_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM1_TISEL_TI1SEL) | ((val << 0) & TIM1_TISEL_TI1SEL);
}
inline uint32_t tim1_tisel_get_ti4sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI4SEL) >> 24; }
inline uint32_t tim1_tisel_get_ti3sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI3SEL) >> 16; }
inline uint32_t tim1_tisel_get_ti2sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI2SEL) >> 8; }
inline uint32_t tim1_tisel_get_ti1sel(struct TIM1_Type* p) { return (p->TISEL & TIM1_TISEL_TI1SEL) >> 0; }

// TIM1->AF1 TIM alternate function option register 1
enum {
	TIM1_AF1_ETRSEL  = ((1UL << 4) - 1) << 14, // ETR source selection
	TIM1_AF1_BKCMP4P = 1UL << 13,              // BRK COMP4 input polarity
	TIM1_AF1_BKCMP3P = 1UL << 12,              // BRK COMP3 input polarity
	TIM1_AF1_BKCMP2P = 1UL << 11,              // BRK COMP2 input polarity
	TIM1_AF1_BKCMP1P = 1UL << 10,              // BRK COMP1 input polarity
	TIM1_AF1_BKINP   = 1UL << 9,               // BRK BKIN input polarity
	TIM1_AF1_BKCMP7E = 1UL << 7,               // BRK COMP7 enable
	TIM1_AF1_BKCMP6E = 1UL << 6,               // BRK COMP6 enable
	TIM1_AF1_BKCMP5E = 1UL << 5,               // BRK COMP5 enable
	TIM1_AF1_BKCMP4E = 1UL << 4,               // BRK COMP4 enable
	TIM1_AF1_BKCMP3E = 1UL << 3,               // BRK COMP3 enable
	TIM1_AF1_BKCMP2E = 1UL << 2,               // BRK COMP2 enable
	TIM1_AF1_BKCMP1E = 1UL << 1,               // BRK COMP1 enable
	TIM1_AF1_BKINE   = 1UL << 0,               // BRK BKIN input enable
};
inline void tim1_af1_set_etrsel(struct TIM1_Type* p, uint32_t val) {
	p->AF1 = (p->AF1 & ~TIM1_AF1_ETRSEL) | ((val << 14) & TIM1_AF1_ETRSEL);
}
inline uint32_t tim1_af1_get_etrsel(struct TIM1_Type* p) { return (p->AF1 & TIM1_AF1_ETRSEL) >> 14; }

// TIM1->AF2 TIM alternate function option register 2
enum {
	TIM1_AF2_OCRSEL   = ((1UL << 3) - 1) << 16, // OCREF_CLR source selection
	TIM1_AF2_BK2CMP4P = 1UL << 13,              // BRK2 COMP4 input polarity
	TIM1_AF2_BK2CMP3P = 1UL << 12,              // BRK2 COMP3 input polarity
	TIM1_AF2_BK2CMP2P = 1UL << 11,              // BRK2 COMP2 input polarity
	TIM1_AF2_BK2CMP1P = 1UL << 10,              // BRK2 COMP1 input polarity
	TIM1_AF2_BK2INP   = 1UL << 9,               // BRK2 BKIN input polarity
	TIM1_AF2_BK2CMP7E = 1UL << 7,               // BRK2 COMP7 enable
	TIM1_AF2_BK2CMP6E = 1UL << 6,               // BRK2 COMP6 enable
	TIM1_AF2_BK2CMP5E = 1UL << 5,               // BRK2 COMP5 enable
	TIM1_AF2_BK2CMP4E = 1UL << 4,               // BRK2 COMP4 enable
	TIM1_AF2_BK2CMP3E = 1UL << 3,               // BRK2 COMP3 enable
	TIM1_AF2_BK2CMP2E = 1UL << 2,               // BRK2 COMP2 enable
	TIM1_AF2_BK2CMP1E = 1UL << 1,               // BRK2 COMP1 enable
	TIM1_AF2_BKINE    = 1UL << 0,               // BRK BKIN input enable
};
inline void tim1_af2_set_ocrsel(struct TIM1_Type* p, uint32_t val) {
	p->AF2 = (p->AF2 & ~TIM1_AF2_OCRSEL) | ((val << 16) & TIM1_AF2_OCRSEL);
}
inline uint32_t tim1_af2_get_ocrsel(struct TIM1_Type* p) { return (p->AF2 & TIM1_AF2_OCRSEL) >> 16; }

// TIM1->DCR control register
enum {
	TIM1_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val << 8) & TIM1_DCR_DBL); }
inline void     tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val << 0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0; }

// Valid Casts:

inline struct TIM6_Type* TIM1_as_TIM6_Type(struct TIM1_Type* p) { return (struct TIM6_Type*)p; }

/* General purpose timers */
struct TIM15_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint16_t CR2;              // @4 control register 2
	uint8_t       RESERVED1[2];     // @6
	__IO uint32_t SMCR;             // @8 slave mode control register
	__IO uint16_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t       RESERVED2[2];     // @14
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED3[2];     // @18
	__O uint8_t   EGR;              // @20 event generation register
	uint8_t       RESERVED4[3];     // @21
	union {                         // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint16_t CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t       RESERVED5[4];    // @28
	__IO uint8_t  CCER;            // @32 capture/compare enable register
	uint8_t       RESERVED6[3];    // @33
	__IO uint32_t CNT;             // @36 counter
	__IO uint16_t PSC;             // @40 prescaler
	uint8_t       RESERVED7[2];    // @42
	__IO uint16_t ARR;             // @44 auto-reload register
	uint8_t       RESERVED8[2];    // @46
	__IO uint8_t  RCR;             // @48 repetition counter register
	uint8_t       RESERVED9[3];    // @49
	__IO uint16_t CCR1;            // @52 capture/compare register 1
	uint8_t       RESERVED10[2];   // @54
	__IO uint16_t CCR2;            // @56 capture/compare register 2
	uint8_t       RESERVED11[10];  // @58
	__IO uint32_t BDTR;            // @68 break and dead-time register
	uint8_t       RESERVED12[12];  // @72
	__IO uint32_t DTR2;            // @84 timer Deadtime Register 2
	uint8_t       RESERVED13[4];   // @88
	__IO uint16_t TISEL;           // @92 TIM timer input selection register
	uint8_t       RESERVED14[2];   // @94
	__IO uint16_t AF1;             // @96 TIM alternate function option register 1
	uint8_t       RESERVED15[2];   // @98
	__IO uint32_t AF2;             // @100 TIM alternate function option register 2
	uint8_t       RESERVED16[884]; // @104
	__IO uint16_t DCR;             // @988 DMA control register
	uint8_t       RESERVED17[2];   // @990
	__IO uint32_t DMAR;            // @992 DMA address for full transfer
};

// TIM15->CR1 control register 1
enum {
	TIM15_CR1_DITHEN   = 1UL << 12,             // Dithering Enable
	TIM15_CR1_UIFREMAP = 1UL << 11,             // UIF status bit remapping
	TIM15_CR1_CKD      = ((1UL << 2) - 1) << 8, // Clock division
	TIM15_CR1_ARPE     = 1UL << 7,              // Auto-reload preload enable
	TIM15_CR1_OPM      = 1UL << 3,              // One-pulse mode
	TIM15_CR1_URS      = 1UL << 2,              // Update request source
	TIM15_CR1_UDIS     = 1UL << 1,              // Update disable
	TIM15_CR1_CEN      = 1UL << 0,              // Counter enable
};
inline void     tim15_cr1_set_ckd(struct TIM15_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM15_CR1_CKD) | ((val << 8) & TIM15_CR1_CKD); }
inline uint32_t tim15_cr1_get_ckd(struct TIM15_Type* p) { return (p->CR1 & TIM15_CR1_CKD) >> 8; }

// TIM15->CR2 control register 2
enum {
	TIM15_CR2_OIS2  = 1UL << 10,             // Output idle state 2 (OC2 output)
	TIM15_CR2_OIS1N = 1UL << 9,              // Output Idle state 1
	TIM15_CR2_OIS1  = 1UL << 8,              // Output Idle state 1
	TIM15_CR2_TI1S  = 1UL << 7,              // TI1 selection
	TIM15_CR2_MMS   = ((1UL << 3) - 1) << 4, // Master mode selection
	TIM15_CR2_CCDS  = 1UL << 3,              // Capture/compare DMA selection
	TIM15_CR2_CCUS  = 1UL << 2,              // Capture/compare control update selection
	TIM15_CR2_CCPC  = 1UL << 0,              // Capture/compare preloaded control
};
inline void     tim15_cr2_set_mms(struct TIM15_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM15_CR2_MMS) | ((val << 4) & TIM15_CR2_MMS); }
inline uint32_t tim15_cr2_get_mms(struct TIM15_Type* p) { return (p->CR2 & TIM15_CR2_MMS) >> 4; }

// TIM15->SMCR slave mode control register
enum {
	TIM15_SMCR_TS_4_3 = ((1UL << 2) - 1) << 20, // Trigger selection - bit 4:3
	TIM15_SMCR_SMS_3  = 1UL << 16,              // Slave mode selection - bit 3
	TIM15_SMCR_MSM    = 1UL << 7,               // Master/Slave mode
	TIM15_SMCR_TS     = ((1UL << 3) - 1) << 4,  // Trigger selection
	TIM15_SMCR_SMS    = ((1UL << 3) - 1) << 0,  // Slave mode selection
};
inline void tim15_smcr_set_ts_4_3(struct TIM15_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM15_SMCR_TS_4_3) | ((val << 20) & TIM15_SMCR_TS_4_3);
}
inline void tim15_smcr_set_ts(struct TIM15_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM15_SMCR_TS) | ((val << 4) & TIM15_SMCR_TS); }
inline void tim15_smcr_set_sms(struct TIM15_Type* p, uint32_t val) {
	p->SMCR = (p->SMCR & ~TIM15_SMCR_SMS) | ((val << 0) & TIM15_SMCR_SMS);
}
inline uint32_t tim15_smcr_get_ts_4_3(struct TIM15_Type* p) { return (p->SMCR & TIM15_SMCR_TS_4_3) >> 20; }
inline uint32_t tim15_smcr_get_ts(struct TIM15_Type* p) { return (p->SMCR & TIM15_SMCR_TS) >> 4; }
inline uint32_t tim15_smcr_get_sms(struct TIM15_Type* p) { return (p->SMCR & TIM15_SMCR_SMS) >> 0; }

// TIM15->DIER DMA/Interrupt enable register
enum {
	TIM15_DIER_TDE   = 1UL << 14, // Trigger DMA request enable
	TIM15_DIER_COMDE = 1UL << 13, // COM DMA request enable
	TIM15_DIER_CC2DE = 1UL << 10, // Capture/Compare 2 DMA request enable
	TIM15_DIER_CC1DE = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM15_DIER_UDE   = 1UL << 8,  // Update DMA request enable
	TIM15_DIER_BIE   = 1UL << 7,  // Break interrupt enable
	TIM15_DIER_TIE   = 1UL << 6,  // Trigger interrupt enable
	TIM15_DIER_COMIE = 1UL << 5,  // COM interrupt enable
	TIM15_DIER_CC2IE = 1UL << 2,  // Capture/Compare 2 interrupt enable
	TIM15_DIER_CC1IE = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM15_DIER_UIE   = 1UL << 0,  // Update interrupt enable
};

// TIM15->SR status register
enum {
	TIM15_SR_CC2OF = 1UL << 10, // Capture/Compare 2 overcapture flag
	TIM15_SR_CC1OF = 1UL << 9,  // Capture/Compare 1 overcapture flag
	TIM15_SR_BIF   = 1UL << 7,  // Break interrupt flag
	TIM15_SR_TIF   = 1UL << 6,  // Trigger interrupt flag
	TIM15_SR_COMIF = 1UL << 5,  // COM interrupt flag
	TIM15_SR_CC2IF = 1UL << 2,  // Capture/compare 2 interrupt flag
	TIM15_SR_CC1IF = 1UL << 1,  // Capture/compare 1 interrupt flag
	TIM15_SR_UIF   = 1UL << 0,  // Update interrupt flag
};

// TIM15->EGR event generation register
enum {
	TIM15_EGR_BG   = 1UL << 7, // Break generation
	TIM15_EGR_TG   = 1UL << 6, // Trigger generation
	TIM15_EGR_COMG = 1UL << 5, // Capture/Compare control update generation
	TIM15_EGR_CC2G = 1UL << 2, // Capture/compare 2 generation
	TIM15_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM15_EGR_UG   = 1UL << 0, // Update generation
};

// TIM15->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM15_CCMR1_OUTPUT_OC2M_3 = 1UL << 24,              // Output Compare 2 mode - bit 3
	TIM15_CCMR1_OUTPUT_OC1M_3 = 1UL << 16,              // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC2M   = ((1UL << 3) - 1) << 12, // OC2M
	TIM15_CCMR1_OUTPUT_OC2PE  = 1UL << 11,              // OC2PE
	TIM15_CCMR1_OUTPUT_OC2FE  = 1UL << 10,              // OC2FE
	TIM15_CCMR1_OUTPUT_CC2S   = ((1UL << 2) - 1) << 8,  // CC2S
	TIM15_CCMR1_OUTPUT_OC1CE  = 1UL << 7,               // OC1CE
	TIM15_CCMR1_OUTPUT_OC1M   = ((1UL << 3) - 1) << 4,  // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1PE  = 1UL << 3,               // Output Compare 1 preload enable
	TIM15_CCMR1_OUTPUT_OC1FE  = 1UL << 2,               // Output Compare 1 fast enable
	TIM15_CCMR1_OUTPUT_CC1S   = ((1UL << 2) - 1) << 0,  // Capture/Compare 1 selection
};
inline void tim15_ccmr1_output_set_oc2m(struct TIM15_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC2M) | ((val << 12) & TIM15_CCMR1_OUTPUT_OC2M);
}
inline void tim15_ccmr1_output_set_cc2s(struct TIM15_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC2S) | ((val << 8) & TIM15_CCMR1_OUTPUT_CC2S);
}
inline void tim15_ccmr1_output_set_oc1m(struct TIM15_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM15_CCMR1_OUTPUT_OC1M);
}
inline void tim15_ccmr1_output_set_cc1s(struct TIM15_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM15_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim15_ccmr1_output_get_oc2m(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC2M) >> 12; }
inline uint32_t tim15_ccmr1_output_get_cc2s(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC2S) >> 8; }
inline uint32_t tim15_ccmr1_output_get_oc1m(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim15_ccmr1_output_get_cc1s(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM15->CCER capture/compare enable register
enum {
	TIM15_CCER_CC2NP = 1UL << 7, // Capture/Compare 2 complementary output polarity
	TIM15_CCER_CC2P  = 1UL << 5, // Capture/Compare 2 output polarity
	TIM15_CCER_CC2E  = 1UL << 4, // Capture/Compare 2 output enable
	TIM15_CCER_CC1NP = 1UL << 3, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1NE = 1UL << 2, // Capture/Compare 1 complementary output enable
	TIM15_CCER_CC1P  = 1UL << 1, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1E  = 1UL << 0, // Capture/Compare 1 output enable
};

// TIM15->CNT counter
enum {
	TIM15_CNT_UIFCPY = 1UL << 31,              // UIF Copy
	TIM15_CNT_CNT    = ((1UL << 16) - 1) << 0, // counter value
};
inline void     tim15_cnt_set_cnt(struct TIM15_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM15_CNT_CNT) | ((val << 0) & TIM15_CNT_CNT); }
inline uint32_t tim15_cnt_get_cnt(struct TIM15_Type* p) { return (p->CNT & TIM15_CNT_CNT) >> 0; }

// TIM15->BDTR break and dead-time register
enum {
	TIM15_BDTR_BKBID  = 1UL << 28,              // BKBID
	TIM15_BDTR_BKDSRM = 1UL << 26,              // BKDSRM
	TIM15_BDTR_BKF    = ((1UL << 4) - 1) << 16, // Break filter
	TIM15_BDTR_MOE    = 1UL << 15,              // Main output enable
	TIM15_BDTR_AOE    = 1UL << 14,              // Automatic output enable
	TIM15_BDTR_BKP    = 1UL << 13,              // Break polarity
	TIM15_BDTR_BKE    = 1UL << 12,              // Break enable
	TIM15_BDTR_OSSR   = 1UL << 11,              // Off-state selection for Run mode
	TIM15_BDTR_OSSI   = 1UL << 10,              // Off-state selection for Idle mode
	TIM15_BDTR_LOCK   = ((1UL << 2) - 1) << 8,  // Lock configuration
	TIM15_BDTR_DTG    = ((1UL << 8) - 1) << 0,  // Dead-time generator setup
};
inline void tim15_bdtr_set_bkf(struct TIM15_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM15_BDTR_BKF) | ((val << 16) & TIM15_BDTR_BKF);
}
inline void tim15_bdtr_set_lock(struct TIM15_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM15_BDTR_LOCK) | ((val << 8) & TIM15_BDTR_LOCK);
}
inline void tim15_bdtr_set_dtg(struct TIM15_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM15_BDTR_DTG) | ((val << 0) & TIM15_BDTR_DTG);
}
inline uint32_t tim15_bdtr_get_bkf(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_BKF) >> 16; }
inline uint32_t tim15_bdtr_get_lock(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_LOCK) >> 8; }
inline uint32_t tim15_bdtr_get_dtg(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_DTG) >> 0; }

// TIM15->DTR2 timer Deadtime Register 2
enum {
	TIM15_DTR2_DTPE = 1UL << 17,             // Deadtime Preload Enable
	TIM15_DTR2_DTAE = 1UL << 16,             // Deadtime Asymmetric Enable
	TIM15_DTR2_DTGF = ((1UL << 8) - 1) << 0, // Dead-time generator setup
};
inline void tim15_dtr2_set_dtgf(struct TIM15_Type* p, uint32_t val) {
	p->DTR2 = (p->DTR2 & ~TIM15_DTR2_DTGF) | ((val << 0) & TIM15_DTR2_DTGF);
}
inline uint32_t tim15_dtr2_get_dtgf(struct TIM15_Type* p) { return (p->DTR2 & TIM15_DTR2_DTGF) >> 0; }

// TIM15->TISEL TIM timer input selection register
enum {
	TIM15_TISEL_TI2SEL = ((1UL << 4) - 1) << 8, // TI2[0] to TI2[15] input selection
	TIM15_TISEL_TI1SEL = ((1UL << 4) - 1) << 0, // TI1[0] to TI1[15] input selection
};
inline void tim15_tisel_set_ti2sel(struct TIM15_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM15_TISEL_TI2SEL) | ((val << 8) & TIM15_TISEL_TI2SEL);
}
inline void tim15_tisel_set_ti1sel(struct TIM15_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM15_TISEL_TI1SEL) | ((val << 0) & TIM15_TISEL_TI1SEL);
}
inline uint32_t tim15_tisel_get_ti2sel(struct TIM15_Type* p) { return (p->TISEL & TIM15_TISEL_TI2SEL) >> 8; }
inline uint32_t tim15_tisel_get_ti1sel(struct TIM15_Type* p) { return (p->TISEL & TIM15_TISEL_TI1SEL) >> 0; }

// TIM15->AF1 TIM alternate function option register 1
enum {
	TIM15_AF1_BKCMP4P = 1UL << 13, // BRK COMP4 input polarity
	TIM15_AF1_BKCMP3P = 1UL << 12, // BRK COMP3 input polarity
	TIM15_AF1_BKCMP2P = 1UL << 11, // BRK COMP2 input polarity
	TIM15_AF1_BKCMP1P = 1UL << 10, // BRK COMP1 input polarity
	TIM15_AF1_BKINP   = 1UL << 9,  // BRK BKIN input polarity
	TIM15_AF1_BKCMP7E = 1UL << 7,  // BRK COMP7 enable
	TIM15_AF1_BKCMP6E = 1UL << 6,  // BRK COMP6 enable
	TIM15_AF1_BKCMP5E = 1UL << 5,  // BRK COMP5 enable
	TIM15_AF1_BKCMP4E = 1UL << 4,  // BRK COMP4 enable
	TIM15_AF1_BKCMP3E = 1UL << 3,  // BRK COMP3 enable
	TIM15_AF1_BKCMP2E = 1UL << 2,  // BRK COMP2 enable
	TIM15_AF1_BKCMP1E = 1UL << 1,  // BRK COMP1 enable
	TIM15_AF1_BKINE   = 1UL << 0,  // BRK BKIN input enable
};

// TIM15->AF2 TIM alternate function option register 2
enum {
	TIM15_AF2_OCRSEL = ((1UL << 3) - 1) << 16, // OCREF_CLR source selection
};
inline void tim15_af2_set_ocrsel(struct TIM15_Type* p, uint32_t val) {
	p->AF2 = (p->AF2 & ~TIM15_AF2_OCRSEL) | ((val << 16) & TIM15_AF2_OCRSEL);
}
inline uint32_t tim15_af2_get_ocrsel(struct TIM15_Type* p) { return (p->AF2 & TIM15_AF2_OCRSEL) >> 16; }

// TIM15->DCR DMA control register
enum {
	TIM15_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM15_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim15_dcr_set_dbl(struct TIM15_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM15_DCR_DBL) | ((val << 8) & TIM15_DCR_DBL); }
inline void     tim15_dcr_set_dba(struct TIM15_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM15_DCR_DBA) | ((val << 0) & TIM15_DCR_DBA); }
inline uint32_t tim15_dcr_get_dbl(struct TIM15_Type* p) { return (p->DCR & TIM15_DCR_DBL) >> 8; }
inline uint32_t tim15_dcr_get_dba(struct TIM15_Type* p) { return (p->DCR & TIM15_DCR_DBA) >> 0; }

// Valid Casts:

inline struct TIM16_Type* TIM15_as_TIM16_Type(struct TIM15_Type* p) { return (struct TIM16_Type*)p; }

inline struct TIM6_Type* TIM15_as_TIM6_Type(struct TIM15_Type* p) { return (struct TIM6_Type*)p; }

/* General purpose timers */
struct TIM16_Type {
	__IO uint16_t CR1;              // @0 control register 1
	uint8_t       RESERVED0[2];     // @2
	__IO uint16_t CR2;              // @4 control register 2
	uint8_t       RESERVED1[6];     // @6
	__IO uint16_t DIER;             // @12 DMA/Interrupt enable register
	uint8_t       RESERVED2[2];     // @14
	__IO uint16_t SR;               // @16 status register
	uint8_t       RESERVED3[2];     // @18
	__O uint8_t   EGR;              // @20 event generation register
	uint8_t       RESERVED4[3];     // @21
	union {                         // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t  CCMR1_Input;  // capture/compare mode register 1 (input mode)
	};
	uint8_t       RESERVED5[4];    // @28
	__IO uint8_t  CCER;            // @32 capture/compare enable register
	uint8_t       RESERVED6[3];    // @33
	__IO uint32_t CNT;             // @36 counter
	__IO uint16_t PSC;             // @40 prescaler
	uint8_t       RESERVED7[2];    // @42
	__IO uint16_t ARR;             // @44 auto-reload register
	uint8_t       RESERVED8[2];    // @46
	__IO uint8_t  RCR;             // @48 repetition counter register
	uint8_t       RESERVED9[3];    // @49
	__IO uint16_t CCR1;            // @52 capture/compare register 1
	uint8_t       RESERVED10[14];  // @54
	__IO uint32_t BDTR;            // @68 break and dead-time register
	uint8_t       RESERVED11[12];  // @72
	__IO uint32_t DTR2;            // @84 timer Deadtime Register 2
	uint8_t       RESERVED12[4];   // @88
	__IO uint8_t  TISEL;           // @92 TIM timer input selection register
	uint8_t       RESERVED13[3];   // @93
	__IO uint16_t AF1;             // @96 TIM alternate function option register 1
	uint8_t       RESERVED14[2];   // @98
	__IO uint32_t AF2;             // @100 TIM alternate function option register 2
	uint8_t       RESERVED15[884]; // @104
	__IO uint16_t DCR;             // @988 DMA control register
	uint8_t       RESERVED16[2];   // @990
	__IO uint32_t DMAR;            // @992 DMA address for full transfer
};

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_DITHEN   = 1UL << 12,             // Dithering Enable
	TIM16_CR1_UIFREMAP = 1UL << 11,             // UIF status bit remapping
	TIM16_CR1_CKD      = ((1UL << 2) - 1) << 8, // Clock division
	TIM16_CR1_ARPE     = 1UL << 7,              // Auto-reload preload enable
	TIM16_CR1_OPM      = 1UL << 3,              // One-pulse mode
	TIM16_CR1_URS      = 1UL << 2,              // Update request source
	TIM16_CR1_UDIS     = 1UL << 1,              // Update disable
	TIM16_CR1_CEN      = 1UL << 0,              // Counter enable
};
inline void     tim16_cr1_set_ckd(struct TIM16_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM16_CR1_CKD) | ((val << 8) & TIM16_CR1_CKD); }
inline uint32_t tim16_cr1_get_ckd(struct TIM16_Type* p) { return (p->CR1 & TIM16_CR1_CKD) >> 8; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL << 9, // Output Idle state 1
	TIM16_CR2_OIS1  = 1UL << 8, // Output Idle state 1
	TIM16_CR2_CCDS  = 1UL << 3, // Capture/compare DMA selection
	TIM16_CR2_CCUS  = 1UL << 2, // Capture/compare control update selection
	TIM16_CR2_CCPC  = 1UL << 0, // Capture/compare preloaded control
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_COMDE = 1UL << 13, // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL << 9,  // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE   = 1UL << 8,  // Update DMA request enable
	TIM16_DIER_BIE   = 1UL << 7,  // Break interrupt enable
	TIM16_DIER_COMIE = 1UL << 5,  // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL << 1,  // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE   = 1UL << 0,  // Update interrupt enable
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL << 9, // Capture/Compare 1 overcapture flag
	TIM16_SR_BIF   = 1UL << 7, // Break interrupt flag
	TIM16_SR_COMIF = 1UL << 5, // COM interrupt flag
	TIM16_SR_CC1IF = 1UL << 1, // Capture/compare 1 interrupt flag
	TIM16_SR_UIF   = 1UL << 0, // Update interrupt flag
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG   = 1UL << 7, // Break generation
	TIM16_EGR_COMG = 1UL << 5, // Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL << 1, // Capture/compare 1 generation
	TIM16_EGR_UG   = 1UL << 0, // Update generation
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_3 = 1UL << 16,             // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M   = ((1UL << 3) - 1) << 4, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE  = 1UL << 3,              // Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE  = 1UL << 2,              // Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S   = ((1UL << 2) - 1) << 0, // Capture/Compare 1 selection
};
inline void tim16_ccmr1_output_set_oc1m(struct TIM16_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val << 4) & TIM16_CCMR1_OUTPUT_OC1M);
}
inline void tim16_ccmr1_output_set_cc1s(struct TIM16_Type* p, uint32_t val) {
	p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val << 0) & TIM16_CCMR1_OUTPUT_CC1S);
}
inline uint32_t tim16_ccmr1_output_get_oc1m(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4; }
inline uint32_t tim16_ccmr1_output_get_cc1s(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL << 3, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL << 2, // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P  = 1UL << 1, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E  = 1UL << 0, // Capture/Compare 1 output enable
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL << 31,              // UIF Copy
	TIM16_CNT_CNT    = ((1UL << 16) - 1) << 0, // counter value
};
inline void     tim16_cnt_set_cnt(struct TIM16_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM16_CNT_CNT) | ((val << 0) & TIM16_CNT_CNT); }
inline uint32_t tim16_cnt_get_cnt(struct TIM16_Type* p) { return (p->CNT & TIM16_CNT_CNT) >> 0; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKBID  = 1UL << 28,              // BKBID
	TIM16_BDTR_BKDSRM = 1UL << 26,              // BKDSRM
	TIM16_BDTR_BKF    = ((1UL << 4) - 1) << 16, // Break filter
	TIM16_BDTR_MOE    = 1UL << 15,              // Main output enable
	TIM16_BDTR_AOE    = 1UL << 14,              // Automatic output enable
	TIM16_BDTR_BKP    = 1UL << 13,              // Break polarity
	TIM16_BDTR_BKE    = 1UL << 12,              // Break enable
	TIM16_BDTR_OSSR   = 1UL << 11,              // Off-state selection for Run mode
	TIM16_BDTR_OSSI   = 1UL << 10,              // Off-state selection for Idle mode
	TIM16_BDTR_LOCK   = ((1UL << 2) - 1) << 8,  // Lock configuration
	TIM16_BDTR_DTG    = ((1UL << 8) - 1) << 0,  // Dead-time generator setup
};
inline void tim16_bdtr_set_bkf(struct TIM16_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM16_BDTR_BKF) | ((val << 16) & TIM16_BDTR_BKF);
}
inline void tim16_bdtr_set_lock(struct TIM16_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM16_BDTR_LOCK) | ((val << 8) & TIM16_BDTR_LOCK);
}
inline void tim16_bdtr_set_dtg(struct TIM16_Type* p, uint32_t val) {
	p->BDTR = (p->BDTR & ~TIM16_BDTR_DTG) | ((val << 0) & TIM16_BDTR_DTG);
}
inline uint32_t tim16_bdtr_get_bkf(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_BKF) >> 16; }
inline uint32_t tim16_bdtr_get_lock(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_LOCK) >> 8; }
inline uint32_t tim16_bdtr_get_dtg(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_DTG) >> 0; }

// TIM16->DTR2 timer Deadtime Register 2
enum {
	TIM16_DTR2_DTPE = 1UL << 17,             // Deadtime Preload Enable
	TIM16_DTR2_DTAE = 1UL << 16,             // Deadtime Asymmetric Enable
	TIM16_DTR2_DTGF = ((1UL << 8) - 1) << 0, // Dead-time generator setup
};
inline void tim16_dtr2_set_dtgf(struct TIM16_Type* p, uint32_t val) {
	p->DTR2 = (p->DTR2 & ~TIM16_DTR2_DTGF) | ((val << 0) & TIM16_DTR2_DTGF);
}
inline uint32_t tim16_dtr2_get_dtgf(struct TIM16_Type* p) { return (p->DTR2 & TIM16_DTR2_DTGF) >> 0; }

// TIM16->TISEL TIM timer input selection register
enum {
	TIM16_TISEL_TI1SEL = ((1UL << 4) - 1) << 0, // TI1[0] to TI1[15] input selection
};
inline void tim16_tisel_set_ti1sel(struct TIM16_Type* p, uint32_t val) {
	p->TISEL = (p->TISEL & ~TIM16_TISEL_TI1SEL) | ((val << 0) & TIM16_TISEL_TI1SEL);
}
inline uint32_t tim16_tisel_get_ti1sel(struct TIM16_Type* p) { return (p->TISEL & TIM16_TISEL_TI1SEL) >> 0; }

// TIM16->AF1 TIM alternate function option register 1
enum {
	TIM16_AF1_BKCMP4P = 1UL << 13, // BRK COMP4 input polarity
	TIM16_AF1_BKCMP3P = 1UL << 12, // BRK COMP3 input polarity
	TIM16_AF1_BKCMP2P = 1UL << 11, // BRK COMP2 input polarity
	TIM16_AF1_BKCMP1P = 1UL << 10, // BRK COMP1 input polarity
	TIM16_AF1_BKINP   = 1UL << 9,  // BRK BKIN input polarity
	TIM16_AF1_BKCMP7E = 1UL << 7,  // BRK COMP7 enable
	TIM16_AF1_BKCMP6E = 1UL << 6,  // BRK COMP6 enable
	TIM16_AF1_BKCMP5E = 1UL << 5,  // BRK COMP5 enable
	TIM16_AF1_BKCMP4E = 1UL << 4,  // BRK COMP4 enable
	TIM16_AF1_BKCMP3E = 1UL << 3,  // BRK COMP3 enable
	TIM16_AF1_BKCMP2E = 1UL << 2,  // BRK COMP2 enable
	TIM16_AF1_BKCMP1E = 1UL << 1,  // BRK COMP1 enable
	TIM16_AF1_BKINE   = 1UL << 0,  // BRK BKIN input enable
};

// TIM16->AF2 TIM alternate function option register 2
enum {
	TIM16_AF2_OCRSEL = ((1UL << 3) - 1) << 16, // OCREF_CLR source selection
};
inline void tim16_af2_set_ocrsel(struct TIM16_Type* p, uint32_t val) {
	p->AF2 = (p->AF2 & ~TIM16_AF2_OCRSEL) | ((val << 16) & TIM16_AF2_OCRSEL);
}
inline uint32_t tim16_af2_get_ocrsel(struct TIM16_Type* p) { return (p->AF2 & TIM16_AF2_OCRSEL) >> 16; }

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL << 5) - 1) << 8, // DMA burst length
	TIM16_DCR_DBA = ((1UL << 5) - 1) << 0, // DMA base address
};
inline void     tim16_dcr_set_dbl(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBL) | ((val << 8) & TIM16_DCR_DBL); }
inline void     tim16_dcr_set_dba(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBA) | ((val << 0) & TIM16_DCR_DBA); }
inline uint32_t tim16_dcr_get_dbl(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBL) >> 8; }
inline uint32_t tim16_dcr_get_dba(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBA) >> 0; }

/* Basic-timers */
struct TIM6_Type {
	__IO uint16_t CR1;           // @0 control register 1
	uint8_t       RESERVED0[2];  // @2
	__IO uint8_t  CR2;           // @4 control register 2
	uint8_t       RESERVED1[7];  // @5
	__IO uint16_t DIER;          // @12 DMA/Interrupt enable register
	uint8_t       RESERVED2[2];  // @14
	__IO uint8_t  SR;            // @16 status register
	uint8_t       RESERVED3[3];  // @17
	__O uint8_t   EGR;           // @20 event generation register
	uint8_t       RESERVED4[15]; // @21
	__IO uint32_t CNT;           // @36 counter
	__IO uint16_t PSC;           // @40 prescaler
	uint8_t       RESERVED5[2];  // @42
	__IO uint16_t ARR;           // @44 auto-reload register
};

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_DITHEN   = 1UL << 12, // Dithering Enable
	TIM6_CR1_UIFREMAP = 1UL << 11, // UIF status bit remapping
	TIM6_CR1_ARPE     = 1UL << 7,  // Auto-reload preload enable
	TIM6_CR1_OPM      = 1UL << 3,  // One-pulse mode
	TIM6_CR1_URS      = 1UL << 2,  // Update request source
	TIM6_CR1_UDIS     = 1UL << 1,  // Update disable
	TIM6_CR1_CEN      = 1UL << 0,  // Counter enable
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL << 3) - 1) << 4, // Master mode selection
};
inline void     tim6_cr2_set_mms(struct TIM6_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val << 4) & TIM6_CR2_MMS); }
inline uint32_t tim6_cr2_get_mms(struct TIM6_Type* p) { return (p->CR2 & TIM6_CR2_MMS) >> 4; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL << 8, // Update DMA request enable
	TIM6_DIER_UIE = 1UL << 0, // Update interrupt enable
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL << 0, // Update interrupt flag
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL << 0, // Update generation
};

// TIM6->CNT counter
enum {
	TIM6_CNT_UIFCPY = 1UL << 31,              // UIF Copy
	TIM6_CNT_CNT    = ((1UL << 16) - 1) << 0, // Low counter value
};
inline void     tim6_cnt_set_cnt(struct TIM6_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM6_CNT_CNT) | ((val << 0) & TIM6_CNT_CNT); }
inline uint32_t tim6_cnt_get_cnt(struct TIM6_Type* p) { return (p->CNT & TIM6_CNT_CNT) >> 0; }

/* Universal synchronous asynchronous receiver transmitter */
struct USART_Type {
	__IO uint32_t CR1;          // @0 Control register 1
	__IO uint32_t CR2;          // @4 Control register 2
	__IO uint32_t CR3;          // @8 Control register 3
	__IO uint16_t BRR;          // @12 Baud rate register
	uint8_t       RESERVED0[2]; // @14
	__IO uint16_t GTPR;         // @16 Guard time and prescaler register
	uint8_t       RESERVED1[2]; // @18
	__IO uint32_t RTOR;         // @20 Receiver timeout register
	__O uint8_t   RQR;          // @24 Request register
	uint8_t       RESERVED2[3]; // @25
	__I uint32_t  ISR;          // @28 Interrupt & status register
	__O uint32_t  ICR;          // @32 Interrupt flag clear register
	__I uint16_t  RDR;          // @36 Receive data register
	uint8_t       RESERVED3[2]; // @38
	__IO uint16_t TDR;          // @40 Transmit data register
	uint8_t       RESERVED4[2]; // @42
	__IO uint8_t  PRESC;        // @44 USART prescaler register
};

// USART->CR1 Control register 1
enum {
	USART_CR1_RXFFIE = 1UL << 31, // RXFFIE
	USART_CR1_TXFEIE = 1UL << 30, // TXFEIE
	USART_CR1_FIFOEN = 1UL << 29, // FIFOEN
	USART_CR1_M1     = 1UL << 28, // M1
	USART_CR1_EOBIE  = 1UL << 27, // End of Block interrupt enable
	USART_CR1_RTOIE  = 1UL << 26, // Receiver timeout interrupt enable
	USART_CR1_DEAT4  = 1UL << 25, // Driver Enable assertion time
	USART_CR1_DEAT3  = 1UL << 24, // DEAT3
	USART_CR1_DEAT2  = 1UL << 23, // DEAT2
	USART_CR1_DEAT1  = 1UL << 22, // DEAT1
	USART_CR1_DEAT0  = 1UL << 21, // DEAT0
	USART_CR1_DEDT4  = 1UL << 20, // Driver Enable de-assertion time
	USART_CR1_DEDT3  = 1UL << 19, // DEDT3
	USART_CR1_DEDT2  = 1UL << 18, // DEDT2
	USART_CR1_DEDT1  = 1UL << 17, // DEDT1
	USART_CR1_DEDT0  = 1UL << 16, // DEDT0
	USART_CR1_OVER8  = 1UL << 15, // Oversampling mode
	USART_CR1_CMIE   = 1UL << 14, // Character match interrupt enable
	USART_CR1_MME    = 1UL << 13, // Mute mode enable
	USART_CR1_M0     = 1UL << 12, // Word length
	USART_CR1_WAKE   = 1UL << 11, // Receiver wakeup method
	USART_CR1_PCE    = 1UL << 10, // Parity control enable
	USART_CR1_PS     = 1UL << 9,  // Parity selection
	USART_CR1_PEIE   = 1UL << 8,  // PE interrupt enable
	USART_CR1_TXEIE  = 1UL << 7,  // interrupt enable
	USART_CR1_TCIE   = 1UL << 6,  // Transmission complete interrupt enable
	USART_CR1_RXNEIE = 1UL << 5,  // RXNE interrupt enable
	USART_CR1_IDLEIE = 1UL << 4,  // IDLE interrupt enable
	USART_CR1_TE     = 1UL << 3,  // Transmitter enable
	USART_CR1_RE     = 1UL << 2,  // Receiver enable
	USART_CR1_UESM   = 1UL << 1,  // USART enable in Stop mode
	USART_CR1_UE     = 1UL << 0,  // USART enable
};

// USART->CR2 Control register 2
enum {
	USART_CR2_ADD4_7   = ((1UL << 4) - 1) << 28, // Address of the USART node
	USART_CR2_ADD0_3   = ((1UL << 4) - 1) << 24, // Address of the USART node
	USART_CR2_RTOEN    = 1UL << 23,              // Receiver timeout enable
	USART_CR2_ABRMOD1  = 1UL << 22,              // Auto baud rate mode
	USART_CR2_ABRMOD0  = 1UL << 21,              // ABRMOD0
	USART_CR2_ABREN    = 1UL << 20,              // Auto baud rate enable
	USART_CR2_MSBFIRST = 1UL << 19,              // Most significant bit first
	USART_CR2_TAINV    = 1UL << 18,              // Binary data inversion
	USART_CR2_TXINV    = 1UL << 17,              // TX pin active level inversion
	USART_CR2_RXINV    = 1UL << 16,              // RX pin active level inversion
	USART_CR2_SWAP     = 1UL << 15,              // Swap TX/RX pins
	USART_CR2_LINEN    = 1UL << 14,              // LIN mode enable
	USART_CR2_STOP     = ((1UL << 2) - 1) << 12, // STOP bits
	USART_CR2_CLKEN    = 1UL << 11,              // Clock enable
	USART_CR2_CPOL     = 1UL << 10,              // Clock polarity
	USART_CR2_CPHA     = 1UL << 9,               // Clock phase
	USART_CR2_LBCL     = 1UL << 8,               // Last bit clock pulse
	USART_CR2_LBDIE    = 1UL << 6,               // LIN break detection interrupt enable
	USART_CR2_LBDL     = 1UL << 5,               // LIN break detection length
	USART_CR2_ADDM7    = 1UL << 4,               // 7-bit Address Detection/4-bit Address Detection
	USART_CR2_DIS_NSS  = 1UL << 3,               // DIS_NSS
	USART_CR2_SLVEN    = 1UL << 0,               // SLVEN
};
inline void usart_cr2_set_add4_7(struct USART_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~USART_CR2_ADD4_7) | ((val << 28) & USART_CR2_ADD4_7);
}
inline void usart_cr2_set_add0_3(struct USART_Type* p, uint32_t val) {
	p->CR2 = (p->CR2 & ~USART_CR2_ADD0_3) | ((val << 24) & USART_CR2_ADD0_3);
}
inline void usart_cr2_set_stop(struct USART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART_CR2_STOP) | ((val << 12) & USART_CR2_STOP); }
inline uint32_t usart_cr2_get_add4_7(struct USART_Type* p) { return (p->CR2 & USART_CR2_ADD4_7) >> 28; }
inline uint32_t usart_cr2_get_add0_3(struct USART_Type* p) { return (p->CR2 & USART_CR2_ADD0_3) >> 24; }
inline uint32_t usart_cr2_get_stop(struct USART_Type* p) { return (p->CR2 & USART_CR2_STOP) >> 12; }

// USART->CR3 Control register 3
enum {
	USART_CR3_TXFTCFG = ((1UL << 3) - 1) << 29, // TXFTCFG
	USART_CR3_RXFTIE  = 1UL << 28,              // RXFTIE
	USART_CR3_RXFTCFG = ((1UL << 3) - 1) << 25, // RXFTCFG
	USART_CR3_TCBGTIE = 1UL << 24,              // TCBGTIE
	USART_CR3_TXFTIE  = 1UL << 23,              // TXFTIE
	USART_CR3_WUFIE   = 1UL << 22,              // Wakeup from Stop mode interrupt enable
	USART_CR3_WUS     = ((1UL << 2) - 1) << 20, // Wakeup from Stop mode interrupt flag selection
	USART_CR3_SCARCNT = ((1UL << 3) - 1) << 17, // Smartcard auto-retry count
	USART_CR3_DEP     = 1UL << 15,              // Driver enable polarity selection
	USART_CR3_DEM     = 1UL << 14,              // Driver enable mode
	USART_CR3_DDRE    = 1UL << 13,              // DMA Disable on Reception Error
	USART_CR3_OVRDIS  = 1UL << 12,              // Overrun Disable
	USART_CR3_ONEBIT  = 1UL << 11,              // One sample bit method enable
	USART_CR3_CTSIE   = 1UL << 10,              // CTS interrupt enable
	USART_CR3_CTSE    = 1UL << 9,               // CTS enable
	USART_CR3_RTSE    = 1UL << 8,               // RTS enable
	USART_CR3_DMAT    = 1UL << 7,               // DMA enable transmitter
	USART_CR3_DMAR    = 1UL << 6,               // DMA enable receiver
	USART_CR3_SCEN    = 1UL << 5,               // Smartcard mode enable
	USART_CR3_NACK    = 1UL << 4,               // Smartcard NACK enable
	USART_CR3_HDSEL   = 1UL << 3,               // Half-duplex selection
	USART_CR3_IRLP    = 1UL << 2,               // Ir low-power
	USART_CR3_IREN    = 1UL << 1,               // Ir mode enable
	USART_CR3_EIE     = 1UL << 0,               // Error interrupt enable
};
inline void usart_cr3_set_txftcfg(struct USART_Type* p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_TXFTCFG) | ((val << 29) & USART_CR3_TXFTCFG);
}
inline void usart_cr3_set_rxftcfg(struct USART_Type* p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_RXFTCFG) | ((val << 25) & USART_CR3_RXFTCFG);
}
inline void usart_cr3_set_wus(struct USART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART_CR3_WUS) | ((val << 20) & USART_CR3_WUS); }
inline void usart_cr3_set_scarcnt(struct USART_Type* p, uint32_t val) {
	p->CR3 = (p->CR3 & ~USART_CR3_SCARCNT) | ((val << 17) & USART_CR3_SCARCNT);
}
inline uint32_t usart_cr3_get_txftcfg(struct USART_Type* p) { return (p->CR3 & USART_CR3_TXFTCFG) >> 29; }
inline uint32_t usart_cr3_get_rxftcfg(struct USART_Type* p) { return (p->CR3 & USART_CR3_RXFTCFG) >> 25; }
inline uint32_t usart_cr3_get_wus(struct USART_Type* p) { return (p->CR3 & USART_CR3_WUS) >> 20; }
inline uint32_t usart_cr3_get_scarcnt(struct USART_Type* p) { return (p->CR3 & USART_CR3_SCARCNT) >> 17; }

// USART->BRR Baud rate register
enum {
	USART_BRR_DIV_MANTISSA = ((1UL << 12) - 1) << 4, // DIV_Mantissa
	USART_BRR_DIV_FRACTION = ((1UL << 4) - 1) << 0,  // DIV_Fraction
};
inline void usart_brr_set_div_mantissa(struct USART_Type* p, uint32_t val) {
	p->BRR = (p->BRR & ~USART_BRR_DIV_MANTISSA) | ((val << 4) & USART_BRR_DIV_MANTISSA);
}
inline void usart_brr_set_div_fraction(struct USART_Type* p, uint32_t val) {
	p->BRR = (p->BRR & ~USART_BRR_DIV_FRACTION) | ((val << 0) & USART_BRR_DIV_FRACTION);
}
inline uint32_t usart_brr_get_div_mantissa(struct USART_Type* p) { return (p->BRR & USART_BRR_DIV_MANTISSA) >> 4; }
inline uint32_t usart_brr_get_div_fraction(struct USART_Type* p) { return (p->BRR & USART_BRR_DIV_FRACTION) >> 0; }

// USART->GTPR Guard time and prescaler register
enum {
	USART_GTPR_GT  = ((1UL << 8) - 1) << 8, // Guard time value
	USART_GTPR_PSC = ((1UL << 8) - 1) << 0, // Prescaler value
};
inline void usart_gtpr_set_gt(struct USART_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART_GTPR_GT) | ((val << 8) & USART_GTPR_GT); }
inline void usart_gtpr_set_psc(struct USART_Type* p, uint32_t val) {
	p->GTPR = (p->GTPR & ~USART_GTPR_PSC) | ((val << 0) & USART_GTPR_PSC);
}
inline uint32_t usart_gtpr_get_gt(struct USART_Type* p) { return (p->GTPR & USART_GTPR_GT) >> 8; }
inline uint32_t usart_gtpr_get_psc(struct USART_Type* p) { return (p->GTPR & USART_GTPR_PSC) >> 0; }

// USART->RTOR Receiver timeout register
enum {
	USART_RTOR_BLEN = ((1UL << 8) - 1) << 24, // Block Length
	USART_RTOR_RTO  = ((1UL << 24) - 1) << 0, // Receiver timeout value
};
inline void usart_rtor_set_blen(struct USART_Type* p, uint32_t val) {
	p->RTOR = (p->RTOR & ~USART_RTOR_BLEN) | ((val << 24) & USART_RTOR_BLEN);
}
inline void usart_rtor_set_rto(struct USART_Type* p, uint32_t val) {
	p->RTOR = (p->RTOR & ~USART_RTOR_RTO) | ((val << 0) & USART_RTOR_RTO);
}
inline uint32_t usart_rtor_get_blen(struct USART_Type* p) { return (p->RTOR & USART_RTOR_BLEN) >> 24; }
inline uint32_t usart_rtor_get_rto(struct USART_Type* p) { return (p->RTOR & USART_RTOR_RTO) >> 0; }

// USART->RQR Request register
enum {
	USART_RQR_TXFRQ = 1UL << 4, // Transmit data flush request
	USART_RQR_RXFRQ = 1UL << 3, // Receive data flush request
	USART_RQR_MMRQ  = 1UL << 2, // Mute mode request
	USART_RQR_SBKRQ = 1UL << 1, // Send break request
	USART_RQR_ABRRQ = 1UL << 0, // Auto baud rate request
};

// USART->ISR Interrupt & status register
enum {
	USART_ISR_TXFT  = 1UL << 27, // TXFT
	USART_ISR_RXFT  = 1UL << 26, // RXFT
	USART_ISR_TCBGT = 1UL << 25, // TCBGT
	USART_ISR_RXFF  = 1UL << 24, // RXFF
	USART_ISR_TXFE  = 1UL << 23, // TXFE
	USART_ISR_REACK = 1UL << 22, // REACK
	USART_ISR_TEACK = 1UL << 21, // TEACK
	USART_ISR_WUF   = 1UL << 20, // WUF
	USART_ISR_RWU   = 1UL << 19, // RWU
	USART_ISR_SBKF  = 1UL << 18, // SBKF
	USART_ISR_CMF   = 1UL << 17, // CMF
	USART_ISR_BUSY  = 1UL << 16, // BUSY
	USART_ISR_ABRF  = 1UL << 15, // ABRF
	USART_ISR_ABRE  = 1UL << 14, // ABRE
	USART_ISR_UDR   = 1UL << 13, // UDR
	USART_ISR_EOBF  = 1UL << 12, // EOBF
	USART_ISR_RTOF  = 1UL << 11, // RTOF
	USART_ISR_CTS   = 1UL << 10, // CTS
	USART_ISR_CTSIF = 1UL << 9,  // CTSIF
	USART_ISR_LBDF  = 1UL << 8,  // LBDF
	USART_ISR_TXE   = 1UL << 7,  // TXE
	USART_ISR_TC    = 1UL << 6,  // TC
	USART_ISR_RXNE  = 1UL << 5,  // RXNE
	USART_ISR_IDLE  = 1UL << 4,  // IDLE
	USART_ISR_ORE   = 1UL << 3,  // ORE
	USART_ISR_NF    = 1UL << 2,  // NF
	USART_ISR_FE    = 1UL << 1,  // FE
	USART_ISR_PE    = 1UL << 0,  // PE
};

// USART->ICR Interrupt flag clear register
enum {
	USART_ICR_WUCF    = 1UL << 20, // Wakeup from Stop mode clear flag
	USART_ICR_CMCF    = 1UL << 17, // Character match clear flag
	USART_ICR_UDRCF   = 1UL << 13, // UDRCF
	USART_ICR_EOBCF   = 1UL << 12, // End of block clear flag
	USART_ICR_RTOCF   = 1UL << 11, // Receiver timeout clear flag
	USART_ICR_CTSCF   = 1UL << 9,  // CTS clear flag
	USART_ICR_LBDCF   = 1UL << 8,  // LIN break detection clear flag
	USART_ICR_TCBGTCF = 1UL << 7,  // TCBGTCF
	USART_ICR_TCCF    = 1UL << 6,  // Transmission complete clear flag
	USART_ICR_TXFECF  = 1UL << 5,  // TXFECF
	USART_ICR_IDLECF  = 1UL << 4,  // Idle line detected clear flag
	USART_ICR_ORECF   = 1UL << 3,  // Overrun error clear flag
	USART_ICR_NCF     = 1UL << 2,  // Noise detected clear flag
	USART_ICR_FECF    = 1UL << 1,  // Framing error clear flag
	USART_ICR_PECF    = 1UL << 0,  // Parity error clear flag
};

// USART->RDR Receive data register
enum {
	USART_RDR_RDR = ((1UL << 9) - 1) << 0, // Receive data value
};
inline uint32_t usart_rdr_get_rdr(struct USART_Type* p) { return (p->RDR & USART_RDR_RDR) >> 0; }

// USART->TDR Transmit data register
enum {
	USART_TDR_TDR = ((1UL << 9) - 1) << 0, // Transmit data value
};
inline void     usart_tdr_set_tdr(struct USART_Type* p, uint32_t val) { p->TDR = (p->TDR & ~USART_TDR_TDR) | ((val << 0) & USART_TDR_TDR); }
inline uint32_t usart_tdr_get_tdr(struct USART_Type* p) { return (p->TDR & USART_TDR_TDR) >> 0; }

// USART->PRESC USART prescaler register
enum {
	USART_PRESC_PRESCALER = ((1UL << 4) - 1) << 0, // PRESCALER
};
inline void usart_presc_set_prescaler(struct USART_Type* p, uint32_t val) {
	p->PRESC = (p->PRESC & ~USART_PRESC_PRESCALER) | ((val << 0) & USART_PRESC_PRESCALER);
}
inline uint32_t usart_presc_get_prescaler(struct USART_Type* p) { return (p->PRESC & USART_PRESC_PRESCALER) >> 0; }

/* UCPD1 */
struct UCPD1_Type {
	__IO uint32_t CFG1;         // @0 UCPD configuration register 1
	__IO uint8_t  CFG2;         // @4 UCPD configuration register 2
	uint8_t       RESERVED0[7]; // @5
	__IO uint32_t CR;           // @12 UCPD configuration register 2
	__IO uint32_t IMR;          // @16 UCPD Interrupt Mask Register
	__IO uint32_t SR;           // @20 UCPD Status Register
	__IO uint32_t ICR;          // @24 UCPD Interrupt Clear Register
	__IO uint32_t TX_ORDSET;    // @28 UCPD Tx Ordered Set Type Register
	__IO uint16_t TX_PAYSZ;     // @32 UCPD Tx Paysize Register
	uint8_t       RESERVED1[2]; // @34
	__IO uint8_t  TXDR;         // @36 UCPD Tx Data Register
	uint8_t       RESERVED2[3]; // @37
	__I uint8_t   RX_ORDSET;    // @40 UCPD Rx Ordered Set Register
	uint8_t       RESERVED3[3]; // @41
	__I uint16_t  RX_PAYSZ;     // @44 UCPD Rx Paysize Register
	uint8_t       RESERVED4[2]; // @46
	__I uint8_t   RXDR;         // @48 UCPD Rx Data Register
	uint8_t       RESERVED5[3]; // @49
	__IO uint32_t RX_ORDEXT1;   // @52 UCPD Rx Ordered Set Extension Register 1
	__IO uint32_t RX_ORDEXT2;   // @56 UCPD Rx Ordered Set Extension Register 2
};

// UCPD1->CFG1 UCPD configuration register 1
enum {
	UCPD1_CFG1_UCPDEN       = 1UL << 31,              // UCPDEN
	UCPD1_CFG1_RXDMAEN      = 1UL << 30,              // RXDMAEN
	UCPD1_CFG1_TXDMAEN      = 1UL << 29,              // TXDMAEN
	UCPD1_CFG1_RXORDSETEN   = ((1UL << 9) - 1) << 20, // RXORDSETEN
	UCPD1_CFG1_PSC_USBPDCLK = ((1UL << 3) - 1) << 17, // PSC_USBPDCLK
	UCPD1_CFG1_TRANSWIN     = ((1UL << 5) - 1) << 11, // TRANSWIN
	UCPD1_CFG1_IFRGAP       = ((1UL << 5) - 1) << 6,  // IFRGAP
	UCPD1_CFG1_HBITCLKDIV   = ((1UL << 6) - 1) << 0,  // HBITCLKDIV
};
inline void ucpd1_cfg1_set_rxordseten(struct UCPD1_Type* p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_RXORDSETEN) | ((val << 20) & UCPD1_CFG1_RXORDSETEN);
}
inline void ucpd1_cfg1_set_psc_usbpdclk(struct UCPD1_Type* p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_PSC_USBPDCLK) | ((val << 17) & UCPD1_CFG1_PSC_USBPDCLK);
}
inline void ucpd1_cfg1_set_transwin(struct UCPD1_Type* p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_TRANSWIN) | ((val << 11) & UCPD1_CFG1_TRANSWIN);
}
inline void ucpd1_cfg1_set_ifrgap(struct UCPD1_Type* p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_IFRGAP) | ((val << 6) & UCPD1_CFG1_IFRGAP);
}
inline void ucpd1_cfg1_set_hbitclkdiv(struct UCPD1_Type* p, uint32_t val) {
	p->CFG1 = (p->CFG1 & ~UCPD1_CFG1_HBITCLKDIV) | ((val << 0) & UCPD1_CFG1_HBITCLKDIV);
}
inline uint32_t ucpd1_cfg1_get_rxordseten(struct UCPD1_Type* p) { return (p->CFG1 & UCPD1_CFG1_RXORDSETEN) >> 20; }
inline uint32_t ucpd1_cfg1_get_psc_usbpdclk(struct UCPD1_Type* p) { return (p->CFG1 & UCPD1_CFG1_PSC_USBPDCLK) >> 17; }
inline uint32_t ucpd1_cfg1_get_transwin(struct UCPD1_Type* p) { return (p->CFG1 & UCPD1_CFG1_TRANSWIN) >> 11; }
inline uint32_t ucpd1_cfg1_get_ifrgap(struct UCPD1_Type* p) { return (p->CFG1 & UCPD1_CFG1_IFRGAP) >> 6; }
inline uint32_t ucpd1_cfg1_get_hbitclkdiv(struct UCPD1_Type* p) { return (p->CFG1 & UCPD1_CFG1_HBITCLKDIV) >> 0; }

// UCPD1->CFG2 UCPD configuration register 2
enum {
	UCPD1_CFG2_WUPEN     = 1UL << 3, // WUPEN
	UCPD1_CFG2_FORCECLK  = 1UL << 2, // FORCECLK
	UCPD1_CFG2_RXFILT2N3 = 1UL << 1, // RXFILT2N3
	UCPD1_CFG2_RXFILTDIS = 1UL << 0, // RXFILTDIS
};

// UCPD1->CR UCPD configuration register 2
enum {
	UCPD1_CR_CC2TCDIS   = 1UL << 21,              // CC2TCDIS
	UCPD1_CR_CC1TCDIS   = 1UL << 20,              // CC1TCDIS
	UCPD1_CR_RDCH       = 1UL << 18,              // RDCH
	UCPD1_CR_FRSTX      = 1UL << 17,              // FRSTX
	UCPD1_CR_FRSRXEN    = 1UL << 16,              // FRSRXEN
	UCPD1_CR_CCENABLE   = ((1UL << 2) - 1) << 10, // CCENABLE
	UCPD1_CR_ANAMODE    = 1UL << 9,               // ANAMODE
	UCPD1_CR_ANASUBMODE = ((1UL << 2) - 1) << 7,  // ANASUBMODE
	UCPD1_CR_PHYCCSEL   = 1UL << 6,               // PHYCCSEL
	UCPD1_CR_PHYRXEN    = 1UL << 5,               // PHYRXEN
	UCPD1_CR_RXMODE     = 1UL << 4,               // RXMODE
	UCPD1_CR_TXHRST     = 1UL << 3,               // TXHRST
	UCPD1_CR_TXSEND     = 1UL << 2,               // TXSEND
	UCPD1_CR_TXMODE     = ((1UL << 2) - 1) << 0,  // TXMODE
};
inline void ucpd1_cr_set_ccenable(struct UCPD1_Type* p, uint32_t val) {
	p->CR = (p->CR & ~UCPD1_CR_CCENABLE) | ((val << 10) & UCPD1_CR_CCENABLE);
}
inline void ucpd1_cr_set_anasubmode(struct UCPD1_Type* p, uint32_t val) {
	p->CR = (p->CR & ~UCPD1_CR_ANASUBMODE) | ((val << 7) & UCPD1_CR_ANASUBMODE);
}
inline void ucpd1_cr_set_txmode(struct UCPD1_Type* p, uint32_t val) { p->CR = (p->CR & ~UCPD1_CR_TXMODE) | ((val << 0) & UCPD1_CR_TXMODE); }
inline uint32_t ucpd1_cr_get_ccenable(struct UCPD1_Type* p) { return (p->CR & UCPD1_CR_CCENABLE) >> 10; }
inline uint32_t ucpd1_cr_get_anasubmode(struct UCPD1_Type* p) { return (p->CR & UCPD1_CR_ANASUBMODE) >> 7; }
inline uint32_t ucpd1_cr_get_txmode(struct UCPD1_Type* p) { return (p->CR & UCPD1_CR_TXMODE) >> 0; }

// UCPD1->IMR UCPD Interrupt Mask Register
enum {
	UCPD1_IMR_FRSEVTIE    = 1UL << 20, // FRSEVTIE
	UCPD1_IMR_TYPECEVT2IE = 1UL << 15, // TYPECEVT2IE
	UCPD1_IMR_TYPECEVT1IE = 1UL << 14, // TYPECEVT1IE
	UCPD1_IMR_RXMSGENDIE  = 1UL << 12, // RXMSGENDIE
	UCPD1_IMR_RXOVRIE     = 1UL << 11, // RXOVRIE
	UCPD1_IMR_RXHRSTDETIE = 1UL << 10, // RXHRSTDETIE
	UCPD1_IMR_RXORDDETIE  = 1UL << 9,  // RXORDDETIE
	UCPD1_IMR_RXNEIE      = 1UL << 8,  // RXNEIE
	UCPD1_IMR_TXUNDIE     = 1UL << 6,  // TXUNDIE
	UCPD1_IMR_HRSTSENTIE  = 1UL << 5,  // HRSTSENTIE
	UCPD1_IMR_HRSTDISCIE  = 1UL << 4,  // HRSTDISCIE
	UCPD1_IMR_TXMSGABTIE  = 1UL << 3,  // TXMSGABTIE
	UCPD1_IMR_TXMSGSENTIE = 1UL << 2,  // TXMSGSENTIE
	UCPD1_IMR_TXMSGDISCIE = 1UL << 1,  // TXMSGDISCIE
	UCPD1_IMR_TXISIE      = 1UL << 0,  // TXISIE
};

// UCPD1->SR UCPD Status Register
enum {
	UCPD1_SR_FRSEVT           = 1UL << 20,              // FRSEVT
	UCPD1_SR_TYPEC_VSTATE_CC2 = ((1UL << 2) - 1) << 18, // TYPEC_VSTATE_CC2
	UCPD1_SR_TYPEC_VSTATE_CC1 = ((1UL << 2) - 1) << 16, // TYPEC_VSTATE_CC1
	UCPD1_SR_TYPECEVT2        = 1UL << 15,              // TYPECEVT2
	UCPD1_SR_TYPECEVT1        = 1UL << 14,              // TYPECEVT1
	UCPD1_SR_RXERR            = 1UL << 13,              // RXERR
	UCPD1_SR_RXMSGEND         = 1UL << 12,              // RXMSGEND
	UCPD1_SR_RXOVR            = 1UL << 11,              // RXOVR
	UCPD1_SR_RXHRSTDET        = 1UL << 10,              // RXHRSTDET
	UCPD1_SR_RXORDDET         = 1UL << 9,               // RXORDDET
	UCPD1_SR_RXNE             = 1UL << 8,               // RXNE
	UCPD1_SR_TXUND            = 1UL << 6,               // TXUND
	UCPD1_SR_HRSTSENT         = 1UL << 5,               // HRSTSENT
	UCPD1_SR_HRSTDISC         = 1UL << 4,               // HRSTDISC
	UCPD1_SR_TXMSGABT         = 1UL << 3,               // TXMSGABT
	UCPD1_SR_TXMSGSENT        = 1UL << 2,               // TXMSGSENT
	UCPD1_SR_TXMSGDISC        = 1UL << 1,               // TXMSGDISC
	UCPD1_SR_TXIS             = 1UL << 0,               // TXIS
};
inline void ucpd1_sr_set_typec_vstate_cc2(struct UCPD1_Type* p, uint32_t val) {
	p->SR = (p->SR & ~UCPD1_SR_TYPEC_VSTATE_CC2) | ((val << 18) & UCPD1_SR_TYPEC_VSTATE_CC2);
}
inline void ucpd1_sr_set_typec_vstate_cc1(struct UCPD1_Type* p, uint32_t val) {
	p->SR = (p->SR & ~UCPD1_SR_TYPEC_VSTATE_CC1) | ((val << 16) & UCPD1_SR_TYPEC_VSTATE_CC1);
}
inline uint32_t ucpd1_sr_get_typec_vstate_cc2(struct UCPD1_Type* p) { return (p->SR & UCPD1_SR_TYPEC_VSTATE_CC2) >> 18; }
inline uint32_t ucpd1_sr_get_typec_vstate_cc1(struct UCPD1_Type* p) { return (p->SR & UCPD1_SR_TYPEC_VSTATE_CC1) >> 16; }

// UCPD1->ICR UCPD Interrupt Clear Register
enum {
	UCPD1_ICR_FRSEVTCF    = 1UL << 20, // FRSEVTCF
	UCPD1_ICR_TYPECEVT2CF = 1UL << 15, // TYPECEVT2CF
	UCPD1_ICR_TYPECEVT1CF = 1UL << 14, // TYPECEVT1CF
	UCPD1_ICR_RXMSGENDCF  = 1UL << 12, // RXMSGENDCF
	UCPD1_ICR_RXOVRCF     = 1UL << 11, // RXOVRCF
	UCPD1_ICR_RXHRSTDETCF = 1UL << 10, // RXHRSTDETCF
	UCPD1_ICR_RXORDDETCF  = 1UL << 9,  // RXORDDETCF
	UCPD1_ICR_TXUNDCF     = 1UL << 6,  // TXUNDCF
	UCPD1_ICR_HRSTSENTCF  = 1UL << 5,  // HRSTSENTCF
	UCPD1_ICR_HRSTDISCCF  = 1UL << 4,  // HRSTDISCCF
	UCPD1_ICR_TXMSGABTCF  = 1UL << 3,  // TXMSGABTCF
	UCPD1_ICR_TXMSGSENTCF = 1UL << 2,  // TXMSGSENTCF
	UCPD1_ICR_TXMSGDISCCF = 1UL << 1,  // TXMSGDISCCF
};

// UCPD1->TX_ORDSET UCPD Tx Ordered Set Type Register
enum {
	UCPD1_TX_ORDSET_TXORDSET = ((1UL << 20) - 1) << 0, // TXORDSET
};
inline void ucpd1_tx_ordset_set_txordset(struct UCPD1_Type* p, uint32_t val) {
	p->TX_ORDSET = (p->TX_ORDSET & ~UCPD1_TX_ORDSET_TXORDSET) | ((val << 0) & UCPD1_TX_ORDSET_TXORDSET);
}
inline uint32_t ucpd1_tx_ordset_get_txordset(struct UCPD1_Type* p) { return (p->TX_ORDSET & UCPD1_TX_ORDSET_TXORDSET) >> 0; }

// UCPD1->TX_PAYSZ UCPD Tx Paysize Register
enum {
	UCPD1_TX_PAYSZ_TXPAYSZ = ((1UL << 10) - 1) << 0, // TXPAYSZ
};
inline void ucpd1_tx_paysz_set_txpaysz(struct UCPD1_Type* p, uint32_t val) {
	p->TX_PAYSZ = (p->TX_PAYSZ & ~UCPD1_TX_PAYSZ_TXPAYSZ) | ((val << 0) & UCPD1_TX_PAYSZ_TXPAYSZ);
}
inline uint32_t ucpd1_tx_paysz_get_txpaysz(struct UCPD1_Type* p) { return (p->TX_PAYSZ & UCPD1_TX_PAYSZ_TXPAYSZ) >> 0; }

// UCPD1->RX_ORDSET UCPD Rx Ordered Set Register
enum {
	UCPD1_RX_ORDSET_RXSOPKINVALID = ((1UL << 3) - 1) << 4, // RXSOPKINVALID
	UCPD1_RX_ORDSET_RXSOP3OF4     = 1UL << 3,              // RXSOP3OF4
	UCPD1_RX_ORDSET_RXORDSET      = ((1UL << 3) - 1) << 0, // RXORDSET
};
inline uint32_t ucpd1_rx_ordset_get_rxsopkinvalid(struct UCPD1_Type* p) { return (p->RX_ORDSET & UCPD1_RX_ORDSET_RXSOPKINVALID) >> 4; }
inline uint32_t ucpd1_rx_ordset_get_rxordset(struct UCPD1_Type* p) { return (p->RX_ORDSET & UCPD1_RX_ORDSET_RXORDSET) >> 0; }

// UCPD1->RX_PAYSZ UCPD Rx Paysize Register
enum {
	UCPD1_RX_PAYSZ_RXPAYSZ = ((1UL << 10) - 1) << 0, // RXPAYSZ
};
inline uint32_t ucpd1_rx_paysz_get_rxpaysz(struct UCPD1_Type* p) { return (p->RX_PAYSZ & UCPD1_RX_PAYSZ_RXPAYSZ) >> 0; }

// UCPD1->RX_ORDEXT1 UCPD Rx Ordered Set Extension Register 1
enum {
	UCPD1_RX_ORDEXT1_RXSOPX1 = ((1UL << 20) - 1) << 0, // RXSOPX1
};
inline void ucpd1_rx_ordext1_set_rxsopx1(struct UCPD1_Type* p, uint32_t val) {
	p->RX_ORDEXT1 = (p->RX_ORDEXT1 & ~UCPD1_RX_ORDEXT1_RXSOPX1) | ((val << 0) & UCPD1_RX_ORDEXT1_RXSOPX1);
}
inline uint32_t ucpd1_rx_ordext1_get_rxsopx1(struct UCPD1_Type* p) { return (p->RX_ORDEXT1 & UCPD1_RX_ORDEXT1_RXSOPX1) >> 0; }

// UCPD1->RX_ORDEXT2 UCPD Rx Ordered Set Extension Register 2
enum {
	UCPD1_RX_ORDEXT2_RXSOPX2 = ((1UL << 20) - 1) << 0, // RXSOPX2
};
inline void ucpd1_rx_ordext2_set_rxsopx2(struct UCPD1_Type* p, uint32_t val) {
	p->RX_ORDEXT2 = (p->RX_ORDEXT2 & ~UCPD1_RX_ORDEXT2_RXSOPX2) | ((val << 0) & UCPD1_RX_ORDEXT2_RXSOPX2);
}
inline uint32_t ucpd1_rx_ordext2_get_rxsopx2(struct UCPD1_Type* p) { return (p->RX_ORDEXT2 & UCPD1_RX_ORDEXT2_RXSOPX2) >> 0; }

/* USB_FS_device */
struct USB_FS_device_Type {
	__IO uint16_t EP0R;          // @0 USB endpoint n register
	uint8_t       RESERVED0[2];  // @2
	__IO uint16_t EP1R;          // @4 USB endpoint n register
	uint8_t       RESERVED1[2];  // @6
	__IO uint16_t EP2R;          // @8 USB endpoint n register
	uint8_t       RESERVED2[2];  // @10
	__IO uint16_t EP3R;          // @12 USB endpoint n register
	uint8_t       RESERVED3[2];  // @14
	__IO uint16_t EP4R;          // @16 USB endpoint n register
	uint8_t       RESERVED4[2];  // @18
	__IO uint16_t EP5R;          // @20 USB endpoint n register
	uint8_t       RESERVED5[2];  // @22
	__IO uint16_t EP6R;          // @24 USB endpoint n register
	uint8_t       RESERVED6[2];  // @26
	__IO uint16_t EP7R;          // @28 USB endpoint n register
	uint8_t       RESERVED7[34]; // @30
	__IO uint16_t CNTR;          // @64 USB control register
	uint8_t       RESERVED8[2];  // @66
	__IO uint16_t ISTR;          // @68 USB interrupt status register
	uint8_t       RESERVED9[2];  // @70
	__I uint16_t  FNR;           // @72 USB frame number register
	uint8_t       RESERVED10[2]; // @74
	__IO uint8_t  DADDR;         // @76 USB device address
	uint8_t       RESERVED11[3]; // @77
	__IO uint16_t BTABLE;        // @80 Buffer table address
};

// USB_FS_device->EP0R USB endpoint n register
enum {
	USB_FS_DEVICE_EP0R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP0R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP0R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP0R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP0R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP0R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP0R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP0R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP0R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP0R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep0r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP0R_STAT_RX);
}
inline void usb_fs_device_ep0r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP0R_EP_TYPE);
}
inline void usb_fs_device_ep0r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP0R_STAT_TX);
}
inline void usb_fs_device_ep0r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP0R = (p->EP0R & ~USB_FS_DEVICE_EP0R_EA) | ((val << 0) & USB_FS_DEVICE_EP0R_EA);
}
inline uint32_t usb_fs_device_ep0r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep0r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep0r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep0r_get_ea(struct USB_FS_device_Type* p) { return (p->EP0R & USB_FS_DEVICE_EP0R_EA) >> 0; }

// USB_FS_device->EP1R USB endpoint n register
enum {
	USB_FS_DEVICE_EP1R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP1R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP1R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP1R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP1R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP1R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP1R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP1R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP1R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP1R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep1r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP1R_STAT_RX);
}
inline void usb_fs_device_ep1r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP1R_EP_TYPE);
}
inline void usb_fs_device_ep1r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP1R_STAT_TX);
}
inline void usb_fs_device_ep1r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP1R = (p->EP1R & ~USB_FS_DEVICE_EP1R_EA) | ((val << 0) & USB_FS_DEVICE_EP1R_EA);
}
inline uint32_t usb_fs_device_ep1r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep1r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep1r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep1r_get_ea(struct USB_FS_device_Type* p) { return (p->EP1R & USB_FS_DEVICE_EP1R_EA) >> 0; }

// USB_FS_device->EP2R USB endpoint n register
enum {
	USB_FS_DEVICE_EP2R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP2R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP2R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP2R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP2R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP2R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP2R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP2R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP2R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP2R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep2r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP2R_STAT_RX);
}
inline void usb_fs_device_ep2r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP2R_EP_TYPE);
}
inline void usb_fs_device_ep2r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP2R_STAT_TX);
}
inline void usb_fs_device_ep2r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP2R = (p->EP2R & ~USB_FS_DEVICE_EP2R_EA) | ((val << 0) & USB_FS_DEVICE_EP2R_EA);
}
inline uint32_t usb_fs_device_ep2r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep2r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep2r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep2r_get_ea(struct USB_FS_device_Type* p) { return (p->EP2R & USB_FS_DEVICE_EP2R_EA) >> 0; }

// USB_FS_device->EP3R USB endpoint n register
enum {
	USB_FS_DEVICE_EP3R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP3R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP3R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP3R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP3R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP3R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP3R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP3R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP3R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP3R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep3r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP3R_STAT_RX);
}
inline void usb_fs_device_ep3r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP3R_EP_TYPE);
}
inline void usb_fs_device_ep3r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP3R_STAT_TX);
}
inline void usb_fs_device_ep3r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP3R = (p->EP3R & ~USB_FS_DEVICE_EP3R_EA) | ((val << 0) & USB_FS_DEVICE_EP3R_EA);
}
inline uint32_t usb_fs_device_ep3r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep3r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep3r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep3r_get_ea(struct USB_FS_device_Type* p) { return (p->EP3R & USB_FS_DEVICE_EP3R_EA) >> 0; }

// USB_FS_device->EP4R USB endpoint n register
enum {
	USB_FS_DEVICE_EP4R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP4R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP4R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP4R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP4R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP4R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP4R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP4R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP4R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP4R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep4r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP4R_STAT_RX);
}
inline void usb_fs_device_ep4r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP4R_EP_TYPE);
}
inline void usb_fs_device_ep4r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP4R_STAT_TX);
}
inline void usb_fs_device_ep4r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP4R = (p->EP4R & ~USB_FS_DEVICE_EP4R_EA) | ((val << 0) & USB_FS_DEVICE_EP4R_EA);
}
inline uint32_t usb_fs_device_ep4r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep4r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep4r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep4r_get_ea(struct USB_FS_device_Type* p) { return (p->EP4R & USB_FS_DEVICE_EP4R_EA) >> 0; }

// USB_FS_device->EP5R USB endpoint n register
enum {
	USB_FS_DEVICE_EP5R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP5R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP5R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP5R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP5R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP5R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP5R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP5R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP5R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP5R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep5r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP5R_STAT_RX);
}
inline void usb_fs_device_ep5r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP5R_EP_TYPE);
}
inline void usb_fs_device_ep5r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP5R_STAT_TX);
}
inline void usb_fs_device_ep5r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP5R = (p->EP5R & ~USB_FS_DEVICE_EP5R_EA) | ((val << 0) & USB_FS_DEVICE_EP5R_EA);
}
inline uint32_t usb_fs_device_ep5r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep5r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep5r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep5r_get_ea(struct USB_FS_device_Type* p) { return (p->EP5R & USB_FS_DEVICE_EP5R_EA) >> 0; }

// USB_FS_device->EP6R USB endpoint n register
enum {
	USB_FS_DEVICE_EP6R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP6R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP6R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP6R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP6R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP6R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP6R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP6R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP6R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP6R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep6r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP6R_STAT_RX);
}
inline void usb_fs_device_ep6r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP6R_EP_TYPE);
}
inline void usb_fs_device_ep6r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP6R_STAT_TX);
}
inline void usb_fs_device_ep6r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP6R = (p->EP6R & ~USB_FS_DEVICE_EP6R_EA) | ((val << 0) & USB_FS_DEVICE_EP6R_EA);
}
inline uint32_t usb_fs_device_ep6r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep6r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep6r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep6r_get_ea(struct USB_FS_device_Type* p) { return (p->EP6R & USB_FS_DEVICE_EP6R_EA) >> 0; }

// USB_FS_device->EP7R USB endpoint n register
enum {
	USB_FS_DEVICE_EP7R_CTR_RX  = 1UL << 15,              // CTR_RX
	USB_FS_DEVICE_EP7R_DTOG_RX = 1UL << 14,              // DTOG_RX
	USB_FS_DEVICE_EP7R_STAT_RX = ((1UL << 2) - 1) << 12, // STAT_RX
	USB_FS_DEVICE_EP7R_SETUP   = 1UL << 11,              // SETUP
	USB_FS_DEVICE_EP7R_EP_TYPE = ((1UL << 2) - 1) << 9,  // EP_TYPE
	USB_FS_DEVICE_EP7R_EP_KIND = 1UL << 8,               // EP_KIND
	USB_FS_DEVICE_EP7R_CTR_TX  = 1UL << 7,               // CTR_TX
	USB_FS_DEVICE_EP7R_DTOG_TX = 1UL << 6,               // DTOG_TX
	USB_FS_DEVICE_EP7R_STAT_TX = ((1UL << 2) - 1) << 4,  // STAT_TX
	USB_FS_DEVICE_EP7R_EA      = ((1UL << 4) - 1) << 0,  // EA
};
inline void usb_fs_device_ep7r_set_stat_rx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_STAT_RX) | ((val << 12) & USB_FS_DEVICE_EP7R_STAT_RX);
}
inline void usb_fs_device_ep7r_set_ep_type(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_EP_TYPE) | ((val << 9) & USB_FS_DEVICE_EP7R_EP_TYPE);
}
inline void usb_fs_device_ep7r_set_stat_tx(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_STAT_TX) | ((val << 4) & USB_FS_DEVICE_EP7R_STAT_TX);
}
inline void usb_fs_device_ep7r_set_ea(struct USB_FS_device_Type* p, uint32_t val) {
	p->EP7R = (p->EP7R & ~USB_FS_DEVICE_EP7R_EA) | ((val << 0) & USB_FS_DEVICE_EP7R_EA);
}
inline uint32_t usb_fs_device_ep7r_get_stat_rx(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_STAT_RX) >> 12; }
inline uint32_t usb_fs_device_ep7r_get_ep_type(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_EP_TYPE) >> 9; }
inline uint32_t usb_fs_device_ep7r_get_stat_tx(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_STAT_TX) >> 4; }
inline uint32_t usb_fs_device_ep7r_get_ea(struct USB_FS_device_Type* p) { return (p->EP7R & USB_FS_DEVICE_EP7R_EA) >> 0; }

// USB_FS_device->CNTR USB control register
enum {
	USB_FS_DEVICE_CNTR_CTRM     = 1UL << 15, // CTRM
	USB_FS_DEVICE_CNTR_PMAOVRM  = 1UL << 14, // PMAOVRM
	USB_FS_DEVICE_CNTR_ERRM     = 1UL << 13, // ERRM
	USB_FS_DEVICE_CNTR_WKUPM    = 1UL << 12, // WKUPM
	USB_FS_DEVICE_CNTR_SUSPM    = 1UL << 11, // SUSPM
	USB_FS_DEVICE_CNTR_RESETM   = 1UL << 10, // RESETM
	USB_FS_DEVICE_CNTR_SOFM     = 1UL << 9,  // SOFM
	USB_FS_DEVICE_CNTR_ESOFM    = 1UL << 8,  // ESOFM
	USB_FS_DEVICE_CNTR_L1REQM   = 1UL << 7,  // L1REQM
	USB_FS_DEVICE_CNTR_L1RESUME = 1UL << 5,  // L1RESUME
	USB_FS_DEVICE_CNTR_RESUME   = 1UL << 4,  // RESUME
	USB_FS_DEVICE_CNTR_FSUSP    = 1UL << 3,  // FSUSP
	USB_FS_DEVICE_CNTR_LP_MODE  = 1UL << 2,  // LP_MODE
	USB_FS_DEVICE_CNTR_PDWN     = 1UL << 1,  // PDWN
	USB_FS_DEVICE_CNTR_FRES     = 1UL << 0,  // FRES
};

// USB_FS_device->ISTR USB interrupt status register
enum {
	USB_FS_DEVICE_ISTR_CTR    = 1UL << 15,             // CTR
	USB_FS_DEVICE_ISTR_PMAOVR = 1UL << 14,             // PMAOVR
	USB_FS_DEVICE_ISTR_ERR    = 1UL << 13,             // ERR
	USB_FS_DEVICE_ISTR_WKUP   = 1UL << 12,             // WKUP
	USB_FS_DEVICE_ISTR_SUSP   = 1UL << 11,             // SUSP
	USB_FS_DEVICE_ISTR_RESET  = 1UL << 10,             // RESET
	USB_FS_DEVICE_ISTR_SOF    = 1UL << 9,              // SOF
	USB_FS_DEVICE_ISTR_ESOF   = 1UL << 8,              // ESOF
	USB_FS_DEVICE_ISTR_L1REQ  = 1UL << 7,              // L1REQ
	USB_FS_DEVICE_ISTR_DIR    = 1UL << 4,              // DIR
	USB_FS_DEVICE_ISTR_EP_ID  = ((1UL << 4) - 1) << 0, // EP_ID
};
inline void usb_fs_device_istr_set_ep_id(struct USB_FS_device_Type* p, uint32_t val) {
	p->ISTR = (p->ISTR & ~USB_FS_DEVICE_ISTR_EP_ID) | ((val << 0) & USB_FS_DEVICE_ISTR_EP_ID);
}
inline uint32_t usb_fs_device_istr_get_ep_id(struct USB_FS_device_Type* p) { return (p->ISTR & USB_FS_DEVICE_ISTR_EP_ID) >> 0; }

// USB_FS_device->FNR USB frame number register
enum {
	USB_FS_DEVICE_FNR_RXDP = 1UL << 15,              // RXDP
	USB_FS_DEVICE_FNR_RXDM = 1UL << 14,              // RXDM
	USB_FS_DEVICE_FNR_LCK  = 1UL << 13,              // LCK
	USB_FS_DEVICE_FNR_LSOF = ((1UL << 2) - 1) << 11, // LSOF
	USB_FS_DEVICE_FNR_FN   = ((1UL << 11) - 1) << 0, // FN
};
inline uint32_t usb_fs_device_fnr_get_lsof(struct USB_FS_device_Type* p) { return (p->FNR & USB_FS_DEVICE_FNR_LSOF) >> 11; }
inline uint32_t usb_fs_device_fnr_get_fn(struct USB_FS_device_Type* p) { return (p->FNR & USB_FS_DEVICE_FNR_FN) >> 0; }

// USB_FS_device->DADDR USB device address
enum {
	USB_FS_DEVICE_DADDR_EF  = 1UL << 7,              // EF
	USB_FS_DEVICE_DADDR_ADD = ((1UL << 7) - 1) << 0, // ADD
};
inline void usb_fs_device_daddr_set_add(struct USB_FS_device_Type* p, uint32_t val) {
	p->DADDR = (p->DADDR & ~USB_FS_DEVICE_DADDR_ADD) | ((val << 0) & USB_FS_DEVICE_DADDR_ADD);
}
inline uint32_t usb_fs_device_daddr_get_add(struct USB_FS_device_Type* p) { return (p->DADDR & USB_FS_DEVICE_DADDR_ADD) >> 0; }

// USB_FS_device->BTABLE Buffer table address
enum {
	USB_FS_DEVICE_BTABLE_BTABLE = ((1UL << 13) - 1) << 3, // BTABLE
};
inline void usb_fs_device_btable_set_btable(struct USB_FS_device_Type* p, uint32_t val) {
	p->BTABLE = (p->BTABLE & ~USB_FS_DEVICE_BTABLE_BTABLE) | ((val << 3) & USB_FS_DEVICE_BTABLE_BTABLE);
}
inline uint32_t usb_fs_device_btable_get_btable(struct USB_FS_device_Type* p) { return (p->BTABLE & USB_FS_DEVICE_BTABLE_BTABLE) >> 3; }

/* Voltage reference buffer */
struct VREFBUF_Type {
	__IO uint8_t VREFBUF_CSR;  // @0 VREF_BUF Control and Status Register
	uint8_t      RESERVED0[3]; // @1
	__IO uint8_t VREFBUF_CCR;  // @4 VREF_BUF Calibration Control Register
};

// VREFBUF->VREFBUF_CSR VREF_BUF Control and Status Register
enum {
	VREFBUF_VREFBUF_CSR_VRS  = ((1UL << 2) - 1) << 4, // Voltage reference scale
	VREFBUF_VREFBUF_CSR_VRR  = 1UL << 3,              // Voltage reference buffer ready
	VREFBUF_VREFBUF_CSR_HIZ  = 1UL << 1,              // High impedence mode for the VREF_BUF
	VREFBUF_VREFBUF_CSR_ENVR = 1UL << 0,              // Enable Voltage Reference
};
inline void vrefbuf_vrefbuf_csr_set_vrs(struct VREFBUF_Type* p, uint32_t val) {
	p->VREFBUF_CSR = (p->VREFBUF_CSR & ~VREFBUF_VREFBUF_CSR_VRS) | ((val << 4) & VREFBUF_VREFBUF_CSR_VRS);
}
inline uint32_t vrefbuf_vrefbuf_csr_get_vrs(struct VREFBUF_Type* p) { return (p->VREFBUF_CSR & VREFBUF_VREFBUF_CSR_VRS) >> 4; }

// VREFBUF->VREFBUF_CCR VREF_BUF Calibration Control Register
enum {
	VREFBUF_VREFBUF_CCR_TRIM = ((1UL << 6) - 1) << 0, // Trimming code
};
inline void vrefbuf_vrefbuf_ccr_set_trim(struct VREFBUF_Type* p, uint32_t val) {
	p->VREFBUF_CCR = (p->VREFBUF_CCR & ~VREFBUF_VREFBUF_CCR_TRIM) | ((val << 0) & VREFBUF_VREFBUF_CCR_TRIM);
}
inline uint32_t vrefbuf_vrefbuf_ccr_get_trim(struct VREFBUF_Type* p) { return (p->VREFBUF_CCR & VREFBUF_VREFBUF_CCR_TRIM) >> 0; }

/* WinWATCHDOG */
struct WWDG_Type {
	__O uint16_t  KR;           // @0 Key register
	uint8_t       RESERVED0[2]; // @2
	__IO uint8_t  PR;           // @4 Prescaler register
	uint8_t       RESERVED1[3]; // @5
	__IO uint16_t RLR;          // @8 Reload register
	uint8_t       RESERVED2[2]; // @10
	__I uint8_t   SR;           // @12 Status register
	uint8_t       RESERVED3[3]; // @13
	__IO uint16_t WINR;         // @16 Window register
};

// WWDG->PR Prescaler register
enum {
	WWDG_PR_PR = ((1UL << 3) - 1) << 0, // Prescaler divider
};
inline void     wwdg_pr_set_pr(struct WWDG_Type* p, uint32_t val) { p->PR = (p->PR & ~WWDG_PR_PR) | ((val << 0) & WWDG_PR_PR); }
inline uint32_t wwdg_pr_get_pr(struct WWDG_Type* p) { return (p->PR & WWDG_PR_PR) >> 0; }

// WWDG->RLR Reload register
enum {
	WWDG_RLR_RL = ((1UL << 12) - 1) << 0, // Watchdog counter reload value
};
inline void     wwdg_rlr_set_rl(struct WWDG_Type* p, uint32_t val) { p->RLR = (p->RLR & ~WWDG_RLR_RL) | ((val << 0) & WWDG_RLR_RL); }
inline uint32_t wwdg_rlr_get_rl(struct WWDG_Type* p) { return (p->RLR & WWDG_RLR_RL) >> 0; }

// WWDG->SR Status register
enum {
	WWDG_SR_WVU = 1UL << 2, // Watchdog counter window value update
	WWDG_SR_RVU = 1UL << 1, // Watchdog counter reload value update
	WWDG_SR_PVU = 1UL << 0, // Watchdog prescaler value update
};

// WWDG->WINR Window register
enum {
	WWDG_WINR_WIN = ((1UL << 12) - 1) << 0, // Watchdog counter window value
};
inline void wwdg_winr_set_win(struct WWDG_Type* p, uint32_t val) { p->WINR = (p->WINR & ~WWDG_WINR_WIN) | ((val << 0) & WWDG_WINR_WIN); }
inline uint32_t wwdg_winr_get_win(struct WWDG_Type* p) { return (p->WINR & WWDG_WINR_WIN) >> 0; }

#undef __I
#undef __O
#undef __IO

struct ADC1_Type          ADC1;          // @0x50000000
struct ADC12_Common_Type  ADC12_Common;  // @0x50000200
struct ADC1_Type          ADC2;          // @0x50000100
struct ADC12_Common_Type  ADC345_Common; // @0x50000700
struct AES_Type           AES;           // @0x50060000
struct COMP_Type          COMP;          // @0x40010200
struct CORDIC_Type        CORDIC;        // @0x40020C00
struct CRC_Type           CRC;           // @0x40023000
struct CRS_Type           CRS;           // @0x40002000
struct DAC1_Type          DAC1;          // @0x50000800
struct DAC1_Type          DAC2;          // @0x50000C00
struct DAC1_Type          DAC3;          // @0x50001000
struct DAC1_Type          DAC4;          // @0x50001400
struct DBGMCU_Type        DBGMCU;        // @0xE0042000
struct DMA1_Type          DMA1;          // @0x40020000
struct DMA1_Type          DMA2;          // @0x40020400
struct DMAMUX_Type        DMAMUX;        // @0x40020800
struct EXTI_Type          EXTI;          // @0x40010400
struct FDCAN_Type         FDCAN;         // @0x4000A400
struct FDCAN_Type         FDCAN1;        // @0x40006400
struct FLASH_Type         FLASH;         // @0x40022000
struct FMAC_Type          FMAC;          // @0x40021400
struct FPU_Type           FPU;           // @0xE000EF34
struct FPU_CPACR_Type     FPU_CPACR;     // @0xE000EF08
struct GPIOA_Type         GPIOA;         // @0x48000000
struct GPIOA_Type         GPIOB;         // @0x48000400
struct GPIOA_Type         GPIOC;         // @0x48000800
struct GPIOA_Type         GPIOD;         // @0x48000C00
struct GPIOA_Type         GPIOE;         // @0x48001000
struct GPIOA_Type         GPIOF;         // @0x48001400
struct GPIOA_Type         GPIOG;         // @0x48001800
struct I2C1_Type          I2C1;          // @0x40005400
struct I2C1_Type          I2C2;          // @0x40005800
struct I2C1_Type          I2C3;          // @0x40007800
struct IWDG_Type          IWDG;          // @0x40003000
struct LPTIMER1_Type      LPTIMER1;      // @0x40007C00
struct LPUART1_Type       LPUART1;       // @0x40008000
struct MPU_Type           MPU;           // @0xE000E084
struct NVIC_Type          NVIC;          // @0xE000E100
struct OPAMP_Type         OPAMP;         // @0x40010300
struct PWR_Type           PWR;           // @0x40007000
struct RCC_Type           RCC;           // @0x40021000
struct RNG_Type           RNG;           // @0x50060800
struct RTC_Type           RTC;           // @0x40002800
struct SAI_Type           SAI;           // @0x40015400
struct SCB_Type           SCB;           // @0xE000E040
struct SCB_ACTRL_Type     SCB_ACTRL;     // @0xE000E008
struct SPI1_Type          SPI1;          // @0x40013000
struct SPI1_Type          SPI2;          // @0x40003800
struct SPI1_Type          SPI3;          // @0x40003C00
struct STK_Type           STK;           // @0xE000E010
struct SYSCFG_Type        SYSCFG;        // @0x40010000
struct TAMP_Type          TAMP;          // @0x40002400
struct TIM1_Type          TIM1;          // @0x40012C00 Also: TIM6_Type
struct TIM15_Type         TIM15;         // @0x40014000 Also: TIM16_Type TIM6_Type
struct TIM16_Type         TIM16;         // @0x40014400
struct TIM16_Type         TIM17;         // @0x40014800
struct TIM1_Type          TIM2;          // @0x40000000
struct TIM1_Type          TIM3;          // @0x40000400
struct TIM1_Type          TIM4;          // @0x40000800
struct TIM6_Type          TIM6;          // @0x40001000
struct TIM6_Type          TIM7;          // @0x40001400
struct TIM1_Type          TIM8;          // @0x40013400
struct USART_Type         UART4;         // @0x40004C00
struct UCPD1_Type         UCPD1;         // @0x4000A000
struct USART_Type         USART1;        // @0x40013800
struct USART_Type         USART2;        // @0x40004400
struct USART_Type         USART3;        // @0x40004800
struct USB_FS_device_Type USB_FS_device; // @0x40005C00
struct VREFBUF_Type       VREFBUF;       // @0x40010030
struct WWDG_Type          WWDG;          // @0x40002C00
